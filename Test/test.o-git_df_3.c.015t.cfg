
;; Function xrealloc (xrealloc, funcdef_no=26, decl_uid=3195, cgraph_uid=27, symbol_order=27)

Merging blocks 9 and 10
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9
;; 2 succs { 3 4 }
;; 3 succs { 4 }
;; 4 succs { 5 9 }
;; 5 succs { 6 7 }
;; 6 succs { 7 }
;; 7 succs { 8 9 }
;; 8 succs { }
;; 9 succs { 1 }
void * xrealloc (void * ptr, size_t size)
{
  void * ret;
  void * D.3499;

  <bb 2> :
  ret = realloc (ptr, size);
  _1 = ret == 0B;
  _2 = size == 0;
  _3 = _1 & _2;
  if (_3 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  ret = realloc (ptr, 1);

  <bb 4> :
  if (ret == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 5> :
  ret = realloc (ptr, size);
  _4 = ret == 0B;
  _5 = size == 0;
  _6 = _4 & _5;
  if (_6 != 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  ret = realloc (ptr, 1);

  <bb 7> :
  if (ret == 0B)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  printf ("Out of memory, realloc failed%s", "");
  exit (1);

  <bb 9> :
  D.3499 = ret;
  return D.3499;

}



;; Function strbuf_grow (strbuf_grow, funcdef_no=27, decl_uid=3327, cgraph_uid=28, symbol_order=79)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11
;; 2 succs { 3 4 }
;; 3 succs { }
;; 4 succs { 5 6 }
;; 5 succs { 6 }
;; 6 succs { 7 11 }
;; 7 succs { 8 9 }
;; 8 succs { 10 }
;; 9 succs { 10 }
;; 10 succs { 11 }
;; 11 succs { 1 }
void strbuf_grow (struct strbuf * sb, size_t extra)
{
  <bb 2> :
  _1 = sb->len;
  _2 = extra + _1;
  _3 = _2 + 1;
  _4 = sb->len;
  if (_3 <= _4)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  printf ("you want to use way too much memory%s", "");
  exit (1);

  <bb 4> :
  _5 = sb->alloc;
  if (_5 == 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  sb->buf = 0B;

  <bb 6> :
  _6 = sb->len;
  _7 = extra + _6;
  _8 = _7 + 1;
  _9 = sb->alloc;
  if (_8 > _9)
    goto <bb 7>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 7> :
  _10 = sb->alloc;
  _11 = alloc_nr (_10);
  _12 = (long unsigned int) _11;
  _13 = sb->len;
  _14 = extra + _13;
  _15 = _14 + 1;
  if (_12 < _15)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  _16 = sb->len;
  _17 = extra + _16;
  _18 = _17 + 1;
  sb->alloc = _18;
  goto <bb 10>; [INV]

  <bb 9> :
  _19 = sb->alloc;
  _20 = alloc_nr (_19);
  _21 = (long unsigned int) _20;
  sb->alloc = _21;

  <bb 10> :
  _22 = sb->alloc;
  _23 = st_mult (1, _22);
  _24 = (long unsigned int) _23;
  _25 = sb->buf;
  _26 = xrealloc (_25, _24);
  sb->buf = _26;

  <bb 11> :
  return;

}



;; Function strbuf_init (strbuf_init, funcdef_no=28, decl_uid=3336, cgraph_uid=29, symbol_order=80)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4
;; 2 succs { 3 4 }
;; 3 succs { 4 }
;; 4 succs { 1 }
void strbuf_init (struct strbuf * sb, size_t hint)
{
  <bb 2> :
  sb->len = 0;
  _1 = sb->len;
  sb->alloc = _1;
  sb->buf = &strbuf_slopbuf;
  if (hint != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  strbuf_grow (sb, hint);

  <bb 4> :
  return;

}



;; Function strbuf_detach (strbuf_detach, funcdef_no=29, decl_uid=3340, cgraph_uid=30, symbol_order=81)

Merging blocks 7 and 8
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7
;; 2 succs { 3 4 }
;; 3 succs { 5 }
;; 4 succs { 5 }
;; 5 succs { 6 7 }
;; 6 succs { 7 }
;; 7 succs { 1 }
char * strbuf_detach (struct strbuf * sb, size_t * sz)
{
  char * res;
  char * D.3518;
  char * iftmp.0;

  <bb 2> :
  _1 = sb->alloc;
  if (_1 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  iftmp.0 = sb->buf;
  goto <bb 5>; [INV]

  <bb 4> :
  iftmp.0 = 0B;

  <bb 5> :
  res = iftmp.0;
  if (sz != 0B)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  _2 = sb->len;
  *sz = _2;

  <bb 7> :
  strbuf_init (sb, 0);
  D.3518 = res;
  return D.3518;

}



;; Function strbuf_add (strbuf_add, funcdef_no=30, decl_uid=3346, cgraph_uid=31, symbol_order=82)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
void strbuf_add (struct strbuf * sb, const void * data, size_t len)
{
  <bb 2> :
  strbuf_grow (sb, len);
  _1 = sb->buf;
  _2 = sb->len;
  _3 = _1 + _2;
  memcpy (_3, data, len);
  _4 = sb->len;
  _5 = len + _4;
  strbuf_setlen (sb, _5);
  return;

}



;; Function strbuf_getline (strbuf_getline, funcdef_no=34, decl_uid=3369, cgraph_uid=35, symbol_order=86)

;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12
;;
;; Loop 1
;;  header 7, latch 6
;;  depth 1, outer 0
;;  nodes: 7 6 5
;; 2 succs { 3 4 }
;; 3 succs { 12 }
;; 4 succs { 7 }
;; 5 succs { 8 6 }
;; 6 succs { 7 }
;; 7 succs { 5 8 }
;; 8 succs { 9 11 }
;; 9 succs { 10 11 }
;; 10 succs { 12 }
;; 11 succs { 12 }
;; 12 succs { 1 }
int strbuf_getline (struct strbuf * sb, struct FILE * fp, int term)
{
  int ch;
  int D.3522;

  <bb 2> :
  strbuf_grow (sb, 0);
  _1 = feof (fp);
  if (_1 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  D.3522 = -1;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 12>; [INV]

  <bb 4> :
  strbuf_setlen (sb, 0);
  goto <bb 7>; [INV]

  <bb 5> :
  if (ch == term)
    goto <bb 8>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 6> :
  strbuf_grow (sb, 1);
  _2 = sb->buf;
  _3 = sb->len;
  _4 = _3;
  _5 = _4 + 1;
  sb->len = _5;
  _6 = _2 + _4;
  _7 = (char) ch;
  *_6 = _7;

  <bb 7> :
  ch = fgetc (fp);
  if (ch != -1)
    goto <bb 5>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 8> :
  if (ch == -1)
    goto <bb 9>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 9> :
  _8 = sb->len;
  if (_8 == 0)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  D.3522 = -1;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 12>; [INV]

  <bb 11> :
  _9 = sb->buf;
  _10 = sb->len;
  _11 = _9 + _10;
  *_11 = 0;
  D.3522 = 0;

  <bb 12> :
  return D.3522;

}



;; Function strbuf_setlen (strbuf_setlen, funcdef_no=31, decl_uid=3353, cgraph_uid=32, symbol_order=83)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4
;; 2 succs { 3 4 }
;; 3 succs { 4 }
;; 4 succs { 1 }
void strbuf_setlen (struct strbuf * sb, size_t len)
{
  <bb 2> :
  _1 = sb->alloc;
  if (_1 == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  strbuf_grow (sb, 0);

  <bb 4> :
  _2 = sb->alloc;
  _3 = len < _2;
  _4 = (int) _3;
  assert (_4);
  sb->len = len;
  _5 = sb->buf;
  _6 = _5 + len;
  *_6 = 0;
  return;

}



;; Function main (main, funcdef_no=40, decl_uid=3473, cgraph_uid=41, symbol_order=92)

Removing basic block 15
Merging blocks 14 and 16
;; 3 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14
;;
;; Loop 2
;;  header 13, multiple latches: 7 9 11
;;  depth 1, outer 0
;;  nodes: 13 7 9 11 10 8 6
;;
;; Loop 1
;;  header 4, latch 3
;;  depth 1, outer 0
;;  nodes: 4 3
;; 2 succs { 4 }
;; 3 succs { 4 }
;; 4 succs { 3 5 }
;; 5 succs { 13 }
;; 6 succs { 7 8 }
;; 7 succs { 13 }
;; 8 succs { 9 10 }
;; 9 succs { 13 }
;; 10 succs { 11 12 }
;; 11 succs { 13 }
;; 12 succs { }
;; 13 succs { 6 14 }
;; 14 succs { 1 }
int main (int argc, const char * * argv)
{
  unsigned int show_stats;
  unsigned int i;
  int D.3540;

  <bb 2> :
  show_stats = 1;
  strbuf_init (&command_buf, 0);
  cmd_save.1_1 = cmd_save;
  _2 = (long unsigned int) cmd_save.1_1;
  _3 = _2 * 24;
  _4 = pool_alloc (_3);
  _5 = (long int) _4;
  _6 = (struct recent_command *) _5;
  rc_free = _6;
  i = 0;
  goto <bb 4>; [INV]

  <bb 3> :
  rc_free.2_7 = rc_free;
  _8 = i + 1;
  _9 = (long unsigned int) _8;
  _10 = _9 * 24;
  rc_free.3_11 = rc_free;
  _12 = (long unsigned int) i;
  _13 = _12 * 24;
  _14 = rc_free.3_11 + _13;
  _15 = rc_free.2_7 + _10;
  _14->next = _15;
  i = i + 1;

  <bb 4> :
  cmd_save.4_16 = cmd_save;
  _17 = cmd_save.4_16 + 4294967295;
  if (i < _17)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 5> :
  rc_free.5_18 = rc_free;
  cmd_save.6_19 = cmd_save;
  _20 = cmd_save.6_19 + 4294967295;
  _21 = (long unsigned int) _20;
  _22 = _21 * 24;
  _23 = rc_free.5_18 + _22;
  _23->next = 0B;
  goto <bb 13>; [INV]

  <bb 6> :
  _24 = command_buf.buf;
  _25 = strcmp ("blob", _24);
  if (_25 == 0)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  cmd_new_blob ();
  goto <bb 13>; [INV]

  <bb 8> :
  _26 = command_buf.buf;
  _27 = prefixcmp (_26, "commit ");
  if (_27 == 0)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  cmd_new_commit ();
  goto <bb 13>; [INV]

  <bb 10> :
  _28 = command_buf.buf;
  _29 = prefixcmp (_28, "tag ");
  if (_29 == 0)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  cmd_new_tag ();
  goto <bb 13>; [INV]

  <bb 12> :
  _30 = command_buf.buf;
  printf ("Unsupported command: %s", _30);
  exit (1);

  <bb 13> :
  _31 = read_next_command ();
  if (_31 != -1)
    goto <bb 6>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 14> :
  failure.7_32 = failure;
  _33 = failure.7_32 != 0;
  D.3540 = (int) _33;
  return D.3540;

}



;; Function cmd_new_blob (cmd_new_blob, funcdef_no=37, decl_uid=3391, cgraph_uid=38, symbol_order=89)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
void cmd_new_blob ()
{
  static struct strbuf buf = {.alloc=0, .len=0, .buf=(char *) &strbuf_slopbuf};

  <bb 2> :
  read_next_command ();
  cmd_mark ();
  cmd_data (&buf);
  next_mark.8_1 = next_mark;
  store_object (3, &buf, &last_blob, 0B, next_mark.8_1);
  return;

}



;; Function cmd_mark (cmd_mark, funcdef_no=36, decl_uid=3384, cgraph_uid=37, symbol_order=88)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5
;; 2 succs { 3 4 }
;; 3 succs { 5 }
;; 4 succs { 5 }
;; 5 succs { 1 }
void cmd_mark ()
{
  <bb 2> :
  _1 = command_buf.buf;
  _2 = prefixcmp (_1, "mark :");
  if (_2 == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  _3 = command_buf.buf;
  _4 = _3 + 6;
  _5 = strtoumax (_4, 0B, 10);
  _6 = (long long unsigned int) _5;
  next_mark = _6;
  read_next_command ();
  goto <bb 5>; [INV]

  <bb 4> :
  next_mark = 0;

  <bb 5> :
  return;

}



;; Function cmd_new_commit (cmd_new_commit, funcdef_no=39, decl_uid=3415, cgraph_uid=40, symbol_order=91)

Removing basic block 13
Removing basic block 29
;; 3 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35
;;
;; Loop 2
;;  header 29, latch 28
;;  depth 1, outer 0
;;  nodes: 29 28
;;
;; Loop 1
;;  header 25, latch 24
;;  depth 1, outer 0
;;  nodes: 25 24 14 16 18 20 22 21 19 17 15 13
;; 2 succs { 3 4 }
;; 3 succs { 4 }
;; 4 succs { 5 6 }
;; 5 succs { 6 }
;; 6 succs { 7 8 }
;; 7 succs { 8 }
;; 8 succs { 9 10 }
;; 9 succs { }
;; 10 succs { 12 11 }
;; 11 succs { 12 25 }
;; 12 succs { 25 }
;; 13 succs { 14 15 }
;; 14 succs { 24 }
;; 15 succs { 16 17 }
;; 16 succs { 24 }
;; 17 succs { 18 19 }
;; 18 succs { 24 }
;; 19 succs { 20 21 }
;; 20 succs { 24 }
;; 21 succs { 22 23 }
;; 22 succs { 24 }
;; 23 succs { 26 }
;; 24 succs { 26 25 }
;; 25 succs { 13 26 }
;; 26 succs { 27 29 }
;; 27 succs { 29 }
;; 28 succs { 29 }
;; 29 succs { 28 30 }
;; 30 succs { 31 32 }
;; 31 succs { 33 }
;; 32 succs { 33 }
;; 33 succs { 34 35 }
;; 34 succs { 35 }
;; 35 succs { 1 }
void cmd_new_commit ()
{
  struct hash_list * next;
  unsigned int merge_count;
  struct hash_list * merge_list;
  char * committer;
  char * author;
  char * sp;
  struct branch * b;
  static struct strbuf msg = {.alloc=0, .len=0, .buf=(char *) &strbuf_slopbuf};
  char * iftmp.10;

  <bb 2> :
  author = 0B;
  committer = 0B;
  merge_list = 0B;
  _1 = command_buf.buf;
  _2 = strchr (_1, 32);
  sp = _2 + 1;
  _3 = lookup_branch (sp);
  _4 = (long int) _3;
  b = (struct branch *) _4;
  if (b == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  _5 = new_branch (sp);
  _6 = (long int) _5;
  b = (struct branch *) _6;

  <bb 4> :
  read_next_command ();
  cmd_mark ();
  _7 = command_buf.buf;
  _8 = prefixcmp (_7, "author ");
  if (_8 == 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  _9 = command_buf.buf;
  _10 = _9 + 7;
  _11 = parse_ident (_10);
  _12 = (long int) _11;
  author = (char *) _12;
  read_next_command ();

  <bb 6> :
  _13 = command_buf.buf;
  _14 = prefixcmp (_13, "committer ");
  if (_14 == 0)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  _15 = command_buf.buf;
  _16 = _15 + 10;
  _17 = parse_ident (_16);
  _18 = (long int) _17;
  committer = (char *) _18;
  read_next_command ();

  <bb 8> :
  if (committer == 0B)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  printf ("Expected committer but didn\'t get one%s", "");
  exit (1);

  <bb 10> :
  cmd_data (&msg);
  read_next_command ();
  cmd_from (b);
  _19 = cmd_merge (&merge_count);
  _20 = (long int) _19;
  merge_list = (struct hash_list *) _20;
  _21 = b->branch_tree.tree;
  if (_21 == 0B)
    goto <bb 12>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 11> :
  max_active_branches.9_22 = max_active_branches;
  if (max_active_branches.9_22 == 0)
    goto <bb 12>; [INV]
  else
    goto <bb 25>; [INV]

  <bb 12> :
  unload_one_branch ();
  load_branch (b);
  goto <bb 25>; [INV]

  <bb 13> :
  _23 = command_buf.buf;
  _24 = prefixcmp (_23, "M ");
  if (_24 == 0)
    goto <bb 14>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 14> :
  file_change_m (b);
  goto <bb 24>; [INV]

  <bb 15> :
  _25 = command_buf.buf;
  _26 = prefixcmp (_25, "D ");
  if (_26 == 0)
    goto <bb 16>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 16> :
  file_change_d (b);
  goto <bb 24>; [INV]

  <bb 17> :
  _27 = command_buf.buf;
  _28 = prefixcmp (_27, "R ");
  if (_28 == 0)
    goto <bb 18>; [INV]
  else
    goto <bb 19>; [INV]

  <bb 18> :
  file_change_cr (b, 1);
  goto <bb 24>; [INV]

  <bb 19> :
  _29 = command_buf.buf;
  _30 = prefixcmp (_29, "C ");
  if (_30 == 0)
    goto <bb 20>; [INV]
  else
    goto <bb 21>; [INV]

  <bb 20> :
  file_change_cr (b, 0);
  goto <bb 24>; [INV]

  <bb 21> :
  _31 = command_buf.buf;
  _32 = strcmp ("deleteall", _31);
  if (_32 == 0)
    goto <bb 22>; [INV]
  else
    goto <bb 23>; [INV]

  <bb 22> :
  file_change_deleteall (b);
  goto <bb 24>; [INV]

  <bb 23> :
  unread_command_buf = 1;
  goto <bb 26>; [INV]

  <bb 24> :
  _33 = read_next_command ();
  if (_33 == -1)
    goto <bb 26>; [INV]
  else
    goto <bb 25>; [INV]

  <bb 25> :
  _34 = command_buf.len;
  if (_34 != 0)
    goto <bb 13>; [INV]
  else
    goto <bb 26>; [INV]

  <bb 26> :
  _35 = &b->branch_tree;
  store_tree (_35);
  _36 = &b->branch_tree.versions[1].sha1;
  _37 = &b->branch_tree.versions[0].sha1;
  hashcpy (_37, _36);
  strbuf_setlen (&new_data, 0);
  _38 = &b->branch_tree.versions[1].sha1;
  _39 = sha1_to_hex (_38);
  strbuf_addf (&new_data, "tree %s\n", _39);
  _40 = &b->sha1;
  _41 = is_null_sha1 (_40);
  if (_41 == 0)
    goto <bb 27>; [INV]
  else
    goto <bb 29>; [INV]

  <bb 27> :
  _42 = &b->sha1;
  _43 = sha1_to_hex (_42);
  strbuf_addf (&new_data, "parent %s\n", _43);
  goto <bb 29>; [INV]

  <bb 28> :
  next = merge_list->next;
  _44 = &merge_list->sha1;
  _45 = sha1_to_hex (_44);
  strbuf_addf (&new_data, "parent %s\n", _45);
  free (merge_list);
  merge_list = next;

  <bb 29> :
  if (merge_list != 0B)
    goto <bb 28>; [INV]
  else
    goto <bb 30>; [INV]

  <bb 30> :
  if (author != 0B)
    goto <bb 31>; [INV]
  else
    goto <bb 32>; [INV]

  <bb 31> :
  iftmp.10 = author;
  goto <bb 33>; [INV]

  <bb 32> :
  iftmp.10 = committer;

  <bb 33> :
  strbuf_addf (&new_data, "author %s\ncommitter %s\n\n", iftmp.10, committer);
  strbuf_addbuf (&new_data, &msg);
  free (author);
  free (committer);
  next_mark.11_46 = next_mark;
  _47 = &b->sha1;
  _48 = store_object (1, &new_data, 0B, _47, next_mark.11_46);
  if (_48 == 0)
    goto <bb 34>; [INV]
  else
    goto <bb 35>; [INV]

  <bb 34> :
  pack_id.12_49 = pack_id;
  _50 = (short unsigned int) pack_id.12_49;
  b->pack_id = _50;

  <bb 35> :
  _51 = object_count_by_type[1];
  _52 = (int) _51;
  b->last_commit = _52;
  merge_count = {CLOBBER};
  return;

}



;; Function cmd_data (cmd_data, funcdef_no=38, decl_uid=3399, cgraph_uid=39, symbol_order=90)

;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13
;;
;; Loop 1
;;  header 6, latch 10
;;  depth 1, outer 0
;;  nodes: 6 10 8 9
;; 2 succs { 3 4 }
;; 3 succs { }
;; 4 succs { 5 12 }
;; 5 succs { 6 }
;; 6 succs { 7 8 }
;; 7 succs { }
;; 8 succs { 9 10 }
;; 9 succs { 11 10 }
;; 10 succs { 6 }
;; 11 succs { 13 }
;; 12 succs { 13 }
;; 13 succs { 1 }
void cmd_data (struct strbuf * sb)
{
  size_t length;
  size_t n;
  size_t term_len;
  char * term;

  <bb 2> :
  strbuf_setlen (sb, 0);
  _1 = command_buf.buf;
  _2 = prefixcmp (_1, "data ");
  if (_2 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  _3 = command_buf.buf;
  printf ("Expected \'data n\' command, found: %s", _3);
  exit (1);

  <bb 4> :
  _4 = command_buf.buf;
  _5 = _4 + 5;
  _6 = prefixcmp (_5, "<<");
  if (_6 == 0)
    goto <bb 5>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 5> :
  _7 = command_buf.buf;
  _8 = _7 + 7;
  term = strdup (_8);
  _9 = command_buf.len;
  term_len = _9 + 18446744073709551609;

  <bb 6> :
  stdin.13_10 = stdin;
  _11 = strbuf_getline (&command_buf, stdin.13_10, 10);
  if (_11 == -1)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  printf ("EOF in data (terminator \'%s\' not found)", term);
  exit (1);

  <bb 8> :
  _12 = command_buf.len;
  if (term_len == _12)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  _13 = command_buf.buf;
  _14 = strcmp (term, _13);
  if (_14 == 0)
    goto <bb 11>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 10> :
  strbuf_addbuf (sb, &command_buf);
  strbuf_addch (sb, 10);
  goto <bb 6>; [INV]

  <bb 11> :
  free (term);
  goto <bb 13>; [INV]

  <bb 12> :
  n = 0;
  _15 = command_buf.buf;
  _16 = _15 + 5;
  length = strtoul (_16, 0B, 10);

  <bb 13> :
  return;

}



;; Function strbuf_addbuf (strbuf_addbuf, funcdef_no=33, decl_uid=3364, cgraph_uid=34, symbol_order=85)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
void strbuf_addbuf (struct strbuf * sb, struct strbuf * sb2)
{
  <bb 2> :
  _1 = sb2->len;
  _2 = sb2->buf;
  strbuf_add (sb, _2, _1);
  return;

}



;; Function read_next_command (read_next_command, funcdef_no=35, decl_uid=3376, cgraph_uid=36, symbol_order=87)

;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14
;;
;; Loop 1
;;  header 4, latch 12
;;  depth 1, outer 0
;;  nodes: 4 12 5 11 9 10 8 6
;; 2 succs { 3 4 }
;; 3 succs { 14 }
;; 4 succs { 5 6 }
;; 5 succs { 12 }
;; 6 succs { 7 8 }
;; 7 succs { 14 }
;; 8 succs { 9 10 }
;; 9 succs { 11 }
;; 10 succs { 11 }
;; 11 succs { 12 }
;; 12 succs { 4 13 }
;; 13 succs { 14 }
;; 14 succs { 1 }
int read_next_command ()
{
  struct recent_command * rc;
  static int stdin_eof = 0;
  int D.3592;

  <bb 2> :
  stdin_eof.14_1 = stdin_eof;
  if (stdin_eof.14_1 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  unread_command_buf = 0;
  D.3592 = -1;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 14>; [INV]

  <bb 4> :
  unread_command_buf.15_2 = unread_command_buf;
  if (unread_command_buf.15_2 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  unread_command_buf = 0;
  goto <bb 12>; [INV]

  <bb 6> :
  strbuf_detach (&command_buf, 0B);
  stdin.16_3 = stdin;
  _4 = strbuf_getline (&command_buf, stdin.16_3, 10);
  stdin_eof = _4;
  stdin_eof.17_5 = stdin_eof;
  if (stdin_eof.17_5 != 0)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  D.3592 = -1;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 14>; [INV]

  <bb 8> :
  rc = rc_free;
  if (rc != 0B)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  _6 = rc->next;
  rc_free = _6;
  goto <bb 11>; [INV]

  <bb 10> :
  rc = cmd_hist.next;
  _7 = rc->next;
  cmd_hist.next = _7;
  _8 = cmd_hist.next;
  _8->prev = &cmd_hist;
  _9 = rc->buf;
  free (_9);

  <bb 11> :
  _10 = command_buf.buf;
  rc->buf = _10;
  cmd_tail.18_11 = cmd_tail;
  rc->prev = cmd_tail.18_11;
  _12 = cmd_hist.prev;
  rc->next = _12;
  _13 = rc->prev;
  _13->next = rc;
  cmd_tail = rc;

  <bb 12> :
  _14 = command_buf.buf;
  _15 = *_14;
  if (_15 == 35)
    goto <bb 4>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 13> :
  D.3592 = 0;

  <bb 14> :
  return D.3592;

}


