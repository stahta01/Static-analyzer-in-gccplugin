
;; Function getchar (null)
;; enabled by -tree-original


{
  return getc (stdin);
}


;; Function fgetc_unlocked (null)
;; enabled by -tree-original


{
  return __builtin_expect (__fp->_IO_read_ptr >= __fp->_IO_read_end, 0) != 0 ? __uflow (__fp) : (int) *(unsigned char *) __fp->_IO_read_ptr++ ;
}


;; Function getc_unlocked (null)
;; enabled by -tree-original


{
  return __builtin_expect (__fp->_IO_read_ptr >= __fp->_IO_read_end, 0) != 0 ? __uflow (__fp) : (int) *(unsigned char *) __fp->_IO_read_ptr++ ;
}


;; Function getchar_unlocked (null)
;; enabled by -tree-original


{
  return __builtin_expect (stdin->_IO_read_ptr >= stdin->_IO_read_end, 0) != 0 ? __uflow (stdin) : (int) *(unsigned char *) stdin->_IO_read_ptr++ ;
}


;; Function putchar (null)
;; enabled by -tree-original


{
  return putc (__c, stdout);
}


;; Function fputc_unlocked (null)
;; enabled by -tree-original


{
  return __builtin_expect (__stream->_IO_write_ptr >= __stream->_IO_write_end, 0) != 0 ? __overflow (__stream, (int) (unsigned char) __c) : (int) (unsigned char) (*__stream->_IO_write_ptr++  = (char) __c);
}


;; Function putc_unlocked (null)
;; enabled by -tree-original


{
  return __builtin_expect (__stream->_IO_write_ptr >= __stream->_IO_write_end, 0) != 0 ? __overflow (__stream, (int) (unsigned char) __c) : (int) (unsigned char) (*__stream->_IO_write_ptr++  = (char) __c);
}


;; Function putchar_unlocked (null)
;; enabled by -tree-original


{
  return __builtin_expect (stdout->_IO_write_ptr >= stdout->_IO_write_end, 0) != 0 ? __overflow (stdout, (int) (unsigned char) __c) : (int) (unsigned char) (*stdout->_IO_write_ptr++  = (char) __c);
}


;; Function feof_unlocked (null)
;; enabled by -tree-original


{
  return (__stream->_flags & 16) != 0;
}


;; Function ferror_unlocked (null)
;; enabled by -tree-original


{
  return (__stream->_flags & 32) != 0;
}


;; Function sprintf (null)
;; enabled by -tree-original


{
  return __builtin___sprintf_chk (__s, 1, __builtin_object_size ((const void *) __s, 1), __fmt, __builtin_va_arg_pack ());
}


;; Function vsprintf (null)
;; enabled by -tree-original


{
  return __builtin___vsprintf_chk (__s, 1, __builtin_object_size ((const void *) __s, 1), __fmt, __ap);
}


;; Function snprintf (null)
;; enabled by -tree-original


{
  return __builtin___snprintf_chk (__s, __n, 1, __builtin_object_size ((const void *) __s, 1), __fmt, __builtin_va_arg_pack ());
}


;; Function vsnprintf (null)
;; enabled by -tree-original


{
  return __builtin___vsnprintf_chk (__s, __n, 1, __builtin_object_size ((const void *) __s, 1), __fmt, __ap);
}


;; Function fprintf (null)
;; enabled by -tree-original


{
  return __fprintf_chk (__stream, 1, __fmt, __builtin_va_arg_pack ());
}


;; Function printf (null)
;; enabled by -tree-original


{
  return __printf_chk (1, __fmt, __builtin_va_arg_pack ());
}


;; Function vprintf (null)
;; enabled by -tree-original


{
  return __vfprintf_chk (stdout, 1, __fmt, __ap);
}


;; Function vfprintf (null)
;; enabled by -tree-original


{
  return __vfprintf_chk (__stream, 1, __fmt, __ap);
}


;; Function dprintf (null)
;; enabled by -tree-original


{
  return __dprintf_chk (__fd, 1, __fmt, __builtin_va_arg_pack ());
}


;; Function vdprintf (null)
;; enabled by -tree-original


{
  return __vdprintf_chk (__fd, 1, __fmt, __ap);
}


;; Function fgets (null)
;; enabled by -tree-original


{
  if (__builtin_object_size ((const void *) __s, 1) != 18446744073709551615)
    {
      if (__builtin_constant_p (__n) == 0 || __n <= 0)
        {
          return __fgets_chk (__s, __builtin_object_size ((const void *) __s, 1), __n, __stream);
        }
      if ((long unsigned int) __n > __builtin_object_size ((const void *) __s, 1))
        {
          return __fgets_chk_warn (__s, __builtin_object_size ((const void *) __s, 1), __n, __stream);
        }
    }
  return __fgets_alias (__s, __n, __stream);
}


;; Function fread (null)
;; enabled by -tree-original


{
  if (__builtin_object_size ((const void *) __ptr, 0) != 18446744073709551615)
    {
      if ((__builtin_constant_p (__size) == 0 || __builtin_constant_p (__n) == 0) || (__size | __n) > 4294967295)
        {
          return __fread_chk (__ptr, __builtin_object_size ((const void *) __ptr, 0), __size, __n, __stream);
        }
      if ((long unsigned int) (__size * __n) > __builtin_object_size ((const void *) __ptr, 0))
        {
          return __fread_chk_warn (__ptr, __builtin_object_size ((const void *) __ptr, 0), __size, __n, __stream);
        }
    }
  return __fread_alias (__ptr, __size, __n, __stream);
}


;; Function fread_unlocked (null)
;; enabled by -tree-original


{
  if (__builtin_object_size ((const void *) __ptr, 0) != 18446744073709551615)
    {
      if ((__builtin_constant_p (__size) == 0 || __builtin_constant_p (__n) == 0) || (__size | __n) > 4294967295)
        {
          return __fread_unlocked_chk (__ptr, __builtin_object_size ((const void *) __ptr, 0), __size, __n, __stream);
        }
      if ((long unsigned int) (__size * __n) > __builtin_object_size ((const void *) __ptr, 0))
        {
          return __fread_unlocked_chk_warn (__ptr, __builtin_object_size ((const void *) __ptr, 0), __size, __n, __stream);
        }
    }
  if (((__builtin_constant_p (__size) != 0 && __builtin_constant_p (__n) != 0) && (__size | __n) <= 4294967295) && __size * __n <= 8)
    {
      {
        size_t __cnt = __size * __n;
        char * __cptr = (char *) __ptr;

                size_t __cnt = __size * __n;
                char * __cptr = (char *) __ptr;
        if (__cnt == 0)
          {
            return 0;
          }
        goto <D.2377>;
        <D.2376>:;
        {
          int __c = getc_unlocked (__stream);

                    int __c = getc_unlocked (__stream);
          if (__c == -1)
            {
              goto <D.2375>;
            }
          *__cptr++  = (char) __c;
        }
         --__cnt;
        <D.2377>:;
        if (__cnt != 0) goto <D.2376>; else goto <D.2375>;
        <D.2375>:;
        return (size_t) ((long unsigned int) ((long int) __cptr - (long int) __ptr) / (long unsigned int) __size);
      }
    }
  return __fread_unlocked_alias (__ptr, __size, __n, __stream);
}


;; Function atoi (null)
;; enabled by -tree-original


{
  return (int) strtol (__nptr, 0B, 10);
}


;; Function atol (null)
;; enabled by -tree-original


{
  return strtol (__nptr, 0B, 10);
}


;; Function atoll (null)
;; enabled by -tree-original


{
  return strtoll (__nptr, 0B, 10);
}


;; Function __bswap_16 (null)
;; enabled by -tree-original


{
  return (__uint16_t) __builtin_bswap16 ((int) __bsx);
}


;; Function __bswap_32 (null)
;; enabled by -tree-original


{
  return (__uint32_t) __builtin_bswap32 (__bsx);
}


;; Function __bswap_64 (null)
;; enabled by -tree-original


{
  return (__uint64_t) __builtin_bswap64 (__bsx);
}


;; Function __uint16_identity (null)
;; enabled by -tree-original


{
  return __x;
}


;; Function __uint32_identity (null)
;; enabled by -tree-original


{
  return __x;
}


;; Function __uint64_identity (null)
;; enabled by -tree-original


{
  return __x;
}


;; Function bsearch (null)
;; enabled by -tree-original


{
  size_t __l;
  size_t __u;
  size_t __idx;
  const void * __p;
  int __comparison;

    size_t __l;
    size_t __u;
    size_t __idx;
    const void * __p;
    int __comparison;
  __l = 0;
  __u = __nmemb;
  goto <D.2818>;
  <D.2817>:;
  __idx = (__l + __u) / 2;
  __p = __base + (sizetype) (__idx * __size);
  __comparison = __compar (__key, __p);
  if (__comparison < 0)
    {
      __u = __idx;
    }
  else
    {
      if (__comparison > 0)
        {
          __l = __idx + 1;
        }
      else
        {
          return (void *) __p;
        }
    }
  <D.2818>:;
  if (__l < __u) goto <D.2817>; else goto <D.2819>;
  <D.2819>:;
  return 0B;
}


;; Function atof (null)
;; enabled by -tree-original


{
  return strtod (__nptr, 0B);
}


;; Function realpath (null)
;; enabled by -tree-original


{
  if (__builtin_object_size ((const void *) __resolved, 1) != 18446744073709551615)
    {
      return __realpath_chk (__name, __resolved, __builtin_object_size ((const void *) __resolved, 1));
    }
  return __realpath_alias (__name, __resolved);
}


;; Function ptsname_r (null)
;; enabled by -tree-original


{
  if (__builtin_object_size ((const void *) __buf, 1) != 18446744073709551615)
    {
      if (__builtin_constant_p (__buflen) == 0)
        {
          return __ptsname_r_chk (__fd, __buf, __buflen, __builtin_object_size ((const void *) __buf, 1));
        }
      if (__builtin_object_size ((const void *) __buf, 1) < (long unsigned int) __buflen)
        {
          return __ptsname_r_chk_warn (__fd, __buf, __buflen, __builtin_object_size ((const void *) __buf, 1));
        }
    }
  return __ptsname_r_alias (__fd, __buf, __buflen);
}


;; Function wctomb (null)
;; enabled by -tree-original


{
  if (__builtin_object_size ((const void *) __s, 1) != 18446744073709551615 && __builtin_object_size ((const void *) __s, 1) <= 15)
    {
      return __wctomb_chk (__s, __wchar, __builtin_object_size ((const void *) __s, 1));
    }
  return __wctomb_alias (__s, __wchar);
}


;; Function mbstowcs (null)
;; enabled by -tree-original


{
  if (__builtin_object_size ((const void *) __dst, 1) != 18446744073709551615)
    {
      if (__builtin_constant_p (__len) == 0)
        {
          return __mbstowcs_chk (__dst, __src, __len, __builtin_object_size ((const void *) __dst, 1) / 4);
        }
      if (__builtin_object_size ((const void *) __dst, 1) / 4 < (long unsigned int) __len)
        {
          return __mbstowcs_chk_warn (__dst, __src, __len, __builtin_object_size ((const void *) __dst, 1) / 4);
        }
    }
  return __mbstowcs_alias (__dst, __src, __len);
}


;; Function wcstombs (null)
;; enabled by -tree-original


{
  if (__builtin_object_size ((const void *) __dst, 1) != 18446744073709551615)
    {
      if (__builtin_constant_p (__len) == 0)
        {
          return __wcstombs_chk (__dst, __src, __len, __builtin_object_size ((const void *) __dst, 1));
        }
      if (__builtin_object_size ((const void *) __dst, 1) < (long unsigned int) __len)
        {
          return __wcstombs_chk_warn (__dst, __src, __len, __builtin_object_size ((const void *) __dst, 1));
        }
    }
  return __wcstombs_alias (__dst, __src, __len);
}


;; Function bcopy (null)
;; enabled by -tree-original


{
  (void) __builtin___memmove_chk (__dest, __src, __len, __builtin_object_size ((const void *) __dest, 0));
}


;; Function bzero (null)
;; enabled by -tree-original


{
  (void) __builtin___memset_chk (__dest, 0, __len, __builtin_object_size ((const void *) __dest, 0));
}


;; Function memcpy (null)
;; enabled by -tree-original


{
  return __builtin___memcpy_chk (__dest, __src, __len, __builtin_object_size ((const void *) __dest, 0));
}


;; Function memmove (null)
;; enabled by -tree-original


{
  return __builtin___memmove_chk (__dest, __src, __len, __builtin_object_size ((const void *) __dest, 0));
}


;; Function memset (null)
;; enabled by -tree-original


{
  return __builtin___memset_chk (__dest, __ch, __len, __builtin_object_size ((const void *) __dest, 0));
}


;; Function explicit_bzero (null)
;; enabled by -tree-original


{
  __explicit_bzero_chk (__dest, __len, __builtin_object_size ((const void *) __dest, 0));
}


;; Function strcpy (null)
;; enabled by -tree-original


{
  return __builtin___strcpy_chk (__dest, __src, __builtin_object_size ((const void *) __dest, 1));
}


;; Function strncpy (null)
;; enabled by -tree-original


{
  return __builtin___strncpy_chk (__dest, __src, __len, __builtin_object_size ((const void *) __dest, 1));
}


;; Function stpncpy (null)
;; enabled by -tree-original


{
  return __builtin___stpncpy_chk (__dest, __src, __n, __builtin_object_size ((const void *) __dest, 1));
}


;; Function strcat (null)
;; enabled by -tree-original


{
  return __builtin___strcat_chk (__dest, __src, __builtin_object_size ((const void *) __dest, 1));
}


;; Function strncat (null)
;; enabled by -tree-original


{
  return __builtin___strncat_chk (__dest, __src, __len, __builtin_object_size ((const void *) __dest, 1));
}


;; Function winlink_cmp (null)
;; enabled by -tree-original


{
  return wl1->idx - wl2->idx;
}


;; Function winlinks_RB_INSERT_COLOR (null)
;; enabled by -tree-original


{
  struct winlink * parent;
  struct winlink * gparent;
  struct winlink * tmp;

    struct winlink * parent;
    struct winlink * gparent;
    struct winlink * tmp;
  goto <D.4307>;
  <D.4308>:;
  gparent = parent->entry.rbe_parent;
  if (gparent->entry.rbe_left == parent)
    {
      tmp = gparent->entry.rbe_right;
      if (tmp != 0B && tmp->entry.rbe_color == 1)
        {
          tmp->entry.rbe_color = 0;
          parent->entry.rbe_color = 0;
          gparent->entry.rbe_color = 1;
          elm = gparent;
          // predicted unlikely by continue predictor.;
          goto <D.4307>;
        }
      if (parent->entry.rbe_right == elm)
        {
          tmp = parent->entry.rbe_right;
          if ((parent->entry.rbe_right = tmp->entry.rbe_left) != 0B)
            {
              tmp->entry.rbe_left->entry.rbe_parent = parent;
            }
          if ((tmp->entry.rbe_parent = parent->entry.rbe_parent) != 0B)
            {
              if (parent->entry.rbe_parent->entry.rbe_left == parent)
                {
                  parent->entry.rbe_parent->entry.rbe_left = tmp;
                }
              else
                {
                  parent->entry.rbe_parent->entry.rbe_right = tmp;
                }
            }
          else
            {
              head->rbh_root = tmp;
            }
          tmp->entry.rbe_left = parent;
          parent->entry.rbe_parent = tmp;
          if (tmp->entry.rbe_parent != 0B)
            {
              
            }
          tmp = parent;
          parent = elm;
          elm = tmp;
        }
      parent->entry.rbe_color = 0;
      gparent->entry.rbe_color = 1;
      tmp = gparent->entry.rbe_left;
      if ((gparent->entry.rbe_left = tmp->entry.rbe_right) != 0B)
        {
          tmp->entry.rbe_right->entry.rbe_parent = gparent;
        }
      if ((tmp->entry.rbe_parent = gparent->entry.rbe_parent) != 0B)
        {
          if (gparent->entry.rbe_parent->entry.rbe_left == gparent)
            {
              gparent->entry.rbe_parent->entry.rbe_left = tmp;
            }
          else
            {
              gparent->entry.rbe_parent->entry.rbe_right = tmp;
            }
        }
      else
        {
          head->rbh_root = tmp;
        }
      tmp->entry.rbe_right = gparent;
      gparent->entry.rbe_parent = tmp;
      if (tmp->entry.rbe_parent != 0B)
        {
          
        }
    }
  else
    {
      tmp = gparent->entry.rbe_left;
      if (tmp != 0B && tmp->entry.rbe_color == 1)
        {
          tmp->entry.rbe_color = 0;
          parent->entry.rbe_color = 0;
          gparent->entry.rbe_color = 1;
          elm = gparent;
          // predicted unlikely by continue predictor.;
          goto <D.4307>;
        }
      if (parent->entry.rbe_left == elm)
        {
          tmp = parent->entry.rbe_left;
          if ((parent->entry.rbe_left = tmp->entry.rbe_right) != 0B)
            {
              tmp->entry.rbe_right->entry.rbe_parent = parent;
            }
          if ((tmp->entry.rbe_parent = parent->entry.rbe_parent) != 0B)
            {
              if (parent->entry.rbe_parent->entry.rbe_left == parent)
                {
                  parent->entry.rbe_parent->entry.rbe_left = tmp;
                }
              else
                {
                  parent->entry.rbe_parent->entry.rbe_right = tmp;
                }
            }
          else
            {
              head->rbh_root = tmp;
            }
          tmp->entry.rbe_right = parent;
          parent->entry.rbe_parent = tmp;
          if (tmp->entry.rbe_parent != 0B)
            {
              
            }
          tmp = parent;
          parent = elm;
          elm = tmp;
        }
      parent->entry.rbe_color = 0;
      gparent->entry.rbe_color = 1;
      tmp = gparent->entry.rbe_right;
      if ((gparent->entry.rbe_right = tmp->entry.rbe_left) != 0B)
        {
          tmp->entry.rbe_left->entry.rbe_parent = gparent;
        }
      if ((tmp->entry.rbe_parent = gparent->entry.rbe_parent) != 0B)
        {
          if (gparent->entry.rbe_parent->entry.rbe_left == gparent)
            {
              gparent->entry.rbe_parent->entry.rbe_left = tmp;
            }
          else
            {
              gparent->entry.rbe_parent->entry.rbe_right = tmp;
            }
        }
      else
        {
          head->rbh_root = tmp;
        }
      tmp->entry.rbe_left = gparent;
      gparent->entry.rbe_parent = tmp;
      if (tmp->entry.rbe_parent != 0B)
        {
          
        }
    }
  <D.4307>:;
  if ((parent = elm->entry.rbe_parent) != 0B && parent->entry.rbe_color == 1) goto <D.4308>; else goto <D.4309>;
  <D.4309>:;
  head->rbh_root->entry.rbe_color = 0;
}


;; Function winlinks_RB_REMOVE_COLOR (null)
;; enabled by -tree-original


{
  struct winlink * tmp;

    struct winlink * tmp;
  goto <D.4320>;
  <D.4319>:;
  if (parent->entry.rbe_left == elm)
    {
      tmp = parent->entry.rbe_right;
      if (tmp->entry.rbe_color == 1)
        {
          tmp->entry.rbe_color = 0;
          parent->entry.rbe_color = 1;
          tmp = parent->entry.rbe_right;
          if ((parent->entry.rbe_right = tmp->entry.rbe_left) != 0B)
            {
              tmp->entry.rbe_left->entry.rbe_parent = parent;
            }
          if ((tmp->entry.rbe_parent = parent->entry.rbe_parent) != 0B)
            {
              if (parent->entry.rbe_parent->entry.rbe_left == parent)
                {
                  parent->entry.rbe_parent->entry.rbe_left = tmp;
                }
              else
                {
                  parent->entry.rbe_parent->entry.rbe_right = tmp;
                }
            }
          else
            {
              head->rbh_root = tmp;
            }
          tmp->entry.rbe_left = parent;
          parent->entry.rbe_parent = tmp;
          if (tmp->entry.rbe_parent != 0B)
            {
              
            }
          tmp = parent->entry.rbe_right;
        }
      if ((tmp->entry.rbe_left == 0B || tmp->entry.rbe_left->entry.rbe_color == 0) && (tmp->entry.rbe_right == 0B || tmp->entry.rbe_right->entry.rbe_color == 0))
        {
          tmp->entry.rbe_color = 1;
          elm = parent;
          parent = elm->entry.rbe_parent;
        }
      else
        {
          if (tmp->entry.rbe_right == 0B || tmp->entry.rbe_right->entry.rbe_color == 0)
            {
              {
                struct winlink * oleft;

                                struct winlink * oleft;
                if ((oleft = tmp->entry.rbe_left) != 0B)
                  {
                    oleft->entry.rbe_color = 0;
                  }
                tmp->entry.rbe_color = 1;
                oleft = tmp->entry.rbe_left;
                if ((tmp->entry.rbe_left = oleft->entry.rbe_right) != 0B)
                  {
                    oleft->entry.rbe_right->entry.rbe_parent = tmp;
                  }
                if ((oleft->entry.rbe_parent = tmp->entry.rbe_parent) != 0B)
                  {
                    if (tmp->entry.rbe_parent->entry.rbe_left == tmp)
                      {
                        tmp->entry.rbe_parent->entry.rbe_left = oleft;
                      }
                    else
                      {
                        tmp->entry.rbe_parent->entry.rbe_right = oleft;
                      }
                  }
                else
                  {
                    head->rbh_root = oleft;
                  }
                oleft->entry.rbe_right = tmp;
                tmp->entry.rbe_parent = oleft;
                if (oleft->entry.rbe_parent != 0B)
                  {
                    
                  }
                tmp = parent->entry.rbe_right;
              }
            }
          tmp->entry.rbe_color = parent->entry.rbe_color;
          parent->entry.rbe_color = 0;
          if (tmp->entry.rbe_right != 0B)
            {
              tmp->entry.rbe_right->entry.rbe_color = 0;
            }
          tmp = parent->entry.rbe_right;
          if ((parent->entry.rbe_right = tmp->entry.rbe_left) != 0B)
            {
              tmp->entry.rbe_left->entry.rbe_parent = parent;
            }
          if ((tmp->entry.rbe_parent = parent->entry.rbe_parent) != 0B)
            {
              if (parent->entry.rbe_parent->entry.rbe_left == parent)
                {
                  parent->entry.rbe_parent->entry.rbe_left = tmp;
                }
              else
                {
                  parent->entry.rbe_parent->entry.rbe_right = tmp;
                }
            }
          else
            {
              head->rbh_root = tmp;
            }
          tmp->entry.rbe_left = parent;
          parent->entry.rbe_parent = tmp;
          if (tmp->entry.rbe_parent != 0B)
            {
              
            }
          elm = head->rbh_root;
          goto <D.4317>;
        }
    }
  else
    {
      tmp = parent->entry.rbe_left;
      if (tmp->entry.rbe_color == 1)
        {
          tmp->entry.rbe_color = 0;
          parent->entry.rbe_color = 1;
          tmp = parent->entry.rbe_left;
          if ((parent->entry.rbe_left = tmp->entry.rbe_right) != 0B)
            {
              tmp->entry.rbe_right->entry.rbe_parent = parent;
            }
          if ((tmp->entry.rbe_parent = parent->entry.rbe_parent) != 0B)
            {
              if (parent->entry.rbe_parent->entry.rbe_left == parent)
                {
                  parent->entry.rbe_parent->entry.rbe_left = tmp;
                }
              else
                {
                  parent->entry.rbe_parent->entry.rbe_right = tmp;
                }
            }
          else
            {
              head->rbh_root = tmp;
            }
          tmp->entry.rbe_right = parent;
          parent->entry.rbe_parent = tmp;
          if (tmp->entry.rbe_parent != 0B)
            {
              
            }
          tmp = parent->entry.rbe_left;
        }
      if ((tmp->entry.rbe_left == 0B || tmp->entry.rbe_left->entry.rbe_color == 0) && (tmp->entry.rbe_right == 0B || tmp->entry.rbe_right->entry.rbe_color == 0))
        {
          tmp->entry.rbe_color = 1;
          elm = parent;
          parent = elm->entry.rbe_parent;
        }
      else
        {
          if (tmp->entry.rbe_left == 0B || tmp->entry.rbe_left->entry.rbe_color == 0)
            {
              {
                struct winlink * oright;

                                struct winlink * oright;
                if ((oright = tmp->entry.rbe_right) != 0B)
                  {
                    oright->entry.rbe_color = 0;
                  }
                tmp->entry.rbe_color = 1;
                oright = tmp->entry.rbe_right;
                if ((tmp->entry.rbe_right = oright->entry.rbe_left) != 0B)
                  {
                    oright->entry.rbe_left->entry.rbe_parent = tmp;
                  }
                if ((oright->entry.rbe_parent = tmp->entry.rbe_parent) != 0B)
                  {
                    if (tmp->entry.rbe_parent->entry.rbe_left == tmp)
                      {
                        tmp->entry.rbe_parent->entry.rbe_left = oright;
                      }
                    else
                      {
                        tmp->entry.rbe_parent->entry.rbe_right = oright;
                      }
                  }
                else
                  {
                    head->rbh_root = oright;
                  }
                oright->entry.rbe_left = tmp;
                tmp->entry.rbe_parent = oright;
                if (oright->entry.rbe_parent != 0B)
                  {
                    
                  }
                tmp = parent->entry.rbe_left;
              }
            }
          tmp->entry.rbe_color = parent->entry.rbe_color;
          parent->entry.rbe_color = 0;
          if (tmp->entry.rbe_left != 0B)
            {
              tmp->entry.rbe_left->entry.rbe_color = 0;
            }
          tmp = parent->entry.rbe_left;
          if ((parent->entry.rbe_left = tmp->entry.rbe_right) != 0B)
            {
              tmp->entry.rbe_right->entry.rbe_parent = parent;
            }
          if ((tmp->entry.rbe_parent = parent->entry.rbe_parent) != 0B)
            {
              if (parent->entry.rbe_parent->entry.rbe_left == parent)
                {
                  parent->entry.rbe_parent->entry.rbe_left = tmp;
                }
              else
                {
                  parent->entry.rbe_parent->entry.rbe_right = tmp;
                }
            }
          else
            {
              head->rbh_root = tmp;
            }
          tmp->entry.rbe_right = parent;
          parent->entry.rbe_parent = tmp;
          if (tmp->entry.rbe_parent != 0B)
            {
              
            }
          elm = head->rbh_root;
          goto <D.4317>;
        }
    }
  <D.4320>:;
  if ((elm == 0B || elm->entry.rbe_color == 0) && head->rbh_root != elm) goto <D.4319>; else goto <D.4317>;
  <D.4317>:;
  if (elm != 0B)
    {
      elm->entry.rbe_color = 0;
    }
}


;; Function winlinks_RB_INSERT (null)
;; enabled by -tree-original


{
  struct winlink * tmp;
  struct winlink * parent = 0B;
  int comp = 0;

    struct winlink * tmp;
    struct winlink * parent = 0B;
    int comp = 0;
  tmp = head->rbh_root;
  goto <D.4329>;
  <D.4328>:;
  parent = tmp;
  comp = winlink_cmp (elm, parent);
  if (comp < 0)
    {
      tmp = tmp->entry.rbe_left;
    }
  else
    {
      if (comp > 0)
        {
          tmp = tmp->entry.rbe_right;
        }
      else
        {
          return tmp;
        }
    }
  <D.4329>:;
  if (tmp != 0B) goto <D.4328>; else goto <D.4330>;
  <D.4330>:;
  elm->entry.rbe_parent = parent;
  elm->entry.rbe_left = elm->entry.rbe_right = 0B;
  elm->entry.rbe_color = 1;
  if (parent != 0B)
    {
      if (comp < 0)
        {
          parent->entry.rbe_left = elm;
        }
      else
        {
          parent->entry.rbe_right = elm;
        }
    }
  else
    {
      head->rbh_root = elm;
    }
  winlinks_RB_INSERT_COLOR (head, elm);
  return 0B;
}


;; Function winlinks_RB_REMOVE (null)
;; enabled by -tree-original


{
  struct winlink * child;
  struct winlink * parent;
  struct winlink * old = elm;
  int color;
  void color = <<< error >>>;

    struct winlink * child;
    struct winlink * parent;
    struct winlink * old = elm;
    int color;
  if (elm->entry.rbe_left == 0B)
    {
      child = elm->entry.rbe_right;
    }
  else
    {
      if (elm->entry.rbe_right == 0B)
        {
          child = elm->entry.rbe_left;
        }
      else
        {
          {
            struct winlink * left;

                        struct winlink * left;
            elm = elm->entry.rbe_right;
            goto <D.4341>;
            <D.4340>:;
            elm = left;
            <D.4341>:;
            if ((left = elm->entry.rbe_left) != 0B) goto <D.4340>; else goto <D.4342>;
            <D.4342>:;
            child = elm->entry.rbe_right;
            parent = elm->entry.rbe_parent;
            color = elm->entry.rbe_color;
            if (child != 0B)
              {
                child->entry.rbe_parent = parent;
              }
            if (parent != 0B)
              {
                if (parent->entry.rbe_left == elm)
                  {
                    parent->entry.rbe_left = child;
                  }
                else
                  {
                    parent->entry.rbe_right = child;
                  }
              }
            else
              {
                head->rbh_root = child;
              }
            if (elm->entry.rbe_parent == old)
              {
                parent = elm;
              }
            elm->entry = old->entry;
            if (old->entry.rbe_parent != 0B)
              {
                if (old->entry.rbe_parent->entry.rbe_left == old)
                  {
                    old->entry.rbe_parent->entry.rbe_left = elm;
                  }
                else
                  {
                    old->entry.rbe_parent->entry.rbe_right = elm;
                  }
              }
            else
              {
                head->rbh_root = elm;
              }
            old->entry.rbe_left->entry.rbe_parent = elm;
            if (old->entry.rbe_right != 0B)
              {
                old->entry.rbe_right->entry.rbe_parent = elm;
              }
            if (parent != 0B)
              {
                left = parent;
                <D.4343>:;
                if ((left = left->entry.rbe_parent) != 0B) goto <D.4343>; else goto <D.4344>;
                <D.4344>:;
              }
            goto color;
          }
        }
    }
  parent = elm->entry.rbe_parent;
  color = elm->entry.rbe_color;
  if (child != 0B)
    {
      child->entry.rbe_parent = parent;
    }
  if (parent != 0B)
    {
      if (parent->entry.rbe_left == elm)
        {
          parent->entry.rbe_left = child;
        }
      else
        {
          parent->entry.rbe_right = child;
        }
    }
  else
    {
      head->rbh_root = child;
    }
  color:;
  if (color == 0)
    {
      winlinks_RB_REMOVE_COLOR (head, parent, child);
    }
  return old;
}


;; Function winlinks_RB_FIND (null)
;; enabled by -tree-original


{
  struct winlink * tmp = head->rbh_root;
  int comp;

    struct winlink * tmp = head->rbh_root;
    int comp;
  goto <D.4353>;
  <D.4352>:;
  comp = winlink_cmp (elm, tmp);
  if (comp < 0)
    {
      tmp = tmp->entry.rbe_left;
    }
  else
    {
      if (comp > 0)
        {
          tmp = tmp->entry.rbe_right;
        }
      else
        {
          return tmp;
        }
    }
  <D.4353>:;
  if (tmp != 0B) goto <D.4352>; else goto <D.4354>;
  <D.4354>:;
  return 0B;
}


;; Function winlinks_RB_NFIND (null)
;; enabled by -tree-original


{
  struct winlink * tmp = head->rbh_root;
  struct winlink * res = 0B;
  int comp;

    struct winlink * tmp = head->rbh_root;
    struct winlink * res = 0B;
    int comp;
  goto <D.4363>;
  <D.4362>:;
  comp = winlink_cmp (elm, tmp);
  if (comp < 0)
    {
      res = tmp;
      tmp = tmp->entry.rbe_left;
    }
  else
    {
      if (comp > 0)
        {
          tmp = tmp->entry.rbe_right;
        }
      else
        {
          return tmp;
        }
    }
  <D.4363>:;
  if (tmp != 0B) goto <D.4362>; else goto <D.4364>;
  <D.4364>:;
  return res;
}


;; Function winlinks_RB_NEXT (null)
;; enabled by -tree-original


{
  if (elm->entry.rbe_right != 0B)
    {
      elm = elm->entry.rbe_right;
      goto <D.4369>;
      <D.4368>:;
      elm = elm->entry.rbe_left;
      <D.4369>:;
      if (elm->entry.rbe_left != 0B) goto <D.4368>; else goto <D.4370>;
      <D.4370>:;
    }
  else
    {
      if (elm->entry.rbe_parent != 0B && elm->entry.rbe_parent->entry.rbe_left == elm)
        {
          elm = elm->entry.rbe_parent;
        }
      else
        {
          goto <D.4372>;
          <D.4371>:;
          elm = elm->entry.rbe_parent;
          <D.4372>:;
          if (elm->entry.rbe_parent != 0B && elm->entry.rbe_parent->entry.rbe_right == elm) goto <D.4371>; else goto <D.4373>;
          <D.4373>:;
          elm = elm->entry.rbe_parent;
        }
    }
  return elm;
}


;; Function winlinks_RB_PREV (null)
;; enabled by -tree-original


{
  if (elm->entry.rbe_left != 0B)
    {
      elm = elm->entry.rbe_left;
      goto <D.4378>;
      <D.4377>:;
      elm = elm->entry.rbe_right;
      <D.4378>:;
      if (elm->entry.rbe_right != 0B) goto <D.4377>; else goto <D.4379>;
      <D.4379>:;
    }
  else
    {
      if (elm->entry.rbe_parent != 0B && elm->entry.rbe_parent->entry.rbe_right == elm)
        {
          elm = elm->entry.rbe_parent;
        }
      else
        {
          goto <D.4381>;
          <D.4380>:;
          elm = elm->entry.rbe_parent;
          <D.4381>:;
          if (elm->entry.rbe_parent != 0B && elm->entry.rbe_parent->entry.rbe_left == elm) goto <D.4380>; else goto <D.4382>;
          <D.4382>:;
          elm = elm->entry.rbe_parent;
        }
    }
  return elm;
}


;; Function winlinks_RB_MINMAX (null)
;; enabled by -tree-original


{
  struct winlink * tmp = head->rbh_root;
  struct winlink * parent = 0B;

    struct winlink * tmp = head->rbh_root;
    struct winlink * parent = 0B;
  goto <D.4390>;
  <D.4389>:;
  parent = tmp;
  if (val < 0)
    {
      tmp = tmp->entry.rbe_left;
    }
  else
    {
      tmp = tmp->entry.rbe_right;
    }
  <D.4390>:;
  if (tmp != 0B) goto <D.4389>; else goto <D.4391>;
  <D.4391>:;
  return parent;
}


;; Function xrealloc (null)
;; enabled by -tree-original


{
  size_t newsize = nmemb * size;
  void * newptr;

    size_t newsize = nmemb * size;
    void * newptr;
  if (newsize == 0)
    {
      printf ((const char * restrict) "zero size%s", (char *) "");
      exit (1);
    }
  if (1073741824 / nmemb < size)
    {
      printf ((const char * restrict) "nmemb * size > SIZE_MAX%s", (char *) "");
      exit (1);
    }
  if ((newptr = realloc (oldptr, newsize)) == 0B)
    {
      printf ((const char * restrict) "xrealloc failed%s", (char *) "");
      exit (1);
    }
  return newptr;
}


;; Function winlink_find_by_index (null)
;; enabled by -tree-original


{
  struct winlink wl;

    struct winlink wl;
  if (idx < 0)
    {
      printf ((const char * restrict) "bad index%s", (char *) "");
      exit (1);
    }
  wl.idx = idx;
  return winlinks_RB_FIND (wwl, &wl);
}


;; Function winlink_count (null)
;; enabled by -tree-original


{
  struct winlink * wl;
  u_int n;

    struct winlink * wl;
    u_int n;
  n = 0;
  wl = winlinks_RB_MINMAX (wwl, -1);
  goto <D.4410>;
  <D.4409>:;
  n++ ;
  wl = winlinks_RB_NEXT (wl);
  <D.4410>:;
  if (wl != 0B) goto <D.4409>; else goto <D.4411>;
  <D.4411>:;
  return n;
}


;; Function winlink_next_index (null)
;; enabled by -tree-original


{
  int i;

    int i;
  i = idx;
  <D.4417>:;
  if (winlink_find_by_index (wwl, i) == 0B)
    {
      return i;
    }
  if (i == 10000)
    {
      i = 0;
    }
  else
    {
      i++ ;
    }
  if (i != idx) goto <D.4417>; else goto <D.4418>;
  <D.4418>:;
  return -1;
}


;; Function winlink_find_by_window (null)
;; enabled by -tree-original


{
  struct winlink * wl;

    struct winlink * wl;
  wl = winlinks_RB_MINMAX (wwl, -1);
  goto <D.4425>;
  <D.4424>:;
  if (wl->window == w)
    {
      return wl;
    }
  wl = winlinks_RB_NEXT (wl);
  <D.4425>:;
  if (wl != 0B) goto <D.4424>; else goto <D.4426>;
  <D.4426>:;
  return 0B;
}


;; Function cmd_find_pane (null)
;; enabled by -tree-original


{
  struct session * s;
  struct winlink * wl;
  u_int idx;

    struct session * s;
    struct winlink * wl;
    u_int idx;
  if (sessions.num == 0)
    {
      printf ((const char * restrict) "can\'t establish current session\n");
      return 0B;
    }
  s = *(sessions.list + 8);
  if (sp != 0B)
    {
      *sp = s;
    }
  if (arg != 0)
    {
      return s->curw;
    }
  return winlinks_RB_NEXT (s->curw);
}


;; Function session_has (null)
;; enabled by -tree-original


{
  struct winlink * wl;

    struct winlink * wl;
  wl = winlinks_RB_MINMAX (&s->windows, -1);
  goto <D.4440>;
  <D.4439>:;
  if (wl->window == w)
    {
      return 1;
    }
  wl = winlinks_RB_NEXT (wl);
  <D.4440>:;
  if (wl != 0B) goto <D.4439>; else goto <D.4441>;
  <D.4441>:;
  return 0;
}


;; Function session_group_find (null)
;; enabled by -tree-original


{
  struct session_group * sg;
  struct session * s;

    struct session_group * sg;
    struct session * s;
  sg = session_groups.tqh_first;
  goto <D.4451>;
  <D.4450>:;
  s = sg->sessions.tqh_first;
  goto <D.4448>;
  <D.4447>:;
  if (s == target)
    {
      return sg;
    }
  s = s->gentry.tqe_next;
  <D.4448>:;
  if (s != 0B) goto <D.4447>; else goto <D.4449>;
  <D.4449>:;
  sg = sg->entry.tqe_next;
  <D.4451>:;
  if (sg != 0B) goto <D.4450>; else goto <D.4452>;
  <D.4452>:;
  return 0B;
}


;; Function session_group_add (null)
;; enabled by -tree-original


{
  struct session_group * sg;

    struct session_group * sg;
  if ((sg = session_group_find (target)) == 0B)
    {
      sg = (struct session_group *) malloc (32);
      sg->entry.tqe_next = 0B;
      sg->entry.tqe_prev = session_groups.tqh_last;
      *session_groups.tqh_last = sg;
      session_groups.tqh_last = &sg->entry.tqe_next;
      sg->sessions.tqh_first = 0B;
      sg->sessions.tqh_last = &sg->sessions.tqh_first;
      target->gentry.tqe_next = 0B;
      target->gentry.tqe_prev = sg->sessions.tqh_last;
      *sg->sessions.tqh_last = target;
      sg->sessions.tqh_last = &target->gentry.tqe_next;
    }
  s->gentry.tqe_next = 0B;
  s->gentry.tqe_prev = sg->sessions.tqh_last;
  *sg->sessions.tqh_last = s;
  sg->sessions.tqh_last = &s->gentry.tqe_next;
}


;; Function winlink_add (null)
;; enabled by -tree-original


{
  struct winlink * wl;

    struct winlink * wl;
  if (idx < 0)
    {
      if ((idx = winlink_next_index (wwl, ~idx)) == -1)
        {
          return 0B;
        }
    }
  else
    {
      if (winlink_find_by_index (wwl, idx) != 0B)
        {
          return 0B;
        }
    }
  wl = (struct winlink *) calloc (1, 136);
  wl->idx = idx;
  wl->window = w;
  winlinks_RB_INSERT (wwl, wl);
  w->references++ ;
  return wl;
}


;; Function window_index (null)
;; enabled by -tree-original


{
  *i = 0;
  goto <D.4469>;
  <D.4468>:;
  if (*(windows.list + (sizetype) ((long unsigned int) *i * 8)) == s)
    {
      return 0;
    }
  *i++ ;
  <D.4469>:;
  if (*i < windows.num) goto <D.4468>; else goto <D.4470>;
  <D.4470>:;
  return -1;
}


;; Function session_group_remove (null)
;; enabled by -tree-original


{
  struct session_group * sg;

    struct session_group * sg;
  if ((sg = session_group_find (s)) == 0B)
    {
      return;
    }
  if (s->gentry.tqe_next != 0B)
    {
      s->gentry.tqe_next->gentry.tqe_prev = s->gentry.tqe_prev;
    }
  else
    {
      sg->sessions.tqh_last = s->gentry.tqe_prev;
    }
  *s->gentry.tqe_prev = s->gentry.tqe_next;
  if (sg->sessions.tqh_first->gentry.tqe_next == 0B)
    {
      if (sg->sessions.tqh_first->gentry.tqe_next != 0B)
        {
          sg->sessions.tqh_first->gentry.tqe_next->gentry.tqe_prev = sg->sessions.tqh_first->gentry.tqe_prev;
        }
      else
        {
          sg->sessions.tqh_last = sg->sessions.tqh_first->gentry.tqe_prev;
        }
      *sg->sessions.tqh_first->gentry.tqe_prev = sg->sessions.tqh_first->gentry.tqe_next;
    }
  if (sg->sessions.tqh_first == 0B)
    {
      if (sg->entry.tqe_next != 0B)
        {
          sg->entry.tqe_next->entry.tqe_prev = sg->entry.tqe_prev;
        }
      else
        {
          session_groups.tqh_last = sg->entry.tqe_prev;
        }
      *sg->entry.tqe_prev = sg->entry.tqe_next;
      free ((void *) sg);
    }
}


;; Function session_find (null)
;; enabled by -tree-original


{
  struct session * s;
  u_int i;

    struct session * s;
    u_int i;
  i = 0;
  goto <D.4481>;
  <D.4480>:;
  s = *(sessions.list + (sizetype) ((long unsigned int) i * 8));
  if (s != 0B && strcmp ((const char *) s->name, name) == 0)
    {
      return s;
    }
  i++ ;
  <D.4481>:;
  if (sessions.num > i) goto <D.4480>; else goto <D.4482>;
  <D.4482>:;
  return 0B;
}


;; Function session_index (null)
;; enabled by -tree-original


{
  *i = 0;
  goto <D.4488>;
  <D.4487>:;
  if (*(sessions.list + (sizetype) ((long unsigned int) *i * 8)) == s)
    {
      return 0;
    }
  *i++ ;
  <D.4488>:;
  if (*i < sessions.num) goto <D.4487>; else goto <D.4489>;
  <D.4489>:;
  return -1;
}


;; Function winlink_stack_remove (null)
;; enabled by -tree-original


{
  struct winlink * wl2;

    struct winlink * wl2;
  if (wl == 0B)
    {
      return;
    }
  wl2 = stack->tqh_first;
  goto <D.4496>;
  <D.4495>:;
  if (wl2 == wl)
    {
      if (wl->sentry.tqe_next != 0B)
        {
          wl->sentry.tqe_next->sentry.tqe_prev = wl->sentry.tqe_prev;
        }
      else
        {
          stack->tqh_last = wl->sentry.tqe_prev;
        }
      *wl->sentry.tqe_prev = wl->sentry.tqe_next;
      return;
    }
  wl2 = wl2->sentry.tqe_next;
  <D.4496>:;
  if (wl2 != 0B) goto <D.4495>; else goto <D.4497>;
  <D.4497>:;
}


;; Function winlink_stack_push (null)
;; enabled by -tree-original


{
  if (wl == 0B)
    {
      return;
    }
  winlink_stack_remove (stack, wl);
  if ((wl->sentry.tqe_next = stack->tqh_first) != 0B)
    {
      stack->tqh_first->sentry.tqe_prev = &wl->sentry.tqe_next;
    }
  else
    {
      stack->tqh_last = &wl->sentry.tqe_next;
    }
  stack->tqh_first = wl;
  wl->sentry.tqe_prev = &stack->tqh_first;
}


;; Function window_destroy (null)
;; enabled by -tree-original


{
  u_int i;

    u_int i;
  if (window_index (w, &i) != 0)
    {
      printf ((const char * restrict) "index not found%s\n", (char *) "");
      exit (1);
    }
  *(windows.list + (sizetype) ((long unsigned int) i * 8)) = 0B;
  goto <D.4507>;
  <D.4506>:;
  if (windows.num > 1)
    {
      windows.num = windows.num + 4294967295;
    }
  else
    {
      free ((void *) windows.list);
      windows.num = 0;
      windows.list = 0B;
      windows.space = 0;
    }
  <D.4507>:;
  if (windows.num != 0 && *(windows.list + (sizetype) ((long unsigned int) (windows.num + 4294967295) * 8)) == 0B) goto <D.4506>; else goto <D.4508>;
  <D.4508>:;
  if (w->name != 0B)
    {
      free ((void *) w->name);
    }
  free ((void *) w);
}


;; Function winlink_remove (null)
;; enabled by -tree-original


{
  struct window * w = wl->window;

    struct window * w = wl->window;
  winlinks_RB_REMOVE (wwl, wl);
  if (wl->status_text != 0B)
    {
      free ((void *) wl->status_text);
    }
  free ((void *) wl);
  if (w->references == 0)
    {
      printf ((const char * restrict) "bad reference count%s\n", (char *) "");
      exit (1);
    }
  w->references-- ;
  if (w->references == 0)
    {
      window_destroy (w);
    }
}


;; Function session_group_synchronize1 (null)
;; enabled by -tree-original


{
  struct winlinks old_windows;
  struct winlinks * ww;
  struct winlink_stack old_lastw;
  struct winlink * wl;
  struct winlink * wl2;
  typedef struct session_alert struct struct session_alert;
  struct session_alert * sa;

    struct winlinks old_windows;
    struct winlinks * ww;
    struct winlink_stack old_lastw;
    struct winlink * wl;
    struct winlink * wl2;
    struct session_alert * sa;
  ww = &target->windows;
  if (ww->rbh_root == 0B)
    {
      return;
    }
  memcpy ((void * restrict) &old_windows, (const void * restrict) &s->windows, 8);
  s->windows.rbh_root = 0B;
  wl = winlinks_RB_MINMAX (ww, -1);
  goto <D.4526>;
  <D.4525>:;
  winlink_add (&s->windows, wl->window, wl->idx);
  wl = winlinks_RB_NEXT (wl);
  <D.4526>:;
  if (wl != 0B) goto <D.4525>; else goto <D.4527>;
  <D.4527>:;
  memcpy ((void * restrict) &old_lastw, (const void * restrict) &s->lastw, 16);
  s->lastw.tqh_first = 0B;
  s->lastw.tqh_last = &s->lastw.tqh_first;
  wl = old_lastw.tqh_first;
  goto <D.4529>;
  <D.4528>:;
  wl2 = winlink_find_by_index (&s->windows, wl->idx);
  if (wl2 != 0B)
    {
      wl2->sentry.tqe_next = 0B;
      wl2->sentry.tqe_prev = s->lastw.tqh_last;
      *s->lastw.tqh_last = wl2;
      s->lastw.tqh_last = &wl2->sentry.tqe_next;
    }
  wl = wl->sentry.tqe_next;
  <D.4529>:;
  if (wl != 0B) goto <D.4528>; else goto <D.4530>;
  <D.4530>:;
  s->curw = s->lastw.tqh_first;
  goto <D.4532>;
  <D.4531>:;
  wl = old_windows.rbh_root;
  winlink_remove (&old_windows, wl);
  <D.4532>:;
  if (old_windows.rbh_root != 0B) goto <D.4531>; else goto <D.4533>;
  <D.4533>:;
}


;; Function session_group_synchronize_to (null)
;; enabled by -tree-original


{
  struct session_group * sg;
  struct session * target;

    struct session_group * sg;
    struct session * target;
  if ((sg = session_group_find (s)) == 0B)
    {
      return;
    }
  target = 0B;
  target = sg->sessions.tqh_first;
  goto <D.4541>;
  <D.4540>:;
  if (target != s)
    {
      goto <D.4539>;
    }
  target = target->gentry.tqe_next;
  <D.4541>:;
  if (target != 0B) goto <D.4540>; else goto <D.4539>;
  <D.4539>:;
  session_group_synchronize1 (target, s);
}


;; Function session_group_synchronize_from (null)
;; enabled by -tree-original


{
  struct session_group * sg;
  struct session * s;

    struct session_group * sg;
    struct session * s;
  if ((sg = session_group_find (target)) == 0B)
    {
      return;
    }
  s = sg->sessions.tqh_first;
  goto <D.4548>;
  <D.4547>:;
  if (s != target)
    {
      session_group_synchronize1 (target, s);
    }
  s = s->gentry.tqe_next;
  <D.4548>:;
  if (s != 0B) goto <D.4547>; else goto <D.4549>;
  <D.4549>:;
}


;; Function session_destroy (null)
;; enabled by -tree-original


{
  u_int i;

    u_int i;
  printf ((const char * restrict) "session %s destroyed\n", s->name);
  if (session_index (s, &i) != 0)
    {
      printf ((const char * restrict) "session not found%s\n", (char *) "");
      exit (1);
    }
  *(sessions.list + (sizetype) ((long unsigned int) i * 8)) = 0B;
  goto <D.4555>;
  <D.4554>:;
  if (sessions.num > 1)
    {
      sessions.num = sessions.num + 4294967295;
    }
  else
    {
      free ((void *) sessions.list);
      sessions.num = 0;
      sessions.list = 0B;
      sessions.space = 0;
    }
  <D.4555>:;
  if (sessions.num != 0 && *(sessions.list + (sizetype) ((long unsigned int) (sessions.num + 4294967295) * 8)) == 0B) goto <D.4554>; else goto <D.4556>;
  <D.4556>:;
  session_group_remove (s);
  goto <D.4558>;
  <D.4557>:;
  winlink_stack_remove (&s->lastw, s->lastw.tqh_first);
  <D.4558>:;
  if (s->lastw.tqh_first != 0B) goto <D.4557>; else goto <D.4559>;
  <D.4559>:;
  goto <D.4561>;
  <D.4560>:;
  winlink_remove (&s->windows, s->windows.rbh_root);
  <D.4561>:;
  if (s->windows.rbh_root != 0B) goto <D.4560>; else goto <D.4562>;
  <D.4562>:;
  free ((void *) s->name);
  free ((void *) s);
}


;; Function session_detach (null)
;; enabled by -tree-original


{
  winlink_stack_remove (&s->lastw, wl);
  winlink_remove (&s->windows, wl);
  session_group_synchronize_from (s);
  if (s->windows.rbh_root == 0B)
    {
      session_destroy (s);
      return 1;
    }
  return 0;
}


;; Function server_destroy_session_group (null)
;; enabled by -tree-original


{
  struct session_group * sg;

    struct session_group * sg;
  if ((sg = session_group_find (s)) == 0B)
    {
      return;
    }
  else
    {
      if (sg->entry.tqe_next != 0B)
        {
          sg->entry.tqe_next->entry.tqe_prev = sg->entry.tqe_prev;
        }
      else
        {
          session_groups.tqh_last = sg->entry.tqe_prev;
        }
      *sg->entry.tqe_prev = sg->entry.tqe_next;
      free ((void *) sg);
    }
}


;; Function server_kill_window (null)
;; enabled by -tree-original


{
  struct session * s;
  struct winlink * wl;
  u_int i;

    struct session * s;
    struct winlink * wl;
    u_int i;
  i = 0;
  goto <D.4582>;
  <D.4581>:;
  s = *(sessions.list + (sizetype) ((long unsigned int) i * 8));
  if (s == 0B || session_has (s, w) == 0)
    {
      // predicted unlikely by continue predictor.;
      goto <D.4577>;
    }
  goto <D.4580>;
  <D.4579>:;
  if (session_detach (s, wl) != 0)
    {
      server_destroy_session_group (s);
      goto <D.4578>;
    }
  <D.4580>:;
  if ((wl = winlink_find_by_window (&s->windows, w)) != 0B) goto <D.4579>; else goto <D.4578>;
  <D.4578>:;
  <D.4577>:;
  i++ ;
  <D.4582>:;
  if (sessions.num > i) goto <D.4581>; else goto <D.4583>;
  <D.4583>:;
}


;; Function session_select (null)
;; enabled by -tree-original


{
  struct winlink * wl;

    struct winlink * wl;
  wl = winlink_find_by_index (&s->windows, idx);
  if (wl == 0B)
    {
      return -1;
    }
  if (s->curw == wl)
    {
      return 1;
    }
  winlink_stack_remove (&s->lastw, wl);
  winlink_stack_push (&s->lastw, s->curw);
  s->curw = wl;
  return 0;
}


;; Function join_pane_exec (null)
;; enabled by -tree-original


{
  struct session * dst_s;
  struct winlink * src_wl;
  struct winlink * dst_wl;
  struct window * src_w;
  struct window * dst_w;

    struct session * dst_s;
    struct winlink * src_wl;
    struct winlink * dst_wl;
    struct window * src_w;
    struct window * dst_w;
  if ((dst_wl = cmd_find_pane (0, &dst_s)) == 0B)
    {
      return -1;
    }
  dst_w = dst_wl->window;
  if ((src_wl = cmd_find_pane (1, 0B)) == 0B)
    {
      return -1;
    }
  src_w = src_wl->window;
  if (src_w == dst_w)
    {
      printf ((const char * restrict) "can\'t join a pane to its own window\n");
      return -1;
    }
  server_kill_window (src_w);
  session_select (dst_s, dst_wl->idx);
  return 0;
}


;; Function window_create1 (null)
;; enabled by -tree-original


{
  struct window * w;
  u_int i;

    struct window * w;
    u_int i;
  w = (struct window *) malloc (88);
  w->name = 0B;
  w->flags = 0;
  w->active = 0B;
  w->lastlayout = -1;
  w->layout_root = 0B;
  w->sx = sx;
  w->sy = sy;
  i = 0;
  goto <D.4605>;
  <D.4604>:;
  if (*(windows.list + (sizetype) ((long unsigned int) i * 8)) == 0B)
    {
      *(windows.list + (sizetype) ((long unsigned int) i * 8)) = w;
      goto <D.4603>;
    }
  i++ ;
  <D.4605>:;
  if (windows.num > i) goto <D.4604>; else goto <D.4603>;
  <D.4603>:;
  if (windows.num == i)
    {
      if (windows.num > 1073741823)
        {
          printf ((const char * restrict) "number too big%s", (char *) "");
          exit (1);
        }
      if (1073741824 / (windows.num + 1) <= 7)
        {
          printf ((const char * restrict) "size too big%s", (char *) "");
          exit (1);
        }
      if (windows.space == 0)
        {
          windows.space = 80;
          windows.list = (struct window * *) xrealloc ((void *) windows.list, 1, windows.space);
        }
      goto <D.4607>;
      <D.4606>:;
      windows.list = (struct window * *) xrealloc ((void *) windows.list, 2, windows.space);
      windows.space = windows.space * 2;
      <D.4607>:;
      if ((long unsigned int) windows.space <= (long unsigned int) (windows.num + 1) * 8) goto <D.4606>; else goto <D.4608>;
      <D.4608>:;
      *(windows.list + (sizetype) ((long unsigned int) windows.num * 8)) = w;
      windows.num++ ;
    }
  w->references = 0;
  return w;
}


;; Function session_attach (null)
;; enabled by -tree-original


{
  struct winlink * wl;

    struct winlink * wl;
  if ((wl = winlink_add (&s->windows, w, idx)) == 0B)
    {
      printf ((const char * restrict) "index in use: %d\n", idx);
    }
  session_group_synchronize_from (s);
  return wl;
}


;; Function session_new (null)
;; enabled by -tree-original


{
  struct window * w;
  const char * shell;
  u_int hlimit;

    struct window * w;
    const char * shell;
    u_int hlimit;
  w = window_create1 (s->sx, s->sy);
  if (w == 0B)
    {
      return 0B;
    }
  return session_attach (s, w, idx, cause);
}


;; Function session_create (null)
;; enabled by -tree-original


{
  struct session * s;
  u_int i;

    struct session * s;
    u_int i;
  s = (struct session *) malloc (112);
  s->references = 0;
  s->flags = 0;
  s->curw = 0B;
  s->lastw.tqh_first = 0B;
  s->lastw.tqh_last = &s->lastw.tqh_first;
  s->windows.rbh_root = 0B;
  s->tio = 0B;
  s->sx = sx;
  s->sy = sy;
  i = 0;
  goto <D.4642>;
  <D.4641>:;
  if (*(sessions.list + (sizetype) ((long unsigned int) i * 8)) == 0B)
    {
      *(sessions.list + (sizetype) ((long unsigned int) i * 8)) = s;
      goto <D.4640>;
    }
  i++ ;
  <D.4642>:;
  if (sessions.num > i) goto <D.4641>; else goto <D.4640>;
  <D.4640>:;
  if (sessions.num == i)
    {
      if (sessions.num > 1073741823)
        {
          printf ((const char * restrict) "number too big%s", (char *) "");
          exit (1);
        }
      if (1073741824 / (sessions.num + 1) <= 7)
        {
          printf ((const char * restrict) "size too big%s", (char *) "");
          exit (1);
        }
      if (sessions.space == 0)
        {
          sessions.space = 80;
          sessions.list = (struct session * *) xrealloc ((void *) sessions.list, 1, sessions.space);
        }
      goto <D.4644>;
      <D.4643>:;
      sessions.list = (struct session * *) xrealloc ((void *) sessions.list, 2, sessions.space);
      sessions.space = sessions.space * 2;
      <D.4644>:;
      if ((long unsigned int) sessions.space <= (long unsigned int) (sessions.num + 1) * 8) goto <D.4643>; else goto <D.4645>;
      <D.4645>:;
      *(sessions.list + (sizetype) ((long unsigned int) sessions.num * 8)) = s;
      sessions.num++ ;
    }
  if (name == 0B)
    {
      printf ((const char * restrict) "no name%s\n", (char *) "");
      exit (1);
    }
  s->name = strdup (name);
  if (cmd != 0B)
    {
      if (session_new (s, 0B, cmd, cwd, idx, cause) == 0B)
        {
          session_destroy (s);
          return 0B;
        }
      session_select (s, s->windows.rbh_root->idx);
    }
  printf ((const char * restrict) "session %s created\n", s->name);
  return s;
}


;; Function main (null)
;; enabled by -tree-original


{
  struct session * s;
  struct session * groupwith;
  struct window * w;
  char * target;
  char * cmd;
  char * name;
  char * cause;
  int idx = 0;
  int sx;
  int sy;

    struct session * s;
    struct session * groupwith;
    struct window * w;
    char * target;
    char * cmd;
    char * name;
    char * cause;
    int idx = 0;
    int sx;
    int sy;
  windows.num = 0;
  windows.list = 0B;
  windows.space = 0;
  sessions.num = 0;
  sessions.list = 0B;
  sessions.space = 0;
  session_groups.tqh_first = 0B;
  session_groups.tqh_last = &session_groups.tqh_first;
  {
    int i = 0;

        int i = 0;
    goto <D.4662>;
    <D.4661>:;
    if (**(argv + (sizetype) ((long unsigned int) i * 8)) == 116 && i > 0)
      {
        target = strdup ((const char *) *(argv + ((sizetype) ((long unsigned int) i * 8) + 18446744073709551608)));
      }
    else
      {
        target = 0B;
      }
    groupwith = session_find ((const char *) target);
    if (target == 0B)
      {
        cmd = strdup ((const char *) "cmd");
      }
    else
      {
        cmd = 0B;
      }
    free ((void *) target);
    name = strdup ((const char *) *(argv + (sizetype) ((long unsigned int) i * 8)));
    s = session_create ((const char *) name, (const char *) cmd, (const char *) "cwd", 0B, 0B, idx++ , (u_int) sx, (u_int) sy, &cause);
    w = window_create1 ((u_int) sx, (u_int) sy);
    session_attach (s, w, idx++ , &cause);
    free ((void *) cmd);
    if (groupwith != 0B)
      {
        session_group_add (groupwith, s);
        session_group_synchronize_to (s);
        session_select (s, s->windows.rbh_root->idx);
      }
    i++ ;
    <D.4662>:;
    if (i < argc) goto <D.4661>; else goto <D.4663>;
    <D.4663>:;
  }
  join_pane_exec ();
  goto <D.4665>;
  <D.4664>:;
  session_destroy (*sessions.list);
  <D.4665>:;
  if (sessions.num != 0) goto <D.4664>; else goto <D.4666>;
  <D.4666>:;
  return 0;
}
return 0;

