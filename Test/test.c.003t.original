
;; Function getchar (null)
;; enabled by -tree-original


{
  return getc (stdin);
}


;; Function fgetc_unlocked (null)
;; enabled by -tree-original


{
  return __builtin_expect (__fp->_IO_read_ptr >= __fp->_IO_read_end, 0) != 0 ? __uflow (__fp) : (int) *(unsigned char *) __fp->_IO_read_ptr++ ;
}


;; Function getc_unlocked (null)
;; enabled by -tree-original


{
  return __builtin_expect (__fp->_IO_read_ptr >= __fp->_IO_read_end, 0) != 0 ? __uflow (__fp) : (int) *(unsigned char *) __fp->_IO_read_ptr++ ;
}


;; Function getchar_unlocked (null)
;; enabled by -tree-original


{
  return __builtin_expect (stdin->_IO_read_ptr >= stdin->_IO_read_end, 0) != 0 ? __uflow (stdin) : (int) *(unsigned char *) stdin->_IO_read_ptr++ ;
}


;; Function putchar (null)
;; enabled by -tree-original


{
  return putc (__c, stdout);
}


;; Function fputc_unlocked (null)
;; enabled by -tree-original


{
  return __builtin_expect (__stream->_IO_write_ptr >= __stream->_IO_write_end, 0) != 0 ? __overflow (__stream, (int) (unsigned char) __c) : (int) (unsigned char) (*__stream->_IO_write_ptr++  = (char) __c);
}


;; Function putc_unlocked (null)
;; enabled by -tree-original


{
  return __builtin_expect (__stream->_IO_write_ptr >= __stream->_IO_write_end, 0) != 0 ? __overflow (__stream, (int) (unsigned char) __c) : (int) (unsigned char) (*__stream->_IO_write_ptr++  = (char) __c);
}


;; Function putchar_unlocked (null)
;; enabled by -tree-original


{
  return __builtin_expect (stdout->_IO_write_ptr >= stdout->_IO_write_end, 0) != 0 ? __overflow (stdout, (int) (unsigned char) __c) : (int) (unsigned char) (*stdout->_IO_write_ptr++  = (char) __c);
}


;; Function feof_unlocked (null)
;; enabled by -tree-original


{
  return (__stream->_flags & 16) != 0;
}


;; Function ferror_unlocked (null)
;; enabled by -tree-original


{
  return (__stream->_flags & 32) != 0;
}


;; Function sprintf (null)
;; enabled by -tree-original


{
  return __builtin___sprintf_chk (__s, 1, __builtin_object_size ((const void *) __s, 1), __fmt, __builtin_va_arg_pack ());
}


;; Function vsprintf (null)
;; enabled by -tree-original


{
  return __builtin___vsprintf_chk (__s, 1, __builtin_object_size ((const void *) __s, 1), __fmt, __ap);
}


;; Function snprintf (null)
;; enabled by -tree-original


{
  return __builtin___snprintf_chk (__s, __n, 1, __builtin_object_size ((const void *) __s, 1), __fmt, __builtin_va_arg_pack ());
}


;; Function vsnprintf (null)
;; enabled by -tree-original


{
  return __builtin___vsnprintf_chk (__s, __n, 1, __builtin_object_size ((const void *) __s, 1), __fmt, __ap);
}


;; Function fprintf (null)
;; enabled by -tree-original


{
  return __fprintf_chk (__stream, 1, __fmt, __builtin_va_arg_pack ());
}


;; Function printf (null)
;; enabled by -tree-original


{
  return __printf_chk (1, __fmt, __builtin_va_arg_pack ());
}


;; Function vprintf (null)
;; enabled by -tree-original


{
  return __vfprintf_chk (stdout, 1, __fmt, __ap);
}


;; Function vfprintf (null)
;; enabled by -tree-original


{
  return __vfprintf_chk (__stream, 1, __fmt, __ap);
}


;; Function dprintf (null)
;; enabled by -tree-original


{
  return __dprintf_chk (__fd, 1, __fmt, __builtin_va_arg_pack ());
}


;; Function vdprintf (null)
;; enabled by -tree-original


{
  return __vdprintf_chk (__fd, 1, __fmt, __ap);
}


;; Function fgets (null)
;; enabled by -tree-original


{
  if (__builtin_object_size ((const void *) __s, 1) != 18446744073709551615)
    {
      if (__builtin_constant_p (__n) == 0 || __n <= 0)
        {
          return __fgets_chk (__s, __builtin_object_size ((const void *) __s, 1), __n, __stream);
        }
      if ((long unsigned int) __n > __builtin_object_size ((const void *) __s, 1))
        {
          return __fgets_chk_warn (__s, __builtin_object_size ((const void *) __s, 1), __n, __stream);
        }
    }
  return __fgets_alias (__s, __n, __stream);
}


;; Function fread (null)
;; enabled by -tree-original


{
  if (__builtin_object_size ((const void *) __ptr, 0) != 18446744073709551615)
    {
      if ((__builtin_constant_p (__size) == 0 || __builtin_constant_p (__n) == 0) || (__size | __n) > 4294967295)
        {
          return __fread_chk (__ptr, __builtin_object_size ((const void *) __ptr, 0), __size, __n, __stream);
        }
      if ((long unsigned int) (__size * __n) > __builtin_object_size ((const void *) __ptr, 0))
        {
          return __fread_chk_warn (__ptr, __builtin_object_size ((const void *) __ptr, 0), __size, __n, __stream);
        }
    }
  return __fread_alias (__ptr, __size, __n, __stream);
}


;; Function fread_unlocked (null)
;; enabled by -tree-original


{
  if (__builtin_object_size ((const void *) __ptr, 0) != 18446744073709551615)
    {
      if ((__builtin_constant_p (__size) == 0 || __builtin_constant_p (__n) == 0) || (__size | __n) > 4294967295)
        {
          return __fread_unlocked_chk (__ptr, __builtin_object_size ((const void *) __ptr, 0), __size, __n, __stream);
        }
      if ((long unsigned int) (__size * __n) > __builtin_object_size ((const void *) __ptr, 0))
        {
          return __fread_unlocked_chk_warn (__ptr, __builtin_object_size ((const void *) __ptr, 0), __size, __n, __stream);
        }
    }
  if (((__builtin_constant_p (__size) != 0 && __builtin_constant_p (__n) != 0) && (__size | __n) <= 4294967295) && __size * __n <= 8)
    {
      {
        size_t __cnt = __size * __n;
        char * __cptr = (char *) __ptr;

                size_t __cnt = __size * __n;
                char * __cptr = (char *) __ptr;
        if (__cnt == 0)
          {
            return 0;
          }
        goto <D.2378>;
        <D.2377>:;
        {
          int __c = getc_unlocked (__stream);

                    int __c = getc_unlocked (__stream);
          if (__c == -1)
            {
              goto <D.2376>;
            }
          *__cptr++  = (char) __c;
        }
         --__cnt;
        <D.2378>:;
        if (__cnt != 0) goto <D.2377>; else goto <D.2376>;
        <D.2376>:;
        return (size_t) ((long unsigned int) ((long int) __cptr - (long int) __ptr) / (long unsigned int) __size);
      }
    }
  return __fread_unlocked_alias (__ptr, __size, __n, __stream);
}


;; Function atoi (null)
;; enabled by -tree-original


{
  return (int) strtol (__nptr, 0B, 10);
}


;; Function atol (null)
;; enabled by -tree-original


{
  return strtol (__nptr, 0B, 10);
}


;; Function atoll (null)
;; enabled by -tree-original


{
  return strtoll (__nptr, 0B, 10);
}


;; Function __bswap_16 (null)
;; enabled by -tree-original


{
  return (__uint16_t) __builtin_bswap16 ((int) __bsx);
}


;; Function __bswap_32 (null)
;; enabled by -tree-original


{
  return (__uint32_t) __builtin_bswap32 (__bsx);
}


;; Function __bswap_64 (null)
;; enabled by -tree-original


{
  return (__uint64_t) __builtin_bswap64 (__bsx);
}


;; Function __uint16_identity (null)
;; enabled by -tree-original


{
  return __x;
}


;; Function __uint32_identity (null)
;; enabled by -tree-original


{
  return __x;
}


;; Function __uint64_identity (null)
;; enabled by -tree-original


{
  return __x;
}


;; Function bsearch (null)
;; enabled by -tree-original


{
  size_t __l;
  size_t __u;
  size_t __idx;
  const void * __p;
  int __comparison;

    size_t __l;
    size_t __u;
    size_t __idx;
    const void * __p;
    int __comparison;
  __l = 0;
  __u = __nmemb;
  goto <D.2819>;
  <D.2818>:;
  __idx = (__l + __u) / 2;
  __p = __base + (sizetype) (__idx * __size);
  __comparison = __compar (__key, __p);
  if (__comparison < 0)
    {
      __u = __idx;
    }
  else
    {
      if (__comparison > 0)
        {
          __l = __idx + 1;
        }
      else
        {
          return (void *) __p;
        }
    }
  <D.2819>:;
  if (__l < __u) goto <D.2818>; else goto <D.2820>;
  <D.2820>:;
  return 0B;
}


;; Function atof (null)
;; enabled by -tree-original


{
  return strtod (__nptr, 0B);
}


;; Function realpath (null)
;; enabled by -tree-original


{
  if (__builtin_object_size ((const void *) __resolved, 1) != 18446744073709551615)
    {
      return __realpath_chk (__name, __resolved, __builtin_object_size ((const void *) __resolved, 1));
    }
  return __realpath_alias (__name, __resolved);
}


;; Function ptsname_r (null)
;; enabled by -tree-original


{
  if (__builtin_object_size ((const void *) __buf, 1) != 18446744073709551615)
    {
      if (__builtin_constant_p (__buflen) == 0)
        {
          return __ptsname_r_chk (__fd, __buf, __buflen, __builtin_object_size ((const void *) __buf, 1));
        }
      if (__builtin_object_size ((const void *) __buf, 1) < (long unsigned int) __buflen)
        {
          return __ptsname_r_chk_warn (__fd, __buf, __buflen, __builtin_object_size ((const void *) __buf, 1));
        }
    }
  return __ptsname_r_alias (__fd, __buf, __buflen);
}


;; Function wctomb (null)
;; enabled by -tree-original


{
  if (__builtin_object_size ((const void *) __s, 1) != 18446744073709551615 && __builtin_object_size ((const void *) __s, 1) <= 15)
    {
      return __wctomb_chk (__s, __wchar, __builtin_object_size ((const void *) __s, 1));
    }
  return __wctomb_alias (__s, __wchar);
}


;; Function mbstowcs (null)
;; enabled by -tree-original


{
  if (__builtin_object_size ((const void *) __dst, 1) != 18446744073709551615)
    {
      if (__builtin_constant_p (__len) == 0)
        {
          return __mbstowcs_chk (__dst, __src, __len, __builtin_object_size ((const void *) __dst, 1) / 4);
        }
      if (__builtin_object_size ((const void *) __dst, 1) / 4 < (long unsigned int) __len)
        {
          return __mbstowcs_chk_warn (__dst, __src, __len, __builtin_object_size ((const void *) __dst, 1) / 4);
        }
    }
  return __mbstowcs_alias (__dst, __src, __len);
}


;; Function wcstombs (null)
;; enabled by -tree-original


{
  if (__builtin_object_size ((const void *) __dst, 1) != 18446744073709551615)
    {
      if (__builtin_constant_p (__len) == 0)
        {
          return __wcstombs_chk (__dst, __src, __len, __builtin_object_size ((const void *) __dst, 1));
        }
      if (__builtin_object_size ((const void *) __dst, 1) < (long unsigned int) __len)
        {
          return __wcstombs_chk_warn (__dst, __src, __len, __builtin_object_size ((const void *) __dst, 1));
        }
    }
  return __wcstombs_alias (__dst, __src, __len);
}


;; Function stat (null)
;; enabled by -tree-original


{
  return __xstat (1, __path, __statbuf);
}


;; Function lstat (null)
;; enabled by -tree-original


{
  return __lxstat (1, __path, __statbuf);
}


;; Function fstat (null)
;; enabled by -tree-original


{
  return __fxstat (1, __fd, __statbuf);
}


;; Function fstatat (null)
;; enabled by -tree-original


{
  return __fxstatat (1, __fd, __filename, __statbuf, __flag);
}


;; Function mknod (null)
;; enabled by -tree-original


{
  return __xmknod (0, __path, __mode, &__dev);
}


;; Function mknodat (null)
;; enabled by -tree-original


{
  return __xmknodat (0, __fd, __path, __mode, &__dev);
}


;; Function discard_cleanups (null)
;; enabled by -tree-original


{
  discard_my_cleanups (&cleanup_chain, old_chain);
}


;; Function discard_final_cleanups (null)
;; enabled by -tree-original


{
  discard_my_cleanups (&final_cleanup_chain, old_chain);
}


;; Function discard_my_cleanups (null)
;; enabled by -tree-original


{
  struct cleanup * ptr;

    struct cleanup * ptr;
  goto <D.3198>;
  <D.3197>:;
  *pmy_chain = ptr->next;
  if (ptr->free_arg != 0B)
    {
      ptr->free_arg (ptr->arg);
    }
  free ((void *) ptr);
  <D.3198>:;
  if ((ptr = *pmy_chain) != old_chain) goto <D.3197>; else goto <D.3199>;
  <D.3199>:;
  printf ((const char * restrict) "freearg: %x\n", ptr->arg);
}


;; Function do_my_cleanups (null)
;; enabled by -tree-original


{
  struct cleanup * ptr;

    struct cleanup * ptr;
  goto <D.3206>;
  <D.3205>:;
  *pmy_chain = ptr->next;
  ptr->function (ptr->arg);
  printf ((const char * restrict) "cleanup!!!!! =========\n");
  printf ((const char * restrict) "%x\n", ptr->arg);
  if (ptr->free_arg != 0B)
    {
      ptr->free_arg (ptr->arg);
    }
  free ((void *) ptr);
  <D.3206>:;
  if ((ptr = *pmy_chain) != old_chain) goto <D.3205>; else goto <D.3207>;
  <D.3207>:;
}


;; Function do_cleanups (null)
;; enabled by -tree-original


{
  do_my_cleanups (&cleanup_chain, old_chain);
}


;; Function make_my_cleanup2 (null)
;; enabled by -tree-original


{
  struct cleanup * new = (struct cleanup *) malloc (32);
  struct cleanup * old_chain = *pmy_chain;

    struct cleanup * new = (struct cleanup *) malloc (32);
    struct cleanup * old_chain = *pmy_chain;
  new->next = *pmy_chain;
  new->function = (void (*<Ted>) (void *)) function;
  new->free_arg = free_arg;
  new->arg = arg;
  *pmy_chain = new;
  if (old_chain == 0B)
    {
      exit (1);
    }
  return old_chain;
}


;; Function make_my_cleanup (null)
;; enabled by -tree-original


{
  return make_my_cleanup2 (pmy_chain, function, arg, 0B);
}


;; Function make_cleanup (null)
;; enabled by -tree-original


{
  return make_my_cleanup (&cleanup_chain, function, arg);
}


;; Function newentry (null)
;; enabled by -tree-original


{
  struct dict_type * new_d = (struct dict_type *) malloc (40);

    struct dict_type * new_d = (struct dict_type *) malloc (40);
  new_d->word = word;
  new_d->next = (struct dict_struct *) root;
  root = new_d;
  new_d->code = (void (*stinst_type) () *) malloc (8);
  new_d->code_length = 1;
  new_d->code_end = 0;
  return new_d;
}


;; Function add_var (null)
;; enabled by -tree-original


{
  struct dict_type * new_d = newentry (name);

    struct dict_type * new_d = newentry (name);
}


;; Function add_to_definition (null)
;; enabled by -tree-original


{
  if (entry->code_end == entry->code_length)
    {
      entry->code_length = entry->code_length + 2;
      entry->code = (void (*stinst_type) () *) realloc ((void *) entry->code, (long unsigned int) entry->code_length * 8);
    }
  *(entry->code + (sizetype) ((long unsigned int) entry->code_end * 8)) = word;
  return (unsigned int) entry->code_end++ ;
}


;; Function nextword (null)
;; enabled by -tree-original


{
  char * word_start;
  int idx;
  char * dst;
  char * src;
  int length = 0;

    char * word_start;
    int idx;
    char * dst;
    char * src;
    int length = 0;
  if (string == 0B)
    {
      return 0B;
    }
  {
    extern int isspace ();

    goto <D.3271>;
    <D.3270>:;
    if (*string == 45)
      {
        goto <D.3268>;
        <D.3267>:;
        string++ ;
        <D.3268>:;
        if (SAVE_EXPR <*string> != 0 && SAVE_EXPR <*string> != 10) goto <D.3267>; else goto <D.3269>;
        <D.3269>:;
      }
    else
      {
        string++ ;
      }
    <D.3271>:;
    if (isspace ((int) (unsigned char) *string) != 0 || *string == 45) goto <D.3270>; else goto <D.3272>;
    <D.3272>:;
  }
  if (*string == 0)
    {
      return 0B;
    }
  word_start = string;
  if (*string == 34)
    {
      <D.3274>:;
      string++ ;
      length++ ;
      if (*string == 92)
        {
          string = string + 2;
          length = length + 2;
        }
      if (*string != 34) goto <D.3274>; else goto <D.3275>;
      <D.3275>:;
    }
  else
    {
      {
        extern int isspace ();

        goto <D.3277>;
        <D.3276>:;
        string++ ;
        length++ ;
        <D.3277>:;
        if (isspace ((int) (unsigned char) *string) == 0) goto <D.3276>; else goto <D.3278>;
        <D.3278>:;
      }
    }
  *word = (char *) malloc ((size_t) (length + 1));
  dst = *word;
  src = word_start;
  idx = 0;
  goto <D.3286>;
  <D.3285>:;
  if (*(src + (sizetype) idx) == 92)
    {
      switch ((int) *(src + ((sizetype) idx + 1)))
        {
          case 110:;
          *dst++  = 10;
          idx++ ;
          goto <D.3281>;
          case 34:;
          case 92:;
          *dst++  = *(src + ((sizetype) idx + 1));
          idx++ ;
          goto <D.3281>;
          default:;
          *dst++  = 92;
          goto <D.3281>;
        }
      <D.3281>:;
    }
  else
    {
      *dst++  = *(src + (sizetype) idx);
    }
  idx++ ;
  <D.3286>:;
  if (idx < length) goto <D.3285>; else goto <D.3287>;
  <D.3287>:;
  *dst++  = 0;
  if (*string != 0)
    {
      return string + 1;
    }
  else
    {
      return 0B;
    }
}


;; Function compile (null)
;; enabled by -tree-original


{
  char * word;

    char * word;
  string = nextword (string, &word);
  goto <D.3311>;
  <D.3310>:;
  printf ((const char * restrict) "string: %s\n", string);
  {
    extern int strcmp ();

    if (strcmp (word, (char *) "var") == 0)
      {
        string = nextword (string, &word);
        add_var (word);
        string = nextword (string, &word);
      }
    else
      {
        if (*word == 58)
          {
            {
              struct dict_type * ptr;

                            struct dict_type * ptr;
              free ((void *) word);
              string = nextword (string, &word);
              ptr = newentry (word);
              string = nextword (string, &word);
              goto <D.3308>;
              <D.3307>:;
              switch ((int) *word)
                {
                  case 34:;
                  add_to_definition (ptr, (void (*<T1d2>) ()) (word + 1));
                  goto <D.3294>;
                  case 48:;
                  case 49:;
                  case 50:;
                  case 51:;
                  case 52:;
                  case 53:;
                  case 54:;
                  case 55:;
                  case 56:;
                  case 57:;
                  printf ((const char * restrict) "%d\n", *(int *) ptr);
                  free ((void *) word);
                  goto <D.3294>;
                  default:;
                  printf ((const char * restrict) "%d\n", *(int *) ptr);
                  free ((void *) word);
                }
              <D.3294>:;
              string = nextword (string, &word);
              if (string == 0B)
                {
                  goto <D.3306>;
                }
              <D.3308>:;
              if (*word != 59) goto <D.3307>; else goto <D.3306>;
              <D.3306>:;
              printf ((const char * restrict) "%d\n", *(int *) ptr);
              string = nextword (string, &word);
            }
          }
        else
          {
            fprintf (stderr, (const char * restrict) "syntax error at %s\n", string + 18446744073709551615);
          }
      }
  }
  <D.3311>:;
  if ((string != 0B && *string != 0) && *word != 0) goto <D.3310>; else goto <D.3312>;
  <D.3312>:;
}


;; Function main (null)
;; enabled by -tree-original


{
  struct dict_type * dict;
  char * string = (char *) "var second : stored_in_dict 5 ; : next";

    struct dict_type * dict;
    char * string = (char *) "var second : stored_in_dict 5 ; : next";
  compile (string);
  dict = root;
  goto <D.3318>;
  <D.3317>:;
  printf ((const char * restrict) "%s\n", dict->word);
  free ((void *) dict->word);
  dict = (struct dict_type *) dict->next;
  <D.3318>:;
  if (dict != 0B) goto <D.3317>; else goto <D.3319>;
  <D.3319>:;
}
return 0;

