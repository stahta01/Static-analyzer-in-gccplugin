
;; Function getchar (null)
;; enabled by -tree-original


{
  return getc (stdin);
}


;; Function fgetc_unlocked (null)
;; enabled by -tree-original


{
  return __builtin_expect (__fp->_IO_read_ptr >= __fp->_IO_read_end, 0) != 0 ? __uflow (__fp) : (int) *(unsigned char *) __fp->_IO_read_ptr++ ;
}


;; Function getc_unlocked (null)
;; enabled by -tree-original


{
  return __builtin_expect (__fp->_IO_read_ptr >= __fp->_IO_read_end, 0) != 0 ? __uflow (__fp) : (int) *(unsigned char *) __fp->_IO_read_ptr++ ;
}


;; Function getchar_unlocked (null)
;; enabled by -tree-original


{
  return __builtin_expect (stdin->_IO_read_ptr >= stdin->_IO_read_end, 0) != 0 ? __uflow (stdin) : (int) *(unsigned char *) stdin->_IO_read_ptr++ ;
}


;; Function putchar (null)
;; enabled by -tree-original


{
  return putc (__c, stdout);
}


;; Function fputc_unlocked (null)
;; enabled by -tree-original


{
  return __builtin_expect (__stream->_IO_write_ptr >= __stream->_IO_write_end, 0) != 0 ? __overflow (__stream, (int) (unsigned char) __c) : (int) (unsigned char) (*__stream->_IO_write_ptr++  = (char) __c);
}


;; Function putc_unlocked (null)
;; enabled by -tree-original


{
  return __builtin_expect (__stream->_IO_write_ptr >= __stream->_IO_write_end, 0) != 0 ? __overflow (__stream, (int) (unsigned char) __c) : (int) (unsigned char) (*__stream->_IO_write_ptr++  = (char) __c);
}


;; Function putchar_unlocked (null)
;; enabled by -tree-original


{
  return __builtin_expect (stdout->_IO_write_ptr >= stdout->_IO_write_end, 0) != 0 ? __overflow (stdout, (int) (unsigned char) __c) : (int) (unsigned char) (*stdout->_IO_write_ptr++  = (char) __c);
}


;; Function feof_unlocked (null)
;; enabled by -tree-original


{
  return (__stream->_flags & 16) != 0;
}


;; Function ferror_unlocked (null)
;; enabled by -tree-original


{
  return (__stream->_flags & 32) != 0;
}


;; Function sprintf (null)
;; enabled by -tree-original


{
  return __builtin___sprintf_chk (__s, 1, __builtin_object_size ((const void *) __s, 1), __fmt, __builtin_va_arg_pack ());
}


;; Function vsprintf (null)
;; enabled by -tree-original


{
  return __builtin___vsprintf_chk (__s, 1, __builtin_object_size ((const void *) __s, 1), __fmt, __ap);
}


;; Function snprintf (null)
;; enabled by -tree-original


{
  return __builtin___snprintf_chk (__s, __n, 1, __builtin_object_size ((const void *) __s, 1), __fmt, __builtin_va_arg_pack ());
}


;; Function vsnprintf (null)
;; enabled by -tree-original


{
  return __builtin___vsnprintf_chk (__s, __n, 1, __builtin_object_size ((const void *) __s, 1), __fmt, __ap);
}


;; Function fprintf (null)
;; enabled by -tree-original


{
  return __fprintf_chk (__stream, 1, __fmt, __builtin_va_arg_pack ());
}


;; Function printf (null)
;; enabled by -tree-original


{
  return __printf_chk (1, __fmt, __builtin_va_arg_pack ());
}


;; Function vprintf (null)
;; enabled by -tree-original


{
  return __vfprintf_chk (stdout, 1, __fmt, __ap);
}


;; Function vfprintf (null)
;; enabled by -tree-original


{
  return __vfprintf_chk (__stream, 1, __fmt, __ap);
}


;; Function dprintf (null)
;; enabled by -tree-original


{
  return __dprintf_chk (__fd, 1, __fmt, __builtin_va_arg_pack ());
}


;; Function vdprintf (null)
;; enabled by -tree-original


{
  return __vdprintf_chk (__fd, 1, __fmt, __ap);
}


;; Function fgets (null)
;; enabled by -tree-original


{
  if (__builtin_object_size ((const void *) __s, 1) != 18446744073709551615)
    {
      if (__builtin_constant_p (__n) == 0 || __n <= 0)
        {
          return __fgets_chk (__s, __builtin_object_size ((const void *) __s, 1), __n, __stream);
        }
      if ((long unsigned int) __n > __builtin_object_size ((const void *) __s, 1))
        {
          return __fgets_chk_warn (__s, __builtin_object_size ((const void *) __s, 1), __n, __stream);
        }
    }
  return __fgets_alias (__s, __n, __stream);
}


;; Function fread (null)
;; enabled by -tree-original


{
  if (__builtin_object_size ((const void *) __ptr, 0) != 18446744073709551615)
    {
      if ((__builtin_constant_p (__size) == 0 || __builtin_constant_p (__n) == 0) || (__size | __n) > 4294967295)
        {
          return __fread_chk (__ptr, __builtin_object_size ((const void *) __ptr, 0), __size, __n, __stream);
        }
      if ((long unsigned int) (__size * __n) > __builtin_object_size ((const void *) __ptr, 0))
        {
          return __fread_chk_warn (__ptr, __builtin_object_size ((const void *) __ptr, 0), __size, __n, __stream);
        }
    }
  return __fread_alias (__ptr, __size, __n, __stream);
}


;; Function fread_unlocked (null)
;; enabled by -tree-original


{
  if (__builtin_object_size ((const void *) __ptr, 0) != 18446744073709551615)
    {
      if ((__builtin_constant_p (__size) == 0 || __builtin_constant_p (__n) == 0) || (__size | __n) > 4294967295)
        {
          return __fread_unlocked_chk (__ptr, __builtin_object_size ((const void *) __ptr, 0), __size, __n, __stream);
        }
      if ((long unsigned int) (__size * __n) > __builtin_object_size ((const void *) __ptr, 0))
        {
          return __fread_unlocked_chk_warn (__ptr, __builtin_object_size ((const void *) __ptr, 0), __size, __n, __stream);
        }
    }
  if (((__builtin_constant_p (__size) != 0 && __builtin_constant_p (__n) != 0) && (__size | __n) <= 4294967295) && __size * __n <= 8)
    {
      {
        size_t __cnt = __size * __n;
        char * __cptr = (char *) __ptr;

                size_t __cnt = __size * __n;
                char * __cptr = (char *) __ptr;
        if (__cnt == 0)
          {
            return 0;
          }
        goto <D.2378>;
        <D.2377>:;
        {
          int __c = getc_unlocked (__stream);

                    int __c = getc_unlocked (__stream);
          if (__c == -1)
            {
              goto <D.2376>;
            }
          *__cptr++  = (char) __c;
        }
         --__cnt;
        <D.2378>:;
        if (__cnt != 0) goto <D.2377>; else goto <D.2376>;
        <D.2376>:;
        return (size_t) ((long unsigned int) ((long int) __cptr - (long int) __ptr) / (long unsigned int) __size);
      }
    }
  return __fread_unlocked_alias (__ptr, __size, __n, __stream);
}


;; Function atoi (null)
;; enabled by -tree-original


{
  return (int) strtol (__nptr, 0B, 10);
}


;; Function atol (null)
;; enabled by -tree-original


{
  return strtol (__nptr, 0B, 10);
}


;; Function atoll (null)
;; enabled by -tree-original


{
  return strtoll (__nptr, 0B, 10);
}


;; Function __bswap_16 (null)
;; enabled by -tree-original


{
  return (__uint16_t) __builtin_bswap16 ((int) __bsx);
}


;; Function __bswap_32 (null)
;; enabled by -tree-original


{
  return (__uint32_t) __builtin_bswap32 (__bsx);
}


;; Function __bswap_64 (null)
;; enabled by -tree-original


{
  return (__uint64_t) __builtin_bswap64 (__bsx);
}


;; Function __uint16_identity (null)
;; enabled by -tree-original


{
  return __x;
}


;; Function __uint32_identity (null)
;; enabled by -tree-original


{
  return __x;
}


;; Function __uint64_identity (null)
;; enabled by -tree-original


{
  return __x;
}


;; Function bsearch (null)
;; enabled by -tree-original


{
  size_t __l;
  size_t __u;
  size_t __idx;
  const void * __p;
  int __comparison;

    size_t __l;
    size_t __u;
    size_t __idx;
    const void * __p;
    int __comparison;
  __l = 0;
  __u = __nmemb;
  goto <D.2819>;
  <D.2818>:;
  __idx = (__l + __u) / 2;
  __p = __base + (sizetype) (__idx * __size);
  __comparison = __compar (__key, __p);
  if (__comparison < 0)
    {
      __u = __idx;
    }
  else
    {
      if (__comparison > 0)
        {
          __l = __idx + 1;
        }
      else
        {
          return (void *) __p;
        }
    }
  <D.2819>:;
  if (__l < __u) goto <D.2818>; else goto <D.2820>;
  <D.2820>:;
  return 0B;
}


;; Function atof (null)
;; enabled by -tree-original


{
  return strtod (__nptr, 0B);
}


;; Function realpath (null)
;; enabled by -tree-original


{
  if (__builtin_object_size ((const void *) __resolved, 1) != 18446744073709551615)
    {
      return __realpath_chk (__name, __resolved, __builtin_object_size ((const void *) __resolved, 1));
    }
  return __realpath_alias (__name, __resolved);
}


;; Function ptsname_r (null)
;; enabled by -tree-original


{
  if (__builtin_object_size ((const void *) __buf, 1) != 18446744073709551615)
    {
      if (__builtin_constant_p (__buflen) == 0)
        {
          return __ptsname_r_chk (__fd, __buf, __buflen, __builtin_object_size ((const void *) __buf, 1));
        }
      if (__builtin_object_size ((const void *) __buf, 1) < (long unsigned int) __buflen)
        {
          return __ptsname_r_chk_warn (__fd, __buf, __buflen, __builtin_object_size ((const void *) __buf, 1));
        }
    }
  return __ptsname_r_alias (__fd, __buf, __buflen);
}


;; Function wctomb (null)
;; enabled by -tree-original


{
  if (__builtin_object_size ((const void *) __s, 1) != 18446744073709551615 && __builtin_object_size ((const void *) __s, 1) <= 15)
    {
      return __wctomb_chk (__s, __wchar, __builtin_object_size ((const void *) __s, 1));
    }
  return __wctomb_alias (__s, __wchar);
}


;; Function mbstowcs (null)
;; enabled by -tree-original


{
  if (__builtin_object_size ((const void *) __dst, 1) != 18446744073709551615)
    {
      if (__builtin_constant_p (__len) == 0)
        {
          return __mbstowcs_chk (__dst, __src, __len, __builtin_object_size ((const void *) __dst, 1) / 4);
        }
      if (__builtin_object_size ((const void *) __dst, 1) / 4 < (long unsigned int) __len)
        {
          return __mbstowcs_chk_warn (__dst, __src, __len, __builtin_object_size ((const void *) __dst, 1) / 4);
        }
    }
  return __mbstowcs_alias (__dst, __src, __len);
}


;; Function wcstombs (null)
;; enabled by -tree-original


{
  if (__builtin_object_size ((const void *) __dst, 1) != 18446744073709551615)
    {
      if (__builtin_constant_p (__len) == 0)
        {
          return __wcstombs_chk (__dst, __src, __len, __builtin_object_size ((const void *) __dst, 1));
        }
      if (__builtin_object_size ((const void *) __dst, 1) < (long unsigned int) __len)
        {
          return __wcstombs_chk_warn (__dst, __src, __len, __builtin_object_size ((const void *) __dst, 1));
        }
    }
  return __wcstombs_alias (__dst, __src, __len);
}


;; Function stat (null)
;; enabled by -tree-original


{
  return __xstat (1, __path, __statbuf);
}


;; Function lstat (null)
;; enabled by -tree-original


{
  return __lxstat (1, __path, __statbuf);
}


;; Function fstat (null)
;; enabled by -tree-original


{
  return __fxstat (1, __fd, __statbuf);
}


;; Function fstatat (null)
;; enabled by -tree-original


{
  return __fxstatat (1, __fd, __filename, __statbuf, __flag);
}


;; Function mknod (null)
;; enabled by -tree-original


{
  return __xmknod (0, __path, __mode, &__dev);
}


;; Function mknodat (null)
;; enabled by -tree-original


{
  return __xmknodat (0, __fd, __path, __mode, &__dev);
}


;; Function copy_array (null)
;; enabled by -tree-original


{
  if (n != 0)
    {
      {
        extern void * memcpy (void *, const void *, long unsigned int);
        extern int st_mult ();

        memcpy (dst, src, (long unsigned int) st_mult (size, n));
      }
    }
}


;; Function move_array (null)
;; enabled by -tree-original


{
  if (n != 0)
    {
      {
        extern void * memmove (void *, const void *, long unsigned int);
        extern int st_mult ();

        memmove (dst, src, (long unsigned int) st_mult (size, n));
      }
    }
}


;; Function xstrdup_or_null (null)
;; enabled by -tree-original


{
  extern char * strdup (const char *);

  return str != 0B ? strdup (str) : 0B;
}


;; Function strbuf_swap (null)
;; enabled by -tree-original


{
  {
    void * _swap_a_ptr = (void *) a;
    void * _swap_b_ptr = (void *) b;
    unsigned char _swap_buffer[24];
    extern void * memcpy (void *, const void *, long unsigned int);

        void * _swap_a_ptr = (void *) a;
        void * _swap_b_ptr = (void *) b;
        unsigned char _swap_buffer[24];
    memcpy ((void *) &_swap_buffer, (const void *) _swap_a_ptr, 24);
    memcpy (_swap_a_ptr, (const void *) _swap_b_ptr, 24);
    memcpy (_swap_b_ptr, (const void *) &_swap_buffer, 24);
  }
}


;; Function xrealloc (null)
;; enabled by -tree-original


{
  void * ret;

    void * ret;
  ret = realloc (ptr, size);
  if (ret == 0B && size == 0)
    {
      ret = realloc (ptr, 1);
    }
  if (ret == 0B)
    {
      ret = realloc (ptr, size);
      if (ret == 0B && size == 0)
        {
          ret = realloc (ptr, 1);
        }
      if (ret == 0B)
        {
          printf ((const char * restrict) "Out of memory, realloc failed%s", (char *) "");
          exit (1);
        }
    }
  return ret;
}


;; Function strbuf_grow (null)
;; enabled by -tree-original


{
  int new_buf = sb->alloc == 0;

    int new_buf = sb->alloc == 0;
  {
    extern int unsigned_add_overflows ();

    if (unsigned_add_overflows (extra, 1) != 0 || unsigned_add_overflows (sb->len, extra + 1) != 0)
      {
        printf ((const char * restrict) "you want to use way too much memory%s", (char *) "");
        exit (1);
      }
  }
  if (new_buf != 0)
    {
      sb->buf = 0B;
    }
  if ((sb->len + extra) + 1 > sb->alloc)
    {
      {
        extern int st_mult ();

        {
          extern int alloc_nr ();

          if ((size_t) alloc_nr (sb->alloc) < (sb->len + extra) + 1)
            {
              sb->alloc = (sb->len + extra) + 1;
            }
          else
            {
              sb->alloc = (size_t) alloc_nr (sb->alloc);
            }
        }
        sb->buf = (char *) xrealloc ((void *) sb->buf, (size_t) st_mult (1, sb->alloc));
      }
    }
  if (new_buf != 0)
    {
      *sb->buf = 0;
    }
}


;; Function strbuf_release (null)
;; enabled by -tree-original


{
  if (sb->alloc != 0)
    {
      {
        extern int strbuf_init ();

        free ((void *) sb->buf);
        strbuf_init (sb, 0);
      }
    }
}


;; Function strbuf_readlink (null)
;; enabled by -tree-original


{
  size_t oldalloc = sb->alloc;

    size_t oldalloc = sb->alloc;
  if (hint <= 31)
    {
      hint = 32;
    }
  goto <D.3479>;
  <D.3478>:;
  {
    int len;
    extern int readlink ();

        int len;
    strbuf_grow (sb, hint);
    len = readlink (path, sb->buf, hint);
    if (len < 0)
      {
        if (*__errno_location () != 34)
          {
            goto <D.3474>;
          }
      }
    else
      {
        if ((size_t) len < hint)
          {
            {
              extern int strbuf_setlen ();

              strbuf_setlen (sb, len);
              return 0;
            }
          }
      }
    hint = hint * 2;
  }
  <D.3479>:;
  if (hint <= 8191) goto <D.3478>; else goto <D.3474>;
  <D.3474>:;
  if (oldalloc == 0)
    {
      strbuf_release (sb);
    }
  return -1;
}


;; Function files_read_raw_ref (null)
;; enabled by -tree-original


{
  struct files_ref_store * refs = (struct files_ref_store *) (long int) files_downcast (ref_store, 1, (char *) "read_raw_ref");
  extern int files_downcast ();
  struct strbuf sb_contents = {.alloc=0, .len=0, .buf=(char *) &strbuf_slopbuf};
  struct strbuf sb_path = {.alloc=0, .len=0, .buf=(char *) &strbuf_slopbuf};
  const char * path;
  const char * buf;
  int fd;
  int ret = -1;
  int save_errno;
  int remaining_retries = 3;
  struct stat st;
  extern int strbuf_reset ();
  extern int files_ref_path ();
  void stat_ref = <<< error >>>;
  void out = <<< error >>>;
  extern int strbuf_rtrim ();

    struct files_ref_store * refs = (struct files_ref_store *) (long int) files_downcast (ref_store, 1, (char *) "read_raw_ref");
    struct strbuf sb_contents = {.alloc=0, .len=0, .buf=(char *) &strbuf_slopbuf};
    struct strbuf sb_path = {.alloc=0, .len=0, .buf=(char *) &strbuf_slopbuf};
    const char * path;
    const char * buf;
    int fd;
    int ret = -1;
    int save_errno;
    int remaining_retries = 3;
    struct stat st;
  *type = 0;
  strbuf_reset (&sb_path);
  files_ref_path (refs, &sb_path, refname);
  path = (const char *) sb_path.buf;
  stat_ref:;
  if (remaining_retries--  <= 0)
    {
      goto out;
    }
  if (lstat (path, &st) < 0)
    {
      if (*__errno_location () != 2)
        {
          goto out;
        }
      {
        extern int resolve_packed_ref ();

        if (resolve_packed_ref (refs, refname, sha1, type) != 0)
          {
            *__errno_location () = 2;
            goto out;
          }
      }
      ret = 0;
      goto out;
    }
  strbuf_reset (&sb_contents);
  if (strbuf_readlink (&sb_contents, path, 0) < 0)
    {
      if (SAVE_EXPR <*__errno_location ()> == 2 || SAVE_EXPR <*__errno_location ()> == 22) goto stat_ref; else goto out;
    }
  {
    extern int starts_with ();
    extern int check_refname_format ();

    if (starts_with (sb_contents.buf, (char *) "refs/") != 0 && check_refname_format (sb_contents.buf, 0) == 0)
      {
        strbuf_swap (&sb_contents, referent);
        *type = *type | 1;
        ret = 0;
        goto out;
      }
  }
  strbuf_reset (&sb_contents);
  {
    extern int strbuf_read ();

    if (strbuf_read (&sb_contents, fd, 256) < 0)
      {
        {
          int save_errno = *__errno_location ();
          extern int close ();

                    int save_errno = *__errno_location ();
          close (fd);
          *__errno_location () = save_errno;
          goto out;
        }
      }
  }
  strbuf_rtrim (&sb_contents);
  buf = (const char *) sb_contents.buf;
  {
    extern int starts_with ();

    if (starts_with (buf, (char *) "ref:") != 0)
      {
        {
          extern int strbuf_addstr ();

          buf = buf + 4;
          {
            extern int isspace ();

            goto <D.3515>;
            <D.3514>:;
            buf++ ;
            <D.3515>:;
            if (isspace ((int) *buf) != 0) goto <D.3514>; else goto <D.3516>;
            <D.3516>:;
          }
          strbuf_reset (referent);
          strbuf_addstr (referent, buf);
          *type = *type | 1;
          ret = 0;
          goto out;
        }
      }
  }
  {
    extern int get_sha1_hex ();
    extern int isspace ();

    if (get_sha1_hex (buf, sha1) != 0 || *(buf + 40) != 0 && isspace ((int) *(buf + 40)) == 0)
      {
        *type = *type | 4;
        *__errno_location () = 22;
        goto out;
      }
  }
  ret = 0;
  out:;
  save_errno = *__errno_location ();
  strbuf_release (&sb_path);
  strbuf_release (&sb_contents);
  *__errno_location () = save_errno;
  return ret;
}


;; Function lock_raw_ref (null)
;; enabled by -tree-original


{
  struct ref_lock * lock;
  struct strbuf ref_file = {.alloc=0, .len=0, .buf=(char *) &strbuf_slopbuf};
  int attempts_remaining = 3;
  int ret = -2;
  extern char * strdup (const char *);
  extern int files_ref_path ();
  void error_return = <<< error >>>;
  void out = <<< error >>>;
  extern int unlock_ref ();

    struct ref_lock * lock;
    struct strbuf ref_file = {.alloc=0, .len=0, .buf=(char *) &strbuf_slopbuf};
    int attempts_remaining = 3;
    int ret = -2;
  *type = 0;
  *lock_p = lock = (struct ref_lock *) calloc (1, 40);
  lock->ref_name = strdup (refname);
  files_ref_path (refs, &ref_file, refname);
  if (files_read_raw_ref (&refs->base, refname, (unsigned char *) &lock->old_oid.hash, referent, type) != 0)
    {
      if (*__errno_location () == 2)
        {
          if (mustexist != 0)
            {
              {
                extern int strbuf_addf ();

                strbuf_addf (err, (char *) "unable to resolve reference \'%s\'", refname);
                goto error_return;
              }
            }
        }
    }
  ret = 0;
  goto out;
  error_return:;
  unlock_ref (lock);
  *lock_p = 0B;
  out:;
  strbuf_release (&ref_file);
  return ret;
}


;; Function lock_ref_for_update (null)
;; enabled by -tree-original


{
  struct strbuf referent = {.alloc=0, .len=0, .buf=(char *) &strbuf_slopbuf};
  int mustexist;
  int ret;
  struct ref_lock * lock;

    struct strbuf referent = {.alloc=0, .len=0, .buf=(char *) &strbuf_slopbuf};
    int mustexist;
    int ret;
    struct ref_lock * lock;
  if (head_ref != 0B)
    {
      {
        extern int split_head_update ();

        ret = split_head_update (update, transaction, head_ref, affected_refnames, err);
        if (ret != 0)
          {
            return ret;
          }
      }
    }
  ret = lock_raw_ref (refs, (const char *) &update->refname, mustexist, (const struct string_list *) affected_refnames, 0B, &lock, &referent, &update->type, err);
  if (ret != 0)
    {
      {
        char * reason;
        extern int strbuf_detach ();
        extern int strbuf_addf ();
        extern int original_update_refname ();

                char * reason;
        reason = (char *) (long int) strbuf_detach (err, 0B);
        strbuf_addf (err, (char *) "cannot lock ref \'%s\': %s", original_update_refname (update), reason);
        free ((void *) reason);
        return ret;
      }
    }
  update->backend_data = (void *) lock;
  if ((update->type & 1) != 0)
    {
      if ((update->flags & 1) != 0)
        {
          {
            extern int refs_read_ref_full ();

            if (refs_read_ref_full (&refs->base, referent.buf, 0, (unsigned char *) &lock->old_oid.hash, 0B) != 0)
              {
                if ((update->flags & 16) != 0)
                  {
                    {
                      extern int strbuf_addf ();
                      extern int original_update_refname ();

                      strbuf_addf (err, (char *) "cannot lock ref \'%s\': error reading reference", original_update_refname (update));
                      return -1;
                    }
                  }
              }
            else
              {
                {
                  extern int check_old_oid ();

                  if (check_old_oid (update, &lock->old_oid, err) != 0)
                    {
                      return -2;
                    }
                }
              }
          }
        }
      else
        {
          {
            extern int split_symref_update ();

            ret = split_symref_update (refs, update, referent.buf, transaction, affected_refnames, err);
            if (ret != 0)
              {
                return ret;
              }
          }
        }
    }
  else
    {
      {
        struct ref_update * parent_update;

                struct ref_update * parent_update;
        {
          extern int check_old_oid ();

          if (check_old_oid (update, &lock->old_oid, err) != 0)
            {
              return -2;
            }
        }
      }
    }
  if ((BIT_FIELD_REF <*update, 32, 320> & 138) == 8)
    {
      {
        extern int oidcmp ();

        if ((update->type & 1) == 0 && oidcmp (&lock->old_oid, &update->new_oid) == 0)
          {
            
          }
        else
          {
            {
              extern int write_ref_to_lockfile ();

              if (write_ref_to_lockfile (lock, &update->new_oid, err) != 0)
                {
                  {
                    char * write_err = (char *) (long int) strbuf_detach (err, 0B);
                    extern int strbuf_detach ();

                                        char * write_err = (char *) (long int) strbuf_detach (err, 0B);
                    update->backend_data = 0B;
                    return -2;
                  }
                }
              else
                {
                  update->flags = update->flags | 32;
                }
            }
          }
      }
    }
  if ((update->flags & 32) == 0)
    {
      {
        extern int close_ref ();

        if (close_ref (lock) != 0)
          {
            return -2;
          }
      }
    }
  return 0;
}


;; Function main (null)
;; enabled by -tree-original


{
  struct files_ref_store refs;
  struct ref_update update;
  struct ref_transaction transaction;
  char * head_ref;
  struct string_list affected_refnames;
  struct strbuf err;

    struct files_ref_store refs;
    struct ref_update update;
    struct ref_transaction transaction;
    char * head_ref;
    struct string_list affected_refnames;
    struct strbuf err;
  lock_ref_for_update (&refs, &update, &transaction, (const char *) head_ref, &affected_refnames, &err);
  return 0;
}
return 0;

