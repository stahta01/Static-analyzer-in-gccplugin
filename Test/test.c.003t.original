
;; Function xrealloc (null)
;; enabled by -tree-original


{
  void * ret;

    void * ret;
  ret = realloc (ptr, size);
  if (ret == 0B)
    {
      if (size == 0)
        {
          ret = realloc (ptr, 1);
        }
    }
  if (ret == 0B)
    {
      ret = realloc (ptr, size);
      if (ret == 0B)
        {
          if (size == 0)
            {
              ret = realloc (ptr, 1);
            }
        }
      if (ret == 0B)
        {
          printf ((const char *) "Out of memory, realloc failed%s", (char *) "");
          exit (1);
        }
    }
  return ret;
}


;; Function update_tree_entry_internal (null)
;; enabled by -tree-original


{
  const void * buf;
  const unsigned char * end;
  long unsigned int size;
  long unsigned int len;
  int tmp;

    const void * buf;
    const unsigned char * end;
    long unsigned int size;
    long unsigned int len;
    int tmp;
  buf = desc->buffer;
  end = (const unsigned char *) &desc->entry.oid->hash + 20;
  size = (long unsigned int) desc->size;
  len = (long unsigned int) ((long int) end - (long int) buf);
  if (size < len)
    {
      printf ((const char *) "too-short tree file%s", buf);
      exit (1);
    }
  buf = (const void *) end;
  size = size - len;
  desc->buffer = buf;
  desc->size = (unsigned int) size;
  if (size != 0)
    {
      tmp = decode_tree_entry (desc, buf, size, err);
      return tmp;
    }
  return 0;
}


;; Function update_tree_entry (null)
;; enabled by -tree-original


{
  struct strbuf err;
  int tmp;

    struct strbuf err;
    int tmp;
  err.alloc = 0;
  err.len = 0;
  err.buf = (char *) &strbuf_slopbuf;
  tmp = update_tree_entry_internal (desc, &err);
  if (tmp != 0)
    {
      printf ((const char *) "%s", err.buf);
      exit (1);
    }
  strbuf_release (&err);
  return;
}


;; Function extended_entry_extract (null)
;; enabled by -tree-original


{
  struct tree_desc_skip * skip;

    struct tree_desc_skip * skip;
  <D.2002>:;
  if (t->d.size == 0)
    {
      entry_clear (a);
      goto <D.1998>;
    }
  entry_extract (&t->d, a);
  skip = t->skip;
  goto <D.2001>;
  <D.2000>:;
  if ((long unsigned int) a->path == (long unsigned int) skip->ptr)
    {
      goto <D.1999>;
    }
  skip = skip->prev;
  <D.2001>:;
  if (skip != 0B) goto <D.2000>; else goto <D.1999>;
  <D.1999>:;
  if (skip == 0B)
    {
      goto <D.1998>;
    }
  update_tree_entry (&t->d);
  goto <D.2002>;
  <D.1998>:;
  return;
}


;; Function traverse_trees (null)
;; enabled by -tree-original


{
  int i;
  int n___0;
  struct tree_desc_x * tx;
  void * tmp;
  struct name_entry * entry;
  void * tmp___0;
  struct name_entry * e;

    int i;
    int n___0;
    struct tree_desc_x * tx;
    void * tmp;
    struct name_entry * entry;
    void * tmp___0;
    struct name_entry * e;
  tmp = calloc ((long unsigned int) n___0, 48);
  tx = (struct tree_desc_x *) tmp;
  tmp___0 = malloc ((long unsigned int) n___0 * 24);
  entry = (struct name_entry *) tmp___0;
  e = 0B;
  i = 0;
  goto <D.2016>;
  <D.2015>:;
  (tx + (sizetype) ((long unsigned int) i * 48))->d = *(t + (sizetype) ((long unsigned int) i * 40));
  i++ ;
  <D.2016>:;
  if (i < n___0) goto <D.2015>; else goto <D.2017>;
  <D.2017>:;
  i = 0;
  goto <D.2019>;
  <D.2018>:;
  e = entry + (sizetype) ((long unsigned int) i * 24);
  extended_entry_extract (tx + (sizetype) ((long unsigned int) i * 48), e, 0B, 0);
  i++ ;
  <D.2019>:;
  if (i < n___0) goto <D.2018>; else goto <D.2020>;
  <D.2020>:;
  free ((void *) tx);
  return 1;
}


;; Function unpack_trees (null)
;; enabled by -tree-original


{
  traverse_trees ((int) len, t, 0B);
  return 0;
}


;; Function init_tree_desc_internal (null)
;; enabled by -tree-original


{
  int tmp;

    int tmp;
  desc->buffer = buffer;
  desc->size = (unsigned int) size;
  if (size != 0)
    {
      tmp = decode_tree_entry (desc, buffer, size, err);
      return tmp;
    }
  return 0;
}


;; Function init_tree_desc (null)
;; enabled by -tree-original


{
  struct strbuf err;
  int tmp;

    struct strbuf err;
    int tmp;
  err.alloc = 0;
  err.len = 0;
  err.buf = (char *) &strbuf_slopbuf;
  tmp = init_tree_desc_internal (desc, buffer, size, &err);
  if (tmp != 0)
    {
      printf ((const char *) "%s", err.buf);
      exit (1);
    }
  strbuf_release (&err);
  return;
}


;; Function fill_tree_descriptor (null)
;; enabled by -tree-original


{
  long unsigned int size;
  void * buf;
  int tmp;

    long unsigned int size;
    void * buf;
    int tmp;
  size = 0;
  buf = 0B;
  if (oid != 0B)
    {
      buf = malloc (100);
      if (buf == 0B)
        {
          tmp = oid_to_hex (oid);
          printf ((const char *) "unable to read tree %s", tmp);
          exit (1);
        }
    }
  init_tree_desc (desc, (const void *) buf, size);
  return;
}


;; Function reset_index (null)
;; enabled by -tree-original


{
  int nr;
  struct tree_desc desc[2];
  struct tree * tree;
  struct unpack_trees_options opts;
  struct object_id head_oid;
  int tmp;
  int tmp___0;
  int tmp___1;
  int tmp___2;
  int tmp___3;

    int nr;
    struct tree_desc desc[2];
    struct tree * tree;
    struct unpack_trees_options opts;
    struct object_id head_oid;
    int tmp;
    int tmp___0;
    int tmp___1;
    int tmp___2;
    int tmp___3;
  nr = 0;
  memset (&opts, 0, 640);
  opts.head_idx = 1;
  opts.src_index = &the_index;
  opts.dst_index = &the_index;
  opts.fn = oneway_merge;
  opts.merge = 1;
  if (quiet == 0)
    {
      opts.verbose_update = 1;
    }
  switch (reset_type)
    {
      case 3:;
      case 4:;
      opts.update = 1;
      goto <D.2072>;
      case 2:;
      opts.update = 1;
      default:;
      opts.reset = 1;
    }
  <D.2072>:;
  read_cache_unmerged ();
  if (reset_type == 4)
    {
      tmp___1 = get_oid ((char *) "HEAD", &head_oid);
      if (tmp___1 != 0)
        {
          tmp = _ ((char *) "You do not have a valid HEAD.");
          tmp___0 = error (tmp);
          return tmp___0;
        }
      fill_tree_descriptor ((struct tree_desc *) &desc + (sizetype) ((long unsigned int) nr * 40), (const struct object_id *) &head_oid);
      nr++ ;
      opts.fn = twoway_merge;
    }
  fill_tree_descriptor ((struct tree_desc *) &desc + (sizetype) ((long unsigned int) nr * 40), oid);
  nr++ ;
  printf ((const char *) "%d\n", desc[nr].buffer);
  tmp___2 = unpack_trees ((unsigned int) nr, (struct tree_desc *) &desc, &opts);
  if (tmp___2 != 0)
    {
      return -1;
    }
  if (reset_type == 0)
    {
      tmp___3 = parse_tree_indirect (oid);
      tree = (struct tree *) (long int) tmp___3;
      prime_cache_tree (&the_index, tree);
    }
  else
    {
      if (reset_type == 2)
        {
          tmp___3 = parse_tree_indirect (oid);
          tree = (struct tree *) (long int) tmp___3;
          prime_cache_tree (&the_index, tree);
        }
    }
  return 0;
}


;; Function main (null)
;; enabled by -tree-original


{
  struct object_id oid;
  int type;
  int quiet;

    struct object_id oid;
    int type;
    int quiet;
  reset_index ((const struct object_id *) &oid, type, quiet);
  return 0;
}
return 0;

