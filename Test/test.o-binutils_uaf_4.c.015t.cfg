
;; Function discard_cleanups (discard_cleanups, funcdef_no=22, decl_uid=3018, cgraph_uid=23, symbol_order=27)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
void discard_cleanups (struct cleanup * old_chain)
{
  <bb 2> :
  discard_my_cleanups (&cleanup_chain, old_chain);
  return;

}



;; Function discard_final_cleanups (discard_final_cleanups, funcdef_no=23, decl_uid=3023, cgraph_uid=24, symbol_order=28)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
void discard_final_cleanups (struct cleanup * old_chain)
{
  <bb 2> :
  discard_my_cleanups (&final_cleanup_chain, old_chain);
  return;

}



;; Function discard_my_cleanups (discard_my_cleanups, funcdef_no=24, decl_uid=3021, cgraph_uid=25, symbol_order=29)

;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7
;;
;; Loop 1
;;  header 6, latch 5
;;  depth 1, outer 0
;;  nodes: 6 5 3 4
;; 2 succs { 6 }
;; 3 succs { 4 5 }
;; 4 succs { 5 }
;; 5 succs { 6 }
;; 6 succs { 3 7 }
;; 7 succs { 1 }
void discard_my_cleanups (struct cleanup * * pmy_chain, struct cleanup * old_chain)
{
  struct cleanup * ptr;

  <bb 2> :
  goto <bb 6>; [INV]

  <bb 3> :
  _1 = ptr->next;
  *pmy_chain = _1;
  _2 = ptr->free_arg;
  if (_2 != 0B)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  _3 = ptr->free_arg;
  _4 = ptr->arg;
  _3 (_4);

  <bb 5> :
  free (ptr);

  <bb 6> :
  ptr = *pmy_chain;
  if (ptr != old_chain)
    goto <bb 3>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  _5 = ptr->arg;
  printf ("freearg: %x\n", _5);
  return;

}



;; Function do_cleanups (do_cleanups, funcdef_no=26, decl_uid=3028, cgraph_uid=27, symbol_order=31)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
void do_cleanups (struct cleanup * old_chain)
{
  <bb 2> :
  do_my_cleanups (&cleanup_chain, old_chain);
  return;

}



;; Function do_my_cleanups (do_my_cleanups, funcdef_no=25, decl_uid=3026, cgraph_uid=26, symbol_order=30)

;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7
;;
;; Loop 1
;;  header 6, latch 5
;;  depth 1, outer 0
;;  nodes: 6 5 3 4
;; 2 succs { 6 }
;; 3 succs { 4 5 }
;; 4 succs { 5 }
;; 5 succs { 6 }
;; 6 succs { 3 7 }
;; 7 succs { 1 }
void do_my_cleanups (struct cleanup * * pmy_chain, struct cleanup * old_chain)
{
  struct cleanup * ptr;

  <bb 2> :
  goto <bb 6>; [INV]

  <bb 3> :
  _1 = ptr->next;
  *pmy_chain = _1;
  _2 = ptr->function;
  _3 = ptr->arg;
  _2 (_3);
  __builtin_puts (&"cleanup!!!!! ========="[0]);
  _4 = ptr->arg;
  printf ("%x\n", _4);
  _5 = ptr->free_arg;
  if (_5 != 0B)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  _6 = ptr->free_arg;
  _7 = ptr->arg;
  _6 (_7);

  <bb 5> :
  free (ptr);

  <bb 6> :
  ptr = *pmy_chain;
  if (ptr != old_chain)
    goto <bb 3>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  return;

}



;; Function make_cleanup (make_cleanup, funcdef_no=29, decl_uid=3041, cgraph_uid=30, symbol_order=34)

Merging blocks 2 and 3
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
struct cleanup * make_cleanup (void (*<T59c>) (void *) function, void * arg)
{
  struct cleanup * D.3328;

  <bb 2> :
  D.3328 = make_my_cleanup (&cleanup_chain, function, arg);
  return D.3328;

}



;; Function make_my_cleanup (make_my_cleanup, funcdef_no=28, decl_uid=3038, cgraph_uid=29, symbol_order=33)

Merging blocks 2 and 3
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
struct cleanup * make_my_cleanup (struct cleanup * * pmy_chain, void (*<T59c>) (void *) function, void * arg)
{
  struct cleanup * D.3330;

  <bb 2> :
  D.3330 = make_my_cleanup2 (pmy_chain, function, arg, 0B);
  return D.3330;

}



;; Function make_my_cleanup2 (make_my_cleanup2, funcdef_no=27, decl_uid=3034, cgraph_uid=28, symbol_order=32)

Merging blocks 4 and 5
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4
;; 2 succs { 3 4 }
;; 3 succs { }
;; 4 succs { 1 }
struct cleanup * make_my_cleanup2 (struct cleanup * * pmy_chain, void (*<T59c>) (void *) function, void * arg, void (*<Tee>) (void *) free_arg)
{
  struct cleanup * old_chain;
  struct cleanup * new;
  struct cleanup * D.3334;

  <bb 2> :
  new = malloc (32);
  old_chain = *pmy_chain;
  _1 = *pmy_chain;
  new->next = _1;
  new->function = function;
  new->free_arg = free_arg;
  new->arg = arg;
  *pmy_chain = new;
  if (old_chain == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  exit (1);

  <bb 4> :
  D.3334 = old_chain;
  return D.3334;

}



;; Function free_so (free_so, funcdef_no=30, decl_uid=3270, cgraph_uid=31, symbol_order=35)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
void free_so (struct so_list * so)
{
  <bb 2> :
  free (so);
  return;

}



;; Function make_cleanup_free_so (make_cleanup_free_so, funcdef_no=32, decl_uid=3277, cgraph_uid=33, symbol_order=37)

Merging blocks 2 and 3
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
struct cleanup * make_cleanup_free_so (struct so_list * so)
{
  struct cleanup * D.3336;

  <bb 2> :
  D.3336 = make_cleanup (do_free_so, so);
  return D.3336;

}



;; Function do_free_so (do_free_so, funcdef_no=31, decl_uid=3273, cgraph_uid=32, symbol_order=36)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
void do_free_so (void * arg)
{
  struct so_list * so;

  <bb 2> :
  so = arg;
  free_so (so);
  return;

}



;; Function main (main, funcdef_no=34, decl_uid=3320, cgraph_uid=35, symbol_order=39)

Removing basic block 4
Merging blocks 2 and 3
Merging blocks 2 and 5
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
int main (int argc, char * * argv)
{
  struct so_list * * link_ptr;
  int D.3338;

  <bb 2> :
  _1 = argc + -1;
  svr4_read_so_list (argc, _1, &link_ptr, 1);
  D.3338 = 0;
  link_ptr = {CLOBBER};
  return D.3338;

}



;; Function svr4_read_so_list (svr4_read_so_list, funcdef_no=33, decl_uid=3283, cgraph_uid=34, symbol_order=38)

;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24
;;
;; Loop 1
;;  header 22, latch 21
;;  depth 1, outer 0
;;  nodes: 22 21 18 20 9 14 17 15 16 10 7 8 5 3 12 13 11
;; 2 succs { 22 }
;; 3 succs { 4 5 }
;; 4 succs { 19 }
;; 5 succs { 6 7 }
;; 6 succs { 19 }
;; 7 succs { 8 10 }
;; 8 succs { 9 10 }
;; 9 succs { 20 }
;; 10 succs { 11 15 }
;; 11 succs { 13 12 }
;; 12 succs { 13 14 }
;; 13 succs { 14 }
;; 14 succs { 20 }
;; 15 succs { 17 16 }
;; 16 succs { 17 18 }
;; 17 succs { 20 }
;; 18 succs { 21 }
;; 19 succs { 24 }
;; 20 succs { 21 }
;; 21 succs { 22 }
;; 22 succs { 3 23 }
;; 23 succs { 24 }
;; 24 succs { 1 }
int svr4_read_so_list (CORE_ADDR lm, CORE_ADDR prev_lm, struct so_list * * * link_ptr_ptr, int ignore_first)
{
  struct svr4_info * info;
  char * buffer;
  int errcode;
  struct cleanup * old_chain;
  struct so_list * new;
  CORE_ADDR next_lm;
  struct so_list * first;
  int D.3343;

  <bb 2> :
  first = 0B;
  goto <bb 22>; [INV]

  <bb 3> :
  new = calloc (1, 1040);
  old_chain = make_cleanup_free_so (new);
  _1 = lm_info_read (lm);
  _2 = (long int) _1;
  _3 = (struct lm_info *) _2;
  new->lm_info = _3;
  _4 = new->lm_info;
  if (_4 == 0B)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  do_cleanups (old_chain);
  D.3343 = 0;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 19>; [INV]

  <bb 5> :
  _5 = new->lm_info;
  next_lm = _5->l_next;
  _6 = new->lm_info;
  _7 = _6->l_prev;
  if (prev_lm != _7)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  _8 = new->lm_info;
  _9 = _8->l_prev;
  _10 = target_gdbarch ();
  _11 = paddress (_10, _9);
  _12 = target_gdbarch ();
  _13 = paddress (_12, prev_lm);
  _14 = _ ("Corrupted shared library list: %s != %s");
  warning (_14, _13, _11);
  do_cleanups (old_chain);
  D.3343 = 0;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 19>; [INV]

  <bb 7> :
  if (ignore_first != 0)
    goto <bb 8>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 8> :
  _15 = new->lm_info;
  _16 = _15->l_prev;
  if (_16 == 0)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  _17 = get_svr4_info ();
  _18 = (long int) _17;
  info = (struct svr4_info *) _18;
  first = new;
  _19 = new->lm_info;
  _20 = _19->lm_addr;
  info->main_lm_addr = _20;
  do_cleanups (old_chain);
  // predicted unlikely by continue predictor.
  goto <bb 20>; [INV]

  <bb 10> :
  _21 = new->lm_info;
  _22 = _21->l_name;
  target_read_string (_22, &buffer, 511, &errcode);
  errcode.0_23 = errcode;
  if (errcode.0_23 != 0)
    goto <bb 11>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 11> :
  if (first == 0B)
    goto <bb 13>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 12> :
  _24 = new->lm_info;
  _25 = _24->l_name;
  _26 = first->lm_info;
  _27 = _26->l_name;
  if (_25 != _27)
    goto <bb 13>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 13> :
  errcode.1_28 = errcode;
  _29 = safe_strerror (errcode.1_28);
  _30 = _ ("Can\'t read pathname for load map: %s.");
  warning (_30, _29);

  <bb 14> :
  do_cleanups (old_chain);
  // predicted unlikely by continue predictor.
  goto <bb 20>; [INV]

  <bb 15> :
  buffer.2_31 = buffer;
  _32 = &new->so_name;
  strncpy (_32, buffer.2_31, 511);
  new->so_name[511] = 0;
  _33 = &new->so_name;
  _34 = &new->so_original_name;
  strcpy (_34, _33);
  buffer.3_35 = buffer;
  free (buffer.3_35);
  _36 = new->so_name[0];
  if (_36 == 0)
    goto <bb 17>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 16> :
  _37 = &new->so_name;
  _38 = match_main (_37);
  if (_38 != 0)
    goto <bb 17>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 17> :
  do_cleanups (old_chain);
  // predicted unlikely by continue predictor.
  goto <bb 20>; [INV]

  <bb 18> :
  discard_cleanups (old_chain);
  new->next = 0B;
  _39 = *link_ptr_ptr;
  *_39 = new;
  _40 = &new->next;
  *link_ptr_ptr = _40;
  errcode = {CLOBBER};
  buffer = {CLOBBER};
  goto <bb 21>; [INV]

  <bb 19> :
  errcode = {CLOBBER};
  buffer = {CLOBBER};
  goto <bb 24>; [INV]

  <bb 20> :
  errcode = {CLOBBER};
  buffer = {CLOBBER};

  <bb 21> :
  prev_lm = lm;
  lm = next_lm;

  <bb 22> :
  if (lm != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 23>; [INV]

  <bb 23> :
  D.3343 = 1;

  <bb 24> :
  return D.3343;

}


