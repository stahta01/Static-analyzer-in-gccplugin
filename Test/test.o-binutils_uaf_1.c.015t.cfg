
;; Function discard_cleanups (discard_cleanups, funcdef_no=22, decl_uid=3018, cgraph_uid=23, symbol_order=27)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
void discard_cleanups (struct cleanup * old_chain)
{
  <bb 2> :
  discard_my_cleanups (&cleanup_chain, old_chain);
  return;

}



;; Function discard_final_cleanups (discard_final_cleanups, funcdef_no=23, decl_uid=3023, cgraph_uid=24, symbol_order=28)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
void discard_final_cleanups (struct cleanup * old_chain)
{
  <bb 2> :
  discard_my_cleanups (&final_cleanup_chain, old_chain);
  return;

}



;; Function discard_my_cleanups (discard_my_cleanups, funcdef_no=24, decl_uid=3021, cgraph_uid=25, symbol_order=29)

;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7
;;
;; Loop 1
;;  header 6, latch 5
;;  depth 1, outer 0
;;  nodes: 6 5 3 4
;; 2 succs { 6 }
;; 3 succs { 4 5 }
;; 4 succs { 5 }
;; 5 succs { 6 }
;; 6 succs { 3 7 }
;; 7 succs { 1 }
void discard_my_cleanups (struct cleanup * * pmy_chain, struct cleanup * old_chain)
{
  struct cleanup * ptr;

  <bb 2> :
  goto <bb 6>; [INV]

  <bb 3> :
  _1 = ptr->next;
  *pmy_chain = _1;
  _2 = ptr->free_arg;
  if (_2 != 0B)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  _3 = ptr->free_arg;
  _4 = ptr->arg;
  _3 (_4);

  <bb 5> :
  free (ptr);

  <bb 6> :
  ptr = *pmy_chain;
  if (ptr != old_chain)
    goto <bb 3>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  _5 = ptr->arg;
  printf ("freearg: %x\n", _5);
  return;

}



;; Function do_cleanups (do_cleanups, funcdef_no=26, decl_uid=3028, cgraph_uid=27, symbol_order=31)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
void do_cleanups (struct cleanup * old_chain)
{
  <bb 2> :
  do_my_cleanups (&cleanup_chain, old_chain);
  return;

}



;; Function do_my_cleanups (do_my_cleanups, funcdef_no=25, decl_uid=3026, cgraph_uid=26, symbol_order=30)

;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7
;;
;; Loop 1
;;  header 6, latch 5
;;  depth 1, outer 0
;;  nodes: 6 5 3 4
;; 2 succs { 6 }
;; 3 succs { 4 5 }
;; 4 succs { 5 }
;; 5 succs { 6 }
;; 6 succs { 3 7 }
;; 7 succs { 1 }
void do_my_cleanups (struct cleanup * * pmy_chain, struct cleanup * old_chain)
{
  struct cleanup * ptr;

  <bb 2> :
  goto <bb 6>; [INV]

  <bb 3> :
  _1 = ptr->next;
  *pmy_chain = _1;
  _2 = ptr->function;
  _3 = ptr->arg;
  _2 (_3);
  __builtin_puts (&"cleanup!!!!! ========="[0]);
  _4 = ptr->arg;
  printf ("%x\n", _4);
  _5 = ptr->free_arg;
  if (_5 != 0B)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  _6 = ptr->free_arg;
  _7 = ptr->arg;
  _6 (_7);

  <bb 5> :
  free (ptr);

  <bb 6> :
  ptr = *pmy_chain;
  if (ptr != old_chain)
    goto <bb 3>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  return;

}



;; Function make_cleanup (make_cleanup, funcdef_no=29, decl_uid=3041, cgraph_uid=30, symbol_order=34)

Merging blocks 2 and 3
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
struct cleanup * make_cleanup (void (*<T59c>) (void *) function, void * arg)
{
  struct cleanup * D.3316;

  <bb 2> :
  D.3316 = make_my_cleanup (&cleanup_chain, function, arg);
  return D.3316;

}



;; Function make_my_cleanup (make_my_cleanup, funcdef_no=28, decl_uid=3038, cgraph_uid=29, symbol_order=33)

Merging blocks 2 and 3
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
struct cleanup * make_my_cleanup (struct cleanup * * pmy_chain, void (*<T59c>) (void *) function, void * arg)
{
  struct cleanup * D.3318;

  <bb 2> :
  D.3318 = make_my_cleanup2 (pmy_chain, function, arg, 0B);
  return D.3318;

}



;; Function make_my_cleanup2 (make_my_cleanup2, funcdef_no=27, decl_uid=3034, cgraph_uid=28, symbol_order=32)

Merging blocks 4 and 5
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4
;; 2 succs { 3 4 }
;; 3 succs { }
;; 4 succs { 1 }
struct cleanup * make_my_cleanup2 (struct cleanup * * pmy_chain, void (*<T59c>) (void *) function, void * arg, void (*<Tee>) (void *) free_arg)
{
  struct cleanup * old_chain;
  struct cleanup * new;
  struct cleanup * D.3322;

  <bb 2> :
  new = malloc (32);
  old_chain = *pmy_chain;
  _1 = *pmy_chain;
  new->next = _1;
  new->function = function;
  new->free_arg = free_arg;
  new->arg = arg;
  *pmy_chain = new;
  if (old_chain == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  exit (1);

  <bb 4> :
  D.3322 = old_chain;
  return D.3322;

}



;; Function getopt (getopt, funcdef_no=32, decl_uid=3299, cgraph_uid=33, symbol_order=42)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5
;; 2 succs { 3 4 }
;; 3 succs { 5 }
;; 4 succs { 5 }
;; 5 succs { 1 }
int getopt (char * optargv)
{
  int D.3326;

  <bb 2> :
  _1 = *optargv;
  if (_1 == 48)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  D.3326 = 0;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 5>; [INV]

  <bb 4> :
  D.3326 = 1;

  <bb 5> :
  return D.3326;

}



;; Function main (main, funcdef_no=33, decl_uid=3303, cgraph_uid=34, symbol_order=43)

Merging blocks 5 and 6
;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5
;;
;; Loop 1
;;  header 4, latch 3
;;  depth 1, outer 0
;;  nodes: 4 3
;; 2 succs { 4 }
;; 3 succs { 4 }
;; 4 succs { 3 5 }
;; 5 succs { 1 }
int main (int argc, char * * argv)
{
  char * string;
  int D.3328;

  <bb 2> :
  _1 = time (0B);
  _2 = (unsigned int) _1;
  srand (_2);
  goto <bb 4>; [INV]

  <bb 3> :
  string = "rv32ix_x";
  riscv_set_arch (string);

  <bb 4> :
  _3 = rand ();
  _4 = _3 % 2;
  if (_4 == 1)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 5> :
  D.3328 = 0;
  return D.3328;

}



;; Function riscv_set_arch (riscv_set_arch, funcdef_no=31, decl_uid=3270, cgraph_uid=32, symbol_order=41)

Removing basic block 8
Removing basic block 12
Removing basic block 14
;; 4 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27
;;
;; Loop 2
;;  header 26, multiple latches: 18 20 22 24
;;  depth 1, outer 0
;;  nodes: 26 18 20 22 24 23 21 19 12 16 14 15 13
;;
;; Loop 3
;;  header 14, latch 15
;;  depth 2, outer 2
;;  nodes: 14 15
;;
;; Loop 1
;;  header 10, latch 9
;;  depth 1, outer 0
;;  nodes: 10 9
;; 2 succs { 3 4 }
;; 3 succs { 7 }
;; 4 succs { 5 6 }
;; 5 succs { 7 }
;; 6 succs { }
;; 7 succs { 11 8 26 }
;; 8 succs { 10 }
;; 9 succs { 10 }
;; 10 succs { 9 26 }
;; 11 succs { }
;; 12 succs { 13 19 }
;; 13 succs { 14 }
;; 14 succs { 15 16 }
;; 15 succs { 14 16 }
;; 16 succs { 17 18 }
;; 17 succs { }
;; 18 succs { 26 }
;; 19 succs { 20 21 }
;; 20 succs { 26 }
;; 21 succs { 22 23 }
;; 22 succs { 26 }
;; 23 succs { 24 25 }
;; 24 succs { 26 }
;; 25 succs { }
;; 26 succs { 12 27 }
;; 27 succs { 1 }
void riscv_set_arch (const char * s)
{
  const char subset[2];
  const char subset[2];
  char * q;
  char * subset;
  const char subset[2];
  const char * p;
  const char * extension;
  const char * all_subsets;

  <bb 2> :
  all_subsets = "imafdc";
  extension = 0B;
  p = s;
  _1 = strncmp (p, "rv32", 4);
  if (_1 == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  xlen = 32;
  p = p + 4;
  goto <bb 7>; [INV]

  <bb 4> :
  _2 = strncmp (p, "rv64", 4);
  if (_2 == 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  xlen = 64;
  p = p + 4;
  goto <bb 7>; [INV]

  <bb 6> :
  printf ("-march=%s: ISA string must begin with rv32 or rv64", s);
  exit (1);

  <bb 7> :
  _3 = *p;
  _4 = (int) _3;
  switch (_4) <default: <L11> [INV], case 103: <L7> [INV], case 105: <L35> [INV]>

  <bb 8> :
<L7>:
  p = p + 1;
  goto <bb 10>; [INV]

  <bb 9> :
  _5 = *all_subsets;
  subset[0] = _5;
  subset[1] = 0;
  riscv_add_subset (&subset);
  subset = {CLOBBER};
  all_subsets = all_subsets + 1;

  <bb 10> :
  _6 = *all_subsets;
  if (_6 != 99)
    goto <bb 9>; [INV]
  else
    goto <bb 26>; [INV]

  <bb 11> :
<L11>:
  printf ("-march=%s: first ISA subset must be `i\' or `g\'", s);
  exit (1);

  <bb 12> :
  _7 = *p;
  if (_7 == 120)
    goto <bb 13>; [INV]
  else
    goto <bb 19>; [INV]

  <bb 13> :
  subset = strdup (p);
  q = subset;

  <bb 14> :
  q = q + 1;
  _8 = *q;
  if (_8 != 0)
    goto <bb 15>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 15> :
  _9 = *q;
  if (_9 != 95)
    goto <bb 14>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 16> :
  *q = 0;
  if (extension != 0B)
    goto <bb 17>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 17> :
  printf ("-march=%s: only one non-standard extension is supported", extension);
  exit (1);

  <bb 18> :
  extension = subset;
  riscv_add_subset (subset);
  _10 = strlen (subset);
  p = p + _10;
  free (subset);
  goto <bb 26>; [INV]

  <bb 19> :
  _11 = *p;
  if (_11 == 95)
    goto <bb 20>; [INV]
  else
    goto <bb 21>; [INV]

  <bb 20> :
  p = p + 1;
  goto <bb 26>; [INV]

  <bb 21> :
  _12 = *p;
  _13 = (int) _12;
  all_subsets = strchr (all_subsets, _13);
  if (all_subsets != 0B)
    goto <bb 22>; [INV]
  else
    goto <bb 23>; [INV]

  <bb 22> :
  _14 = *p;
  subset[0] = _14;
  subset[1] = 0;
  riscv_add_subset (&subset);
  all_subsets = all_subsets + 1;
  p = p + 1;
  subset = {CLOBBER};
  goto <bb 26>; [INV]

  <bb 23> :
  _15 = *p;
  if (_15 == 113)
    goto <bb 24>; [INV]
  else
    goto <bb 25>; [INV]

  <bb 24> :
  _16 = *p;
  subset[0] = _16;
  subset[1] = 0;
  riscv_add_subset (&subset);
  p = p + 1;
  subset = {CLOBBER};
  goto <bb 26>; [INV]

  <bb 25> :
  _17 = *p;
  _18 = (int) _17;
  printf ("-march=%s: unsupported ISA subset `%c\'", _18);
  exit (1);

  <bb 26> :
<L35>:
  _19 = *p;
  if (_19 != 0)
    goto <bb 12>; [INV]
  else
    goto <bb 27>; [INV]

  <bb 27> :
  return;

}



;; Function riscv_add_subset (riscv_add_subset, funcdef_no=30, decl_uid=3264, cgraph_uid=31, symbol_order=40)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
void riscv_add_subset (const char * subset)
{
  struct riscv_subset * s;
  char c;

  <bb 2> :
  c = *subset;
  s = malloc (16);
  _1 = strdup (subset);
  s->name = _1;
  riscv_subsets.0_2 = riscv_subsets;
  s->next = riscv_subsets.0_2;
  riscv_subsets = s;
  return;

}


