
;; Function sshpam_free_ctx (sshpam_free_ctx, funcdef_no=22, decl_uid=3730, cgraph_uid=23, symbol_order=53)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
void sshpam_free_ctx (void * ctxtp)
{
  static const char __func__[16] = "sshpam_free_ctx";
  struct pam_ctxt * ctxt;

  <bb 2> :
  ctxt = ctxtp;
  debug3 ("PAM: %s entering", &__func__);
  sshpam_thread_cleanup ();
  free (ctxt);
  return;

}



;; Function sshpam_respond (sshpam_respond, funcdef_no=24, decl_uid=3754, cgraph_uid=25, symbol_order=55)

Removing basic block 4
Merging blocks 13 and 14
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12
;; 2 succs { 4 5 3 }
;; 3 succs { 12 }
;; 4 succs { 12 }
;; 5 succs { 6 7 }
;; 6 succs { 12 }
;; 7 succs { 8 10 }
;; 8 succs { 9 10 }
;; 9 succs { 11 }
;; 10 succs { 11 }
;; 11 succs { 12 }
;; 12 succs { 1 }
int sshpam_respond (void * ctx, u_int num, char * * resp)
{
  struct pam_ctxt * ctxt;
  struct Buffer buffer;
  int D.3852;

  <bb 2> :
  ctxt = ctx;
  _1 = ctxt->pam_done;
  switch (_1) <default: <L2> [INV], case 0: <L12> [INV], case 1: <L0> [INV]>

  <bb 3> :
<L0>:
  sshpam_authenticated = 1;
  D.3852 = 0;
  goto <bb 12>; [INV]

  <bb 4> :
<L2>:
  D.3852 = -1;
  goto <bb 12>; [INV]

  <bb 5> :
<L12>:
  if (num != 1)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  error ("PAM: expected one response, got %u", num);
  D.3852 = -1;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 12>; [INV]

  <bb 7> :
  buffer_init (&buffer);
  sshpam_authctxt.0_2 = sshpam_authctxt;
  _3 = sshpam_authctxt.0_2->valid;
  if (_3 != 0)
    goto <bb 8>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 8> :
  sshpam_authctxt.1_4 = sshpam_authctxt;
  _5 = sshpam_authctxt.1_4->pw;
  _6 = _5->pw_uid;
  if (_6 != 0)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  _7 = *resp;
  buffer_put_cstring (&buffer, _7);
  goto <bb 11>; [INV]

  <bb 10> :
  buffer_put_cstring (&buffer, &badpw);

  <bb 11> :
  buffer_free (&buffer);
  D.3852 = 1;

  <bb 12> :
  buffer = {CLOBBER};
  return D.3852;

}



;; Function sshpam_init_ctx (sshpam_init_ctx, funcdef_no=23, decl_uid=3739, cgraph_uid=24, symbol_order=54)

Merging blocks 5 and 6
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5
;; 2 succs { 3 4 }
;; 3 succs { 5 }
;; 4 succs { 5 }
;; 5 succs { 1 }
void * sshpam_init_ctx (struct Authctxt * authctxt)
{
  int socks[2];
  struct pam_ctxt * ctxt;
  void * D.3864;

  <bb 2> :
  ctxt = calloc (1, 16);
  _1 = socks[0];
  ctxt->pam_psock = _1;
  _2 = socks[1];
  ctxt->pam_csock = _2;
  _3 = &ctxt->pam_thread;
  _4 = pthread_create (_3, 0B, sshpam_thread, ctxt);
  if (_4 == -1)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  _5 = __errno_location ();
  _6 = *_5;
  _7 = strerror (_6);
  error ("PAM: failed to start authentication thread: %s", _7);
  _8 = socks[0];
  close (_8);
  _9 = socks[1];
  close (_9);
  free (ctxt);
  D.3864 = 0B;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 5>; [INV]

  <bb 4> :
  cleanup_ctxt = ctxt;
  D.3864 = ctxt;

  <bb 5> :
  socks = {CLOBBER};
  return D.3864;

}



;; Function mm_answer_pam_init_ctx (mm_answer_pam_init_ctx, funcdef_no=25, decl_uid=3610, cgraph_uid=26, symbol_order=57)

Merging blocks 2 and 3
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
int mm_answer_pam_init_ctx (int sock, struct Buffer * m)
{
  static const char __func__[23] = "mm_answer_pam_init_ctx";
  int D.3867;

  <bb 2> :
  debug3 ("%s", &__func__);
  _1 = sshpam_device.init_ctx;
  authctxt.2_2 = authctxt;
  _3 = _1 (authctxt.2_2);
  sshpam_ctxt = _3;
  sshpam_authok = 0B;
  D.3867 = 0;
  return D.3867;

}



;; Function mm_answer_pam_free_ctx (mm_answer_pam_free_ctx, funcdef_no=26, decl_uid=3619, cgraph_uid=27, symbol_order=58)

Merging blocks 2 and 3
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
int mm_answer_pam_free_ctx (int sock, struct Buffer * m)
{
  static const char __func__[23] = "mm_answer_pam_free_ctx";
  int D.3869;

  <bb 2> :
  debug3 ("%s", &__func__);
  _1 = sshpam_device.free_ctx;
  sshpam_ctxt.3_2 = sshpam_ctxt;
  _1 (sshpam_ctxt.3_2);
  buffer_clear (m);
  mm_request_send (sock, 111, m);
  auth_method = "keyboard-interactive";
  auth_submethod = "pam";
  sshpam_authok.4_3 = sshpam_authok;
  sshpam_ctxt.5_4 = sshpam_ctxt;
  _5 = sshpam_authok.4_3 == sshpam_ctxt.5_4;
  D.3869 = (int) _5;
  return D.3869;

}



;; Function mm_answer_pam_respond (mm_answer_pam_respond, funcdef_no=27, decl_uid=3616, cgraph_uid=28, symbol_order=59)

Merging blocks 13 and 14
;; 3 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13
;;
;; Loop 2
;;  header 8, latch 7
;;  depth 1, outer 0
;;  nodes: 8 7
;;
;; Loop 1
;;  header 5, latch 4
;;  depth 1, outer 0
;;  nodes: 5 4
;; 2 succs { 3 10 }
;; 3 succs { 5 }
;; 4 succs { 5 }
;; 5 succs { 4 6 }
;; 6 succs { 8 }
;; 7 succs { 8 }
;; 8 succs { 7 9 }
;; 9 succs { 11 }
;; 10 succs { 11 }
;; 11 succs { 12 13 }
;; 12 succs { 13 }
;; 13 succs { 1 }
int mm_answer_pam_respond (int sock, struct Buffer * m)
{
  int ret;
  u_int num;
  u_int i;
  char * * resp;
  int D.3876;

  <bb 2> :
  sshpam_authok = 0B;
  _1 = buffer_get_int (m);
  num = (u_int) _1;
  if (num != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 3> :
  _2 = (long unsigned int) num;
  resp = calloc (_2, 8);
  i = 0;
  goto <bb 5>; [INV]

  <bb 4> :
  _3 = buffer_get_string (m, 0B);
  _4 = (long int) _3;
  _5 = (long unsigned int) i;
  _6 = _5 * 8;
  _7 = resp + _6;
  _8 = (char *) _4;
  *_7 = _8;
  i = i + 1;

  <bb 5> :
  if (i < num)
    goto <bb 4>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 6> :
  _9 = sshpam_device.respond;
  sshpam_ctxt.6_10 = sshpam_ctxt;
  ret = _9 (sshpam_ctxt.6_10, num, resp);
  i = 0;
  goto <bb 8>; [INV]

  <bb 7> :
  _11 = (long unsigned int) i;
  _12 = _11 * 8;
  _13 = resp + _12;
  _14 = *_13;
  free (_14);
  i = i + 1;

  <bb 8> :
  if (i < num)
    goto <bb 7>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 9> :
  free (resp);
  goto <bb 11>; [INV]

  <bb 10> :
  _15 = sshpam_device.respond;
  sshpam_ctxt.7_16 = sshpam_ctxt;
  ret = _15 (sshpam_ctxt.7_16, num, 0B);

  <bb 11> :
  if (ret == 0)
    goto <bb 12>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 12> :
  sshpam_ctxt.8_17 = sshpam_ctxt;
  sshpam_authok = sshpam_ctxt.8_17;

  <bb 13> :
  D.3876 = 0;
  return D.3876;

}



;; Function monitor_read (monitor_read, funcdef_no=28, decl_uid=3811, cgraph_uid=29, symbol_order=60)

Removing basic block 15
Merging blocks 13 and 16
Merging blocks 13 and 17
;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14
;;
;; Loop 1
;;  header 5, latch 4
;;  depth 1, outer 0
;;  nodes: 5 4 3
;; 2 succs { 5 }
;; 3 succs { 6 4 }
;; 4 succs { 5 }
;; 5 succs { 3 6 }
;; 6 succs { 7 14 }
;; 7 succs { 8 9 }
;; 8 succs { }
;; 9 succs { 10 11 }
;; 10 succs { 11 }
;; 11 succs { 12 13 }
;; 12 succs { 13 }
;; 13 succs { 1 }
;; 14 succs { }
int monitor_read (struct monitor * pmonitor, struct mon_table * ent, struct mon_table * * pent)
{
  static const char __func__[13] = "monitor_read";
  struct pollfd pfd[2];
  u_char type;
  int ret;
  struct Buffer m;
  int D.3887;

  <bb 2> :
  buffer_init (&m);
  _1 = pmonitor->m_sendfd;
  mm_request_receive (_1, &m);
  _2 = buffer_get_char (&m);
  type = (u_char) _2;
  goto <bb 5>; [INV]

  <bb 3> :
  _3 = ent->type;
  _4 = (monitor_reqtype) type;
  if (_3 == _4)
    goto <bb 6>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 4> :
  ent = ent + 16;

  <bb 5> :
  _5 = ent->f;
  if (_5 != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 6> :
  _6 = ent->f;
  if (_6 != 0B)
    goto <bb 7>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 7> :
  _7 = ent->flags;
  _8 = _7 & 4096;
  if (_8 == 0)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  printf ("%s: unpermitted request", &__func__);
  exit (1);

  <bb 9> :
  _9 = ent->f;
  _10 = pmonitor->m_sendfd;
  ret = _9 (_10, &m);
  buffer_free (&m);
  _11 = ent->flags;
  _12 = _11 & 16;
  if (_12 != 0)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  _13 = (int) type;
  debug2 ("%s: %d used once, disabling now", &__func__, _13);
  _14 = ent->flags;
  _15 = _14 & -4097;
  ent->flags = _15;

  <bb 11> :
  if (pent != 0B)
    goto <bb 12>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 12> :
  *pent = ent;

  <bb 13> :
  D.3887 = ret;
  // predicted unlikely by early return (on trees) predictor.
  m = {CLOBBER};
  pfd = {CLOBBER};
  return D.3887;

  <bb 14> :
  printf ("%s: unsupported request: ", &__func__);
  exit (1);

}



;; Function monitor_child_preauth (monitor_child_preauth, funcdef_no=29, decl_uid=3831, cgraph_uid=30, symbol_order=61)

Removing basic block 5
;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12
;;
;; Loop 1
;;  header 11, multiple latches: 5 8 9 10
;;  depth 1, outer 0
;;  nodes: 11 5 8 9 10 6
;; 2 succs { 3 4 }
;; 3 succs { 11 }
;; 4 succs { 11 }
;; 5 succs { 6 11 }
;; 6 succs { 7 8 }
;; 7 succs { }
;; 8 succs { 9 11 }
;; 9 succs { 10 11 }
;; 10 succs { 11 }
;; 11 succs { 5 12 }
;; 12 succs { 1 }
void monitor_child_preauth (struct Authctxt * _authctxt, struct monitor * pmonitor)
{
  static const char __func__[22] = "monitor_child_preauth";
  int compat20;
  int partial;
  int authenticated;
  struct mon_table * ent;

  <bb 2> :
  authenticated = 0;
  partial = 0;
  pmonitor->m_recvfd = -1;
  _1 = pmonitor->m_recvfd;
  pmonitor->m_log_sendfd = _1;
  authctxt = _authctxt;
  authctxt.9_2 = authctxt;
  memset (authctxt.9_2, 0, 128);
  if (compat20 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  mon_dispatch = &mon_dispatch_proto20;
  mon_dispatch.10_3 = mon_dispatch;
  monitor_permit (mon_dispatch.10_3, 0, 1);
  mon_dispatch.11_4 = mon_dispatch;
  monitor_permit (mon_dispatch.11_4, 6, 1);
  goto <bb 11>; [INV]

  <bb 4> :
  mon_dispatch = &mon_dispatch_proto15;
  mon_dispatch.12_5 = mon_dispatch;
  monitor_permit (mon_dispatch.12_5, 32, 1);
  goto <bb 11>; [INV]

  <bb 5> :
  partial = 0;
  auth_method = "unknown";
  auth_submethod = 0B;
  mon_dispatch.13_6 = mon_dispatch;
  _7 = monitor_read (pmonitor, mon_dispatch.13_6, &ent);
  _8 = _7 == 1;
  authenticated = (int) _8;
  if (authenticated != 0)
    goto <bb 6>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 6> :
  ent.14_9 = ent;
  _10 = ent.14_9->flags;
  _11 = _10 & 8;
  if (_11 == 0)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  printf ("%s: unexpected authentication from %d", &__func__);
  exit (1);

  <bb 8> :
  authctxt.15_12 = authctxt;
  _13 = authctxt.15_12->pw;
  _14 = _13->pw_uid;
  if (_14 == 0)
    goto <bb 9>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 9> :
  auth_method.16_15 = auth_method;
  _16 = auth_root_allowed (auth_method.16_15);
  if (_16 == 0)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  authenticated = 0;

  <bb 11> :
  if (authenticated == 0)
    goto <bb 5>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 12> :
  ent = {CLOBBER};
  return;

}



;; Function main (main, funcdef_no=30, decl_uid=3847, cgraph_uid=31, symbol_order=62)

Removing basic block 4
Merging blocks 2 and 3
Merging blocks 2 and 5
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
int main ()
{
  struct Authctxt authctxt;
  struct monitor pmonitor;
  int D.3901;

  <bb 2> :
  monitor_child_preauth (&authctxt, &pmonitor);
  D.3901 = 0;
  pmonitor = {CLOBBER};
  authctxt = {CLOBBER};
  return D.3901;

}


