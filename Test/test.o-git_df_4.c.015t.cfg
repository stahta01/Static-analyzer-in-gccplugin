
;; Function xrealloc (xrealloc, funcdef_no=26, decl_uid=3195, cgraph_uid=27, symbol_order=27)

Merging blocks 9 and 10
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9
;; 2 succs { 3 4 }
;; 3 succs { 4 }
;; 4 succs { 5 9 }
;; 5 succs { 6 7 }
;; 6 succs { 7 }
;; 7 succs { 8 9 }
;; 8 succs { }
;; 9 succs { 1 }
void * xrealloc (void * ptr, size_t size)
{
  void * ret;
  void * D.3347;

  <bb 2> :
  ret = realloc (ptr, size);
  _1 = ret == 0B;
  _2 = size == 0;
  _3 = _1 & _2;
  if (_3 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  ret = realloc (ptr, 1);

  <bb 4> :
  if (ret == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 5> :
  ret = realloc (ptr, size);
  _4 = ret == 0B;
  _5 = size == 0;
  _6 = _4 & _5;
  if (_6 != 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  ret = realloc (ptr, 1);

  <bb 7> :
  if (ret == 0B)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  printf ("Out of memory, realloc failed%s", "");
  exit (1);

  <bb 9> :
  D.3347 = ret;
  return D.3347;

}



;; Function free_refs (free_refs, funcdef_no=28, decl_uid=3237, cgraph_uid=29, symbol_order=31)

;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5
;;
;; Loop 1
;;  header 4, latch 3
;;  depth 1, outer 0
;;  nodes: 4 3
;; 2 succs { 4 }
;; 3 succs { 4 }
;; 4 succs { 3 5 }
;; 5 succs { 1 }
void free_refs (struct ref * ref)
{
  struct ref * next;

  <bb 2> :
  goto <bb 4>; [INV]

  <bb 3> :
  next = ref->next;
  free_ref (ref);
  ref = next;

  <bb 4> :
  if (ref != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 5> :
  return;

}



;; Function free_ref (free_ref, funcdef_no=27, decl_uid=3234, cgraph_uid=28, symbol_order=30)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5
;; 2 succs { 3 4 }
;; 3 succs { 5 }
;; 4 succs { 5 }
;; 5 succs { 1 }
void free_ref (struct ref * ref)
{
  <bb 2> :
  if (ref == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 5>; [INV]

  <bb 4> :
  _1 = ref->peer_ref;
  free_ref (_1);
  _2 = ref->remote_status;
  free (_2);
  _3 = ref->symref;
  free (_3);
  free (ref);

  <bb 5> :
  return;

}



;; Function find_ref_by_name (find_ref_by_name, funcdef_no=29, decl_uid=3245, cgraph_uid=30, symbol_order=32)

;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8
;;
;; Loop 1
;;  header 6, latch 5
;;  depth 1, outer 0
;;  nodes: 6 5 3
;; 2 succs { 6 }
;; 3 succs { 4 5 }
;; 4 succs { 8 }
;; 5 succs { 6 }
;; 6 succs { 3 7 }
;; 7 succs { 8 }
;; 8 succs { 1 }
struct ref * find_ref_by_name (const struct ref * list, const char * name)
{
  struct ref * D.3354;

  <bb 2> :
  goto <bb 6>; [INV]

  <bb 3> :
  _1 = &list->name;
  _2 = strcmp (_1, name);
  if (_2 == 0)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  D.3354 = list;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 8>; [INV]

  <bb 5> :
  list = list->next;

  <bb 6> :
  if (list != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  D.3354 = 0B;

  <bb 8> :
  return D.3354;

}



;; Function alloc_ref (alloc_ref, funcdef_no=31, decl_uid=3262, cgraph_uid=32, symbol_order=34)

Merging blocks 2 and 3
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
struct ref * alloc_ref (const char * name)
{
  struct ref * D.3356;

  <bb 2> :
  D.3356 = alloc_ref_with_prefix ("", 0, name);
  return D.3356;

}



;; Function alloc_ref_with_prefix (alloc_ref_with_prefix, funcdef_no=30, decl_uid=3255, cgraph_uid=31, symbol_order=33)

Merging blocks 2 and 3
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
struct ref * alloc_ref_with_prefix (const char * prefix, size_t prefixlen, const char * name)
{
  struct ref * ref;
  size_t len;
  struct ref * D.3358;

  <bb 2> :
  len = strlen (name);
  _1 = prefixlen + len;
  _2 = _1 + 81;
  ref = calloc (1, _2);
  _3 = &ref->name;
  memcpy (_3, prefix, prefixlen);
  _4 = &ref->name;
  _5 = _4 + prefixlen;
  memcpy (_5, name, len);
  D.3358 = ref;
  return D.3358;

}



;; Function match_refs (match_refs, funcdef_no=36, decl_uid=3301, cgraph_uid=37, symbol_order=39)

Removing basic block 8
Merging blocks 17 and 18
;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16
;;
;; Loop 1
;;  header 15, latch 14
;;  depth 1, outer 0
;;  nodes: 15 14 4 13 7 10 12 6 11 8 9 5 3
;; 2 succs { 15 }
;; 3 succs { 4 5 }
;; 4 succs { 14 }
;; 5 succs { 6 8 }
;; 6 succs { 7 12 }
;; 7 succs { 13 }
;; 8 succs { 9 11 }
;; 9 succs { 10 11 }
;; 10 succs { 13 }
;; 11 succs { 12 }
;; 12 succs { 13 }
;; 13 succs { 14 }
;; 14 succs { 15 }
;; 15 succs { 3 16 }
;; 16 succs { 1 }
int match_refs (struct ref * src, struct ref * dst, struct ref * * * dst_tail, int nr_refspec, const char * * refspec, int flags)
{
  char * dst_name;
  const struct refspec * pat;
  struct ref * dst_peer;
  static const char * default_refspec[2] = {(const char *) ":", 0B};
  int send_mirror;
  int send_all;
  struct refspec * rs;
  int D.3371;

  <bb 2> :
  send_all = flags & 1;
  send_mirror = flags & 2;
  goto <bb 15>; [INV]

  <bb 3> :
  pat = 0B;
  dst_name = &src->name;
  _1 = src->peer_ref;
  if (_1 != 0B)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  // predicted unlikely by continue predictor.
  goto <bb 14>; [INV]

  <bb 5> :
  dst_peer = find_ref_by_name (dst, dst_name);
  if (dst_peer != 0B)
    goto <bb 6>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 6> :
  _2 = dst_peer->peer_ref;
  if (_2 != 0B)
    goto <bb 7>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 7> :
  // predicted unlikely by goto predictor.
  goto <bb 13>; [INV]

  <bb 8> :
  _3 = BIT_FIELD_REF <*pat, 8, 0>;
  _4 = _3 & 4;
  if (_4 != 0)
    goto <bb 9>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 9> :
  _5 = send_all | send_mirror;
  if (_5 == 0)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  // predicted unlikely by goto predictor.
  goto <bb 13>; [INV]

  <bb 11> :
  dst_peer = make_linked_ref (dst_name, dst_tail);
  _6 = &src->new_sha1;
  _7 = &dst_peer->new_sha1;
  hashcpy (_7, _6);

  <bb 12> :
  dst_peer->peer_ref = src;
  _8 = pat->force;
  dst_peer->force = _8;

  <bb 13> :
free_name:
  free (dst_name);

  <bb 14> :
  src = src->next;

  <bb 15> :
  if (src != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 16> :
  D.3371 = 0;
  return D.3371;

}



;; Function make_linked_ref (make_linked_ref, funcdef_no=35, decl_uid=3292, cgraph_uid=36, symbol_order=38)

Merging blocks 2 and 3
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
struct ref * make_linked_ref (const char * name, struct ref * * * tail)
{
  struct ref * ret;
  struct ref * D.3373;

  <bb 2> :
  ret = alloc_ref (name);
  tail_link_ref (ret, tail);
  D.3373 = ret;
  return D.3373;

}



;; Function tail_link_ref (tail_link_ref, funcdef_no=34, decl_uid=3285, cgraph_uid=35, symbol_order=37)

;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5
;;
;; Loop 1
;;  header 4, latch 3
;;  depth 1, outer 0
;;  nodes: 4 3
;; 2 succs { 4 }
;; 3 succs { 4 }
;; 4 succs { 3 5 }
;; 5 succs { 1 }
void tail_link_ref (struct ref * ref, struct ref * * * tail)
{
  <bb 2> :
  _1 = *tail;
  *_1 = ref;
  goto <bb 4>; [INV]

  <bb 3> :
  ref = ref->next;

  <bb 4> :
  _2 = ref->next;
  if (_2 != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 5> :
  _3 = &ref->next;
  *tail = _3;
  return;

}



;; Function main (main, funcdef_no=37, decl_uid=3318, cgraph_uid=38, symbol_order=40)

Merging blocks 6 and 7
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6
;; 2 succs { 3 4 }
;; 3 succs { 6 }
;; 4 succs { 5 6 }
;; 5 succs { 6 }
;; 6 succs { 1 }
int main (int argc, char * * argv)
{
  char * rewritten_url;
  struct ref * local_refs;
  struct ref * ref;
  int new_refs;
  int i;
  int rc;
  int objects_to_send;
  int force_delete;
  int delete_branch;
  struct rev_info revs;
  struct remote_lock * info_ref_lock;
  struct remote_lock * ref_lock;
  char * * refspec;
  int nr_refspec;
  int D.3379;

  <bb 2> :
  nr_refspec = 0;
  refspec = 0B;
  ref_lock = 0B;
  info_ref_lock = 0B;
  delete_branch = 0;
  force_delete = 0;
  rc = 0;
  rewritten_url = 0B;
  refspec = argv;
  _1 = get_local_heads ();
  _2 = (long int) _1;
  local_refs = (struct ref *) _2;
  remote_tail = &remote_refs;
  remote_refs.0_3 = remote_refs;
  _4 = match_refs (local_refs, remote_refs.0_3, &remote_tail, nr_refspec, refspec, 1);
  if (_4 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  rc = -1;
  // predicted unlikely by goto predictor.
  goto <bb 6>; [INV]

  <bb 4> :
  remote_refs.1_5 = remote_refs;
  if (remote_refs.1_5 == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  stderr.2_6 = stderr;
  __builtin_fwrite ("No refs in common and none specified; doing nothing.\n", 1, 53, stderr.2_6);
  rc = 0;
  // predicted unlikely by goto predictor.

  <bb 6> :
cleanup:
  free_refs (local_refs);
  remote_refs.3_7 = remote_refs;
  free_refs (remote_refs.3_7);
  revs = {CLOBBER};
  D.3379 = 0;
  return D.3379;

}


