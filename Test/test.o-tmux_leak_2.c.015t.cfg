
;; Function winlinks_RB_INSERT_COLOR (winlinks_RB_INSERT_COLOR, funcdef_no=22, decl_uid=4017, cgraph_uid=23, symbol_order=22)

Removing basic block 14
Merging blocks 16 and 17
Removing basic block 24
Merging blocks 26 and 27
Removing basic block 38
Merging blocks 40 and 41
Removing basic block 48
;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46
;;
;; Loop 1
;;  header 44, multiple latches: 6 23 26 43
;;  depth 1, outer 0
;;  nodes: 44 6 23 26 43 41 42 40 39 38 36 37 27 35 33 34 32 31 30 28 29 24 25 3 45 21 22 20 19 18 16 17 7 15 13 14 12 11 10 8 9 4 5
;; 2 succs { 44 }
;; 3 succs { 4 24 }
;; 4 succs { 5 7 }
;; 5 succs { 6 7 }
;; 6 succs { 44 }
;; 7 succs { 8 16 }
;; 8 succs { 9 10 }
;; 9 succs { 10 }
;; 10 succs { 11 14 }
;; 11 succs { 12 13 }
;; 12 succs { 15 }
;; 13 succs { 15 }
;; 14 succs { 15 }
;; 15 succs { 16 }
;; 16 succs { 17 18 }
;; 17 succs { 18 }
;; 18 succs { 19 22 }
;; 19 succs { 20 21 }
;; 20 succs { 23 }
;; 21 succs { 23 }
;; 22 succs { 23 }
;; 23 succs { 44 }
;; 24 succs { 25 27 }
;; 25 succs { 26 27 }
;; 26 succs { 44 }
;; 27 succs { 28 36 }
;; 28 succs { 29 30 }
;; 29 succs { 30 }
;; 30 succs { 31 34 }
;; 31 succs { 32 33 }
;; 32 succs { 35 }
;; 33 succs { 35 }
;; 34 succs { 35 }
;; 35 succs { 36 }
;; 36 succs { 37 38 }
;; 37 succs { 38 }
;; 38 succs { 39 42 }
;; 39 succs { 40 41 }
;; 40 succs { 43 }
;; 41 succs { 43 }
;; 42 succs { 43 }
;; 43 succs { 44 }
;; 44 succs { 45 46 }
;; 45 succs { 3 46 }
;; 46 succs { 1 }
void winlinks_RB_INSERT_COLOR (struct winlinks * head, struct winlink * elm)
{
  struct winlink * tmp;
  struct winlink * gparent;
  struct winlink * parent;

  <bb 2> :
  goto <bb 44>; [INV]

  <bb 3> :
  gparent = parent->entry.rbe_parent;
  _1 = gparent->entry.rbe_left;
  if (parent == _1)
    goto <bb 4>; [INV]
  else
    goto <bb 24>; [INV]

  <bb 4> :
  tmp = gparent->entry.rbe_right;
  if (tmp != 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 5> :
  _2 = tmp->entry.rbe_color;
  if (_2 == 1)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  tmp->entry.rbe_color = 0;
  parent->entry.rbe_color = 0;
  gparent->entry.rbe_color = 1;
  elm = gparent;
  // predicted unlikely by continue predictor.
  goto <bb 44>; [INV]

  <bb 7> :
  _3 = parent->entry.rbe_right;
  if (elm == _3)
    goto <bb 8>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 8> :
  tmp = parent->entry.rbe_right;
  _4 = tmp->entry.rbe_left;
  parent->entry.rbe_right = _4;
  _5 = parent->entry.rbe_right;
  if (_5 != 0B)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  _6 = tmp->entry.rbe_left;
  _6->entry.rbe_parent = parent;

  <bb 10> :
  _7 = parent->entry.rbe_parent;
  tmp->entry.rbe_parent = _7;
  _8 = tmp->entry.rbe_parent;
  if (_8 != 0B)
    goto <bb 11>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 11> :
  _9 = parent->entry.rbe_parent;
  _10 = _9->entry.rbe_left;
  if (parent == _10)
    goto <bb 12>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 12> :
  _11 = parent->entry.rbe_parent;
  _11->entry.rbe_left = tmp;
  goto <bb 15>; [INV]

  <bb 13> :
  _12 = parent->entry.rbe_parent;
  _12->entry.rbe_right = tmp;
  goto <bb 15>; [INV]

  <bb 14> :
  head->rbh_root = tmp;

  <bb 15> :
  tmp->entry.rbe_left = parent;
  parent->entry.rbe_parent = tmp;
  _13 = tmp->entry.rbe_parent;
  tmp = parent;
  parent = elm;
  elm = tmp;

  <bb 16> :
  parent->entry.rbe_color = 0;
  gparent->entry.rbe_color = 1;
  tmp = gparent->entry.rbe_left;
  _14 = tmp->entry.rbe_right;
  gparent->entry.rbe_left = _14;
  _15 = gparent->entry.rbe_left;
  if (_15 != 0B)
    goto <bb 17>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 17> :
  _16 = tmp->entry.rbe_right;
  _16->entry.rbe_parent = gparent;

  <bb 18> :
  _17 = gparent->entry.rbe_parent;
  tmp->entry.rbe_parent = _17;
  _18 = tmp->entry.rbe_parent;
  if (_18 != 0B)
    goto <bb 19>; [INV]
  else
    goto <bb 22>; [INV]

  <bb 19> :
  _19 = gparent->entry.rbe_parent;
  _20 = _19->entry.rbe_left;
  if (gparent == _20)
    goto <bb 20>; [INV]
  else
    goto <bb 21>; [INV]

  <bb 20> :
  _21 = gparent->entry.rbe_parent;
  _21->entry.rbe_left = tmp;
  goto <bb 23>; [INV]

  <bb 21> :
  _22 = gparent->entry.rbe_parent;
  _22->entry.rbe_right = tmp;
  goto <bb 23>; [INV]

  <bb 22> :
  head->rbh_root = tmp;

  <bb 23> :
  tmp->entry.rbe_right = gparent;
  gparent->entry.rbe_parent = tmp;
  _23 = tmp->entry.rbe_parent;
  goto <bb 44>; [INV]

  <bb 24> :
  tmp = gparent->entry.rbe_left;
  if (tmp != 0B)
    goto <bb 25>; [INV]
  else
    goto <bb 27>; [INV]

  <bb 25> :
  _24 = tmp->entry.rbe_color;
  if (_24 == 1)
    goto <bb 26>; [INV]
  else
    goto <bb 27>; [INV]

  <bb 26> :
  tmp->entry.rbe_color = 0;
  parent->entry.rbe_color = 0;
  gparent->entry.rbe_color = 1;
  elm = gparent;
  // predicted unlikely by continue predictor.
  goto <bb 44>; [INV]

  <bb 27> :
  _25 = parent->entry.rbe_left;
  if (elm == _25)
    goto <bb 28>; [INV]
  else
    goto <bb 36>; [INV]

  <bb 28> :
  tmp = parent->entry.rbe_left;
  _26 = tmp->entry.rbe_right;
  parent->entry.rbe_left = _26;
  _27 = parent->entry.rbe_left;
  if (_27 != 0B)
    goto <bb 29>; [INV]
  else
    goto <bb 30>; [INV]

  <bb 29> :
  _28 = tmp->entry.rbe_right;
  _28->entry.rbe_parent = parent;

  <bb 30> :
  _29 = parent->entry.rbe_parent;
  tmp->entry.rbe_parent = _29;
  _30 = tmp->entry.rbe_parent;
  if (_30 != 0B)
    goto <bb 31>; [INV]
  else
    goto <bb 34>; [INV]

  <bb 31> :
  _31 = parent->entry.rbe_parent;
  _32 = _31->entry.rbe_left;
  if (parent == _32)
    goto <bb 32>; [INV]
  else
    goto <bb 33>; [INV]

  <bb 32> :
  _33 = parent->entry.rbe_parent;
  _33->entry.rbe_left = tmp;
  goto <bb 35>; [INV]

  <bb 33> :
  _34 = parent->entry.rbe_parent;
  _34->entry.rbe_right = tmp;
  goto <bb 35>; [INV]

  <bb 34> :
  head->rbh_root = tmp;

  <bb 35> :
  tmp->entry.rbe_right = parent;
  parent->entry.rbe_parent = tmp;
  _35 = tmp->entry.rbe_parent;
  tmp = parent;
  parent = elm;
  elm = tmp;

  <bb 36> :
  parent->entry.rbe_color = 0;
  gparent->entry.rbe_color = 1;
  tmp = gparent->entry.rbe_right;
  _36 = tmp->entry.rbe_left;
  gparent->entry.rbe_right = _36;
  _37 = gparent->entry.rbe_right;
  if (_37 != 0B)
    goto <bb 37>; [INV]
  else
    goto <bb 38>; [INV]

  <bb 37> :
  _38 = tmp->entry.rbe_left;
  _38->entry.rbe_parent = gparent;

  <bb 38> :
  _39 = gparent->entry.rbe_parent;
  tmp->entry.rbe_parent = _39;
  _40 = tmp->entry.rbe_parent;
  if (_40 != 0B)
    goto <bb 39>; [INV]
  else
    goto <bb 42>; [INV]

  <bb 39> :
  _41 = gparent->entry.rbe_parent;
  _42 = _41->entry.rbe_left;
  if (gparent == _42)
    goto <bb 40>; [INV]
  else
    goto <bb 41>; [INV]

  <bb 40> :
  _43 = gparent->entry.rbe_parent;
  _43->entry.rbe_left = tmp;
  goto <bb 43>; [INV]

  <bb 41> :
  _44 = gparent->entry.rbe_parent;
  _44->entry.rbe_right = tmp;
  goto <bb 43>; [INV]

  <bb 42> :
  head->rbh_root = tmp;

  <bb 43> :
  tmp->entry.rbe_left = gparent;
  gparent->entry.rbe_parent = tmp;
  _45 = tmp->entry.rbe_parent;

  <bb 44> :
  parent = elm->entry.rbe_parent;
  if (parent != 0B)
    goto <bb 45>; [INV]
  else
    goto <bb 46>; [INV]

  <bb 45> :
  _46 = parent->entry.rbe_color;
  if (_46 == 1)
    goto <bb 3>; [INV]
  else
    goto <bb 46>; [INV]

  <bb 46> :
  _47 = head->rbh_root;
  _47->entry.rbe_color = 0;
  return;

}



;; Function winlinks_RB_REMOVE_COLOR (winlinks_RB_REMOVE_COLOR, funcdef_no=23, decl_uid=4068, cgraph_uid=24, symbol_order=23)

Removing basic block 11
Merging blocks 13 and 14
Merging blocks 19 and 46
Removing basic block 30
Merging blocks 32 and 33
Removing basic block 42
Merging blocks 44 and 45
Removing basic block 54
Merging blocks 56 and 57
Removing basic block 73
Merging blocks 75 and 76
Removing basic block 85
Merging blocks 87 and 88
;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81
;;
;; Loop 1
;;  header 76, multiple latches: 17 53
;;  depth 1, outer 0
;;  nodes: 76 17 53 51 52 49 50 40 48 46 47 45 44 43 41 42 3 78 77 15 16 13 14 4 12 10 11 9 8 7 5 6
;; 2 succs { 76 }
;; 3 succs { 4 40 }
;; 4 succs { 5 13 }
;; 5 succs { 6 7 }
;; 6 succs { 7 }
;; 7 succs { 8 11 }
;; 8 succs { 9 10 }
;; 9 succs { 12 }
;; 10 succs { 12 }
;; 11 succs { 12 }
;; 12 succs { 13 }
;; 13 succs { 15 14 }
;; 14 succs { 15 18 }
;; 15 succs { 17 16 }
;; 16 succs { 17 18 }
;; 17 succs { 76 }
;; 18 succs { 20 19 }
;; 19 succs { 20 30 }
;; 20 succs { 21 22 }
;; 21 succs { 22 }
;; 22 succs { 23 24 }
;; 23 succs { 24 }
;; 24 succs { 25 28 }
;; 25 succs { 26 27 }
;; 26 succs { 29 }
;; 27 succs { 29 }
;; 28 succs { 29 }
;; 29 succs { 30 }
;; 30 succs { 31 32 }
;; 31 succs { 32 }
;; 32 succs { 33 34 }
;; 33 succs { 34 }
;; 34 succs { 35 38 }
;; 35 succs { 36 37 }
;; 36 succs { 39 }
;; 37 succs { 39 }
;; 38 succs { 39 }
;; 39 succs { 79 }
;; 40 succs { 41 49 }
;; 41 succs { 42 43 }
;; 42 succs { 43 }
;; 43 succs { 44 47 }
;; 44 succs { 45 46 }
;; 45 succs { 48 }
;; 46 succs { 48 }
;; 47 succs { 48 }
;; 48 succs { 49 }
;; 49 succs { 51 50 }
;; 50 succs { 51 54 }
;; 51 succs { 53 52 }
;; 52 succs { 53 54 }
;; 53 succs { 76 }
;; 54 succs { 56 55 }
;; 55 succs { 56 66 }
;; 56 succs { 57 58 }
;; 57 succs { 58 }
;; 58 succs { 59 60 }
;; 59 succs { 60 }
;; 60 succs { 61 64 }
;; 61 succs { 62 63 }
;; 62 succs { 65 }
;; 63 succs { 65 }
;; 64 succs { 65 }
;; 65 succs { 66 }
;; 66 succs { 67 68 }
;; 67 succs { 68 }
;; 68 succs { 69 70 }
;; 69 succs { 70 }
;; 70 succs { 71 74 }
;; 71 succs { 72 73 }
;; 72 succs { 75 }
;; 73 succs { 75 }
;; 74 succs { 75 }
;; 75 succs { 79 }
;; 76 succs { 78 77 }
;; 77 succs { 78 79 }
;; 78 succs { 3 79 }
;; 79 succs { 80 81 }
;; 80 succs { 81 }
;; 81 succs { 1 }
void winlinks_RB_REMOVE_COLOR (struct winlinks * head, struct winlink * parent, struct winlink * elm)
{
  struct winlink * oright;
  struct winlink * oleft;
  struct winlink * tmp;

  <bb 2> :
  goto <bb 76>; [INV]

  <bb 3> :
  _1 = parent->entry.rbe_left;
  if (elm == _1)
    goto <bb 4>; [INV]
  else
    goto <bb 40>; [INV]

  <bb 4> :
  tmp = parent->entry.rbe_right;
  _2 = tmp->entry.rbe_color;
  if (_2 == 1)
    goto <bb 5>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 5> :
  tmp->entry.rbe_color = 0;
  parent->entry.rbe_color = 1;
  tmp = parent->entry.rbe_right;
  _3 = tmp->entry.rbe_left;
  parent->entry.rbe_right = _3;
  _4 = parent->entry.rbe_right;
  if (_4 != 0B)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  _5 = tmp->entry.rbe_left;
  _5->entry.rbe_parent = parent;

  <bb 7> :
  _6 = parent->entry.rbe_parent;
  tmp->entry.rbe_parent = _6;
  _7 = tmp->entry.rbe_parent;
  if (_7 != 0B)
    goto <bb 8>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 8> :
  _8 = parent->entry.rbe_parent;
  _9 = _8->entry.rbe_left;
  if (parent == _9)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  _10 = parent->entry.rbe_parent;
  _10->entry.rbe_left = tmp;
  goto <bb 12>; [INV]

  <bb 10> :
  _11 = parent->entry.rbe_parent;
  _11->entry.rbe_right = tmp;
  goto <bb 12>; [INV]

  <bb 11> :
  head->rbh_root = tmp;

  <bb 12> :
  tmp->entry.rbe_left = parent;
  parent->entry.rbe_parent = tmp;
  _12 = tmp->entry.rbe_parent;
  tmp = parent->entry.rbe_right;

  <bb 13> :
  _13 = tmp->entry.rbe_left;
  if (_13 == 0B)
    goto <bb 15>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 14> :
  _14 = tmp->entry.rbe_left;
  _15 = _14->entry.rbe_color;
  if (_15 == 0)
    goto <bb 15>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 15> :
  _16 = tmp->entry.rbe_right;
  if (_16 == 0B)
    goto <bb 17>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 16> :
  _17 = tmp->entry.rbe_right;
  _18 = _17->entry.rbe_color;
  if (_18 == 0)
    goto <bb 17>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 17> :
  tmp->entry.rbe_color = 1;
  elm = parent;
  parent = elm->entry.rbe_parent;
  goto <bb 76>; [INV]

  <bb 18> :
  _19 = tmp->entry.rbe_right;
  if (_19 == 0B)
    goto <bb 20>; [INV]
  else
    goto <bb 19>; [INV]

  <bb 19> :
  _20 = tmp->entry.rbe_right;
  _21 = _20->entry.rbe_color;
  if (_21 == 0)
    goto <bb 20>; [INV]
  else
    goto <bb 30>; [INV]

  <bb 20> :
  oleft = tmp->entry.rbe_left;
  if (oleft != 0B)
    goto <bb 21>; [INV]
  else
    goto <bb 22>; [INV]

  <bb 21> :
  oleft->entry.rbe_color = 0;

  <bb 22> :
  tmp->entry.rbe_color = 1;
  oleft = tmp->entry.rbe_left;
  _22 = oleft->entry.rbe_right;
  tmp->entry.rbe_left = _22;
  _23 = tmp->entry.rbe_left;
  if (_23 != 0B)
    goto <bb 23>; [INV]
  else
    goto <bb 24>; [INV]

  <bb 23> :
  _24 = oleft->entry.rbe_right;
  _24->entry.rbe_parent = tmp;

  <bb 24> :
  _25 = tmp->entry.rbe_parent;
  oleft->entry.rbe_parent = _25;
  _26 = oleft->entry.rbe_parent;
  if (_26 != 0B)
    goto <bb 25>; [INV]
  else
    goto <bb 28>; [INV]

  <bb 25> :
  _27 = tmp->entry.rbe_parent;
  _28 = _27->entry.rbe_left;
  if (tmp == _28)
    goto <bb 26>; [INV]
  else
    goto <bb 27>; [INV]

  <bb 26> :
  _29 = tmp->entry.rbe_parent;
  _29->entry.rbe_left = oleft;
  goto <bb 29>; [INV]

  <bb 27> :
  _30 = tmp->entry.rbe_parent;
  _30->entry.rbe_right = oleft;
  goto <bb 29>; [INV]

  <bb 28> :
  head->rbh_root = oleft;

  <bb 29> :
  oleft->entry.rbe_right = tmp;
  tmp->entry.rbe_parent = oleft;
  _31 = oleft->entry.rbe_parent;
  tmp = parent->entry.rbe_right;

  <bb 30> :
  _32 = parent->entry.rbe_color;
  tmp->entry.rbe_color = _32;
  parent->entry.rbe_color = 0;
  _33 = tmp->entry.rbe_right;
  if (_33 != 0B)
    goto <bb 31>; [INV]
  else
    goto <bb 32>; [INV]

  <bb 31> :
  _34 = tmp->entry.rbe_right;
  _34->entry.rbe_color = 0;

  <bb 32> :
  tmp = parent->entry.rbe_right;
  _35 = tmp->entry.rbe_left;
  parent->entry.rbe_right = _35;
  _36 = parent->entry.rbe_right;
  if (_36 != 0B)
    goto <bb 33>; [INV]
  else
    goto <bb 34>; [INV]

  <bb 33> :
  _37 = tmp->entry.rbe_left;
  _37->entry.rbe_parent = parent;

  <bb 34> :
  _38 = parent->entry.rbe_parent;
  tmp->entry.rbe_parent = _38;
  _39 = tmp->entry.rbe_parent;
  if (_39 != 0B)
    goto <bb 35>; [INV]
  else
    goto <bb 38>; [INV]

  <bb 35> :
  _40 = parent->entry.rbe_parent;
  _41 = _40->entry.rbe_left;
  if (parent == _41)
    goto <bb 36>; [INV]
  else
    goto <bb 37>; [INV]

  <bb 36> :
  _42 = parent->entry.rbe_parent;
  _42->entry.rbe_left = tmp;
  goto <bb 39>; [INV]

  <bb 37> :
  _43 = parent->entry.rbe_parent;
  _43->entry.rbe_right = tmp;
  goto <bb 39>; [INV]

  <bb 38> :
  head->rbh_root = tmp;

  <bb 39> :
  tmp->entry.rbe_left = parent;
  parent->entry.rbe_parent = tmp;
  _44 = tmp->entry.rbe_parent;
  elm = head->rbh_root;
  goto <bb 79>; [INV]

  <bb 40> :
  tmp = parent->entry.rbe_left;
  _45 = tmp->entry.rbe_color;
  if (_45 == 1)
    goto <bb 41>; [INV]
  else
    goto <bb 49>; [INV]

  <bb 41> :
  tmp->entry.rbe_color = 0;
  parent->entry.rbe_color = 1;
  tmp = parent->entry.rbe_left;
  _46 = tmp->entry.rbe_right;
  parent->entry.rbe_left = _46;
  _47 = parent->entry.rbe_left;
  if (_47 != 0B)
    goto <bb 42>; [INV]
  else
    goto <bb 43>; [INV]

  <bb 42> :
  _48 = tmp->entry.rbe_right;
  _48->entry.rbe_parent = parent;

  <bb 43> :
  _49 = parent->entry.rbe_parent;
  tmp->entry.rbe_parent = _49;
  _50 = tmp->entry.rbe_parent;
  if (_50 != 0B)
    goto <bb 44>; [INV]
  else
    goto <bb 47>; [INV]

  <bb 44> :
  _51 = parent->entry.rbe_parent;
  _52 = _51->entry.rbe_left;
  if (parent == _52)
    goto <bb 45>; [INV]
  else
    goto <bb 46>; [INV]

  <bb 45> :
  _53 = parent->entry.rbe_parent;
  _53->entry.rbe_left = tmp;
  goto <bb 48>; [INV]

  <bb 46> :
  _54 = parent->entry.rbe_parent;
  _54->entry.rbe_right = tmp;
  goto <bb 48>; [INV]

  <bb 47> :
  head->rbh_root = tmp;

  <bb 48> :
  tmp->entry.rbe_right = parent;
  parent->entry.rbe_parent = tmp;
  _55 = tmp->entry.rbe_parent;
  tmp = parent->entry.rbe_left;

  <bb 49> :
  _56 = tmp->entry.rbe_left;
  if (_56 == 0B)
    goto <bb 51>; [INV]
  else
    goto <bb 50>; [INV]

  <bb 50> :
  _57 = tmp->entry.rbe_left;
  _58 = _57->entry.rbe_color;
  if (_58 == 0)
    goto <bb 51>; [INV]
  else
    goto <bb 54>; [INV]

  <bb 51> :
  _59 = tmp->entry.rbe_right;
  if (_59 == 0B)
    goto <bb 53>; [INV]
  else
    goto <bb 52>; [INV]

  <bb 52> :
  _60 = tmp->entry.rbe_right;
  _61 = _60->entry.rbe_color;
  if (_61 == 0)
    goto <bb 53>; [INV]
  else
    goto <bb 54>; [INV]

  <bb 53> :
  tmp->entry.rbe_color = 1;
  elm = parent;
  parent = elm->entry.rbe_parent;
  goto <bb 76>; [INV]

  <bb 54> :
  _62 = tmp->entry.rbe_left;
  if (_62 == 0B)
    goto <bb 56>; [INV]
  else
    goto <bb 55>; [INV]

  <bb 55> :
  _63 = tmp->entry.rbe_left;
  _64 = _63->entry.rbe_color;
  if (_64 == 0)
    goto <bb 56>; [INV]
  else
    goto <bb 66>; [INV]

  <bb 56> :
  oright = tmp->entry.rbe_right;
  if (oright != 0B)
    goto <bb 57>; [INV]
  else
    goto <bb 58>; [INV]

  <bb 57> :
  oright->entry.rbe_color = 0;

  <bb 58> :
  tmp->entry.rbe_color = 1;
  oright = tmp->entry.rbe_right;
  _65 = oright->entry.rbe_left;
  tmp->entry.rbe_right = _65;
  _66 = tmp->entry.rbe_right;
  if (_66 != 0B)
    goto <bb 59>; [INV]
  else
    goto <bb 60>; [INV]

  <bb 59> :
  _67 = oright->entry.rbe_left;
  _67->entry.rbe_parent = tmp;

  <bb 60> :
  _68 = tmp->entry.rbe_parent;
  oright->entry.rbe_parent = _68;
  _69 = oright->entry.rbe_parent;
  if (_69 != 0B)
    goto <bb 61>; [INV]
  else
    goto <bb 64>; [INV]

  <bb 61> :
  _70 = tmp->entry.rbe_parent;
  _71 = _70->entry.rbe_left;
  if (tmp == _71)
    goto <bb 62>; [INV]
  else
    goto <bb 63>; [INV]

  <bb 62> :
  _72 = tmp->entry.rbe_parent;
  _72->entry.rbe_left = oright;
  goto <bb 65>; [INV]

  <bb 63> :
  _73 = tmp->entry.rbe_parent;
  _73->entry.rbe_right = oright;
  goto <bb 65>; [INV]

  <bb 64> :
  head->rbh_root = oright;

  <bb 65> :
  oright->entry.rbe_left = tmp;
  tmp->entry.rbe_parent = oright;
  _74 = oright->entry.rbe_parent;
  tmp = parent->entry.rbe_left;

  <bb 66> :
  _75 = parent->entry.rbe_color;
  tmp->entry.rbe_color = _75;
  parent->entry.rbe_color = 0;
  _76 = tmp->entry.rbe_left;
  if (_76 != 0B)
    goto <bb 67>; [INV]
  else
    goto <bb 68>; [INV]

  <bb 67> :
  _77 = tmp->entry.rbe_left;
  _77->entry.rbe_color = 0;

  <bb 68> :
  tmp = parent->entry.rbe_left;
  _78 = tmp->entry.rbe_right;
  parent->entry.rbe_left = _78;
  _79 = parent->entry.rbe_left;
  if (_79 != 0B)
    goto <bb 69>; [INV]
  else
    goto <bb 70>; [INV]

  <bb 69> :
  _80 = tmp->entry.rbe_right;
  _80->entry.rbe_parent = parent;

  <bb 70> :
  _81 = parent->entry.rbe_parent;
  tmp->entry.rbe_parent = _81;
  _82 = tmp->entry.rbe_parent;
  if (_82 != 0B)
    goto <bb 71>; [INV]
  else
    goto <bb 74>; [INV]

  <bb 71> :
  _83 = parent->entry.rbe_parent;
  _84 = _83->entry.rbe_left;
  if (parent == _84)
    goto <bb 72>; [INV]
  else
    goto <bb 73>; [INV]

  <bb 72> :
  _85 = parent->entry.rbe_parent;
  _85->entry.rbe_left = tmp;
  goto <bb 75>; [INV]

  <bb 73> :
  _86 = parent->entry.rbe_parent;
  _86->entry.rbe_right = tmp;
  goto <bb 75>; [INV]

  <bb 74> :
  head->rbh_root = tmp;

  <bb 75> :
  tmp->entry.rbe_right = parent;
  parent->entry.rbe_parent = tmp;
  _87 = tmp->entry.rbe_parent;
  elm = head->rbh_root;
  goto <bb 79>; [INV]

  <bb 76> :
  if (elm == 0B)
    goto <bb 78>; [INV]
  else
    goto <bb 77>; [INV]

  <bb 77> :
  _88 = elm->entry.rbe_color;
  if (_88 == 0)
    goto <bb 78>; [INV]
  else
    goto <bb 79>; [INV]

  <bb 78> :
  _89 = head->rbh_root;
  if (elm != _89)
    goto <bb 3>; [INV]
  else
    goto <bb 79>; [INV]

  <bb 79> :
  if (elm != 0B)
    goto <bb 80>; [INV]
  else
    goto <bb 81>; [INV]

  <bb 80> :
  elm->entry.rbe_color = 0;

  <bb 81> :
  return;

}



;; Function winlinks_RB_INSERT (winlinks_RB_INSERT, funcdef_no=24, decl_uid=4130, cgraph_uid=25, symbol_order=24)

Removing basic block 13
;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
;;
;; Loop 1
;;  header 8, multiple latches: 4 6
;;  depth 1, outer 0
;;  nodes: 8 4 6 5 3
;; 2 succs { 8 }
;; 3 succs { 4 5 }
;; 4 succs { 8 }
;; 5 succs { 6 7 }
;; 6 succs { 8 }
;; 7 succs { 15 }
;; 8 succs { 3 9 }
;; 9 succs { 10 13 }
;; 10 succs { 11 12 }
;; 11 succs { 14 }
;; 12 succs { 14 }
;; 13 succs { 14 }
;; 14 succs { 15 }
;; 15 succs { 1 }
struct winlink * winlinks_RB_INSERT (struct winlinks * head, struct winlink * elm)
{
  int comp;
  struct winlink * parent;
  struct winlink * tmp;
  struct winlink * D.4484;

  <bb 2> :
  parent = 0B;
  comp = 0;
  tmp = head->rbh_root;
  goto <bb 8>; [INV]

  <bb 3> :
  parent = tmp;
  if (comp < 0)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  tmp = tmp->entry.rbe_left;
  goto <bb 8>; [INV]

  <bb 5> :
  if (comp > 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  tmp = tmp->entry.rbe_right;
  goto <bb 8>; [INV]

  <bb 7> :
  D.4484 = tmp;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 15>; [INV]

  <bb 8> :
  if (tmp != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 9> :
  elm->entry.rbe_parent = parent;
  elm->entry.rbe_right = 0B;
  _1 = elm->entry.rbe_right;
  elm->entry.rbe_left = _1;
  elm->entry.rbe_color = 1;
  if (parent != 0B)
    goto <bb 10>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 10> :
  if (comp < 0)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  parent->entry.rbe_left = elm;
  goto <bb 14>; [INV]

  <bb 12> :
  parent->entry.rbe_right = elm;
  goto <bb 14>; [INV]

  <bb 13> :
  head->rbh_root = elm;

  <bb 14> :
  winlinks_RB_INSERT_COLOR (head, elm);
  D.4484 = 0B;

  <bb 15> :
  return D.4484;

}



;; Function winlinks_RB_REMOVE (winlinks_RB_REMOVE, funcdef_no=25, decl_uid=4144, cgraph_uid=26, symbol_order=25)

Removing basic block 15
Removing basic block 23
Removing basic block 37
Merging blocks 41 and 42
;; 3 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38
;;
;; Loop 2
;;  header 27, latch 27
;;  depth 1, outer 0
;;  nodes: 27
;;
;; Loop 1
;;  header 8, latch 7
;;  depth 1, outer 0
;;  nodes: 8 7
;; 2 succs { 3 4 }
;; 3 succs { 29 }
;; 4 succs { 5 6 }
;; 5 succs { 29 }
;; 6 succs { 8 }
;; 7 succs { 8 }
;; 8 succs { 7 9 }
;; 9 succs { 10 11 }
;; 10 succs { 11 }
;; 11 succs { 12 15 }
;; 12 succs { 13 14 }
;; 13 succs { 16 }
;; 14 succs { 16 }
;; 15 succs { 16 }
;; 16 succs { 17 18 }
;; 17 succs { 18 }
;; 18 succs { 19 22 }
;; 19 succs { 20 21 }
;; 20 succs { 23 }
;; 21 succs { 23 }
;; 22 succs { 23 }
;; 23 succs { 24 25 }
;; 24 succs { 25 }
;; 25 succs { 26 28 }
;; 26 succs { 27 }
;; 27 succs { 27 28 }
;; 28 succs { 36 }
;; 29 succs { 30 31 }
;; 30 succs { 31 }
;; 31 succs { 32 35 }
;; 32 succs { 33 34 }
;; 33 succs { 36 }
;; 34 succs { 36 }
;; 35 succs { 36 }
;; 36 succs { 37 38 }
;; 37 succs { 38 }
;; 38 succs { 1 }
struct winlink * winlinks_RB_REMOVE (struct winlinks * head, struct winlink * elm)
{
  struct winlink * left;
  int color;
  struct winlink * old;
  struct winlink * parent;
  struct winlink * child;
  struct winlink * D.4528;

  <bb 2> :
  old = elm;
  _1 = elm->entry.rbe_left;
  if (_1 == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  child = elm->entry.rbe_right;
  goto <bb 29>; [INV]

  <bb 4> :
  _2 = elm->entry.rbe_right;
  if (_2 == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  child = elm->entry.rbe_left;
  goto <bb 29>; [INV]

  <bb 6> :
  elm = elm->entry.rbe_right;
  goto <bb 8>; [INV]

  <bb 7> :
  elm = left;

  <bb 8> :
  left = elm->entry.rbe_left;
  if (left != 0B)
    goto <bb 7>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 9> :
  child = elm->entry.rbe_right;
  parent = elm->entry.rbe_parent;
  color = elm->entry.rbe_color;
  if (child != 0B)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  child->entry.rbe_parent = parent;

  <bb 11> :
  if (parent != 0B)
    goto <bb 12>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 12> :
  _3 = parent->entry.rbe_left;
  if (elm == _3)
    goto <bb 13>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 13> :
  parent->entry.rbe_left = child;
  goto <bb 16>; [INV]

  <bb 14> :
  parent->entry.rbe_right = child;
  goto <bb 16>; [INV]

  <bb 15> :
  head->rbh_root = child;

  <bb 16> :
  _4 = elm->entry.rbe_parent;
  if (old == _4)
    goto <bb 17>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 17> :
  parent = elm;

  <bb 18> :
  elm->entry = old->entry;
  _5 = old->entry.rbe_parent;
  if (_5 != 0B)
    goto <bb 19>; [INV]
  else
    goto <bb 22>; [INV]

  <bb 19> :
  _6 = old->entry.rbe_parent;
  _7 = _6->entry.rbe_left;
  if (old == _7)
    goto <bb 20>; [INV]
  else
    goto <bb 21>; [INV]

  <bb 20> :
  _8 = old->entry.rbe_parent;
  _8->entry.rbe_left = elm;
  goto <bb 23>; [INV]

  <bb 21> :
  _9 = old->entry.rbe_parent;
  _9->entry.rbe_right = elm;
  goto <bb 23>; [INV]

  <bb 22> :
  head->rbh_root = elm;

  <bb 23> :
  _10 = old->entry.rbe_left;
  _10->entry.rbe_parent = elm;
  _11 = old->entry.rbe_right;
  if (_11 != 0B)
    goto <bb 24>; [INV]
  else
    goto <bb 25>; [INV]

  <bb 24> :
  _12 = old->entry.rbe_right;
  _12->entry.rbe_parent = elm;

  <bb 25> :
  if (parent != 0B)
    goto <bb 26>; [INV]
  else
    goto <bb 28>; [INV]

  <bb 26> :
  left = parent;

  <bb 27> :
  left = left->entry.rbe_parent;
  if (left != 0B)
    goto <bb 27>; [INV]
  else
    goto <bb 28>; [INV]

  <bb 28> :
  // predicted unlikely by goto predictor.
  goto <bb 36>; [INV]

  <bb 29> :
  parent = elm->entry.rbe_parent;
  color = elm->entry.rbe_color;
  if (child != 0B)
    goto <bb 30>; [INV]
  else
    goto <bb 31>; [INV]

  <bb 30> :
  child->entry.rbe_parent = parent;

  <bb 31> :
  if (parent != 0B)
    goto <bb 32>; [INV]
  else
    goto <bb 35>; [INV]

  <bb 32> :
  _13 = parent->entry.rbe_left;
  if (elm == _13)
    goto <bb 33>; [INV]
  else
    goto <bb 34>; [INV]

  <bb 33> :
  parent->entry.rbe_left = child;
  goto <bb 36>; [INV]

  <bb 34> :
  parent->entry.rbe_right = child;
  goto <bb 36>; [INV]

  <bb 35> :
  head->rbh_root = child;

  <bb 36> :
color:
  if (color == 0)
    goto <bb 37>; [INV]
  else
    goto <bb 38>; [INV]

  <bb 37> :
  winlinks_RB_REMOVE_COLOR (head, parent, child);

  <bb 38> :
  D.4528 = old;
  return D.4528;

}



;; Function winlinks_RB_FIND (winlinks_RB_FIND, funcdef_no=26, decl_uid=4168, cgraph_uid=27, symbol_order=26)

;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10
;;
;; Loop 1
;;  header 8, multiple latches: 4 6
;;  depth 1, outer 0
;;  nodes: 8 4 6 5 3
;; 2 succs { 8 }
;; 3 succs { 4 5 }
;; 4 succs { 8 }
;; 5 succs { 6 7 }
;; 6 succs { 8 }
;; 7 succs { 10 }
;; 8 succs { 3 9 }
;; 9 succs { 10 }
;; 10 succs { 1 }
struct winlink * winlinks_RB_FIND (struct winlinks * head, struct winlink * elm)
{
  int comp;
  struct winlink * tmp;
  struct winlink * D.4536;

  <bb 2> :
  tmp = head->rbh_root;
  goto <bb 8>; [INV]

  <bb 3> :
  comp = winlink_cmp (elm, tmp);
  if (comp < 0)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  tmp = tmp->entry.rbe_left;
  goto <bb 8>; [INV]

  <bb 5> :
  if (comp > 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  tmp = tmp->entry.rbe_right;
  goto <bb 8>; [INV]

  <bb 7> :
  D.4536 = tmp;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 10>; [INV]

  <bb 8> :
  if (tmp != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 9> :
  D.4536 = 0B;

  <bb 10> :
  return D.4536;

}



;; Function winlinks_RB_NFIND (winlinks_RB_NFIND, funcdef_no=27, decl_uid=4179, cgraph_uid=28, symbol_order=27)

;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10
;;
;; Loop 1
;;  header 8, multiple latches: 4 6
;;  depth 1, outer 0
;;  nodes: 8 4 6 5 3
;; 2 succs { 8 }
;; 3 succs { 4 5 }
;; 4 succs { 8 }
;; 5 succs { 6 7 }
;; 6 succs { 8 }
;; 7 succs { 10 }
;; 8 succs { 3 9 }
;; 9 succs { 10 }
;; 10 succs { 1 }
struct winlink * winlinks_RB_NFIND (struct winlinks * head, struct winlink * elm)
{
  int comp;
  struct winlink * res;
  struct winlink * tmp;
  struct winlink * D.4544;

  <bb 2> :
  tmp = head->rbh_root;
  res = 0B;
  goto <bb 8>; [INV]

  <bb 3> :
  comp = winlink_cmp (elm, tmp);
  if (comp < 0)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  res = tmp;
  tmp = tmp->entry.rbe_left;
  goto <bb 8>; [INV]

  <bb 5> :
  if (comp > 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  tmp = tmp->entry.rbe_right;
  goto <bb 8>; [INV]

  <bb 7> :
  D.4544 = tmp;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 10>; [INV]

  <bb 8> :
  if (tmp != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 9> :
  D.4544 = res;

  <bb 10> :
  return D.4544;

}



;; Function winlinks_RB_NEXT (winlinks_RB_NEXT, funcdef_no=28, decl_uid=4189, cgraph_uid=29, symbol_order=28)

Removing basic block 6
Removing basic block 10
Merging blocks 15 and 16
;; 3 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13
;;
;; Loop 2
;;  header 5, latch 4
;;  depth 1, outer 0
;;  nodes: 5 4
;;
;; Loop 1
;;  header 10, latch 9
;;  depth 1, outer 0
;;  nodes: 10 9 11
;; 2 succs { 3 6 }
;; 3 succs { 5 }
;; 4 succs { 5 }
;; 5 succs { 4 13 }
;; 6 succs { 7 10 }
;; 7 succs { 8 10 }
;; 8 succs { 13 }
;; 9 succs { 10 }
;; 10 succs { 11 12 }
;; 11 succs { 9 12 }
;; 12 succs { 13 }
;; 13 succs { 1 }
struct winlink * winlinks_RB_NEXT (struct winlink * elm)
{
  struct winlink * D.4554;

  <bb 2> :
  _1 = elm->entry.rbe_right;
  if (_1 != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 3> :
  elm = elm->entry.rbe_right;
  goto <bb 5>; [INV]

  <bb 4> :
  elm = elm->entry.rbe_left;

  <bb 5> :
  _2 = elm->entry.rbe_left;
  if (_2 != 0B)
    goto <bb 4>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 6> :
  _3 = elm->entry.rbe_parent;
  if (_3 != 0B)
    goto <bb 7>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 7> :
  _4 = elm->entry.rbe_parent;
  _5 = _4->entry.rbe_left;
  if (elm == _5)
    goto <bb 8>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 8> :
  elm = elm->entry.rbe_parent;
  goto <bb 13>; [INV]

  <bb 9> :
  elm = elm->entry.rbe_parent;

  <bb 10> :
  _6 = elm->entry.rbe_parent;
  if (_6 != 0B)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  _7 = elm->entry.rbe_parent;
  _8 = _7->entry.rbe_right;
  if (elm == _8)
    goto <bb 9>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 12> :
  elm = elm->entry.rbe_parent;

  <bb 13> :
  D.4554 = elm;
  return D.4554;

}



;; Function winlinks_RB_PREV (winlinks_RB_PREV, funcdef_no=29, decl_uid=4198, cgraph_uid=30, symbol_order=29)

Removing basic block 6
Removing basic block 10
Merging blocks 15 and 16
;; 3 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13
;;
;; Loop 2
;;  header 5, latch 4
;;  depth 1, outer 0
;;  nodes: 5 4
;;
;; Loop 1
;;  header 10, latch 9
;;  depth 1, outer 0
;;  nodes: 10 9 11
;; 2 succs { 3 6 }
;; 3 succs { 5 }
;; 4 succs { 5 }
;; 5 succs { 4 13 }
;; 6 succs { 7 10 }
;; 7 succs { 8 10 }
;; 8 succs { 13 }
;; 9 succs { 10 }
;; 10 succs { 11 12 }
;; 11 succs { 9 12 }
;; 12 succs { 13 }
;; 13 succs { 1 }
struct winlink * winlinks_RB_PREV (struct winlink * elm)
{
  struct winlink * D.4564;

  <bb 2> :
  _1 = elm->entry.rbe_left;
  if (_1 != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 3> :
  elm = elm->entry.rbe_left;
  goto <bb 5>; [INV]

  <bb 4> :
  elm = elm->entry.rbe_right;

  <bb 5> :
  _2 = elm->entry.rbe_right;
  if (_2 != 0B)
    goto <bb 4>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 6> :
  _3 = elm->entry.rbe_parent;
  if (_3 != 0B)
    goto <bb 7>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 7> :
  _4 = elm->entry.rbe_parent;
  _5 = _4->entry.rbe_right;
  if (elm == _5)
    goto <bb 8>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 8> :
  elm = elm->entry.rbe_parent;
  goto <bb 13>; [INV]

  <bb 9> :
  elm = elm->entry.rbe_parent;

  <bb 10> :
  _6 = elm->entry.rbe_parent;
  if (_6 != 0B)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  _7 = elm->entry.rbe_parent;
  _8 = _7->entry.rbe_left;
  if (elm == _8)
    goto <bb 9>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 12> :
  elm = elm->entry.rbe_parent;

  <bb 13> :
  D.4564 = elm;
  return D.4564;

}



;; Function winlinks_RB_MINMAX (winlinks_RB_MINMAX, funcdef_no=30, decl_uid=4208, cgraph_uid=31, symbol_order=30)

Merging blocks 7 and 8
;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7
;;
;; Loop 1
;;  header 6, multiple latches: 4 5
;;  depth 1, outer 0
;;  nodes: 6 4 5 3
;; 2 succs { 6 }
;; 3 succs { 4 5 }
;; 4 succs { 6 }
;; 5 succs { 6 }
;; 6 succs { 3 7 }
;; 7 succs { 1 }
struct winlink * winlinks_RB_MINMAX (struct winlinks * head, int val)
{
  struct winlink * parent;
  struct winlink * tmp;
  struct winlink * D.4569;

  <bb 2> :
  tmp = head->rbh_root;
  parent = 0B;
  goto <bb 6>; [INV]

  <bb 3> :
  parent = tmp;
  if (val < 0)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  tmp = tmp->entry.rbe_left;
  goto <bb 6>; [INV]

  <bb 5> :
  tmp = tmp->entry.rbe_right;

  <bb 6> :
  if (tmp != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  D.4569 = parent;
  return D.4569;

}



;; Function winlink_cmp (winlink_cmp, funcdef_no=31, decl_uid=4172, cgraph_uid=32, symbol_order=31)

Merging blocks 2 and 3
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
int winlink_cmp (struct winlink * wl1, struct winlink * wl2)
{
  int D.4571;

  <bb 2> :
  _1 = wl1->idx;
  _2 = wl2->idx;
  D.4571 = _1 - _2;
  return D.4571;

}



;; Function xasprintf (xasprintf, funcdef_no=32, decl_uid=4236, cgraph_uid=33, symbol_order=32)

Merging blocks 2 and 3
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
int xasprintf (char * * ret, const char * fmt, char * ap)
{
  int i;
  int D.4573;

  <bb 2> :
  i = xvasprintf (ret, fmt, ap);
  D.4573 = i;
  return D.4573;

}



;; Function xvasprintf (xvasprintf, funcdef_no=33, decl_uid=4239, cgraph_uid=34, symbol_order=33)

Merging blocks 5 and 6
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5
;; 2 succs { 4 3 }
;; 3 succs { 4 5 }
;; 4 succs { }
;; 5 succs { 1 }
int xvasprintf (char * * ret, const char * fmt, char * ap)
{
  int i;
  int D.4578;

  <bb 2> :
  i = vasprintf (ret, fmt, ap);
  if (i < 0)
    goto <bb 4>; [INV]
  else
    goto <bb 3>; [INV]

  <bb 3> :
  _1 = *ret;
  if (_1 == 0B)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  _2 = __errno_location ();
  _3 = *_2;
  _4 = strerror (_3);
  printf ("xasprintf: %s", _4);
  exit (1);

  <bb 5> :
  D.4578 = i;
  return D.4578;

}



;; Function main (main, funcdef_no=37, decl_uid=4321, cgraph_uid=38, symbol_order=37)

Removing basic block 4
Merging blocks 2 and 3
Merging blocks 2 and 5
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
int main ()
{
  struct session session;
  int D.4580;

  <bb 2> :
  status_prompt_complete (&session, "string");
  D.4580 = 0;
  session = {CLOBBER};
  return D.4580;

}



;; Function status_prompt_complete (status_prompt_complete, funcdef_no=36, decl_uid=4285, cgraph_uid=37, symbol_order=36)

Removing basic block 30
Merging blocks 49 and 50
;; 4 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48
;;
;; Loop 3
;;  header 46, latch 45
;;  depth 1, outer 0
;;  nodes: 46 45
;;
;; Loop 2
;;  header 29, latch 28
;;  depth 1, outer 0
;;  nodes: 29 28 24 26 27 25 23
;;
;; Loop 1
;;  header 37, latch 36
;;  depth 1, outer 0
;;  nodes: 37 36 32 34 35 33 31
;; 2 succs { 3 4 }
;; 3 succs { 48 }
;; 4 succs { 5 12 }
;; 5 succs { 6 12 }
;; 6 succs { 7 8 }
;; 7 succs { 11 }
;; 8 succs { 9 10 }
;; 9 succs { 11 }
;; 10 succs { 11 }
;; 11 succs { 48 }
;; 12 succs { 13 14 }
;; 13 succs { 15 }
;; 14 succs { 15 }
;; 15 succs { 16 17 }
;; 16 succs { 19 }
;; 17 succs { 18 19 }
;; 18 succs { 19 }
;; 19 succs { 20 21 }
;; 20 succs { 47 }
;; 21 succs { 22 30 }
;; 22 succs { 29 }
;; 23 succs { 24 25 }
;; 24 succs { 28 }
;; 25 succs { 26 27 }
;; 26 succs { 28 }
;; 27 succs { 28 }
;; 28 succs { 29 }
;; 29 succs { 23 38 }
;; 30 succs { 37 }
;; 31 succs { 32 33 }
;; 32 succs { 36 }
;; 33 succs { 34 35 }
;; 34 succs { 36 }
;; 35 succs { 36 }
;; 36 succs { 37 }
;; 37 succs { 31 38 }
;; 38 succs { 39 40 }
;; 39 succs { 42 }
;; 40 succs { 41 42 }
;; 41 succs { 42 }
;; 42 succs { 43 44 }
;; 43 succs { 44 }
;; 44 succs { 46 }
;; 45 succs { 46 }
;; 46 succs { 45 47 }
;; 47 succs { 48 }
;; 48 succs { 1 }
char * status_prompt_complete (struct session * session, const char * s)
{
  char * tmp;
  char * out;
  char * copy;
  struct window * w;
  struct winlink * wl;
  struct session * s_loop;
  u_int i;
  u_int size;
  const char * colon;
  const char * * list;
  char * D.4585;

  <bb 2> :
  list = 0B;
  size = 0;
  _1 = *s;
  if (_1 == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  D.4585 = 0B;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 48>; [INV]

  <bb 4> :
  out = 0B;
  _2 = strncmp (s, "-t", 2);
  if (_2 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 5> :
  _3 = strncmp (s, "-s", 2);
  if (_3 != 0)
    goto <bb 6>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 6> :
  list = status_prompt_complete_list (&size, s);
  size.0_4 = size;
  if (size.0_4 == 0)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  out = 0B;
  goto <bb 11>; [INV]

  <bb 8> :
  size.1_5 = size;
  if (size.1_5 == 1)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  _6 = *list;
  xasprintf (&out, "%s ", _6);
  goto <bb 11>; [INV]

  <bb 10> :
  size.2_7 = size;
  _8 = status_prompt_complete_prefix (list, size.2_7);
  out = _8;

  <bb 11> :
  free (list);
  D.4585 = out;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 48>; [INV]

  <bb 12> :
  copy = strdup (s);
  colon = ":";
  _9 = strlen (copy);
  _10 = _9 + 18446744073709551615;
  _11 = copy + _10;
  _12 = *_11;
  if (_12 == 58)
    goto <bb 13>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 13> :
  _13 = strlen (copy);
  _14 = _13 + 18446744073709551615;
  _15 = copy + _14;
  *_15 = 0;
  goto <bb 15>; [INV]

  <bb 14> :
  colon = "";

  <bb 15> :
  s = copy + 2;
  size.3_16 = size;
  if (size.3_16 == 1)
    goto <bb 16>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 16> :
  _17 = *list;
  _18 = strdup (_17);
  out = _18;
  goto <bb 19>; [INV]

  <bb 17> :
  size.4_19 = size;
  if (size.4_19 != 0)
    goto <bb 18>; [INV]
  else
    goto <bb 19>; [INV]

  <bb 18> :
  size.5_20 = size;
  _21 = status_prompt_complete_prefix (list, size.5_20);
  out = _21;

  <bb 19> :
  out.6_22 = out;
  if (out.6_22 != 0B)
    goto <bb 20>; [INV]
  else
    goto <bb 21>; [INV]

  <bb 20> :
  out.7_23 = out;
  xasprintf (&tmp, "-%s", out.7_23);
  tmp.8_24 = tmp;
  out = tmp.8_24;
  // predicted unlikely by goto predictor.
  goto <bb 47>; [INV]

  <bb 21> :
  colon = "";
  _25 = *s;
  if (_25 == 58)
    goto <bb 22>; [INV]
  else
    goto <bb 30>; [INV]

  <bb 22> :
  _26 = &session->windows;
  wl = winlinks_RB_MINMAX (_26, -1);
  goto <bb 29>; [INV]

  <bb 23> :
  _27 = wl->window;
  _28 = _27->name;
  xasprintf (&tmp, ":%s", _28);
  _29 = strlen (s);
  tmp.9_30 = tmp;
  _31 = strncmp (tmp.9_30, s, _29);
  if (_31 == 0)
    goto <bb 24>; [INV]
  else
    goto <bb 25>; [INV]

  <bb 24> :
  size.10_32 = size;
  size.11_33 = size.10_32;
  _34 = size.11_33 + 1;
  size = _34;
  _35 = (long unsigned int) size.11_33;
  _36 = _35 * 8;
  _37 = list + _36;
  tmp.12_38 = tmp;
  *_37 = tmp.12_38;
  // predicted unlikely by continue predictor.
  goto <bb 28>; [INV]

  <bb 25> :
  tmp.13_39 = tmp;
  free (tmp.13_39);
  _40 = wl->idx;
  _41 = (long int) _40;
  _42 = (char *) _41;
  xasprintf (&tmp, ":%d", _42);
  _43 = strlen (s);
  tmp.14_44 = tmp;
  _45 = strncmp (tmp.14_44, s, _43);
  if (_45 == 0)
    goto <bb 26>; [INV]
  else
    goto <bb 27>; [INV]

  <bb 26> :
  size.15_46 = size;
  size.16_47 = size.15_46;
  _48 = size.16_47 + 1;
  size = _48;
  _49 = (long unsigned int) size.16_47;
  _50 = _49 * 8;
  _51 = list + _50;
  tmp.17_52 = tmp;
  *_51 = tmp.17_52;
  // predicted unlikely by continue predictor.
  goto <bb 28>; [INV]

  <bb 27> :
  tmp.18_53 = tmp;
  free (tmp.18_53);

  <bb 28> :
  wl = winlinks_RB_NEXT (wl);

  <bb 29> :
  if (wl != 0B)
    goto <bb 23>; [INV]
  else
    goto <bb 38>; [INV]

  <bb 30> :
  _54 = &s_loop->windows;
  wl = winlinks_RB_MINMAX (_54, -1);
  goto <bb 37>; [INV]

  <bb 31> :
  w = wl->window;
  _55 = s_loop->name;
  xasprintf (&tmp, "%ss", _55);
  _56 = strlen (s);
  tmp.19_57 = tmp;
  _58 = strncmp (tmp.19_57, s, _56);
  if (_58 == 0)
    goto <bb 32>; [INV]
  else
    goto <bb 33>; [INV]

  <bb 32> :
  size.20_59 = size;
  size.21_60 = size.20_59;
  _61 = size.21_60 + 1;
  size = _61;
  _62 = (long unsigned int) size.21_60;
  _63 = _62 * 8;
  _64 = list + _63;
  tmp.22_65 = tmp;
  *_64 = tmp.22_65;
  // predicted unlikely by continue predictor.
  goto <bb 36>; [INV]

  <bb 33> :
  tmp.23_66 = tmp;
  free (tmp.23_66);
  _67 = s_loop->name;
  xasprintf (&tmp, "%s:", _67);
  _68 = strlen (s);
  tmp.24_69 = tmp;
  _70 = strncmp (tmp.24_69, s, _68);
  if (_70 == 0)
    goto <bb 34>; [INV]
  else
    goto <bb 35>; [INV]

  <bb 34> :
  size.25_71 = size;
  size.26_72 = size.25_71;
  _73 = size.26_72 + 1;
  size = _73;
  _74 = (long unsigned int) size.26_72;
  _75 = _74 * 8;
  _76 = list + _75;
  tmp.27_77 = tmp;
  *_76 = tmp.27_77;
  // predicted unlikely by continue predictor.
  goto <bb 36>; [INV]

  <bb 35> :
  tmp.28_78 = tmp;
  free (tmp.28_78);

  <bb 36> :
  wl = winlinks_RB_NEXT (wl);

  <bb 37> :
  if (wl != 0B)
    goto <bb 31>; [INV]
  else
    goto <bb 38>; [INV]

  <bb 38> :
  size.29_79 = size;
  if (size.29_79 == 1)
    goto <bb 39>; [INV]
  else
    goto <bb 40>; [INV]

  <bb 39> :
  _80 = *list;
  _81 = strdup (_80);
  out = _81;
  colon = " ";
  goto <bb 42>; [INV]

  <bb 40> :
  size.30_82 = size;
  if (size.30_82 != 0)
    goto <bb 41>; [INV]
  else
    goto <bb 42>; [INV]

  <bb 41> :
  size.31_83 = size;
  _84 = status_prompt_complete_prefix (list, size.31_83);
  out = _84;

  <bb 42> :
  out.32_85 = out;
  if (out.32_85 != 0B)
    goto <bb 43>; [INV]
  else
    goto <bb 44>; [INV]

  <bb 43> :
  out.33_86 = out;
  xasprintf (&tmp, "-%s", out.33_86);
  tmp.34_87 = tmp;
  out = tmp.34_87;

  <bb 44> :
  i = 0;
  goto <bb 46>; [INV]

  <bb 45> :
  _88 = (long unsigned int) i;
  _89 = _88 * 8;
  _90 = list + _89;
  _91 = *_90;
  free (_91);
  i = i + 1;

  <bb 46> :
  size.35_92 = size;
  if (i < size.35_92)
    goto <bb 45>; [INV]
  else
    goto <bb 47>; [INV]

  <bb 47> :
found:
  free (copy);
  free (list);
  D.4585 = out;

  <bb 48> :
  size = {CLOBBER};
  out = {CLOBBER};
  tmp = {CLOBBER};
  return D.4585;

}



;; Function status_prompt_complete_list (status_prompt_complete_list, funcdef_no=35, decl_uid=4270, cgraph_uid=36, symbol_order=35)

Merging blocks 7 and 8
Merging blocks 7 and 9
;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7
;;
;; Loop 1
;;  header 6, latch 5
;;  depth 1, outer 0
;;  nodes: 6 5 3 4
;; 2 succs { 6 }
;; 3 succs { 4 5 }
;; 4 succs { 5 }
;; 5 succs { 6 }
;; 6 succs { 3 7 }
;; 7 succs { 1 }
const char * * status_prompt_complete_list (u_int * size, const char * s)
{
  const char * layouts[6];
  const struct options_table_entry * oe;
  const struct cmd_entry * * cmdent;
  const char * * layout;
  const char * * list;
  const char * * D.4628;

  <bb 2> :
  list = 0B;
  layouts[0] = "even-horizontal";
  layouts[1] = "even-vertical";
  layouts[2] = "main-horizontal";
  layouts[3] = "main-vertical";
  layouts[4] = "tiled";
  layouts[5] = 0B;
  *size = 0;
  _1 = *size;
  _2 = (long unsigned int) _1;
  _3 = _2 * 8;
  list = malloc (_3);
  layout = &layouts;
  goto <bb 6>; [INV]

  <bb 3> :
  _4 = strlen (s);
  _5 = *layout;
  _6 = strncmp (_5, s, _4);
  if (_6 == 0)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  _7 = *size;
  _8 = _7;
  _9 = _8 + 1;
  *size = _9;
  _10 = (long unsigned int) _8;
  _11 = _10 * 8;
  _12 = list + _11;
  _13 = *layout;
  *_12 = _13;

  <bb 5> :
  layout = layout + 8;

  <bb 6> :
  _14 = *layout;
  if (_14 != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  D.4628 = list;
  layouts = {CLOBBER};
  return D.4628;

}



;; Function status_prompt_complete_prefix (status_prompt_complete_prefix, funcdef_no=34, decl_uid=4253, cgraph_uid=35, symbol_order=34)

Removing basic block 5
Merging blocks 12 and 13
;; 3 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11
;;
;; Loop 1
;;  header 10, latch 9
;;  depth 1, outer 0
;;  nodes: 10 9 8 4 7 3 5 6
;;
;; Loop 2
;;  header 8, latch 7
;;  depth 2, outer 1
;;  nodes: 8 7 5 6
;; 2 succs { 10 }
;; 3 succs { 4 8 }
;; 4 succs { 8 }
;; 5 succs { 6 7 }
;; 6 succs { 7 }
;; 7 succs { 8 }
;; 8 succs { 5 9 }
;; 9 succs { 10 }
;; 10 succs { 3 11 }
;; 11 succs { 1 }
char * status_prompt_complete_prefix (const char * * list, u_int size)
{
  size_t j;
  u_int i;
  char * out;
  char * D.4635;

  <bb 2> :
  _1 = *list;
  out = strdup (_1);
  i = 1;
  goto <bb 10>; [INV]

  <bb 3> :
  _2 = (long unsigned int) i;
  _3 = _2 * 8;
  _4 = list + _3;
  _5 = *_4;
  j = strlen (_5);
  _6 = strlen (out);
  if (j > _6)
    goto <bb 4>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 4> :
  j = strlen (out);
  goto <bb 8>; [INV]

  <bb 5> :
  _7 = j + 18446744073709551615;
  _8 = out + _7;
  _9 = *_8;
  _10 = (long unsigned int) i;
  _11 = _10 * 8;
  _12 = list + _11;
  _13 = *_12;
  _14 = j + 18446744073709551615;
  _15 = _13 + _14;
  _16 = *_15;
  if (_9 != _16)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  _17 = j + 18446744073709551615;
  _18 = out + _17;
  *_18 = 0;

  <bb 7> :
  j = j + 18446744073709551615;

  <bb 8> :
  if (j != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 9> :
  i = i + 1;

  <bb 10> :
  if (i < size)
    goto <bb 3>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 11> :
  D.4635 = out;
  return D.4635;

}


