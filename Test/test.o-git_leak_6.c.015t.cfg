
;; Function xrealloc (xrealloc, funcdef_no=26, decl_uid=3195, cgraph_uid=27, symbol_order=27)

Merging blocks 9 and 10
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9
;; 2 succs { 3 4 }
;; 3 succs { 4 }
;; 4 succs { 5 9 }
;; 5 succs { 6 7 }
;; 6 succs { 7 }
;; 7 succs { 8 9 }
;; 8 succs { }
;; 9 succs { 1 }
void * xrealloc (void * ptr, size_t size)
{
  void * ret;
  void * D.3328;

  <bb 2> :
  ret = realloc (ptr, size);
  _1 = ret == 0B;
  _2 = size == 0;
  _3 = _1 & _2;
  if (_3 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  ret = realloc (ptr, 1);

  <bb 4> :
  if (ret == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 5> :
  ret = realloc (ptr, size);
  _4 = ret == 0B;
  _5 = size == 0;
  _6 = _4 & _5;
  if (_6 != 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  ret = realloc (ptr, 1);

  <bb 7> :
  if (ret == 0B)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  printf ("Out of memory, realloc failed%s", "");
  exit (1);

  <bb 9> :
  D.3328 = ret;
  return D.3328;

}



;; Function commit_list_insert_by_date (commit_list_insert_by_date, funcdef_no=27, decl_uid=3200, cgraph_uid=28, symbol_order=28)

Merging blocks 6 and 7
;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6
;;
;; Loop 1
;;  header 5, latch 4
;;  depth 1, outer 0
;;  nodes: 5 4 3
;; 2 succs { 5 }
;; 3 succs { 6 4 }
;; 4 succs { 5 }
;; 5 succs { 3 6 }
;; 6 succs { 1 }
struct commit_list * commit_list_insert_by_date (struct commit * item, struct commit_list * * list)
{
  struct commit_list * p;
  struct commit_list * * pp;
  struct commit_list * D.3331;

  <bb 2> :
  pp = list;
  goto <bb 5>; [INV]

  <bb 3> :
  _1 = p->item;
  _2 = _1->date;
  _3 = item->date;
  if (_2 < _3)
    goto <bb 6>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 4> :
  pp = &p->next;

  <bb 5> :
  p = *pp;
  if (p != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 6> :
  _4 = commit_list_insert (item, pp);
  _5 = (long int) _4;
  D.3331 = (struct commit_list *) _5;
  return D.3331;

}



;; Function commit_list_insert (commit_list_insert, funcdef_no=29, decl_uid=3239, cgraph_uid=30, symbol_order=30)

Merging blocks 2 and 3
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
struct commit_list * commit_list_insert (struct commit * item, struct commit_list * * list_p)
{
  struct commit_list * new_list;
  struct commit_list * D.3333;

  <bb 2> :
  new_list = malloc (16);
  new_list->item = item;
  _1 = *list_p;
  new_list->next = _1;
  *list_p = new_list;
  D.3333 = new_list;
  return D.3333;

}



;; Function get_merge_bases_many_dirty (get_merge_bases_many_dirty, funcdef_no=31, decl_uid=3280, cgraph_uid=32, symbol_order=32)

Merging blocks 2 and 3
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
struct commit_list * get_merge_bases_many_dirty (struct commit * one, int n, struct commit * * twos)
{
  struct commit_list * D.3335;

  <bb 2> :
  D.3335 = get_merge_bases_many_0 (one, n, twos, 0);
  return D.3335;

}



;; Function get_merge_bases_many_0 (get_merge_bases_many_0, funcdef_no=30, decl_uid=3246, cgraph_uid=31, symbol_order=31)

Merging blocks 19 and 20
;; 4 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19
;;
;; Loop 3
;;  header 17, latch 16
;;  depth 1, outer 0
;;  nodes: 17 16
;;
;; Loop 2
;;  header 14, latch 13
;;  depth 1, outer 0
;;  nodes: 14 13
;;
;; Loop 1
;;  header 6, latch 5
;;  depth 1, outer 0
;;  nodes: 6 5 3
;; 2 succs { 6 }
;; 3 succs { 4 5 }
;; 4 succs { 19 }
;; 5 succs { 6 }
;; 6 succs { 3 7 }
;; 7 succs { 9 8 }
;; 8 succs { 9 12 }
;; 9 succs { 10 11 }
;; 10 succs { 11 }
;; 11 succs { 19 }
;; 12 succs { 14 }
;; 13 succs { 14 }
;; 14 succs { 13 15 }
;; 15 succs { 17 }
;; 16 succs { 17 }
;; 17 succs { 16 18 }
;; 18 succs { 19 }
;; 19 succs { 1 }
struct commit_list * get_merge_bases_many_0 (struct commit * one, int n, struct commit * * twos, int cleanup)
{
  int i;
  int cnt;
  struct commit_list * result;
  struct commit * * rslt;
  struct commit_list * list;
  struct commit_list * D.3339;

  <bb 2> :
  _1 = merge_bases_many (one, n, twos);
  result = _1;
  i = 0;
  goto <bb 6>; [INV]

  <bb 3> :
  _2 = (long unsigned int) i;
  _3 = _2 * 8;
  _4 = twos + _3;
  _5 = *_4;
  if (one == _5)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  D.3339 = result;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 19>; [INV]

  <bb 5> :
  i = i + 1;

  <bb 6> :
  if (i < n)
    goto <bb 3>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  result.0_6 = result;
  if (result.0_6 == 0B)
    goto <bb 9>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 8> :
  result.1_7 = result;
  _8 = result.1_7->next;
  if (_8 == 0B)
    goto <bb 9>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 9> :
  if (cleanup != 0)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  clear_commit_marks (one, 983040);
  clear_commit_marks_many (n, twos, 983040);

  <bb 11> :
  D.3339 = result;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 19>; [INV]

  <bb 12> :
  result.2_9 = result;
  cnt = commit_list_count (result.2_9);
  _10 = (long unsigned int) cnt;
  rslt = calloc (_10, 8);
  list = result;
  i = 0;
  goto <bb 14>; [INV]

  <bb 13> :
  i.3_11 = i;
  i = i.3_11 + 1;
  _12 = (long unsigned int) i.3_11;
  _13 = _12 * 8;
  _14 = rslt + _13;
  _15 = list->item;
  *_14 = _15;
  list = list->next;

  <bb 14> :
  if (list != 0B)
    goto <bb 13>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 15> :
  result.4_16 = result;
  free_commit_list (result.4_16);
  clear_commit_marks (one, 983040);
  clear_commit_marks_many (n, twos, 983040);
  cnt = remove_redundant (rslt, cnt);
  result = 0B;
  i = 0;
  goto <bb 17>; [INV]

  <bb 16> :
  _17 = (long unsigned int) i;
  _18 = _17 * 8;
  _19 = rslt + _18;
  _20 = *_19;
  commit_list_insert_by_date (_20, &result);
  i = i + 1;

  <bb 17> :
  if (i < cnt)
    goto <bb 16>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 18> :
  free (rslt);
  D.3339 = result;

  <bb 19> :
  result = {CLOBBER};
  return D.3339;

}



;; Function merge_bases_many (merge_bases_many, funcdef_no=28, decl_uid=3212, cgraph_uid=29, symbol_order=29)

Merging blocks 19 and 20
;; 4 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19
;;
;; Loop 3
;;  header 17, multiple latches: 15 16
;;  depth 1, outer 0
;;  nodes: 17 15 16
;;
;; Loop 2
;;  header 13, latch 12
;;  depth 1, outer 0
;;  nodes: 13 12 10
;;
;; Loop 1
;;  header 6, latch 5
;;  depth 1, outer 0
;;  nodes: 6 5 3
;; 2 succs { 6 }
;; 3 succs { 4 5 }
;; 4 succs { 19 }
;; 5 succs { 6 }
;; 6 succs { 3 7 }
;; 7 succs { 8 9 }
;; 8 succs { 19 }
;; 9 succs { 13 }
;; 10 succs { 11 12 }
;; 11 succs { 19 }
;; 12 succs { 13 }
;; 13 succs { 10 14 }
;; 14 succs { 17 }
;; 15 succs { 16 17 }
;; 16 succs { 17 }
;; 17 succs { 15 18 }
;; 18 succs { 19 }
;; 19 succs { 1 }
struct commit_list * merge_bases_many (struct commit * one, int n, struct commit * * twos)
{
  struct commit * commit;
  int i;
  struct commit_list * result;
  struct commit_list * list;
  struct commit_list * D.3349;

  <bb 2> :
  list = 0B;
  result = 0B;
  i = 0;
  goto <bb 6>; [INV]

  <bb 3> :
  _1 = (long unsigned int) i;
  _2 = _1 * 8;
  _3 = twos + _2;
  _4 = *_3;
  if (one == _4)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  _5 = commit_list_insert (one, &result);
  _6 = (long int) _5;
  D.3349 = (struct commit_list *) _6;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 19>; [INV]

  <bb 5> :
  i = i + 1;

  <bb 6> :
  if (i < n)
    goto <bb 3>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  _7 = parse_commit (one);
  if (_7 != 0)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  D.3349 = 0B;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 19>; [INV]

  <bb 9> :
  i = 0;
  goto <bb 13>; [INV]

  <bb 10> :
  _8 = (long unsigned int) i;
  _9 = _8 * 8;
  _10 = twos + _9;
  _11 = *_10;
  _12 = parse_commit (_11);
  if (_12 != 0)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  D.3349 = 0B;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 19>; [INV]

  <bb 12> :
  i = i + 1;

  <bb 13> :
  if (i < n)
    goto <bb 10>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 14> :
  _13 = paint_down_to_common (one, n, twos);
  _14 = (long int) _13;
  _15 = (struct commit_list *) _14;
  list = _15;
  goto <bb 17>; [INV]

  <bb 15> :
  _16 = pop_commit (&list);
  _17 = (long int) _16;
  commit = (struct commit *) _17;
  _18 = commit->object.flags;
  _19 = (unsigned int) _18;
  _20 = _19 & 262144;
  if (_20 == 0)
    goto <bb 16>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 16> :
  commit_list_insert_by_date (commit, &result);

  <bb 17> :
  list.5_21 = list;
  if (list.5_21 != 0B)
    goto <bb 15>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 18> :
  D.3349 = result;

  <bb 19> :
  list = {CLOBBER};
  result = {CLOBBER};
  return D.3349;

}



;; Function main (main, funcdef_no=34, decl_uid=3314, cgraph_uid=35, symbol_order=35)

Removing basic block 4
Merging blocks 2 and 3
Merging blocks 2 and 5
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
int main (int argc, char * * argv)
{
  int rev_nr;
  int show_all;
  struct commit * rev;
  int D.3358;

  <bb 2> :
  show_merge_base (&rev, rev_nr, show_all);
  handle_independent (argc, argv);
  D.3358 = 0;
  rev = {CLOBBER};
  return D.3358;

}



;; Function show_merge_base (show_merge_base, funcdef_no=32, decl_uid=3285, cgraph_uid=33, symbol_order=33)

Removing basic block 4
;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9
;;
;; Loop 1
;;  header 7, latch 6
;;  depth 1, outer 0
;;  nodes: 7 6 4
;; 2 succs { 3 7 }
;; 3 succs { 9 }
;; 4 succs { 5 6 }
;; 5 succs { 9 }
;; 6 succs { 7 }
;; 7 succs { 4 8 }
;; 8 succs { 9 }
;; 9 succs { 1 }
int show_merge_base (struct commit * * rev, int rev_nr, int show_all)
{
  struct commit_list * result;
  int D.3363;

  <bb 2> :
  _1 = rev + 8;
  _2 = rev_nr + -1;
  _3 = *rev;
  result = get_merge_bases_many_dirty (_3, _2, _1);
  if (result == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 3> :
  D.3363 = 1;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 9>; [INV]

  <bb 4> :
  _4 = result->item;
  _5 = &_4->object.oid;
  _6 = oid_to_hex (_5);
  printf ("%s\n", _6);
  if (show_all == 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  D.3363 = 0;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 9>; [INV]

  <bb 6> :
  result = result->next;

  <bb 7> :
  if (result != 0B)
    goto <bb 4>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 8> :
  D.3363 = 0;

  <bb 9> :
  return D.3363;

}



;; Function handle_independent (handle_independent, funcdef_no=33, decl_uid=3295, cgraph_uid=34, symbol_order=34)

Removing basic block 7
Merging blocks 11 and 12
;; 3 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10
;;
;; Loop 2
;;  header 8, latch 7
;;  depth 1, outer 0
;;  nodes: 8 7
;;
;; Loop 1
;;  header 4, latch 3
;;  depth 1, outer 0
;;  nodes: 4 3
;; 2 succs { 4 }
;; 3 succs { 4 }
;; 4 succs { 3 5 }
;; 5 succs { 6 8 }
;; 6 succs { 10 }
;; 7 succs { 8 }
;; 8 succs { 7 9 }
;; 9 succs { 10 }
;; 10 succs { 1 }
int handle_independent (int count, const char * * args)
{
  int i;
  struct commit_list * result;
  struct commit_list * revs;
  int D.3369;

  <bb 2> :
  revs = 0B;
  i = count + -1;
  goto <bb 4>; [INV]

  <bb 3> :
  _1 = (long unsigned int) i;
  _2 = _1 * 8;
  _3 = args + _2;
  _4 = *_3;
  _5 = get_commit_reference (_4);
  _6 = (long int) _5;
  _7 = (struct commit *) _6;
  commit_list_insert (_7, &revs);
  i = i + -1;

  <bb 4> :
  if (i >= 0)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 5> :
  revs.6_8 = revs;
  _9 = reduce_heads (revs.6_8);
  _10 = (long int) _9;
  result = (struct commit_list *) _10;
  if (result == 0B)
    goto <bb 6>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 6> :
  D.3369 = 1;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 10>; [INV]

  <bb 7> :
  _11 = result->item;
  _12 = &_11->object.oid;
  _13 = oid_to_hex (_12);
  printf ("%s\n", _13);
  result = result->next;

  <bb 8> :
  if (result != 0B)
    goto <bb 7>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 9> :
  D.3369 = 0;

  <bb 10> :
  revs = {CLOBBER};
  return D.3369;

}


