
;; Function bool __gnu_cxx::__is_null_pointer(std::nullptr_t) (null)
;; enabled by -tree-original


return <retval> = 1;


;; Function constexpr __gnu_cxx::__ops::_Iter_less_iter __gnu_cxx::__ops::__iter_less_iter() (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = TARGET_EXPR <D.7902, {}>>>;


;; Function __gnu_cxx::__ops::_Iter_less_val::_Iter_less_val(__gnu_cxx::__ops::_Iter_less_iter) (null)
;; enabled by -tree-original


{
  
}


;; Function __gnu_cxx::__ops::_Iter_less_val __gnu_cxx::__ops::__iter_less_val() (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = TARGET_EXPR <D.7973, {}>>>;


;; Function __gnu_cxx::__ops::_Iter_less_val __gnu_cxx::__ops::__iter_comp_val(__gnu_cxx::__ops::_Iter_less_iter) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = TARGET_EXPR <D.7978, {}>>>;


;; Function __gnu_cxx::__ops::_Val_less_iter::_Val_less_iter(__gnu_cxx::__ops::_Iter_less_iter) (null)
;; enabled by -tree-original


{
  
}


;; Function __gnu_cxx::__ops::_Val_less_iter __gnu_cxx::__ops::__val_less_iter() (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = TARGET_EXPR <D.8040, {}>>>;


;; Function __gnu_cxx::__ops::_Val_less_iter __gnu_cxx::__ops::__val_comp_iter(__gnu_cxx::__ops::_Iter_less_iter) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = TARGET_EXPR <D.8045, {}>>>;


;; Function __gnu_cxx::__ops::_Iter_equal_to_iter __gnu_cxx::__ops::__iter_equal_to_iter() (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = TARGET_EXPR <D.8083, {}>>>;


;; Function __gnu_cxx::__ops::_Iter_equal_to_val __gnu_cxx::__ops::__iter_equal_to_val() (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = TARGET_EXPR <D.8130, {}>>>;


;; Function __gnu_cxx::__ops::_Iter_equal_to_val __gnu_cxx::__ops::__iter_comp_val(__gnu_cxx::__ops::_Iter_equal_to_iter) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = TARGET_EXPR <D.8143, {}>>>;


;; Function constexpr int std::__lg(int) (null)
;; enabled by -tree-original


return <retval> = (int) (31 - (unsigned int) __builtin_clz ((unsigned int) __n));


;; Function constexpr unsigned int std::__lg(unsigned int) (null)
;; enabled by -tree-original


return <retval> = 31 - (unsigned int) __builtin_clz (__n);


;; Function constexpr long int std::__lg(long int) (null)
;; enabled by -tree-original


return <retval> = (long int) (63 - (long unsigned int) __builtin_clzl ((long unsigned int) __n));


;; Function constexpr long unsigned int std::__lg(long unsigned int) (null)
;; enabled by -tree-original


return <retval> = 63 - (long unsigned int) __builtin_clzl (__n);


;; Function constexpr long long int std::__lg(long long int) (null)
;; enabled by -tree-original


return <retval> = (long long int) (63 - (long unsigned int) __builtin_clzll ((long long unsigned int) __n));


;; Function constexpr long long unsigned int std::__lg(long long unsigned int) (null)
;; enabled by -tree-original


return <retval> = (long long unsigned int) (63 - (long unsigned int) __builtin_clzll (__n));


;; Function wint_t btowc(int) (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  <<cleanup_point return <retval> = __builtin_constant_p (__c) == 0 || (unsigned int) __c > 127 ? __btowc_alias (__c) : (wint_t) __c>>
   >>>;


;; Function int wctob(wint_t) (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  <<cleanup_point return <retval> = __builtin_constant_p (__wc) == 0 || __wc > 127 ? __wctob_alias (__wc) : (int) __wc>>
   >>>;


;; Function size_t mbrlen(const char*, size_t, mbstate_t*) (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  <<cleanup_point return <retval> = __ps != 0B ? mbrtowc (0B, __s, __n, __ps) : __mbrlen (__s, __n, 0B)>>
   >>>;


;; Function wchar_t* wmemcpy(wchar_t*, const wchar_t*, size_t) (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  if (__builtin_object_size ((const void *) __s1, 0) != 18446744073709551615)
    {
      if (__builtin_constant_p (__n) == 0)
        {
          <<cleanup_point return <retval> = __wmemcpy_chk (__s1, __s2, __n, __builtin_object_size ((const void *) __s1, 0) / 4)>>;
        }
      if (__builtin_object_size ((const void *) __s1, 0) / 4 < __n)
        {
          <<cleanup_point return <retval> = __wmemcpy_chk_warn (__s1, __s2, __n, __builtin_object_size ((const void *) __s1, 0) / 4)>>;
        }
    }
  <<cleanup_point return <retval> = __wmemcpy_alias (__s1, __s2, __n)>>;
   >>>;


;; Function wchar_t* wmemmove(wchar_t*, const wchar_t*, size_t) (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  if (__builtin_object_size ((const void *) __s1, 0) != 18446744073709551615)
    {
      if (__builtin_constant_p (__n) == 0)
        {
          <<cleanup_point return <retval> = __wmemmove_chk (__s1, __s2, __n, __builtin_object_size ((const void *) __s1, 0) / 4)>>;
        }
      if (__builtin_object_size ((const void *) __s1, 0) / 4 < __n)
        {
          <<cleanup_point return <retval> = __wmemmove_chk_warn (__s1, __s2, __n, __builtin_object_size ((const void *) __s1, 0) / 4)>>;
        }
    }
  <<cleanup_point return <retval> = __wmemmove_alias (__s1, __s2, __n)>>;
   >>>;


;; Function wchar_t* wmempcpy(wchar_t*, const wchar_t*, size_t) (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  if (__builtin_object_size ((const void *) __s1, 0) != 18446744073709551615)
    {
      if (__builtin_constant_p (__n) == 0)
        {
          <<cleanup_point return <retval> = __wmempcpy_chk (__s1, __s2, __n, __builtin_object_size ((const void *) __s1, 0) / 4)>>;
        }
      if (__builtin_object_size ((const void *) __s1, 0) / 4 < __n)
        {
          <<cleanup_point return <retval> = __wmempcpy_chk_warn (__s1, __s2, __n, __builtin_object_size ((const void *) __s1, 0) / 4)>>;
        }
    }
  <<cleanup_point return <retval> = __wmempcpy_alias (__s1, __s2, __n)>>;
   >>>;


;; Function wchar_t* wmemset(wchar_t*, wchar_t, size_t) (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  if (__builtin_object_size ((const void *) __s, 0) != 18446744073709551615)
    {
      if (__builtin_constant_p (__n) == 0)
        {
          <<cleanup_point return <retval> = __wmemset_chk (__s, __c, __n, __builtin_object_size ((const void *) __s, 0) / 4)>>;
        }
      if (__builtin_object_size ((const void *) __s, 0) / 4 < __n)
        {
          <<cleanup_point return <retval> = __wmemset_chk_warn (__s, __c, __n, __builtin_object_size ((const void *) __s, 0) / 4)>>;
        }
    }
  <<cleanup_point return <retval> = __wmemset_alias (__s, __c, __n)>>;
   >>>;


;; Function wchar_t* wcscpy(wchar_t*, const wchar_t*) (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  if (__builtin_object_size ((const void *) __dest, 1) != 18446744073709551615)
    {
      <<cleanup_point return <retval> = __wcscpy_chk (__dest, __src, __builtin_object_size ((const void *) __dest, 1) / 4)>>;
    }
  <<cleanup_point return <retval> = __wcscpy_alias (__dest, __src)>>;
   >>>;


;; Function wchar_t* wcpcpy(wchar_t*, const wchar_t*) (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  if (__builtin_object_size ((const void *) __dest, 1) != 18446744073709551615)
    {
      <<cleanup_point return <retval> = __wcpcpy_chk (__dest, __src, __builtin_object_size ((const void *) __dest, 1) / 4)>>;
    }
  <<cleanup_point return <retval> = __wcpcpy_alias (__dest, __src)>>;
   >>>;


;; Function wchar_t* wcsncpy(wchar_t*, const wchar_t*, size_t) (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  if (__builtin_object_size ((const void *) __dest, 1) != 18446744073709551615)
    {
      if (__builtin_constant_p (__n) == 0)
        {
          <<cleanup_point return <retval> = __wcsncpy_chk (__dest, __src, __n, __builtin_object_size ((const void *) __dest, 1) / 4)>>;
        }
      if (__builtin_object_size ((const void *) __dest, 1) / 4 < __n)
        {
          <<cleanup_point return <retval> = __wcsncpy_chk_warn (__dest, __src, __n, __builtin_object_size ((const void *) __dest, 1) / 4)>>;
        }
    }
  <<cleanup_point return <retval> = __wcsncpy_alias (__dest, __src, __n)>>;
   >>>;


;; Function wchar_t* wcpncpy(wchar_t*, const wchar_t*, size_t) (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  if (__builtin_object_size ((const void *) __dest, 1) != 18446744073709551615)
    {
      if (__builtin_constant_p (__n) == 0)
        {
          <<cleanup_point return <retval> = __wcpncpy_chk (__dest, __src, __n, __builtin_object_size ((const void *) __dest, 1) / 4)>>;
        }
      if (__builtin_object_size ((const void *) __dest, 1) / 4 < __n)
        {
          <<cleanup_point return <retval> = __wcpncpy_chk_warn (__dest, __src, __n, __builtin_object_size ((const void *) __dest, 1) / 4)>>;
        }
    }
  <<cleanup_point return <retval> = __wcpncpy_alias (__dest, __src, __n)>>;
   >>>;


;; Function wchar_t* wcscat(wchar_t*, const wchar_t*) (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  if (__builtin_object_size ((const void *) __dest, 1) != 18446744073709551615)
    {
      <<cleanup_point return <retval> = __wcscat_chk (__dest, __src, __builtin_object_size ((const void *) __dest, 1) / 4)>>;
    }
  <<cleanup_point return <retval> = __wcscat_alias (__dest, __src)>>;
   >>>;


;; Function wchar_t* wcsncat(wchar_t*, const wchar_t*, size_t) (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  if (__builtin_object_size ((const void *) __dest, 1) != 18446744073709551615)
    {
      <<cleanup_point return <retval> = __wcsncat_chk (__dest, __src, __n, __builtin_object_size ((const void *) __dest, 1) / 4)>>;
    }
  <<cleanup_point return <retval> = __wcsncat_alias (__dest, __src, __n)>>;
   >>>;


;; Function int swprintf(wchar_t*, size_t, const wchar_t*, ...) (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  <<cleanup_point return <retval> = __swprintf_chk (__s, __n, 1, __builtin_object_size ((const void *) __s, 1) / 4, __fmt, __builtin_va_arg_pack ())>>;
  <<cleanup_point return <retval> = __swprintf_alias (__s, __n, __fmt, __builtin_va_arg_pack ())>>;
   >>>;


;; Function int vswprintf(wchar_t*, size_t, const wchar_t*, __va_list_tag*) (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  <<cleanup_point return <retval> = __vswprintf_chk (__s, __n, 1, __builtin_object_size ((const void *) __s, 1) / 4, __fmt, __ap)>>;
  <<cleanup_point return <retval> = __vswprintf_alias (__s, __n, __fmt, __ap)>>;
   >>>;


;; Function int wprintf(const wchar_t*, ...) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __wprintf_chk (1, __fmt, __builtin_va_arg_pack ())>>;


;; Function int fwprintf(__FILE*, const wchar_t*, ...) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __fwprintf_chk (__stream, 1, __fmt, __builtin_va_arg_pack ())>>;


;; Function int vwprintf(const wchar_t*, __va_list_tag*) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __vwprintf_chk (1, __fmt, __ap)>>;


;; Function int vfwprintf(__FILE*, const wchar_t*, __va_list_tag*) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __vfwprintf_chk (__stream, 1, __fmt, __ap)>>;


;; Function wchar_t* fgetws(wchar_t*, int, __FILE*) (null)
;; enabled by -tree-original


if (__builtin_object_size ((const void *) __s, 1) != 18446744073709551615)
  {
    if (__builtin_constant_p (__n) == 0 || __n <= 0)
      {
        <<cleanup_point return <retval> = __fgetws_chk (__s, __builtin_object_size ((const void *) __s, 1) / 4, __n, __stream)>>;
      }
    if ((size_t) __n > __builtin_object_size ((const void *) __s, 1) / 4)
      {
        <<cleanup_point return <retval> = __fgetws_chk_warn (__s, __builtin_object_size ((const void *) __s, 1) / 4, __n, __stream)>>;
      }
  }
<<cleanup_point return <retval> = __fgetws_alias (__s, __n, __stream)>>;


;; Function wchar_t* fgetws_unlocked(wchar_t*, int, __FILE*) (null)
;; enabled by -tree-original


if (__builtin_object_size ((const void *) __s, 1) != 18446744073709551615)
  {
    if (__builtin_constant_p (__n) == 0 || __n <= 0)
      {
        <<cleanup_point return <retval> = __fgetws_unlocked_chk (__s, __builtin_object_size ((const void *) __s, 1) / 4, __n, __stream)>>;
      }
    if ((size_t) __n > __builtin_object_size ((const void *) __s, 1) / 4)
      {
        <<cleanup_point return <retval> = __fgetws_unlocked_chk_warn (__s, __builtin_object_size ((const void *) __s, 1) / 4, __n, __stream)>>;
      }
  }
<<cleanup_point return <retval> = __fgetws_unlocked_alias (__s, __n, __stream)>>;


;; Function size_t wcrtomb(char*, wchar_t, mbstate_t*) (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  if (__builtin_object_size ((const void *) __s, 1) != 18446744073709551615 && __builtin_object_size ((const void *) __s, 1) <= 15)
    {
      <<cleanup_point return <retval> = __wcrtomb_chk (__s, __wchar, __ps, __builtin_object_size ((const void *) __s, 1))>>;
    }
  <<cleanup_point return <retval> = __wcrtomb_alias (__s, __wchar, __ps)>>;
   >>>;


;; Function size_t mbsrtowcs(wchar_t*, const char**, size_t, mbstate_t*) (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  if (__builtin_object_size ((const void *) __dst, 1) != 18446744073709551615)
    {
      if (__builtin_constant_p (__len) == 0)
        {
          <<cleanup_point return <retval> = __mbsrtowcs_chk (__dst, __src, __len, __ps, __builtin_object_size ((const void *) __dst, 1) / 4)>>;
        }
      if (__builtin_object_size ((const void *) __dst, 1) / 4 < __len)
        {
          <<cleanup_point return <retval> = __mbsrtowcs_chk_warn (__dst, __src, __len, __ps, __builtin_object_size ((const void *) __dst, 1) / 4)>>;
        }
    }
  <<cleanup_point return <retval> = __mbsrtowcs_alias (__dst, __src, __len, __ps)>>;
   >>>;


;; Function size_t wcsrtombs(char*, const wchar_t**, size_t, mbstate_t*) (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  if (__builtin_object_size ((const void *) __dst, 1) != 18446744073709551615)
    {
      if (__builtin_constant_p (__len) == 0)
        {
          <<cleanup_point return <retval> = __wcsrtombs_chk (__dst, __src, __len, __ps, __builtin_object_size ((const void *) __dst, 1))>>;
        }
      if (__builtin_object_size ((const void *) __dst, 1) < __len)
        {
          <<cleanup_point return <retval> = __wcsrtombs_chk_warn (__dst, __src, __len, __ps, __builtin_object_size ((const void *) __dst, 1))>>;
        }
    }
  <<cleanup_point return <retval> = __wcsrtombs_alias (__dst, __src, __len, __ps)>>;
   >>>;


;; Function size_t mbsnrtowcs(wchar_t*, const char**, size_t, size_t, mbstate_t*) (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  if (__builtin_object_size ((const void *) __dst, 1) != 18446744073709551615)
    {
      if (__builtin_constant_p (__len) == 0)
        {
          <<cleanup_point return <retval> = __mbsnrtowcs_chk (__dst, __src, __nmc, __len, __ps, __builtin_object_size ((const void *) __dst, 1) / 4)>>;
        }
      if (__builtin_object_size ((const void *) __dst, 1) / 4 < __len)
        {
          <<cleanup_point return <retval> = __mbsnrtowcs_chk_warn (__dst, __src, __nmc, __len, __ps, __builtin_object_size ((const void *) __dst, 1) / 4)>>;
        }
    }
  <<cleanup_point return <retval> = __mbsnrtowcs_alias (__dst, __src, __nmc, __len, __ps)>>;
   >>>;


;; Function size_t wcsnrtombs(char*, const wchar_t**, size_t, size_t, mbstate_t*) (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  if (__builtin_object_size ((const void *) __dst, 1) != 18446744073709551615)
    {
      if (__builtin_constant_p (__len) == 0)
        {
          <<cleanup_point return <retval> = __wcsnrtombs_chk (__dst, __src, __nwc, __len, __ps, __builtin_object_size ((const void *) __dst, 1))>>;
        }
      if (__builtin_object_size ((const void *) __dst, 1) < __len)
        {
          <<cleanup_point return <retval> = __wcsnrtombs_chk_warn (__dst, __src, __nwc, __len, __ps, __builtin_object_size ((const void *) __dst, 1))>>;
        }
    }
  <<cleanup_point return <retval> = __wcsnrtombs_alias (__dst, __src, __nwc, __len, __ps)>>;
   >>>;


;; Function static void std::char_traits<char>::assign(std::char_traits<char>::char_type&, const char_type&) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__c1 = (char_type) *__c2) >>>>>
   >>>;


;; Function static constexpr bool std::char_traits<char>::eq(const char_type&, const char_type&) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = *__c1 == *__c2
   >>>;


;; Function static constexpr bool std::char_traits<char>::lt(const char_type&, const char_type&) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (unsigned char) *__c1 < (unsigned char) *__c2
   >>>;


;; Function static int std::char_traits<char>::compare(const char_type*, const char_type*, std::size_t) (null)
;; enabled by -tree-original


if (__n == 0)
  {
    return <retval> = 0;
  }
return <retval> = __builtin_memcmp ((const void *) __s1, (const void *) __s2, __n);


;; Function static std::size_t std::char_traits<char>::length(const char_type*) (null)
;; enabled by -tree-original


return <retval> = __builtin_strlen (__s);


;; Function static const char_type* std::char_traits<char>::find(const char_type*, std::size_t, const char_type&) (null)
;; enabled by -tree-original


if (__n == 0)
  {
    return <retval> = 0B;
  }
return <retval> = (const char_type *) __builtin_memchr ((const void *) __s, (int) *__a, __n);


;; Function static std::char_traits<char>::char_type* std::char_traits<char>::move(std::char_traits<char>::char_type*, const char_type*, std::size_t) (null)
;; enabled by -tree-original


if (__n == 0)
  {
    return <retval> = __s1;
  }
<<cleanup_point return <retval> = (char_type *) __builtin_memmove ((void *) __s1, (const void *) __s2, __n)>>;


;; Function static std::char_traits<char>::char_type* std::char_traits<char>::copy(std::char_traits<char>::char_type*, const char_type*, std::size_t) (null)
;; enabled by -tree-original


if (__n == 0)
  {
    return <retval> = __s1;
  }
<<cleanup_point return <retval> = (char_type *) __builtin_memcpy ((void *) __s1, (const void *) __s2, __n)>>;


;; Function static std::char_traits<char>::char_type* std::char_traits<char>::assign(std::char_traits<char>::char_type*, std::size_t, std::char_traits<char>::char_type) (null)
;; enabled by -tree-original


if (__n == 0)
  {
    return <retval> = __s;
  }
<<cleanup_point return <retval> = (char_type *) __builtin_memset ((void *) __s, (int) __a, __n)>>;


;; Function static constexpr std::char_traits<char>::char_type std::char_traits<char>::to_char_type(const int_type&) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (char_type) *__c
   >>>;


;; Function static constexpr std::char_traits<char>::int_type std::char_traits<char>::to_int_type(const char_type&) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (int_type) (unsigned char) *__c
   >>>;


;; Function static constexpr bool std::char_traits<char>::eq_int_type(const int_type&, const int_type&) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = *__c1 == *__c2
   >>>;


;; Function static constexpr std::char_traits<char>::int_type std::char_traits<char>::eof() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = -1
   >>>;


;; Function static constexpr std::char_traits<char>::int_type std::char_traits<char>::not_eof(const int_type&) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = *__c != -1 ? (int_type) *__c : 0>>
   >>>;


;; Function static void std::char_traits<wchar_t>::assign(std::char_traits<wchar_t>::char_type&, const char_type&) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__c1 = (char_type) *__c2) >>>>>
   >>>;


;; Function static constexpr bool std::char_traits<wchar_t>::eq(const char_type&, const char_type&) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = *__c1 == *__c2
   >>>;


;; Function static constexpr bool std::char_traits<wchar_t>::lt(const char_type&, const char_type&) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = *__c1 < *__c2
   >>>;


;; Function static int std::char_traits<wchar_t>::compare(const char_type*, const char_type*, std::size_t) (null)
;; enabled by -tree-original


if (__n == 0)
  {
    return <retval> = 0;
  }
else
  {
    return <retval> = wmemcmp (__s1, __s2, __n);
  }


;; Function static std::size_t std::char_traits<wchar_t>::length(const char_type*) (null)
;; enabled by -tree-original


return <retval> = wcslen (__s);


;; Function static const char_type* std::char_traits<wchar_t>::find(const char_type*, std::size_t, const char_type&) (null)
;; enabled by -tree-original


if (__n == 0)
  {
    return <retval> = 0B;
  }
else
  {
    return <retval> = (const char_type *) wmemchr (__s, (char_type) *__a, __n);
  }


;; Function static std::char_traits<wchar_t>::char_type* std::char_traits<wchar_t>::move(std::char_traits<wchar_t>::char_type*, const char_type*, std::size_t) (null)
;; enabled by -tree-original


if (__n == 0)
  {
    return <retval> = __s1;
  }
<<cleanup_point return <retval> = (char_type *) wmemmove (__s1, __s2, __n)>>;


;; Function static std::char_traits<wchar_t>::char_type* std::char_traits<wchar_t>::copy(std::char_traits<wchar_t>::char_type*, const char_type*, std::size_t) (null)
;; enabled by -tree-original


if (__n == 0)
  {
    return <retval> = __s1;
  }
<<cleanup_point return <retval> = (char_type *) wmemcpy (__s1, __s2, __n)>>;


;; Function static std::char_traits<wchar_t>::char_type* std::char_traits<wchar_t>::assign(std::char_traits<wchar_t>::char_type*, std::size_t, std::char_traits<wchar_t>::char_type) (null)
;; enabled by -tree-original


if (__n == 0)
  {
    return <retval> = __s;
  }
<<cleanup_point return <retval> = (char_type *) wmemset (__s, __a, __n)>>;


;; Function static constexpr std::char_traits<wchar_t>::char_type std::char_traits<wchar_t>::to_char_type(const int_type&) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (char_type) *__c
   >>>;


;; Function static constexpr std::char_traits<wchar_t>::int_type std::char_traits<wchar_t>::to_int_type(const char_type&) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (int_type) *__c
   >>>;


;; Function static constexpr bool std::char_traits<wchar_t>::eq_int_type(const int_type&, const int_type&) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = *__c1 == *__c2
   >>>;


;; Function static constexpr std::char_traits<wchar_t>::int_type std::char_traits<wchar_t>::eof() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 4294967295
   >>>;


;; Function static constexpr std::char_traits<wchar_t>::int_type std::char_traits<wchar_t>::not_eof(const int_type&) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::char_traits<wchar_t>::eq_int_type (__c, (const int_type &) &TARGET_EXPR <D.10452, 4294967295>) ? 0 : (int_type) *__c>>
   >>>;


;; Function static void std::char_traits<char16_t>::assign(std::char_traits<char16_t>::char_type&, const char_type&) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__c1 = (char_type) *__c2) >>>>>
   >>>;


;; Function static constexpr bool std::char_traits<char16_t>::eq(const char_type&, const char_type&) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = *__c1 == *__c2
   >>>;


;; Function static constexpr bool std::char_traits<char16_t>::lt(const char_type&, const char_type&) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = *__c1 < *__c2
   >>>;


;; Function static int std::char_traits<char16_t>::compare(const char_type*, const char_type*, std::size_t) (null)
;; enabled by -tree-original


{
  {
    size_t __i = 0;

    <<cleanup_point     size_t __i = 0;>>;
    while (1)
      {
        if (__i >= __n) goto <D.10627>;
        if (<<cleanup_point std::char_traits<char16_t>::lt ((const char_type &) (__s1 + (sizetype) (__i * 2)), (const char_type &) (__s2 + (sizetype) (__i * 2)))>>)
          {
            return <retval> = -1;
          }
        else
          {
            if (<<cleanup_point std::char_traits<char16_t>::lt ((const char_type &) (__s2 + (sizetype) (__i * 2)), (const char_type &) (__s1 + (sizetype) (__i * 2)))>>)
              {
                return <retval> = 1;
              }
          }
        <<cleanup_point (void)  ++__i>>;
      }
    <D.10627>:;
  }
  return <retval> = 0;
}


;; Function static std::size_t std::char_traits<char16_t>::length(const char_type*) (null)
;; enabled by -tree-original


{
  size_t __i = 0;

  <<cleanup_point   size_t __i = 0;>>;
  while (1)
    {
      if (<<cleanup_point !std::char_traits<char16_t>::eq ((const char_type &) (__s + (sizetype) (__i * 2)), (const char_type &) &TARGET_EXPR <D.10631, 0>)>>) (void) 0; else goto <D.10632>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void)  ++__i >>>>>;
    }
  <D.10632>:;
  return <retval> = __i;
}


;; Function static const char_type* std::char_traits<char16_t>::find(const char_type*, std::size_t, const char_type&) (null)
;; enabled by -tree-original


{
  {
    size_t __i = 0;

    <<cleanup_point     size_t __i = 0;>>;
    while (1)
      {
        if (__i >= __n) goto <D.10636>;
        if (<<cleanup_point std::char_traits<char16_t>::eq ((const char_type &) (__s + (sizetype) (__i * 2)), __a)>>)
          {
            return <retval> = __s + (sizetype) (__i * 2);
          }
        <<cleanup_point (void)  ++__i>>;
      }
    <D.10636>:;
  }
  return <retval> = 0B;
}


;; Function static std::char_traits<char16_t>::char_type* std::char_traits<char16_t>::move(std::char_traits<char16_t>::char_type*, const char_type*, std::size_t) (null)
;; enabled by -tree-original


if (__n == 0)
  {
    return <retval> = __s1;
  }
<<cleanup_point return <retval> = (char_type *) __builtin_memmove ((void *) __s1, (const void *) __s2, __n * 2)>>;


;; Function static std::char_traits<char16_t>::char_type* std::char_traits<char16_t>::copy(std::char_traits<char16_t>::char_type*, const char_type*, std::size_t) (null)
;; enabled by -tree-original


if (__n == 0)
  {
    return <retval> = __s1;
  }
<<cleanup_point return <retval> = (char_type *) __builtin_memcpy ((void *) __s1, (const void *) __s2, __n * 2)>>;


;; Function static std::char_traits<char16_t>::char_type* std::char_traits<char16_t>::assign(std::char_traits<char16_t>::char_type*, std::size_t, std::char_traits<char16_t>::char_type) (null)
;; enabled by -tree-original


{
  {
    size_t __i = 0;

    <<cleanup_point     size_t __i = 0;>>;
    while (1)
      {
        if (__i >= __n) goto <D.10642>;
        <<cleanup_point <<< Unknown tree: expr_stmt
  std::char_traits<char16_t>::assign ((char_type &) (__s + (sizetype) (__i * 2)), (const char_type &) &__a) >>>>>;
        <<cleanup_point (void)  ++__i>>;
      }
    <D.10642>:;
  }
  return <retval> = __s;
}


;; Function static constexpr std::char_traits<char16_t>::char_type std::char_traits<char16_t>::to_char_type(const int_type&) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (char_type) *__c
   >>>;


;; Function static constexpr std::char_traits<char16_t>::int_type std::char_traits<char16_t>::to_int_type(const char_type&) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (int_type) *__c
   >>>;


;; Function static constexpr bool std::char_traits<char16_t>::eq_int_type(const int_type&, const int_type&) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = *__c1 == *__c2
   >>>;


;; Function static constexpr std::char_traits<char16_t>::int_type std::char_traits<char16_t>::eof() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 65535
   >>>;


;; Function static constexpr std::char_traits<char16_t>::int_type std::char_traits<char16_t>::not_eof(const int_type&) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::char_traits<char16_t>::eq_int_type (__c, (const int_type &) &TARGET_EXPR <D.10649, 65535>) ? 0 : (int_type) *__c>>
   >>>;


;; Function static void std::char_traits<char32_t>::assign(std::char_traits<char32_t>::char_type&, const char_type&) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__c1 = (char_type) *__c2) >>>>>
   >>>;


;; Function static constexpr bool std::char_traits<char32_t>::eq(const char_type&, const char_type&) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = *__c1 == *__c2
   >>>;


;; Function static constexpr bool std::char_traits<char32_t>::lt(const char_type&, const char_type&) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = *__c1 < *__c2
   >>>;


;; Function static int std::char_traits<char32_t>::compare(const char_type*, const char_type*, std::size_t) (null)
;; enabled by -tree-original


{
  {
    size_t __i = 0;

    <<cleanup_point     size_t __i = 0;>>;
    while (1)
      {
        if (__i >= __n) goto <D.10703>;
        if (<<cleanup_point std::char_traits<char32_t>::lt ((const char_type &) (__s1 + (sizetype) (__i * 4)), (const char_type &) (__s2 + (sizetype) (__i * 4)))>>)
          {
            return <retval> = -1;
          }
        else
          {
            if (<<cleanup_point std::char_traits<char32_t>::lt ((const char_type &) (__s2 + (sizetype) (__i * 4)), (const char_type &) (__s1 + (sizetype) (__i * 4)))>>)
              {
                return <retval> = 1;
              }
          }
        <<cleanup_point (void)  ++__i>>;
      }
    <D.10703>:;
  }
  return <retval> = 0;
}


;; Function static std::size_t std::char_traits<char32_t>::length(const char_type*) (null)
;; enabled by -tree-original


{
  size_t __i = 0;

  <<cleanup_point   size_t __i = 0;>>;
  while (1)
    {
      if (<<cleanup_point !std::char_traits<char32_t>::eq ((const char_type &) (__s + (sizetype) (__i * 4)), (const char_type &) &TARGET_EXPR <D.10707, 0>)>>) (void) 0; else goto <D.10708>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void)  ++__i >>>>>;
    }
  <D.10708>:;
  return <retval> = __i;
}


;; Function static const char_type* std::char_traits<char32_t>::find(const char_type*, std::size_t, const char_type&) (null)
;; enabled by -tree-original


{
  {
    size_t __i = 0;

    <<cleanup_point     size_t __i = 0;>>;
    while (1)
      {
        if (__i >= __n) goto <D.10712>;
        if (<<cleanup_point std::char_traits<char32_t>::eq ((const char_type &) (__s + (sizetype) (__i * 4)), __a)>>)
          {
            return <retval> = __s + (sizetype) (__i * 4);
          }
        <<cleanup_point (void)  ++__i>>;
      }
    <D.10712>:;
  }
  return <retval> = 0B;
}


;; Function static std::char_traits<char32_t>::char_type* std::char_traits<char32_t>::move(std::char_traits<char32_t>::char_type*, const char_type*, std::size_t) (null)
;; enabled by -tree-original


if (__n == 0)
  {
    return <retval> = __s1;
  }
<<cleanup_point return <retval> = (char_type *) __builtin_memmove ((void *) __s1, (const void *) __s2, __n * 4)>>;


;; Function static std::char_traits<char32_t>::char_type* std::char_traits<char32_t>::copy(std::char_traits<char32_t>::char_type*, const char_type*, std::size_t) (null)
;; enabled by -tree-original


if (__n == 0)
  {
    return <retval> = __s1;
  }
<<cleanup_point return <retval> = (char_type *) __builtin_memcpy ((void *) __s1, (const void *) __s2, __n * 4)>>;


;; Function static std::char_traits<char32_t>::char_type* std::char_traits<char32_t>::assign(std::char_traits<char32_t>::char_type*, std::size_t, std::char_traits<char32_t>::char_type) (null)
;; enabled by -tree-original


{
  {
    size_t __i = 0;

    <<cleanup_point     size_t __i = 0;>>;
    while (1)
      {
        if (__i >= __n) goto <D.10718>;
        <<cleanup_point <<< Unknown tree: expr_stmt
  std::char_traits<char32_t>::assign ((char_type &) (__s + (sizetype) (__i * 4)), (const char_type &) &__a) >>>>>;
        <<cleanup_point (void)  ++__i>>;
      }
    <D.10718>:;
  }
  return <retval> = __s;
}


;; Function static constexpr std::char_traits<char32_t>::char_type std::char_traits<char32_t>::to_char_type(const int_type&) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (char_type) *__c
   >>>;


;; Function static constexpr std::char_traits<char32_t>::int_type std::char_traits<char32_t>::to_int_type(const char_type&) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (int_type) *__c
   >>>;


;; Function static constexpr bool std::char_traits<char32_t>::eq_int_type(const int_type&, const int_type&) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = *__c1 == *__c2
   >>>;


;; Function static constexpr std::char_traits<char32_t>::int_type std::char_traits<char32_t>::eof() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 4294967295
   >>>;


;; Function static constexpr std::char_traits<char32_t>::int_type std::char_traits<char32_t>::not_eof(const int_type&) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::char_traits<char32_t>::eq_int_type (__c, (const int_type &) &TARGET_EXPR <D.10725, 4294967295>) ? 0 : (int_type) *__c>>
   >>>;


;; Function std::exception::exception() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point <<< Unknown tree: expr_stmt
  *(struct 
  {
    int (*__vtbl_ptr_type) () * _vptr.exception;
  } &) this = {CLOBBER} >>>>>;
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct exception *) this)->_vptr.exception = &_ZTVSt9exception + 16) >>>>>;
  }
   >>>;


;; Function std::bad_exception::bad_exception() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point <<< Unknown tree: expr_stmt
  *(struct 
  {
    struct 
    {
      int (*__vtbl_ptr_type) () * _vptr.exception;
    } D.10778;
  } &) this = {CLOBBER} >>>>>;
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::exception::exception (&((struct bad_exception *) this)->D.10777) >>>>>;
    try
      {
        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct bad_exception *) this)->D.10777._vptr.exception = &_ZTVSt13bad_exception + 16) >>>>>;
      }
    catch
      {
        std::exception::~exception (&((struct bad_exception *) this)->D.10777);
      }
  }
   >>>;


;; Function const char* std::type_info::name() const (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = *(const char *) ((const struct type_info *) this)->__name == 42 ? (const char *) ((const struct type_info *) this)->__name + 1 : (const char *) ((const struct type_info *) this)->__name
   >>>;


;; Function bool std::type_info::before(const std::type_info&) const (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = *(const char *) ((const struct type_info *) this)->__name == 42 && *(const char *) __arg->__name == 42 ? (const char *) ((const struct type_info *) this)->__name < (const char *) __arg->__name : __builtin_strcmp ((const char *) ((const struct type_info *) this)->__name, (const char *) __arg->__name) < 0
   >>>;


;; Function bool std::type_info::operator==(const std::type_info&) const (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (const char *) ((const struct type_info *) this)->__name == (const char *) __arg->__name || *(const char *) ((const struct type_info *) this)->__name != 42 && __builtin_strcmp ((const char *) ((const struct type_info *) this)->__name, (const char *) __arg->__name) == 0
   >>>;


;; Function bool std::type_info::operator!=(const std::type_info&) const (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = !std::type_info::operator== ((const struct type_info *) this, __arg)>>
   >>>;


;; Function std::size_t std::type_info::hash_code() const (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::_Hash_bytes ((const void *) std::type_info::name ((const struct type_info *) this), __builtin_strlen (std::type_info::name ((const struct type_info *) this)), 3339675911)>>
   >>>;


;; Function std::type_info::type_info(const char*) (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  *(struct 
  {
    int (*__vtbl_ptr_type) () * _vptr.type_info;
    const char * __name;
  } &) this = {CLOBBER} >>>>>;
{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct type_info *) this)->_vptr.type_info = &_ZTVSt9type_info + 16) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct type_info *) this)->__name = __n) >>>>>;
}


;; Function std::bad_cast::bad_cast() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point <<< Unknown tree: expr_stmt
  *(struct 
  {
    struct 
    {
      int (*__vtbl_ptr_type) () * _vptr.exception;
    } D.10929;
  } &) this = {CLOBBER} >>>>>;
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::exception::exception (&((struct bad_cast *) this)->D.10928) >>>>>;
    try
      {
        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct bad_cast *) this)->D.10928._vptr.exception = &_ZTVSt8bad_cast + 16) >>>>>;
      }
    catch
      {
        std::exception::~exception (&((struct bad_cast *) this)->D.10928);
      }
  }
   >>>;


;; Function std::bad_typeid::bad_typeid() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point <<< Unknown tree: expr_stmt
  *(struct 
  {
    struct 
    {
      int (*__vtbl_ptr_type) () * _vptr.exception;
    } D.10958;
  } &) this = {CLOBBER} >>>>>;
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::exception::exception (&((struct bad_typeid *) this)->D.10957) >>>>>;
    try
      {
        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct bad_typeid *) this)->D.10957._vptr.exception = &_ZTVSt10bad_typeid + 16) >>>>>;
      }
    catch
      {
        std::exception::~exception (&((struct bad_typeid *) this)->D.10957);
      }
  }
   >>>;


;; Function std::__exception_ptr::exception_ptr::exception_ptr(std::nullptr_t) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point <<< Unknown tree: expr_stmt
  *(struct 
  {
    void * _M_exception_object;
  } &) this = {CLOBBER} >>>>>;
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct exception_ptr *) this)->_M_exception_object = 0B) >>>>>;
  }
   >>>;


;; Function std::__exception_ptr::exception_ptr::exception_ptr(std::__exception_ptr::exception_ptr&&) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point <<< Unknown tree: expr_stmt
  *(struct 
  {
    void * _M_exception_object;
  } &) this = {CLOBBER} >>>>>;
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct exception_ptr *) this)->_M_exception_object = __o->_M_exception_object) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__o->_M_exception_object = 0B) >>>>>;
  }
   >>>;


;; Function std::__exception_ptr::exception_ptr& std::__exception_ptr::exception_ptr::operator=(std::__exception_ptr::exception_ptr&&) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__exception_ptr::exception_ptr::swap (&TARGET_EXPR <D.11065, <<< Unknown tree: aggr_init_expr
  5
  __comp_ctor 
  D.11065
  (struct exception_ptr *) <<< Unknown tree: void_cst >>>
  NON_LVALUE_EXPR <__o> >>>>, (struct exception_ptr &) this) >>>>>;
  return <retval> = (struct exception_ptr &) this;
   >>>;


;; Function std::__exception_ptr::exception_ptr::operator bool() const (null)
;; enabled by -tree-original


return <retval> = (void *) ((const struct exception_ptr *) this)->_M_exception_object != 0B;


;; Function void std::__exception_ptr::swap(std::__exception_ptr::exception_ptr&, std::__exception_ptr::exception_ptr&) (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  std::__exception_ptr::exception_ptr::swap ((struct exception_ptr *) __lhs, __rhs) >>>>>;


;; Function std::nested_exception::nested_exception() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point <<< Unknown tree: expr_stmt
  *(struct 
  {
    int (*__vtbl_ptr_type) () * _vptr.nested_exception;
    struct exception_ptr _M_ptr;
  } &) this = {CLOBBER} >>>>>;
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct nested_exception *) this)->_vptr.nested_exception = &_ZTVSt16nested_exception + 16) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct nested_exception *) this)->_M_ptr = TARGET_EXPR <D.11147, <<< Unknown tree: aggr_init_expr
  3
  current_exception
  D.11147 >>>>) >>>>>;
    try
      {
        
      }
    catch
      {
        std::__exception_ptr::exception_ptr::~exception_ptr (&((struct nested_exception *) this)->_M_ptr);
      }
  }
   >>>;


;; Function void std::nested_exception::rethrow_nested() const (null)
;; enabled by -tree-original


if (<<cleanup_point std::__exception_ptr::exception_ptr::operator bool (&((const struct nested_exception *) this)->_M_ptr)>>)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::rethrow_exception (&TARGET_EXPR <D.11152, <<< Unknown tree: aggr_init_expr
  5
  __comp_ctor 
  D.11152
  (struct exception_ptr *) <<< Unknown tree: void_cst >>>
  (const struct exception_ptr &) &((const struct nested_exception *) this)->_M_ptr >>>>) >>>>>;
  }
<<cleanup_point <<< Unknown tree: expr_stmt
  std::terminate () >>>>>;


;; Function std::__exception_ptr::exception_ptr std::nested_exception::nested_ptr() const (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return *<retval> = TARGET_EXPR <D.11154, <<< Unknown tree: aggr_init_expr
  5
  __comp_ctor 
  D.11154
  (struct exception_ptr *) <<< Unknown tree: void_cst >>>
  (const struct exception_ptr &) &((const struct nested_exception *) this)->_M_ptr >>>>>>
   >>>;


;; Function void std::__rethrow_if_nested_impl(const void*) (null)
;; enabled by -tree-original





;; Function std::bad_alloc::bad_alloc() (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  <<cleanup_point <<< Unknown tree: expr_stmt
  *(struct 
  {
    struct 
    {
      int (*__vtbl_ptr_type) () * _vptr.exception;
    } D.11256;
  } &) this = {CLOBBER} >>>>>;
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::exception::exception (&((struct bad_alloc *) this)->D.11255) >>>>>;
    try
      {
        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct bad_alloc *) this)->D.11255._vptr.exception = &_ZTVSt9bad_alloc + 16) >>>>>;
      }
    catch
      {
        std::exception::~exception (&((struct bad_alloc *) this)->D.11255);
      }
  }
   >>>;


;; Function std::bad_array_new_length::bad_array_new_length() (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  <<cleanup_point <<< Unknown tree: expr_stmt
  *(struct 
  {
    struct 
    {
      struct 
      {
        int (*__vtbl_ptr_type) () * _vptr.exception;
      } D.11256;
    } D.11285;
  } &) this = {CLOBBER} >>>>>;
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::bad_alloc::bad_alloc (&((struct bad_array_new_length *) this)->D.11284) >>>>>;
    try
      {
        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct bad_array_new_length *) this)->D.11284.D.11255._vptr.exception = &_ZTVSt20bad_array_new_length + 16) >>>>>;
      }
    catch
      {
        std::bad_alloc::~bad_alloc (&((struct bad_array_new_length *) this)->D.11284);
      }
  }
   >>>;


;; Function void* operator new(std::size_t, void*) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = __p
   >>>;


;; Function void* operator new [](std::size_t, void*) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = __p
   >>>;


;; Function void operator delete(void*, void*) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  
   >>>;


;; Function void operator delete [](void*, void*) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  
   >>>;


;; Function int std::__convert_from_v(__locale_struct* const&, char*, int, const char*, ...) (null)
;; enabled by -tree-original


{
  struct __locale_struct * __old;
  struct  __args[1];
  const int __ret;

    struct __locale_struct * __old;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__old = __gnu_cxx::__uselocale ((struct __locale_struct *) *__cloc)) >>>>>;
    struct  __args[1];
  <<cleanup_point <<< Unknown tree: expr_stmt
  __builtin_va_start ((struct  *) &__args, __fmt) >>>>>;
    const int __ret;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__ret = __builtin_vsnprintf (__out, (long unsigned int) __size, __fmt, (struct  *) &__args)) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  __builtin_va_end ((struct  *) &__args) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) __gnu_cxx::__uselocale (__old) >>>>>;
  return <retval> = (int) __ret;
}


;; Function __pthread_cleanup_class::__pthread_cleanup_class(void (*)(void*), void*) (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  *(struct 
  {
    void (*<Tf2>) (void *) __cancel_routine;
    void * __cancel_arg;
    int __do_it;
    int __cancel_type;
  } &) this = {CLOBBER} >>>>>;
{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __pthread_cleanup_class *) this)->__cancel_routine = __fct) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __pthread_cleanup_class *) this)->__cancel_arg = __arg) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __pthread_cleanup_class *) this)->__do_it = 1) >>>>>;
}


;; Function __pthread_cleanup_class::~__pthread_cleanup_class() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    try
      {
        if (((struct __pthread_cleanup_class *) this)->__do_it != 0)
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  ((struct __pthread_cleanup_class *) this)->__cancel_routine (((struct __pthread_cleanup_class *) this)->__cancel_arg) >>>>>;
          }
      }
    finally
      {
        *(struct 
        {
          void (*<Tf2>) (void *) __cancel_routine;
          void * __cancel_arg;
          int __do_it;
          int __cancel_type;
        } &) this = {CLOBBER};
      }
  }
  <D.14357>:;
   >>>;


;; Function void __pthread_cleanup_class::__setdoit(int) (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __pthread_cleanup_class *) this)->__do_it = __newval) >>>>>;


;; Function void __pthread_cleanup_class::__defer() (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void) pthread_setcanceltype (0, &((struct __pthread_cleanup_class *) this)->__cancel_type) >>>>>;


;; Function void __pthread_cleanup_class::__restore() const (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void) pthread_setcanceltype ((int) ((const struct __pthread_cleanup_class *) this)->__cancel_type, 0B) >>>>>;


;; Function int pthread_equal(pthread_t, pthread_t) (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  return <retval> = __thread1 == __thread2
   >>>;


;; Function int __gthread_active_p() (null)
;; enabled by -tree-original


{
  static void * const __gthread_active_ptr = (void *) __gthrw___pthread_key_create;

  <<cleanup_point   static void * const __gthread_active_ptr = (void *) __gthrw___pthread_key_create;>>;
  return <retval> = (void *) __gthrw___pthread_key_create != 0B;
}


;; Function int __gthread_create(__gthread_t*, void* (*)(void*), void*) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __gthrw_pthread_create (__threadid, 0B, __func, __args)>>;


;; Function int __gthread_join(__gthread_t, void**) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __gthrw_pthread_join (__threadid, __value_ptr)>>;


;; Function int __gthread_detach(__gthread_t) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __gthrw_pthread_detach (__threadid)>>;


;; Function int __gthread_equal(__gthread_t, __gthread_t) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __gthrw_pthread_equal (__t1, __t2)>>;


;; Function __gthread_t __gthread_self() (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __gthrw_pthread_self ()>>;


;; Function int __gthread_yield() (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __gthrw_sched_yield ()>>;


;; Function int __gthread_once(__gthread_once_t*, void (*)()) (null)
;; enabled by -tree-original


if (<<cleanup_point __gthread_active_p () != 0>>)
  {
    <<cleanup_point return <retval> = __gthrw_pthread_once (__once, __func)>>;
  }
else
  {
    return <retval> = -1;
  }


;; Function int __gthread_key_create(__gthread_key_t*, void (*)(void*)) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __gthrw_pthread_key_create (__key, __dtor)>>;


;; Function int __gthread_key_delete(__gthread_key_t) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __gthrw_pthread_key_delete (__key)>>;


;; Function void* __gthread_getspecific(__gthread_key_t) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __gthrw_pthread_getspecific (__key)>>;


;; Function int __gthread_setspecific(__gthread_key_t, const void*) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __gthrw_pthread_setspecific (__key, __ptr)>>;


;; Function void __gthread_mutex_init_function(__gthread_mutex_t*) (null)
;; enabled by -tree-original


if (<<cleanup_point __gthread_active_p () != 0>>)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) __gthrw_pthread_mutex_init (__mutex, 0B) >>>>>;
  }


;; Function int __gthread_mutex_destroy(__gthread_mutex_t*) (null)
;; enabled by -tree-original


if (<<cleanup_point __gthread_active_p () != 0>>)
  {
    <<cleanup_point return <retval> = __gthrw_pthread_mutex_destroy (__mutex)>>;
  }
else
  {
    return <retval> = 0;
  }


;; Function int __gthread_mutex_lock(__gthread_mutex_t*) (null)
;; enabled by -tree-original


if (<<cleanup_point __gthread_active_p () != 0>>)
  {
    <<cleanup_point return <retval> = __gthrw_pthread_mutex_lock (__mutex)>>;
  }
else
  {
    return <retval> = 0;
  }


;; Function int __gthread_mutex_trylock(__gthread_mutex_t*) (null)
;; enabled by -tree-original


if (<<cleanup_point __gthread_active_p () != 0>>)
  {
    <<cleanup_point return <retval> = __gthrw_pthread_mutex_trylock (__mutex)>>;
  }
else
  {
    return <retval> = 0;
  }


;; Function int __gthread_mutex_timedlock(__gthread_mutex_t*, const __gthread_time_t*) (null)
;; enabled by -tree-original


if (<<cleanup_point __gthread_active_p () != 0>>)
  {
    <<cleanup_point return <retval> = __gthrw_pthread_mutex_timedlock (__mutex, __abs_timeout)>>;
  }
else
  {
    return <retval> = 0;
  }


;; Function int __gthread_mutex_unlock(__gthread_mutex_t*) (null)
;; enabled by -tree-original


if (<<cleanup_point __gthread_active_p () != 0>>)
  {
    <<cleanup_point return <retval> = __gthrw_pthread_mutex_unlock (__mutex)>>;
  }
else
  {
    return <retval> = 0;
  }


;; Function int __gthread_recursive_mutex_lock(__gthread_recursive_mutex_t*) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __gthread_mutex_lock (__mutex)>>;


;; Function int __gthread_recursive_mutex_trylock(__gthread_recursive_mutex_t*) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __gthread_mutex_trylock (__mutex)>>;


;; Function int __gthread_recursive_mutex_timedlock(__gthread_recursive_mutex_t*, const __gthread_time_t*) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __gthread_mutex_timedlock (__mutex, __abs_timeout)>>;


;; Function int __gthread_recursive_mutex_unlock(__gthread_recursive_mutex_t*) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __gthread_mutex_unlock (__mutex)>>;


;; Function int __gthread_recursive_mutex_destroy(__gthread_recursive_mutex_t*) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __gthread_mutex_destroy (__mutex)>>;


;; Function int __gthread_cond_broadcast(__gthread_cond_t*) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __gthrw_pthread_cond_broadcast (__cond)>>;


;; Function int __gthread_cond_signal(__gthread_cond_t*) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __gthrw_pthread_cond_signal (__cond)>>;


;; Function int __gthread_cond_wait(__gthread_cond_t*, __gthread_mutex_t*) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __gthrw_pthread_cond_wait (__cond, __mutex)>>;


;; Function int __gthread_cond_timedwait(__gthread_cond_t*, __gthread_mutex_t*, const __gthread_time_t*) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __gthrw_pthread_cond_timedwait (__cond, __mutex, __abs_timeout)>>;


;; Function int __gthread_cond_wait_recursive(__gthread_cond_t*, __gthread_recursive_mutex_t*) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __gthread_cond_wait (__cond, __mutex)>>;


;; Function int __gthread_cond_destroy(__gthread_cond_t*) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __gthrw_pthread_cond_destroy (__cond)>>;


;; Function _Atomic_word __gnu_cxx::__exchange_and_add(volatile _Atomic_word*, int) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = (int) __atomic_fetch_add_4 ((volatile void *) __mem, (unsigned int) __val, 4)>>;


;; Function void __gnu_cxx::__atomic_add(volatile _Atomic_word*, int) (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void) (int) __atomic_fetch_add_4 ((volatile void *) __mem, (unsigned int) __val, 4) >>>>>;


;; Function _Atomic_word __gnu_cxx::__exchange_and_add_single(_Atomic_word*, int) (null)
;; enabled by -tree-original


{
  _Atomic_word __result = *__mem;

    _Atomic_word __result = *__mem;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__mem = *__mem + __val) >>>>>;
  return <retval> = __result;
}


;; Function void __gnu_cxx::__atomic_add_single(_Atomic_word*, int) (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__mem = *__mem + __val) >>>>>;


;; Function _Atomic_word __gnu_cxx::__exchange_and_add_dispatch(_Atomic_word*, int) (null)
;; enabled by -tree-original


if (<<cleanup_point __gthread_active_p () != 0>>)
  {
    <<cleanup_point return <retval> = __gnu_cxx::__exchange_and_add ((volatile _Atomic_word *) __mem, __val)>>;
  }
else
  {
    <<cleanup_point return <retval> = __gnu_cxx::__exchange_and_add_single (__mem, __val)>>;
  }


;; Function void __gnu_cxx::__atomic_add_dispatch(_Atomic_word*, int) (null)
;; enabled by -tree-original


if (<<cleanup_point __gthread_active_p () != 0>>)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::__atomic_add ((volatile _Atomic_word *) __mem, __val) >>>>>;
  }
else
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::__atomic_add_single (__mem, __val) >>>>>;
  }


;; Function int atoi(const char*) (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  <<cleanup_point return <retval> = (int) strtol (__nptr, 0B, 10)>>
   >>>;


;; Function long int atol(const char*) (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  <<cleanup_point return <retval> = strtol (__nptr, 0B, 10)>>
   >>>;


;; Function long long int atoll(const char*) (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  <<cleanup_point return <retval> = strtoll (__nptr, 0B, 10)>>
   >>>;


;; Function __uint16_t __bswap_16(__uint16_t) (null)
;; enabled by -tree-original


return <retval> = __builtin_bswap16 ((int) __bsx);


;; Function __uint32_t __bswap_32(__uint32_t) (null)
;; enabled by -tree-original


return <retval> = __builtin_bswap32 (__bsx);


;; Function __uint64_t __bswap_64(__uint64_t) (null)
;; enabled by -tree-original


return <retval> = __builtin_bswap64 (__bsx);


;; Function __uint16_t __uint16_identity(__uint16_t) (null)
;; enabled by -tree-original


return <retval> = __x;


;; Function __uint32_t __uint32_identity(__uint32_t) (null)
;; enabled by -tree-original


return <retval> = __x;


;; Function __uint64_t __uint64_identity(__uint64_t) (null)
;; enabled by -tree-original


return <retval> = __x;


;; Function void* bsearch(const void*, const void*, size_t, size_t, __compar_fn_t) (null)
;; enabled by -tree-original


{
  size_t __l;
  size_t __u;
  size_t __idx;
  const void * __p;
  int __comparison;

    size_t __l;
    size_t __u;
    size_t __idx;
    const void * __p;
    int __comparison;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__l = 0) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__u = __nmemb) >>>>>;
  while (1)
    {
      if (__l >= __u) goto <D.17393>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__idx = (__l + __u) / 2) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__p = __base + (sizetype) (__idx * __size)) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__comparison = __compar (__key, __p)) >>>>>;
      if (__comparison < 0)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__u = __idx) >>>>>;
        }
      else
        {
          if (__comparison > 0)
            {
              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__l = __idx + 1) >>>>>;
            }
          else
            {
              return <retval> = (void *) __p;
            }
        }
    }
  <D.17393>:;
  return <retval> = 0B;
}


;; Function double atof(const char*) (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  <<cleanup_point return <retval> = strtod (__nptr, 0B)>>
   >>>;


;; Function char* realpath(const char*, char*) (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  if (__builtin_object_size ((const void *) __resolved, 1) != 18446744073709551615)
    {
      <<cleanup_point return <retval> = __realpath_chk (__name, __resolved, __builtin_object_size ((const void *) __resolved, 1))>>;
    }
  <<cleanup_point return <retval> = __realpath_alias (__name, __resolved)>>;
   >>>;


;; Function int ptsname_r(int, char*, size_t) (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  if (__builtin_object_size ((const void *) __buf, 1) != 18446744073709551615)
    {
      if (__builtin_constant_p (__buflen) == 0)
        {
          <<cleanup_point return <retval> = __ptsname_r_chk (__fd, __buf, __buflen, __builtin_object_size ((const void *) __buf, 1))>>;
        }
      if (__builtin_object_size ((const void *) __buf, 1) < __buflen)
        {
          <<cleanup_point return <retval> = __ptsname_r_chk_warn (__fd, __buf, __buflen, __builtin_object_size ((const void *) __buf, 1))>>;
        }
    }
  <<cleanup_point return <retval> = __ptsname_r_alias (__fd, __buf, __buflen)>>;
   >>>;


;; Function int wctomb(char*, wchar_t) (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  if (__builtin_object_size ((const void *) __s, 1) != 18446744073709551615 && __builtin_object_size ((const void *) __s, 1) <= 15)
    {
      <<cleanup_point return <retval> = __wctomb_chk (__s, __wchar, __builtin_object_size ((const void *) __s, 1))>>;
    }
  <<cleanup_point return <retval> = __wctomb_alias (__s, __wchar)>>;
   >>>;


;; Function size_t mbstowcs(wchar_t*, const char*, size_t) (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  if (__builtin_object_size ((const void *) __dst, 1) != 18446744073709551615)
    {
      if (__builtin_constant_p (__len) == 0)
        {
          <<cleanup_point return <retval> = __mbstowcs_chk (__dst, __src, __len, __builtin_object_size ((const void *) __dst, 1) / 4)>>;
        }
      if (__builtin_object_size ((const void *) __dst, 1) / 4 < __len)
        {
          <<cleanup_point return <retval> = __mbstowcs_chk_warn (__dst, __src, __len, __builtin_object_size ((const void *) __dst, 1) / 4)>>;
        }
    }
  <<cleanup_point return <retval> = __mbstowcs_alias (__dst, __src, __len)>>;
   >>>;


;; Function size_t wcstombs(char*, const wchar_t*, size_t) (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  if (__builtin_object_size ((const void *) __dst, 1) != 18446744073709551615)
    {
      if (__builtin_constant_p (__len) == 0)
        {
          <<cleanup_point return <retval> = __wcstombs_chk (__dst, __src, __len, __builtin_object_size ((const void *) __dst, 1))>>;
        }
      if (__builtin_object_size ((const void *) __dst, 1) < __len)
        {
          <<cleanup_point return <retval> = __wcstombs_chk_warn (__dst, __src, __len, __builtin_object_size ((const void *) __dst, 1))>>;
        }
    }
  <<cleanup_point return <retval> = __wcstombs_alias (__dst, __src, __len)>>;
   >>>;


;; Function long int std::abs(long int) (null)
;; enabled by -tree-original


return <retval> = ABS_EXPR <__i>;


;; Function long long int std::abs(long long int) (null)
;; enabled by -tree-original


return <retval> = ABS_EXPR <__x>;


;; Function constexpr double std::abs(double) (null)
;; enabled by -tree-original


return <retval> = ABS_EXPR <__x>;


;; Function constexpr float std::abs(float) (null)
;; enabled by -tree-original


return <retval> = ABS_EXPR <__x>;


;; Function constexpr long double std::abs(long double) (null)
;; enabled by -tree-original


return <retval> = ABS_EXPR <__x>;


;; Function constexpr __int128 std::abs(__int128) (null)
;; enabled by -tree-original


return <retval> = ABS_EXPR <__x>;


;; Function constexpr __float128 std::abs(__float128) (null)
;; enabled by -tree-original


return <retval> = __x < 0.0 ? -NON_LVALUE_EXPR <__x> : __x;


;; Function ldiv_t std::div(long int, long int) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = TARGET_EXPR <D.17660, ldiv (__i, __j)>>>;


;; Function lldiv_t __gnu_cxx::div(long long int, long long int) (null)
;; enabled by -tree-original


{
  struct lldiv_t __q;

    struct lldiv_t __q;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__q.quot = __n / __d) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__q.rem = __n % __d) >>>>>;
  <<cleanup_point return <retval> = TARGET_EXPR <D.17735, __q>>>;
}


;; Function int getchar() (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = getc (stdin)>>;


;; Function int fgetc_unlocked(FILE*) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __builtin_expect (__fp->_IO_read_ptr >= __fp->_IO_read_end, 0) != 0 ? __uflow (__fp) : (int) *(unsigned char *) __fp->_IO_read_ptr++ >>;


;; Function int getc_unlocked(FILE*) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __builtin_expect (__fp->_IO_read_ptr >= __fp->_IO_read_end, 0) != 0 ? __uflow (__fp) : (int) *(unsigned char *) __fp->_IO_read_ptr++ >>;


;; Function int getchar_unlocked() (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __builtin_expect (stdin->_IO_read_ptr >= stdin->_IO_read_end, 0) != 0 ? __uflow (stdin) : (int) *(unsigned char *) stdin->_IO_read_ptr++ >>;


;; Function int putchar(int) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = putc (__c, stdout)>>;


;; Function int fputc_unlocked(int, FILE*) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __builtin_expect (__stream->_IO_write_ptr >= __stream->_IO_write_end, 0) != 0 ? __overflow (__stream, (int) (unsigned char) __c) : (int) (unsigned char) (*__stream->_IO_write_ptr++  = (char) __c)>>;


;; Function int putc_unlocked(int, FILE*) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __builtin_expect (__stream->_IO_write_ptr >= __stream->_IO_write_end, 0) != 0 ? __overflow (__stream, (int) (unsigned char) __c) : (int) (unsigned char) (*__stream->_IO_write_ptr++  = (char) __c)>>;


;; Function int putchar_unlocked(int) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __builtin_expect (stdout->_IO_write_ptr >= stdout->_IO_write_end, 0) != 0 ? __overflow (stdout, (int) (unsigned char) __c) : (int) (unsigned char) (*stdout->_IO_write_ptr++  = (char) __c)>>;


;; Function __ssize_t getline(char**, size_t*, FILE*) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __getdelim (__lineptr, __n, 10, __stream)>>;


;; Function int feof_unlocked(FILE*) (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  return <retval> = (__stream->_flags & 16) != 0
   >>>;


;; Function int ferror_unlocked(FILE*) (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  return <retval> = (__stream->_flags & 32) != 0
   >>>;


;; Function int sprintf(char*, const char*, ...) (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  <<cleanup_point return <retval> = __builtin___sprintf_chk (__s, 1, __builtin_object_size ((const void *) __s, 1), __fmt, __builtin_va_arg_pack ())>>
   >>>;


;; Function int vsprintf(char*, const char*, __va_list_tag*) (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  <<cleanup_point return <retval> = __builtin___vsprintf_chk (__s, 1, __builtin_object_size ((const void *) __s, 1), __fmt, __ap)>>
   >>>;


;; Function int snprintf(char*, size_t, const char*, ...) (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  <<cleanup_point return <retval> = __builtin___snprintf_chk (__s, __n, 1, __builtin_object_size ((const void *) __s, 1), __fmt, __builtin_va_arg_pack ())>>
   >>>;


;; Function int vsnprintf(char*, size_t, const char*, __va_list_tag*) (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  <<cleanup_point return <retval> = __builtin___vsnprintf_chk (__s, __n, 1, __builtin_object_size ((const void *) __s, 1), __fmt, __ap)>>
   >>>;


;; Function int fprintf(FILE*, const char*, ...) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __fprintf_chk (__stream, 1, __fmt, __builtin_va_arg_pack ())>>;


;; Function int printf(const char*, ...) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __printf_chk (1, __fmt, __builtin_va_arg_pack ())>>;


;; Function int vprintf(const char*, __va_list_tag*) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __vfprintf_chk (stdout, 1, __fmt, __ap)>>;


;; Function int vfprintf(FILE*, const char*, __va_list_tag*) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __vfprintf_chk (__stream, 1, __fmt, __ap)>>;


;; Function int dprintf(int, const char*, ...) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __dprintf_chk (__fd, 1, __fmt, __builtin_va_arg_pack ())>>;


;; Function int vdprintf(int, const char*, __va_list_tag*) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __vdprintf_chk (__fd, 1, __fmt, __ap)>>;


;; Function int asprintf(char**, const char*, ...) (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  <<cleanup_point return <retval> = __asprintf_chk (__ptr, 1, __fmt, __builtin_va_arg_pack ())>>
   >>>;


;; Function int __asprintf(char**, const char*, ...) (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  <<cleanup_point return <retval> = __asprintf_chk (__ptr, 1, __fmt, __builtin_va_arg_pack ())>>
   >>>;


;; Function int obstack_printf(obstack*, const char*, ...) (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  <<cleanup_point return <retval> = __obstack_printf_chk (__obstack, 1, __fmt, __builtin_va_arg_pack ())>>
   >>>;


;; Function int vasprintf(char**, const char*, __va_list_tag*) (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  <<cleanup_point return <retval> = __vasprintf_chk (__ptr, 1, __fmt, __ap)>>
   >>>;


;; Function int obstack_vprintf(obstack*, const char*, __va_list_tag*) (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  <<cleanup_point return <retval> = __obstack_vprintf_chk (__obstack, 1, __fmt, __ap)>>
   >>>;


;; Function char* fgets(char*, int, FILE*) (null)
;; enabled by -tree-original


if (__builtin_object_size ((const void *) __s, 1) != 18446744073709551615)
  {
    if (__builtin_constant_p (__n) == 0 || __n <= 0)
      {
        <<cleanup_point return <retval> = __fgets_chk (__s, __builtin_object_size ((const void *) __s, 1), __n, __stream)>>;
      }
    if ((size_t) __n > __builtin_object_size ((const void *) __s, 1))
      {
        <<cleanup_point return <retval> = __fgets_chk_warn (__s, __builtin_object_size ((const void *) __s, 1), __n, __stream)>>;
      }
  }
<<cleanup_point return <retval> = __fgets_alias (__s, __n, __stream)>>;


;; Function size_t fread(void*, size_t, size_t, FILE*) (null)
;; enabled by -tree-original


if (__builtin_object_size ((const void *) __ptr, 0) != 18446744073709551615)
  {
    if ((__builtin_constant_p (__size) == 0 || __builtin_constant_p (__n) == 0) || (__size | __n) > 4294967295)
      {
        <<cleanup_point return <retval> = __fread_chk (__ptr, __builtin_object_size ((const void *) __ptr, 0), __size, __n, __stream)>>;
      }
    if (__size * __n > __builtin_object_size ((const void *) __ptr, 0))
      {
        <<cleanup_point return <retval> = __fread_chk_warn (__ptr, __builtin_object_size ((const void *) __ptr, 0), __size, __n, __stream)>>;
      }
  }
<<cleanup_point return <retval> = __fread_alias (__ptr, __size, __n, __stream)>>;


;; Function char* fgets_unlocked(char*, int, FILE*) (null)
;; enabled by -tree-original


if (__builtin_object_size ((const void *) __s, 1) != 18446744073709551615)
  {
    if (__builtin_constant_p (__n) == 0 || __n <= 0)
      {
        <<cleanup_point return <retval> = __fgets_unlocked_chk (__s, __builtin_object_size ((const void *) __s, 1), __n, __stream)>>;
      }
    if ((size_t) __n > __builtin_object_size ((const void *) __s, 1))
      {
        <<cleanup_point return <retval> = __fgets_unlocked_chk_warn (__s, __builtin_object_size ((const void *) __s, 1), __n, __stream)>>;
      }
  }
<<cleanup_point return <retval> = __fgets_unlocked_alias (__s, __n, __stream)>>;


;; Function size_t fread_unlocked(void*, size_t, size_t, FILE*) (null)
;; enabled by -tree-original


{
  if (__builtin_object_size ((const void *) __ptr, 0) != 18446744073709551615)
    {
      if ((__builtin_constant_p (__size) == 0 || __builtin_constant_p (__n) == 0) || (__size | __n) > 4294967295)
        {
          <<cleanup_point return <retval> = __fread_unlocked_chk (__ptr, __builtin_object_size ((const void *) __ptr, 0), __size, __n, __stream)>>;
        }
      if (__size * __n > __builtin_object_size ((const void *) __ptr, 0))
        {
          <<cleanup_point return <retval> = __fread_unlocked_chk_warn (__ptr, __builtin_object_size ((const void *) __ptr, 0), __size, __n, __stream)>>;
        }
    }
  {
    if (((__builtin_constant_p (__size) != 0 && __builtin_constant_p (__n) != 0) && (__size | __n) <= 4294967295) && __size * __n <= 8)
      {
        {
          size_t __cnt = __size * __n;
          char * __cptr = (char *) __ptr;

                    size_t __cnt = __size * __n;
                    char * __cptr = (char *) __ptr;
          if (__cnt == 0)
            {
              return <retval> = 0;
            }
          {
            while (1)
              {
                if (__cnt == 0) goto <D.18402>;
                {
                  int __c;

                                    int __c;
                  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__c = getc_unlocked (__stream)) >>>>>;
                  if (__c == -1) goto <D.18402>;
                  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__cptr++  = (char) __c) >>>>>;
                }
                <<cleanup_point (void)  --__cnt>>;
              }
            <D.18402>:;
          }
          return <retval> = (long unsigned int) ((long int) __cptr - (long int) __ptr) / __size;
        }
      }
  }
  <<cleanup_point return <retval> = __fread_unlocked_alias (__ptr, __size, __n, __stream)>>;
}


;; Function int std::__cxx11::stoi(const string&, std::size_t*, int) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __gnu_cxx::__stoa<long int, int, char, int> (strtol, (const char *) "stoi", std::__cxx11::basic_string<char>::c_str ((const struct string *) __str), __idx, __base)>>;


;; Function long int std::__cxx11::stol(const string&, std::size_t*, int) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __gnu_cxx::__stoa<long int> (strtol, (const char *) "stol", std::__cxx11::basic_string<char>::c_str ((const struct string *) __str), __idx, __base)>>;


;; Function long unsigned int std::__cxx11::stoul(const string&, std::size_t*, int) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __gnu_cxx::__stoa<long unsigned int> (strtoul, (const char *) "stoul", std::__cxx11::basic_string<char>::c_str ((const struct string *) __str), __idx, __base)>>;


;; Function long long int std::__cxx11::stoll(const string&, std::size_t*, int) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __gnu_cxx::__stoa<long long int> (strtoll, (const char *) "stoll", std::__cxx11::basic_string<char>::c_str ((const struct string *) __str), __idx, __base)>>;


;; Function long long unsigned int std::__cxx11::stoull(const string&, std::size_t*, int) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __gnu_cxx::__stoa<long long unsigned int> (strtoull, (const char *) "stoull", std::__cxx11::basic_string<char>::c_str ((const struct string *) __str), __idx, __base)>>;


;; Function float std::__cxx11::stof(const string&, std::size_t*) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __gnu_cxx::__stoa<float> (strtof, (const char *) "stof", std::__cxx11::basic_string<char>::c_str ((const struct string *) __str), __idx)>>;


;; Function double std::__cxx11::stod(const string&, std::size_t*) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __gnu_cxx::__stoa<double> (strtod, (const char *) "stod", std::__cxx11::basic_string<char>::c_str ((const struct string *) __str), __idx)>>;


;; Function long double std::__cxx11::stold(const string&, std::size_t*) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __gnu_cxx::__stoa<long double> (strtold, (const char *) "stold", std::__cxx11::basic_string<char>::c_str ((const struct string *) __str), __idx)>>;


;; Function std::__cxx11::string std::__cxx11::to_string(int) (null)
;; enabled by -tree-original


<<cleanup_point return *<retval> = TARGET_EXPR <D.19756, <<< Unknown tree: aggr_init_expr
  7
  __to_xstring
  D.19756
  vsnprintf
  16
  (const char *) "%d"
  __val >>>>>>;


;; Function std::__cxx11::string std::__cxx11::to_string(unsigned int) (null)
;; enabled by -tree-original


<<cleanup_point return *<retval> = TARGET_EXPR <D.19822, <<< Unknown tree: aggr_init_expr
  7
  __to_xstring
  D.19822
  vsnprintf
  16
  (const char *) "%u"
  __val >>>>>>;


;; Function std::__cxx11::string std::__cxx11::to_string(long int) (null)
;; enabled by -tree-original


<<cleanup_point return *<retval> = TARGET_EXPR <D.19826, <<< Unknown tree: aggr_init_expr
  7
  __to_xstring
  D.19826
  vsnprintf
  32
  (const char *) "%ld"
  __val >>>>>>;


;; Function std::__cxx11::string std::__cxx11::to_string(long unsigned int) (null)
;; enabled by -tree-original


<<cleanup_point return *<retval> = TARGET_EXPR <D.19830, <<< Unknown tree: aggr_init_expr
  7
  __to_xstring
  D.19830
  vsnprintf
  32
  (const char *) "%lu"
  __val >>>>>>;


;; Function std::__cxx11::string std::__cxx11::to_string(long long int) (null)
;; enabled by -tree-original


<<cleanup_point return *<retval> = TARGET_EXPR <D.19834, <<< Unknown tree: aggr_init_expr
  7
  __to_xstring
  D.19834
  vsnprintf
  32
  (const char *) "%lld"
  __val >>>>>>;


;; Function std::__cxx11::string std::__cxx11::to_string(long long unsigned int) (null)
;; enabled by -tree-original


<<cleanup_point return *<retval> = TARGET_EXPR <D.19838, <<< Unknown tree: aggr_init_expr
  7
  __to_xstring
  D.19838
  vsnprintf
  32
  (const char *) "%llu"
  __val >>>>>>;


;; Function std::__cxx11::string std::__cxx11::to_string(float) (null)
;; enabled by -tree-original


{
  const int __n = 58;

  <<cleanup_point   const int __n = 58;>>;
  <<cleanup_point return *<retval> = TARGET_EXPR <D.19869, <<< Unknown tree: aggr_init_expr
  7
  __to_xstring
  D.19869
  vsnprintf
  58
  (const char *) "%f"
  (double) __val >>>>>>;
}


;; Function std::__cxx11::string std::__cxx11::to_string(double) (null)
;; enabled by -tree-original


{
  const int __n = 328;

  <<cleanup_point   const int __n = 328;>>;
  <<cleanup_point return *<retval> = TARGET_EXPR <D.19900, <<< Unknown tree: aggr_init_expr
  7
  __to_xstring
  D.19900
  vsnprintf
  328
  (const char *) "%f"
  __val >>>>>>;
}


;; Function std::__cxx11::string std::__cxx11::to_string(long double) (null)
;; enabled by -tree-original


{
  const int __n = 4952;

  <<cleanup_point   const int __n = 4952;>>;
  <<cleanup_point return *<retval> = TARGET_EXPR <D.19931, <<< Unknown tree: aggr_init_expr
  7
  __to_xstring
  D.19931
  vsnprintf
  4952
  (const char *) "%Lf"
  __val >>>>>>;
}


;; Function int std::__cxx11::stoi(const wstring&, std::size_t*, int) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __gnu_cxx::__stoa<long int, int, wchar_t, int> (wcstol, (const char *) "stoi", std::__cxx11::basic_string<wchar_t>::c_str ((const struct wstring *) __str), __idx, __base)>>;


;; Function long int std::__cxx11::stol(const wstring&, std::size_t*, int) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __gnu_cxx::__stoa<long int> (wcstol, (const char *) "stol", std::__cxx11::basic_string<wchar_t>::c_str ((const struct wstring *) __str), __idx, __base)>>;


;; Function long unsigned int std::__cxx11::stoul(const wstring&, std::size_t*, int) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __gnu_cxx::__stoa<long unsigned int> (wcstoul, (const char *) "stoul", std::__cxx11::basic_string<wchar_t>::c_str ((const struct wstring *) __str), __idx, __base)>>;


;; Function long long int std::__cxx11::stoll(const wstring&, std::size_t*, int) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __gnu_cxx::__stoa<long long int> (wcstoll, (const char *) "stoll", std::__cxx11::basic_string<wchar_t>::c_str ((const struct wstring *) __str), __idx, __base)>>;


;; Function long long unsigned int std::__cxx11::stoull(const wstring&, std::size_t*, int) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __gnu_cxx::__stoa<long long unsigned int> (wcstoull, (const char *) "stoull", std::__cxx11::basic_string<wchar_t>::c_str ((const struct wstring *) __str), __idx, __base)>>;


;; Function float std::__cxx11::stof(const wstring&, std::size_t*) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __gnu_cxx::__stoa<float> (wcstof, (const char *) "stof", std::__cxx11::basic_string<wchar_t>::c_str ((const struct wstring *) __str), __idx)>>;


;; Function double std::__cxx11::stod(const wstring&, std::size_t*) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __gnu_cxx::__stoa<double> (wcstod, (const char *) "stod", std::__cxx11::basic_string<wchar_t>::c_str ((const struct wstring *) __str), __idx)>>;


;; Function long double std::__cxx11::stold(const wstring&, std::size_t*) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = __gnu_cxx::__stoa<long double> (wcstold, (const char *) "stold", std::__cxx11::basic_string<wchar_t>::c_str ((const struct wstring *) __str), __idx)>>;


;; Function std::__cxx11::wstring std::__cxx11::to_wstring(int) (null)
;; enabled by -tree-original


<<cleanup_point return *<retval> = TARGET_EXPR <D.21155, <<< Unknown tree: aggr_init_expr
  7
  __to_xstring
  D.21155
  vswprintf
  16
  (const wchar_t *) "%"
  __val >>>>>>;


;; Function std::__cxx11::wstring std::__cxx11::to_wstring(unsigned int) (null)
;; enabled by -tree-original


<<cleanup_point return *<retval> = TARGET_EXPR <D.21221, <<< Unknown tree: aggr_init_expr
  7
  __to_xstring
  D.21221
  vswprintf
  16
  (const wchar_t *) "%"
  __val >>>>>>;


;; Function std::__cxx11::wstring std::__cxx11::to_wstring(long int) (null)
;; enabled by -tree-original


<<cleanup_point return *<retval> = TARGET_EXPR <D.21225, <<< Unknown tree: aggr_init_expr
  7
  __to_xstring
  D.21225
  vswprintf
  32
  (const wchar_t *) "%"
  __val >>>>>>;


;; Function std::__cxx11::wstring std::__cxx11::to_wstring(long unsigned int) (null)
;; enabled by -tree-original


<<cleanup_point return *<retval> = TARGET_EXPR <D.21229, <<< Unknown tree: aggr_init_expr
  7
  __to_xstring
  D.21229
  vswprintf
  32
  (const wchar_t *) "%"
  __val >>>>>>;


;; Function std::__cxx11::wstring std::__cxx11::to_wstring(long long int) (null)
;; enabled by -tree-original


<<cleanup_point return *<retval> = TARGET_EXPR <D.21233, <<< Unknown tree: aggr_init_expr
  7
  __to_xstring
  D.21233
  vswprintf
  32
  (const wchar_t *) "%"
  __val >>>>>>;


;; Function std::__cxx11::wstring std::__cxx11::to_wstring(long long unsigned int) (null)
;; enabled by -tree-original


<<cleanup_point return *<retval> = TARGET_EXPR <D.21237, <<< Unknown tree: aggr_init_expr
  7
  __to_xstring
  D.21237
  vswprintf
  32
  (const wchar_t *) "%"
  __val >>>>>>;


;; Function std::__cxx11::wstring std::__cxx11::to_wstring(float) (null)
;; enabled by -tree-original


{
  const int __n = 58;

  <<cleanup_point   const int __n = 58;>>;
  <<cleanup_point return *<retval> = TARGET_EXPR <D.21242, <<< Unknown tree: aggr_init_expr
  7
  __to_xstring
  D.21242
  vswprintf
  58
  (const wchar_t *) "%"
  (double) __val >>>>>>;
}


;; Function std::__cxx11::wstring std::__cxx11::to_wstring(double) (null)
;; enabled by -tree-original


{
  const int __n = 328;

  <<cleanup_point   const int __n = 328;>>;
  <<cleanup_point return *<retval> = TARGET_EXPR <D.21247, <<< Unknown tree: aggr_init_expr
  7
  __to_xstring
  D.21247
  vswprintf
  328
  (const wchar_t *) "%"
  __val >>>>>>;
}


;; Function std::__cxx11::wstring std::__cxx11::to_wstring(long double) (null)
;; enabled by -tree-original


{
  const int __n = 4952;

  <<cleanup_point   const int __n = 4952;>>;
  <<cleanup_point return *<retval> = TARGET_EXPR <D.21252, <<< Unknown tree: aggr_init_expr
  7
  __to_xstring
  D.21252
  vswprintf
  4952
  (const wchar_t *) "%"
  __val >>>>>>;
}


;; Function std::size_t std::hash<bool>::operator()(bool) const (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (size_t) __val
   >>>;


;; Function std::size_t std::hash<char>::operator()(char) const (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (size_t) __val
   >>>;


;; Function std::size_t std::hash<signed char>::operator()(signed char) const (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (size_t) __val
   >>>;


;; Function std::size_t std::hash<unsigned char>::operator()(unsigned char) const (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (size_t) __val
   >>>;


;; Function std::size_t std::hash<wchar_t>::operator()(wchar_t) const (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (size_t) __val
   >>>;


;; Function std::size_t std::hash<char16_t>::operator()(char16_t) const (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (size_t) __val
   >>>;


;; Function std::size_t std::hash<char32_t>::operator()(char32_t) const (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (size_t) __val
   >>>;


;; Function std::size_t std::hash<short int>::operator()(short int) const (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (size_t) __val
   >>>;


;; Function std::size_t std::hash<int>::operator()(int) const (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (size_t) __val
   >>>;


;; Function std::size_t std::hash<long int>::operator()(long int) const (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (size_t) __val
   >>>;


;; Function std::size_t std::hash<long long int>::operator()(long long int) const (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (size_t) __val
   >>>;


;; Function std::size_t std::hash<short unsigned int>::operator()(short unsigned int) const (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (size_t) __val
   >>>;


;; Function std::size_t std::hash<unsigned int>::operator()(unsigned int) const (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (size_t) __val
   >>>;


;; Function std::size_t std::hash<long unsigned int>::operator()(long unsigned int) const (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = __val
   >>>;


;; Function std::size_t std::hash<long long unsigned int>::operator()(long long unsigned int) const (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (size_t) __val
   >>>;


;; Function std::size_t std::hash<__int128>::operator()(__int128) const (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (size_t) __val
   >>>;


;; Function std::size_t std::hash<__int128 unsigned>::operator()(__int128 unsigned) const (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (size_t) __val
   >>>;


;; Function static std::size_t std::_Hash_impl::hash(const void*, std::size_t, std::size_t) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = std::_Hash_bytes (__ptr, __clength, __seed)>>;


;; Function static std::size_t std::_Fnv_hash_impl::hash(const void*, std::size_t, std::size_t) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = std::_Fnv_hash_bytes (__ptr, __clength, __seed)>>;


;; Function std::size_t std::hash<float>::operator()(float) const (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = __val != 0.0 ? std::_Hash_impl::hash<float> ((const float &) &__val) : 0>>
   >>>;


;; Function std::size_t std::hash<double>::operator()(double) const (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = __val != 0.0 ? std::_Hash_impl::hash<double> ((const double &) &__val) : 0>>
   >>>;


;; Function std::size_t std::hash<std::__cxx11::basic_string<char> >::operator()(const string&) const (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::_Hash_impl::hash ((const void *) std::__cxx11::basic_string<char>::data ((const struct string *) __s), std::__cxx11::basic_string<char>::length ((const struct string *) __s), 3339675911)>>
   >>>;


;; Function std::size_t std::hash<std::__cxx11::basic_string<wchar_t> >::operator()(const wstring&) const (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::_Hash_impl::hash ((const void *) std::__cxx11::basic_string<wchar_t>::data ((const struct wstring *) __s), std::__cxx11::basic_string<wchar_t>::length ((const struct wstring *) __s) * 4, 3339675911)>>
   >>>;


;; Function std::size_t std::hash<std::__cxx11::basic_string<char16_t> >::operator()(const u16string&) const (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::_Hash_impl::hash ((const void *) std::__cxx11::basic_string<char16_t>::data ((const struct u16string *) __s), std::__cxx11::basic_string<char16_t>::length ((const struct u16string *) __s) * 2, 3339675911)>>
   >>>;


;; Function std::size_t std::hash<std::__cxx11::basic_string<char32_t> >::operator()(const u32string&) const (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::_Hash_impl::hash ((const void *) std::__cxx11::basic_string<char32_t>::data ((const struct u32string *) __s), std::__cxx11::basic_string<char32_t>::length ((const struct u32string *) __s) * 4, 3339675911)>>
   >>>;


;; Function std::__cxx11::basic_string<char> std::literals::string_literals::operator""s(const char*, std::size_t) (null)
;; enabled by -tree-original


<<cleanup_point return *<retval> = TARGET_EXPR <D.24271, <<< Unknown tree: aggr_init_expr
  7
  __comp_ctor 
  D.24271
  (struct basic_string *) <<< Unknown tree: void_cst >>>
  __str
  __len
  (const struct allocator &) &TARGET_EXPR <D.24270, <<< Unknown tree: aggr_init_expr
  4
  __comp_ctor 
  D.24270
  (struct allocator *) <<< Unknown tree: void_cst >>> >>>> >>>>>>;


;; Function std::__cxx11::basic_string<wchar_t> std::literals::string_literals::operator""s(const wchar_t*, std::size_t) (null)
;; enabled by -tree-original


<<cleanup_point return *<retval> = TARGET_EXPR <D.24278, <<< Unknown tree: aggr_init_expr
  7
  __comp_ctor 
  D.24278
  (struct basic_string *) <<< Unknown tree: void_cst >>>
  __str
  __len
  (const struct allocator &) &TARGET_EXPR <D.24277, <<< Unknown tree: aggr_init_expr
  4
  __comp_ctor 
  D.24277
  (struct allocator *) <<< Unknown tree: void_cst >>> >>>> >>>>>>;


;; Function std::__cxx11::basic_string<char16_t> std::literals::string_literals::operator""s(const char16_t*, std::size_t) (null)
;; enabled by -tree-original


<<cleanup_point return *<retval> = TARGET_EXPR <D.24338, <<< Unknown tree: aggr_init_expr
  7
  __comp_ctor 
  D.24338
  (struct basic_string *) <<< Unknown tree: void_cst >>>
  __str
  __len
  (const struct allocator &) &TARGET_EXPR <D.24337, <<< Unknown tree: aggr_init_expr
  4
  __comp_ctor 
  D.24337
  (struct allocator *) <<< Unknown tree: void_cst >>> >>>> >>>>>>;


;; Function std::__cxx11::basic_string<char32_t> std::literals::string_literals::operator""s(const char32_t*, std::size_t) (null)
;; enabled by -tree-original


<<cleanup_point return *<retval> = TARGET_EXPR <D.24407, <<< Unknown tree: aggr_init_expr
  7
  __comp_ctor 
  D.24407
  (struct basic_string *) <<< Unknown tree: void_cst >>>
  __str
  __len
  (const struct allocator &) &TARGET_EXPR <D.24406, <<< Unknown tree: aggr_init_expr
  4
  __comp_ctor 
  D.24406
  (struct allocator *) <<< Unknown tree: void_cst >>> >>>> >>>>>>;


;; Function ssize_t read(int, void*, size_t) (null)
;; enabled by -tree-original


if (__builtin_object_size ((const void *) __buf, 0) != 18446744073709551615)
  {
    if (__builtin_constant_p (__nbytes) == 0)
      {
        <<cleanup_point return <retval> = __read_chk (__fd, __buf, __nbytes, __builtin_object_size ((const void *) __buf, 0))>>;
      }
    if (__builtin_object_size ((const void *) __buf, 0) < __nbytes)
      {
        <<cleanup_point return <retval> = __read_chk_warn (__fd, __buf, __nbytes, __builtin_object_size ((const void *) __buf, 0))>>;
      }
  }
<<cleanup_point return <retval> = __read_alias (__fd, __buf, __nbytes)>>;


;; Function ssize_t pread(int, void*, size_t, __off64_t) (*pread64)
;; enabled by -tree-original


if (__builtin_object_size ((const void *) __buf, 0) != 18446744073709551615)
  {
    if (__builtin_constant_p (__nbytes) == 0)
      {
        <<cleanup_point return <retval> = __pread64_chk (__fd, __buf, __nbytes, __offset, __builtin_object_size ((const void *) __buf, 0))>>;
      }
    if (__builtin_object_size ((const void *) __buf, 0) < __nbytes)
      {
        <<cleanup_point return <retval> = __pread64_chk_warn (__fd, __buf, __nbytes, __offset, __builtin_object_size ((const void *) __buf, 0))>>;
      }
  }
<<cleanup_point return <retval> = __pread64_alias (__fd, __buf, __nbytes, __offset)>>;


;; Function ssize_t pread64(int, void*, size_t, __off64_t) (null)
;; enabled by -tree-original


if (__builtin_object_size ((const void *) __buf, 0) != 18446744073709551615)
  {
    if (__builtin_constant_p (__nbytes) == 0)
      {
        <<cleanup_point return <retval> = __pread64_chk (__fd, __buf, __nbytes, __offset, __builtin_object_size ((const void *) __buf, 0))>>;
      }
    if (__builtin_object_size ((const void *) __buf, 0) < __nbytes)
      {
        <<cleanup_point return <retval> = __pread64_chk_warn (__fd, __buf, __nbytes, __offset, __builtin_object_size ((const void *) __buf, 0))>>;
      }
  }
<<cleanup_point return <retval> = __pread64_alias (__fd, __buf, __nbytes, __offset)>>;


;; Function ssize_t readlink(const char*, char*, size_t) (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  if (__builtin_object_size ((const void *) __buf, 1) != 18446744073709551615)
    {
      if (__builtin_constant_p (__len) == 0)
        {
          <<cleanup_point return <retval> = __readlink_chk (__path, __buf, __len, __builtin_object_size ((const void *) __buf, 1))>>;
        }
      if (__builtin_object_size ((const void *) __buf, 1) < __len)
        {
          <<cleanup_point return <retval> = __readlink_chk_warn (__path, __buf, __len, __builtin_object_size ((const void *) __buf, 1))>>;
        }
    }
  <<cleanup_point return <retval> = __readlink_alias (__path, __buf, __len)>>;
   >>>;


;; Function ssize_t readlinkat(int, const char*, char*, size_t) (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  if (__builtin_object_size ((const void *) __buf, 1) != 18446744073709551615)
    {
      if (__builtin_constant_p (__len) == 0)
        {
          <<cleanup_point return <retval> = __readlinkat_chk (__fd, __path, __buf, __len, __builtin_object_size ((const void *) __buf, 1))>>;
        }
      if (__builtin_object_size ((const void *) __buf, 1) < __len)
        {
          <<cleanup_point return <retval> = __readlinkat_chk_warn (__fd, __path, __buf, __len, __builtin_object_size ((const void *) __buf, 1))>>;
        }
    }
  <<cleanup_point return <retval> = __readlinkat_alias (__fd, __path, __buf, __len)>>;
   >>>;


;; Function char* getcwd(char*, size_t) (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  if (__builtin_object_size ((const void *) __buf, 1) != 18446744073709551615)
    {
      if (__builtin_constant_p (__size) == 0)
        {
          <<cleanup_point return <retval> = __getcwd_chk (__buf, __size, __builtin_object_size ((const void *) __buf, 1))>>;
        }
      if (__builtin_object_size ((const void *) __buf, 1) < __size)
        {
          <<cleanup_point return <retval> = __getcwd_chk_warn (__buf, __size, __builtin_object_size ((const void *) __buf, 1))>>;
        }
    }
  <<cleanup_point return <retval> = __getcwd_alias (__buf, __size)>>;
   >>>;


;; Function char* getwd(char*) (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  if (__builtin_object_size ((const void *) __buf, 1) != 18446744073709551615)
    {
      <<cleanup_point return <retval> = __getwd_chk (__buf, __builtin_object_size ((const void *) __buf, 1))>>;
    }
  <<cleanup_point return <retval> = __getwd_warn (__buf)>>;
   >>>;


;; Function size_t confstr(int, char*, size_t) (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  if (__builtin_object_size ((const void *) __buf, 1) != 18446744073709551615)
    {
      if (__builtin_constant_p (__len) == 0)
        {
          <<cleanup_point return <retval> = __confstr_chk (__name, __buf, __len, __builtin_object_size ((const void *) __buf, 1))>>;
        }
      if (__builtin_object_size ((const void *) __buf, 1) < __len)
        {
          <<cleanup_point return <retval> = __confstr_chk_warn (__name, __buf, __len, __builtin_object_size ((const void *) __buf, 1))>>;
        }
    }
  <<cleanup_point return <retval> = __confstr_alias (__name, __buf, __len)>>;
   >>>;


;; Function int getgroups(int, __gid_t*) (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  if (__builtin_object_size ((const void *) __list, 1) != 18446744073709551615)
    {
      if (__builtin_constant_p (__size) == 0 || __size < 0)
        {
          <<cleanup_point return <retval> = __getgroups_chk (__size, __list, __builtin_object_size ((const void *) __list, 1))>>;
        }
      if ((long unsigned int) __size * 4 > __builtin_object_size ((const void *) __list, 1))
        {
          <<cleanup_point return <retval> = __getgroups_chk_warn (__size, __list, __builtin_object_size ((const void *) __list, 1))>>;
        }
    }
  <<cleanup_point return <retval> = __getgroups_alias (__size, __list)>>;
   >>>;


;; Function int ttyname_r(int, char*, size_t) (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  if (__builtin_object_size ((const void *) __buf, 1) != 18446744073709551615)
    {
      if (__builtin_constant_p (__buflen) == 0)
        {
          <<cleanup_point return <retval> = __ttyname_r_chk (__fd, __buf, __buflen, __builtin_object_size ((const void *) __buf, 1))>>;
        }
      if (__builtin_object_size ((const void *) __buf, 1) < __buflen)
        {
          <<cleanup_point return <retval> = __ttyname_r_chk_warn (__fd, __buf, __buflen, __builtin_object_size ((const void *) __buf, 1))>>;
        }
    }
  <<cleanup_point return <retval> = __ttyname_r_alias (__fd, __buf, __buflen)>>;
   >>>;


;; Function int getlogin_r(char*, size_t) (null)
;; enabled by -tree-original


if (__builtin_object_size ((const void *) __buf, 1) != 18446744073709551615)
  {
    if (__builtin_constant_p (__buflen) == 0)
      {
        <<cleanup_point return <retval> = __getlogin_r_chk (__buf, __buflen, __builtin_object_size ((const void *) __buf, 1))>>;
      }
    if (__builtin_object_size ((const void *) __buf, 1) < __buflen)
      {
        <<cleanup_point return <retval> = __getlogin_r_chk_warn (__buf, __buflen, __builtin_object_size ((const void *) __buf, 1))>>;
      }
  }
<<cleanup_point return <retval> = __getlogin_r_alias (__buf, __buflen)>>;


;; Function int gethostname(char*, size_t) (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  if (__builtin_object_size ((const void *) __buf, 1) != 18446744073709551615)
    {
      if (__builtin_constant_p (__buflen) == 0)
        {
          <<cleanup_point return <retval> = __gethostname_chk (__buf, __buflen, __builtin_object_size ((const void *) __buf, 1))>>;
        }
      if (__builtin_object_size ((const void *) __buf, 1) < __buflen)
        {
          <<cleanup_point return <retval> = __gethostname_chk_warn (__buf, __buflen, __builtin_object_size ((const void *) __buf, 1))>>;
        }
    }
  <<cleanup_point return <retval> = __gethostname_alias (__buf, __buflen)>>;
   >>>;


;; Function int getdomainname(char*, size_t) (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  if (__builtin_object_size ((const void *) __buf, 1) != 18446744073709551615)
    {
      if (__builtin_constant_p (__buflen) == 0)
        {
          <<cleanup_point return <retval> = __getdomainname_chk (__buf, __buflen, __builtin_object_size ((const void *) __buf, 1))>>;
        }
      if (__builtin_object_size ((const void *) __buf, 1) < __buflen)
        {
          <<cleanup_point return <retval> = __getdomainname_chk_warn (__buf, __buflen, __builtin_object_size ((const void *) __buf, 1))>>;
        }
    }
  <<cleanup_point return <retval> = __getdomainname_alias (__buf, __buflen)>>;
   >>>;


;; Function intmax_t strtoimax(const char*, char**, int) (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  <<cleanup_point return <retval> = __strtol_internal (nptr, endptr, base, 0)>>
   >>>;


;; Function uintmax_t strtoumax(const char*, char**, int) (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  <<cleanup_point return <retval> = __strtoul_internal (nptr, endptr, base, 0)>>
   >>>;


;; Function intmax_t wcstoimax(const wchar_t*, wchar_t**, int) (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  <<cleanup_point return <retval> = __wcstol_internal (nptr, endptr, base, 0)>>
   >>>;


;; Function uintmax_t wcstoumax(const wchar_t*, wchar_t**, int) (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  <<cleanup_point return <retval> = __wcstoul_internal (nptr, endptr, base, 0)>>
   >>>;


;; Function outBuff::outBuff(char*, unsigned int, int, int, unsigned int, bool, outBuff*) (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  *(struct 
  {
    char * buf;
    unsigned int bufSize;
    int blockNumber;
    int sequenceNumber;
    unsigned int inSize;
    bool isLastInSequence;
    struct outBuff * next;
  } &) this = {CLOBBER} >>>>>;
{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct outBuff *) this)->buf = aBuf) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct outBuff *) this)->bufSize = aBufSize) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct outBuff *) this)->blockNumber = aBlockNumber) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct outBuff *) this)->sequenceNumber = aSequenceNumber) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct outBuff *) this)->inSize = aInSize) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct outBuff *) this)->isLastInSequence = isLast) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct outBuff *) this)->next = aNext) >>>>>;
}


;; Function queue::queue() (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  *(struct 
  {
    struct ElementType * * qData;
    long int size;
    long int count;
    long int head;
    long int tail;
    int full;
    int empty;
    int topLevelFull;
    int topLevelEmpty;
    union pthread_mutex_t * mut;
    union pthread_cond_t * notFull;
    union pthread_cond_t * notEmpty;
    pthread_t * consumers;
    struct ElementType * lastElement;
  } &) this = {CLOBBER} >>>>>;
{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct queue *) this)->count = 0) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct queue *) this)->lastElement = 0B) >>>>>;
}


;; Function void queue::clear() (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct queue *) this)->empty = 1) >>>>>;
<<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct queue *) this)->full = 0) >>>>>;
<<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct queue *) this)->head = 0) >>>>>;
<<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct queue *) this)->tail = 0) >>>>>;
<<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct queue *) this)->count = 0) >>>>>;
<<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct queue *) this)->lastElement = 0B) >>>>>;
<<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct queue *) this)->topLevelFull = 0) >>>>>;
<<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct queue *) this)->topLevelEmpty = 1) >>>>>;


;; Function void queue::add(queue::ElementTypePtr) (null)
;; enabled by -tree-original


if (element->sequenceNumber > 1)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct queue *) this)->lastElement->next = element) >>>>>;
  }
else
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*(((struct queue *) this)->qData + (sizetype) ((long unsigned int) ((struct queue *) this)->tail * 8)) = element) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void)  ++((struct queue *) this)->tail >>>>>;
    if (((struct queue *) this)->tail == ((struct queue *) this)->size)
      {
        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct queue *) this)->tail = 0) >>>>>;
      }
    if (((struct queue *) this)->tail == ((struct queue *) this)->head)
      {
        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct queue *) this)->topLevelFull = 1) >>>>>;
      }
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct queue *) this)->topLevelEmpty = 0) >>>>>;
  }
<<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct queue *) this)->lastElement = element) >>>>>;
<<cleanup_point <<< Unknown tree: expr_stmt
  (void)  ++((struct queue *) this)->count >>>>>;
if (((struct queue *) this)->count == ((struct queue *) this)->size)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct queue *) this)->full = 1) >>>>>;
  }
<<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct queue *) this)->empty = 0) >>>>>;


;; Function int queue::remove(queue::ElementType*&) (null)
;; enabled by -tree-original


{
  struct ElementType * & headElem = (struct ElementType * &) (((struct queue *) this)->qData + (sizetype) ((long unsigned int) ((struct queue *) this)->head * 8));

    struct ElementType * & headElem = (struct ElementType * &) (((struct queue *) this)->qData + (sizetype) ((long unsigned int) ((struct queue *) this)->head * 8));
  if (*element != 0B && !(*element)->isLastInSequence)
    {
      if ((*element)->next != 0B)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*element = (*element)->next) >>>>>;
        }
      else
        {
          return <retval> = 0;
        }
    }
  else
    {
      if (((struct queue *) this)->topLevelEmpty != 0)
        {
          return <retval> = 0;
        }
      else
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*element = *headElem) >>>>>;
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void)  ++((struct queue *) this)->head >>>>>;
          if (((struct queue *) this)->head == ((struct queue *) this)->size)
            {
              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct queue *) this)->head = 0) >>>>>;
            }
          if (((struct queue *) this)->head == ((struct queue *) this)->tail)
            {
              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct queue *) this)->topLevelEmpty = 1) >>>>>;
            }
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct queue *) this)->topLevelFull = 0) >>>>>;
        }
    }
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void)  --((struct queue *) this)->count >>>>>;
  if (((struct queue *) this)->count == 0)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct queue *) this)->empty = 1) >>>>>;
    }
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct queue *) this)->full = 0) >>>>>;
  return <retval> = 1;
}


;; Function std::_Bit_reference::_Bit_reference(std::_Bit_type*, std::_Bit_type) (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  *(struct 
  {
    _Bit_type * _M_p;
    _Bit_type _M_mask;
  } &) this = {CLOBBER} >>>>>;
{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Bit_reference *) this)->_M_p = __x) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Bit_reference *) this)->_M_mask = __y) >>>>>;
}


;; Function std::_Bit_reference::_Bit_reference() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point <<< Unknown tree: expr_stmt
  *(struct 
  {
    _Bit_type * _M_p;
    _Bit_type _M_mask;
  } &) this = {CLOBBER} >>>>>;
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Bit_reference *) this)->_M_p = 0B) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Bit_reference *) this)->_M_mask = 0) >>>>>;
  }
   >>>;


;; Function std::_Bit_reference::operator bool() const (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (*(_Bit_type *) ((const struct _Bit_reference *) this)->_M_p & (long unsigned int) ((const struct _Bit_reference *) this)->_M_mask) != 0
   >>>;


;; Function std::_Bit_reference& std::_Bit_reference::operator=(bool) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  if (__x)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*((struct _Bit_reference *) this)->_M_p = *((struct _Bit_reference *) this)->_M_p | ((struct _Bit_reference *) this)->_M_mask) >>>>>;
    }
  else
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*((struct _Bit_reference *) this)->_M_p = *((struct _Bit_reference *) this)->_M_p & ~((struct _Bit_reference *) this)->_M_mask) >>>>>;
    }
  return <retval> = (struct _Bit_reference &) this;
   >>>;


;; Function std::_Bit_reference& std::_Bit_reference::operator=(const std::_Bit_reference&) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::_Bit_reference::operator= ((struct _Bit_reference *) this, (int) std::_Bit_reference::operator bool ((const struct _Bit_reference *) __x))>>
   >>>;


;; Function bool std::_Bit_reference::operator==(const std::_Bit_reference&) const (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = std::_Bit_reference::operator bool ((const struct _Bit_reference *) this) == std::_Bit_reference::operator bool ((const struct _Bit_reference *) __x)>>;


;; Function bool std::_Bit_reference::operator<(const std::_Bit_reference&) const (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = !std::_Bit_reference::operator bool ((const struct _Bit_reference *) this) && std::_Bit_reference::operator bool ((const struct _Bit_reference *) __x)>>;


;; Function void std::_Bit_reference::flip() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*((struct _Bit_reference *) this)->_M_p = *((struct _Bit_reference *) this)->_M_p ^ ((struct _Bit_reference *) this)->_M_mask) >>>>>
   >>>;


;; Function void std::swap(std::_Bit_reference, std::_Bit_reference) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    bool __tmp;

        bool __tmp;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__tmp = std::_Bit_reference::operator bool (&__x)) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) std::_Bit_reference::operator= (&__x, (const struct _Bit_reference &) &__y) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) std::_Bit_reference::operator= (&__y, (int) __tmp) >>>>>;
  }
   >>>;


;; Function void std::swap(std::_Bit_reference, bool&) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    bool __tmp;

        bool __tmp;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__tmp = std::_Bit_reference::operator bool (&__x)) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) std::_Bit_reference::operator= (&__x, (int) *__y) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__y = __tmp) >>>>>;
  }
   >>>;


;; Function void std::swap(bool&, std::_Bit_reference) (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    bool __tmp = *__x;

        bool __tmp = *__x;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__x = std::_Bit_reference::operator bool (&__y)) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) std::_Bit_reference::operator= (&__y, (int) __tmp) >>>>>;
  }
   >>>;


;; Function std::_Bit_iterator_base::_Bit_iterator_base(std::_Bit_type*, unsigned int) (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  *(struct 
  {
    _Bit_type * _M_p;
    unsigned int _M_offset;
  } &) this = {CLOBBER} >>>>>;
{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Bit_iterator_base *) this)->_M_p = __x) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Bit_iterator_base *) this)->_M_offset = __y) >>>>>;
}


;; Function void std::_Bit_iterator_base::_M_bump_up() (null)
;; enabled by -tree-original


if (<<cleanup_point ((struct _Bit_iterator_base *) this)->_M_offset++  == 63>>)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Bit_iterator_base *) this)->_M_offset = 0) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void)  ++((struct _Bit_iterator_base *) this)->_M_p >>>>>;
  }


;; Function void std::_Bit_iterator_base::_M_bump_down() (null)
;; enabled by -tree-original


if (<<cleanup_point ((struct _Bit_iterator_base *) this)->_M_offset--  == 0>>)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Bit_iterator_base *) this)->_M_offset = 63) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void)  --((struct _Bit_iterator_base *) this)->_M_p >>>>>;
  }


;; Function void std::_Bit_iterator_base::_M_incr(std::ptrdiff_t) (null)
;; enabled by -tree-original


{
  difference_type __n = (ptrdiff_t) ((struct _Bit_iterator_base *) this)->_M_offset + __i;

    difference_type __n = (ptrdiff_t) ((struct _Bit_iterator_base *) this)->_M_offset + __i;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Bit_iterator_base *) this)->_M_p = ((struct _Bit_iterator_base *) this)->_M_p + (sizetype) ((long unsigned int) (__n / 64) * 8)) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__n = __n % 64) >>>>>;
  if (__n < 0)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__n = __n + 64) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void)  --((struct _Bit_iterator_base *) this)->_M_p >>>>>;
    }
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Bit_iterator_base *) this)->_M_offset = (unsigned int) __n) >>>>>;
}


;; Function bool std::_Bit_iterator_base::operator==(const std::_Bit_iterator_base&) const (null)
;; enabled by -tree-original


return <retval> = (_Bit_type *) ((const struct _Bit_iterator_base *) this)->_M_p == (_Bit_type *) __i->_M_p && ((const struct _Bit_iterator_base *) this)->_M_offset == __i->_M_offset;


;; Function bool std::_Bit_iterator_base::operator<(const std::_Bit_iterator_base&) const (null)
;; enabled by -tree-original


return <retval> = (_Bit_type *) ((const struct _Bit_iterator_base *) this)->_M_p < (_Bit_type *) __i->_M_p || (_Bit_type *) ((const struct _Bit_iterator_base *) this)->_M_p == (_Bit_type *) __i->_M_p && ((const struct _Bit_iterator_base *) this)->_M_offset < __i->_M_offset;


;; Function bool std::_Bit_iterator_base::operator!=(const std::_Bit_iterator_base&) const (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = !std::_Bit_iterator_base::operator== ((const struct _Bit_iterator_base *) this, __i)>>;


;; Function bool std::_Bit_iterator_base::operator>(const std::_Bit_iterator_base&) const (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = std::_Bit_iterator_base::operator< ((const struct _Bit_iterator_base *) __i, (const struct _Bit_iterator_base &) this)>>;


;; Function bool std::_Bit_iterator_base::operator<=(const std::_Bit_iterator_base&) const (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = !std::_Bit_iterator_base::operator< ((const struct _Bit_iterator_base *) __i, (const struct _Bit_iterator_base &) this)>>;


;; Function bool std::_Bit_iterator_base::operator>=(const std::_Bit_iterator_base&) const (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = !std::_Bit_iterator_base::operator< ((const struct _Bit_iterator_base *) this, __i)>>;


;; Function std::ptrdiff_t std::operator-(const std::_Bit_iterator_base&, const std::_Bit_iterator_base&) (null)
;; enabled by -tree-original


return <retval> = ((((long int) __x->_M_p - (long int) __y->_M_p) /[ex] 8) * 64 + (long int) __x->_M_offset) - (long int) __y->_M_offset;


;; Function std::_Bit_iterator::_Bit_iterator() (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  *(struct 
  {
    struct 
    {
      _Bit_type * _M_p;
      unsigned int _M_offset;
    } D.27795;
  } &) this = {CLOBBER} >>>>>;
{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Bit_iterator_base::_Bit_iterator_base (&((struct _Bit_iterator *) this)->D.27794, 0B, 0) >>>>>;
}


;; Function std::_Bit_iterator::_Bit_iterator(std::_Bit_type*, unsigned int) (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  *(struct 
  {
    struct 
    {
      _Bit_type * _M_p;
      unsigned int _M_offset;
    } D.27795;
  } &) this = {CLOBBER} >>>>>;
{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Bit_iterator_base::_Bit_iterator_base (&((struct _Bit_iterator *) this)->D.27794, __x, __y) >>>>>;
}


;; Function std::_Bit_iterator::iterator std::_Bit_iterator::_M_const_cast() const (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = TARGET_EXPR <D.27848, *(const struct _Bit_iterator &) this>>>;


;; Function std::_Bit_iterator::reference std::_Bit_iterator::operator*() const (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = TARGET_EXPR <D.27859, <<< Unknown tree: aggr_init_expr
  6
  __comp_ctor 
  D.27859
  (struct _Bit_reference *) <<< Unknown tree: void_cst >>>
  (_Bit_type *) ((const struct _Bit_iterator *) this)->D.27794._M_p
  1 << (unsigned int) ((const struct _Bit_iterator *) this)->D.27794._M_offset >>>>;, D.27859>>;


;; Function std::_Bit_iterator::iterator& std::_Bit_iterator::operator++() (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  std::_Bit_iterator_base::_M_bump_up (&((struct _Bit_iterator *) this)->D.27794) >>>>>;
return <retval> = (struct iterator &) this;


;; Function std::_Bit_iterator::iterator std::_Bit_iterator::operator++(int) (null)
;; enabled by -tree-original


{
  struct iterator __tmp = *(const struct _Bit_iterator &) this;

    struct iterator __tmp = *(const struct _Bit_iterator &) this;
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Bit_iterator_base::_M_bump_up (&((struct _Bit_iterator *) this)->D.27794) >>>>>;
  <<cleanup_point return <retval> = TARGET_EXPR <D.27873, __tmp>>>;
}


;; Function std::_Bit_iterator::iterator& std::_Bit_iterator::operator--() (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  std::_Bit_iterator_base::_M_bump_down (&((struct _Bit_iterator *) this)->D.27794) >>>>>;
return <retval> = (struct iterator &) this;


;; Function std::_Bit_iterator::iterator std::_Bit_iterator::operator--(int) (null)
;; enabled by -tree-original


{
  struct iterator __tmp = *(const struct _Bit_iterator &) this;

    struct iterator __tmp = *(const struct _Bit_iterator &) this;
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Bit_iterator_base::_M_bump_down (&((struct _Bit_iterator *) this)->D.27794) >>>>>;
  <<cleanup_point return <retval> = TARGET_EXPR <D.27878, __tmp>>>;
}


;; Function std::_Bit_iterator::iterator& std::_Bit_iterator::operator+=(std::iterator<std::random_access_iterator_tag, bool>::difference_type) (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  std::_Bit_iterator_base::_M_incr (&((struct _Bit_iterator *) this)->D.27794, __i) >>>>>;
return <retval> = (struct iterator &) this;


;; Function std::_Bit_iterator::iterator& std::_Bit_iterator::operator-=(std::iterator<std::random_access_iterator_tag, bool>::difference_type) (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void) std::_Bit_iterator::operator+= ((struct _Bit_iterator *) this, -NON_LVALUE_EXPR <__i>) >>>>>;
return <retval> = (struct iterator &) this;


;; Function std::_Bit_iterator::iterator std::_Bit_iterator::operator+(std::iterator<std::random_access_iterator_tag, bool>::difference_type) const (null)
;; enabled by -tree-original


{
  struct iterator __tmp = *(const struct _Bit_iterator &) this;

    struct iterator __tmp = *(const struct _Bit_iterator &) this;
  <<cleanup_point return <retval> = TARGET_EXPR <D.27884, *(const struct _Bit_iterator &) std::_Bit_iterator::operator+= (&__tmp, __i)>>>;
}


;; Function std::_Bit_iterator::iterator std::_Bit_iterator::operator-(std::iterator<std::random_access_iterator_tag, bool>::difference_type) const (null)
;; enabled by -tree-original


{
  struct iterator __tmp = *(const struct _Bit_iterator &) this;

    struct iterator __tmp = *(const struct _Bit_iterator &) this;
  <<cleanup_point return <retval> = TARGET_EXPR <D.27888, *(const struct _Bit_iterator &) std::_Bit_iterator::operator-= (&__tmp, __i)>>>;
}


;; Function std::_Bit_iterator::reference std::_Bit_iterator::operator[](std::iterator<std::random_access_iterator_tag, bool>::difference_type) const (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = TARGET_EXPR <D.27891, std::_Bit_iterator::operator* (&TARGET_EXPR <D.27890, std::_Bit_iterator::operator+ ((const struct _Bit_iterator *) this, __i)>)>>>;


;; Function std::_Bit_iterator std::operator+(std::ptrdiff_t, const std::_Bit_iterator&) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = TARGET_EXPR <D.27896, std::_Bit_iterator::operator+ ((const struct _Bit_iterator *) __x, __n)>>>;


;; Function std::_Bit_const_iterator::_Bit_const_iterator() (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  *(struct 
  {
    struct 
    {
      _Bit_type * _M_p;
      unsigned int _M_offset;
    } D.27960;
  } &) this = {CLOBBER} >>>>>;
{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Bit_iterator_base::_Bit_iterator_base (&((struct _Bit_const_iterator *) this)->D.27959, 0B, 0) >>>>>;
}


;; Function std::_Bit_const_iterator::_Bit_const_iterator(std::_Bit_type*, unsigned int) (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  *(struct 
  {
    struct 
    {
      _Bit_type * _M_p;
      unsigned int _M_offset;
    } D.27960;
  } &) this = {CLOBBER} >>>>>;
{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Bit_iterator_base::_Bit_iterator_base (&((struct _Bit_const_iterator *) this)->D.27959, __x, __y) >>>>>;
}


;; Function std::_Bit_const_iterator::_Bit_const_iterator(const std::_Bit_iterator&) (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  *(struct 
  {
    struct 
    {
      _Bit_type * _M_p;
      unsigned int _M_offset;
    } D.27960;
  } &) this = {CLOBBER} >>>>>;
{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Bit_iterator_base::_Bit_iterator_base (&((struct _Bit_const_iterator *) this)->D.27959, (_Bit_type *) ((const struct _Bit_iterator *) __x)->D.27794._M_p, (unsigned int) ((const struct _Bit_iterator *) __x)->D.27794._M_offset) >>>>>;
}


;; Function std::_Bit_iterator std::_Bit_const_iterator::_M_const_cast() const (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = TARGET_EXPR <D.27971, <<< Unknown tree: aggr_init_expr
  6
  __comp_ctor 
  D.27971
  (struct _Bit_iterator *) <<< Unknown tree: void_cst >>>
  (_Bit_type *) ((const struct _Bit_const_iterator *) this)->D.27959._M_p
  (unsigned int) ((const struct _Bit_const_iterator *) this)->D.27959._M_offset >>>>;, D.27971>>;


;; Function std::_Bit_const_iterator::const_reference std::_Bit_const_iterator::operator*() const (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = std::_Bit_reference::operator bool (&TARGET_EXPR <D.27973, <<< Unknown tree: aggr_init_expr
  6
  __comp_ctor 
  D.27973
  (struct _Bit_reference *) <<< Unknown tree: void_cst >>>
  (_Bit_type *) ((const struct _Bit_const_iterator *) this)->D.27959._M_p
  1 << (unsigned int) ((const struct _Bit_const_iterator *) this)->D.27959._M_offset >>>>)>>;


;; Function std::_Bit_const_iterator::const_iterator& std::_Bit_const_iterator::operator++() (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  std::_Bit_iterator_base::_M_bump_up (&((struct _Bit_const_iterator *) this)->D.27959) >>>>>;
return <retval> = (struct const_iterator &) this;


;; Function std::_Bit_const_iterator::const_iterator std::_Bit_const_iterator::operator++(int) (null)
;; enabled by -tree-original


{
  struct const_iterator __tmp = *(const struct _Bit_const_iterator &) this;

    struct const_iterator __tmp = *(const struct _Bit_const_iterator &) this;
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Bit_iterator_base::_M_bump_up (&((struct _Bit_const_iterator *) this)->D.27959) >>>>>;
  <<cleanup_point return <retval> = TARGET_EXPR <D.28005, __tmp>>>;
}


;; Function std::_Bit_const_iterator::const_iterator& std::_Bit_const_iterator::operator--() (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  std::_Bit_iterator_base::_M_bump_down (&((struct _Bit_const_iterator *) this)->D.27959) >>>>>;
return <retval> = (struct const_iterator &) this;


;; Function std::_Bit_const_iterator::const_iterator std::_Bit_const_iterator::operator--(int) (null)
;; enabled by -tree-original


{
  struct const_iterator __tmp = *(const struct _Bit_const_iterator &) this;

    struct const_iterator __tmp = *(const struct _Bit_const_iterator &) this;
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Bit_iterator_base::_M_bump_down (&((struct _Bit_const_iterator *) this)->D.27959) >>>>>;
  <<cleanup_point return <retval> = TARGET_EXPR <D.28010, __tmp>>>;
}


;; Function std::_Bit_const_iterator::const_iterator& std::_Bit_const_iterator::operator+=(std::iterator<std::random_access_iterator_tag, bool>::difference_type) (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  std::_Bit_iterator_base::_M_incr (&((struct _Bit_const_iterator *) this)->D.27959, __i) >>>>>;
return <retval> = (struct const_iterator &) this;


;; Function std::_Bit_const_iterator::const_iterator& std::_Bit_const_iterator::operator-=(std::iterator<std::random_access_iterator_tag, bool>::difference_type) (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void) std::_Bit_const_iterator::operator+= ((struct _Bit_const_iterator *) this, -NON_LVALUE_EXPR <__i>) >>>>>;
return <retval> = (struct const_iterator &) this;


;; Function std::_Bit_const_iterator::const_iterator std::_Bit_const_iterator::operator+(std::iterator<std::random_access_iterator_tag, bool>::difference_type) const (null)
;; enabled by -tree-original


{
  struct const_iterator __tmp = *(const struct _Bit_const_iterator &) this;

    struct const_iterator __tmp = *(const struct _Bit_const_iterator &) this;
  <<cleanup_point return <retval> = TARGET_EXPR <D.28016, *(const struct _Bit_const_iterator &) std::_Bit_const_iterator::operator+= (&__tmp, __i)>>>;
}


;; Function std::_Bit_const_iterator::const_iterator std::_Bit_const_iterator::operator-(std::iterator<std::random_access_iterator_tag, bool>::difference_type) const (null)
;; enabled by -tree-original


{
  struct const_iterator __tmp = *(const struct _Bit_const_iterator &) this;

    struct const_iterator __tmp = *(const struct _Bit_const_iterator &) this;
  <<cleanup_point return <retval> = TARGET_EXPR <D.28020, *(const struct _Bit_const_iterator &) std::_Bit_const_iterator::operator-= (&__tmp, __i)>>>;
}


;; Function std::_Bit_const_iterator::const_reference std::_Bit_const_iterator::operator[](std::iterator<std::random_access_iterator_tag, bool>::difference_type) const (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = std::_Bit_const_iterator::operator* (&TARGET_EXPR <D.28022, std::_Bit_const_iterator::operator+ ((const struct _Bit_const_iterator *) this, __i)>)>>;


;; Function std::_Bit_const_iterator std::operator+(std::ptrdiff_t, const std::_Bit_const_iterator&) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = TARGET_EXPR <D.28027, std::_Bit_const_iterator::operator+ ((const struct _Bit_const_iterator *) __x, __n)>>>;


;; Function void std::__fill_bvector(std::_Bit_iterator, std::_Bit_iterator, bool) (null)
;; enabled by -tree-original


while (1)
  {
    if (<<cleanup_point std::_Bit_iterator_base::operator!= (&__first.D.27794, (const struct _Bit_iterator_base &) &__last.D.27794)>>) (void) 0; else goto <D.28034>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) std::_Bit_reference::operator= (&TARGET_EXPR <D.28033, std::_Bit_iterator::operator* (&__first)>, (int) __x) >>>>>;
    <<cleanup_point (void) std::_Bit_iterator::operator++ (&__first)>>;
  }
<D.28034>:;


;; Function void std::fill(std::_Bit_iterator, std::_Bit_iterator, const bool&) (null)
;; enabled by -tree-original


if (__first.D.27794._M_p != __last.D.27794._M_p)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::fill<long unsigned int*, int> (__first.D.27794._M_p + 8, __last.D.27794._M_p, (const int &) &TARGET_EXPR <D.28045, (bool) *__x ? -1 : 0>) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__fill_bvector (TARGET_EXPR <D.28047, __first>, TARGET_EXPR <D.28046, <<< Unknown tree: aggr_init_expr
  6
  __comp_ctor 
  D.28046
  (struct _Bit_iterator *) <<< Unknown tree: void_cst >>>
  __first.D.27794._M_p + 8
  0 >>>>, (int) *__x) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__fill_bvector (TARGET_EXPR <D.28048, <<< Unknown tree: aggr_init_expr
  6
  __comp_ctor 
  D.28048
  (struct _Bit_iterator *) <<< Unknown tree: void_cst >>>
  __last.D.27794._M_p
  0 >>>>, TARGET_EXPR <D.28049, __last>, (int) *__x) >>>>>;
  }
else
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__fill_bvector (TARGET_EXPR <D.28050, __first>, TARGET_EXPR <D.28051, __last>, (int) *__x) >>>>>;
  }


;; Function size_t pbzip2::BZ2StreamScanner::getInBuffSize() const (null)
;; enabled by -tree-original


return <retval> = (size_t) ((long int) ((const struct BZ2StreamScanner *) this)->_inBuffEnd - (long int) ((const struct BZ2StreamScanner *) this)->_inBuff);


;; Function size_t pbzip2::BZ2StreamScanner::getInBuffCapacity() const (null)
;; enabled by -tree-original


return <retval> = (size_t) ((const struct BZ2StreamScanner *) this)->_inBuffCapacity;


;; Function const std::__cxx11::basic_string<unsigned char>& pbzip2::BZ2StreamScanner::getHeader() const (null)
;; enabled by -tree-original


return <retval> = (const struct basic_string &) &((const struct BZ2StreamScanner *) this)->_bz2Header;


;; Function size_t pbzip2::BZ2StreamScanner::getHeaderSize() const (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = std::__cxx11::basic_string<unsigned char>::size (&((const struct BZ2StreamScanner *) this)->_bz2Header)>>;


;; Function int pbzip2::BZ2StreamScanner::getErrState() const (null)
;; enabled by -tree-original


return <retval> = (int) ((const struct BZ2StreamScanner *) this)->_errState;


;; Function bool pbzip2::BZ2StreamScanner::failed() (null)
;; enabled by -tree-original


return <retval> = ((struct BZ2StreamScanner *) this)->_errState != 0;


;; Function bool pbzip2::BZ2StreamScanner::isBz2HeaderFound() const (null)
;; enabled by -tree-original


return <retval> = (bool) ((const struct BZ2StreamScanner *) this)->_bz2HeaderFound;


;; Function bool pbzip2::BZ2StreamScanner::getSearchStatus() const (null)
;; enabled by -tree-original


return <retval> = (bool) ((const struct BZ2StreamScanner *) this)->_searchStatus;


;; Function bool pbzip2::BZ2StreamScanner::eof() const (null)
;; enabled by -tree-original


return <retval> = (bool) ((const struct BZ2StreamScanner *) this)->_eof;


;; Function bool pbzip2::BZ2StreamScanner::isOutBuffFullEnough() const (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = (size_t) ((const struct BZ2StreamScanner *) this)->_outBuff.bufSize >= pbzip2::BZ2StreamScanner::getOutBuffCapacityLimit ((const struct BZ2StreamScanner *) this)>>;


;; Function pbzip2::BZ2StreamScanner::BZ2StreamScanner(const pbzip2::BZ2StreamScanner&) (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  *(struct 
  {
    int (*__vtbl_ptr_type) () * _vptr.BZ2StreamScanner;
    int _hInFile;
    bool _eof;
    struct basic_string _bz2Header;
    struct basic_string _bz2HeaderZero;
    bool _bz2HeaderFound;
    bool _searchStatus;
    CharType * _inBuff;
    CharType * _inBuffEnd;
    CharType * _inBuffCurrent;
    CharType * _inBuffSearchPtr;
    size_t _inBuffCapacity;
    struct outBuff _outBuff;
    size_t _outBuffCapacity;
    size_t _outBuffCapacityHint;
    size_t _outBuffCapacityLimit;
    unsigned int _errState;
    int _outSequenceNumber;
    int _streamNumber;
  } &) this = {CLOBBER} >>>>>;
{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct BZ2StreamScanner *) this)->_vptr.BZ2StreamScanner = &_ZTVN6pbzip216BZ2StreamScannerE + 16) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<unsigned char>::basic_string (&((struct BZ2StreamScanner *) this)->_bz2Header) >>>>>;
  try
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<unsigned char>::basic_string (&((struct BZ2StreamScanner *) this)->_bz2HeaderZero) >>>>>;
      try
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  outBuff::outBuff (&((struct BZ2StreamScanner *) this)->_outBuff, 0B, 0, 0, 0, 0, 1, 0B) >>>>>;
        }
      catch
        {
          std::__cxx11::basic_string<unsigned char>::~basic_string (&((struct BZ2StreamScanner *) this)->_bz2HeaderZero);
        }
    }
  catch
    {
      std::__cxx11::basic_string<unsigned char>::~basic_string (&((struct BZ2StreamScanner *) this)->_bz2Header);
    }
}


;; Function int pbzip2::BZ2StreamScanner::appendOutBuffData() (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = pbzip2::BZ2StreamScanner::appendOutBuffData ((struct BZ2StreamScanner *) this, pbzip2::BZ2StreamScanner::getInBuffSearchPtr ((struct BZ2StreamScanner *) this))>>;


;; Function pbzip2::BZ2StreamScanner::CharType* pbzip2::BZ2StreamScanner::getInBuffEnd() (null)
;; enabled by -tree-original


return <retval> = ((struct BZ2StreamScanner *) this)->_inBuffEnd;


;; Function pbzip2::BZ2StreamScanner::CharType* pbzip2::BZ2StreamScanner::getInBuffBegin() (null)
;; enabled by -tree-original


return <retval> = ((struct BZ2StreamScanner *) this)->_inBuff;


;; Function pbzip2::BZ2StreamScanner::CharType* pbzip2::BZ2StreamScanner::getInBuffCurrent() (null)
;; enabled by -tree-original


return <retval> = ((struct BZ2StreamScanner *) this)->_inBuffCurrent;


;; Function pbzip2::BZ2StreamScanner::CharType* pbzip2::BZ2StreamScanner::getInBuffSearchPtr() (null)
;; enabled by -tree-original


return <retval> = ((struct BZ2StreamScanner *) this)->_inBuffSearchPtr;


;; Function char* pbzip2::BZ2StreamScanner::getOutBuffEnd() (null)
;; enabled by -tree-original


return <retval> = ((struct BZ2StreamScanner *) this)->_outBuff.buf + (sizetype) ((struct BZ2StreamScanner *) this)->_outBuff.bufSize;


;; Function size_t pbzip2::BZ2StreamScanner::getUnsearchedCount() const (null)
;; enabled by -tree-original


return <retval> = (size_t) ((long int) ((const struct BZ2StreamScanner *) this)->_inBuffEnd - (long int) ((const struct BZ2StreamScanner *) this)->_inBuffSearchPtr);


;; Function size_t pbzip2::BZ2StreamScanner::getOutBuffCapacityLimit() const (null)
;; enabled by -tree-original


return <retval> = (size_t) ((const struct BZ2StreamScanner *) this)->_outBuffCapacityLimit;


;; Function pbzip2::ErrorContext::ErrorContext() (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  *(struct 
  {
    int _first_kernel_err_no;
    int _last_kernel_err_no;
  } &) this = {CLOBBER} >>>>>;
{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct ErrorContext *) this)->_first_kernel_err_no = 0) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct ErrorContext *) this)->_last_kernel_err_no = 0) >>>>>;
}


;; Function static constexpr bool std::numeric_limits<bool>::min() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr bool std::numeric_limits<bool>::max() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 1
   >>>;


;; Function static constexpr bool std::numeric_limits<bool>::lowest() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = 0>>
   >>>;


;; Function static constexpr bool std::numeric_limits<bool>::epsilon() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr bool std::numeric_limits<bool>::round_error() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr bool std::numeric_limits<bool>::infinity() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr bool std::numeric_limits<bool>::quiet_NaN() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr bool std::numeric_limits<bool>::signaling_NaN() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr bool std::numeric_limits<bool>::denorm_min() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr char std::numeric_limits<char>::min() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = -128
   >>>;


;; Function static constexpr char std::numeric_limits<char>::max() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 127
   >>>;


;; Function static constexpr char std::numeric_limits<char>::lowest() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = -128>>
   >>>;


;; Function static constexpr char std::numeric_limits<char>::epsilon() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr char std::numeric_limits<char>::round_error() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr char std::numeric_limits<char>::infinity() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr char std::numeric_limits<char>::quiet_NaN() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr char std::numeric_limits<char>::signaling_NaN() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr char std::numeric_limits<char>::denorm_min() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr signed char std::numeric_limits<signed char>::min() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = -128
   >>>;


;; Function static constexpr signed char std::numeric_limits<signed char>::max() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 127
   >>>;


;; Function static constexpr signed char std::numeric_limits<signed char>::lowest() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = -128>>
   >>>;


;; Function static constexpr signed char std::numeric_limits<signed char>::epsilon() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr signed char std::numeric_limits<signed char>::round_error() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr signed char std::numeric_limits<signed char>::infinity() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr signed char std::numeric_limits<signed char>::quiet_NaN() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr signed char std::numeric_limits<signed char>::signaling_NaN() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr signed char std::numeric_limits<signed char>::denorm_min() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr unsigned char std::numeric_limits<unsigned char>::min() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr unsigned char std::numeric_limits<unsigned char>::max() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 255
   >>>;


;; Function static constexpr unsigned char std::numeric_limits<unsigned char>::lowest() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = 0>>
   >>>;


;; Function static constexpr unsigned char std::numeric_limits<unsigned char>::epsilon() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr unsigned char std::numeric_limits<unsigned char>::round_error() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr unsigned char std::numeric_limits<unsigned char>::infinity() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr unsigned char std::numeric_limits<unsigned char>::quiet_NaN() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr unsigned char std::numeric_limits<unsigned char>::signaling_NaN() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr unsigned char std::numeric_limits<unsigned char>::denorm_min() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr wchar_t std::numeric_limits<wchar_t>::min() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = -2147483648
   >>>;


;; Function static constexpr wchar_t std::numeric_limits<wchar_t>::max() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 2147483647
   >>>;


;; Function static constexpr wchar_t std::numeric_limits<wchar_t>::lowest() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = -2147483648>>
   >>>;


;; Function static constexpr wchar_t std::numeric_limits<wchar_t>::epsilon() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr wchar_t std::numeric_limits<wchar_t>::round_error() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr wchar_t std::numeric_limits<wchar_t>::infinity() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr wchar_t std::numeric_limits<wchar_t>::quiet_NaN() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr wchar_t std::numeric_limits<wchar_t>::signaling_NaN() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr wchar_t std::numeric_limits<wchar_t>::denorm_min() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr char16_t std::numeric_limits<char16_t>::min() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr char16_t std::numeric_limits<char16_t>::max() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 65535
   >>>;


;; Function static constexpr char16_t std::numeric_limits<char16_t>::lowest() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = 0>>
   >>>;


;; Function static constexpr char16_t std::numeric_limits<char16_t>::epsilon() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr char16_t std::numeric_limits<char16_t>::round_error() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr char16_t std::numeric_limits<char16_t>::infinity() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr char16_t std::numeric_limits<char16_t>::quiet_NaN() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr char16_t std::numeric_limits<char16_t>::signaling_NaN() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr char16_t std::numeric_limits<char16_t>::denorm_min() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr char32_t std::numeric_limits<char32_t>::min() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr char32_t std::numeric_limits<char32_t>::max() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 4294967295
   >>>;


;; Function static constexpr char32_t std::numeric_limits<char32_t>::lowest() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = 0>>
   >>>;


;; Function static constexpr char32_t std::numeric_limits<char32_t>::epsilon() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr char32_t std::numeric_limits<char32_t>::round_error() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr char32_t std::numeric_limits<char32_t>::infinity() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr char32_t std::numeric_limits<char32_t>::quiet_NaN() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr char32_t std::numeric_limits<char32_t>::signaling_NaN() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr char32_t std::numeric_limits<char32_t>::denorm_min() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr short int std::numeric_limits<short int>::min() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = -32768
   >>>;


;; Function static constexpr short int std::numeric_limits<short int>::max() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 32767
   >>>;


;; Function static constexpr short int std::numeric_limits<short int>::lowest() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = -32768>>
   >>>;


;; Function static constexpr short int std::numeric_limits<short int>::epsilon() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr short int std::numeric_limits<short int>::round_error() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr short int std::numeric_limits<short int>::infinity() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr short int std::numeric_limits<short int>::quiet_NaN() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr short int std::numeric_limits<short int>::signaling_NaN() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr short int std::numeric_limits<short int>::denorm_min() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr short unsigned int std::numeric_limits<short unsigned int>::min() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr short unsigned int std::numeric_limits<short unsigned int>::max() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 65535
   >>>;


;; Function static constexpr short unsigned int std::numeric_limits<short unsigned int>::lowest() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = 0>>
   >>>;


;; Function static constexpr short unsigned int std::numeric_limits<short unsigned int>::epsilon() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr short unsigned int std::numeric_limits<short unsigned int>::round_error() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr short unsigned int std::numeric_limits<short unsigned int>::infinity() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr short unsigned int std::numeric_limits<short unsigned int>::quiet_NaN() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr short unsigned int std::numeric_limits<short unsigned int>::signaling_NaN() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr short unsigned int std::numeric_limits<short unsigned int>::denorm_min() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr int std::numeric_limits<int>::min() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = -2147483648
   >>>;


;; Function static constexpr int std::numeric_limits<int>::max() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 2147483647
   >>>;


;; Function static constexpr int std::numeric_limits<int>::lowest() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = -2147483648>>
   >>>;


;; Function static constexpr int std::numeric_limits<int>::epsilon() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr int std::numeric_limits<int>::round_error() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr int std::numeric_limits<int>::infinity() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr int std::numeric_limits<int>::quiet_NaN() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr int std::numeric_limits<int>::signaling_NaN() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr int std::numeric_limits<int>::denorm_min() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr unsigned int std::numeric_limits<unsigned int>::min() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr unsigned int std::numeric_limits<unsigned int>::max() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 4294967295
   >>>;


;; Function static constexpr unsigned int std::numeric_limits<unsigned int>::lowest() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = 0>>
   >>>;


;; Function static constexpr unsigned int std::numeric_limits<unsigned int>::epsilon() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr unsigned int std::numeric_limits<unsigned int>::round_error() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr unsigned int std::numeric_limits<unsigned int>::infinity() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr unsigned int std::numeric_limits<unsigned int>::quiet_NaN() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr unsigned int std::numeric_limits<unsigned int>::signaling_NaN() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr unsigned int std::numeric_limits<unsigned int>::denorm_min() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr long int std::numeric_limits<long int>::min() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = -9223372036854775808
   >>>;


;; Function static constexpr long int std::numeric_limits<long int>::max() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 9223372036854775807
   >>>;


;; Function static constexpr long int std::numeric_limits<long int>::lowest() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = -9223372036854775808>>
   >>>;


;; Function static constexpr long int std::numeric_limits<long int>::epsilon() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr long int std::numeric_limits<long int>::round_error() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr long int std::numeric_limits<long int>::infinity() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr long int std::numeric_limits<long int>::quiet_NaN() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr long int std::numeric_limits<long int>::signaling_NaN() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr long int std::numeric_limits<long int>::denorm_min() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr long unsigned int std::numeric_limits<long unsigned int>::min() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr long unsigned int std::numeric_limits<long unsigned int>::max() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 18446744073709551615
   >>>;


;; Function static constexpr long unsigned int std::numeric_limits<long unsigned int>::lowest() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = 0>>
   >>>;


;; Function static constexpr long unsigned int std::numeric_limits<long unsigned int>::epsilon() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr long unsigned int std::numeric_limits<long unsigned int>::round_error() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr long unsigned int std::numeric_limits<long unsigned int>::infinity() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr long unsigned int std::numeric_limits<long unsigned int>::quiet_NaN() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr long unsigned int std::numeric_limits<long unsigned int>::signaling_NaN() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr long unsigned int std::numeric_limits<long unsigned int>::denorm_min() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr long long int std::numeric_limits<long long int>::min() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = -9223372036854775808
   >>>;


;; Function static constexpr long long int std::numeric_limits<long long int>::max() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 9223372036854775807
   >>>;


;; Function static constexpr long long int std::numeric_limits<long long int>::lowest() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = -9223372036854775808>>
   >>>;


;; Function static constexpr long long int std::numeric_limits<long long int>::epsilon() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr long long int std::numeric_limits<long long int>::round_error() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr long long int std::numeric_limits<long long int>::infinity() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr long long int std::numeric_limits<long long int>::quiet_NaN() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr long long int std::numeric_limits<long long int>::signaling_NaN() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr long long int std::numeric_limits<long long int>::denorm_min() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr long long unsigned int std::numeric_limits<long long unsigned int>::min() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr long long unsigned int std::numeric_limits<long long unsigned int>::max() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 18446744073709551615
   >>>;


;; Function static constexpr long long unsigned int std::numeric_limits<long long unsigned int>::lowest() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = 0>>
   >>>;


;; Function static constexpr long long unsigned int std::numeric_limits<long long unsigned int>::epsilon() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr long long unsigned int std::numeric_limits<long long unsigned int>::round_error() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr long long unsigned int std::numeric_limits<long long unsigned int>::infinity() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr long long unsigned int std::numeric_limits<long long unsigned int>::quiet_NaN() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr long long unsigned int std::numeric_limits<long long unsigned int>::signaling_NaN() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr long long unsigned int std::numeric_limits<long long unsigned int>::denorm_min() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr __int128 std::numeric_limits<__int128>::min() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = -0x80000000000000000000000000000000
   >>>;


;; Function static constexpr __int128 std::numeric_limits<__int128>::max() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0x7fffffffffffffffffffffffffffffff
   >>>;


;; Function static constexpr __int128 std::numeric_limits<__int128>::epsilon() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr __int128 std::numeric_limits<__int128>::round_error() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr __int128 std::numeric_limits<__int128>::lowest() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = -0x80000000000000000000000000000000>>
   >>>;


;; Function static constexpr __int128 std::numeric_limits<__int128>::infinity() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr __int128 std::numeric_limits<__int128>::quiet_NaN() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr __int128 std::numeric_limits<__int128>::signaling_NaN() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr __int128 std::numeric_limits<__int128>::denorm_min() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr __int128 unsigned std::numeric_limits<__int128 unsigned>::min() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr __int128 unsigned std::numeric_limits<__int128 unsigned>::max() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0xffffffffffffffffffffffffffffffff
   >>>;


;; Function static constexpr __int128 unsigned std::numeric_limits<__int128 unsigned>::lowest() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = 0>>
   >>>;


;; Function static constexpr __int128 unsigned std::numeric_limits<__int128 unsigned>::epsilon() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr __int128 unsigned std::numeric_limits<__int128 unsigned>::round_error() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr __int128 unsigned std::numeric_limits<__int128 unsigned>::infinity() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr __int128 unsigned std::numeric_limits<__int128 unsigned>::quiet_NaN() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr __int128 unsigned std::numeric_limits<__int128 unsigned>::signaling_NaN() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr __int128 unsigned std::numeric_limits<__int128 unsigned>::denorm_min() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function static constexpr float std::numeric_limits<float>::min() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 1.17549435082228750796873653722224567781866555677208752151e-38
   >>>;


;; Function static constexpr float std::numeric_limits<float>::max() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 3.4028234663852885981170418348451692544e+38
   >>>;


;; Function static constexpr float std::numeric_limits<float>::lowest() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = -3.4028234663852885981170418348451692544e+38
   >>>;


;; Function static constexpr float std::numeric_limits<float>::epsilon() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 1.1920928955078125e-7
   >>>;


;; Function static constexpr float std::numeric_limits<float>::round_error() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 5.0e-1
   >>>;


;; Function static constexpr float std::numeric_limits<float>::infinity() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> =  Inf
   >>>;


;; Function static constexpr float std::numeric_limits<float>::quiet_NaN() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> =  Nan
   >>>;


;; Function static constexpr float std::numeric_limits<float>::signaling_NaN() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> =  Nan
   >>>;


;; Function static constexpr float std::numeric_limits<float>::denorm_min() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 1.40129846432481707092372958328991613128026194187651577176e-45
   >>>;


;; Function static constexpr double std::numeric_limits<double>::min() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 2.22507385850720138309023271733240406421921598046233183055e-308
   >>>;


;; Function static constexpr double std::numeric_limits<double>::max() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 1.79769313486231570814527423731704356798070567525844996599e+308
   >>>;


;; Function static constexpr double std::numeric_limits<double>::lowest() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = -1.79769313486231570814527423731704356798070567525844996599e+308
   >>>;


;; Function static constexpr double std::numeric_limits<double>::epsilon() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 2.220446049250313080847263336181640625e-16
   >>>;


;; Function static constexpr double std::numeric_limits<double>::round_error() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 5.0e-1
   >>>;


;; Function static constexpr double std::numeric_limits<double>::infinity() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> =  Inf
   >>>;


;; Function static constexpr double std::numeric_limits<double>::quiet_NaN() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> =  Nan
   >>>;


;; Function static constexpr double std::numeric_limits<double>::signaling_NaN() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> =  Nan
   >>>;


;; Function static constexpr double std::numeric_limits<double>::denorm_min() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 4.94065645841246544176568792868221372365059802614324764425e-324
   >>>;


;; Function static constexpr long double std::numeric_limits<long double>::min() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 3.36210314311209350626267781732175260259807934484647124011e-4932
   >>>;


;; Function static constexpr long double std::numeric_limits<long double>::max() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 1.18973149535723176502126385303097020516906332229462420044e+4932
   >>>;


;; Function static constexpr long double std::numeric_limits<long double>::lowest() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = -1.18973149535723176502126385303097020516906332229462420044e+4932
   >>>;


;; Function static constexpr long double std::numeric_limits<long double>::epsilon() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 1.08420217248550443400745280086994171142578125e-19
   >>>;


;; Function static constexpr long double std::numeric_limits<long double>::round_error() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 5.0e-1
   >>>;


;; Function static constexpr long double std::numeric_limits<long double>::infinity() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> =  Inf
   >>>;


;; Function static constexpr long double std::numeric_limits<long double>::quiet_NaN() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> =  Nan
   >>>;


;; Function static constexpr long double std::numeric_limits<long double>::signaling_NaN() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> =  Nan
   >>>;


;; Function static constexpr long double std::numeric_limits<long double>::denorm_min() (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 3.64519953188247460252840593361941981639905081569356334372e-4951
   >>>;


;; Function int stat(const char*, stat*) (*stat64)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  <<cleanup_point return <retval> = __xstat (1, __path, __statbuf)>>
   >>>;


;; Function int lstat(const char*, stat*) (*lstat64)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  <<cleanup_point return <retval> = __lxstat (1, __path, __statbuf)>>
   >>>;


;; Function int fstat(int, stat*) (*fstat64)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  <<cleanup_point return <retval> = __fxstat (1, __fd, __statbuf)>>
   >>>;


;; Function int fstatat(int, const char*, stat*, int) (*fstatat64)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  <<cleanup_point return <retval> = __fxstatat (1, __fd, __filename, __statbuf, __flag)>>
   >>>;


;; Function int mknod(const char*, __mode_t, __dev_t) (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  <<cleanup_point return <retval> = __xmknod (0, __path, __mode, &__dev)>>
   >>>;


;; Function int mknodat(int, const char*, __mode_t, __dev_t) (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  <<cleanup_point return <retval> = __xmknodat (0, __fd, __path, __mode, &__dev)>>
   >>>;


;; Function int stat64(const char*, stat64*) (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  <<cleanup_point return <retval> = __xstat64 (1, __path, __statbuf)>>
   >>>;


;; Function int lstat64(const char*, stat64*) (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  <<cleanup_point return <retval> = __lxstat64 (1, __path, __statbuf)>>
   >>>;


;; Function int fstat64(int, stat64*) (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  <<cleanup_point return <retval> = __fxstat64 (1, __fd, __statbuf)>>
   >>>;


;; Function int fstatat64(int, const char*, stat64*, int) (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  <<cleanup_point return <retval> = __fxstatat64 (1, __fd, __filename, __statbuf, __flag)>>
   >>>;


;; Function int open(const char*, int, ...) (*open64)
;; enabled by -tree-original


if (__builtin_va_arg_pack_len () > 1)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  __open_too_many_args () >>>>>;
  }
if (__builtin_constant_p (__oflag) != 0)
  {
    if (((__oflag & 64) != 0 || (__oflag & 4259840) == 4259840) && __builtin_va_arg_pack_len () <= 0)
      {
        <<cleanup_point <<< Unknown tree: expr_stmt
  __open_missing_mode () >>>>>;
        <<cleanup_point return <retval> = __open_2 (__path, __oflag)>>;
      }
    <<cleanup_point return <retval> = __open_alias (__path, __oflag, __builtin_va_arg_pack ())>>;
  }
if (__builtin_va_arg_pack_len () <= 0)
  {
    <<cleanup_point return <retval> = __open_2 (__path, __oflag)>>;
  }
<<cleanup_point return <retval> = __open_alias (__path, __oflag, __builtin_va_arg_pack ())>>;


;; Function int open64(const char*, int, ...) (null)
;; enabled by -tree-original


if (__builtin_va_arg_pack_len () > 1)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  __open64_too_many_args () >>>>>;
  }
if (__builtin_constant_p (__oflag) != 0)
  {
    if (((__oflag & 64) != 0 || (__oflag & 4259840) == 4259840) && __builtin_va_arg_pack_len () <= 0)
      {
        <<cleanup_point <<< Unknown tree: expr_stmt
  __open64_missing_mode () >>>>>;
        <<cleanup_point return <retval> = __open64_2 (__path, __oflag)>>;
      }
    <<cleanup_point return <retval> = __open64_alias (__path, __oflag, __builtin_va_arg_pack ())>>;
  }
if (__builtin_va_arg_pack_len () <= 0)
  {
    <<cleanup_point return <retval> = __open64_2 (__path, __oflag)>>;
  }
<<cleanup_point return <retval> = __open64_alias (__path, __oflag, __builtin_va_arg_pack ())>>;


;; Function int openat(int, const char*, int, ...) (*openat64)
;; enabled by -tree-original


if (__builtin_va_arg_pack_len () > 1)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  __openat_too_many_args () >>>>>;
  }
if (__builtin_constant_p (__oflag) != 0)
  {
    if (((__oflag & 64) != 0 || (__oflag & 4259840) == 4259840) && __builtin_va_arg_pack_len () <= 0)
      {
        <<cleanup_point <<< Unknown tree: expr_stmt
  __openat_missing_mode () >>>>>;
        <<cleanup_point return <retval> = __openat_2 (__fd, __path, __oflag)>>;
      }
    <<cleanup_point return <retval> = __openat_alias (__fd, __path, __oflag, __builtin_va_arg_pack ())>>;
  }
if (__builtin_va_arg_pack_len () <= 0)
  {
    <<cleanup_point return <retval> = __openat_2 (__fd, __path, __oflag)>>;
  }
<<cleanup_point return <retval> = __openat_alias (__fd, __path, __oflag, __builtin_va_arg_pack ())>>;


;; Function int openat64(int, const char*, int, ...) (null)
;; enabled by -tree-original


if (__builtin_va_arg_pack_len () > 1)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  __openat64_too_many_args () >>>>>;
  }
if (__builtin_constant_p (__oflag) != 0)
  {
    if (((__oflag & 64) != 0 || (__oflag & 4259840) == 4259840) && __builtin_va_arg_pack_len () <= 0)
      {
        <<cleanup_point <<< Unknown tree: expr_stmt
  __openat64_missing_mode () >>>>>;
        <<cleanup_point return <retval> = __openat64_2 (__fd, __path, __oflag)>>;
      }
    <<cleanup_point return <retval> = __openat64_alias (__fd, __path, __oflag, __builtin_va_arg_pack ())>>;
  }
if (__builtin_va_arg_pack_len () <= 0)
  {
    <<cleanup_point return <retval> = __openat64_2 (__fd, __path, __oflag)>>;
  }
<<cleanup_point return <retval> = __openat64_alias (__fd, __path, __oflag, __builtin_va_arg_pack ())>>;


;; Function void* memchr(void*, int, size_t) (*memchr)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  return <retval> = __builtin_memchr ((const void *) __s, __c, __n)
   >>>;


;; Function const void* memchr(const void*, int, size_t) (*memchr)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  return <retval> = (const void *) __builtin_memchr (__s, __c, __n)
   >>>;


;; Function char* strchr(char*, int) (*strchr)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  return <retval> = __builtin_strchr ((const char *) __s, __c)
   >>>;


;; Function const char* strchr(const char*, int) (*strchr)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  return <retval> = (const char *) __builtin_strchr (__s, __c)
   >>>;


;; Function char* strrchr(char*, int) (*strrchr)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  return <retval> = __builtin_strrchr ((const char *) __s, __c)
   >>>;


;; Function const char* strrchr(const char*, int) (*strrchr)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  return <retval> = (const char *) __builtin_strrchr (__s, __c)
   >>>;


;; Function char* strpbrk(char*, const char*) (*strpbrk)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  return <retval> = __builtin_strpbrk ((const char *) __s, __accept)
   >>>;


;; Function const char* strpbrk(const char*, const char*) (*strpbrk)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  return <retval> = (const char *) __builtin_strpbrk (__s, __accept)
   >>>;


;; Function char* strstr(char*, const char*) (*strstr)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  return <retval> = __builtin_strstr ((const char *) __haystack, __needle)
   >>>;


;; Function const char* strstr(const char*, const char*) (*strstr)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  return <retval> = (const char *) __builtin_strstr (__haystack, __needle)
   >>>;


;; Function char* index(char*, int) (*index)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  return <retval> = __builtin_index ((const char *) __s, __c)
   >>>;


;; Function const char* index(const char*, int) (*index)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  return <retval> = (const char *) __builtin_index (__s, __c)
   >>>;


;; Function char* rindex(char*, int) (*rindex)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  return <retval> = __builtin_rindex ((const char *) __s, __c)
   >>>;


;; Function const char* rindex(const char*, int) (*rindex)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  return <retval> = (const char *) __builtin_rindex (__s, __c)
   >>>;


;; Function void bcopy(const void*, void*, size_t) (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) __builtin___memmove_chk (__dest, __src, __len, __builtin_object_size ((const void *) __dest, 0)) >>>>>
   >>>;


;; Function void bzero(void*, size_t) (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) __builtin___memset_chk (__dest, 0, __len, __builtin_object_size ((const void *) __dest, 0)) >>>>>
   >>>;


;; Function void* memcpy(void*, const void*, size_t) (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  <<cleanup_point return <retval> = __builtin___memcpy_chk (__dest, __src, __len, __builtin_object_size ((const void *) __dest, 0))>>
   >>>;


;; Function void* memmove(void*, const void*, size_t) (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  <<cleanup_point return <retval> = __builtin___memmove_chk (__dest, __src, __len, __builtin_object_size ((const void *) __dest, 0))>>
   >>>;


;; Function void* mempcpy(void*, const void*, size_t) (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  <<cleanup_point return <retval> = __builtin___mempcpy_chk (__dest, __src, __len, __builtin_object_size ((const void *) __dest, 0))>>
   >>>;


;; Function void* memset(void*, int, size_t) (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  <<cleanup_point return <retval> = __builtin___memset_chk (__dest, __ch, __len, __builtin_object_size ((const void *) __dest, 0))>>
   >>>;


;; Function void explicit_bzero(void*, size_t) (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  <<cleanup_point <<< Unknown tree: expr_stmt
  __explicit_bzero_chk (__dest, __len, __builtin_object_size ((const void *) __dest, 0)) >>>>>
   >>>;


;; Function char* strcpy(char*, const char*) (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  <<cleanup_point return <retval> = __builtin___strcpy_chk (__dest, __src, __builtin_object_size ((const void *) __dest, 1))>>
   >>>;


;; Function char* stpcpy(char*, const char*) (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  <<cleanup_point return <retval> = __builtin___stpcpy_chk (__dest, __src, __builtin_object_size ((const void *) __dest, 1))>>
   >>>;


;; Function char* strncpy(char*, const char*, size_t) (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  <<cleanup_point return <retval> = __builtin___strncpy_chk (__dest, __src, __len, __builtin_object_size ((const void *) __dest, 1))>>
   >>>;


;; Function char* stpncpy(char*, const char*, size_t) (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  if (__builtin_object_size ((const void *) __dest, 1) != 18446744073709551615 && (__builtin_constant_p (__n) == 0 || __builtin_object_size ((const void *) __dest, 1) < __n))
    {
      <<cleanup_point return <retval> = __stpncpy_chk (__dest, __src, __n, __builtin_object_size ((const void *) __dest, 1))>>;
    }
  <<cleanup_point return <retval> = __stpncpy_alias (__dest, __src, __n)>>;
   >>>;


;; Function char* strcat(char*, const char*) (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  <<cleanup_point return <retval> = __builtin___strcat_chk (__dest, __src, __builtin_object_size ((const void *) __dest, 1))>>
   >>>;


;; Function char* strncat(char*, const char*, size_t) (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  <<cleanup_point return <retval> = __builtin___strncat_chk (__dest, __src, __len, __builtin_object_size ((const void *) __dest, 1))>>
   >>>;


;; Function void safe_mutex_lock(pthread_mutex_t*) (null)
;; enabled by -tree-original


{
  int ret;

    int ret;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (ret = pthread_mutex_lock (mutex)) >>>>>;
  if (ret != 0)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "pthread_mutex_lock error [%d]! Aborting immediately!\n", ret) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  cleanupAndQuit (-5) >>>>>;
    }
}


;; Function void safe_mutex_unlock(pthread_mutex_t*) (null)
;; enabled by -tree-original


{
  int ret;

    int ret;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (ret = pthread_mutex_unlock (mutex)) >>>>>;
  if (ret != 0)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "pthread_mutex_unlock error [%d]! Aborting immediately!\n", ret) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  cleanupAndQuit (-6) >>>>>;
    }
}


;; Function void safe_cond_signal(pthread_cond_t*) (null)
;; enabled by -tree-original


{
  int ret;

    int ret;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (ret = pthread_cond_signal (cond)) >>>>>;
  if (ret != 0)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "pthread_cond_signal error [%d]! Aborting immediately!\n", ret) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  cleanupAndQuit (-7) >>>>>;
    }
}


;; Function void safe_cond_broadcast(pthread_cond_t*) (null)
;; enabled by -tree-original


{
  int ret;

    int ret;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (ret = pthread_cond_broadcast (cond)) >>>>>;
  if (ret != 0)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "pthread_cond_broadcast error [%d]! Aborting immediately!\n", ret) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  cleanupAndQuit (-7) >>>>>;
    }
}


;; Function void safe_cond_wait(pthread_cond_t*, pthread_mutex_t*) (null)
;; enabled by -tree-original


{
  int ret;

    int ret;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (ret = pthread_cond_wait (cond, mutex)) >>>>>;
  if (ret != 0)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "pthread_cond_wait error [%d]! Aborting immediately!\n", ret) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) pthread_mutex_unlock (mutex) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  cleanupAndQuit (-8) >>>>>;
    }
}


;; Function int safe_cond_timed_wait(pthread_cond_t*, pthread_mutex_t*, int, const char*) (null)
;; enabled by -tree-original


{
  struct timespec waitTimer;
  struct timeval tv;
  struct timezone tz;
  int pret;

    struct timespec waitTimer;
    struct timeval tv;
    struct timezone tz;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) gettimeofday (&tv, (void *) &tz) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (waitTimer.tv_sec = tv.tv_sec + (__time_t) seconds) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (waitTimer.tv_nsec = tv.tv_usec * 1000) >>>>>;
    int pret;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (pret = pthread_cond_timedwait (cond, mutex, (const struct timespec *) &waitTimer)) >>>>>;
  if ((pret != 0 && pret != 4) && (pret != 16 && pret != 110))
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  pbzip2::ErrorContext::saveError (pbzip2::ErrorContext::getInstance ()) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) pthread_mutex_unlock (mutex) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) handle_error (1, 1, (const char *) "pbzip2: *ERROR: %s:  pthread_cond_timedwait() call invalid [pret=%d].  This machine\n         does not have compatible pthreads library.  Aborting.\n", caller, pret) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  cleanupAndQuit (-9) >>>>>;
    }
  return <retval> = 0;
}


;; Function ssize_t do_write(int, const void*, size_t) (null)
;; enabled by -tree-original


{
  ssize_t bytesRemaining = (ssize_t) count;
  ssize_t nbytes = 0;
  const char * pbuf = (const char *) buf;

    ssize_t bytesRemaining = (ssize_t) count;
  <<cleanup_point   ssize_t nbytes = 0;>>;
    const char * pbuf = (const char *) buf;
  while (1)
    {
      if (<<cleanup_point bytesRemaining > 0 && (nbytes = write (fd, (const void *) pbuf, (size_t) bytesRemaining)) > 0>>) (void) 0; else goto <D.39200>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (bytesRemaining = bytesRemaining - nbytes) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (pbuf = pbuf + (sizetype) nbytes) >>>>>;
    }
  <D.39200>:;
  if (nbytes < 0)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  pbzip2::ErrorContext::saveError (pbzip2::ErrorContext::getInstance ()) >>>>>;
      return <retval> = nbytes;
    }
  return <retval> = (ssize_t) (count - (long unsigned int) bytesRemaining);
}


;; Function ssize_t do_read(int, void*, size_t) (null)
;; enabled by -tree-original


{
  ssize_t bytesRemaining = (ssize_t) count;
  ssize_t nbytes = 0;
  char * pbuf = (char *) buf;

    ssize_t bytesRemaining = (ssize_t) count;
  <<cleanup_point   ssize_t nbytes = 0;>>;
    char * pbuf = (char *) buf;
  while (1)
    {
      if (<<cleanup_point bytesRemaining > 0 && (nbytes = read (fd, (void *) pbuf, (size_t) bytesRemaining)) > 0>>) (void) 0; else goto <D.39210>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (bytesRemaining = bytesRemaining - nbytes) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (pbuf = pbuf + (sizetype) nbytes) >>>>>;
    }
  <D.39210>:;
  if (nbytes < 0)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  pbzip2::ErrorContext::saveError (pbzip2::ErrorContext::getInstance ()) >>>>>;
      return <retval> = nbytes;
    }
  return <retval> = (ssize_t) (count - (long unsigned int) bytesRemaining);
}


;; Function int safe_open_output(const char*) (null)
;; enabled by -tree-original


{
  int ret;

    int ret;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (ret = open (path, 193, 384)) >>>>>;
  if (ret == -1)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  pbzip2::ErrorContext::saveError (pbzip2::ErrorContext::getInstance ()) >>>>>;
    }
  return <retval> = ret;
}


;; Function FILE* safe_fopen_output(const char*, const char*) (null)
;; enabled by -tree-original


{
  int fh;
  struct FILE * fp;

    int fh;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (fh = safe_open_output (path)) >>>>>;
  if (fh == -1)
    {
      return <retval> = 0B;
    }
    struct FILE * fp;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (fp = fdopen (fh, mode)) >>>>>;
  if (fp == 0B)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  pbzip2::ErrorContext::saveError (pbzip2::ErrorContext::getInstance ()) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) close (fh) >>>>>;
    }
  return <retval> = fp;
}


;; Function int do_close(int) (null)
;; enabled by -tree-original


{
  int ret;

    int ret;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (ret = close (fd)) >>>>>;
  if (ret == -1)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  pbzip2::ErrorContext::saveError (pbzip2::ErrorContext::getInstance ()) >>>>>;
    }
  return <retval> = ret;
}


;; Function int do_fclose(FILE*) (null)
;; enabled by -tree-original


{
  int ret;

    int ret;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (ret = fclose (file)) >>>>>;
  if (ret == -1)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  pbzip2::ErrorContext::saveError (pbzip2::ErrorContext::getInstance ()) >>>>>;
    }
  return <retval> = ret;
}


;; Function int do_fflush(FILE*) (null)
;; enabled by -tree-original


{
  int ret;

    int ret;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (ret = fflush (file)) >>>>>;
  if (ret == -1)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  pbzip2::ErrorContext::saveError (pbzip2::ErrorContext::getInstance ()) >>>>>;
    }
  return <retval> = ret;
}


;; Function int verbose_fclose(FILE*, const char*) (null)
;; enabled by -tree-original


{
  int ret;

    int ret;
  if (<<cleanup_point (ret = fclose (file)) == -1>>)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  pbzip2::ErrorContext::syncPrintErrnoMsg (stderr, *__errno_location ()) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "pbzip2: *ERROR: Failed to close file [%s]!\n", fileName) >>>>>;
    }
  return <retval> = ret;
}


;; Function int do_remove(const char*) (null)
;; enabled by -tree-original


{
  int ret;

    int ret;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (ret = remove (pathname)) >>>>>;
  if (ret == -1)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  pbzip2::ErrorContext::saveError (pbzip2::ErrorContext::getInstance ()) >>>>>;
    }
  return <retval> = ret;
}


;; Function bool check_file_exists(const char*) (null)
;; enabled by -tree-original


{
  int hOutfile;

    int hOutfile;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (hOutfile = open (filename, 0)) >>>>>;
  if (hOutfile == -1)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  pbzip2::ErrorContext::saveError (pbzip2::ErrorContext::getInstance ()) >>>>>;
      return <retval> = 0;
    }
  else
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) close (hOutfile) >>>>>;
      return <retval> = 1;
    }
}


;; Function int syncGetProducerDone() (null)
;; enabled by -tree-original


{
  int ret;

    int ret;
  <<cleanup_point <<< Unknown tree: expr_stmt
  safe_mutex_lock (ProducerDoneMutex) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (ret = producerDone) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  safe_mutex_unlock (ProducerDoneMutex) >>>>>;
  return <retval> = ret;
}


;; Function void syncSetProducerDone(int) (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  safe_mutex_lock (ProducerDoneMutex) >>>>>;
<<cleanup_point <<< Unknown tree: expr_stmt
  (void) (producerDone = newValue) >>>>>;
<<cleanup_point <<< Unknown tree: expr_stmt
  safe_mutex_unlock (ProducerDoneMutex) >>>>>;


;; Function int syncGetTerminateFlag() (null)
;; enabled by -tree-original


{
  int ret;

    int ret;
  <<cleanup_point <<< Unknown tree: expr_stmt
  safe_mutex_lock (&TerminateFlagMutex) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (ret = terminateFlag) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  safe_mutex_unlock (&TerminateFlagMutex) >>>>>;
  return <retval> = ret;
}


;; Function void syncSetTerminateFlag(int) (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  safe_mutex_lock (&TerminateFlagMutex) >>>>>;
<<cleanup_point <<< Unknown tree: expr_stmt
  (void) (terminateFlag = newValue) >>>>>;
if (terminateFlag != 0)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) pthread_cond_signal (&TerminateCond) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  safe_mutex_unlock (&TerminateFlagMutex) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  safe_mutex_lock (OutMutex) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) pthread_cond_broadcast (notTooMuchNumBuffered) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  safe_mutex_unlock (OutMutex) >>>>>;
    if (FifoQueue != 0B)
      {
        <<cleanup_point <<< Unknown tree: expr_stmt
  safe_mutex_lock (FifoQueue->mut) >>>>>;
        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) pthread_cond_broadcast (FifoQueue->notFull) >>>>>;
        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) pthread_cond_broadcast (FifoQueue->notEmpty) >>>>>;
        <<cleanup_point <<< Unknown tree: expr_stmt
  safe_mutex_unlock (FifoQueue->mut) >>>>>;
      }
  }
else
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  safe_mutex_unlock (&TerminateFlagMutex) >>>>>;
  }


;; Function void syncSetFinishedFlag(int) (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  safe_mutex_lock (&TerminateFlagMutex) >>>>>;
<<cleanup_point <<< Unknown tree: expr_stmt
  (void) (finishedFlag = newValue) >>>>>;
if (finishedFlag != 0)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) pthread_cond_signal (&TerminateCond) >>>>>;
  }
<<cleanup_point <<< Unknown tree: expr_stmt
  safe_mutex_unlock (&TerminateFlagMutex) >>>>>;


;; Function void syncSetLastGoodBlock(int, int) (null)
;; enabled by -tree-original


{
  bool changed = 0;

  <<cleanup_point   bool changed = 0;>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  safe_mutex_lock (OutMutex) >>>>>;
  if (LastGoodBlock == -1 || newValue < LastGoodBlock)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (LastGoodBlock = newValue) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (changed = 1) >>>>>;
    }
  if (MinErrorBlock == -1 || errBlock < MinErrorBlock)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (MinErrorBlock = errBlock) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (changed = 1) >>>>>;
    }
  if (changed)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  safe_cond_signal (&ErrStateChangeCond) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  safe_cond_signal (&OutBufferHeadNotEmpty) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) pthread_cond_broadcast (notTooMuchNumBuffered) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  safe_mutex_unlock (OutMutex) >>>>>;
      if (FifoQueue != 0B)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  safe_mutex_lock (FifoQueue->mut) >>>>>;
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) pthread_cond_broadcast (FifoQueue->notFull) >>>>>;
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) pthread_cond_broadcast (FifoQueue->notEmpty) >>>>>;
          <<cleanup_point <<< Unknown tree: expr_stmt
  safe_mutex_unlock (FifoQueue->mut) >>>>>;
        }
    }
  else
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  safe_mutex_unlock (OutMutex) >>>>>;
    }
}


;; Function int syncGetLastGoodBlock() (null)
;; enabled by -tree-original


{
  int ret;

    int ret;
  <<cleanup_point <<< Unknown tree: expr_stmt
  safe_mutex_lock (OutMutex) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (ret = LastGoodBlock) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  safe_mutex_unlock (OutMutex) >>>>>;
  return <retval> = ret;
}


;; Function int syncGetMinErrorBlock() (null)
;; enabled by -tree-original


{
  int ret;

    int ret;
  <<cleanup_point <<< Unknown tree: expr_stmt
  safe_mutex_lock (OutMutex) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (ret = MinErrorBlock) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  safe_mutex_unlock (OutMutex) >>>>>;
  return <retval> = ret;
}


;; Function bool isIgnoredTrailingGarbage() (null)
;; enabled by -tree-original


return <retval> = IgnoreTrailingGarbageFlag != 0;


;; Function int handle_error(ExitFlag, int, const char*, ...) (null)
;; enabled by -tree-original


{
  struct  args[1];

    struct  args[1];
  <<cleanup_point <<< Unknown tree: expr_stmt
  __builtin_va_start ((struct  *) &args, fmt) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) vfprintf (stderr, fmt, (struct  *) &args) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  pbzip2::ErrorContext::printErrorMessages (pbzip2::ErrorContext::getInstance (), stderr) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fflush (stderr) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  __builtin_va_end ((struct  *) &args) >>>>>;
  if (exitFlag == 2)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  syncSetTerminateFlag (1) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  abort () >>>>>;
    }
  if (exitFlag == 1)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  syncSetTerminateFlag (1) >>>>>;
    }
  return <retval> = exitCode;
}


;; Function int waitForPreviousBlock(int, int) (null)
;; enabled by -tree-original


while (1)
  {
    if (<<cleanup_point syncGetTerminateFlag () != 0>>)
      {
        return <retval> = -1;
      }
    <<cleanup_point <<< Unknown tree: expr_stmt
  safe_mutex_lock (OutMutex) >>>>>;
    if (MinErrorBlock != -1 && MinErrorBlock < errBlockNumber)
      {
        <<cleanup_point <<< Unknown tree: expr_stmt
  safe_mutex_unlock (OutMutex) >>>>>;
        return <retval> = 2;
      }
    if (errBlockNumber <= NextBlockToWrite)
      {
        <<cleanup_point <<< Unknown tree: expr_stmt
  safe_mutex_unlock (OutMutex) >>>>>;
        return <retval> = 0;
      }
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) safe_cond_timed_wait (&ErrStateChangeCond, OutMutex, 1, (const char *) "waitForPreviousBlock") >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  safe_mutex_unlock (OutMutex) >>>>>;
  }


;; Function int getLastGoodBlockBeforeErr(int, int) (null)
;; enabled by -tree-original


if (outSequenceNumber != -1)
  {
    return <retval> = errBlockNumber;
  }
else
  {
    return <retval> = errBlockNumber + -1;
  }


;; Function int issueDecompressError(int, const outBuff*, int, const bz_stream&, const char*, int) (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void) handle_error (1, exitCode, (const char *) "pbzip2: %s: ret=%d; block=%d; seq=%d; isLastInSeq=%d; avail_in=%d\n", errmsg, bzret, (int) fileData->blockNumber, outSequenceNumber, (int) fileData->isLastInSequence, (unsigned int) strm->avail_in) >>>>>;
return <retval> = exitCode;


;; Function int decompressErrCheckSingle(int, const outBuff*, int, const bz_stream&, const char*, bool) (null)
;; enabled by -tree-original


{
  int lastGoodBlock;

    int lastGoodBlock;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (lastGoodBlock = getLastGoodBlockBeforeErr ((int) fileData->blockNumber, outSequenceNumber)) >>>>>;
  {
    if (<<cleanup_point lastGoodBlock == -1 || !isIgnoredTrailingGarbage ()>>)
      {
        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) issueDecompressError (bzret, fileData, outSequenceNumber, strm, errmsg, -1) >>>>>;
        return <retval> = -1;
      }
    else
      {
        {
          int prevState;

          <<cleanup_point <<< Unknown tree: expr_stmt
  syncSetLastGoodBlock (lastGoodBlock, (int) fileData->blockNumber) >>>>>;
                    int prevState;
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (prevState = waitForPreviousBlock (lastGoodBlock, (int) fileData->blockNumber)) >>>>>;
          if (prevState == 0)
            {
              if (isTrailingGarbageErr)
                {
                  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "pbzip2: *WARNING: Trailing garbage after EOF ignored!\n") >>>>>;
                  return <retval> = 1;
                }
              else
                {
                  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) issueDecompressError (bzret, fileData, outSequenceNumber, strm, errmsg, -1) >>>>>;
                  return <retval> = -1;
                }
            }
          else
            {
              if (prevState == 2)
                {
                  return <retval> = 2;
                }
              else
                {
                  return <retval> = -1;
                }
            }
        }
      }
  }
}


;; Function bool hasTrailingGarbage(int, const outBuff*, const bz_stream&) (null)
;; enabled by -tree-original


return <retval> = bzret == 4 && (strm->avail_in != 0 || !(bool) fileData->isLastInSequence);


;; Function int decompressErrCheck(int, const outBuff*, int, const bz_stream&) (null)
;; enabled by -tree-original


if (<<cleanup_point hasTrailingGarbage (bzret, fileData, strm)>>)
  {
    <<cleanup_point return <retval> = decompressErrCheckSingle (bzret, fileData, outSequenceNumber, strm, (const char *) "*ERROR during BZ2_bzDecompress - trailing garbage", 1)>>;
  }
else
  {
    if (bzret != 4 && bzret != 0)
      {
        <<cleanup_point return <retval> = decompressErrCheckSingle (bzret, fileData, outSequenceNumber, strm, (const char *) "*ERROR during BZ2_bzDecompress - failure exit code", 0)>>;
      }
    else
      {
        if (strm->avail_in != 0)
          {
            <<cleanup_point return <retval> = decompressErrCheckSingle (bzret, fileData, outSequenceNumber, strm, (const char *) "*ERROR unconsumed in after BZ2_bzDecompress loop", 0)>>;
          }
        else
          {
            if (bzret != 4 && (bool) fileData->isLastInSequence)
              {
                <<cleanup_point return <retval> = decompressErrCheckSingle (bzret, fileData, outSequenceNumber, strm, (const char *) "*ERROR on decompress - last in segment reached before BZ_STREAM_END", 0)>>;
              }
          }
      }
  }
return <retval> = 0;


;; Function int initSignalMask() (null)
;; enabled by -tree-original


{
  int ret = 0;

  <<cleanup_point   int ret = 0;>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (ret = sigemptyset (&SignalMask)) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (ret = sigaddset (&SignalMask, 2) | ret) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (ret = sigaddset (&SignalMask, 15) | ret) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (ret = sigaddset (&SignalMask, 6) | ret) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (ret = sigaddset (&SignalMask, SIG_HANDLER_QUIT_SIGNAL) | ret) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (ret = sigaddset (&SignalMask, 1) | ret) >>>>>;
  if (ret == 0)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (ret = pthread_sigmask (0, (const struct __sigset_t *) &SignalMask, 0B)) >>>>>;
    }
  return <retval> = ret;
}


;; Function int initChildThreadAttributes() (null)
;; enabled by -tree-original


{
  int ret;

    int ret;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (ret = pthread_attr_init (&ChildThreadAttributes)) >>>>>;
  if (ret < 0)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "Can\'t initialize thread atrributes [err=%d]! Aborting...\n", ret) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  exit (-1) >>>>>;
    }
  if (ChildThreadStackSize > 0)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (ret = pthread_attr_setstacksize (&ChildThreadAttributes, (size_t) ChildThreadStackSize)) >>>>>;
      if (ret != 0)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "Can\'t set thread stacksize [err=%d]! Countinue with default one.\n", ret) >>>>>;
        }
    }
  return <retval> = ret;
}


;; Function int setupSignalHandling() (null)
;; enabled by -tree-original


{
  int ret;

    int ret;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (ret = initSignalMask ()) >>>>>;
  if (ret == 0)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (ret = pthread_create (&SignalHandlerThread, (const union pthread_attr_t *) &ChildThreadAttributes, signalHandlerProc, 0B)) >>>>>;
    }
  return <retval> = ret;
}


;; Function int setupTerminator() (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = pthread_create (&TerminatorThread, (const union pthread_attr_t *) &ChildThreadAttributes, terminatorThreadProc, 0B)>>;


;; Function void cleanupUnfinishedWork() (null)
;; enabled by -tree-original


{
  struct stat statBuf;
  int ret = 0;

  if (unfinishedWorkCleaned != 0)
    {
      return;
    }
    struct stat statBuf;
  <<cleanup_point   int ret = 0;>>;
  if ((sigInFilename == 0B || sigOutFilename == 0B) || OutputStdOut == 1)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (unfinishedWorkCleaned = 1) >>>>>;
      return;
    }
  if (QuietMode != 1)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "Cleanup unfinished work [Outfile: %s]...\n", sigOutFilename) >>>>>;
    }
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (ret = stat (sigInFilename, &statBuf)) >>>>>;
  if (ret == 0)
    {
      if (QuietMode != 1)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "Deleting output file: %s, if it exists...\n", sigOutFilename) >>>>>;
        }
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (ret = remove (sigOutFilename)) >>>>>;
      if (ret != 0)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  pbzip2::ErrorContext::syncPrintErrnoMsg (stderr, *__errno_location ()) >>>>>;
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "pbzip2:  *WARNING: Deletion of output file (apparently) failed.\n") >>>>>;
        }
      else
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "pbzip2:  *INFO: Deletion of output file succeeded.\n") >>>>>;
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (sigOutFilename = 0B) >>>>>;
        }
    }
  else
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "pbzip2:  *WARNING: Output file was not deleted since input file no longer exists.\n") >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "pbzip2:  *WARNING: Output file: %s, may be incomplete!\n", sigOutFilename) >>>>>;
    }
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (unfinishedWorkCleaned = 1) >>>>>;
}


;; Function void* terminatorThreadProc(void*) (null)
;; enabled by -tree-original


{
  int ret;

    int ret;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (ret = pthread_mutex_lock (&TerminateFlagMutex)) >>>>>;
  if (ret != 0)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  pbzip2::ErrorContext::syncPrintErrnoMsg (stderr, *__errno_location ()) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "Terminator thread: pthread_mutex_lock error [%d]! Aborting...\n", ret) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  syncSetTerminateFlag (1) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  cleanupAndQuit (1) >>>>>;
    }
  while (1)
    {
      if (finishedFlag != 0 || terminateFlag != 0) goto <D.39339>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (ret = pthread_cond_wait (&TerminateCond, &TerminateFlagMutex)) >>>>>;
    }
  <D.39339>:;
  if (finishedFlag != 0)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (ret = pthread_mutex_unlock (&TerminateFlagMutex)) >>>>>;
      return <retval> = 0B;
    }
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (ret = pthread_mutex_unlock (&TerminateFlagMutex)) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "Terminator thread: premature exit requested - quitting...\n") >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  cleanupAndQuit (1) >>>>>;
  return <retval> = 0B;
}


;; Function void* signalHandlerProc(void*) (null)
;; enabled by -tree-original


{
  int signalCaught;
  int ret;

    int signalCaught;
    int ret;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (ret = sigwait ((const struct sigset_t *) &SignalMask, &signalCaught)) >>>>>;
  if (ret != 0)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "\n *signalHandlerProc - sigwait error: %d\n", ret) >>>>>;
    }
  else
    {
      if (signalCaught == SIG_HANDLER_QUIT_SIGNAL)
        {
          return <retval> = 0B;
        }
      else
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "\n *Control-C or similar caught [sig=%d], quitting...\n", signalCaught) >>>>>;
          <<cleanup_point <<< Unknown tree: expr_stmt
  syncSetTerminateFlag (1) >>>>>;
        }
    }
  return <retval> = 0B;
}


;; Function void cleanupAndQuit(int) (null)
;; enabled by -tree-original


{
  int ret;

    int ret;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (ret = pthread_mutex_lock (&ErrorHandlerMutex)) >>>>>;
  if (ret != 0)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "Cleanup Handler: Failed to lock ErrorHandlerMutex! May double cleanup...\n") >>>>>;
    }
  <<cleanup_point <<< Unknown tree: expr_stmt
  cleanupUnfinishedWork () >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) pthread_mutex_unlock (&ErrorHandlerMutex) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  exit (exitCode) >>>>>;
}


;; Function int producerDecompressCheckInterrupt(int, outBuff*&, int) (null)
;; enabled by -tree-original


{
  bool isInterrupted = 0;

  <<cleanup_point   bool isInterrupted = 0;>>;
  if (<<cleanup_point syncGetLastGoodBlock () != -1>>)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (isInterrupted = 1) >>>>>;
    }
  if (<<cleanup_point syncGetTerminateFlag () != 0>>)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (isInterrupted = 1) >>>>>;
    }
  if (isInterrupted)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) close (hInfile) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  disposeMemorySingle<outBuff> ((struct outBuff * &) fileData) >>>>>;
      return <retval> = 1;
    }
  return <retval> = 0;
}


;; Function int producer_decompress(int, off_t, queue*) (null)
;; enabled by -tree-original


{
  struct BZ2StreamScanner bz2StreamScanner;
  struct outBuff * fileData;

  <<cleanup_point <<< Unknown tree: expr_stmt
  safe_mutex_lock (&ProgressIndicatorsMutex) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (InBytesProduced = 0) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (NumBlocks = 0) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  safe_mutex_unlock (&ProgressIndicatorsMutex) >>>>>;
    struct BZ2StreamScanner bz2StreamScanner;
  <<cleanup_point <<< Unknown tree: expr_stmt
  pbzip2::BZ2StreamScanner::BZ2StreamScanner (&bz2StreamScanner, hInfile, 1048576) >>>>>;
  try
    {
            struct outBuff * fileData;
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (fileData = pbzip2::BZ2StreamScanner::getNextStream (&bz2StreamScanner)) >>>>>;
      while (1)
        {
          if (<<cleanup_point !pbzip2::BZ2StreamScanner::failed (&bz2StreamScanner) && fileData->bufSize != 0>>) (void) 0; else goto <D.39378>;
          if (<<cleanup_point producerDecompressCheckInterrupt (hInfile, (struct outBuff * &) &fileData, NumBlocks) != 0>>)
            {
              <<cleanup_point <<< Unknown tree: expr_stmt
  safe_mutex_lock (fifo->mut) >>>>>;
              <<cleanup_point <<< Unknown tree: expr_stmt
  safe_cond_broadcast (fifo->notEmpty) >>>>>;
              <<cleanup_point <<< Unknown tree: expr_stmt
  safe_mutex_unlock (fifo->mut) >>>>>;
              <<cleanup_point <<< Unknown tree: expr_stmt
  syncSetProducerDone (1) >>>>>;
              return <retval> = 0;
            }
          if (QuietMode != 1)
            {
              if (fileData->bufSize > 250000000)
                {
                  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "pbzip2:  *WARNING: Compressed block size is large [%lu bytes].\n", (uintmax_t) fileData->bufSize) >>>>>;
                  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "          If program aborts, use regular BZIP2 to decompress.\n") >>>>>;
                }
            }
          <<cleanup_point <<< Unknown tree: expr_stmt
  safe_mutex_lock (fifo->mut) >>>>>;
          while (1)
            {
              if (fifo->full == 0) goto <D.39380>;
              <<cleanup_point <<< Unknown tree: expr_stmt
  safe_cond_wait (fifo->notFull, fifo->mut) >>>>>;
              if (<<cleanup_point producerDecompressCheckInterrupt (hInfile, (struct outBuff * &) &fileData, NumBlocks) != 0>>)
                {
                  <<cleanup_point <<< Unknown tree: expr_stmt
  safe_cond_broadcast (fifo->notEmpty) >>>>>;
                  <<cleanup_point <<< Unknown tree: expr_stmt
  syncSetProducerDone (1) >>>>>;
                  <<cleanup_point <<< Unknown tree: expr_stmt
  safe_mutex_unlock (fifo->mut) >>>>>;
                  return <retval> = 0;
                }
            }
          <D.39380>:;
          <<cleanup_point <<< Unknown tree: expr_stmt
  queue::add (NON_LVALUE_EXPR <fifo>, fileData) >>>>>;
          <<cleanup_point <<< Unknown tree: expr_stmt
  safe_cond_signal (fifo->notEmpty) >>>>>;
          <<cleanup_point <<< Unknown tree: expr_stmt
  safe_mutex_lock (&ProgressIndicatorsMutex) >>>>>;
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (InBytesProduced = (off_t) fileData->bufSize + InBytesProduced) >>>>>;
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (NumBlocks = fileData->blockNumber + 1) >>>>>;
          <<cleanup_point <<< Unknown tree: expr_stmt
  safe_mutex_unlock (&ProgressIndicatorsMutex) >>>>>;
          <<cleanup_point <<< Unknown tree: expr_stmt
  safe_mutex_unlock (fifo->mut) >>>>>;
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (fileData = pbzip2::BZ2StreamScanner::getNextStream (&bz2StreamScanner)) >>>>>;
        }
      <D.39378>:;
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) close (hInfile) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  operator delete ((void *) fileData, 40) >>>>>;
      if (<<cleanup_point pbzip2::BZ2StreamScanner::failed (&bz2StreamScanner)>>)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) handle_error (1, 1, (const char *) "pbzip2: producer_decompress: *ERROR: when reading bzip2 input stream\n") >>>>>;
          return <retval> = -1;
        }
      else
        {
          if (<<cleanup_point !pbzip2::BZ2StreamScanner::isBz2HeaderFound (&bz2StreamScanner) || !pbzip2::BZ2StreamScanner::eof (&bz2StreamScanner)>>)
            {
              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) handle_error (1, 1, (const char *) "pbzip2: producer_decompress: *ERROR: input file is not a valid bzip2 stream\n") >>>>>;
              return <retval> = -1;
            }
        }
      <<cleanup_point <<< Unknown tree: expr_stmt
  syncSetProducerDone (1) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  safe_mutex_lock (fifo->mut) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  safe_cond_broadcast (fifo->notEmpty) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  safe_mutex_unlock (fifo->mut) >>>>>;
      return <retval> = 0;
    }
  finally
    {
      pbzip2::BZ2StreamScanner::~BZ2StreamScanner (&bz2StreamScanner);
    }
}


;; Function int consumerDecompressCheckInterrupt(const outBuff*) (null)
;; enabled by -tree-original


{
  bool isInterrupted = 0;
  int minErrBlock;

  <<cleanup_point   bool isInterrupted = 0;>>;
  if (<<cleanup_point syncGetTerminateFlag () != 0>>)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (isInterrupted = 1) >>>>>;
    }
    int minErrBlock;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (minErrBlock = syncGetMinErrorBlock ()) >>>>>;
  if (minErrBlock != -1 && ((lastElement == 0B || (int) lastElement->blockNumber >= minErrBlock) || (bool) lastElement->isLastInSequence))
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (isInterrupted = 1) >>>>>;
    }
  if (isInterrupted)
    {
      return <retval> = 1;
    }
  return <retval> = 0;
}


;; Function void* consumer_decompress(void*) (null)
;; enabled by -tree-original


{
  struct queue * fifo = (struct queue *) q;
  struct outBuff * fileData = 0B;
  struct outBuff * lastFileData = 0B;
  char * DecompressedData = 0B;
  unsigned int outSize = 0;
  struct outBuff * prevOutBlockInSequence = 0B;
  int outSequenceNumber = -1;
  unsigned int processedIn = 0;
  int errState = 0;
  struct bz_stream strm;

    struct queue * fifo = (struct queue *) q;
  <<cleanup_point   struct outBuff * fileData = 0B;>>;
  <<cleanup_point   struct outBuff * lastFileData = 0B;>>;
  <<cleanup_point   char * DecompressedData = 0B;>>;
  <<cleanup_point   unsigned int outSize = 0;>>;
  <<cleanup_point   struct outBuff * prevOutBlockInSequence = 0B;>>;
  <<cleanup_point   int outSequenceNumber = -1;>>;
  <<cleanup_point   unsigned int processedIn = 0;>>;
  <<cleanup_point   int errState = 0;>>;
    struct bz_stream strm;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (strm.bzalloc = 0B) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (strm.bzfree = 0B) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (strm.opaque = 0B) >>>>>;
  {
    while (1)
      {
        {
          int bzret = 0;

          <<cleanup_point <<< Unknown tree: expr_stmt
  safe_mutex_lock (fifo->mut) >>>>>;
          while (1)
            {
              if (<<cleanup_point consumerDecompressCheckInterrupt ((const struct outBuff *) fileData) != 0>>)
                {
                  <<cleanup_point <<< Unknown tree: expr_stmt
  safe_mutex_unlock (fifo->mut) >>>>>;
                  return <retval> = 0B;
                }
              if (<<cleanup_point fifo->empty == 0 && queue::remove (NON_LVALUE_EXPR <fifo>, (struct ElementType * &) &fileData) == 1>>) goto <D.39445>;
              if (<<cleanup_point fifo->empty != 0 && (syncGetProducerDone () == 1 || syncGetTerminateFlag () != 0)>>)
                {
                  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) pthread_mutex_unlock (fifo->mut) >>>>>;
                  if (<<cleanup_point syncGetTerminateFlag () == 0 && outSequenceNumber != -1>>)
                    {
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) handle_error (1, -1, (const char *) "pbzip2: *ERROR on decompress - premature end of archive stream (block=%d; seq=%d; outseq=%d)!\n", lastFileData->blockNumber, lastFileData->sequenceNumber, outSequenceNumber) >>>>>;
                    }
                  <<cleanup_point <<< Unknown tree: expr_stmt
  disposeMemorySingle<outBuff> ((struct outBuff * &) &lastFileData) >>>>>;
                  return <retval> = 0B;
                }
              <<cleanup_point <<< Unknown tree: expr_stmt
  safe_cond_wait (fifo->notEmpty, fifo->mut) >>>>>;
            }
          <D.39445>:;
          <<cleanup_point <<< Unknown tree: expr_stmt
  safe_cond_signal (fifo->notFull) >>>>>;
          <<cleanup_point <<< Unknown tree: expr_stmt
  safe_mutex_unlock (fifo->mut) >>>>>;
          if (lastFileData != 0B)
            {
              <<cleanup_point <<< Unknown tree: expr_stmt
  operator delete ((void *) lastFileData, 40) >>>>>;
            }
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (lastFileData = fileData) >>>>>;
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (outSize = 900000) >>>>>;
          <<cleanup_point           int bzret = 0;>>;
          if (fileData->sequenceNumber <= 1)
            {
              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (bzret = BZ2_bzDecompressInit (&strm, Verbosity, 0)) >>>>>;
              if (bzret != 0)
                {
                  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) handle_error (1, -1, (const char *) "pbzip2: *ERROR during BZ2_bzDecompressInit: %d\n", bzret) >>>>>;
                  return <retval> = 0B;
                }
            }
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (strm.avail_in = fileData->bufSize) >>>>>;
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (strm.next_in = fileData->buf) >>>>>;
          while (1)
            {
              if (bzret != 0 || strm.avail_in == 0) goto <D.39447>;
              {
                unsigned int availIn = strm.avail_in;

                if (DecompressedData == 0B)
                  {
                    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (DecompressedData = (char *) operator new [] ((size_t) NON_LVALUE_EXPR <SAVE_EXPR <(sizetype) outSize>>, (const struct nothrow_t &) &nothrow)) >>>>>;
                    if (DecompressedData == 0B)
                      {
                        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) handle_error (1, -1, (const char *) " *ERROR: Could not allocate memory (DecompressedData)!  Aborting...\n") >>>>>;
                        return <retval> = 0B;
                      }
                    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (processedIn = 0) >>>>>;
                    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (strm.avail_out = outSize) >>>>>;
                    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (strm.next_out = DecompressedData) >>>>>;
                  }
                                unsigned int availIn = strm.avail_in;
                <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (bzret = BZ2_bzDecompress (&strm)) >>>>>;
                <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (processedIn = (availIn - strm.avail_in) + processedIn) >>>>>;
                {
                  if (bzret == 0 && strm.avail_out == 0 || bzret == 4)
                    {
                      {
                        struct outBuff * addret = 0B;
                        unsigned int len = outSize - strm.avail_out;
                        bool isLast = bzret == 4;

                        <<cleanup_point                         struct outBuff * addret = 0B;>>;
                                                unsigned int len = outSize - strm.avail_out;
                                                bool isLast = bzret == 4;
                        if (<<cleanup_point hasTrailingGarbage (bzret, (const struct outBuff *) fileData, (const struct bz_stream &) &strm)>>)
                          {
                            <<cleanup_point <<< Unknown tree: expr_stmt
  syncSetLastGoodBlock (fileData->blockNumber, fileData->blockNumber) >>>>>;
                          }
                        {
                          if (outSequenceNumber > 0)
                            {
                              {
                                struct outBuff * nextOutBlock;

                                <<cleanup_point <<< Unknown tree: expr_stmt
  (void)  ++outSequenceNumber >>>>>;
                                                                struct outBuff * nextOutBlock;
                                <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (nextOutBlock = TARGET_EXPR <D.39439, operator new (40, (const struct nothrow_t &) &nothrow)>;, (struct outBuff *) D.39439 != 0B ? try
    {
      outBuff::outBuff ((struct outBuff *) D.39439, DecompressedData, len, fileData->blockNumber, outSequenceNumber, processedIn, (int) isLast, 0B);
    }
  catch
    {
      operator delete (D.39439, (const struct nothrow_t &) &nothrow);
    }, (struct outBuff *) D.39439; : (struct outBuff *) D.39439;) >>>>>;
                                if (nextOutBlock == 0B)
                                  {
                                    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) BZ2_bzDecompressEnd (&strm) >>>>>;
                                    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) handle_error (1, -1, (const char *) " *ERROR: Could not allocate memory (nextOutBlock)!  Aborting...\n") >>>>>;
                                    return <retval> = 0B;
                                  }
                                <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (addret = outputBufferSeqAddNext (prevOutBlockInSequence, nextOutBlock)) >>>>>;
                              }
                            }
                          else
                            {
                              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (outSequenceNumber = bzret == 0 ? 1 : 0) >>>>>;
                              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (addret = outputBufferAdd ((const struct outBuff &) &TARGET_EXPR <D.39440, <<< Unknown tree: aggr_init_expr
  11
  __comp_ctor 
  D.39440
  (struct outBuff *) <<< Unknown tree: void_cst >>>
  DecompressedData
  len
  fileData->blockNumber
  outSequenceNumber
  processedIn
  (int) isLast
  0B >>>>, (const char *) "consumer_decompress")) >>>>>;
                            }
                        }
                        if (addret == 0B)
                          {
                            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) BZ2_bzDecompressEnd (&strm) >>>>>;
                            return <retval> = 0B;
                          }
                        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (prevOutBlockInSequence = addret) >>>>>;
                        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (DecompressedData = 0B) >>>>>;
                      }
                    }
                }
              }
            }
          <D.39447>:;
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (errState = decompressErrCheck (bzret, (const struct outBuff *) fileData, outSequenceNumber, (const struct bz_stream &) &strm)) >>>>>;
          if (bzret == 4)
            {
              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (bzret = BZ2_bzDecompressEnd (&strm)) >>>>>;
              if (bzret != 0 && (unsigned int) errState <= 1)
                {
                  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) handle_error (1, -1, (const char *) "pbzip2: *ERROR during BZ2_bzDecompressEnd: %d\n", bzret) >>>>>;
                  return <retval> = 0B;
                }
              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (outSequenceNumber = -1) >>>>>;
              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (prevOutBlockInSequence = 0B) >>>>>;
            }
          <<cleanup_point <<< Unknown tree: expr_stmt
  disposeMemory<char> ((char * &) &fileData->buf) >>>>>;
          if (errState != 0)
            {
              return <retval> = 0B;
            }
        }
      }
  }
  return <retval> = 0B;
}


;; Function void* fileWriter(void*) (null)
;; enabled by -tree-original


{
  char * OutFilename;
  off_t CompressedSize = 0;
  int percentComplete = 0;
  int hOutfile = 1;
  int currBlock = 0;
  size_t outBufferPos = 0;
  int ret = -1;
  off_t bytesProcessed = 0;
  struct outBuff * prevBlockInSequence = 0B;

    char * OutFilename;
  <<cleanup_point   off_t CompressedSize = 0;>>;
  <<cleanup_point   int percentComplete = 0;>>;
  <<cleanup_point   int hOutfile = 1;>>;
  <<cleanup_point   int currBlock = 0;>>;
  <<cleanup_point   size_t outBufferPos = 0;>>;
  <<cleanup_point   int ret = -1;>>;
  <<cleanup_point   off_t bytesProcessed = 0;>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (OutFilename = (char *) outname) >>>>>;
  <<cleanup_point   struct outBuff * prevBlockInSequence = 0B;>>;
  if (OutputStdOut == 0)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (hOutfile = safe_open_output ((const char *) OutFilename)) >>>>>;
      if (hOutfile == -1)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) handle_error (1, -1, (const char *) "pbzip2: *ERROR: Could not create output file [%s]!\n", OutFilename) >>>>>;
          return <retval> = 0B;
        }
    }
  while (1)
    {
      {
        struct outBuff * outBlock;

        if (<<cleanup_point (syncGetProducerDone () == 1 && currBlock >= NumBlocks) && prevBlockInSequence == 0B>>) goto <D.39463>;
        if (<<cleanup_point syncGetTerminateFlag () != 0>>) goto <D.39463>;
        <<cleanup_point <<< Unknown tree: expr_stmt
  safe_mutex_lock (OutMutex) >>>>>;
        if (LastGoodBlock != -1 && NextBlockToWrite > LastGoodBlock)
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  safe_mutex_unlock (OutMutex) >>>>>;
            goto <D.39463>;
          }
        if (<<cleanup_point std::vector<outBuff>::operator[] (&OutputBuffer, outBufferPos)->buf == 0B && (prevBlockInSequence == 0B || prevBlockInSequence->next == 0B)>>)
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) safe_cond_timed_wait (&OutBufferHeadNotEmpty, OutMutex, 1, (const char *) "fileWriter") >>>>>;
            <<cleanup_point <<< Unknown tree: expr_stmt
  safe_mutex_unlock (OutMutex) >>>>>;
            // predicted unlikely by continue predictor.;
            goto <D.39464>;
          }
        else
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  safe_mutex_unlock (OutMutex) >>>>>;
          }
                struct outBuff * outBlock;
        if (prevBlockInSequence != 0B)
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (outBlock = prevBlockInSequence->next) >>>>>;
          }
        else
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (outBlock = (struct value_type *) std::vector<outBuff>::operator[] (&OutputBuffer, outBufferPos)) >>>>>;
          }
        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (ret = (int) do_write (hOutfile, (const void *) outBlock->buf, (size_t) outBlock->bufSize)) >>>>>;
        if (ret < 0)
          {
            if (OutputStdOut == 0)
              {
                <<cleanup_point <<< Unknown tree: expr_stmt
  (void) close (hOutfile) >>>>>;
              }
            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) handle_error (1, -1, (const char *) "pbzip2: *ERROR: Could not write %d bytes to file [ret=%d]!  Aborting...\n", outBlock->bufSize, ret) >>>>>;
            return <retval> = 0B;
          }
        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (CompressedSize = (off_t) ret + CompressedSize) >>>>>;
        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (bytesProcessed = (off_t) outBlock->inSize + bytesProcessed) >>>>>;
        <<cleanup_point <<< Unknown tree: expr_stmt
  (if (outBlock->buf != 0B)
    {
      operator delete [] ((void *) outBlock->buf);
    }
  else
    {
      0
    }) >>>>>;
        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (outBlock->buf = 0B) >>>>>;
        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (outBlock->bufSize = 0) >>>>>;
        if (outBlock->isLastInSequence)
          {
            if (<<cleanup_point  ++outBufferPos == NumBufferedBlocksMax>>)
              {
                <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (outBufferPos = 0) >>>>>;
              }
            <<cleanup_point <<< Unknown tree: expr_stmt
  (void)  ++currBlock >>>>>;
          }
        <<cleanup_point <<< Unknown tree: expr_stmt
  safe_mutex_lock (OutMutex) >>>>>;
        if (outBlock->isLastInSequence)
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  (void)  ++NextBlockToWrite >>>>>;
            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (OutBufferPosToWrite = outBufferPos) >>>>>;
          }
        if (outBlock->sequenceNumber > 1)
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  (void)  --NumBufferedTailBlocks >>>>>;
          }
        <<cleanup_point <<< Unknown tree: expr_stmt
  safe_cond_broadcast (notTooMuchNumBuffered) >>>>>;
        <<cleanup_point <<< Unknown tree: expr_stmt
  safe_cond_broadcast (&ErrStateChangeCond) >>>>>;
        <<cleanup_point <<< Unknown tree: expr_stmt
  safe_mutex_unlock (OutMutex) >>>>>;
        if (outBlock->sequenceNumber > 2)
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  operator delete ((void *) prevBlockInSequence, 40) >>>>>;
          }
        if (outBlock->isLastInSequence)
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (prevBlockInSequence = 0B) >>>>>;
            if (outBlock->sequenceNumber > 1)
              {
                <<cleanup_point <<< Unknown tree: expr_stmt
  operator delete ((void *) outBlock, 40) >>>>>;
              }
          }
        else
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (prevBlockInSequence = outBlock) >>>>>;
          }
        {
          if (QuietMode != 1)
            {
              {
                int percentCompleteOld = percentComplete;

                                int percentCompleteOld = percentComplete;
                if (InFileSize > 0)
                  {
                    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (percentComplete = (int) (((double) bytesProcessed * 1.0e+2) / (double) InFileSize)) >>>>>;
                  }
                if (percentComplete != percentCompleteOld)
                  {
                    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "Completed: %d%%             \r", percentComplete) >>>>>;
                    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fflush (stderr) >>>>>;
                  }
              }
            }
        }
      }
      <D.39464>:;
    }
  <D.39463>:;
  if (currBlock == 0)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (ret = (int) do_write (hOutfile, (const void *) &Bz2HeaderZero, 14)) >>>>>;
      if (ret < 0)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) handle_error (1, -1, (const char *) "pbzip2: *ERROR: Could not write to file!  Aborting...\n") >>>>>;
          return <retval> = 0B;
        }
    }
  if (OutputStdOut == 0)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (ret = close (hOutfile)) >>>>>;
      if (ret == -1)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  pbzip2::ErrorContext::saveError (pbzip2::ErrorContext::getInstance ()) >>>>>;
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) handle_error (1, -1, (const char *) "pbzip2: *ERROR: Could not close output file!  Aborting...\n") >>>>>;
          return <retval> = 0B;
        }
    }
  if (QuietMode != 1)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "    Output Size: %lu bytes\n", (uintmax_t) CompressedSize) >>>>>;
    }
  if (FifoQueue != 0B)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  safe_mutex_lock (FifoQueue->mut) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  safe_cond_broadcast (FifoQueue->notEmpty) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  safe_cond_broadcast (FifoQueue->notFull) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  safe_mutex_unlock (FifoQueue->mut) >>>>>;
    }
  <<cleanup_point <<< Unknown tree: expr_stmt
  safe_mutex_lock (OutMutex) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  safe_cond_broadcast (notTooMuchNumBuffered) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  safe_mutex_unlock (OutMutex) >>>>>;
  if (QuietMode != 1)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (percentComplete = 100) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "Completed: %d%%             \r", percentComplete) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fflush (stderr) >>>>>;
    }
  return <retval> = 0B;
}


;; Function int directcompress(int, off_t, int, const char*) (null)
;; enabled by -tree-original


{
  char * FileData = 0B;
  char * CompressedData = 0B;
  off_t CompressedSize = 0;
  off_t bytesLeft = 0;
  off_t inSize = 0;
  unsigned int outSize = 0;
  int percentComplete = 0;
  int hOutfile = 1;
  int currBlock = 0;
  int rret = 0;
  int ret = 0;

  <<cleanup_point   char * FileData = 0B;>>;
  <<cleanup_point   char * CompressedData = 0B;>>;
  <<cleanup_point   off_t CompressedSize = 0;>>;
  <<cleanup_point   off_t bytesLeft = 0;>>;
  <<cleanup_point   off_t inSize = 0;>>;
  <<cleanup_point   unsigned int outSize = 0;>>;
  <<cleanup_point   int percentComplete = 0;>>;
  <<cleanup_point   int hOutfile = 1;>>;
  <<cleanup_point   int currBlock = 0;>>;
  <<cleanup_point   int rret = 0;>>;
  <<cleanup_point   int ret = 0;>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (bytesLeft = fileSize) >>>>>;
  if (OutputStdOut == 0)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (hOutfile = safe_open_output (OutFilename)) >>>>>;
      if (hOutfile == -1)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) handle_error (1, -1, (const char *) "pbzip2: *ERROR: Could not create output file [%s]!\n", OutFilename) >>>>>;
          return <retval> = -1;
        }
    }
  while (1)
    {
      if (bytesLeft <= 0) goto <D.39483>;
      {
        int percentCompleteOld = percentComplete;

        if (<<cleanup_point syncGetTerminateFlag () != 0>>)
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) close (hInfile) >>>>>;
            if (OutputStdOut == 0)
              {
                <<cleanup_point <<< Unknown tree: expr_stmt
  (void) close (hOutfile) >>>>>;
              }
            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "directcompress: terminating - terminateFlag set\n") >>>>>;
            return <retval> = -1;
          }
        if ((off_t) blockSize < bytesLeft)
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (inSize = (off_t) blockSize) >>>>>;
          }
        else
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (inSize = bytesLeft) >>>>>;
          }
        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (FileData = 0B) >>>>>;
        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (FileData = (char *) operator new [] ((size_t) NON_LVALUE_EXPR <SAVE_EXPR <(sizetype) inSize>>, (const struct nothrow_t &) &nothrow)) >>>>>;
        if (FileData == 0B)
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) close (hInfile) >>>>>;
            if (OutputStdOut == 0)
              {
                <<cleanup_point <<< Unknown tree: expr_stmt
  (void) close (hOutfile) >>>>>;
              }
            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) handle_error (1, -1, (const char *) "pbzip2: *ERROR: Could not allocate memory (FileData)!  Aborting...\n") >>>>>;
            return <retval> = -1;
          }
        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (rret = (int) do_read (hInfile, (void *) FileData, (size_t) inSize)) >>>>>;
        if (rret == 0)
          {
            if (FileData != 0B)
              {
                <<cleanup_point <<< Unknown tree: expr_stmt
  (if (FileData != 0B)
    {
      operator delete [] ((void *) FileData);
    }
  else
    {
      0
    }) >>>>>;
              }
            goto <D.39483>;
          }
        else
          {
            if (rret < 0)
              {
                <<cleanup_point <<< Unknown tree: expr_stmt
  (void) close (hInfile) >>>>>;
                if (FileData != 0B)
                  {
                    <<cleanup_point <<< Unknown tree: expr_stmt
  (if (FileData != 0B)
    {
      operator delete [] ((void *) FileData);
    }
  else
    {
      0
    }) >>>>>;
                  }
                if (OutputStdOut == 0)
                  {
                    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) close (hOutfile) >>>>>;
                  }
                <<cleanup_point <<< Unknown tree: expr_stmt
  (void) handle_error (1, -1, (const char *) "pbzip2: *ERROR: Could not read from file!  Aborting...\n") >>>>>;
                return <retval> = -1;
              }
          }
        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (bytesLeft = bytesLeft - (off_t) rret) >>>>>;
        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (outSize = (unsigned int) (int) ((double) inSize * 1.0100000000000000088817841970012523233890533447265625e+0 + 6.0e+2)) >>>>>;
        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (CompressedData = (char *) operator new [] ((size_t) NON_LVALUE_EXPR <SAVE_EXPR <(sizetype) outSize>>, (const struct nothrow_t &) &nothrow)) >>>>>;
        if (CompressedData == 0B)
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) close (hInfile) >>>>>;
            if (FileData != 0B)
              {
                <<cleanup_point <<< Unknown tree: expr_stmt
  (if (FileData != 0B)
    {
      operator delete [] ((void *) FileData);
    }
  else
    {
      0
    }) >>>>>;
              }
            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) handle_error (1, -1, (const char *) "pbzip2: *ERROR: Could not allocate memory (CompressedData)!  Aborting...\n") >>>>>;
            return <retval> = -1;
          }
        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (ret = BZ2_bzBuffToBuffCompress (CompressedData, &outSize, FileData, (unsigned int) inSize, BWTblockSize, Verbosity, 30)) >>>>>;
        if (ret != 0)
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) close (hInfile) >>>>>;
            if (FileData != 0B)
              {
                <<cleanup_point <<< Unknown tree: expr_stmt
  (if (FileData != 0B)
    {
      operator delete [] ((void *) FileData);
    }
  else
    {
      0
    }) >>>>>;
              }
            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) handle_error (1, -1, (const char *) "pbzip2: *ERROR during compression: %d!  Aborting...\n", ret) >>>>>;
            return <retval> = -1;
          }
        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (ret = (int) do_write (hOutfile, (const void *) CompressedData, (size_t) outSize)) >>>>>;
        if (ret <= 0)
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) close (hInfile) >>>>>;
            if (FileData != 0B)
              {
                <<cleanup_point <<< Unknown tree: expr_stmt
  (if (FileData != 0B)
    {
      operator delete [] ((void *) FileData);
    }
  else
    {
      0
    }) >>>>>;
              }
            if (CompressedData != 0B)
              {
                <<cleanup_point <<< Unknown tree: expr_stmt
  (if (CompressedData != 0B)
    {
      operator delete [] ((void *) CompressedData);
    }
  else
    {
      0
    }) >>>>>;
              }
            if (OutputStdOut == 0)
              {
                <<cleanup_point <<< Unknown tree: expr_stmt
  (void) close (hOutfile) >>>>>;
              }
            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) handle_error (1, -1, (const char *) "pbzip2: *ERROR: Could not write to file!  Aborting...\n") >>>>>;
            return <retval> = -1;
          }
        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (CompressedSize = (off_t) ret + CompressedSize) >>>>>;
        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) currBlock++  >>>>>;
                int percentCompleteOld = percentComplete;
        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (percentComplete = (currBlock * 100) / NumBlocksEstimated) >>>>>;
        if (QuietMode != 1)
          {
            if (percentComplete != percentCompleteOld)
              {
                <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "Completed: %d%%             \r", percentComplete) >>>>>;
                <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fflush (stderr) >>>>>;
              }
          }
        if (FileData != 0B)
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  (if (FileData != 0B)
    {
      operator delete [] ((void *) FileData);
    }
  else
    {
      0
    }) >>>>>;
            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (FileData = 0B) >>>>>;
          }
        if (CompressedData != 0B)
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  (if (CompressedData != 0B)
    {
      operator delete [] ((void *) CompressedData);
    }
  else
    {
      0
    }) >>>>>;
            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (CompressedData = 0B) >>>>>;
          }
        if ((off_t) rret != inSize)
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (inSize = (off_t) rret) >>>>>;
          }
      }
    }
  <D.39483>:;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) close (hInfile) >>>>>;
  if (OutputStdOut == 0)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) close (hOutfile) >>>>>;
    }
  if (QuietMode != 1)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "    Output Size: %lu bytes\n", (uintmax_t) CompressedSize) >>>>>;
    }
  <<cleanup_point <<< Unknown tree: expr_stmt
  syncSetProducerDone (1) >>>>>;
  return <retval> = 0;
}


;; Function int directdecompress(const char*, const char*) (null)
;; enabled by -tree-original


{
  struct FILE * stream = 0B;
  struct FILE * zStream = 0B;
  BZFILE * bzf = 0B;
  unsigned char obuf[5000];
  unsigned char unused[5000];
  unsigned char * unusedTmp;
  int bzerr;
  int nread;
  int streamNo;
  int nUnused;
  int ret = 0;
  int i;

  <<cleanup_point   struct FILE * stream = 0B;>>;
  <<cleanup_point   struct FILE * zStream = 0B;>>;
  <<cleanup_point   BZFILE * bzf = 0B;>>;
    unsigned char obuf[5000];
    unsigned char unused[5000];
    unsigned char * unusedTmp;
    int bzerr;
    int nread;
    int streamNo;
    int nUnused;
  <<cleanup_point   int ret = 0;>>;
    int i;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (nUnused = 0) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (streamNo = 0) >>>>>;
  if (strcmp (InFilename, (const char *) "-") != 0)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (zStream = fopen (InFilename, (const char *) "rb")) >>>>>;
      if (zStream == 0B)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) handle_error (1, -1, (const char *) "pbzip2: *ERROR: Could not open input file [%s]!  Aborting...\n", InFilename) >>>>>;
          return <retval> = -1;
        }
    }
  else
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (zStream = stdin) >>>>>;
    }
  if (<<cleanup_point ferror (zStream) != 0>>)
    {
      if (zStream != stdin)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fclose (zStream) >>>>>;
        }
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) handle_error (1, -1, (const char *) "pbzip2: *ERROR: Problem with input stream of file [%s]!  Aborting...\n", InFilename) >>>>>;
      return <retval> = -1;
    }
  if (OutputStdOut == 0)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (stream = safe_fopen_output (OutFilename, (const char *) "wb")) >>>>>;
      if (stream == 0B)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) handle_error (1, -1, (const char *) "pbzip2: *ERROR: Could not open output file [%s]!  Aborting...\n", OutFilename) >>>>>;
          return <retval> = -1;
        }
    }
  else
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (stream = stdout) >>>>>;
    }
  if (<<cleanup_point ferror (stream) != 0>>)
    {
      if (stream != stdout)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fclose (stream) >>>>>;
        }
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) handle_error (1, -1, (const char *) "pbzip2: *ERROR: Problem with output stream of file [%s]!  Aborting...\n", InFilename) >>>>>;
      return <retval> = -1;
    }
  while (1)
    {
      {
        if (<<cleanup_point syncGetTerminateFlag () != 0>>)
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "directdecompress: terminating1 - terminateFlag set\n") >>>>>;
            if (zStream != stdin)
              {
                <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fclose (zStream) >>>>>;
              }
            if (stream != stdout)
              {
                <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fclose (stream) >>>>>;
              }
            return <retval> = -1;
          }
        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (bzf = BZ2_bzReadOpen (&bzerr, zStream, Verbosity, 0, (void *) &unused, nUnused)) >>>>>;
        if (bzf == 0B || bzerr != 0)
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (ret = testBZ2ErrorHandling (bzerr, bzf, streamNo)) >>>>>;
            if (zStream != stdin)
              {
                <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fclose (zStream) >>>>>;
              }
            if (stream != stdout)
              {
                <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fclose (stream) >>>>>;
              }
            if (ret != 0)
              {
                <<cleanup_point <<< Unknown tree: expr_stmt
  syncSetTerminateFlag (1) >>>>>;
              }
            return <retval> = ret;
          }
        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) streamNo++  >>>>>;
        while (1)
          {
            if (bzerr != 0) goto <D.39506>;
            {
              if (<<cleanup_point syncGetTerminateFlag () != 0>>)
                {
                  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "directdecompress: terminating2 - terminateFlag set\n") >>>>>;
                  if (zStream != stdin)
                    {
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fclose (zStream) >>>>>;
                    }
                  if (stream != stdout)
                    {
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fclose (stream) >>>>>;
                    }
                  return <retval> = -1;
                }
              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (nread = BZ2_bzRead (&bzerr, bzf, (void *) &obuf, 5000)) >>>>>;
              {
                if (bzerr == -5)
                  {
                    {
                      {
                        if (ForceOverwrite == 1)
                          {
                            {
                              <<cleanup_point <<< Unknown tree: expr_stmt
  rewind (zStream) >>>>>;
                              while (1)
                                {
                                  {
                                    int c;

                                                                        int c;
                                    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (c = fgetc (zStream)) >>>>>;
                                    if (c == -1) goto <D.39508>;
                                    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) ungetc (c, zStream) >>>>>;
                                    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (nread = (int) fread ((void *) &obuf, 1, 5000, zStream)) >>>>>;
                                    if (<<cleanup_point ferror (zStream) != 0>>)
                                      {
                                        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (ret = testBZ2ErrorHandling (bzerr, bzf, streamNo)) >>>>>;
                                        if (zStream != stdin)
                                          {
                                            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fclose (zStream) >>>>>;
                                          }
                                        if (stream != stdout)
                                          {
                                            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fclose (stream) >>>>>;
                                          }
                                        if (ret != 0)
                                          {
                                            <<cleanup_point <<< Unknown tree: expr_stmt
  syncSetTerminateFlag (1) >>>>>;
                                          }
                                        return <retval> = ret;
                                      }
                                    if (nread > 0)
                                      {
                                        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fwrite ((const void *) &obuf, 1, (size_t) nread, stream) >>>>>;
                                      }
                                    if (<<cleanup_point ferror (stream) != 0>>)
                                      {
                                        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (ret = testBZ2ErrorHandling (bzerr, bzf, streamNo)) >>>>>;
                                        if (zStream != stdin)
                                          {
                                            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fclose (zStream) >>>>>;
                                          }
                                        if (stream != stdout)
                                          {
                                            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fclose (stream) >>>>>;
                                          }
                                        if (ret != 0)
                                          {
                                            <<cleanup_point <<< Unknown tree: expr_stmt
  syncSetTerminateFlag (1) >>>>>;
                                          }
                                        return <retval> = ret;
                                      }
                                  }
                                }
                              <D.39508>:;
                              goto closeok;
                            }
                          }
                      }
                    }
                  }
              }
              if ((bzerr == 0 || bzerr == 4) && nread > 0)
                {
                  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fwrite ((const void *) &obuf, 1, (size_t) nread, stream) >>>>>;
                }
              if (<<cleanup_point ferror (stream) != 0>>)
                {
                  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (ret = testBZ2ErrorHandling (bzerr, bzf, streamNo)) >>>>>;
                  if (zStream != stdin)
                    {
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fclose (zStream) >>>>>;
                    }
                  if (stream != stdout)
                    {
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fclose (stream) >>>>>;
                    }
                  if (ret != 0)
                    {
                      <<cleanup_point <<< Unknown tree: expr_stmt
  syncSetTerminateFlag (1) >>>>>;
                    }
                  return <retval> = ret;
                }
            }
          }
        <D.39506>:;
        if (bzerr != 4)
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (ret = testBZ2ErrorHandling (bzerr, bzf, streamNo)) >>>>>;
            if (zStream != stdin)
              {
                <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fclose (zStream) >>>>>;
              }
            if (stream != stdout)
              {
                <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fclose (stream) >>>>>;
              }
            if (ret != 0)
              {
                <<cleanup_point <<< Unknown tree: expr_stmt
  syncSetTerminateFlag (1) >>>>>;
              }
            return <retval> = ret;
          }
        <<cleanup_point <<< Unknown tree: expr_stmt
  BZ2_bzReadGetUnused (&bzerr, bzf, (void * *) &unusedTmp, &nUnused) >>>>>;
        if (bzerr != 0)
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) handle_error (1, 3, (const char *) "pbzip2: *ERROR: Unexpected error [bzerr=%d]. Aborting!\n", bzerr) >>>>>;
            return <retval> = 3;
          }
        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (i = 0) >>>>>;
        while (1)
          {
            if (i >= nUnused) goto <D.39510>;
            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (unused[i] = *(unusedTmp + (sizetype) i)) >>>>>;
            <<cleanup_point (void) i++ >>;
          }
        <D.39510>:;
        <<cleanup_point <<< Unknown tree: expr_stmt
  BZ2_bzReadClose (&bzerr, bzf) >>>>>;
        if (bzerr != 0)
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) handle_error (1, 3, (const char *) "pbzip2: *ERROR: Unexpected error [bzerr=%d]. Aborting!\n", bzerr) >>>>>;
            return <retval> = 3;
          }
        {
          if (nUnused == 0)
            {
              {
                int c;

                                int c;
                <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (c = fgetc (zStream)) >>>>>;
                if (c == -1) goto <D.39504>;
                <<cleanup_point <<< Unknown tree: expr_stmt
  (void) ungetc (c, zStream) >>>>>;
              }
            }
        }
      }
    }
  <D.39504>:;
  closeok:;
  if (<<cleanup_point ferror (zStream) != 0>>)
    {
      if (zStream != stdin)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fclose (zStream) >>>>>;
        }
      if (stream != stdout)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fclose (stream) >>>>>;
        }
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) handle_error (1, -1, (const char *) "pbzip2: *ERROR: Problem with input stream of file [%s]!  Skipping...\n", InFilename) >>>>>;
      return <retval> = -1;
    }
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (ret = do_fclose (zStream)) >>>>>;
  if (ret == -1)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) handle_error (1, -1, (const char *) "pbzip2: *ERROR: Problem closing file [%s]!  Skipping...\n", InFilename) >>>>>;
      return <retval> = -1;
    }
  if (<<cleanup_point ferror (stream) != 0>>)
    {
      if (stream != stdout)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fclose (stream) >>>>>;
        }
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) handle_error (1, -1, (const char *) "pbzip2: *ERROR: Problem with output stream of file [%s]!  Skipping...\n", InFilename) >>>>>;
      return <retval> = -1;
    }
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (ret = do_fflush (stream)) >>>>>;
  if (ret != 0)
    {
      if (stream != stdout)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fclose (stream) >>>>>;
        }
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) handle_error (1, -1, (const char *) "pbzip2: *ERROR: Problem with output stream of file [%s]!  Skipping...\n", InFilename) >>>>>;
      return <retval> = -1;
    }
  if (stream != stdout)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (ret = do_fclose (stream)) >>>>>;
      if (ret == -1)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) handle_error (1, -1, (const char *) "pbzip2: *ERROR: Problem closing file [%s]!  Skipping...\n", OutFilename) >>>>>;
          return <retval> = -1;
        }
    }
  <<cleanup_point <<< Unknown tree: expr_stmt
  syncSetProducerDone (1) >>>>>;
  return <retval> = 0;
}


;; Function ssize_t bufread(int, char*, size_t) (null)
;; enabled by -tree-original


{
  size_t bufr = 0;
  int ret;
  int rsize = (int) bsize;

  <<cleanup_point   size_t bufr = 0;>>;
    int ret;
    int rsize = (int) bsize;
  while (1)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (ret = (int) read (hf, (void *) buf, (size_t) rsize)) >>>>>;
      if (ret < 0)
        {
          return <retval> = (ssize_t) ret;
        }
      if (ret == 0)
        {
          return <retval> = (ssize_t) bufr;
        }
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (bufr = (size_t) ret + bufr) >>>>>;
      if (bufr == bsize)
        {
          return <retval> = (ssize_t) bsize;
        }
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (rsize = rsize - ret) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (buf = buf + (sizetype) ret) >>>>>;
    }
}


;; Function int producer(int, int, queue*) (null)
;; enabled by -tree-original


{
  char * FileData = 0B;
  size_t inSize = 0;
  int ret = 0;

  <<cleanup_point   char * FileData = 0B;>>;
  <<cleanup_point   size_t inSize = 0;>>;
  <<cleanup_point   int ret = 0;>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  safe_mutex_lock (&ProgressIndicatorsMutex) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (NumBlocks = 0) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (InBytesProduced = 0) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  safe_mutex_unlock (&ProgressIndicatorsMutex) >>>>>;
  while (1)
    {
      {
        struct outBuff * queueElement;

        if (<<cleanup_point syncGetTerminateFlag () != 0>>)
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) close (hInfile) >>>>>;
            return <retval> = -1;
          }
        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (inSize = (size_t) blockSize) >>>>>;
        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (FileData = 0B) >>>>>;
        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (FileData = (char *) operator new [] ((size_t) NON_LVALUE_EXPR <SAVE_EXPR <(sizetype) inSize>>, (const struct nothrow_t &) &nothrow)) >>>>>;
        if (FileData == 0B)
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) close (hInfile) >>>>>;
            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) handle_error (1, -1, (const char *) "pbzip2: *ERROR: Could not allocate memory (FileData)!  Aborting...\n") >>>>>;
            return <retval> = -1;
          }
        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (ret = (int) bufread (hInfile, FileData, inSize)) >>>>>;
        if (ret == 0)
          {
            if (FileData != 0B)
              {
                <<cleanup_point <<< Unknown tree: expr_stmt
  (if (FileData != 0B)
    {
      operator delete [] ((void *) FileData);
    }
  else
    {
      0
    }) >>>>>;
              }
            goto <D.39532>;
          }
        else
          {
            if (ret < 0)
              {
                <<cleanup_point <<< Unknown tree: expr_stmt
  (void) close (hInfile) >>>>>;
                if (FileData != 0B)
                  {
                    <<cleanup_point <<< Unknown tree: expr_stmt
  (if (FileData != 0B)
    {
      operator delete [] ((void *) FileData);
    }
  else
    {
      0
    }) >>>>>;
                  }
                <<cleanup_point <<< Unknown tree: expr_stmt
  (void) handle_error (1, -1, (const char *) "pbzip2: *ERROR: Could not read from file!  Aborting...\n") >>>>>;
                return <retval> = -1;
              }
          }
        if ((size_t) ret != inSize)
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (inSize = (size_t) ret) >>>>>;
          }
        <<cleanup_point <<< Unknown tree: expr_stmt
  safe_mutex_lock (fifo->mut) >>>>>;
        while (1)
          {
            if (fifo->full == 0) goto <D.39534>;
            <<cleanup_point <<< Unknown tree: expr_stmt
  safe_cond_wait (fifo->notFull, fifo->mut) >>>>>;
            if (<<cleanup_point syncGetTerminateFlag () != 0>>)
              {
                <<cleanup_point <<< Unknown tree: expr_stmt
  (void) pthread_mutex_unlock (fifo->mut) >>>>>;
                <<cleanup_point <<< Unknown tree: expr_stmt
  (void) close (hInfile) >>>>>;
                return <retval> = -1;
              }
          }
        <D.39534>:;
                struct outBuff * queueElement;
        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (queueElement = TARGET_EXPR <D.39531, operator new (40, (const struct nothrow_t &) &nothrow)>;, (struct outBuff *) D.39531 != 0B ? try
    {
      outBuff::outBuff ((struct outBuff *) D.39531, FileData, (unsigned int) inSize, NumBlocks, 0, 0, 1, 0B);
    }
  catch
    {
      operator delete (D.39531, (const struct nothrow_t &) &nothrow);
    }, (struct outBuff *) D.39531; : (struct outBuff *) D.39531;) >>>>>;
        if (queueElement == 0B)
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) close (hInfile) >>>>>;
            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) handle_error (1, -1, (const char *) "pbzip2: *ERROR: Could not allocate memory (queueElement)!  Aborting...\n") >>>>>;
            return <retval> = -1;
          }
        <<cleanup_point <<< Unknown tree: expr_stmt
  queue::add (NON_LVALUE_EXPR <fifo>, queueElement) >>>>>;
        <<cleanup_point <<< Unknown tree: expr_stmt
  safe_cond_signal (fifo->notEmpty) >>>>>;
        <<cleanup_point <<< Unknown tree: expr_stmt
  safe_mutex_lock (&ProgressIndicatorsMutex) >>>>>;
        <<cleanup_point <<< Unknown tree: expr_stmt
  (void)  ++NumBlocks >>>>>;
        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (InBytesProduced = (off_t) ((long unsigned int) InBytesProduced + inSize)) >>>>>;
        <<cleanup_point <<< Unknown tree: expr_stmt
  safe_mutex_unlock (&ProgressIndicatorsMutex) >>>>>;
        <<cleanup_point <<< Unknown tree: expr_stmt
  safe_mutex_unlock (fifo->mut) >>>>>;
      }
    }
  <D.39532>:;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) close (hInfile) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  syncSetProducerDone (1) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  safe_mutex_lock (fifo->mut) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  safe_cond_broadcast (fifo->notEmpty) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  safe_mutex_unlock (fifo->mut) >>>>>;
  return <retval> = 0;
}


;; Function void* consumer(void*) (null)
;; enabled by -tree-original


{
  struct queue * fifo;
  struct outBuff * fileData = 0B;
  char * CompressedData = 0B;
  unsigned int outSize = 0;
  int ret = -1;

    struct queue * fifo;
  <<cleanup_point   struct outBuff * fileData = 0B;>>;
  <<cleanup_point   char * CompressedData = 0B;>>;
  <<cleanup_point   unsigned int outSize = 0;>>;
  <<cleanup_point   int ret = -1;>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (fifo = (struct queue *) q) >>>>>;
  {
    while (1)
      {
        {
          struct outBuff outBlock;

          if (<<cleanup_point syncGetTerminateFlag () != 0>>)
            {
              return <retval> = 0B;
            }
          <<cleanup_point <<< Unknown tree: expr_stmt
  safe_mutex_lock (fifo->mut) >>>>>;
          while (1)
            {
              if (<<cleanup_point fifo->empty == 0 && queue::remove (NON_LVALUE_EXPR <fifo>, (struct ElementType * &) &fileData) == 1>>) goto <D.39548>;
              if (<<cleanup_point fifo->empty != 0 && (syncGetProducerDone () == 1 || syncGetTerminateFlag () != 0)>>)
                {
                  <<cleanup_point <<< Unknown tree: expr_stmt
  safe_mutex_unlock (fifo->mut) >>>>>;
                  return <retval> = 0B;
                }
              <<cleanup_point <<< Unknown tree: expr_stmt
  safe_cond_wait (fifo->notEmpty, fifo->mut) >>>>>;
            }
          <D.39548>:;
          <<cleanup_point <<< Unknown tree: expr_stmt
  safe_cond_signal (fifo->notFull) >>>>>;
          <<cleanup_point <<< Unknown tree: expr_stmt
  safe_mutex_unlock (fifo->mut) >>>>>;
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (outSize = (unsigned int) ((double) fileData->bufSize * 1.0100000000000000088817841970012523233890533447265625e+0 + 6.0e+2)) >>>>>;
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (CompressedData = (char *) operator new [] ((size_t) NON_LVALUE_EXPR <SAVE_EXPR <(sizetype) outSize>>, (const struct nothrow_t &) &nothrow)) >>>>>;
          if (CompressedData == 0B)
            {
              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) handle_error (1, -1, (const char *) "pbzip2: *ERROR: Could not allocate memory (CompressedData)!  Aborting...\n") >>>>>;
              return <retval> = 0B;
            }
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (ret = BZ2_bzBuffToBuffCompress (CompressedData, &outSize, fileData->buf, fileData->bufSize, BWTblockSize, Verbosity, 30)) >>>>>;
          if (ret != 0)
            {
              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) handle_error (1, -1, (const char *) "pbzip2: *ERROR during compression: %d!  Aborting...\n", ret) >>>>>;
              return <retval> = 0B;
            }
          <<cleanup_point <<< Unknown tree: expr_stmt
  disposeMemory<char> ((char * &) &fileData->buf) >>>>>;
                    struct outBuff outBlock;
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (outBlock = <<< Unknown tree: aggr_init_expr
  11
  __comp_ctor 
  D.39545
  (struct outBuff *) <<< Unknown tree: void_cst >>>
  CompressedData
  outSize
  fileData->blockNumber
  0
  fileData->bufSize
  1
  0B >>>) >>>>>;
          if (<<cleanup_point outputBufferAdd ((const struct outBuff &) &outBlock, (const char *) "consumer") == 0B>>)
            {
              return <retval> = 0B;
            }
          <<cleanup_point <<< Unknown tree: expr_stmt
  operator delete ((void *) fileData, 40) >>>>>;
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (fileData = 0B) >>>>>;
        }
      }
  }
  return <retval> = 0B;
}


;; Function int mutexesInit() (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void) (OutMutex = (union pthread_mutex_t *) operator new (40, (const struct nothrow_t &) &nothrow)) >>>>>;
if (OutMutex == 0B)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "pbzip2: *ERROR: Could not allocate memory (OutMutex)!  Aborting...\n") >>>>>;
    return <retval> = 1;
  }
<<cleanup_point <<< Unknown tree: expr_stmt
  (void) pthread_mutex_init (OutMutex, 0B) >>>>>;
<<cleanup_point <<< Unknown tree: expr_stmt
  (void) (ProducerDoneMutex = (union pthread_mutex_t *) operator new (40, (const struct nothrow_t &) &nothrow)) >>>>>;
if (ProducerDoneMutex == 0B)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "pbzip2: *ERROR: Could not allocate memory (ProducerDoneMutex)!  Aborting...\n") >>>>>;
    return <retval> = 1;
  }
<<cleanup_point <<< Unknown tree: expr_stmt
  (void) pthread_mutex_init (ProducerDoneMutex, 0B) >>>>>;
return <retval> = 0;


;; Function void mutexesDelete() (null)
;; enabled by -tree-original


if (OutMutex != 0B)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) pthread_mutex_destroy (OutMutex) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  operator delete ((void *) OutMutex, 40) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (OutMutex = 0B) >>>>>;
  }
if (ProducerDoneMutex != 0B)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) pthread_mutex_destroy (ProducerDoneMutex) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  operator delete ((void *) ProducerDoneMutex, 40) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (ProducerDoneMutex = 0B) >>>>>;
  }


;; Function queue* queueInit(int) (null)
;; enabled by -tree-original


{
  struct queue * q;

    struct queue * q;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (QUEUESIZE = queueSize) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (q = TARGET_EXPR <D.39558, operator new (96, (const struct nothrow_t &) &nothrow)>;, (struct queue *) D.39558 != 0B ? try
    {
      queue::queue ((struct queue *) D.39558);
    }
  catch
    {
      operator delete (D.39558, (const struct nothrow_t &) &nothrow);
    }, (struct queue *) D.39558; : (struct queue *) D.39558;) >>>>>;
  if (q == 0B)
    {
      return <retval> = 0B;
    }
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (q->qData = (struct ElementType * *) operator new [] (SAVE_EXPR <(sizetype) queueSize> <= 1152921504606846975 ? (size_t) (SAVE_EXPR <(sizetype) queueSize> * 8) : (size_t) __cxa_throw_bad_array_new_length (), (const struct nothrow_t &) &nothrow)) >>>>>;
  if (q->qData == 0B)
    {
      return <retval> = 0B;
    }
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (q->size = (long int) queueSize) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  queue::clear (NON_LVALUE_EXPR <q>) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (q->mut = 0B) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (q->mut = (union pthread_mutex_t *) operator new (40, (const struct nothrow_t &) &nothrow)) >>>>>;
  if (q->mut == 0B)
    {
      return <retval> = 0B;
    }
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) pthread_mutex_init (q->mut, 0B) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (q->notFull = 0B) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (q->notFull = (union pthread_cond_t *) operator new (48, (const struct nothrow_t &) &nothrow)) >>>>>;
  if (q->notFull == 0B)
    {
      return <retval> = 0B;
    }
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) pthread_cond_init (q->notFull, 0B) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (q->notEmpty = 0B) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (q->notEmpty = (union pthread_cond_t *) operator new (48, (const struct nothrow_t &) &nothrow)) >>>>>;
  if (q->notEmpty == 0B)
    {
      return <retval> = 0B;
    }
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) pthread_cond_init (q->notEmpty, 0B) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (q->consumers = 0B) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (q->consumers = (pthread_t *) operator new [] (SAVE_EXPR <(sizetype) queueSize> <= 1152921504606846975 ? (size_t) (SAVE_EXPR <(sizetype) queueSize> * 8) : (size_t) __cxa_throw_bad_array_new_length (), (const struct nothrow_t &) &nothrow)) >>>>>;
  if (q->consumers == 0B)
    {
      return <retval> = 0B;
    }
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (notTooMuchNumBuffered = 0B) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (notTooMuchNumBuffered = (union pthread_cond_t *) operator new (48, (const struct nothrow_t &) &nothrow)) >>>>>;
  if (notTooMuchNumBuffered == 0B)
    {
      return <retval> = 0B;
    }
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) pthread_cond_init (notTooMuchNumBuffered, 0B) >>>>>;
  return <retval> = q;
}


;; Function void queueDelete(queue*) (null)
;; enabled by -tree-original


if (q == 0B)
  {
    return;
  }
if (q->mut != 0B)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) pthread_mutex_destroy (q->mut) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  operator delete ((void *) q->mut, 40) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (q->mut = 0B) >>>>>;
  }
if (q->notFull != 0B)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) pthread_cond_destroy (q->notFull) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  operator delete ((void *) q->notFull, 48) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (q->notFull = 0B) >>>>>;
  }
if (q->notEmpty != 0B)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) pthread_cond_destroy (q->notEmpty) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  operator delete ((void *) q->notEmpty, 48) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (q->notEmpty = 0B) >>>>>;
  }
<<cleanup_point <<< Unknown tree: expr_stmt
  (if (q->consumers != 0B)
    {
      operator delete [] ((void *) q->consumers);
    }
  else
    {
      0
    }) >>>>>;
<<cleanup_point <<< Unknown tree: expr_stmt
  (if (q->qData != 0B)
    {
      operator delete [] ((void *) q->qData);
    }
  else
    {
      0
    }) >>>>>;
<<cleanup_point <<< Unknown tree: expr_stmt
  operator delete ((void *) q, 96) >>>>>;
<<cleanup_point <<< Unknown tree: expr_stmt
  (void) (q = 0B) >>>>>;
if (notTooMuchNumBuffered != 0B)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) pthread_cond_destroy (notTooMuchNumBuffered) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  operator delete ((void *) notTooMuchNumBuffered, 48) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (notTooMuchNumBuffered = 0B) >>>>>;
  }
return;


;; Function void outputBufferInit(size_t) (null)
;; enabled by -tree-original


{
  struct outBuff emptyElement;

  <<cleanup_point <<< Unknown tree: expr_stmt
  safe_mutex_lock (OutMutex) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (NextBlockToWrite = 0) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (OutBufferPosToWrite = 0) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (NumBufferedBlocks = 0) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (NumBufferedTailBlocks = 0) >>>>>;
    struct outBuff emptyElement;
  <<cleanup_point <<< Unknown tree: expr_stmt
  outBuff::outBuff (&emptyElement, 0B, 0, 0, 0, 0, 1, 0B) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (emptyElement.buf = 0B) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (emptyElement.bufSize = 0) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::vector<outBuff>::assign (&OutputBuffer, size, (const struct value_type &) &emptyElement) >>>>>;
  if (<<cleanup_point std::vector<outBuff>::size (&OutputBuffer) != size>>)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "pbzip2: *ERROR: Could not initialize (OutputBuffer); size=%lu!  Aborting...\n", NON_LVALUE_EXPR <size>) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  safe_mutex_unlock (OutMutex) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  exit (1) >>>>>;
    }
  <<cleanup_point <<< Unknown tree: expr_stmt
  safe_mutex_unlock (OutMutex) >>>>>;
}


;; Function size_t getOutputBufferPos(int) (null)
;; enabled by -tree-original


{
  size_t outBuffPos = ((size_t) blockNum + OutBufferPosToWrite) - (size_t) NextBlockToWrite;

    size_t outBuffPos = ((size_t) blockNum + OutBufferPosToWrite) - (size_t) NextBlockToWrite;
  if (outBuffPos >= NumBufferedBlocksMax)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (outBuffPos = outBuffPos - NumBufferedBlocksMax) >>>>>;
    }
  return <retval> = outBuffPos;
}


;; Function outBuff* outputBufferSeqAddNext(outBuff*, outBuff*) (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  safe_mutex_lock (OutMutex) >>>>>;
while (1)
  {
    if (NumBufferedTailBlocks < NumBufferedBlocksMax || preveElement->buf == 0B) goto <D.39602>;
    if (<<cleanup_point syncGetTerminateFlag () != 0>>)
      {
        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) pthread_mutex_unlock (OutMutex) >>>>>;
        return <retval> = 0B;
      }
    if (LastGoodBlock != -1 && newElement->blockNumber > LastGoodBlock)
      {
        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) pthread_mutex_unlock (OutMutex) >>>>>;
        return <retval> = 0B;
      }
    <<cleanup_point <<< Unknown tree: expr_stmt
  safe_cond_wait (notTooMuchNumBuffered, OutMutex) >>>>>;
  }
<D.39602>:;
<<cleanup_point <<< Unknown tree: expr_stmt
  (void) (preveElement->next = newElement) >>>>>;
<<cleanup_point <<< Unknown tree: expr_stmt
  (void)  ++NumBufferedTailBlocks >>>>>;
if (preveElement->buf == 0B)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  safe_cond_signal (&OutBufferHeadNotEmpty) >>>>>;
  }
<<cleanup_point <<< Unknown tree: expr_stmt
  safe_mutex_unlock (OutMutex) >>>>>;
return <retval> = newElement;


;; Function outBuff* outputBufferAdd(const outBuff&, const char*) (null)
;; enabled by -tree-original


{
  int dist = (int) ((unsigned int) element->blockNumber - (unsigned int) NumBufferedBlocksMax);
  size_t outBuffPos;

  <<cleanup_point <<< Unknown tree: expr_stmt
  safe_mutex_lock (OutMutex) >>>>>;
    int dist = (int) ((unsigned int) element->blockNumber - (unsigned int) NumBufferedBlocksMax);
  while (1)
    {
      if (dist < NextBlockToWrite) goto <D.39616>;
      if (<<cleanup_point syncGetTerminateFlag () != 0>>)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) pthread_mutex_unlock (OutMutex) >>>>>;
          return <retval> = 0B;
        }
      if (LastGoodBlock != -1 && (int) element->blockNumber > LastGoodBlock)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) pthread_mutex_unlock (OutMutex) >>>>>;
          return <retval> = 0B;
        }
      <<cleanup_point <<< Unknown tree: expr_stmt
  safe_cond_wait (notTooMuchNumBuffered, OutMutex) >>>>>;
    }
  <D.39616>:;
    size_t outBuffPos;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (outBuffPos = getOutputBufferPos ((int) element->blockNumber)) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*(struct value_type *) SAVE_EXPR <std::vector<outBuff>::operator[] (&OutputBuffer, outBuffPos)> = *(const struct outBuff &) element) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void)  ++NumBufferedBlocks >>>>>;
  if ((int) element->blockNumber == NextBlockToWrite)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  safe_cond_signal (&OutBufferHeadNotEmpty) >>>>>;
    }
  <<cleanup_point <<< Unknown tree: expr_stmt
  safe_mutex_unlock (OutMutex) >>>>>;
  <<cleanup_point return <retval> = (struct outBuff *) std::vector<outBuff>::operator[] (&OutputBuffer, outBuffPos)>>;
}


;; Function int testBZ2ErrorHandling(int, BZFILE*, int) (null)
;; enabled by -tree-original


{
  int bzerr_dummy;

    int bzerr_dummy;
  <<cleanup_point <<< Unknown tree: expr_stmt
  BZ2_bzReadClose (&bzerr_dummy, bzf) >>>>>;
  switch (bzerr)
    {
      case -9:;
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "pbzip2: *ERROR: Integers are not the right size for libbzip2. Aborting!\n") >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  exit (3) >>>>>;
      case -6:;
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "pbzip2: *ERROR: Integers are not the right size for libbzip2. Aborting!\n") >>>>>;
      return <retval> = 1;
      case -4:;
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "pbzip2: *ERROR: Data integrity (CRC) error in data!  Skipping...\n") >>>>>;
      return <retval> = -1;
      case -3:;
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "pbzip2: *ERROR: Could NOT allocate enough memory. Aborting!\n") >>>>>;
      return <retval> = 1;
      case -7:;
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "pbzip2: *ERROR: File ends unexpectedly!  Skipping...\n") >>>>>;
      return <retval> = -1;
      case -5:;
      if (streamNo == 1)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "pbzip2: *ERROR: Bad magic number (file not created by bzip2)!  Skipping...\n") >>>>>;
          return <retval> = -1;
        }
      else
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "pbzip2: *WARNING: Trailing garbage after EOF ignored!\n") >>>>>;
          return <retval> = 0;
        }
      default:;
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "pbzip2: *ERROR: Unexpected error. Aborting!\n") >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  exit (3) >>>>>;
    }
  return <retval> = 0;
}


;; Function int testCompressedData(char*) (null)
;; enabled by -tree-original


{
  struct FILE * zStream = 0B;
  int ret = 0;
  BZFILE * bzf = 0B;
  unsigned char obuf[5000];
  unsigned char unused[5000];
  unsigned char * unusedTmp;
  int bzerr;
  int nread;
  int streamNo;
  int nUnused;
  int i;

  <<cleanup_point   struct FILE * zStream = 0B;>>;
  <<cleanup_point   int ret = 0;>>;
  <<cleanup_point   BZFILE * bzf = 0B;>>;
    unsigned char obuf[5000];
    unsigned char unused[5000];
    unsigned char * unusedTmp;
    int bzerr;
    int nread;
    int streamNo;
    int nUnused;
    int i;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (nUnused = 0) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (streamNo = 0) >>>>>;
  if (strcmp ((const char *) fileName, (const char *) "-") != 0)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (zStream = fopen ((const char *) fileName, (const char *) "rb")) >>>>>;
      if (zStream == 0B)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  pbzip2::ErrorContext::saveError (pbzip2::ErrorContext::getInstance ()) >>>>>;
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) handle_error (0, -1, (const char *) "pbzip2: *ERROR: Could not open input file [%s]!  Skipping...\n", fileName) >>>>>;
          return <retval> = -1;
        }
    }
  else
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (zStream = stdin) >>>>>;
    }
  if (<<cleanup_point ferror (zStream) != 0>>)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) handle_error (0, -1, (const char *) "pbzip2: *ERROR: Problem with stream of file [%s]!  Skipping...\n", fileName) >>>>>;
      if (zStream != stdin)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) verbose_fclose (zStream, (const char *) fileName) >>>>>;
        }
      return <retval> = -1;
    }
  while (1)
    {
      {
        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (bzf = BZ2_bzReadOpen (&bzerr, zStream, Verbosity, 0, (void *) &unused, nUnused)) >>>>>;
        if (bzf == 0B || bzerr != 0)
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (ret = testBZ2ErrorHandling (bzerr, bzf, streamNo)) >>>>>;
            if (zStream != stdin)
              {
                <<cleanup_point <<< Unknown tree: expr_stmt
  (void) verbose_fclose (zStream, (const char *) fileName) >>>>>;
              }
            return <retval> = ret;
          }
        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) streamNo++  >>>>>;
        while (1)
          {
            if (bzerr != 0) goto <D.39649>;
            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (nread = BZ2_bzRead (&bzerr, bzf, (void *) &obuf, 5000)) >>>>>;
            if (bzerr == -5)
              {
                <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (ret = testBZ2ErrorHandling (bzerr, bzf, streamNo)) >>>>>;
                if (zStream != stdin)
                  {
                    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) verbose_fclose (zStream, (const char *) fileName) >>>>>;
                  }
                return <retval> = ret;
              }
          }
        <D.39649>:;
        if (bzerr != 4)
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (ret = testBZ2ErrorHandling (bzerr, bzf, streamNo)) >>>>>;
            if (zStream != stdin)
              {
                <<cleanup_point <<< Unknown tree: expr_stmt
  (void) verbose_fclose (zStream, (const char *) fileName) >>>>>;
              }
            return <retval> = ret;
          }
        <<cleanup_point <<< Unknown tree: expr_stmt
  BZ2_bzReadGetUnused (&bzerr, bzf, (void * *) &unusedTmp, &nUnused) >>>>>;
        if (bzerr != 0)
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "pbzip2: *ERROR: Unexpected error. Aborting!\n") >>>>>;
            <<cleanup_point <<< Unknown tree: expr_stmt
  exit (3) >>>>>;
          }
        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (i = 0) >>>>>;
        while (1)
          {
            if (i >= nUnused) goto <D.39651>;
            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (unused[i] = *(unusedTmp + (sizetype) i)) >>>>>;
            <<cleanup_point (void) i++ >>;
          }
        <D.39651>:;
        <<cleanup_point <<< Unknown tree: expr_stmt
  BZ2_bzReadClose (&bzerr, bzf) >>>>>;
        if (bzerr != 0)
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "pbzip2: *ERROR: Unexpected error. Aborting!\n") >>>>>;
            <<cleanup_point <<< Unknown tree: expr_stmt
  exit (3) >>>>>;
          }
        {
          if (nUnused == 0)
            {
              {
                int c;

                                int c;
                <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (c = fgetc (zStream)) >>>>>;
                if (c == -1)
                  {
                    goto <D.39647>;
                  }
                else
                  {
                    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) ungetc (c, zStream) >>>>>;
                  }
              }
            }
        }
      }
    }
  <D.39647>:;
  if (<<cleanup_point ferror (zStream) != 0>>)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  pbzip2::ErrorContext::saveError (pbzip2::ErrorContext::getInstance ()) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) handle_error (0, -1, (const char *) "pbzip2: *ERROR: Problem with stream of file [%s]!  Skipping...\n", fileName) >>>>>;
      if (zStream != stdin)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) verbose_fclose (zStream, (const char *) fileName) >>>>>;
        }
      return <retval> = -1;
    }
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (ret = verbose_fclose (zStream, (const char *) fileName)) >>>>>;
  if (ret == -1)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "pbzip2: *ERROR: Problem closing file [%s]!  Skipping...\n", fileName) >>>>>;
      return <retval> = -1;
    }
  return <retval> = 0;
}


;; Function int getFileMetaData(const char*) (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = stat (fileName, &fileMetaData)>>;


;; Function int writeFileMetaData(const char*) (null)
;; enabled by -tree-original


{
  int ret = 0;
  struct utimbuf uTimBuf;

  <<cleanup_point   int ret = 0;>>;
    struct utimbuf uTimBuf;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (uTimBuf.actime = fileMetaData.st_atim.tv_sec) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (uTimBuf.modtime = fileMetaData.st_mtim.tv_sec) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (ret = chmod (fileName, fileMetaData.st_mode)) >>>>>;
  if (ret != 0)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  pbzip2::ErrorContext::saveError (pbzip2::ErrorContext::getInstance ()) >>>>>;
      return <retval> = ret;
    }
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (ret = utime (fileName, (const struct utimbuf *) &uTimBuf)) >>>>>;
  if (ret != 0)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  pbzip2::ErrorContext::saveError (pbzip2::ErrorContext::getInstance ()) >>>>>;
      return <retval> = ret;
    }
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (ret = chown (fileName, fileMetaData.st_uid, fileMetaData.st_gid)) >>>>>;
  if (ret != 0)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  pbzip2::ErrorContext::saveError (pbzip2::ErrorContext::getInstance ()) >>>>>;
      if (<<cleanup_point geteuid () == 0>>)
        {
          return <retval> = ret;
        }
    }
  return <retval> = 0;
}


;; Function int detectCPUs() (null)
;; enabled by -tree-original


{
  int ncpu;

    int ncpu;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (ncpu = 1) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (ncpu = (int) sysconf (84)) >>>>>;
  if (ncpu <= 0)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (ncpu = 1) >>>>>;
    }
  return <retval> = ncpu;
}


;; Function void banner() (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "Parallel BZIP2 v1.1.11 [Dec 12, 2014]\n") >>>>>;
<<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "By: Jeff Gilchrist [http://compression.ca]\n") >>>>>;
<<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "Major contributions: Yavor Nikolov [http://javornikolov.wordpress.com]\n") >>>>>;
<<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "Uses libbzip2 by Julian Seward\n") >>>>>;
return;


;; Function void usage(char*, const char*) (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  banner () >>>>>;
if (strncmp (reason, (const char *) "HELP", 4) == 0)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "\n") >>>>>;
  }
else
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "\nInvalid command line: %s.  Aborting...\n\n", reason) >>>>>;
  }
<<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "Usage: %s [-1 .. -9] [-b#cdfhklm#p#qrS#tVz] <filename> <filename2> <filenameN>\n", progname) >>>>>;
<<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) " -1 .. -9        set BWT block size to 100k .. 900k (default 900k)\n") >>>>>;
<<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) " -b#             Block size in 100k steps (default 9 = 900k)\n") >>>>>;
<<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) " -c,--stdout     Output to standard out (stdout)\n") >>>>>;
<<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) " -d,--decompress Decompress file\n") >>>>>;
<<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) " -f,--force      Overwrite existing output file\n") >>>>>;
<<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) " -h,--help       Print this help message\n") >>>>>;
<<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) " -k,--keep       Keep input file, don\'t delete\n") >>>>>;
<<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) " -l,--loadavg    Load average determines max number processors to use\n") >>>>>;
<<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) " -m#             Maximum memory usage in 1MB steps (default 100 = 100MB)\n") >>>>>;
<<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) " -p#             Number of processors to use (default") >>>>>;
<<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) ": autodetect [%d])\n", detectCPUs ()) >>>>>;
<<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) " -q,--quiet      Quiet mode (default)\n") >>>>>;
<<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) " -r,--read       Read entire input file into RAM and split between processors\n") >>>>>;
<<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) " -S#             Child thread stack size in 1KB steps (default stack size if unspecified)\n") >>>>>;
<<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) " -t,--test       Test compressed file integrity\n") >>>>>;
<<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) " -v,--verbose    Verbose mode\n") >>>>>;
<<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) " -V,--version    Display version info for pbzip2 then exit\n") >>>>>;
<<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) " -z,--compress   Compress file (default)\n") >>>>>;
<<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) " --ignore-trailing-garbage=# Ignore trailing garbage flag (1 - ignored; 0 - forbidden)\n") >>>>>;
<<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "\n") >>>>>;
<<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "If no file names are given, pbzip2 compresses or decompresses from standard input to standard output.\n") >>>>>;
<<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "\n") >>>>>;
<<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "Example: pbzip2 -b15vk myfile.tar\n") >>>>>;
<<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "Example: pbzip2 -p4 -r -5 myfile.tar second*.txt\n") >>>>>;
<<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "Example: tar cf myfile.tar.bz2 --use-compress-prog=pbzip2 dir_to_compress/\n") >>>>>;
<<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "Example: pbzip2 -d -m500 myfile.tar.bz2\n") >>>>>;
<<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "Example: pbzip2 -dc myfile.tar.bz2 | tar x\n") >>>>>;
<<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "Example: pbzip2 -c < myfile.txt > myfile.txt.bz2 \n") >>>>>;
<<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "\n") >>>>>;
<<cleanup_point <<< Unknown tree: expr_stmt
  exit (-1) >>>>>;


;; Function static constexpr bool __gnu_cxx::__alloc_traits<_Alloc>::_S_propagate_on_move_assign() [with _Alloc = std::allocator<char>] (null)
;; enabled by -tree-original


return <retval> = 1;


;; Function static constexpr bool __gnu_cxx::__alloc_traits<_Alloc>::_S_always_equal() [with _Alloc = std::allocator<char>] (null)
;; enabled by -tree-original


return <retval> = 1;


;; Function static constexpr bool __gnu_cxx::__alloc_traits<_Alloc>::_S_nothrow_move() [with _Alloc = std::allocator<char>] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = 1>>;


;; Function int main(int, char**) (null)
;; enabled by -tree-original


{
  struct queue * fifo;
  pthread_t output;
  char * * FileList = 0B;
  char * InFilename = 0B;
  char * progName = 0B;
  char * progNamePos = 0B;
  char bz2Header[11] = "BZh91AY&SY";
  struct string outFilename;
  char cmdLineTemp[2048];
  unsigned char tmpBuff[50];
  char stdinFile[2] = "-";
  struct timeval tvStartTime;
  struct timeval tvStopTime;
  struct timezone tz;
  double loadAverage = 0.0;
  double loadAvgArray[3];
  int useLoadAverage = 0;
  int numCPUtotal = 0;
  int numCPUidle = 0;
  double timeCalc = 0.0;
  double timeStart = 0.0;
  double timeStop = 0.0;
  int cmdLineTempCount = 0;
  int readEntireFile = 0;
  int zeroByteFile = 0;
  int hInfile = -1;
  int hOutfile = -1;
  int numBlocks = 0;
  int blockSize = 900000;
  int maxMemory = 100000000;
  int maxMemorySwitch = 0;
  int decompress = 0;
  int compress = 0;
  int testFile = 0;
  int errLevel = 0;
  int noThreads = 0;
  int keep = 0;
  int force = 0;
  int ret = 0;
  int fileLoop;
  size_t i;
  size_t j;
  size_t k;
  bool switchedMtToSt = 0;
  int mutexesInitRet;

    struct queue * fifo;
    pthread_t output;
  <<cleanup_point   char * * FileList = 0B;>>;
  <<cleanup_point   char * InFilename = 0B;>>;
  <<cleanup_point   char * progName = 0B;>>;
  <<cleanup_point   char * progNamePos = 0B;>>;
  <<cleanup_point   char bz2Header[11] = "BZh91AY&SY";>>;
    struct string outFilename;
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char>::basic_string (&outFilename) >>>>>;
  try
    {
            char cmdLineTemp[2048];
            unsigned char tmpBuff[50];
      <<cleanup_point       char stdinFile[2] = "-";>>;
            struct timeval tvStartTime;
            struct timeval tvStopTime;
            struct timezone tz;
      <<cleanup_point       double loadAverage = 0.0;>>;
            double loadAvgArray[3];
      <<cleanup_point       int useLoadAverage = 0;>>;
      <<cleanup_point       int numCPUtotal = 0;>>;
      <<cleanup_point       int numCPUidle = 0;>>;
      <<cleanup_point       double timeCalc = 0.0;>>;
      <<cleanup_point       double timeStart = 0.0;>>;
      <<cleanup_point       double timeStop = 0.0;>>;
      <<cleanup_point       int cmdLineTempCount = 0;>>;
      <<cleanup_point       int readEntireFile = 0;>>;
      <<cleanup_point       int zeroByteFile = 0;>>;
      <<cleanup_point       int hInfile = -1;>>;
      <<cleanup_point       int hOutfile = -1;>>;
      <<cleanup_point       int numBlocks = 0;>>;
      <<cleanup_point       int blockSize = 900000;>>;
      <<cleanup_point       int maxMemory = 100000000;>>;
      <<cleanup_point       int maxMemorySwitch = 0;>>;
      <<cleanup_point       int decompress = 0;>>;
      <<cleanup_point       int compress = 0;>>;
      <<cleanup_point       int testFile = 0;>>;
      <<cleanup_point       int errLevel = 0;>>;
      <<cleanup_point       int noThreads = 0;>>;
      <<cleanup_point       int keep = 0;>>;
      <<cleanup_point       int force = 0;>>;
      <<cleanup_point       int ret = 0;>>;
            int fileLoop;
            size_t i;
            size_t j;
            size_t k;
      <<cleanup_point       bool switchedMtToSt = 0;>>;
      if (<<cleanup_point pbzip2::ErrorContext::getInstance () == 0B>>)
        {
          return <retval> = 1;
        }
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) gettimeofday (&tvStartTime, (void *) &tz) >>>>>;
      if (argc <= 1)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (OutputStdOut = 1) >>>>>;
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (keep = 1) >>>>>;
        }
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (progName = *NON_LVALUE_EXPR <argv>) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (progNamePos = *NON_LVALUE_EXPR <argv>) >>>>>;
      while (1)
        {
          if (*NON_LVALUE_EXPR <progNamePos> == 0) goto <D.39871>;
          if (*NON_LVALUE_EXPR <progNamePos> == 47)
            {
              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (progName = progNamePos + 1) >>>>>;
            }
          <<cleanup_point (void) progNamePos++ >>;
        }
      <D.39871>:;
      if (strstr (progName, (const char *) "unzip") != 0B || strstr (progName, (const char *) "UNZIP") != 0B)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (decompress = 1) >>>>>;
        }
      if (strstr (progName, (const char *) "zcat") != 0B || strstr (progName, (const char *) "ZCAT") != 0B)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (decompress = OutputStdOut = keep = 1) >>>>>;
        }
      if (((((strcmp ((const char *) progName, (const char *) "bzip2") == 0 || strcmp ((const char *) progName, (const char *) "BZIP2") == 0) || strcmp ((const char *) progName, (const char *) "bunzip2") == 0) || strcmp ((const char *) progName, (const char *) "BUNZIP2") == 0) || strcmp ((const char *) progName, (const char *) "bzcat") == 0) || strcmp ((const char *) progName, (const char *) "BZCAT") == 0)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (IgnoreTrailingGarbageFlag = 1) >>>>>;
        }
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (FileListCount = 0) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (FileList = (char * *) operator new [] (SAVE_EXPR <(sizetype) argc> <= 1152921504606846975 ? (size_t) (SAVE_EXPR <(sizetype) argc> * 8) : (size_t) __cxa_throw_bad_array_new_length (), (const struct nothrow_t &) &nothrow)) >>>>>;
      if (FileList == 0B)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "pbzip2: *ERROR: Not enough memory!  Aborting...\n") >>>>>;
          return <retval> = 1;
        }
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (maxMemory = 100000000) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (NumBufferedBlocksMax = 0) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (numCPU = detectCPUs ()) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (numCPUtotal = numCPU) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (i = 1) >>>>>;
      while (1)
        {
          if ((int) i >= argc) goto <D.39873>;
          if (*NON_LVALUE_EXPR <*(argv + (sizetype) (i * 8))> == 45)
            {
              if (*(*(argv + (sizetype) (i * 8)) + 1) == 0)
                {
                  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*(FileList + (sizetype) ((long unsigned int) FileListCount * 8)) = *(argv + (sizetype) (i * 8))) >>>>>;
                  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) FileListCount++  >>>>>;
                  // predicted unlikely by continue predictor.;
                  goto <D.39874>;
                }
              else
                {
                  if (*(*(argv + (sizetype) (i * 8)) + 1) == 45)
                    {
                      if (strcmp ((const char *) *(argv + (sizetype) (i * 8)), (const char *) "--best") == 0)
                        {
                          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (BWTblockSize = 9) >>>>>;
                        }
                      else
                        {
                          if (strcmp ((const char *) *(argv + (sizetype) (i * 8)), (const char *) "--decompress") == 0)
                            {
                              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (decompress = 1) >>>>>;
                            }
                          else
                            {
                              if (strcmp ((const char *) *(argv + (sizetype) (i * 8)), (const char *) "--compress") == 0)
                                {
                                  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (compress = 1) >>>>>;
                                }
                              else
                                {
                                  if (strcmp ((const char *) *(argv + (sizetype) (i * 8)), (const char *) "--fast") == 0)
                                    {
                                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (BWTblockSize = 1) >>>>>;
                                    }
                                  else
                                    {
                                      if (strcmp ((const char *) *(argv + (sizetype) (i * 8)), (const char *) "--force") == 0)
                                        {
                                          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (force = 1) >>>>>;
                                          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (ForceOverwrite = 1) >>>>>;
                                        }
                                      else
                                        {
                                          if (strcmp ((const char *) *(argv + (sizetype) (i * 8)), (const char *) "--help") == 0)
                                            {
                                              <<cleanup_point <<< Unknown tree: expr_stmt
  usage (*NON_LVALUE_EXPR <argv>, (const char *) "HELP") >>>>>;
                                            }
                                          else
                                            {
                                              if (strcmp ((const char *) *(argv + (sizetype) (i * 8)), (const char *) "--keep") == 0)
                                                {
                                                  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (keep = 1) >>>>>;
                                                }
                                              else
                                                {
                                                  if (strcmp ((const char *) *(argv + (sizetype) (i * 8)), (const char *) "--license") == 0)
                                                    {
                                                      <<cleanup_point <<< Unknown tree: expr_stmt
  usage (*NON_LVALUE_EXPR <argv>, (const char *) "HELP") >>>>>;
                                                    }
                                                  else
                                                    {
                                                      if (strcmp ((const char *) *(argv + (sizetype) (i * 8)), (const char *) "--loadavg") == 0)
                                                        {
                                                          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (useLoadAverage = 1) >>>>>;
                                                        }
                                                      else
                                                        {
                                                          if (strcmp ((const char *) *(argv + (sizetype) (i * 8)), (const char *) "--quiet") == 0)
                                                            {
                                                              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (QuietMode = 1) >>>>>;
                                                            }
                                                          else
                                                            {
                                                              if (strcmp ((const char *) *(argv + (sizetype) (i * 8)), (const char *) "--read") == 0)
                                                                {
                                                                  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (readEntireFile = 1) >>>>>;
                                                                }
                                                              else
                                                                {
                                                                  if (strcmp ((const char *) *(argv + (sizetype) (i * 8)), (const char *) "--stdout") == 0)
                                                                    {
                                                                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (OutputStdOut = 1) >>>>>;
                                                                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (keep = 1) >>>>>;
                                                                    }
                                                                  else
                                                                    {
                                                                      if (strcmp ((const char *) *(argv + (sizetype) (i * 8)), (const char *) "--test") == 0)
                                                                        {
                                                                          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (testFile = 1) >>>>>;
                                                                        }
                                                                      else
                                                                        {
                                                                          if (strcmp ((const char *) *(argv + (sizetype) (i * 8)), (const char *) "--verbose") == 0)
                                                                            {
                                                                              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (QuietMode = 0) >>>>>;
                                                                            }
                                                                          else
                                                                            {
                                                                              if (strcmp ((const char *) *(argv + (sizetype) (i * 8)), (const char *) "--version") == 0)
                                                                                {
                                                                                  <<cleanup_point <<< Unknown tree: expr_stmt
  banner () >>>>>;
                                                                                  <<cleanup_point <<< Unknown tree: expr_stmt
  exit (0) >>>>>;
                                                                                }
                                                                              else
                                                                                {
                                                                                  if (strcmp ((const char *) *(argv + (sizetype) (i * 8)), (const char *) "--ignore-trailing-garbage") == 0)
                                                                                    {
                                                                                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (IgnoreTrailingGarbageFlag = 1) >>>>>;
                                                                                    }
                                                                                  else
                                                                                    {
                                                                                      if (strcmp ((const char *) *(argv + (sizetype) (i * 8)), (const char *) "--ignore-trailing-garbage=1") == 0)
                                                                                        {
                                                                                          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (IgnoreTrailingGarbageFlag = 1) >>>>>;
                                                                                        }
                                                                                      else
                                                                                        {
                                                                                          if (strcmp ((const char *) *(argv + (sizetype) (i * 8)), (const char *) "--ignore-trailing-garbage=0") == 0)
                                                                                            {
                                                                                              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (IgnoreTrailingGarbageFlag = 0) >>>>>;
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                      // predicted unlikely by continue predictor.;
                      goto <D.39874>;
                    }
                }
              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (j = 1) >>>>>;
              while (1)
                {
                  if (*(*(argv + (sizetype) (i * 8)) + (sizetype) NON_LVALUE_EXPR <j>) == 0) goto <D.39875>;
                  switch ((int) *(*(argv + (sizetype) (i * 8)) + (sizetype) NON_LVALUE_EXPR <j>))
                    {
                      case 112:;
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (k = j + 1) >>>>>;
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (cmdLineTempCount = 0) >>>>>;
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) strcpy ((char *) &cmdLineTemp, (const char *) "2") >>>>>;
                      while (1)
                        {
                          if (*(*(argv + (sizetype) (i * 8)) + (sizetype) NON_LVALUE_EXPR <k>) == 0 || k > 2047) goto <D.39878>;
                          if ((unsigned char) *(*(argv + (sizetype) (i * 8)) + (sizetype) NON_LVALUE_EXPR <k>) + 208 > 9) goto <D.39878>;
                          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) k++  >>>>>;
                          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) cmdLineTempCount++  >>>>>;
                        }
                      <D.39878>:;
                      if (cmdLineTempCount == 0)
                        {
                          <<cleanup_point <<< Unknown tree: expr_stmt
  usage (*NON_LVALUE_EXPR <argv>, (const char *) "Cannot parse -p argument") >>>>>;
                        }
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) strncpy ((char *) &cmdLineTemp, (const char *) (*(argv + (sizetype) (i * 8)) + ((sizetype) NON_LVALUE_EXPR <j> + 1)), (size_t) cmdLineTempCount) >>>>>;
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (cmdLineTemp[cmdLineTempCount] = 0) >>>>>;
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (numCPU = atoi ((const char *) &cmdLineTemp)) >>>>>;
                      if (numCPU > 4096)
                        {
                          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "pbzip2: *ERROR: Maximal number of supported processors is 4096!  Aborting...\n") >>>>>;
                          return <retval> = 1;
                        }
                      else
                        {
                          if (numCPU <= 0)
                            {
                              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "pbzip2: *ERROR: Minimum number of supported processors is 1!  Aborting...\n") >>>>>;
                              return <retval> = 1;
                            }
                        }
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (j = (size_t) cmdLineTempCount + j) >>>>>;
                      goto <D.39877>;
                      case 98:;
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (k = j + 1) >>>>>;
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (cmdLineTempCount = 0) >>>>>;
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) strcpy ((char *) &cmdLineTemp, (const char *) "9") >>>>>;
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (blockSize = 900000) >>>>>;
                      while (1)
                        {
                          if (*(*(argv + (sizetype) (i * 8)) + (sizetype) NON_LVALUE_EXPR <k>) == 0 || k > 2047) goto <D.39880>;
                          if ((unsigned char) *(*(argv + (sizetype) (i * 8)) + (sizetype) NON_LVALUE_EXPR <k>) + 208 > 9) goto <D.39880>;
                          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) k++  >>>>>;
                          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) cmdLineTempCount++  >>>>>;
                        }
                      <D.39880>:;
                      if (cmdLineTempCount == 0)
                        {
                          <<cleanup_point <<< Unknown tree: expr_stmt
  usage (*NON_LVALUE_EXPR <argv>, (const char *) "Cannot parse file block size") >>>>>;
                        }
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) strncpy ((char *) &cmdLineTemp, (const char *) (*(argv + (sizetype) (i * 8)) + ((sizetype) NON_LVALUE_EXPR <j> + 1)), (size_t) cmdLineTempCount) >>>>>;
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (cmdLineTemp[cmdLineTempCount] = 0) >>>>>;
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (blockSize = atoi ((const char *) &cmdLineTemp) * 100000) >>>>>;
                      if ((unsigned int) blockSize + 4294867296 > 999900000)
                        {
                          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "pbzip2: *ERROR: File block size Min: 100k and Max: 1000000k!  Aborting...\n") >>>>>;
                          return <retval> = 1;
                        }
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (j = (size_t) cmdLineTempCount + j) >>>>>;
                      goto <D.39877>;
                      case 109:;
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (k = j + 1) >>>>>;
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (cmdLineTempCount = 0) >>>>>;
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) strcpy ((char *) &cmdLineTemp, (const char *) "1") >>>>>;
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (maxMemory = 1000000) >>>>>;
                      while (1)
                        {
                          if (*(*(argv + (sizetype) (i * 8)) + (sizetype) NON_LVALUE_EXPR <k>) == 0 || k > 2047) goto <D.39882>;
                          if ((unsigned char) *(*(argv + (sizetype) (i * 8)) + (sizetype) NON_LVALUE_EXPR <k>) + 208 > 9) goto <D.39882>;
                          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) k++  >>>>>;
                          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) cmdLineTempCount++  >>>>>;
                        }
                      <D.39882>:;
                      if (cmdLineTempCount == 0)
                        {
                          <<cleanup_point <<< Unknown tree: expr_stmt
  usage (*NON_LVALUE_EXPR <argv>, (const char *) "Cannot parse -m argument") >>>>>;
                        }
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) strncpy ((char *) &cmdLineTemp, (const char *) (*(argv + (sizetype) (i * 8)) + ((sizetype) NON_LVALUE_EXPR <j> + 1)), (size_t) cmdLineTempCount) >>>>>;
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (cmdLineTemp[cmdLineTempCount] = 0) >>>>>;
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (maxMemory = atoi ((const char *) &cmdLineTemp) * 1000000) >>>>>;
                      if ((unsigned int) maxMemory + 4293967296 > 1999000000)
                        {
                          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "pbzip2: *ERROR: Memory usage size Min: 1MB and Max: 2000MB!  Aborting...\n") >>>>>;
                          return <retval> = 1;
                        }
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (maxMemorySwitch = 1) >>>>>;
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (j = (size_t) cmdLineTempCount + j) >>>>>;
                      goto <D.39877>;
                      case 83:;
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (k = j + 1) >>>>>;
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (cmdLineTempCount = 0) >>>>>;
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) strcpy ((char *) &cmdLineTemp, (const char *) "0") >>>>>;
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (ChildThreadStackSize = -1) >>>>>;
                      while (1)
                        {
                          if (*(*(argv + (sizetype) (i * 8)) + (sizetype) NON_LVALUE_EXPR <k>) == 0 || k > 2047) goto <D.39884>;
                          if ((unsigned char) *(*(argv + (sizetype) (i * 8)) + (sizetype) NON_LVALUE_EXPR <k>) + 208 > 9) goto <D.39884>;
                          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) k++  >>>>>;
                          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) cmdLineTempCount++  >>>>>;
                        }
                      <D.39884>:;
                      if (cmdLineTempCount == 0)
                        {
                          <<cleanup_point <<< Unknown tree: expr_stmt
  usage (*NON_LVALUE_EXPR <argv>, (const char *) "Cannot parse -S argument") >>>>>;
                        }
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) strncpy ((char *) &cmdLineTemp, (const char *) (*(argv + (sizetype) (i * 8)) + ((sizetype) NON_LVALUE_EXPR <j> + 1)), (size_t) cmdLineTempCount) >>>>>;
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (cmdLineTemp[cmdLineTempCount] = 0) >>>>>;
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (ChildThreadStackSize = atoi ((const char *) &cmdLineTemp) * 1024) >>>>>;
                      if (ChildThreadStackSize < 0)
                        {
                          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "pbzip2: *ERROR: Parsing -S: invalid stack size specified [%d]!  Ignoring...\n", ChildThreadStackSize) >>>>>;
                        }
                      else
                        {
                          if (ChildThreadStackSize <= 16383)
                            {
                              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "pbzip2: *WARNING: Stack size %d bytes less than minumum - adjusting to %d bytes.\n", ChildThreadStackSize, 16384) >>>>>;
                              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (ChildThreadStackSize = 16384) >>>>>;
                            }
                        }
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (j = (size_t) cmdLineTempCount + j) >>>>>;
                      goto <D.39877>;
                      case 100:;
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (decompress = 1) >>>>>;
                      goto <D.39877>;
                      case 99:;
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (OutputStdOut = 1) >>>>>;
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (keep = 1) >>>>>;
                      goto <D.39877>;
                      case 102:;
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (force = 1) >>>>>;
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (ForceOverwrite = 1) >>>>>;
                      goto <D.39877>;
                      case 104:;
                      <<cleanup_point <<< Unknown tree: expr_stmt
  usage (*NON_LVALUE_EXPR <argv>, (const char *) "HELP") >>>>>;
                      goto <D.39877>;
                      case 107:;
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (keep = 1) >>>>>;
                      goto <D.39877>;
                      case 108:;
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (useLoadAverage = 1) >>>>>;
                      goto <D.39877>;
                      case 76:;
                      <<cleanup_point <<< Unknown tree: expr_stmt
  banner () >>>>>;
                      <<cleanup_point <<< Unknown tree: expr_stmt
  exit (0) >>>>>;
                      case 113:;
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (QuietMode = 1) >>>>>;
                      goto <D.39877>;
                      case 114:;
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (readEntireFile = 1) >>>>>;
                      goto <D.39877>;
                      case 116:;
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (testFile = 1) >>>>>;
                      goto <D.39877>;
                      case 118:;
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (QuietMode = 0) >>>>>;
                      goto <D.39877>;
                      case 86:;
                      <<cleanup_point <<< Unknown tree: expr_stmt
  banner () >>>>>;
                      <<cleanup_point <<< Unknown tree: expr_stmt
  exit (0) >>>>>;
                      case 122:;
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (compress = 1) >>>>>;
                      goto <D.39877>;
                      case 49:;
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (BWTblockSize = 1) >>>>>;
                      goto <D.39877>;
                      case 50:;
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (BWTblockSize = 2) >>>>>;
                      goto <D.39877>;
                      case 51:;
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (BWTblockSize = 3) >>>>>;
                      goto <D.39877>;
                      case 52:;
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (BWTblockSize = 4) >>>>>;
                      goto <D.39877>;
                      case 53:;
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (BWTblockSize = 5) >>>>>;
                      goto <D.39877>;
                      case 54:;
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (BWTblockSize = 6) >>>>>;
                      goto <D.39877>;
                      case 55:;
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (BWTblockSize = 7) >>>>>;
                      goto <D.39877>;
                      case 56:;
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (BWTblockSize = 8) >>>>>;
                      goto <D.39877>;
                      case 57:;
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (BWTblockSize = 9) >>>>>;
                      goto <D.39877>;
                    }
                  <D.39877>:;
                  <<cleanup_point (void) j++ >>;
                }
              <D.39875>:;
            }
          else
            {
              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*(FileList + (sizetype) ((long unsigned int) FileListCount * 8)) = *(argv + (sizetype) (i * 8))) >>>>>;
              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) FileListCount++  >>>>>;
            }
          <D.39874>:;
          <<cleanup_point (void) i++ >>;
        }
      <D.39873>:;
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (Bz2HeaderZero[3] = (unsigned char) BWTblockSize + 48) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (bz2Header[3] = (char) Bz2HeaderZero[3]) >>>>>;
      if (compress == 1 && decompress == 1)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "pbzip2: *ERROR: Can\'t compress and uncompress data at same time.  Aborting!\n") >>>>>;
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "pbzip2: For help type: %s -h\n", *NON_LVALUE_EXPR <argv>) >>>>>;
          return <retval> = 1;
        }
      if (FileListCount == 0)
        {
          if (testFile == 1)
            {
              if (<<cleanup_point isatty (fileno (stdin)) != 0>>)
                {
                  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "pbzip2: *ERROR: Won\'t read compressed data from terminal.  Aborting!\n") >>>>>;
                  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "pbzip2: For help type: %s -h\n", *NON_LVALUE_EXPR <argv>) >>>>>;
                  return <retval> = 1;
                }
              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*(FileList + (sizetype) ((long unsigned int) FileListCount * 8)) = (char *) &stdinFile) >>>>>;
              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) FileListCount++  >>>>>;
            }
          else
            {
              if (decompress == 1)
                {
                  if (<<cleanup_point isatty (fileno (stdin)) != 0>>)
                    {
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "pbzip2: *ERROR: Won\'t read compressed data from terminal.  Aborting!\n") >>>>>;
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "pbzip2: For help type: %s -h\n", *NON_LVALUE_EXPR <argv>) >>>>>;
                      return <retval> = 1;
                    }
                  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (OutputStdOut = 1) >>>>>;
                  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (keep = 1) >>>>>;
                  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*(FileList + (sizetype) ((long unsigned int) FileListCount * 8)) = (char *) &stdinFile) >>>>>;
                  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) FileListCount++  >>>>>;
                }
              else
                {
                  if (OutputStdOut == 0)
                    {
                      if (QuietMode != 1)
                        {
                          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "pbzip2: Assuming input data coming from stdin...\n\n") >>>>>;
                        }
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (OutputStdOut = 1) >>>>>;
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (keep = 1) >>>>>;
                    }
                  if (<<cleanup_point isatty (fileno (stdout)) != 0>>)
                    {
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "pbzip2: *ERROR: Won\'t write compressed data to terminal.  Aborting!\n") >>>>>;
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "pbzip2: For help type: %s -h\n", *NON_LVALUE_EXPR <argv>) >>>>>;
                      return <retval> = 1;
                    }
                  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*(FileList + (sizetype) ((long unsigned int) FileListCount * 8)) = (char *) &stdinFile) >>>>>;
                  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) FileListCount++  >>>>>;
                }
            }
        }
      if (QuietMode != 1)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  banner () >>>>>;
          if (0)
            {
              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "\npbzip2: *WARNING: off_t variable size only %u bits!\n", 64) >>>>>;
              if (decompress == 1)
                {
                  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) " You will only able to uncompress files smaller than 2GB in size.\n\n") >>>>>;
                }
              else
                {
                  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) " You will only able to compress files smaller than 2GB in size.\n\n") >>>>>;
                }
            }
        }
      if (useLoadAverage == 1)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (ret = getloadavg ((double *) &loadAvgArray, 3)) >>>>>;
          if (ret != 3)
            {
              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (loadAverage = 0.0) >>>>>;
              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (useLoadAverage = 0) >>>>>;
              if (QuietMode != 1)
                {
                  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "pbzip2:  *WARNING: Could not get load average!  Using requested processors...\n") >>>>>;
                }
            }
          else
            {
              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (loadAverage = loadAvgArray[0]) >>>>>;
              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (numCPUidle = numCPUtotal - (int) (loadAverage + 5.0e-1)) >>>>>;
              if (numCPUidle < numCPU)
                {
                  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (numCPU = numCPUidle) >>>>>;
                }
              if (numCPU <= 0)
                {
                  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (numCPU = 1) >>>>>;
                }
            }
        }
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) initChildThreadAttributes () >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (sigInFilename = 0B) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (sigOutFilename = 0B) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (ret = setupSignalHandling ()) >>>>>;
      if (ret != 0)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "pbzip2: *ERROR: Can\'t setup signal handling [%d]. Aborting!\n", ret) >>>>>;
          return <retval> = 1;
        }
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (ret = setupTerminator ()) >>>>>;
      if (ret != 0)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "pbzip2: *ERROR: Can\'t setup terminator thread [%d]. Aborting!\n", ret) >>>>>;
          return <retval> = 1;
        }
      if (numCPU <= 0)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (numCPU = 1) >>>>>;
        }
      if (QuietMode != 1)
        {
          if (testFile != 1)
            {
              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "\n         # CPUs: %d\n", numCPU) >>>>>;
              if (useLoadAverage == 1)
                {
                  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "   Load Average: %.2f\n", loadAverage) >>>>>;
                }
              if (decompress != 1)
                {
                  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) " BWT Block Size: %d00 KB\n", BWTblockSize) >>>>>;
                  if (blockSize <= 99999)
                    {
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "File Block Size: %d bytes\n", blockSize) >>>>>;
                    }
                  else
                    {
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "File Block Size: %d KB\n", blockSize / 1000) >>>>>;
                    }
                }
              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) " Maximum Memory: %d MB\n", maxMemory / 1000000) >>>>>;
              if (ChildThreadStackSize > 0)
                {
                  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "     Stack Size: %d KB\n", ChildThreadStackSize / 1024) >>>>>;
                }
              if (decompress == 1)
                {
                  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) " Ignore Trailing Garbage: %s\n", IgnoreTrailingGarbageFlag == 1 ? (const char *) "on" : (const char *) "off") >>>>>;
                }
            }
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "-------------------------------------------\n") >>>>>;
        }
            int mutexesInitRet;
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (mutexesInitRet = mutexesInit ()) >>>>>;
      if (mutexesInitRet != 0)
        {
          return <retval> = mutexesInitRet;
        }
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (fifo = FifoQueue = queueInit (numCPU)) >>>>>;
      if (fifo == 0B)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "pbzip2: *ERROR: Queue Init failed.  Aborting...\n") >>>>>;
          return <retval> = 1;
        }
      {
        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (fileLoop = 0) >>>>>;
        while (1)
          {
            if (fileLoop >= FileListCount) goto <D.39886>;
            {
              int errLevelCurrentFile = 0;

              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (producerDone = 0) >>>>>;
              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (InFileSize = 0) >>>>>;
              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (NumBlocks = 0) >>>>>;
              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (switchedMtToSt = 0) >>>>>;
              <<cleanup_point               int errLevelCurrentFile = 0;>>;
              <<cleanup_point <<< Unknown tree: expr_stmt
  pbzip2::ErrorContext::reset (pbzip2::ErrorContext::getInstance ()) >>>>>;
              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (InFilename = *(FileList + (sizetype) ((long unsigned int) fileLoop * 8))) >>>>>;
              if (testFile != 0)
                {
                  if (QuietMode != 1)
                    {
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "      File #: %d of %d\n", fileLoop + 1, FileListCount) >>>>>;
                      if (strcmp ((const char *) InFilename, (const char *) "-") != 0)
                        {
                          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "     Testing: %s\n", InFilename) >>>>>;
                        }
                      else
                        {
                          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "     Testing: <stdin>\n") >>>>>;
                        }
                    }
                  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (ret = testCompressedData (InFilename)) >>>>>;
                  if (ret > 0)
                    {
                      return <retval> = ret;
                    }
                  else
                    {
                      if (ret == 0)
                        {
                          if (QuietMode != 1)
                            {
                              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "        Test: OK\n") >>>>>;
                            }
                        }
                      else
                        {
                          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (errLevel = 2) >>>>>;
                        }
                    }
                  if (QuietMode != 1)
                    {
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "-------------------------------------------\n") >>>>>;
                    }
                  // predicted unlikely by continue predictor.;
                  goto <D.39887>;
                }
              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) std::__cxx11::basic_string<char>::operator= (&outFilename, (struct basic_string &) &TARGET_EXPR <D.39833, <<< Unknown tree: aggr_init_expr
  6
  __comp_ctor 
  D.39833
  (struct basic_string *) <<< Unknown tree: void_cst >>>
  (const char *) *(FileList + (sizetype) ((long unsigned int) fileLoop * 8))
  (const struct allocator &) &TARGET_EXPR <D.39832, <<< Unknown tree: aggr_init_expr
  4
  __comp_ctor 
  D.39832
  (struct allocator *) <<< Unknown tree: void_cst >>> >>>> >>>>) >>>>>;
              {
                if (decompress == 1 && strcmp ((const char *) InFilename, (const char *) "-") != 0)
                  {
                    {
                      size_t size;
                      struct string bz2Tail;
                      struct string tbz2Tail;

                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (hInfile = open ((const char *) InFilename, 0)) >>>>>;
                      if (hInfile == -1)
                        {
                          <<cleanup_point <<< Unknown tree: expr_stmt
  pbzip2::ErrorContext::printErrnoMsg (stderr, *__errno_location ()) >>>>>;
                          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "pbzip2: *ERROR: File [%s] NOT found!  Skipping...\n", InFilename) >>>>>;
                          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "-------------------------------------------\n") >>>>>;
                          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (errLevel = 1) >>>>>;
                          // predicted unlikely by continue predictor.;
                          goto <D.39887>;
                        }
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) memset ((void *) &tmpBuff, 0, 50) >>>>>;
                                            size_t size;
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (size = (size_t) do_read (hInfile, (void *) &tmpBuff, strlen ((const char *) &bz2Header) + 1)) >>>>>;
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) do_close (hInfile) >>>>>;
                      if (size == 18446744073709551615 || strlen ((const char *) &bz2Header) + 1 > size)
                        {
                          <<cleanup_point <<< Unknown tree: expr_stmt
  pbzip2::ErrorContext::printErrorMessages (pbzip2::ErrorContext::getInstance (), stderr) >>>>>;
                          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "pbzip2: *ERROR: File [%s] is NOT a valid bzip2!  Skipping...\n", InFilename) >>>>>;
                          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "-------------------------------------------\n") >>>>>;
                          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (errLevel = 1) >>>>>;
                          // predicted unlikely by continue predictor.;
                          goto <D.39887>;
                        }
                      else
                        {
                          if (<<cleanup_point memstr<unsigned char*, char*> ((unsigned char *) &tmpBuff, 4, (char *) &bz2Header, 3) == 0B>>)
                            {
                              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "pbzip2: *ERROR: File [%s] is NOT a valid bzip2!  Skipping...\n", InFilename) >>>>>;
                              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "-------------------------------------------\n") >>>>>;
                              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (errLevel = 1) >>>>>;
                              // predicted unlikely by continue predictor.;
                              goto <D.39887>;
                            }
                          if (<<cleanup_point memstr<unsigned char*, char*> ((unsigned char *) &tmpBuff + 4, (int) ((unsigned int) size + 4294967292), (char *) &bz2Header + 4, (int) ((unsigned int) strlen ((const char *) &bz2Header) + 4294967292)) == 0B>>)
                            {
                              if (<<cleanup_point memstr<unsigned char*, unsigned char*> ((unsigned char *) &tmpBuff + 4, (int) ((unsigned int) size + 4294967292), (unsigned char *) &Bz2HeaderZero + 4, (int) ((unsigned int) strlen ((const char *) &bz2Header) + 4294967292)) == 0B>>)
                                {
                                  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "pbzip2: *ERROR: File [%s] is NOT a valid bzip2!  Skipping...\n", InFilename) >>>>>;
                                  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "-------------------------------------------\n") >>>>>;
                                  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (errLevel = 1) >>>>>;
                                  // predicted unlikely by continue predictor.;
                                  goto <D.39887>;
                                }
                            }
                          if (tmpBuff[3] + 207 <= 8)
                            {
                              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (BWTblockSizeChar = (char) tmpBuff[3]) >>>>>;
                            }
                          else
                            {
                              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "pbzip2: *ERROR: File [%s] is NOT a valid bzip2!  Skipping...\n", InFilename) >>>>>;
                              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "-------------------------------------------\n") >>>>>;
                              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (errLevel = 1) >>>>>;
                              // predicted unlikely by continue predictor.;
                              goto <D.39887>;
                            }
                        }
                                            struct string bz2Tail;
                      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char>::basic_string (&bz2Tail, (const char *) ".bz2", (const struct allocator &) &TARGET_EXPR <D.39850, <<< Unknown tree: aggr_init_expr
  4
  __comp_ctor 
  D.39850
  (struct allocator *) <<< Unknown tree: void_cst >>> >>>>) >>>>>;
                      try
                        {
                                                    struct string tbz2Tail;
                          <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char>::basic_string (&tbz2Tail, (const char *) ".tbz2", (const struct allocator &) &TARGET_EXPR <D.39853, <<< Unknown tree: aggr_init_expr
  4
  __comp_ctor 
  D.39853
  (struct allocator *) <<< Unknown tree: void_cst >>> >>>>) >>>>>;
                          try
                            {
                              if (<<cleanup_point ends_with_icase<char> ((const struct basic_string &) &outFilename, (const struct basic_string &) &bz2Tail)>>)
                                {
                                  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char>::resize (&outFilename, std::__cxx11::basic_string<char>::size (&outFilename) - std::__cxx11::basic_string<char>::size (&bz2Tail)) >>>>>;
                                }
                              else
                                {
                                  if (<<cleanup_point ends_with_icase<char> ((const struct basic_string &) &outFilename, (const struct basic_string &) &tbz2Tail)>>)
                                    {
                                      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char>::resize (&outFilename, std::__cxx11::basic_string<char>::size (&outFilename) - std::__cxx11::basic_string<char>::size (&tbz2Tail)) >>>>>;
                                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) std::__cxx11::basic_string<char>::operator+= (&outFilename, (const char *) ".tar") >>>>>;
                                    }
                                  else
                                    {
                                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) std::__cxx11::basic_string<char>::operator+= (&outFilename, (const char *) ".out") >>>>>;
                                    }
                                }
                            }
                          finally
                            {
                              std::__cxx11::basic_string<char>::~basic_string (&tbz2Tail);
                            }
                        }
                      finally
                        {
                          std::__cxx11::basic_string<char>::~basic_string (&bz2Tail);
                        }
                    }
                  }
                else
                  {
                    {
                      struct string bz2Tail;

                                            struct string bz2Tail;
                      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char>::basic_string (&bz2Tail, (const char *) ".bz2", (const struct allocator &) &TARGET_EXPR <D.39859, <<< Unknown tree: aggr_init_expr
  4
  __comp_ctor 
  D.39859
  (struct allocator *) <<< Unknown tree: void_cst >>> >>>>) >>>>>;
                      try
                        {
                          if (<<cleanup_point ends_with_icase<char> ((const struct basic_string &) &TARGET_EXPR <D.39862, <<< Unknown tree: aggr_init_expr
  6
  __comp_ctor 
  D.39862
  (struct basic_string *) <<< Unknown tree: void_cst >>>
  (const char *) InFilename
  (const struct allocator &) &TARGET_EXPR <D.39861, <<< Unknown tree: aggr_init_expr
  4
  __comp_ctor 
  D.39861
  (struct allocator *) <<< Unknown tree: void_cst >>> >>>> >>>>, (const struct basic_string &) &bz2Tail)>>)
                            {
                              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "pbzip2: *ERROR: Input file [%s] already has a .bz2 extension!  Skipping...\n", InFilename) >>>>>;
                              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "-------------------------------------------\n") >>>>>;
                              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (errLevel = 1) >>>>>;
                              // predicted unlikely by continue predictor.;
                              goto <D.39887>;
                            }
                          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) std::__cxx11::basic_string<char>::operator+= (&outFilename, (const struct basic_string &) &bz2Tail) >>>>>;
                        }
                      finally
                        {
                          std::__cxx11::basic_string<char>::~basic_string (&bz2Tail);
                        }
                    }
                  }
              }
              <<cleanup_point <<< Unknown tree: expr_stmt
  safe_mutex_lock (&ErrorHandlerMutex) >>>>>;
              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (sigInFilename = (const char *) InFilename) >>>>>;
              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (sigOutFilename = std::__cxx11::basic_string<char>::c_str (&outFilename)) >>>>>;
              <<cleanup_point <<< Unknown tree: expr_stmt
  safe_mutex_unlock (&ErrorHandlerMutex) >>>>>;
              {
                if (strcmp ((const char *) InFilename, (const char *) "-") != 0)
                  {
                    {
                      struct stat statbuf;

                                            struct stat statbuf;
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (hInfile = open ((const char *) InFilename, 0)) >>>>>;
                      if (hInfile == -1)
                        {
                          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "pbzip2: *ERROR: File [%s] NOT found!  Skipping...\n", InFilename) >>>>>;
                          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "-------------------------------------------\n") >>>>>;
                          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (errLevel = 1) >>>>>;
                          // predicted unlikely by continue predictor.;
                          goto <D.39887>;
                        }
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fstat (hInfile, &statbuf) >>>>>;
                      if ((statbuf.st_mode & 61440) == 16384)
                        {
                          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "pbzip2: *ERROR: File [%s] is a directory!  Skipping...\n", InFilename) >>>>>;
                          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "-------------------------------------------\n") >>>>>;
                          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (errLevel = 1) >>>>>;
                          // predicted unlikely by continue predictor.;
                          goto <D.39887>;
                        }
                      if ((statbuf.st_mode & 61440) != 32768)
                        {
                          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "pbzip2: *ERROR: File [%s] is not a regular file!  Skipping...\n", InFilename) >>>>>;
                          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "-------------------------------------------\n") >>>>>;
                          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (errLevel = 1) >>>>>;
                          // predicted unlikely by continue predictor.;
                          goto <D.39887>;
                        }
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (InFileSize = statbuf.st_size) >>>>>;
                      if (InFileSize == 0)
                        {
                          if (decompress == 1)
                            {
                              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "pbzip2: *ERROR: File is of size 0 [%s]!  Skipping...\n", InFilename) >>>>>;
                              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "-------------------------------------------\n") >>>>>;
                              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (errLevel = 1) >>>>>;
                              // predicted unlikely by continue predictor.;
                              goto <D.39887>;
                            }
                          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (zeroByteFile = 1) >>>>>;
                        }
                      else
                        {
                          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (zeroByteFile = 0) >>>>>;
                        }
                      if (<<cleanup_point getFileMetaData ((const char *) InFilename) != 0>>)
                        {
                          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "pbzip2: *ERROR: Could not get file meta data from [%s]!  Skipping...\n", InFilename) >>>>>;
                          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "-------------------------------------------\n") >>>>>;
                          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (errLevel = 1) >>>>>;
                          // predicted unlikely by continue predictor.;
                          goto <D.39887>;
                        }
                    }
                  }
                else
                  {
                    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (hInfile = 0) >>>>>;
                    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (InFileSize = -1) >>>>>;
                  }
              }
              if (<<cleanup_point OutputStdOut == 0 && check_file_exists (std::__cxx11::basic_string<char>::c_str (&outFilename))>>)
                {
                  if (force != 1)
                    {
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "pbzip2: *ERROR: Output file [%s] already exists!  Use -f to overwrite...\n", std::__cxx11::basic_string<char>::c_str (&outFilename)) >>>>>;
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "-------------------------------------------\n") >>>>>;
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (errLevel = 1) >>>>>;
                      // predicted unlikely by continue predictor.;
                      goto <D.39887>;
                    }
                  else
                    {
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) remove (std::__cxx11::basic_string<char>::c_str (&outFilename)) >>>>>;
                    }
                }
              if (readEntireFile == 1)
                {
                  if (hInfile == 0)
                    {
                      if (QuietMode != 1)
                        {
                          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) " *Warning: Ignoring -r switch since input is stdin.\n") >>>>>;
                        }
                    }
                  else
                    {
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (blockSize = (int) (InFileSize / (off_t) numCPU)) >>>>>;
                    }
                }
              if (QuietMode != 1)
                {
                  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "         File #: %d of %d\n", fileLoop + 1, FileListCount) >>>>>;
                  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "     Input Name: %s\n", hInfile != 0 ? (const char *) InFilename : (const char *) "<stdin>") >>>>>;
                  if (OutputStdOut == 0)
                    {
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "    Output Name: %s\n\n", std::__cxx11::basic_string<char>::c_str (&outFilename)) >>>>>;
                    }
                  else
                    {
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "    Output Name: <stdout>\n\n") >>>>>;
                    }
                  if (decompress == 1)
                    {
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) " BWT Block Size: %c00k\n", (int) BWTblockSizeChar) >>>>>;
                    }
                  if (strcmp ((const char *) InFilename, (const char *) "-") != 0)
                    {
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "     Input Size: %lu bytes\n", (uintmax_t) InFileSize) >>>>>;
                    }
                }
              {
                if (decompress == 1)
                  {
                    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (numBlocks = 0) >>>>>;
                    if (numCPU == 1 || InFileSize <= 999999)
                      {
                        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (noThreads = 1) >>>>>;
                      }
                    else
                      {
                        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (noThreads = 0) >>>>>;
                      }
                    if (numCPU > 1 && strcmp ((const char *) InFilename, (const char *) "-") == 0)
                      {
                        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (noThreads = 0) >>>>>;
                      }
                  }
                else
                  {
                    {
                      if (InFileSize > 0)
                        {
                          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (numBlocks = (int) ((((off_t) blockSize + InFileSize) + -1) / (off_t) blockSize)) >>>>>;
                          if (numBlocks == 1 || numCPU == 1)
                            {
                              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (noThreads = 1) >>>>>;
                            }
                          else
                            {
                              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (noThreads = 0) >>>>>;
                            }
                        }
                      else
                        {
                          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (numBlocks = 10000) >>>>>;
                        }
                      {
                        if (zeroByteFile == 1)
                          {
                            {
                              int close_ret = 0;

                              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (hOutfile = 1) >>>>>;
                              if (OutputStdOut == 0)
                                {
                                  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (hOutfile = safe_open_output (std::__cxx11::basic_string<char>::c_str (&outFilename))) >>>>>;
                                  if (hOutfile == -1)
                                    {
                                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) handle_error (1, 1, (const char *) "pbzip2: *ERROR: Could not create output file [%s]!\n", std::__cxx11::basic_string<char>::c_str (&outFilename)) >>>>>;
                                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (errLevelCurrentFile = errLevel = 1) >>>>>;
                                      goto <D.39886>;
                                    }
                                }
                              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (ret = (int) do_write (hOutfile, (const void *) &Bz2HeaderZero, 14)) >>>>>;
                              <<cleanup_point                               int close_ret = 0;>>;
                              if (OutputStdOut == 0)
                                {
                                  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (close_ret = do_close (hOutfile)) >>>>>;
                                  if (<<cleanup_point writeFileMetaData (std::__cxx11::basic_string<char>::c_str (&outFilename)) != 0>>)
                                    {
                                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) handle_error (0, -1, (const char *) "pbzip2: *ERROR: Could not write file meta data to [%s]!\n", std::__cxx11::basic_string<char>::c_str (&outFilename)) >>>>>;
                                    }
                                }
                              if (ret != 14 || close_ret == -1)
                                {
                                  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) handle_error (1, 1, (const char *) "pbzip2: *ERROR: Could not write to file [%s]! Aborting...\n", std::__cxx11::basic_string<char>::c_str (&outFilename)) >>>>>;
                                  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "-------------------------------------------\n") >>>>>;
                                  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (errLevelCurrentFile = errLevel = 1) >>>>>;
                                  goto <D.39886>;
                                }
                              if (QuietMode != 1)
                                {
                                  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "    Output Size: %u bytes\n", 14) >>>>>;
                                  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "-------------------------------------------\n") >>>>>;
                                }
                              {
                                if (keep != 1 && errLevelCurrentFile == 0)
                                  {
                                    {
                                      struct stat statbuf;
                                      bool removeFlag;

                                                                            struct stat statbuf;
                                                                            bool removeFlag;
                                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (removeFlag = OutputStdOut != 0 || stat (std::__cxx11::basic_string<char>::c_str (&outFilename), &statbuf) == 0) >>>>>;
                                      if (removeFlag)
                                        {
                                          if (<<cleanup_point do_remove ((const char *) InFilename) == -1>>)
                                            {
                                              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) handle_error (0, 1, (const char *) "Can\'t remove input file [%s]!", InFilename) >>>>>;
                                            }
                                        }
                                    }
                                  }
                              }
                              // predicted unlikely by continue predictor.;
                              goto <D.39887>;
                            }
                          }
                      }
                    }
                  }
              }
              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (NumBlocksEstimated = numBlocks) >>>>>;
              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (NumBufferedBlocksMax = (size_t) (maxMemory / blockSize)) >>>>>;
              if ((int) NumBufferedBlocksMax - numCPU * 2 <= 0)
                {
                  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (NumBufferedBlocksMax = 1) >>>>>;
                }
              else
                {
                  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (NumBufferedBlocksMax = NumBufferedBlocksMax - (size_t) (numCPU * 2)) >>>>>;
                }
              if ((size_t) numCPU > NumBufferedBlocksMax)
                {
                  if (maxMemorySwitch == 0)
                    {
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (NumBufferedBlocksMax = (size_t) numCPU) >>>>>;
                      if (QuietMode != 1)
                        {
                          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "*Warning* Max memory limit increased to %lu MB to support %d CPUs\n", (uintmax_t) (((size_t) (numCPU * 2) + NumBufferedBlocksMax) * (size_t) blockSize) / 1000000, numCPU) >>>>>;
                        }
                    }
                  else
                    {
                      if (QuietMode != 1)
                        {
                          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "*Warning* CPU usage and performance may be suboptimal due to max memory limit.\n") >>>>>;
                        }
                    }
                }
              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (LastGoodBlock = -1) >>>>>;
              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (MinErrorBlock = -1) >>>>>;
              <<cleanup_point <<< Unknown tree: expr_stmt
  outputBufferInit (NumBufferedBlocksMax) >>>>>;
              if (decompress == 1)
                {
                  if (noThreads == 0)
                    {
                      if (QuietMode != 1)
                        {
                          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "Decompressing data...\n") >>>>>;
                        }
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (i = 0) >>>>>;
                      while (1)
                        {
                          if ((int) i >= numCPU) goto <D.39888>;
                          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (ret = pthread_create (fifo->consumers + (sizetype) (i * 8), (const union pthread_attr_t *) &ChildThreadAttributes, consumer_decompress, (void *) fifo)) >>>>>;
                          if (ret != 0)
                            {
                              <<cleanup_point <<< Unknown tree: expr_stmt
  pbzip2::ErrorContext::saveError (pbzip2::ErrorContext::getInstance ()) >>>>>;
                              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) handle_error (1, 1, (const char *) "pbzip2: *ERROR: Not enough resources to create consumer thread #%u (code = %d)  Aborting...\n", i, ret) >>>>>;
                              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (ret = pthread_join (TerminatorThread, 0B)) >>>>>;
                              return <retval> = 1;
                            }
                          <<cleanup_point (void) i++ >>;
                        }
                      <D.39888>:;
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (ret = pthread_create (&output, (const union pthread_attr_t *) &ChildThreadAttributes, fileWriter, (void *) std::__cxx11::basic_string<char>::c_str (&outFilename))) >>>>>;
                      if (ret != 0)
                        {
                          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) handle_error (1, 1, (const char *) "pbzip2: *ERROR: Not enough resources to create fileWriter thread (code = %d)  Aborting...\n", ret) >>>>>;
                          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (ret = pthread_join (TerminatorThread, 0B)) >>>>>;
                          return <retval> = 1;
                        }
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (ret = producer_decompress (hInfile, InFileSize, fifo)) >>>>>;
                      if (ret == -99)
                        {
                          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (noThreads = 1) >>>>>;
                          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (switchedMtToSt = 1) >>>>>;
                          if (<<cleanup_point pthread_join (output, 0B) != 0>>)
                            {
                              <<cleanup_point <<< Unknown tree: expr_stmt
  pbzip2::ErrorContext::saveError (pbzip2::ErrorContext::getInstance ()) >>>>>;
                              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) handle_error (1, 1, (const char *) "pbzip2: *ERROR: Error joining fileWriter thread (code = %d)  Aborting...\n", ret) >>>>>;
                              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (errLevelCurrentFile = errLevel = 1) >>>>>;
                              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (ret = pthread_join (TerminatorThread, 0B)) >>>>>;
                              return <retval> = 1;
                            }
                        }
                      else
                        {
                          if (ret != 0)
                            {
                              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (errLevelCurrentFile = errLevel = 1) >>>>>;
                            }
                        }
                    }
                  if (noThreads == 1 && errLevelCurrentFile == 0)
                    {
                      if (QuietMode != 1)
                        {
                          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "Decompressing data (no threads)...\n") >>>>>;
                        }
                      if (hInfile > 0)
                        {
                          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) close (hInfile) >>>>>;
                        }
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (ret = directdecompress ((const char *) InFilename, std::__cxx11::basic_string<char>::c_str (&outFilename))) >>>>>;
                      if (ret != 0)
                        {
                          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (errLevelCurrentFile = errLevel = 1) >>>>>;
                        }
                    }
                }
              else
                {
                  if (noThreads == 0)
                    {
                      if (QuietMode != 1)
                        {
                          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "Compressing data...\n") >>>>>;
                        }
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (i = 0) >>>>>;
                      while (1)
                        {
                          if ((int) i >= numCPU) goto <D.39890>;
                          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (ret = pthread_create (fifo->consumers + (sizetype) (i * 8), (const union pthread_attr_t *) &ChildThreadAttributes, consumer, (void *) fifo)) >>>>>;
                          if (ret != 0)
                            {
                              <<cleanup_point <<< Unknown tree: expr_stmt
  pbzip2::ErrorContext::saveError (pbzip2::ErrorContext::getInstance ()) >>>>>;
                              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) handle_error (1, 1, (const char *) "pbzip2: *ERROR: Not enough resources to create consumer thread #%u (code = %d)  Aborting...\n", i, ret) >>>>>;
                              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) pthread_join (TerminatorThread, 0B) >>>>>;
                              return <retval> = 1;
                            }
                          <<cleanup_point (void) i++ >>;
                        }
                      <D.39890>:;
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (ret = pthread_create (&output, (const union pthread_attr_t *) &ChildThreadAttributes, fileWriter, (void *) std::__cxx11::basic_string<char>::c_str (&outFilename))) >>>>>;
                      if (ret != 0)
                        {
                          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) handle_error (1, 1, (const char *) "pbzip2: *ERROR: Not enough resources to create fileWriter thread (code = %d)  Aborting...\n", ret) >>>>>;
                          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) pthread_join (TerminatorThread, 0B) >>>>>;
                          return <retval> = 1;
                        }
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (ret = producer (hInfile, blockSize, fifo)) >>>>>;
                      if (ret != 0)
                        {
                          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (errLevelCurrentFile = errLevel = 1) >>>>>;
                        }
                    }
                  else
                    {
                      if (QuietMode != 1)
                        {
                          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "Compressing data (no threads)...\n") >>>>>;
                        }
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (ret = directcompress (hInfile, InFileSize, blockSize, std::__cxx11::basic_string<char>::c_str (&outFilename))) >>>>>;
                      if (ret != 0)
                        {
                          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (errLevelCurrentFile = errLevel = 1) >>>>>;
                        }
                    }
                }
              if (noThreads == 0)
                {
                  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (ret = pthread_join (output, 0B)) >>>>>;
                  if (ret != 0)
                    {
                      <<cleanup_point <<< Unknown tree: expr_stmt
  pbzip2::ErrorContext::printErrnoMsg (stderr, *__errno_location ()) >>>>>;
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (errLevelCurrentFile = errLevel = 1) >>>>>;
                    }
                }
              if (noThreads == 0 || switchedMtToSt)
                {
                  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (i = 0) >>>>>;
                  while (1)
                    {
                      if ((int) i >= numCPU) goto <D.39892>;
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (ret = pthread_join (*(fifo->consumers + (sizetype) (i * 8)), 0B)) >>>>>;
                      if (ret != 0)
                        {
                          <<cleanup_point <<< Unknown tree: expr_stmt
  pbzip2::ErrorContext::printErrnoMsg (stderr, *__errno_location ()) >>>>>;
                          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (errLevelCurrentFile = errLevel = 1) >>>>>;
                        }
                      <<cleanup_point (void) i++ >>;
                    }
                  <D.39892>:;
                }
              if (<<cleanup_point syncGetTerminateFlag () != 0>>)
                {
                  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (errLevelCurrentFile = errLevel = 1) >>>>>;
                }
              if (OutputStdOut == 0)
                {
                  if (<<cleanup_point writeFileMetaData (std::__cxx11::basic_string<char>::c_str (&outFilename)) != 0>>)
                    {
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) handle_error (0, -1, (const char *) "pbzip2: *ERROR: Could not write file meta data to [%s]!\n", std::__cxx11::basic_string<char>::c_str (&outFilename)) >>>>>;
                    }
                }
              {
                if (keep != 1 && errLevelCurrentFile == 0)
                  {
                    {
                      struct stat statbuf;
                      bool removeFlag;

                                            struct stat statbuf;
                                            bool removeFlag;
                      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (removeFlag = OutputStdOut != 0 || stat (std::__cxx11::basic_string<char>::c_str (&outFilename), &statbuf) == 0) >>>>>;
                      if (removeFlag)
                        {
                          if (<<cleanup_point do_remove ((const char *) InFilename) == -1>>)
                            {
                              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) handle_error (0, 1, (const char *) "Can\'t remove input file [%s]!", InFilename) >>>>>;
                            }
                        }
                    }
                  }
              }
              <<cleanup_point <<< Unknown tree: expr_stmt
  std::vector<outBuff>::clear (&OutputBuffer) >>>>>;
              <<cleanup_point <<< Unknown tree: expr_stmt
  queue::clear (NON_LVALUE_EXPR <fifo>) >>>>>;
              if (<<cleanup_point errLevelCurrentFile == 0 && syncGetTerminateFlag () == 0>>)
                {
                  <<cleanup_point <<< Unknown tree: expr_stmt
  safe_mutex_lock (&ErrorHandlerMutex) >>>>>;
                  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (sigInFilename = 0B) >>>>>;
                  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (sigOutFilename = 0B) >>>>>;
                  <<cleanup_point <<< Unknown tree: expr_stmt
  safe_mutex_unlock (&ErrorHandlerMutex) >>>>>;
                }
              if (errLevelCurrentFile == 1)
                {
                  <<cleanup_point <<< Unknown tree: expr_stmt
  syncSetTerminateFlag (1) >>>>>;
                  goto <D.39886>;
                }
              if (QuietMode != 1)
                {
                  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "-------------------------------------------\n") >>>>>;
                }
            }
            <D.39887>:;
            <<cleanup_point (void) fileLoop++ >>;
          }
        <D.39886>:;
      }
      if (OutputStdOut == 1)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (ret = close (1)) >>>>>;
          if (ret == -1)
            {
              <<cleanup_point <<< Unknown tree: expr_stmt
  pbzip2::ErrorContext::saveError (pbzip2::ErrorContext::getInstance ()) >>>>>;
              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) handle_error (1, 1, (const char *) "pbzip2: *ERROR: Failed to close STDOUT! Aborting...\n") >>>>>;
              <<cleanup_point <<< Unknown tree: expr_stmt
  exit (1) >>>>>;
            }
        }
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (ret = pthread_kill (SignalHandlerThread, SIG_HANDLER_QUIT_SIGNAL)) >>>>>;
      if (ret != 0)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "Couldn\'t signal signal QUIT to SignalHandlerThread [%d]. Quitting prematurely!\n", ret) >>>>>;
          <<cleanup_point <<< Unknown tree: expr_stmt
  exit (errLevel) >>>>>;
        }
      else
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (ret = pthread_join (SignalHandlerThread, 0B)) >>>>>;
          if (ret != 0)
            {
              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "Error on join of SignalHandlerThread [%d]\n", ret) >>>>>;
            }
        }
      if (<<cleanup_point syncGetTerminateFlag () == 0>>)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  syncSetFinishedFlag (1) >>>>>;
        }
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (ret = pthread_join (TerminatorThread, 0B)) >>>>>;
      if (ret != 0)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "Error on join of TerminatorThread [%d]\n", ret) >>>>>;
        }
      <<cleanup_point <<< Unknown tree: expr_stmt
  queueDelete (fifo) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  mutexesDelete () >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  disposeMemory<char*> ((char * * &) &FileList) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) gettimeofday (&tvStopTime, (void *) &tz) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (timeStart = (double) tvStartTime.tv_sec + (double) tvStartTime.tv_usec / 1.0e+6) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (timeStop = (double) tvStopTime.tv_sec + (double) tvStopTime.tv_usec / 1.0e+6) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (timeCalc = timeStop - timeStart) >>>>>;
      if (QuietMode != 1)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) fprintf (stderr, (const char *) "\n     Wall Clock: %f seconds\n", timeCalc) >>>>>;
        }
      <<cleanup_point <<< Unknown tree: expr_stmt
  exit (errLevel) >>>>>;
    }
  finally
    {
      std::__cxx11::basic_string<char>::~basic_string (&outFilename);
    }
}
return <retval> = 0;


;; Function const _CharT* std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::c_str() const [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (const char *) std::__cxx11::basic_string<char>::_M_data ((const struct basic_string *) this)>>
   >>>;


;; Function __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...)::_Save_errno::_Save_errno() [with _TRet = long int; _Ret = int; _CharT = char; _Base = {int}] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  *(struct 
  {
    int _M_errno;
  } &) this = {CLOBBER} >>>>>;
{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Save_errno *) this)->_M_errno = *__errno_location ()) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__errno_location () = 0) >>>>>;
}


;; Function __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...)::_Save_errno::~_Save_errno() [with _TRet = long int; _Ret = int; _CharT = char; _Base = {int}] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    try
      {
        if (*__errno_location () == 0)
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__errno_location () = ((struct _Save_errno *) this)->_M_errno) >>>>>;
          }
      }
    finally
      {
        *(struct 
        {
          int _M_errno;
        } &) this = {CLOBBER};
      }
  }
  <D.39931>:;
   >>>;


;; Function static bool __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...)::_Range_chk::_S_chk(_TRet, std::false_type) [with _TRet = long int; _Ret = int; _CharT = char; _Base = {int}; std::false_type = std::integral_constant<bool, false>] (null)
;; enabled by -tree-original


return <retval> = 0;


;; Function static bool __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...)::_Range_chk::_S_chk(_TRet, std::true_type) [with _TRet = long int; _Ret = int; _CharT = char; _Base = {int}; std::true_type = std::integral_constant<bool, true>] (null)
;; enabled by -tree-original


return <retval> = (unsigned long) __val + 2147483648 > 4294967295;


;; Function _Ret __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...) [with _TRet = long int; _Ret = int; _CharT = char; _Base = {int}; std::size_t = long unsigned int] (_ZN9__gnu_cxx6__stoaIlicJiEEET0_PFT_PKT1_PPS3_DpT2_EPKcS5_PmS9_)
;; enabled by -tree-original


{
  int __ret;
  char * __endptr;
  typedef extern struct _Save_errno _Save_errno;
  const struct _Save_errno __save_errno;
  typedef extern struct _Range_chk _Range_chk;
  const long int __tmp;

    int __ret;
    char * __endptr;
    const struct _Save_errno __save_errno;
  <<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...) [with _TRet = long int; _Ret = int; _CharT = char; _Base = {int}; std::size_t = long unsigned int]::_Save_errno::_Save_errno ((struct _Save_errno *) &__save_errno) >>>>>;
  try
    {
            const long int __tmp;
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__tmp = __convf (__str, &__endptr, __base#0)) >>>>>;
      if ((const char *) __endptr == __str)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_invalid_argument (__name) >>>>>;
        }
      else
        {
          if (<<cleanup_point *__errno_location () == 34 || __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...) [with _TRet = long int; _Ret = int; _CharT = char; _Base = {int}; std::size_t = long unsigned int]::_Range_chk::_S_chk ((long int) __tmp, TARGET_EXPR <D.40043, *(struct integral_constant &) &TARGET_EXPR <D.40009, {}>>;, <<< Unknown tree: empty_class_expr >>>;)>>)
            {
              <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_out_of_range (__name) >>>>>;
            }
          else
            {
              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__ret = (int) __tmp) >>>>>;
            }
        }
      if (__idx != 0B)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__idx = (size_t) ((long int) __endptr - (long int) __str)) >>>>>;
        }
      return <retval> = __ret;
    }
  finally
    {
      __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...) [with _TRet = long int; _Ret = int; _CharT = char; _Base = {int}; std::size_t = long unsigned int]::_Save_errno::~_Save_errno ((struct _Save_errno *) &__save_errno);
    }
}


;; Function __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...)::_Save_errno::_Save_errno() [with _TRet = long int; _Ret = long int; _CharT = char; _Base = {int}] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  *(struct 
  {
    int _M_errno;
  } &) this = {CLOBBER} >>>>>;
{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Save_errno *) this)->_M_errno = *__errno_location ()) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__errno_location () = 0) >>>>>;
}


;; Function __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...)::_Save_errno::~_Save_errno() [with _TRet = long int; _Ret = long int; _CharT = char; _Base = {int}] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    try
      {
        if (*__errno_location () == 0)
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__errno_location () = ((struct _Save_errno *) this)->_M_errno) >>>>>;
          }
      }
    finally
      {
        *(struct 
        {
          int _M_errno;
        } &) this = {CLOBBER};
      }
  }
  <D.40080>:;
   >>>;


;; Function static bool __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...)::_Range_chk::_S_chk(_TRet, std::false_type) [with _TRet = long int; _Ret = long int; _CharT = char; _Base = {int}; std::false_type = std::integral_constant<bool, false>] (null)
;; enabled by -tree-original


return <retval> = 0;


;; Function static bool __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...)::_Range_chk::_S_chk(_TRet, std::true_type) [with _TRet = long int; _Ret = long int; _CharT = char; _Base = {int}; std::true_type = std::integral_constant<bool, true>] (null)
;; enabled by -tree-original


return <retval> = (unsigned long) __val + 2147483648 > 4294967295;


;; Function _Ret __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...) [with _TRet = long int; _Ret = long int; _CharT = char; _Base = {int}; std::size_t = long unsigned int] (_ZN9__gnu_cxx6__stoaIllcJiEEET0_PFT_PKT1_PPS3_DpT2_EPKcS5_PmS9_)
;; enabled by -tree-original


{
  long int __ret;
  char * __endptr;
  typedef extern struct _Save_errno _Save_errno;
  const struct _Save_errno __save_errno;
  typedef extern struct _Range_chk _Range_chk;
  const long int __tmp;

    long int __ret;
    char * __endptr;
    const struct _Save_errno __save_errno;
  <<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...) [with _TRet = long int; _Ret = long int; _CharT = char; _Base = {int}; std::size_t = long unsigned int]::_Save_errno::_Save_errno ((struct _Save_errno *) &__save_errno) >>>>>;
  try
    {
            const long int __tmp;
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__tmp = __convf (__str, &__endptr, __base#0)) >>>>>;
      if ((const char *) __endptr == __str)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_invalid_argument (__name) >>>>>;
        }
      else
        {
          if (<<cleanup_point *__errno_location () == 34 || __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...) [with _TRet = long int; _Ret = long int; _CharT = char; _Base = {int}; std::size_t = long unsigned int]::_Range_chk::_S_chk ((long int) __tmp, TARGET_EXPR <D.40144, *(struct integral_constant &) &TARGET_EXPR <D.40134, {}>>;, <<< Unknown tree: empty_class_expr >>>;)>>)
            {
              <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_out_of_range (__name) >>>>>;
            }
          else
            {
              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__ret = (long int) __tmp) >>>>>;
            }
        }
      if (__idx != 0B)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__idx = (size_t) ((long int) __endptr - (long int) __str)) >>>>>;
        }
      return <retval> = __ret;
    }
  finally
    {
      __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...) [with _TRet = long int; _Ret = long int; _CharT = char; _Base = {int}; std::size_t = long unsigned int]::_Save_errno::~_Save_errno ((struct _Save_errno *) &__save_errno);
    }
}


;; Function __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...)::_Save_errno::_Save_errno() [with _TRet = long unsigned int; _Ret = long unsigned int; _CharT = char; _Base = {int}] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  *(struct 
  {
    int _M_errno;
  } &) this = {CLOBBER} >>>>>;
{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Save_errno *) this)->_M_errno = *__errno_location ()) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__errno_location () = 0) >>>>>;
}


;; Function __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...)::_Save_errno::~_Save_errno() [with _TRet = long unsigned int; _Ret = long unsigned int; _CharT = char; _Base = {int}] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    try
      {
        if (*__errno_location () == 0)
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__errno_location () = ((struct _Save_errno *) this)->_M_errno) >>>>>;
          }
      }
    finally
      {
        *(struct 
        {
          int _M_errno;
        } &) this = {CLOBBER};
      }
  }
  <D.40181>:;
   >>>;


;; Function static bool __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...)::_Range_chk::_S_chk(_TRet, std::false_type) [with _TRet = long unsigned int; _Ret = long unsigned int; _CharT = char; _Base = {int}; std::false_type = std::integral_constant<bool, false>] (null)
;; enabled by -tree-original


return <retval> = 0;


;; Function static bool __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...)::_Range_chk::_S_chk(_TRet, std::true_type) [with _TRet = long unsigned int; _Ret = long unsigned int; _CharT = char; _Base = {int}; std::true_type = std::integral_constant<bool, true>] (null)
;; enabled by -tree-original


return <retval> = 1;


;; Function _Ret __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...) [with _TRet = long unsigned int; _Ret = long unsigned int; _CharT = char; _Base = {int}; std::size_t = long unsigned int] (_ZN9__gnu_cxx6__stoaImmcJiEEET0_PFT_PKT1_PPS3_DpT2_EPKcS5_PmS9_)
;; enabled by -tree-original


{
  long unsigned int __ret;
  char * __endptr;
  typedef extern struct _Save_errno _Save_errno;
  const struct _Save_errno __save_errno;
  typedef extern struct _Range_chk _Range_chk;
  const long unsigned int __tmp;

    long unsigned int __ret;
    char * __endptr;
    const struct _Save_errno __save_errno;
  <<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...) [with _TRet = long unsigned int; _Ret = long unsigned int; _CharT = char; _Base = {int}; std::size_t = long unsigned int]::_Save_errno::_Save_errno ((struct _Save_errno *) &__save_errno) >>>>>;
  try
    {
            const long unsigned int __tmp;
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__tmp = __convf (__str, &__endptr, __base#0)) >>>>>;
      if ((const char *) __endptr == __str)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_invalid_argument (__name) >>>>>;
        }
      else
        {
          if (<<cleanup_point *__errno_location () == 34 || __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...) [with _TRet = long unsigned int; _Ret = long unsigned int; _CharT = char; _Base = {int}; std::size_t = long unsigned int]::_Range_chk::_S_chk ((long unsigned int) __tmp, TARGET_EXPR <D.40236, *(struct integral_constant &) &TARGET_EXPR <D.40226, {}>>;, <<< Unknown tree: empty_class_expr >>>;)>>)
            {
              <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_out_of_range (__name) >>>>>;
            }
          else
            {
              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__ret = (long unsigned int) __tmp) >>>>>;
            }
        }
      if (__idx != 0B)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__idx = (size_t) ((long int) __endptr - (long int) __str)) >>>>>;
        }
      return <retval> = __ret;
    }
  finally
    {
      __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...) [with _TRet = long unsigned int; _Ret = long unsigned int; _CharT = char; _Base = {int}; std::size_t = long unsigned int]::_Save_errno::~_Save_errno ((struct _Save_errno *) &__save_errno);
    }
}


;; Function __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...)::_Save_errno::_Save_errno() [with _TRet = long long int; _Ret = long long int; _CharT = char; _Base = {int}] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  *(struct 
  {
    int _M_errno;
  } &) this = {CLOBBER} >>>>>;
{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Save_errno *) this)->_M_errno = *__errno_location ()) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__errno_location () = 0) >>>>>;
}


;; Function __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...)::_Save_errno::~_Save_errno() [with _TRet = long long int; _Ret = long long int; _CharT = char; _Base = {int}] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    try
      {
        if (*__errno_location () == 0)
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__errno_location () = ((struct _Save_errno *) this)->_M_errno) >>>>>;
          }
      }
    finally
      {
        *(struct 
        {
          int _M_errno;
        } &) this = {CLOBBER};
      }
  }
  <D.40273>:;
   >>>;


;; Function static bool __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...)::_Range_chk::_S_chk(_TRet, std::false_type) [with _TRet = long long int; _Ret = long long int; _CharT = char; _Base = {int}; std::false_type = std::integral_constant<bool, false>] (null)
;; enabled by -tree-original


return <retval> = 0;


;; Function static bool __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...)::_Range_chk::_S_chk(_TRet, std::true_type) [with _TRet = long long int; _Ret = long long int; _CharT = char; _Base = {int}; std::true_type = std::integral_constant<bool, true>] (null)
;; enabled by -tree-original


return <retval> = (unsigned long) __val + 2147483648 > 4294967295;


;; Function _Ret __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...) [with _TRet = long long int; _Ret = long long int; _CharT = char; _Base = {int}; std::size_t = long unsigned int] (_ZN9__gnu_cxx6__stoaIxxcJiEEET0_PFT_PKT1_PPS3_DpT2_EPKcS5_PmS9_)
;; enabled by -tree-original


{
  long long int __ret;
  char * __endptr;
  typedef extern struct _Save_errno _Save_errno;
  const struct _Save_errno __save_errno;
  typedef extern struct _Range_chk _Range_chk;
  const long long int __tmp;

    long long int __ret;
    char * __endptr;
    const struct _Save_errno __save_errno;
  <<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...) [with _TRet = long long int; _Ret = long long int; _CharT = char; _Base = {int}; std::size_t = long unsigned int]::_Save_errno::_Save_errno ((struct _Save_errno *) &__save_errno) >>>>>;
  try
    {
            const long long int __tmp;
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__tmp = __convf (__str, &__endptr, __base#0)) >>>>>;
      if ((const char *) __endptr == __str)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_invalid_argument (__name) >>>>>;
        }
      else
        {
          if (<<cleanup_point *__errno_location () == 34 || __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...) [with _TRet = long long int; _Ret = long long int; _CharT = char; _Base = {int}; std::size_t = long unsigned int]::_Range_chk::_S_chk ((long long int) __tmp, TARGET_EXPR <D.40328, *(struct integral_constant &) &TARGET_EXPR <D.40318, {}>>;, <<< Unknown tree: empty_class_expr >>>;)>>)
            {
              <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_out_of_range (__name) >>>>>;
            }
          else
            {
              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__ret = (long long int) __tmp) >>>>>;
            }
        }
      if (__idx != 0B)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__idx = (size_t) ((long int) __endptr - (long int) __str)) >>>>>;
        }
      return <retval> = __ret;
    }
  finally
    {
      __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...) [with _TRet = long long int; _Ret = long long int; _CharT = char; _Base = {int}; std::size_t = long unsigned int]::_Save_errno::~_Save_errno ((struct _Save_errno *) &__save_errno);
    }
}


;; Function __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...)::_Save_errno::_Save_errno() [with _TRet = long long unsigned int; _Ret = long long unsigned int; _CharT = char; _Base = {int}] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  *(struct 
  {
    int _M_errno;
  } &) this = {CLOBBER} >>>>>;
{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Save_errno *) this)->_M_errno = *__errno_location ()) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__errno_location () = 0) >>>>>;
}


;; Function __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...)::_Save_errno::~_Save_errno() [with _TRet = long long unsigned int; _Ret = long long unsigned int; _CharT = char; _Base = {int}] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    try
      {
        if (*__errno_location () == 0)
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__errno_location () = ((struct _Save_errno *) this)->_M_errno) >>>>>;
          }
      }
    finally
      {
        *(struct 
        {
          int _M_errno;
        } &) this = {CLOBBER};
      }
  }
  <D.40365>:;
   >>>;


;; Function static bool __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...)::_Range_chk::_S_chk(_TRet, std::false_type) [with _TRet = long long unsigned int; _Ret = long long unsigned int; _CharT = char; _Base = {int}; std::false_type = std::integral_constant<bool, false>] (null)
;; enabled by -tree-original


return <retval> = 0;


;; Function static bool __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...)::_Range_chk::_S_chk(_TRet, std::true_type) [with _TRet = long long unsigned int; _Ret = long long unsigned int; _CharT = char; _Base = {int}; std::true_type = std::integral_constant<bool, true>] (null)
;; enabled by -tree-original


return <retval> = 1;


;; Function _Ret __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...) [with _TRet = long long unsigned int; _Ret = long long unsigned int; _CharT = char; _Base = {int}; std::size_t = long unsigned int] (_ZN9__gnu_cxx6__stoaIyycJiEEET0_PFT_PKT1_PPS3_DpT2_EPKcS5_PmS9_)
;; enabled by -tree-original


{
  long long unsigned int __ret;
  char * __endptr;
  typedef extern struct _Save_errno _Save_errno;
  const struct _Save_errno __save_errno;
  typedef extern struct _Range_chk _Range_chk;
  const long long unsigned int __tmp;

    long long unsigned int __ret;
    char * __endptr;
    const struct _Save_errno __save_errno;
  <<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...) [with _TRet = long long unsigned int; _Ret = long long unsigned int; _CharT = char; _Base = {int}; std::size_t = long unsigned int]::_Save_errno::_Save_errno ((struct _Save_errno *) &__save_errno) >>>>>;
  try
    {
            const long long unsigned int __tmp;
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__tmp = __convf (__str, &__endptr, __base#0)) >>>>>;
      if ((const char *) __endptr == __str)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_invalid_argument (__name) >>>>>;
        }
      else
        {
          if (<<cleanup_point *__errno_location () == 34 || __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...) [with _TRet = long long unsigned int; _Ret = long long unsigned int; _CharT = char; _Base = {int}; std::size_t = long unsigned int]::_Range_chk::_S_chk ((long long unsigned int) __tmp, TARGET_EXPR <D.40420, *(struct integral_constant &) &TARGET_EXPR <D.40410, {}>>;, <<< Unknown tree: empty_class_expr >>>;)>>)
            {
              <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_out_of_range (__name) >>>>>;
            }
          else
            {
              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__ret = (long long unsigned int) __tmp) >>>>>;
            }
        }
      if (__idx != 0B)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__idx = (size_t) ((long int) __endptr - (long int) __str)) >>>>>;
        }
      return <retval> = __ret;
    }
  finally
    {
      __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...) [with _TRet = long long unsigned int; _Ret = long long unsigned int; _CharT = char; _Base = {int}; std::size_t = long unsigned int]::_Save_errno::~_Save_errno ((struct _Save_errno *) &__save_errno);
    }
}


;; Function __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...)::_Save_errno::_Save_errno() [with _TRet = float; _Ret = float; _CharT = char; _Base = {}] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  *(struct 
  {
    int _M_errno;
  } &) this = {CLOBBER} >>>>>;
{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Save_errno *) this)->_M_errno = *__errno_location ()) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__errno_location () = 0) >>>>>;
}


;; Function __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...)::_Save_errno::~_Save_errno() [with _TRet = float; _Ret = float; _CharT = char; _Base = {}] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    try
      {
        if (*__errno_location () == 0)
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__errno_location () = ((struct _Save_errno *) this)->_M_errno) >>>>>;
          }
      }
    finally
      {
        *(struct 
        {
          int _M_errno;
        } &) this = {CLOBBER};
      }
  }
  <D.40457>:;
   >>>;


;; Function static bool __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...)::_Range_chk::_S_chk(_TRet, std::false_type) [with _TRet = float; _Ret = float; _CharT = char; _Base = {}; std::false_type = std::integral_constant<bool, false>] (null)
;; enabled by -tree-original


return <retval> = 0;


;; Function static bool __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...)::_Range_chk::_S_chk(_TRet, std::true_type) [with _TRet = float; _Ret = float; _CharT = char; _Base = {}; std::true_type = std::integral_constant<bool, true>] (null)
;; enabled by -tree-original


return <retval> = __val < -2.147483648e+9 || __val > 2.147483648e+9;


;; Function _Ret __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...) [with _TRet = float; _Ret = float; _CharT = char; _Base = {}; std::size_t = long unsigned int] (_ZN9__gnu_cxx6__stoaIffcJEEET0_PFT_PKT1_PPS3_DpT2_EPKcS5_PmS9_)
;; enabled by -tree-original


{
  float __ret;
  char * __endptr;
  typedef extern struct _Save_errno _Save_errno;
  const struct _Save_errno __save_errno;
  typedef extern struct _Range_chk _Range_chk;
  const float __tmp;

    float __ret;
    char * __endptr;
    const struct _Save_errno __save_errno;
  <<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...) [with _TRet = float; _Ret = float; _CharT = char; _Base = {}; std::size_t = long unsigned int]::_Save_errno::_Save_errno ((struct _Save_errno *) &__save_errno) >>>>>;
  try
    {
            const float __tmp;
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__tmp = __convf (__str, &__endptr)) >>>>>;
      if ((const char *) __endptr == __str)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_invalid_argument (__name) >>>>>;
        }
      else
        {
          if (<<cleanup_point *__errno_location () == 34 || __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...) [with _TRet = float; _Ret = float; _CharT = char; _Base = {}; std::size_t = long unsigned int]::_Range_chk::_S_chk ((float) __tmp, TARGET_EXPR <D.40512, *(struct integral_constant &) &TARGET_EXPR <D.40502, {}>>;, <<< Unknown tree: empty_class_expr >>>;)>>)
            {
              <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_out_of_range (__name) >>>>>;
            }
          else
            {
              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__ret = (float) __tmp) >>>>>;
            }
        }
      if (__idx != 0B)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__idx = (size_t) ((long int) __endptr - (long int) __str)) >>>>>;
        }
      return <retval> = __ret;
    }
  finally
    {
      __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...) [with _TRet = float; _Ret = float; _CharT = char; _Base = {}; std::size_t = long unsigned int]::_Save_errno::~_Save_errno ((struct _Save_errno *) &__save_errno);
    }
}


;; Function __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...)::_Save_errno::_Save_errno() [with _TRet = double; _Ret = double; _CharT = char; _Base = {}] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  *(struct 
  {
    int _M_errno;
  } &) this = {CLOBBER} >>>>>;
{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Save_errno *) this)->_M_errno = *__errno_location ()) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__errno_location () = 0) >>>>>;
}


;; Function __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...)::_Save_errno::~_Save_errno() [with _TRet = double; _Ret = double; _CharT = char; _Base = {}] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    try
      {
        if (*__errno_location () == 0)
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__errno_location () = ((struct _Save_errno *) this)->_M_errno) >>>>>;
          }
      }
    finally
      {
        *(struct 
        {
          int _M_errno;
        } &) this = {CLOBBER};
      }
  }
  <D.40549>:;
   >>>;


;; Function static bool __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...)::_Range_chk::_S_chk(_TRet, std::false_type) [with _TRet = double; _Ret = double; _CharT = char; _Base = {}; std::false_type = std::integral_constant<bool, false>] (null)
;; enabled by -tree-original


return <retval> = 0;


;; Function static bool __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...)::_Range_chk::_S_chk(_TRet, std::true_type) [with _TRet = double; _Ret = double; _CharT = char; _Base = {}; std::true_type = std::integral_constant<bool, true>] (null)
;; enabled by -tree-original


return <retval> = __val < -2.147483648e+9 || __val > 2.147483647e+9;


;; Function _Ret __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...) [with _TRet = double; _Ret = double; _CharT = char; _Base = {}; std::size_t = long unsigned int] (_ZN9__gnu_cxx6__stoaIddcJEEET0_PFT_PKT1_PPS3_DpT2_EPKcS5_PmS9_)
;; enabled by -tree-original


{
  double __ret;
  char * __endptr;
  typedef extern struct _Save_errno _Save_errno;
  const struct _Save_errno __save_errno;
  typedef extern struct _Range_chk _Range_chk;
  const double __tmp;

    double __ret;
    char * __endptr;
    const struct _Save_errno __save_errno;
  <<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...) [with _TRet = double; _Ret = double; _CharT = char; _Base = {}; std::size_t = long unsigned int]::_Save_errno::_Save_errno ((struct _Save_errno *) &__save_errno) >>>>>;
  try
    {
            const double __tmp;
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__tmp = __convf (__str, &__endptr)) >>>>>;
      if ((const char *) __endptr == __str)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_invalid_argument (__name) >>>>>;
        }
      else
        {
          if (<<cleanup_point *__errno_location () == 34 || __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...) [with _TRet = double; _Ret = double; _CharT = char; _Base = {}; std::size_t = long unsigned int]::_Range_chk::_S_chk ((double) __tmp, TARGET_EXPR <D.40604, *(struct integral_constant &) &TARGET_EXPR <D.40594, {}>>;, <<< Unknown tree: empty_class_expr >>>;)>>)
            {
              <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_out_of_range (__name) >>>>>;
            }
          else
            {
              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__ret = (double) __tmp) >>>>>;
            }
        }
      if (__idx != 0B)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__idx = (size_t) ((long int) __endptr - (long int) __str)) >>>>>;
        }
      return <retval> = __ret;
    }
  finally
    {
      __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...) [with _TRet = double; _Ret = double; _CharT = char; _Base = {}; std::size_t = long unsigned int]::_Save_errno::~_Save_errno ((struct _Save_errno *) &__save_errno);
    }
}


;; Function __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...)::_Save_errno::_Save_errno() [with _TRet = long double; _Ret = long double; _CharT = char; _Base = {}] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  *(struct 
  {
    int _M_errno;
  } &) this = {CLOBBER} >>>>>;
{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Save_errno *) this)->_M_errno = *__errno_location ()) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__errno_location () = 0) >>>>>;
}


;; Function __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...)::_Save_errno::~_Save_errno() [with _TRet = long double; _Ret = long double; _CharT = char; _Base = {}] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    try
      {
        if (*__errno_location () == 0)
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__errno_location () = ((struct _Save_errno *) this)->_M_errno) >>>>>;
          }
      }
    finally
      {
        *(struct 
        {
          int _M_errno;
        } &) this = {CLOBBER};
      }
  }
  <D.40641>:;
   >>>;


;; Function static bool __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...)::_Range_chk::_S_chk(_TRet, std::false_type) [with _TRet = long double; _Ret = long double; _CharT = char; _Base = {}; std::false_type = std::integral_constant<bool, false>] (null)
;; enabled by -tree-original


return <retval> = 0;


;; Function static bool __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...)::_Range_chk::_S_chk(_TRet, std::true_type) [with _TRet = long double; _Ret = long double; _CharT = char; _Base = {}; std::true_type = std::integral_constant<bool, true>] (null)
;; enabled by -tree-original


return <retval> = __val < -2.147483648e+9 || __val > 2.147483647e+9;


;; Function _Ret __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...) [with _TRet = long double; _Ret = long double; _CharT = char; _Base = {}; std::size_t = long unsigned int] (_ZN9__gnu_cxx6__stoaIeecJEEET0_PFT_PKT1_PPS3_DpT2_EPKcS5_PmS9_)
;; enabled by -tree-original


{
  long double __ret;
  char * __endptr;
  typedef extern struct _Save_errno _Save_errno;
  const struct _Save_errno __save_errno;
  typedef extern struct _Range_chk _Range_chk;
  const long double __tmp;

    long double __ret;
    char * __endptr;
    const struct _Save_errno __save_errno;
  <<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...) [with _TRet = long double; _Ret = long double; _CharT = char; _Base = {}; std::size_t = long unsigned int]::_Save_errno::_Save_errno ((struct _Save_errno *) &__save_errno) >>>>>;
  try
    {
            const long double __tmp;
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__tmp = __convf (__str, &__endptr)) >>>>>;
      if ((const char *) __endptr == __str)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_invalid_argument (__name) >>>>>;
        }
      else
        {
          if (<<cleanup_point *__errno_location () == 34 || __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...) [with _TRet = long double; _Ret = long double; _CharT = char; _Base = {}; std::size_t = long unsigned int]::_Range_chk::_S_chk ((long double) __tmp, TARGET_EXPR <D.40696, *(struct integral_constant &) &TARGET_EXPR <D.40686, {}>>;, <<< Unknown tree: empty_class_expr >>>;)>>)
            {
              <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_out_of_range (__name) >>>>>;
            }
          else
            {
              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__ret = (long double) __tmp) >>>>>;
            }
        }
      if (__idx != 0B)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__idx = (size_t) ((long int) __endptr - (long int) __str)) >>>>>;
        }
      return <retval> = __ret;
    }
  finally
    {
      __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...) [with _TRet = long double; _Ret = long double; _CharT = char; _Base = {}; std::size_t = long unsigned int]::_Save_errno::~_Save_errno ((struct _Save_errno *) &__save_errno);
    }
}


;; Function _String __gnu_cxx::__to_xstring(int (*)(_CharT*, std::size_t, const _CharT*, __va_list_tag*), std::size_t, const _CharT*, ...) [with _String = std::__cxx11::basic_string<char>; _CharT = char; std::size_t = long unsigned int] (null)
;; enabled by -tree-original


{
  char * __s;
  struct  __args[1];
  const int __len;

    char * __s;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__s = (char *) __builtin_alloca (NON_LVALUE_EXPR <__n>)) >>>>>;
    struct  __args[1];
  <<cleanup_point <<< Unknown tree: expr_stmt
  __builtin_va_start ((struct  *) &__args, __fmt) >>>>>;
    const int __len;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__len = __convf (__s, __n, __fmt, (struct  *) &__args)) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  __builtin_va_end ((struct  *) &__args) >>>>>;
  <<cleanup_point return *<retval> = TARGET_EXPR <D.40884, <<< Unknown tree: aggr_init_expr
  7
  __comp_ctor 
  D.40884
  (struct basic_string *) <<< Unknown tree: void_cst >>>
  __s
  __s + (sizetype) __len
  (const struct allocator &) &TARGET_EXPR <D.40883, <<< Unknown tree: aggr_init_expr
  4
  __comp_ctor 
  D.40883
  (struct allocator *) <<< Unknown tree: void_cst >>> >>>> >>>>>>;
}


;; Function std::__cxx11::basic_string<char>::_Alloc_hider::~_Alloc_hider() (null)
;; enabled by -tree-original


{
  try
    {
      try
        {
          
        }
      finally
        {
          std::allocator<char>::~allocator ((struct allocator *) this);
        }
    }
  finally
    {
      *(struct 
      {
        char * _M_p;
      } &) this = {CLOBBER};
    }
}
<D.40888>:;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::~basic_string() [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    try
      {
        try
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char>::_M_dispose ((struct basic_string *) this) >>>>>;
          }
        finally
          {
            std::__cxx11::basic_string<char>::_Alloc_hider::~_Alloc_hider (&((struct basic_string *) this)->_M_dataplus);
          }
      }
    finally
      {
        *(struct 
        {
          struct _Alloc_hider _M_dataplus;
          size_type _M_string_length;
          union ._71 D.19671;
        } &) this = {CLOBBER};
      }
  }
  <D.40886>:;
   >>>;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point <<< Unknown tree: expr_stmt
  *(struct 
  {
    struct _Alloc_hider _M_dataplus;
    size_type _M_string_length;
    union ._71 D.19671;
  } &) this = {CLOBBER} >>>>>;
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char>::_Alloc_hider::_Alloc_hider (&((struct basic_string *) this)->_M_dataplus, std::__cxx11::basic_string<char>::_M_local_data ((struct basic_string *) this), (struct allocator &) std::move<std::allocator<char>&> ((struct allocator &) std::__cxx11::basic_string<char>::_M_get_allocator ((struct basic_string *) __str))) >>>>>;
    try
      {
        if (<<cleanup_point std::__cxx11::basic_string<char>::_M_is_local ((struct basic_string *) __str)>>)
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) std::char_traits<char>::copy ((char *) &((struct basic_string *) this)->D.18739._M_local_buf, (const char_type *) &__str->D.18739._M_local_buf, 16) >>>>>;
          }
        else
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char>::_M_data ((struct basic_string *) this, std::__cxx11::basic_string<char>::_M_data ((struct basic_string *) __str)) >>>>>;
            <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char>::_M_capacity ((struct basic_string *) this, __str->D.18739._M_allocated_capacity) >>>>>;
          }
        <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char>::_M_length ((struct basic_string *) this, std::__cxx11::basic_string<char>::length ((struct basic_string *) __str)) >>>>>;
        <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char>::_M_data ((struct basic_string *) __str, std::__cxx11::basic_string<char>::_M_local_data ((struct basic_string *) __str)) >>>>>;
        <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char>::_M_set_length ((struct basic_string *) __str, 0) >>>>>;
      }
    catch
      {
        std::__cxx11::basic_string<char>::_Alloc_hider::~_Alloc_hider (&((struct basic_string *) this)->_M_dataplus);
      }
  }
   >>>;


;; Function const _CharT* std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::c_str() const [with _CharT = wchar_t; _Traits = std::char_traits<wchar_t>; _Alloc = std::allocator<wchar_t>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (const wchar_t *) std::__cxx11::basic_string<wchar_t>::_M_data ((const struct basic_string *) this)>>
   >>>;


;; Function __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...)::_Save_errno::_Save_errno() [with _TRet = long int; _Ret = int; _CharT = wchar_t; _Base = {int}] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  *(struct 
  {
    int _M_errno;
  } &) this = {CLOBBER} >>>>>;
{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Save_errno *) this)->_M_errno = *__errno_location ()) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__errno_location () = 0) >>>>>;
}


;; Function __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...)::_Save_errno::~_Save_errno() [with _TRet = long int; _Ret = int; _CharT = wchar_t; _Base = {int}] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    try
      {
        if (*__errno_location () == 0)
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__errno_location () = ((struct _Save_errno *) this)->_M_errno) >>>>>;
          }
      }
    finally
      {
        *(struct 
        {
          int _M_errno;
        } &) this = {CLOBBER};
      }
  }
  <D.40971>:;
   >>>;


;; Function static bool __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...)::_Range_chk::_S_chk(_TRet, std::false_type) [with _TRet = long int; _Ret = int; _CharT = wchar_t; _Base = {int}; std::false_type = std::integral_constant<bool, false>] (null)
;; enabled by -tree-original


return <retval> = 0;


;; Function static bool __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...)::_Range_chk::_S_chk(_TRet, std::true_type) [with _TRet = long int; _Ret = int; _CharT = wchar_t; _Base = {int}; std::true_type = std::integral_constant<bool, true>] (null)
;; enabled by -tree-original


return <retval> = (unsigned long) __val + 2147483648 > 4294967295;


;; Function _Ret __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...) [with _TRet = long int; _Ret = int; _CharT = wchar_t; _Base = {int}; std::size_t = long unsigned int] (_ZN9__gnu_cxx6__stoaIliwJiEEET0_PFT_PKT1_PPS3_DpT2_EPKcS5_PmS9_)
;; enabled by -tree-original


{
  int __ret;
  wchar_t * __endptr;
  typedef extern struct _Save_errno _Save_errno;
  const struct _Save_errno __save_errno;
  typedef extern struct _Range_chk _Range_chk;
  const long int __tmp;

    int __ret;
    wchar_t * __endptr;
    const struct _Save_errno __save_errno;
  <<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...) [with _TRet = long int; _Ret = int; _CharT = wchar_t; _Base = {int}; std::size_t = long unsigned int]::_Save_errno::_Save_errno ((struct _Save_errno *) &__save_errno) >>>>>;
  try
    {
            const long int __tmp;
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__tmp = __convf (__str, &__endptr, __base#0)) >>>>>;
      if ((const wchar_t *) __endptr == __str)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_invalid_argument (__name) >>>>>;
        }
      else
        {
          if (<<cleanup_point *__errno_location () == 34 || __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...) [with _TRet = long int; _Ret = int; _CharT = wchar_t; _Base = {int}; std::size_t = long unsigned int]::_Range_chk::_S_chk ((long int) __tmp, TARGET_EXPR <D.40991, *(struct integral_constant &) &TARGET_EXPR <D.40990, {}>>;, <<< Unknown tree: empty_class_expr >>>;)>>)
            {
              <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_out_of_range (__name) >>>>>;
            }
          else
            {
              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__ret = (int) __tmp) >>>>>;
            }
        }
      if (__idx != 0B)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__idx = (size_t) (((long int) __endptr - (long int) __str) /[ex] 4)) >>>>>;
        }
      return <retval> = __ret;
    }
  finally
    {
      __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...) [with _TRet = long int; _Ret = int; _CharT = wchar_t; _Base = {int}; std::size_t = long unsigned int]::_Save_errno::~_Save_errno ((struct _Save_errno *) &__save_errno);
    }
}


;; Function __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...)::_Save_errno::_Save_errno() [with _TRet = long int; _Ret = long int; _CharT = wchar_t; _Base = {int}] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  *(struct 
  {
    int _M_errno;
  } &) this = {CLOBBER} >>>>>;
{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Save_errno *) this)->_M_errno = *__errno_location ()) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__errno_location () = 0) >>>>>;
}


;; Function __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...)::_Save_errno::~_Save_errno() [with _TRet = long int; _Ret = long int; _CharT = wchar_t; _Base = {int}] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    try
      {
        if (*__errno_location () == 0)
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__errno_location () = ((struct _Save_errno *) this)->_M_errno) >>>>>;
          }
      }
    finally
      {
        *(struct 
        {
          int _M_errno;
        } &) this = {CLOBBER};
      }
  }
  <D.41028>:;
   >>>;


;; Function static bool __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...)::_Range_chk::_S_chk(_TRet, std::false_type) [with _TRet = long int; _Ret = long int; _CharT = wchar_t; _Base = {int}; std::false_type = std::integral_constant<bool, false>] (null)
;; enabled by -tree-original


return <retval> = 0;


;; Function static bool __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...)::_Range_chk::_S_chk(_TRet, std::true_type) [with _TRet = long int; _Ret = long int; _CharT = wchar_t; _Base = {int}; std::true_type = std::integral_constant<bool, true>] (null)
;; enabled by -tree-original


return <retval> = (unsigned long) __val + 2147483648 > 4294967295;


;; Function _Ret __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...) [with _TRet = long int; _Ret = long int; _CharT = wchar_t; _Base = {int}; std::size_t = long unsigned int] (_ZN9__gnu_cxx6__stoaIllwJiEEET0_PFT_PKT1_PPS3_DpT2_EPKcS5_PmS9_)
;; enabled by -tree-original


{
  long int __ret;
  wchar_t * __endptr;
  typedef extern struct _Save_errno _Save_errno;
  const struct _Save_errno __save_errno;
  typedef extern struct _Range_chk _Range_chk;
  const long int __tmp;

    long int __ret;
    wchar_t * __endptr;
    const struct _Save_errno __save_errno;
  <<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...) [with _TRet = long int; _Ret = long int; _CharT = wchar_t; _Base = {int}; std::size_t = long unsigned int]::_Save_errno::_Save_errno ((struct _Save_errno *) &__save_errno) >>>>>;
  try
    {
            const long int __tmp;
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__tmp = __convf (__str, &__endptr, __base#0)) >>>>>;
      if ((const wchar_t *) __endptr == __str)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_invalid_argument (__name) >>>>>;
        }
      else
        {
          if (<<cleanup_point *__errno_location () == 34 || __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...) [with _TRet = long int; _Ret = long int; _CharT = wchar_t; _Base = {int}; std::size_t = long unsigned int]::_Range_chk::_S_chk ((long int) __tmp, TARGET_EXPR <D.41048, *(struct integral_constant &) &TARGET_EXPR <D.41047, {}>>;, <<< Unknown tree: empty_class_expr >>>;)>>)
            {
              <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_out_of_range (__name) >>>>>;
            }
          else
            {
              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__ret = (long int) __tmp) >>>>>;
            }
        }
      if (__idx != 0B)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__idx = (size_t) (((long int) __endptr - (long int) __str) /[ex] 4)) >>>>>;
        }
      return <retval> = __ret;
    }
  finally
    {
      __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...) [with _TRet = long int; _Ret = long int; _CharT = wchar_t; _Base = {int}; std::size_t = long unsigned int]::_Save_errno::~_Save_errno ((struct _Save_errno *) &__save_errno);
    }
}


;; Function __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...)::_Save_errno::_Save_errno() [with _TRet = long unsigned int; _Ret = long unsigned int; _CharT = wchar_t; _Base = {int}] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  *(struct 
  {
    int _M_errno;
  } &) this = {CLOBBER} >>>>>;
{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Save_errno *) this)->_M_errno = *__errno_location ()) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__errno_location () = 0) >>>>>;
}


;; Function __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...)::_Save_errno::~_Save_errno() [with _TRet = long unsigned int; _Ret = long unsigned int; _CharT = wchar_t; _Base = {int}] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    try
      {
        if (*__errno_location () == 0)
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__errno_location () = ((struct _Save_errno *) this)->_M_errno) >>>>>;
          }
      }
    finally
      {
        *(struct 
        {
          int _M_errno;
        } &) this = {CLOBBER};
      }
  }
  <D.41085>:;
   >>>;


;; Function static bool __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...)::_Range_chk::_S_chk(_TRet, std::false_type) [with _TRet = long unsigned int; _Ret = long unsigned int; _CharT = wchar_t; _Base = {int}; std::false_type = std::integral_constant<bool, false>] (null)
;; enabled by -tree-original


return <retval> = 0;


;; Function static bool __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...)::_Range_chk::_S_chk(_TRet, std::true_type) [with _TRet = long unsigned int; _Ret = long unsigned int; _CharT = wchar_t; _Base = {int}; std::true_type = std::integral_constant<bool, true>] (null)
;; enabled by -tree-original


return <retval> = 1;


;; Function _Ret __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...) [with _TRet = long unsigned int; _Ret = long unsigned int; _CharT = wchar_t; _Base = {int}; std::size_t = long unsigned int] (_ZN9__gnu_cxx6__stoaImmwJiEEET0_PFT_PKT1_PPS3_DpT2_EPKcS5_PmS9_)
;; enabled by -tree-original


{
  long unsigned int __ret;
  wchar_t * __endptr;
  typedef extern struct _Save_errno _Save_errno;
  const struct _Save_errno __save_errno;
  typedef extern struct _Range_chk _Range_chk;
  const long unsigned int __tmp;

    long unsigned int __ret;
    wchar_t * __endptr;
    const struct _Save_errno __save_errno;
  <<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...) [with _TRet = long unsigned int; _Ret = long unsigned int; _CharT = wchar_t; _Base = {int}; std::size_t = long unsigned int]::_Save_errno::_Save_errno ((struct _Save_errno *) &__save_errno) >>>>>;
  try
    {
            const long unsigned int __tmp;
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__tmp = __convf (__str, &__endptr, __base#0)) >>>>>;
      if ((const wchar_t *) __endptr == __str)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_invalid_argument (__name) >>>>>;
        }
      else
        {
          if (<<cleanup_point *__errno_location () == 34 || __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...) [with _TRet = long unsigned int; _Ret = long unsigned int; _CharT = wchar_t; _Base = {int}; std::size_t = long unsigned int]::_Range_chk::_S_chk ((long unsigned int) __tmp, TARGET_EXPR <D.41105, *(struct integral_constant &) &TARGET_EXPR <D.41104, {}>>;, <<< Unknown tree: empty_class_expr >>>;)>>)
            {
              <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_out_of_range (__name) >>>>>;
            }
          else
            {
              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__ret = (long unsigned int) __tmp) >>>>>;
            }
        }
      if (__idx != 0B)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__idx = (size_t) (((long int) __endptr - (long int) __str) /[ex] 4)) >>>>>;
        }
      return <retval> = __ret;
    }
  finally
    {
      __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...) [with _TRet = long unsigned int; _Ret = long unsigned int; _CharT = wchar_t; _Base = {int}; std::size_t = long unsigned int]::_Save_errno::~_Save_errno ((struct _Save_errno *) &__save_errno);
    }
}


;; Function __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...)::_Save_errno::_Save_errno() [with _TRet = long long int; _Ret = long long int; _CharT = wchar_t; _Base = {int}] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  *(struct 
  {
    int _M_errno;
  } &) this = {CLOBBER} >>>>>;
{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Save_errno *) this)->_M_errno = *__errno_location ()) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__errno_location () = 0) >>>>>;
}


;; Function __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...)::_Save_errno::~_Save_errno() [with _TRet = long long int; _Ret = long long int; _CharT = wchar_t; _Base = {int}] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    try
      {
        if (*__errno_location () == 0)
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__errno_location () = ((struct _Save_errno *) this)->_M_errno) >>>>>;
          }
      }
    finally
      {
        *(struct 
        {
          int _M_errno;
        } &) this = {CLOBBER};
      }
  }
  <D.41142>:;
   >>>;


;; Function static bool __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...)::_Range_chk::_S_chk(_TRet, std::false_type) [with _TRet = long long int; _Ret = long long int; _CharT = wchar_t; _Base = {int}; std::false_type = std::integral_constant<bool, false>] (null)
;; enabled by -tree-original


return <retval> = 0;


;; Function static bool __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...)::_Range_chk::_S_chk(_TRet, std::true_type) [with _TRet = long long int; _Ret = long long int; _CharT = wchar_t; _Base = {int}; std::true_type = std::integral_constant<bool, true>] (null)
;; enabled by -tree-original


return <retval> = (unsigned long) __val + 2147483648 > 4294967295;


;; Function _Ret __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...) [with _TRet = long long int; _Ret = long long int; _CharT = wchar_t; _Base = {int}; std::size_t = long unsigned int] (_ZN9__gnu_cxx6__stoaIxxwJiEEET0_PFT_PKT1_PPS3_DpT2_EPKcS5_PmS9_)
;; enabled by -tree-original


{
  long long int __ret;
  wchar_t * __endptr;
  typedef extern struct _Save_errno _Save_errno;
  const struct _Save_errno __save_errno;
  typedef extern struct _Range_chk _Range_chk;
  const long long int __tmp;

    long long int __ret;
    wchar_t * __endptr;
    const struct _Save_errno __save_errno;
  <<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...) [with _TRet = long long int; _Ret = long long int; _CharT = wchar_t; _Base = {int}; std::size_t = long unsigned int]::_Save_errno::_Save_errno ((struct _Save_errno *) &__save_errno) >>>>>;
  try
    {
            const long long int __tmp;
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__tmp = __convf (__str, &__endptr, __base#0)) >>>>>;
      if ((const wchar_t *) __endptr == __str)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_invalid_argument (__name) >>>>>;
        }
      else
        {
          if (<<cleanup_point *__errno_location () == 34 || __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...) [with _TRet = long long int; _Ret = long long int; _CharT = wchar_t; _Base = {int}; std::size_t = long unsigned int]::_Range_chk::_S_chk ((long long int) __tmp, TARGET_EXPR <D.41162, *(struct integral_constant &) &TARGET_EXPR <D.41161, {}>>;, <<< Unknown tree: empty_class_expr >>>;)>>)
            {
              <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_out_of_range (__name) >>>>>;
            }
          else
            {
              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__ret = (long long int) __tmp) >>>>>;
            }
        }
      if (__idx != 0B)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__idx = (size_t) (((long int) __endptr - (long int) __str) /[ex] 4)) >>>>>;
        }
      return <retval> = __ret;
    }
  finally
    {
      __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...) [with _TRet = long long int; _Ret = long long int; _CharT = wchar_t; _Base = {int}; std::size_t = long unsigned int]::_Save_errno::~_Save_errno ((struct _Save_errno *) &__save_errno);
    }
}


;; Function __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...)::_Save_errno::_Save_errno() [with _TRet = long long unsigned int; _Ret = long long unsigned int; _CharT = wchar_t; _Base = {int}] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  *(struct 
  {
    int _M_errno;
  } &) this = {CLOBBER} >>>>>;
{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Save_errno *) this)->_M_errno = *__errno_location ()) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__errno_location () = 0) >>>>>;
}


;; Function __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...)::_Save_errno::~_Save_errno() [with _TRet = long long unsigned int; _Ret = long long unsigned int; _CharT = wchar_t; _Base = {int}] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    try
      {
        if (*__errno_location () == 0)
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__errno_location () = ((struct _Save_errno *) this)->_M_errno) >>>>>;
          }
      }
    finally
      {
        *(struct 
        {
          int _M_errno;
        } &) this = {CLOBBER};
      }
  }
  <D.41199>:;
   >>>;


;; Function static bool __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...)::_Range_chk::_S_chk(_TRet, std::false_type) [with _TRet = long long unsigned int; _Ret = long long unsigned int; _CharT = wchar_t; _Base = {int}; std::false_type = std::integral_constant<bool, false>] (null)
;; enabled by -tree-original


return <retval> = 0;


;; Function static bool __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...)::_Range_chk::_S_chk(_TRet, std::true_type) [with _TRet = long long unsigned int; _Ret = long long unsigned int; _CharT = wchar_t; _Base = {int}; std::true_type = std::integral_constant<bool, true>] (null)
;; enabled by -tree-original


return <retval> = 1;


;; Function _Ret __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...) [with _TRet = long long unsigned int; _Ret = long long unsigned int; _CharT = wchar_t; _Base = {int}; std::size_t = long unsigned int] (_ZN9__gnu_cxx6__stoaIyywJiEEET0_PFT_PKT1_PPS3_DpT2_EPKcS5_PmS9_)
;; enabled by -tree-original


{
  long long unsigned int __ret;
  wchar_t * __endptr;
  typedef extern struct _Save_errno _Save_errno;
  const struct _Save_errno __save_errno;
  typedef extern struct _Range_chk _Range_chk;
  const long long unsigned int __tmp;

    long long unsigned int __ret;
    wchar_t * __endptr;
    const struct _Save_errno __save_errno;
  <<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...) [with _TRet = long long unsigned int; _Ret = long long unsigned int; _CharT = wchar_t; _Base = {int}; std::size_t = long unsigned int]::_Save_errno::_Save_errno ((struct _Save_errno *) &__save_errno) >>>>>;
  try
    {
            const long long unsigned int __tmp;
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__tmp = __convf (__str, &__endptr, __base#0)) >>>>>;
      if ((const wchar_t *) __endptr == __str)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_invalid_argument (__name) >>>>>;
        }
      else
        {
          if (<<cleanup_point *__errno_location () == 34 || __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...) [with _TRet = long long unsigned int; _Ret = long long unsigned int; _CharT = wchar_t; _Base = {int}; std::size_t = long unsigned int]::_Range_chk::_S_chk ((long long unsigned int) __tmp, TARGET_EXPR <D.41219, *(struct integral_constant &) &TARGET_EXPR <D.41218, {}>>;, <<< Unknown tree: empty_class_expr >>>;)>>)
            {
              <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_out_of_range (__name) >>>>>;
            }
          else
            {
              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__ret = (long long unsigned int) __tmp) >>>>>;
            }
        }
      if (__idx != 0B)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__idx = (size_t) (((long int) __endptr - (long int) __str) /[ex] 4)) >>>>>;
        }
      return <retval> = __ret;
    }
  finally
    {
      __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...) [with _TRet = long long unsigned int; _Ret = long long unsigned int; _CharT = wchar_t; _Base = {int}; std::size_t = long unsigned int]::_Save_errno::~_Save_errno ((struct _Save_errno *) &__save_errno);
    }
}


;; Function __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...)::_Save_errno::_Save_errno() [with _TRet = float; _Ret = float; _CharT = wchar_t; _Base = {}] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  *(struct 
  {
    int _M_errno;
  } &) this = {CLOBBER} >>>>>;
{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Save_errno *) this)->_M_errno = *__errno_location ()) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__errno_location () = 0) >>>>>;
}


;; Function __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...)::_Save_errno::~_Save_errno() [with _TRet = float; _Ret = float; _CharT = wchar_t; _Base = {}] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    try
      {
        if (*__errno_location () == 0)
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__errno_location () = ((struct _Save_errno *) this)->_M_errno) >>>>>;
          }
      }
    finally
      {
        *(struct 
        {
          int _M_errno;
        } &) this = {CLOBBER};
      }
  }
  <D.41256>:;
   >>>;


;; Function static bool __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...)::_Range_chk::_S_chk(_TRet, std::false_type) [with _TRet = float; _Ret = float; _CharT = wchar_t; _Base = {}; std::false_type = std::integral_constant<bool, false>] (null)
;; enabled by -tree-original


return <retval> = 0;


;; Function static bool __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...)::_Range_chk::_S_chk(_TRet, std::true_type) [with _TRet = float; _Ret = float; _CharT = wchar_t; _Base = {}; std::true_type = std::integral_constant<bool, true>] (null)
;; enabled by -tree-original


return <retval> = __val < -2.147483648e+9 || __val > 2.147483648e+9;


;; Function _Ret __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...) [with _TRet = float; _Ret = float; _CharT = wchar_t; _Base = {}; std::size_t = long unsigned int] (_ZN9__gnu_cxx6__stoaIffwJEEET0_PFT_PKT1_PPS3_DpT2_EPKcS5_PmS9_)
;; enabled by -tree-original


{
  float __ret;
  wchar_t * __endptr;
  typedef extern struct _Save_errno _Save_errno;
  const struct _Save_errno __save_errno;
  typedef extern struct _Range_chk _Range_chk;
  const float __tmp;

    float __ret;
    wchar_t * __endptr;
    const struct _Save_errno __save_errno;
  <<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...) [with _TRet = float; _Ret = float; _CharT = wchar_t; _Base = {}; std::size_t = long unsigned int]::_Save_errno::_Save_errno ((struct _Save_errno *) &__save_errno) >>>>>;
  try
    {
            const float __tmp;
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__tmp = __convf (__str, &__endptr)) >>>>>;
      if ((const wchar_t *) __endptr == __str)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_invalid_argument (__name) >>>>>;
        }
      else
        {
          if (<<cleanup_point *__errno_location () == 34 || __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...) [with _TRet = float; _Ret = float; _CharT = wchar_t; _Base = {}; std::size_t = long unsigned int]::_Range_chk::_S_chk ((float) __tmp, TARGET_EXPR <D.41276, *(struct integral_constant &) &TARGET_EXPR <D.41275, {}>>;, <<< Unknown tree: empty_class_expr >>>;)>>)
            {
              <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_out_of_range (__name) >>>>>;
            }
          else
            {
              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__ret = (float) __tmp) >>>>>;
            }
        }
      if (__idx != 0B)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__idx = (size_t) (((long int) __endptr - (long int) __str) /[ex] 4)) >>>>>;
        }
      return <retval> = __ret;
    }
  finally
    {
      __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...) [with _TRet = float; _Ret = float; _CharT = wchar_t; _Base = {}; std::size_t = long unsigned int]::_Save_errno::~_Save_errno ((struct _Save_errno *) &__save_errno);
    }
}


;; Function __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...)::_Save_errno::_Save_errno() [with _TRet = double; _Ret = double; _CharT = wchar_t; _Base = {}] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  *(struct 
  {
    int _M_errno;
  } &) this = {CLOBBER} >>>>>;
{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Save_errno *) this)->_M_errno = *__errno_location ()) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__errno_location () = 0) >>>>>;
}


;; Function __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...)::_Save_errno::~_Save_errno() [with _TRet = double; _Ret = double; _CharT = wchar_t; _Base = {}] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    try
      {
        if (*__errno_location () == 0)
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__errno_location () = ((struct _Save_errno *) this)->_M_errno) >>>>>;
          }
      }
    finally
      {
        *(struct 
        {
          int _M_errno;
        } &) this = {CLOBBER};
      }
  }
  <D.41313>:;
   >>>;


;; Function static bool __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...)::_Range_chk::_S_chk(_TRet, std::false_type) [with _TRet = double; _Ret = double; _CharT = wchar_t; _Base = {}; std::false_type = std::integral_constant<bool, false>] (null)
;; enabled by -tree-original


return <retval> = 0;


;; Function static bool __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...)::_Range_chk::_S_chk(_TRet, std::true_type) [with _TRet = double; _Ret = double; _CharT = wchar_t; _Base = {}; std::true_type = std::integral_constant<bool, true>] (null)
;; enabled by -tree-original


return <retval> = __val < -2.147483648e+9 || __val > 2.147483647e+9;


;; Function _Ret __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...) [with _TRet = double; _Ret = double; _CharT = wchar_t; _Base = {}; std::size_t = long unsigned int] (_ZN9__gnu_cxx6__stoaIddwJEEET0_PFT_PKT1_PPS3_DpT2_EPKcS5_PmS9_)
;; enabled by -tree-original


{
  double __ret;
  wchar_t * __endptr;
  typedef extern struct _Save_errno _Save_errno;
  const struct _Save_errno __save_errno;
  typedef extern struct _Range_chk _Range_chk;
  const double __tmp;

    double __ret;
    wchar_t * __endptr;
    const struct _Save_errno __save_errno;
  <<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...) [with _TRet = double; _Ret = double; _CharT = wchar_t; _Base = {}; std::size_t = long unsigned int]::_Save_errno::_Save_errno ((struct _Save_errno *) &__save_errno) >>>>>;
  try
    {
            const double __tmp;
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__tmp = __convf (__str, &__endptr)) >>>>>;
      if ((const wchar_t *) __endptr == __str)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_invalid_argument (__name) >>>>>;
        }
      else
        {
          if (<<cleanup_point *__errno_location () == 34 || __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...) [with _TRet = double; _Ret = double; _CharT = wchar_t; _Base = {}; std::size_t = long unsigned int]::_Range_chk::_S_chk ((double) __tmp, TARGET_EXPR <D.41333, *(struct integral_constant &) &TARGET_EXPR <D.41332, {}>>;, <<< Unknown tree: empty_class_expr >>>;)>>)
            {
              <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_out_of_range (__name) >>>>>;
            }
          else
            {
              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__ret = (double) __tmp) >>>>>;
            }
        }
      if (__idx != 0B)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__idx = (size_t) (((long int) __endptr - (long int) __str) /[ex] 4)) >>>>>;
        }
      return <retval> = __ret;
    }
  finally
    {
      __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...) [with _TRet = double; _Ret = double; _CharT = wchar_t; _Base = {}; std::size_t = long unsigned int]::_Save_errno::~_Save_errno ((struct _Save_errno *) &__save_errno);
    }
}


;; Function __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...)::_Save_errno::_Save_errno() [with _TRet = long double; _Ret = long double; _CharT = wchar_t; _Base = {}] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  *(struct 
  {
    int _M_errno;
  } &) this = {CLOBBER} >>>>>;
{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Save_errno *) this)->_M_errno = *__errno_location ()) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__errno_location () = 0) >>>>>;
}


;; Function __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...)::_Save_errno::~_Save_errno() [with _TRet = long double; _Ret = long double; _CharT = wchar_t; _Base = {}] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    try
      {
        if (*__errno_location () == 0)
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__errno_location () = ((struct _Save_errno *) this)->_M_errno) >>>>>;
          }
      }
    finally
      {
        *(struct 
        {
          int _M_errno;
        } &) this = {CLOBBER};
      }
  }
  <D.41370>:;
   >>>;


;; Function static bool __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...)::_Range_chk::_S_chk(_TRet, std::false_type) [with _TRet = long double; _Ret = long double; _CharT = wchar_t; _Base = {}; std::false_type = std::integral_constant<bool, false>] (null)
;; enabled by -tree-original


return <retval> = 0;


;; Function static bool __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...)::_Range_chk::_S_chk(_TRet, std::true_type) [with _TRet = long double; _Ret = long double; _CharT = wchar_t; _Base = {}; std::true_type = std::integral_constant<bool, true>] (null)
;; enabled by -tree-original


return <retval> = __val < -2.147483648e+9 || __val > 2.147483647e+9;


;; Function _Ret __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...) [with _TRet = long double; _Ret = long double; _CharT = wchar_t; _Base = {}; std::size_t = long unsigned int] (_ZN9__gnu_cxx6__stoaIeewJEEET0_PFT_PKT1_PPS3_DpT2_EPKcS5_PmS9_)
;; enabled by -tree-original


{
  long double __ret;
  wchar_t * __endptr;
  typedef extern struct _Save_errno _Save_errno;
  const struct _Save_errno __save_errno;
  typedef extern struct _Range_chk _Range_chk;
  const long double __tmp;

    long double __ret;
    wchar_t * __endptr;
    const struct _Save_errno __save_errno;
  <<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...) [with _TRet = long double; _Ret = long double; _CharT = wchar_t; _Base = {}; std::size_t = long unsigned int]::_Save_errno::_Save_errno ((struct _Save_errno *) &__save_errno) >>>>>;
  try
    {
            const long double __tmp;
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__tmp = __convf (__str, &__endptr)) >>>>>;
      if ((const wchar_t *) __endptr == __str)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_invalid_argument (__name) >>>>>;
        }
      else
        {
          if (<<cleanup_point *__errno_location () == 34 || __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...) [with _TRet = long double; _Ret = long double; _CharT = wchar_t; _Base = {}; std::size_t = long unsigned int]::_Range_chk::_S_chk ((long double) __tmp, TARGET_EXPR <D.41390, *(struct integral_constant &) &TARGET_EXPR <D.41389, {}>>;, <<< Unknown tree: empty_class_expr >>>;)>>)
            {
              <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_out_of_range (__name) >>>>>;
            }
          else
            {
              <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__ret = (long double) __tmp) >>>>>;
            }
        }
      if (__idx != 0B)
        {
          <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__idx = (size_t) (((long int) __endptr - (long int) __str) /[ex] 4)) >>>>>;
        }
      return <retval> = __ret;
    }
  finally
    {
      __gnu_cxx::__stoa(_TRet (*)(const _CharT*, _CharT**, _Base ...), const char*, const _CharT*, std::size_t*, _Base ...) [with _TRet = long double; _Ret = long double; _CharT = wchar_t; _Base = {}; std::size_t = long unsigned int]::_Save_errno::~_Save_errno ((struct _Save_errno *) &__save_errno);
    }
}


;; Function _String __gnu_cxx::__to_xstring(int (*)(_CharT*, std::size_t, const _CharT*, __va_list_tag*), std::size_t, const _CharT*, ...) [with _String = std::__cxx11::basic_string<wchar_t>; _CharT = wchar_t; std::size_t = long unsigned int] (null)
;; enabled by -tree-original


{
  wchar_t * __s;
  struct  __args[1];
  const int __len;

    wchar_t * __s;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__s = (wchar_t *) __builtin_alloca (__n * 4)) >>>>>;
    struct  __args[1];
  <<cleanup_point <<< Unknown tree: expr_stmt
  __builtin_va_start ((struct  *) &__args, __fmt) >>>>>;
    const int __len;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__len = __convf (__s, __n, __fmt, (struct  *) &__args)) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  __builtin_va_end ((struct  *) &__args) >>>>>;
  <<cleanup_point return *<retval> = TARGET_EXPR <D.41422, <<< Unknown tree: aggr_init_expr
  7
  __comp_ctor 
  D.41422
  (struct basic_string *) <<< Unknown tree: void_cst >>>
  __s
  __s + (sizetype) ((long unsigned int) __len * 4)
  (const struct allocator &) &TARGET_EXPR <D.41421, <<< Unknown tree: aggr_init_expr
  4
  __comp_ctor 
  D.41421
  (struct allocator *) <<< Unknown tree: void_cst >>> >>>> >>>>>>;
}


;; Function std::__cxx11::basic_string<wchar_t>::_Alloc_hider::~_Alloc_hider() (null)
;; enabled by -tree-original


{
  try
    {
      try
        {
          
        }
      finally
        {
          std::allocator<wchar_t>::~allocator ((struct allocator *) this);
        }
    }
  finally
    {
      *(struct 
      {
        wchar_t * _M_p;
      } &) this = {CLOBBER};
    }
}
<D.41426>:;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::~basic_string() [with _CharT = wchar_t; _Traits = std::char_traits<wchar_t>; _Alloc = std::allocator<wchar_t>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    try
      {
        try
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<wchar_t>::_M_dispose ((struct basic_string *) this) >>>>>;
          }
        finally
          {
            std::__cxx11::basic_string<wchar_t>::_Alloc_hider::~_Alloc_hider (&((struct basic_string *) this)->_M_dataplus);
          }
      }
    finally
      {
        *(struct 
        {
          struct _Alloc_hider _M_dataplus;
          size_type _M_string_length;
          union ._71 D.21070;
        } &) this = {CLOBBER};
      }
  }
  <D.41424>:;
   >>>;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&&) [with _CharT = wchar_t; _Traits = std::char_traits<wchar_t>; _Alloc = std::allocator<wchar_t>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point <<< Unknown tree: expr_stmt
  *(struct 
  {
    struct _Alloc_hider _M_dataplus;
    size_type _M_string_length;
    union ._71 D.21070;
  } &) this = {CLOBBER} >>>>>;
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<wchar_t>::_Alloc_hider::_Alloc_hider (&((struct basic_string *) this)->_M_dataplus, std::__cxx11::basic_string<wchar_t>::_M_local_data ((struct basic_string *) this), (struct allocator &) std::move<std::allocator<wchar_t>&> ((struct allocator &) std::__cxx11::basic_string<wchar_t>::_M_get_allocator ((struct basic_string *) __str))) >>>>>;
    try
      {
        if (<<cleanup_point std::__cxx11::basic_string<wchar_t>::_M_is_local ((struct basic_string *) __str)>>)
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) std::char_traits<wchar_t>::copy ((wchar_t *) &((struct basic_string *) this)->D.20139._M_local_buf, (const char_type *) &__str->D.20139._M_local_buf, 4) >>>>>;
          }
        else
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<wchar_t>::_M_data ((struct basic_string *) this, std::__cxx11::basic_string<wchar_t>::_M_data ((struct basic_string *) __str)) >>>>>;
            <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<wchar_t>::_M_capacity ((struct basic_string *) this, __str->D.20139._M_allocated_capacity) >>>>>;
          }
        <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<wchar_t>::_M_length ((struct basic_string *) this, std::__cxx11::basic_string<wchar_t>::length ((struct basic_string *) __str)) >>>>>;
        <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<wchar_t>::_M_data ((struct basic_string *) __str, std::__cxx11::basic_string<wchar_t>::_M_local_data ((struct basic_string *) __str)) >>>>>;
        <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<wchar_t>::_M_set_length ((struct basic_string *) __str, 0) >>>>>;
      }
    catch
      {
        std::__cxx11::basic_string<wchar_t>::_Alloc_hider::~_Alloc_hider (&((struct basic_string *) this)->_M_dataplus);
      }
  }
   >>>;


;; Function static std::size_t std::_Hash_impl::hash(const _Tp&) [with _Tp = float; std::size_t = long unsigned int] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = std::_Hash_impl::hash ((const void *) __val, 4, 3339675911)>>;


;; Function static std::size_t std::_Hash_impl::hash(const _Tp&) [with _Tp = double; std::size_t = long unsigned int] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = std::_Hash_impl::hash ((const void *) __val, 8, 3339675911)>>;


;; Function const _CharT* std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::data() const [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (const char *) std::__cxx11::basic_string<char>::_M_data ((const struct basic_string *) this)>>
   >>>;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::length() const [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (size_type) ((const struct basic_string *) this)->_M_string_length
   >>>;


;; Function const _CharT* std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::data() const [with _CharT = wchar_t; _Traits = std::char_traits<wchar_t>; _Alloc = std::allocator<wchar_t>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (const wchar_t *) std::__cxx11::basic_string<wchar_t>::_M_data ((const struct basic_string *) this)>>
   >>>;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::length() const [with _CharT = wchar_t; _Traits = std::char_traits<wchar_t>; _Alloc = std::allocator<wchar_t>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (size_type) ((const struct basic_string *) this)->_M_string_length
   >>>;


;; Function const _CharT* std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::data() const [with _CharT = char16_t; _Traits = std::char_traits<char16_t>; _Alloc = std::allocator<char16_t>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (const char16_t *) std::__cxx11::basic_string<char16_t>::_M_data ((const struct basic_string *) this)>>
   >>>;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::length() const [with _CharT = char16_t; _Traits = std::char_traits<char16_t>; _Alloc = std::allocator<char16_t>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (size_type) ((const struct basic_string *) this)->_M_string_length
   >>>;


;; Function const _CharT* std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::data() const [with _CharT = char32_t; _Traits = std::char_traits<char32_t>; _Alloc = std::allocator<char32_t>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (const char32_t *) std::__cxx11::basic_string<char32_t>::_M_data ((const struct basic_string *) this)>>
   >>>;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::length() const [with _CharT = char32_t; _Traits = std::char_traits<char32_t>; _Alloc = std::allocator<char32_t>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (size_type) ((const struct basic_string *) this)->_M_string_length
   >>>;


;; Function std::allocator< <template-parameter-1-1> >::allocator() [with _Tp = char] (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::new_allocator<char>::new_allocator ((struct new_allocator *) this) >>>>>;
    try
      {
        
      }
    catch
      {
        __gnu_cxx::new_allocator<char>::~new_allocator ((struct new_allocator *) this);
      }
  }
   >>>;


;; Function std::allocator< <template-parameter-1-1> >::~allocator() [with _Tp = char] (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  {
    try
      {
        
      }
    finally
      {
        __gnu_cxx::new_allocator<char>::~new_allocator ((struct new_allocator *) this);
      }
  }
  <D.41487>:;
   >>>;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(const _CharT*, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type, const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  *(struct 
  {
    struct _Alloc_hider _M_dataplus;
    size_type _M_string_length;
    union ._71 D.19671;
  } &) this = {CLOBBER} >>>>>;
{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char>::_Alloc_hider::_Alloc_hider (&((struct basic_string *) this)->_M_dataplus, std::__cxx11::basic_string<char>::_M_local_data ((struct basic_string *) this), __a) >>>>>;
  try
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char>::_M_construct<const char*> ((struct basic_string *) this, __s, __s + (sizetype) NON_LVALUE_EXPR <__n>) >>>>>;
    }
  catch
    {
      std::__cxx11::basic_string<char>::_Alloc_hider::~_Alloc_hider (&((struct basic_string *) this)->_M_dataplus);
    }
}


;; Function std::allocator< <template-parameter-1-1> >::allocator() [with _Tp = wchar_t] (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::new_allocator<wchar_t>::new_allocator ((struct new_allocator *) this) >>>>>;
    try
      {
        
      }
    catch
      {
        __gnu_cxx::new_allocator<wchar_t>::~new_allocator ((struct new_allocator *) this);
      }
  }
   >>>;


;; Function std::allocator< <template-parameter-1-1> >::~allocator() [with _Tp = wchar_t] (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  {
    try
      {
        
      }
    finally
      {
        __gnu_cxx::new_allocator<wchar_t>::~new_allocator ((struct new_allocator *) this);
      }
  }
  <D.41504>:;
   >>>;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(const _CharT*, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type, const _Alloc&) [with _CharT = wchar_t; _Traits = std::char_traits<wchar_t>; _Alloc = std::allocator<wchar_t>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  *(struct 
  {
    struct _Alloc_hider _M_dataplus;
    size_type _M_string_length;
    union ._71 D.21070;
  } &) this = {CLOBBER} >>>>>;
{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<wchar_t>::_Alloc_hider::_Alloc_hider (&((struct basic_string *) this)->_M_dataplus, std::__cxx11::basic_string<wchar_t>::_M_local_data ((struct basic_string *) this), __a) >>>>>;
  try
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<wchar_t>::_M_construct<const wchar_t*> ((struct basic_string *) this, __s, __s + (sizetype) (__n * 4)) >>>>>;
    }
  catch
    {
      std::__cxx11::basic_string<wchar_t>::_Alloc_hider::~_Alloc_hider (&((struct basic_string *) this)->_M_dataplus);
    }
}


;; Function std::allocator< <template-parameter-1-1> >::allocator() [with _Tp = char16_t] (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::new_allocator<char16_t>::new_allocator ((struct new_allocator *) this) >>>>>;
    try
      {
        
      }
    catch
      {
        __gnu_cxx::new_allocator<char16_t>::~new_allocator ((struct new_allocator *) this);
      }
  }
   >>>;


;; Function std::allocator< <template-parameter-1-1> >::~allocator() [with _Tp = char16_t] (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  {
    try
      {
        
      }
    finally
      {
        __gnu_cxx::new_allocator<char16_t>::~new_allocator ((struct new_allocator *) this);
      }
  }
  <D.41521>:;
   >>>;


;; Function std::__cxx11::basic_string<char16_t>::_Alloc_hider::~_Alloc_hider() (null)
;; enabled by -tree-original


{
  try
    {
      try
        {
          
        }
      finally
        {
          std::allocator<char16_t>::~allocator ((struct allocator *) this);
        }
    }
  finally
    {
      *(struct 
      {
        char16_t * _M_p;
      } &) this = {CLOBBER};
    }
}
<D.41556>:;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(const _CharT*, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type, const _Alloc&) [with _CharT = char16_t; _Traits = std::char_traits<char16_t>; _Alloc = std::allocator<char16_t>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  *(struct 
  {
    struct _Alloc_hider _M_dataplus;
    size_type _M_string_length;
    union ._71 D.22943;
  } &) this = {CLOBBER} >>>>>;
{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char16_t>::_Alloc_hider::_Alloc_hider (&((struct basic_string *) this)->_M_dataplus, std::__cxx11::basic_string<char16_t>::_M_local_data ((struct basic_string *) this), __a) >>>>>;
  try
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char16_t>::_M_construct<const char16_t*> ((struct basic_string *) this, __s, __s + (sizetype) (__n * 2)) >>>>>;
    }
  catch
    {
      std::__cxx11::basic_string<char16_t>::_Alloc_hider::~_Alloc_hider (&((struct basic_string *) this)->_M_dataplus);
    }
}


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::~basic_string() [with _CharT = char16_t; _Traits = std::char_traits<char16_t>; _Alloc = std::allocator<char16_t>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    try
      {
        try
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char16_t>::_M_dispose ((struct basic_string *) this) >>>>>;
          }
        finally
          {
            std::__cxx11::basic_string<char16_t>::_Alloc_hider::~_Alloc_hider (&((struct basic_string *) this)->_M_dataplus);
          }
      }
    finally
      {
        *(struct 
        {
          struct _Alloc_hider _M_dataplus;
          size_type _M_string_length;
          union ._71 D.22943;
        } &) this = {CLOBBER};
      }
  }
  <D.41569>:;
   >>>;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&&) [with _CharT = char16_t; _Traits = std::char_traits<char16_t>; _Alloc = std::allocator<char16_t>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point <<< Unknown tree: expr_stmt
  *(struct 
  {
    struct _Alloc_hider _M_dataplus;
    size_type _M_string_length;
    union ._71 D.22943;
  } &) this = {CLOBBER} >>>>>;
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char16_t>::_Alloc_hider::_Alloc_hider (&((struct basic_string *) this)->_M_dataplus, std::__cxx11::basic_string<char16_t>::_M_local_data ((struct basic_string *) this), (struct allocator &) std::move<std::allocator<char16_t>&> ((struct allocator &) std::__cxx11::basic_string<char16_t>::_M_get_allocator ((struct basic_string *) __str))) >>>>>;
    try
      {
        if (<<cleanup_point std::__cxx11::basic_string<char16_t>::_M_is_local ((struct basic_string *) __str)>>)
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) std::char_traits<char16_t>::copy ((char16_t *) &((struct basic_string *) this)->D.22012._M_local_buf, (const char_type *) &__str->D.22012._M_local_buf, 8) >>>>>;
          }
        else
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char16_t>::_M_data ((struct basic_string *) this, std::__cxx11::basic_string<char16_t>::_M_data ((struct basic_string *) __str)) >>>>>;
            <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char16_t>::_M_capacity ((struct basic_string *) this, __str->D.22012._M_allocated_capacity) >>>>>;
          }
        <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char16_t>::_M_length ((struct basic_string *) this, std::__cxx11::basic_string<char16_t>::length ((struct basic_string *) __str)) >>>>>;
        <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char16_t>::_M_data ((struct basic_string *) __str, std::__cxx11::basic_string<char16_t>::_M_local_data ((struct basic_string *) __str)) >>>>>;
        <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char16_t>::_M_set_length ((struct basic_string *) __str, 0) >>>>>;
      }
    catch
      {
        std::__cxx11::basic_string<char16_t>::_Alloc_hider::~_Alloc_hider (&((struct basic_string *) this)->_M_dataplus);
      }
  }
   >>>;


;; Function std::allocator< <template-parameter-1-1> >::allocator() [with _Tp = char32_t] (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::new_allocator<char32_t>::new_allocator ((struct new_allocator *) this) >>>>>;
    try
      {
        
      }
    catch
      {
        __gnu_cxx::new_allocator<char32_t>::~new_allocator ((struct new_allocator *) this);
      }
  }
   >>>;


;; Function std::allocator< <template-parameter-1-1> >::~allocator() [with _Tp = char32_t] (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  {
    try
      {
        
      }
    finally
      {
        __gnu_cxx::new_allocator<char32_t>::~new_allocator ((struct new_allocator *) this);
      }
  }
  <D.41588>:;
   >>>;


;; Function std::__cxx11::basic_string<char32_t>::_Alloc_hider::~_Alloc_hider() (null)
;; enabled by -tree-original


{
  try
    {
      try
        {
          
        }
      finally
        {
          std::allocator<char32_t>::~allocator ((struct allocator *) this);
        }
    }
  finally
    {
      *(struct 
      {
        char32_t * _M_p;
      } &) this = {CLOBBER};
    }
}
<D.41623>:;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(const _CharT*, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type, const _Alloc&) [with _CharT = char32_t; _Traits = std::char_traits<char32_t>; _Alloc = std::allocator<char32_t>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  *(struct 
  {
    struct _Alloc_hider _M_dataplus;
    size_type _M_string_length;
    union ._71 D.24260;
  } &) this = {CLOBBER} >>>>>;
{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char32_t>::_Alloc_hider::_Alloc_hider (&((struct basic_string *) this)->_M_dataplus, std::__cxx11::basic_string<char32_t>::_M_local_data ((struct basic_string *) this), __a) >>>>>;
  try
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char32_t>::_M_construct<const char32_t*> ((struct basic_string *) this, __s, __s + (sizetype) (__n * 4)) >>>>>;
    }
  catch
    {
      std::__cxx11::basic_string<char32_t>::_Alloc_hider::~_Alloc_hider (&((struct basic_string *) this)->_M_dataplus);
    }
}


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::~basic_string() [with _CharT = char32_t; _Traits = std::char_traits<char32_t>; _Alloc = std::allocator<char32_t>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    try
      {
        try
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char32_t>::_M_dispose ((struct basic_string *) this) >>>>>;
          }
        finally
          {
            std::__cxx11::basic_string<char32_t>::_Alloc_hider::~_Alloc_hider (&((struct basic_string *) this)->_M_dataplus);
          }
      }
    finally
      {
        *(struct 
        {
          struct _Alloc_hider _M_dataplus;
          size_type _M_string_length;
          union ._71 D.24260;
        } &) this = {CLOBBER};
      }
  }
  <D.41636>:;
   >>>;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&&) [with _CharT = char32_t; _Traits = std::char_traits<char32_t>; _Alloc = std::allocator<char32_t>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point <<< Unknown tree: expr_stmt
  *(struct 
  {
    struct _Alloc_hider _M_dataplus;
    size_type _M_string_length;
    union ._71 D.24260;
  } &) this = {CLOBBER} >>>>>;
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char32_t>::_Alloc_hider::_Alloc_hider (&((struct basic_string *) this)->_M_dataplus, std::__cxx11::basic_string<char32_t>::_M_local_data ((struct basic_string *) this), (struct allocator &) std::move<std::allocator<char32_t>&> ((struct allocator &) std::__cxx11::basic_string<char32_t>::_M_get_allocator ((struct basic_string *) __str))) >>>>>;
    try
      {
        if (<<cleanup_point std::__cxx11::basic_string<char32_t>::_M_is_local ((struct basic_string *) __str)>>)
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) std::char_traits<char32_t>::copy ((char32_t *) &((struct basic_string *) this)->D.23329._M_local_buf, (const char_type *) &__str->D.23329._M_local_buf, 4) >>>>>;
          }
        else
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char32_t>::_M_data ((struct basic_string *) this, std::__cxx11::basic_string<char32_t>::_M_data ((struct basic_string *) __str)) >>>>>;
            <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char32_t>::_M_capacity ((struct basic_string *) this, __str->D.23329._M_allocated_capacity) >>>>>;
          }
        <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char32_t>::_M_length ((struct basic_string *) this, std::__cxx11::basic_string<char32_t>::length ((struct basic_string *) __str)) >>>>>;
        <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char32_t>::_M_data ((struct basic_string *) __str, std::__cxx11::basic_string<char32_t>::_M_local_data ((struct basic_string *) __str)) >>>>>;
        <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char32_t>::_M_set_length ((struct basic_string *) __str, 0) >>>>>;
      }
    catch
      {
        std::__cxx11::basic_string<char32_t>::_Alloc_hider::~_Alloc_hider (&((struct basic_string *) this)->_M_dataplus);
      }
  }
   >>>;


;; Function void std::fill(_ForwardIterator, _ForwardIterator, const _Tp&) [with _ForwardIterator = long unsigned int*; _Tp = int] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  std::__fill_a<long unsigned int*, int> (std::__niter_base<long unsigned int*> (__first), std::__niter_base<long unsigned int*> (__last), __value) >>>>>;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size() const [with _CharT = unsigned char; _Traits = std::char_traits<unsigned char>; _Alloc = std::allocator<unsigned char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (size_type) ((const struct basic_string *) this)->_M_string_length
   >>>;


;; Function std::__cxx11::basic_string<unsigned char>::_Alloc_hider::~_Alloc_hider() (null)
;; enabled by -tree-original


{
  try
    {
      try
        {
          
        }
      finally
        {
          std::allocator<unsigned char>::~allocator ((struct allocator *) this);
        }
    }
  finally
    {
      *(struct 
      {
        unsigned char * _M_p;
      } &) this = {CLOBBER};
    }
}
<D.41725>:;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string() [with _CharT = unsigned char; _Traits = std::char_traits<unsigned char>; _Alloc = std::allocator<unsigned char>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point <<< Unknown tree: expr_stmt
  *(struct 
  {
    struct _Alloc_hider _M_dataplus;
    size_type _M_string_length;
    union ._71 D.30739;
  } &) this = {CLOBBER} >>>>>;
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<unsigned char>::_Alloc_hider::_Alloc_hider (&((struct basic_string *) this)->_M_dataplus, std::__cxx11::basic_string<unsigned char>::_M_local_data ((struct basic_string *) this), (struct allocator &) &TARGET_EXPR <D.41723, <<< Unknown tree: aggr_init_expr
  4
  __comp_ctor 
  D.41723
  (struct allocator *) <<< Unknown tree: void_cst >>> >>>>) >>>>>;
    try
      {
        <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<unsigned char>::_M_set_length ((struct basic_string *) this, 0) >>>>>;
      }
    catch
      {
        std::__cxx11::basic_string<unsigned char>::_Alloc_hider::~_Alloc_hider (&((struct basic_string *) this)->_M_dataplus);
      }
  }
   >>>;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::~basic_string() [with _CharT = unsigned char; _Traits = std::char_traits<unsigned char>; _Alloc = std::allocator<unsigned char>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    try
      {
        try
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<unsigned char>::_M_dispose ((struct basic_string *) this) >>>>>;
          }
        finally
          {
            std::__cxx11::basic_string<unsigned char>::_Alloc_hider::~_Alloc_hider (&((struct basic_string *) this)->_M_dataplus);
          }
      }
    finally
      {
        *(struct 
        {
          struct _Alloc_hider _M_dataplus;
          size_type _M_string_length;
          union ._71 D.30739;
        } &) this = {CLOBBER};
      }
  }
  <D.41735>:;
   >>>;


;; Function std::vector<_Tp, _Alloc>::vector() [with _Tp = outBuff; _Alloc = std::allocator<outBuff>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point <<< Unknown tree: expr_stmt
  *(struct 
  {
    struct 
    {
      struct _Vector_impl _M_impl;
    } D.38529;
  } &) this = {CLOBBER} >>>>>;
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Vector_base<outBuff, std::allocator<outBuff> >::_Vector_base (&((struct vector *) this)->D.38528) >>>>>;
    try
      {
        
      }
    catch
      {
        std::_Vector_base<outBuff, std::allocator<outBuff> >::~_Vector_base (&((struct vector *) this)->D.38528);
      }
  }
   >>>;


;; Function void disposeMemorySingle(C*&) [with C = outBuff] (null)
;; enabled by -tree-original


if (*pBuff != 0B)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  operator delete ((void *) *pBuff, 40) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*pBuff = 0B) >>>>>;
  }


;; Function void disposeMemory(C*&) [with C = char] (null)
;; enabled by -tree-original


if (*pBuff != 0B)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (if (*pBuff != 0B)
    {
      operator delete [] ((void *) *pBuff);
    }
  else
    {
      0
    }) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*pBuff = 0B) >>>>>;
  }


;; Function std::vector<_Tp, _Alloc>::reference std::vector<_Tp, _Alloc>::operator[](std::vector<_Tp, _Alloc>::size_type) [with _Tp = outBuff; _Alloc = std::allocator<outBuff>; std::vector<_Tp, _Alloc>::reference = outBuff&; std::vector<_Tp, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct value_type &) (((struct vector *) this)->D.38528._M_impl._M_start + (sizetype) (__n * 40))
   >>>;


;; Function void std::vector<_Tp, _Alloc>::assign(std::vector<_Tp, _Alloc>::size_type, const value_type&) [with _Tp = outBuff; _Alloc = std::allocator<outBuff>; std::vector<_Tp, _Alloc>::size_type = long unsigned int; std::vector<_Tp, _Alloc>::value_type = outBuff] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  std::vector<outBuff>::_M_fill_assign ((struct vector *) this, __n, __val) >>>>>;


;; Function std::vector<_Tp, _Alloc>::size_type std::vector<_Tp, _Alloc>::size() const [with _Tp = outBuff; _Alloc = std::allocator<outBuff>; std::vector<_Tp, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (size_type) (((long int) ((const struct vector *) this)->D.38528._M_impl._M_finish - (long int) ((const struct vector *) this)->D.38528._M_impl._M_start) /[ex] 40)
   >>>;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string() [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point <<< Unknown tree: expr_stmt
  *(struct 
  {
    struct _Alloc_hider _M_dataplus;
    size_type _M_string_length;
    union ._71 D.19671;
  } &) this = {CLOBBER} >>>>>;
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char>::_Alloc_hider::_Alloc_hider (&((struct basic_string *) this)->_M_dataplus, std::__cxx11::basic_string<char>::_M_local_data ((struct basic_string *) this), (struct allocator &) &TARGET_EXPR <D.41796, <<< Unknown tree: aggr_init_expr
  4
  __comp_ctor 
  D.41796
  (struct allocator *) <<< Unknown tree: void_cst >>> >>>>) >>>>>;
    try
      {
        <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char>::_M_set_length ((struct basic_string *) this, 0) >>>>>;
      }
    catch
      {
        std::__cxx11::basic_string<char>::_Alloc_hider::~_Alloc_hider (&((struct basic_string *) this)->_M_dataplus);
      }
  }
   >>>;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(const _CharT*, const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  *(struct 
  {
    struct _Alloc_hider _M_dataplus;
    size_type _M_string_length;
    union ._71 D.19671;
  } &) this = {CLOBBER} >>>>>;
{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char>::_Alloc_hider::_Alloc_hider (&((struct basic_string *) this)->_M_dataplus, std::__cxx11::basic_string<char>::_M_local_data ((struct basic_string *) this), __a) >>>>>;
  try
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char>::_M_construct<const char*> ((struct basic_string *) this, __s, __s != 0B ? __s + (sizetype) std::char_traits<char>::length (__s) : __s + 18446744073709551615) >>>>>;
    }
  catch
    {
      std::__cxx11::basic_string<char>::_Alloc_hider::~_Alloc_hider (&((struct basic_string *) this)->_M_dataplus);
    }
}


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>& std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::operator=(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    if (<<cleanup_point (!std::__cxx11::basic_string<char>::_M_is_local ((struct basic_string *) this);, 0) && std::operator!=<char> ((const struct allocator &) std::__cxx11::basic_string<char>::_M_get_allocator ((struct basic_string *) this), (const struct allocator &) std::__cxx11::basic_string<char>::_M_get_allocator ((struct basic_string *) __str))>>)
      {
        <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char>::_M_destroy ((struct basic_string *) this, ((struct basic_string *) this)->D.18739._M_allocated_capacity) >>>>>;
        <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char>::_M_data ((struct basic_string *) this, std::__cxx11::basic_string<char>::_M_local_data ((struct basic_string *) this)) >>>>>;
        <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char>::_M_set_length ((struct basic_string *) this, 0) >>>>>;
      }
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__alloc_on_move<std::allocator<char> > ((struct allocator &) std::__cxx11::basic_string<char>::_M_get_allocator ((struct basic_string *) this), (struct allocator &) std::__cxx11::basic_string<char>::_M_get_allocator ((struct basic_string *) __str)) >>>>>;
    {
      if (<<cleanup_point std::__cxx11::basic_string<char>::_M_is_local ((struct basic_string *) __str)>>)
        {
          if (<<cleanup_point std::__cxx11::basic_string<char>::size ((struct basic_string *) __str) != 0>>)
            {
              <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char>::_S_copy (std::__cxx11::basic_string<char>::_M_data ((struct basic_string *) this), (const char *) std::__cxx11::basic_string<char>::_M_data ((struct basic_string *) __str), std::__cxx11::basic_string<char>::size ((struct basic_string *) __str)) >>>>>;
            }
          <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char>::_M_set_length ((struct basic_string *) this, std::__cxx11::basic_string<char>::size ((struct basic_string *) __str)) >>>>>;
        }
      else
        {
          {
            {
              if (1)
                {
                  {
                    char * __data = 0B;
                    size_type __capacity;

                    <<cleanup_point                     char * __data = 0B;>>;
                                        size_type __capacity;
                    if (<<cleanup_point !std::__cxx11::basic_string<char>::_M_is_local ((struct basic_string *) this)>>)
                      {
                        if (1)
                          {
                            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__data = std::__cxx11::basic_string<char>::_M_data ((struct basic_string *) this)) >>>>>;
                            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__capacity = ((struct basic_string *) this)->D.18739._M_allocated_capacity) >>>>>;
                          }
                        else
                          {
                            <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char>::_M_destroy ((struct basic_string *) this, ((struct basic_string *) this)->D.18739._M_allocated_capacity) >>>>>;
                          }
                      }
                    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char>::_M_data ((struct basic_string *) this, std::__cxx11::basic_string<char>::_M_data ((struct basic_string *) __str)) >>>>>;
                    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char>::_M_length ((struct basic_string *) this, std::__cxx11::basic_string<char>::length ((struct basic_string *) __str)) >>>>>;
                    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char>::_M_capacity ((struct basic_string *) this, __str->D.18739._M_allocated_capacity) >>>>>;
                    if (__data != 0B)
                      {
                        <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char>::_M_data ((struct basic_string *) __str, __data) >>>>>;
                        <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char>::_M_capacity ((struct basic_string *) __str, __capacity) >>>>>;
                      }
                    else
                      {
                        <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char>::_M_data ((struct basic_string *) __str, (char *) &__str->D.18739._M_local_buf) >>>>>;
                      }
                  }
                }
              else
                {
                  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) std::__cxx11::basic_string<char>::assign ((struct basic_string *) this, (const struct basic_string &) __str) >>>>>;
                }
            }
          }
        }
    }
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char>::clear ((struct basic_string *) __str) >>>>>;
    return <retval> = (struct basic_string &) this;
  }
   >>>;


;; Function FI1 memstr(FI1, int, FI2, int) [with FI1 = unsigned char*; FI2 = char*] (null)
;; enabled by -tree-original


{
  unsigned char * searchBufEnd = searchBuf + (sizetype) searchBufSize;
  unsigned char * s;

    unsigned char * searchBufEnd = searchBuf + (sizetype) searchBufSize;
    unsigned char * s;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (s = std::search<unsigned char*, char*> (searchBuf, searchBufEnd, searchString, searchString + (sizetype) searchStringSize)) >>>>>;
  return <retval> = s != searchBufEnd ? s : 0B;
}


;; Function FI1 memstr(FI1, int, FI2, int) [with FI1 = unsigned char*; FI2 = unsigned char*] (null)
;; enabled by -tree-original


{
  unsigned char * searchBufEnd = searchBuf + (sizetype) searchBufSize;
  unsigned char * s;

    unsigned char * searchBufEnd = searchBuf + (sizetype) searchBufSize;
    unsigned char * s;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (s = std::search<unsigned char*, unsigned char*> (searchBuf, searchBufEnd, searchString, searchString + (sizetype) searchStringSize)) >>>>>;
  return <retval> = s != searchBufEnd ? s : 0B;
}


;; Function bool ends_with_icase(const std::__cxx11::basic_string<_CharT>&, const std::__cxx11::basic_string<_CharT>&) [with charT = char] (null)
;; enabled by -tree-original


{
  int ti;
  size_t si = 0;

    int ti;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (ti = (int) ((unsigned int) std::__cxx11::basic_string<char>::size ((const struct basic_string *) str) - (unsigned int) std::__cxx11::basic_string<char>::size ((const struct basic_string *) suffix))) >>>>>;
  if (ti < 0)
    {
      return <retval> = 0;
    }
  <<cleanup_point   size_t si = 0;>>;
  while (1)
    {
      if (<<cleanup_point std::__cxx11::basic_string<char>::size ((const struct basic_string *) suffix) > si>>) (void) 0; else goto <D.41846>;
      if (<<cleanup_point tolower ((int) *std::__cxx11::basic_string<char>::operator[] ((const struct basic_string *) str, (size_type) ti)) != tolower ((int) *std::__cxx11::basic_string<char>::operator[] ((const struct basic_string *) suffix, si))>>)
        {
          return <retval> = 0;
        }
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void)  ++si >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void)  ++ti >>>>>;
    }
  <D.41846>:;
  return <retval> = 1;
}


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size() const [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (size_type) ((const struct basic_string *) this)->_M_string_length
   >>>;


;; Function void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::resize(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char>::resize ((struct basic_string *) this, __n, 0) >>>>>;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>& std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::operator+=(const _CharT*) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = std::__cxx11::basic_string<char>::append ((struct basic_string *) this, __s)>>;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>& std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::operator+=(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = std::__cxx11::basic_string<char>::append ((struct basic_string *) this, __str)>>;


;; Function void std::vector<_Tp, _Alloc>::clear() [with _Tp = outBuff; _Alloc = std::allocator<outBuff>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::vector<outBuff>::_M_erase_at_end ((struct vector *) this, ((struct vector *) this)->D.38528._M_impl._M_start) >>>>>
   >>>;


;; Function void disposeMemory(C*&) [with C = char*] (null)
;; enabled by -tree-original


if (*pBuff != 0B)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (if (*pBuff != 0B)
    {
      operator delete [] ((void *) *pBuff);
    }
  else
    {
      0
    }) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*pBuff = 0B) >>>>>;
  }


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_data() const [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer = char*] (null)
;; enabled by -tree-original


return <retval> = (char *) ((const struct basic_string *) this)->_M_dataplus._M_p;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(_InputIterator, _InputIterator, const _Alloc&) [with _InputIterator = char*; <template-parameter-2-2> = void; _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  *(struct 
  {
    struct _Alloc_hider _M_dataplus;
    size_type _M_string_length;
    union ._71 D.19671;
  } &) this = {CLOBBER} >>>>>;
{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char>::_Alloc_hider::_Alloc_hider (&((struct basic_string *) this)->_M_dataplus, std::__cxx11::basic_string<char>::_M_local_data ((struct basic_string *) this), __a) >>>>>;
  try
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char>::_M_construct<char*> ((struct basic_string *) this, __beg, __end) >>>>>;
    }
  catch
    {
      std::__cxx11::basic_string<char>::_Alloc_hider::~_Alloc_hider (&((struct basic_string *) this)->_M_dataplus);
    }
}


;; Function void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_dispose() [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>] (null)
;; enabled by -tree-original


if (<<cleanup_point !std::__cxx11::basic_string<char>::_M_is_local ((struct basic_string *) this)>>)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char>::_M_destroy ((struct basic_string *) this, ((struct basic_string *) this)->D.18739._M_allocated_capacity) >>>>>;
  }


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_local_data() [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer = char*] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = (char *) std::pointer_traits<char*>::pointer_to ((__make_not_void &) &((struct basic_string *) this)->D.18739._M_local_buf)>>;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::allocator_type& std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_get_allocator() [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::allocator_type = std::allocator<char>] (null)
;; enabled by -tree-original


return <retval> = (struct allocator_type &) &((struct basic_string *) this)->_M_dataplus;


;; Function constexpr typename std::remove_reference< <template-parameter-1-1> >::type&& std::move(_Tp&&) [with _Tp = std::allocator<char>&; typename std::remove_reference< <template-parameter-1-1> >::type = std::allocator<char>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct type &) __t
   >>>;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_Alloc_hider::_Alloc_hider(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer, _Alloc&&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer = char*] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  *(struct 
  {
    char * _M_p;
  } &) this = {CLOBBER} >>>>>;
{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::allocator<char>::allocator ((struct allocator *) this, (const struct allocator &) std::move<std::allocator<char>&> ((struct allocator &) __a)) >>>>>;
  try
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Alloc_hider *) this)->_M_p = __dat) >>>>>;
    }
  catch
    {
      std::allocator<char>::~allocator ((struct allocator *) this);
    }
}


;; Function bool std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_is_local() const [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = (const char *) std::__cxx11::basic_string<char>::_M_data ((const struct basic_string *) this) == std::__cxx11::basic_string<char>::_M_local_data ((const struct basic_string *) this)>>;


;; Function void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_data(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer = char*] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct basic_string *) this)->_M_dataplus._M_p = __p) >>>>>;


;; Function void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_capacity(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct basic_string *) this)->D.18739._M_allocated_capacity = __capacity) >>>>>;


;; Function void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_length(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct basic_string *) this)->_M_string_length = __length) >>>>>;


;; Function void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_set_length(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char>::_M_length ((struct basic_string *) this, __n) >>>>>;
<<cleanup_point <<< Unknown tree: expr_stmt
  std::char_traits<char>::assign ((char_type &) (std::__cxx11::basic_string<char>::_M_data ((struct basic_string *) this) + (sizetype) NON_LVALUE_EXPR <__n>), (const char_type &) &TARGET_EXPR <D.41909, 0>) >>>>>;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_data() const [with _CharT = wchar_t; _Traits = std::char_traits<wchar_t>; _Alloc = std::allocator<wchar_t>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer = wchar_t*] (null)
;; enabled by -tree-original


return <retval> = (wchar_t *) ((const struct basic_string *) this)->_M_dataplus._M_p;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(_InputIterator, _InputIterator, const _Alloc&) [with _InputIterator = wchar_t*; <template-parameter-2-2> = void; _CharT = wchar_t; _Traits = std::char_traits<wchar_t>; _Alloc = std::allocator<wchar_t>] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  *(struct 
  {
    struct _Alloc_hider _M_dataplus;
    size_type _M_string_length;
    union ._71 D.21070;
  } &) this = {CLOBBER} >>>>>;
{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<wchar_t>::_Alloc_hider::_Alloc_hider (&((struct basic_string *) this)->_M_dataplus, std::__cxx11::basic_string<wchar_t>::_M_local_data ((struct basic_string *) this), __a) >>>>>;
  try
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<wchar_t>::_M_construct<wchar_t*> ((struct basic_string *) this, __beg, __end) >>>>>;
    }
  catch
    {
      std::__cxx11::basic_string<wchar_t>::_Alloc_hider::~_Alloc_hider (&((struct basic_string *) this)->_M_dataplus);
    }
}


;; Function void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_dispose() [with _CharT = wchar_t; _Traits = std::char_traits<wchar_t>; _Alloc = std::allocator<wchar_t>] (null)
;; enabled by -tree-original


if (<<cleanup_point !std::__cxx11::basic_string<wchar_t>::_M_is_local ((struct basic_string *) this)>>)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<wchar_t>::_M_destroy ((struct basic_string *) this, ((struct basic_string *) this)->D.20139._M_allocated_capacity) >>>>>;
  }


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_local_data() [with _CharT = wchar_t; _Traits = std::char_traits<wchar_t>; _Alloc = std::allocator<wchar_t>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer = wchar_t*] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = (wchar_t *) std::pointer_traits<wchar_t*>::pointer_to ((__make_not_void &) &((struct basic_string *) this)->D.20139._M_local_buf)>>;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::allocator_type& std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_get_allocator() [with _CharT = wchar_t; _Traits = std::char_traits<wchar_t>; _Alloc = std::allocator<wchar_t>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::allocator_type = std::allocator<wchar_t>] (null)
;; enabled by -tree-original


return <retval> = (struct allocator_type &) &((struct basic_string *) this)->_M_dataplus;


;; Function constexpr typename std::remove_reference< <template-parameter-1-1> >::type&& std::move(_Tp&&) [with _Tp = std::allocator<wchar_t>&; typename std::remove_reference< <template-parameter-1-1> >::type = std::allocator<wchar_t>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct type &) __t
   >>>;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_Alloc_hider::_Alloc_hider(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer, _Alloc&&) [with _CharT = wchar_t; _Traits = std::char_traits<wchar_t>; _Alloc = std::allocator<wchar_t>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer = wchar_t*] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  *(struct 
  {
    wchar_t * _M_p;
  } &) this = {CLOBBER} >>>>>;
{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::allocator<wchar_t>::allocator ((struct allocator *) this, (const struct allocator &) std::move<std::allocator<wchar_t>&> ((struct allocator &) __a)) >>>>>;
  try
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Alloc_hider *) this)->_M_p = __dat) >>>>>;
    }
  catch
    {
      std::allocator<wchar_t>::~allocator ((struct allocator *) this);
    }
}


;; Function bool std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_is_local() const [with _CharT = wchar_t; _Traits = std::char_traits<wchar_t>; _Alloc = std::allocator<wchar_t>] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = (const wchar_t *) std::__cxx11::basic_string<wchar_t>::_M_data ((const struct basic_string *) this) == std::__cxx11::basic_string<wchar_t>::_M_local_data ((const struct basic_string *) this)>>;


;; Function void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_data(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer) [with _CharT = wchar_t; _Traits = std::char_traits<wchar_t>; _Alloc = std::allocator<wchar_t>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer = wchar_t*] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct basic_string *) this)->_M_dataplus._M_p = __p) >>>>>;


;; Function void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_capacity(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type) [with _CharT = wchar_t; _Traits = std::char_traits<wchar_t>; _Alloc = std::allocator<wchar_t>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct basic_string *) this)->D.20139._M_allocated_capacity = __capacity) >>>>>;


;; Function void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_length(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type) [with _CharT = wchar_t; _Traits = std::char_traits<wchar_t>; _Alloc = std::allocator<wchar_t>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct basic_string *) this)->_M_string_length = __length) >>>>>;


;; Function void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_set_length(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type) [with _CharT = wchar_t; _Traits = std::char_traits<wchar_t>; _Alloc = std::allocator<wchar_t>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<wchar_t>::_M_length ((struct basic_string *) this, __n) >>>>>;
<<cleanup_point <<< Unknown tree: expr_stmt
  std::char_traits<wchar_t>::assign ((char_type &) (std::__cxx11::basic_string<wchar_t>::_M_data ((struct basic_string *) this) + (sizetype) (__n * 4)), (const char_type &) &TARGET_EXPR <D.41965, 0>) >>>>>;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_data() const [with _CharT = char16_t; _Traits = std::char_traits<char16_t>; _Alloc = std::allocator<char16_t>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer = char16_t*] (null)
;; enabled by -tree-original


return <retval> = (char16_t *) ((const struct basic_string *) this)->_M_dataplus._M_p;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_data() const [with _CharT = char32_t; _Traits = std::char_traits<char32_t>; _Alloc = std::allocator<char32_t>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer = char32_t*] (null)
;; enabled by -tree-original


return <retval> = (char32_t *) ((const struct basic_string *) this)->_M_dataplus._M_p;


;; Function __gnu_cxx::new_allocator<_Tp>::new_allocator() [with _Tp = char] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    
  }
   >>>;


;; Function __gnu_cxx::new_allocator<_Tp>::~new_allocator() [with _Tp = char] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    
  }
  <D.41972>:;
   >>>;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_Alloc_hider::_Alloc_hider(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer, const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer = char*] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  *(struct 
  {
    char * _M_p;
  } &) this = {CLOBBER} >>>>>;
{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::allocator<char>::allocator ((struct allocator *) this, __a) >>>>>;
  try
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Alloc_hider *) this)->_M_p = __dat) >>>>>;
    }
  catch
    {
      std::allocator<char>::~allocator ((struct allocator *) this);
    }
}


;; Function void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_construct(_InIterator, _InIterator) [with _InIterator = const char*; _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>] (null)
;; enabled by -tree-original


{
  typedef struct _Integral _Integral;

  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char>::_M_construct_aux<const char*> ((struct basic_string *) this, __beg, __end, TARGET_EXPR <D.42013, {}>;, <<< Unknown tree: empty_class_expr >>>;) >>>>>;
}


;; Function __gnu_cxx::new_allocator<_Tp>::new_allocator() [with _Tp = wchar_t] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    
  }
   >>>;


;; Function __gnu_cxx::new_allocator<_Tp>::~new_allocator() [with _Tp = wchar_t] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    
  }
  <D.42056>:;
   >>>;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_Alloc_hider::_Alloc_hider(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer, const _Alloc&) [with _CharT = wchar_t; _Traits = std::char_traits<wchar_t>; _Alloc = std::allocator<wchar_t>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer = wchar_t*] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  *(struct 
  {
    wchar_t * _M_p;
  } &) this = {CLOBBER} >>>>>;
{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::allocator<wchar_t>::allocator ((struct allocator *) this, __a) >>>>>;
  try
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Alloc_hider *) this)->_M_p = __dat) >>>>>;
    }
  catch
    {
      std::allocator<wchar_t>::~allocator ((struct allocator *) this);
    }
}


;; Function void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_construct(_InIterator, _InIterator) [with _InIterator = const wchar_t*; _CharT = wchar_t; _Traits = std::char_traits<wchar_t>; _Alloc = std::allocator<wchar_t>] (null)
;; enabled by -tree-original


{
  typedef struct _Integral _Integral;

  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<wchar_t>::_M_construct_aux<const wchar_t*> ((struct basic_string *) this, __beg, __end, TARGET_EXPR <D.42073, {}>;, <<< Unknown tree: empty_class_expr >>>;) >>>>>;
}


;; Function __gnu_cxx::new_allocator<_Tp>::new_allocator() [with _Tp = char16_t] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    
  }
   >>>;


;; Function __gnu_cxx::new_allocator<_Tp>::~new_allocator() [with _Tp = char16_t] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    
  }
  <D.42083>:;
   >>>;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_local_data() [with _CharT = char16_t; _Traits = std::char_traits<char16_t>; _Alloc = std::allocator<char16_t>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer = char16_t*] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = (char16_t *) std::pointer_traits<char16_t*>::pointer_to ((__make_not_void &) &((struct basic_string *) this)->D.22012._M_local_buf)>>;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_Alloc_hider::_Alloc_hider(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer, const _Alloc&) [with _CharT = char16_t; _Traits = std::char_traits<char16_t>; _Alloc = std::allocator<char16_t>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer = char16_t*] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  *(struct 
  {
    char16_t * _M_p;
  } &) this = {CLOBBER} >>>>>;
{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::allocator<char16_t>::allocator ((struct allocator *) this, __a) >>>>>;
  try
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Alloc_hider *) this)->_M_p = __dat) >>>>>;
    }
  catch
    {
      std::allocator<char16_t>::~allocator ((struct allocator *) this);
    }
}


;; Function void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_construct(_InIterator, _InIterator) [with _InIterator = const char16_t*; _CharT = char16_t; _Traits = std::char_traits<char16_t>; _Alloc = std::allocator<char16_t>] (null)
;; enabled by -tree-original


{
  typedef struct _Integral _Integral;

  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char16_t>::_M_construct_aux<const char16_t*> ((struct basic_string *) this, __beg, __end, TARGET_EXPR <D.42136, {}>;, <<< Unknown tree: empty_class_expr >>>;) >>>>>;
}


;; Function void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_dispose() [with _CharT = char16_t; _Traits = std::char_traits<char16_t>; _Alloc = std::allocator<char16_t>] (null)
;; enabled by -tree-original


if (<<cleanup_point !std::__cxx11::basic_string<char16_t>::_M_is_local ((struct basic_string *) this)>>)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char16_t>::_M_destroy ((struct basic_string *) this, ((struct basic_string *) this)->D.22012._M_allocated_capacity) >>>>>;
  }


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::allocator_type& std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_get_allocator() [with _CharT = char16_t; _Traits = std::char_traits<char16_t>; _Alloc = std::allocator<char16_t>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::allocator_type = std::allocator<char16_t>] (null)
;; enabled by -tree-original


return <retval> = (struct allocator_type &) &((struct basic_string *) this)->_M_dataplus;


;; Function constexpr typename std::remove_reference< <template-parameter-1-1> >::type&& std::move(_Tp&&) [with _Tp = std::allocator<char16_t>&; typename std::remove_reference< <template-parameter-1-1> >::type = std::allocator<char16_t>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct type &) __t
   >>>;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_Alloc_hider::_Alloc_hider(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer, _Alloc&&) [with _CharT = char16_t; _Traits = std::char_traits<char16_t>; _Alloc = std::allocator<char16_t>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer = char16_t*] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  *(struct 
  {
    char16_t * _M_p;
  } &) this = {CLOBBER} >>>>>;
{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::allocator<char16_t>::allocator ((struct allocator *) this, (const struct allocator &) std::move<std::allocator<char16_t>&> ((struct allocator &) __a)) >>>>>;
  try
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Alloc_hider *) this)->_M_p = __dat) >>>>>;
    }
  catch
    {
      std::allocator<char16_t>::~allocator ((struct allocator *) this);
    }
}


;; Function bool std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_is_local() const [with _CharT = char16_t; _Traits = std::char_traits<char16_t>; _Alloc = std::allocator<char16_t>] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = (const char16_t *) std::__cxx11::basic_string<char16_t>::_M_data ((const struct basic_string *) this) == std::__cxx11::basic_string<char16_t>::_M_local_data ((const struct basic_string *) this)>>;


;; Function void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_data(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer) [with _CharT = char16_t; _Traits = std::char_traits<char16_t>; _Alloc = std::allocator<char16_t>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer = char16_t*] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct basic_string *) this)->_M_dataplus._M_p = __p) >>>>>;


;; Function void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_capacity(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type) [with _CharT = char16_t; _Traits = std::char_traits<char16_t>; _Alloc = std::allocator<char16_t>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct basic_string *) this)->D.22012._M_allocated_capacity = __capacity) >>>>>;


;; Function void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_length(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type) [with _CharT = char16_t; _Traits = std::char_traits<char16_t>; _Alloc = std::allocator<char16_t>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct basic_string *) this)->_M_string_length = __length) >>>>>;


;; Function void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_set_length(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type) [with _CharT = char16_t; _Traits = std::char_traits<char16_t>; _Alloc = std::allocator<char16_t>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char16_t>::_M_length ((struct basic_string *) this, __n) >>>>>;
<<cleanup_point <<< Unknown tree: expr_stmt
  std::char_traits<char16_t>::assign ((char_type &) (std::__cxx11::basic_string<char16_t>::_M_data ((struct basic_string *) this) + (sizetype) (__n * 2)), (const char_type &) &TARGET_EXPR <D.42153, 0>) >>>>>;


;; Function __gnu_cxx::new_allocator<_Tp>::new_allocator() [with _Tp = char32_t] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    
  }
   >>>;


;; Function __gnu_cxx::new_allocator<_Tp>::~new_allocator() [with _Tp = char32_t] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    
  }
  <D.42158>:;
   >>>;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_local_data() [with _CharT = char32_t; _Traits = std::char_traits<char32_t>; _Alloc = std::allocator<char32_t>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer = char32_t*] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = (char32_t *) std::pointer_traits<char32_t*>::pointer_to ((__make_not_void &) &((struct basic_string *) this)->D.23329._M_local_buf)>>;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_Alloc_hider::_Alloc_hider(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer, const _Alloc&) [with _CharT = char32_t; _Traits = std::char_traits<char32_t>; _Alloc = std::allocator<char32_t>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer = char32_t*] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  *(struct 
  {
    char32_t * _M_p;
  } &) this = {CLOBBER} >>>>>;
{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::allocator<char32_t>::allocator ((struct allocator *) this, __a) >>>>>;
  try
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Alloc_hider *) this)->_M_p = __dat) >>>>>;
    }
  catch
    {
      std::allocator<char32_t>::~allocator ((struct allocator *) this);
    }
}


;; Function void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_construct(_InIterator, _InIterator) [with _InIterator = const char32_t*; _CharT = char32_t; _Traits = std::char_traits<char32_t>; _Alloc = std::allocator<char32_t>] (null)
;; enabled by -tree-original


{
  typedef struct _Integral _Integral;

  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char32_t>::_M_construct_aux<const char32_t*> ((struct basic_string *) this, __beg, __end, TARGET_EXPR <D.42211, {}>;, <<< Unknown tree: empty_class_expr >>>;) >>>>>;
}


;; Function void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_dispose() [with _CharT = char32_t; _Traits = std::char_traits<char32_t>; _Alloc = std::allocator<char32_t>] (null)
;; enabled by -tree-original


if (<<cleanup_point !std::__cxx11::basic_string<char32_t>::_M_is_local ((struct basic_string *) this)>>)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char32_t>::_M_destroy ((struct basic_string *) this, ((struct basic_string *) this)->D.23329._M_allocated_capacity) >>>>>;
  }


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::allocator_type& std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_get_allocator() [with _CharT = char32_t; _Traits = std::char_traits<char32_t>; _Alloc = std::allocator<char32_t>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::allocator_type = std::allocator<char32_t>] (null)
;; enabled by -tree-original


return <retval> = (struct allocator_type &) &((struct basic_string *) this)->_M_dataplus;


;; Function constexpr typename std::remove_reference< <template-parameter-1-1> >::type&& std::move(_Tp&&) [with _Tp = std::allocator<char32_t>&; typename std::remove_reference< <template-parameter-1-1> >::type = std::allocator<char32_t>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct type &) __t
   >>>;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_Alloc_hider::_Alloc_hider(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer, _Alloc&&) [with _CharT = char32_t; _Traits = std::char_traits<char32_t>; _Alloc = std::allocator<char32_t>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer = char32_t*] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  *(struct 
  {
    char32_t * _M_p;
  } &) this = {CLOBBER} >>>>>;
{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::allocator<char32_t>::allocator ((struct allocator *) this, (const struct allocator &) std::move<std::allocator<char32_t>&> ((struct allocator &) __a)) >>>>>;
  try
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Alloc_hider *) this)->_M_p = __dat) >>>>>;
    }
  catch
    {
      std::allocator<char32_t>::~allocator ((struct allocator *) this);
    }
}


;; Function bool std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_is_local() const [with _CharT = char32_t; _Traits = std::char_traits<char32_t>; _Alloc = std::allocator<char32_t>] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = (const char32_t *) std::__cxx11::basic_string<char32_t>::_M_data ((const struct basic_string *) this) == std::__cxx11::basic_string<char32_t>::_M_local_data ((const struct basic_string *) this)>>;


;; Function void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_data(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer) [with _CharT = char32_t; _Traits = std::char_traits<char32_t>; _Alloc = std::allocator<char32_t>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer = char32_t*] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct basic_string *) this)->_M_dataplus._M_p = __p) >>>>>;


;; Function void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_capacity(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type) [with _CharT = char32_t; _Traits = std::char_traits<char32_t>; _Alloc = std::allocator<char32_t>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct basic_string *) this)->D.23329._M_allocated_capacity = __capacity) >>>>>;


;; Function void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_length(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type) [with _CharT = char32_t; _Traits = std::char_traits<char32_t>; _Alloc = std::allocator<char32_t>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct basic_string *) this)->_M_string_length = __length) >>>>>;


;; Function void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_set_length(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type) [with _CharT = char32_t; _Traits = std::char_traits<char32_t>; _Alloc = std::allocator<char32_t>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char32_t>::_M_length ((struct basic_string *) this, __n) >>>>>;
<<cleanup_point <<< Unknown tree: expr_stmt
  std::char_traits<char32_t>::assign ((char_type &) (std::__cxx11::basic_string<char32_t>::_M_data ((struct basic_string *) this) + (sizetype) (__n * 4)), (const char_type &) &TARGET_EXPR <D.42228, 0>) >>>>>;


;; Function _Iterator std::__niter_base(_Iterator) [with _Iterator = long unsigned int*] (null)
;; enabled by -tree-original


return <retval> = __it;


;; Function typename __gnu_cxx::__enable_if<std::__is_scalar<_Tp>::__value, void>::__type std::__fill_a(_ForwardIterator, _ForwardIterator, const _Tp&) [with _ForwardIterator = long unsigned int*; _Tp = int; typename __gnu_cxx::__enable_if<std::__is_scalar<_Tp>::__value, void>::__type = void] (null)
;; enabled by -tree-original


{
  const int __tmp = (int) *__value;

    const int __tmp = (int) *__value;
  while (1)
    {
      if (__first == __last) goto <D.42232>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__first = (long unsigned int) __tmp) >>>>>;
      <<cleanup_point (void)  ++__first>>;
    }
  <D.42232>:;
}


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_local_data() [with _CharT = unsigned char; _Traits = std::char_traits<unsigned char>; _Alloc = std::allocator<unsigned char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer = unsigned char*] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = (unsigned char *) std::pointer_traits<unsigned char*>::pointer_to ((__make_not_void &) &((struct basic_string *) this)->D.29808._M_local_buf)>>;


;; Function std::allocator< <template-parameter-1-1> >::allocator() [with _Tp = unsigned char] (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::new_allocator<unsigned char>::new_allocator ((struct new_allocator *) this) >>>>>;
    try
      {
        
      }
    catch
      {
        __gnu_cxx::new_allocator<unsigned char>::~new_allocator ((struct new_allocator *) this);
      }
  }
   >>>;


;; Function std::allocator< <template-parameter-1-1> >::~allocator() [with _Tp = unsigned char] (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  {
    try
      {
        
      }
    finally
      {
        __gnu_cxx::new_allocator<unsigned char>::~new_allocator ((struct new_allocator *) this);
      }
  }
  <D.42274>:;
   >>>;


;; Function constexpr typename std::remove_reference< <template-parameter-1-1> >::type&& std::move(_Tp&&) [with _Tp = std::allocator<unsigned char>&; typename std::remove_reference< <template-parameter-1-1> >::type = std::allocator<unsigned char>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct type &) __t
   >>>;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_Alloc_hider::_Alloc_hider(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer, _Alloc&&) [with _CharT = unsigned char; _Traits = std::char_traits<unsigned char>; _Alloc = std::allocator<unsigned char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer = unsigned char*] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  *(struct 
  {
    unsigned char * _M_p;
  } &) this = {CLOBBER} >>>>>;
{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::allocator<unsigned char>::allocator ((struct allocator *) this, (const struct allocator &) std::move<std::allocator<unsigned char>&> ((struct allocator &) __a)) >>>>>;
  try
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Alloc_hider *) this)->_M_p = __dat) >>>>>;
    }
  catch
    {
      std::allocator<unsigned char>::~allocator ((struct allocator *) this);
    }
}


;; Function void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_set_length(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type) [with _CharT = unsigned char; _Traits = std::char_traits<unsigned char>; _Alloc = std::allocator<unsigned char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<unsigned char>::_M_length ((struct basic_string *) this, __n) >>>>>;
<<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::char_traits<unsigned char>::assign ((char_type &) (std::__cxx11::basic_string<unsigned char>::_M_data ((struct basic_string *) this) + (sizetype) NON_LVALUE_EXPR <__n>), (const char_type &) &TARGET_EXPR <D.42291, 0>) >>>>>;


;; Function void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_dispose() [with _CharT = unsigned char; _Traits = std::char_traits<unsigned char>; _Alloc = std::allocator<unsigned char>] (null)
;; enabled by -tree-original


if (<<cleanup_point !std::__cxx11::basic_string<unsigned char>::_M_is_local ((struct basic_string *) this)>>)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<unsigned char>::_M_destroy ((struct basic_string *) this, ((struct basic_string *) this)->D.29808._M_allocated_capacity) >>>>>;
  }


;; Function std::_Vector_base<outBuff, std::allocator<outBuff> >::_Vector_impl::~_Vector_impl() (null)
;; enabled by -tree-original


{
  try
    {
      try
        {
          
        }
      finally
        {
          std::allocator<outBuff>::~allocator ((struct allocator *) this);
        }
    }
  finally
    {
      *(struct 
      {
        struct outBuff * _M_start;
        struct outBuff * _M_finish;
        struct outBuff * _M_end_of_storage;
      } &) this = {CLOBBER};
    }
}
<D.42296>:;


;; Function std::_Vector_base<_Tp, _Alloc>::_Vector_base() [with _Tp = outBuff; _Alloc = std::allocator<outBuff>] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  *(struct 
  {
    struct _Vector_impl _M_impl;
  } &) this = {CLOBBER} >>>>>;
{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Vector_base *) this)->_M_impl = <<< Unknown tree: aggr_init_expr
  4
  __comp_ctor 
  D.42294
  (struct _Vector_impl *) <<< Unknown tree: void_cst >>> >>>) >>>>>;
  try
    {
      
    }
  catch
    {
      std::_Vector_base<outBuff, std::allocator<outBuff> >::_Vector_impl::~_Vector_impl (&((struct _Vector_base *) this)->_M_impl);
    }
}


;; Function std::_Vector_base<_Tp, _Alloc>::~_Vector_base() [with _Tp = outBuff; _Alloc = std::allocator<outBuff>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    try
      {
        try
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Vector_base<outBuff, std::allocator<outBuff> >::_M_deallocate ((struct _Vector_base *) this, ((struct _Vector_base *) this)->_M_impl._M_start, (size_t) (((long int) ((struct _Vector_base *) this)->_M_impl._M_end_of_storage - (long int) ((struct _Vector_base *) this)->_M_impl._M_start) /[ex] 40)) >>>>>;
          }
        finally
          {
            std::_Vector_base<outBuff, std::allocator<outBuff> >::_Vector_impl::~_Vector_impl (&((struct _Vector_base *) this)->_M_impl);
          }
      }
    finally
      {
        *(struct 
        {
          struct _Vector_impl _M_impl;
        } &) this = {CLOBBER};
      }
  }
  <D.42306>:;
   >>>;


;; Function void std::vector<_Tp, _Alloc>::_M_fill_assign(std::size_t, const value_type&) [with _Tp = outBuff; _Alloc = std::allocator<outBuff>; std::size_t = long unsigned int; std::vector<_Tp, _Alloc>::value_type = outBuff] (null)
;; enabled by -tree-original


{
  {
    if (<<cleanup_point std::vector<outBuff>::capacity ((struct vector *) this) < __n>>)
      {
        {
          struct vector __tmp;

                    struct vector __tmp;
          <<cleanup_point <<< Unknown tree: expr_stmt
  std::vector<outBuff>::vector (&__tmp, __n, __val, (const struct allocator_type &) std::_Vector_base<outBuff, std::allocator<outBuff> >::_M_get_Tp_allocator (&((struct vector *) this)->D.38528)) >>>>>;
          try
            {
              <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Vector_base<outBuff, std::allocator<outBuff> >::_Vector_impl::_M_swap_data (&__tmp.D.38528._M_impl, (struct _Vector_impl &) &((struct vector *) this)->D.38528._M_impl) >>>>>;
            }
          finally
            {
              std::vector<outBuff>::~vector (&__tmp);
            }
        }
      }
    else
      {
        if (<<cleanup_point std::vector<outBuff>::size ((struct vector *) this) < __n>>)
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  std::fill<__gnu_cxx::__normal_iterator<outBuff*, std::vector<outBuff> >, outBuff> (TARGET_EXPR <D.42407, std::vector<outBuff>::begin ((struct vector *) this)>, TARGET_EXPR <D.42417, std::vector<outBuff>::end ((struct vector *) this)>, (const struct outBuff &) __val) >>>>>;
            <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct vector *) this)->D.38528._M_impl._M_finish = std::__uninitialized_fill_n_a<outBuff*, long unsigned int, outBuff, outBuff> (((struct vector *) this)->D.38528._M_impl._M_finish, __n - std::vector<outBuff>::size ((struct vector *) this), (const struct outBuff &) __val, (struct allocator &) std::_Vector_base<outBuff, std::allocator<outBuff> >::_M_get_Tp_allocator (&((struct vector *) this)->D.38528))) >>>>>;
          }
        else
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  std::vector<outBuff>::_M_erase_at_end ((struct vector *) this, std::fill_n<outBuff*, long unsigned int, outBuff> (((struct vector *) this)->D.38528._M_impl._M_start, __n, (const struct outBuff &) __val)) >>>>>;
          }
      }
  }
}


;; Function bool std::operator!=(const std::allocator<_CharT>&, const std::allocator<_CharT>&) [with _Tp = char] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 0
   >>>;


;; Function void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_destroy(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::allocator_traits<std::allocator<char> >::deallocate ((struct allocator_type &) std::__cxx11::basic_string<char>::_M_get_allocator ((struct basic_string *) this), std::__cxx11::basic_string<char>::_M_data ((struct basic_string *) this), __size + 1) >>>>>
   >>>;


;; Function void std::__alloc_on_move(_Alloc&, _Alloc&) [with _Alloc = std::allocator<char>] (null)
;; enabled by -tree-original


{
  typedef struct __traits __traits;
  typedef struct __pocma __pocma;

  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__do_alloc_on_move<std::allocator<char> > (__one, __two, TARGET_EXPR <D.42478, {}>;, <<< Unknown tree: empty_class_expr >>>;) >>>>>;
}


;; Function static void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_S_copy(_CharT*, const _CharT*, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


if (__n == 1)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::char_traits<char>::assign ((char_type &) NON_LVALUE_EXPR <__d>, (const char_type &) NON_LVALUE_EXPR <__s>) >>>>>;
  }
else
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) std::char_traits<char>::copy (__d, __s, __n) >>>>>;
  }


;; Function bool std::operator==(const std::allocator<_CharT>&, const std::allocator<_CharT>&) [with _Tp = char] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 1
   >>>;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>& std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::assign(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char>::_M_assign ((struct basic_string *) this, __str) >>>>>;
return <retval> = (struct basic_string &) this;


;; Function void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::clear() [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char>::_M_set_length ((struct basic_string *) this, 0) >>>>>
   >>>;


;; Function _FIter1 std::search(_FIter1, _FIter1, _FIter2, _FIter2) [with _FIter1 = unsigned char*; _FIter2 = char*] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = std::__search<unsigned char*, char*, __gnu_cxx::__ops::_Iter_equal_to_iter> (__first1, __last1, __first2, __last2, TARGET_EXPR <D.42488, __gnu_cxx::__ops::__iter_equal_to_iter ()>;, <<< Unknown tree: empty_class_expr >>>;)>>;


;; Function _FIter1 std::search(_FIter1, _FIter1, _FIter2, _FIter2) [with _FIter1 = unsigned char*; _FIter2 = unsigned char*] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = std::__search<unsigned char*, unsigned char*, __gnu_cxx::__ops::_Iter_equal_to_iter> (__first1, __last1, __first2, __last2, TARGET_EXPR <D.42496, __gnu_cxx::__ops::__iter_equal_to_iter ()>;, <<< Unknown tree: empty_class_expr >>>;)>>;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_reference std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::operator[](std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type) const [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_reference = const char&; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (const value_type &) (std::__cxx11::basic_string<char>::_M_data ((const struct basic_string *) this) + (sizetype) NON_LVALUE_EXPR <__pos>)>>
   >>>;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>& std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::append(const _CharT*) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>] (null)
;; enabled by -tree-original


{
  const size_type __n;

    const size_type __n;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__n = std::char_traits<char>::length (__s)) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char>::_M_check_length ((struct basic_string *) this, 0, (size_type) __n, (const char *) "basic_string::append") >>>>>;
  <<cleanup_point return <retval> = std::__cxx11::basic_string<char>::_M_append ((struct basic_string *) this, __s, (size_type) __n)>>;
}


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>& std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::append(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = std::__cxx11::basic_string<char>::_M_append ((struct basic_string *) this, (const char *) std::__cxx11::basic_string<char>::_M_data ((const struct basic_string *) __str), std::__cxx11::basic_string<char>::size ((const struct basic_string *) __str))>>;


;; Function void std::vector<_Tp, _Alloc>::_M_erase_at_end(std::vector<_Tp, _Alloc>::pointer) [with _Tp = outBuff; _Alloc = std::allocator<outBuff>; std::vector<_Tp, _Alloc>::pointer = outBuff*] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Destroy<outBuff*, outBuff> (__pos, ((struct vector *) this)->D.38528._M_impl._M_finish, (struct allocator &) std::_Vector_base<outBuff, std::allocator<outBuff> >::_M_get_Tp_allocator (&((struct vector *) this)->D.38528)) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct vector *) this)->D.38528._M_impl._M_finish = __pos) >>>>>;
   >>>;


;; Function void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_construct(_InIterator, _InIterator) [with _InIterator = char*; _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>] (null)
;; enabled by -tree-original


{
  typedef struct _Integral _Integral;

  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char>::_M_construct_aux<char*> ((struct basic_string *) this, __beg, __end, TARGET_EXPR <D.42524, {}>;, <<< Unknown tree: empty_class_expr >>>;) >>>>>;
}


;; Function static _Tp* std::pointer_traits<_Tp*>::pointer_to(std::__make_not_void<_Tp>&) [with _Tp = char; std::pointer_traits<_Tp*>::pointer = char*; std::__make_not_void<_Tp> = char] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (char *) std::addressof<char> ((char &) __r)>>
   >>>;


;; Function std::allocator< <template-parameter-1-1> >::allocator(const std::allocator< <template-parameter-1-1> >&) [with _Tp = char] (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::new_allocator<char>::new_allocator ((struct new_allocator *) this, (const struct new_allocator &) __a) >>>>>;
    try
      {
        
      }
    catch
      {
        __gnu_cxx::new_allocator<char>::~new_allocator ((struct new_allocator *) this);
      }
  }
   >>>;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_pointer std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_local_data() const [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_pointer = const char*] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = (const char *) std::pointer_traits<const char*>::pointer_to ((const __make_not_void &) &((const struct basic_string *) this)->D.18739._M_local_buf)>>;


;; Function void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_construct(_InIterator, _InIterator) [with _InIterator = wchar_t*; _CharT = wchar_t; _Traits = std::char_traits<wchar_t>; _Alloc = std::allocator<wchar_t>] (null)
;; enabled by -tree-original


{
  typedef struct _Integral _Integral;

  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<wchar_t>::_M_construct_aux<wchar_t*> ((struct basic_string *) this, __beg, __end, TARGET_EXPR <D.42589, {}>;, <<< Unknown tree: empty_class_expr >>>;) >>>>>;
}


;; Function void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_destroy(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type) [with _CharT = wchar_t; _Traits = std::char_traits<wchar_t>; _Alloc = std::allocator<wchar_t>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::allocator_traits<std::allocator<wchar_t> >::deallocate ((struct allocator_type &) std::__cxx11::basic_string<wchar_t>::_M_get_allocator ((struct basic_string *) this), std::__cxx11::basic_string<wchar_t>::_M_data ((struct basic_string *) this), __size + 1) >>>>>
   >>>;


;; Function static _Tp* std::pointer_traits<_Tp*>::pointer_to(std::__make_not_void<_Tp>&) [with _Tp = wchar_t; std::pointer_traits<_Tp*>::pointer = wchar_t*; std::__make_not_void<_Tp> = wchar_t] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (wchar_t *) std::addressof<wchar_t> ((wchar_t &) __r)>>
   >>>;


;; Function std::allocator< <template-parameter-1-1> >::allocator(const std::allocator< <template-parameter-1-1> >&) [with _Tp = wchar_t] (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::new_allocator<wchar_t>::new_allocator ((struct new_allocator *) this, (const struct new_allocator &) __a) >>>>>;
    try
      {
        
      }
    catch
      {
        __gnu_cxx::new_allocator<wchar_t>::~new_allocator ((struct new_allocator *) this);
      }
  }
   >>>;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_pointer std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_local_data() const [with _CharT = wchar_t; _Traits = std::char_traits<wchar_t>; _Alloc = std::allocator<wchar_t>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_pointer = const wchar_t*] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = (const wchar_t *) std::pointer_traits<const wchar_t*>::pointer_to ((const __make_not_void &) &((const struct basic_string *) this)->D.20139._M_local_buf)>>;


;; Function void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_construct_aux(_InIterator, _InIterator, std::__false_type) [with _InIterator = const char*; _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>] (null)
;; enabled by -tree-original


{
  typedef struct _Tag _Tag;

  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char>::_M_construct<const char*> ((struct basic_string *) this, __beg, __end, TARGET_EXPR <D.42767, *(struct forward_iterator_tag &) &TARGET_EXPR <D.42747, {}>>;, <<< Unknown tree: empty_class_expr >>>;) >>>>>;
}


;; Function void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_construct_aux(_InIterator, _InIterator, std::__false_type) [with _InIterator = const wchar_t*; _CharT = wchar_t; _Traits = std::char_traits<wchar_t>; _Alloc = std::allocator<wchar_t>] (null)
;; enabled by -tree-original


{
  typedef struct _Tag _Tag;

  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<wchar_t>::_M_construct<const wchar_t*> ((struct basic_string *) this, __beg, __end, TARGET_EXPR <D.42790, *(struct forward_iterator_tag &) &TARGET_EXPR <D.42779, {}>>;, <<< Unknown tree: empty_class_expr >>>;) >>>>>;
}


;; Function static _Tp* std::pointer_traits<_Tp*>::pointer_to(std::__make_not_void<_Tp>&) [with _Tp = char16_t; std::pointer_traits<_Tp*>::pointer = char16_t*; std::__make_not_void<_Tp> = char16_t] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (char16_t *) std::addressof<char16_t> ((char16_t &) __r)>>
   >>>;


;; Function std::allocator< <template-parameter-1-1> >::allocator(const std::allocator< <template-parameter-1-1> >&) [with _Tp = char16_t] (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::new_allocator<char16_t>::new_allocator ((struct new_allocator *) this, (const struct new_allocator &) __a) >>>>>;
    try
      {
        
      }
    catch
      {
        __gnu_cxx::new_allocator<char16_t>::~new_allocator ((struct new_allocator *) this);
      }
  }
   >>>;


;; Function void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_construct_aux(_InIterator, _InIterator, std::__false_type) [with _InIterator = const char16_t*; _CharT = char16_t; _Traits = std::char_traits<char16_t>; _Alloc = std::allocator<char16_t>] (null)
;; enabled by -tree-original


{
  typedef struct _Tag _Tag;

  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char16_t>::_M_construct<const char16_t*> ((struct basic_string *) this, __beg, __end, TARGET_EXPR <D.42830, *(struct forward_iterator_tag &) &TARGET_EXPR <D.42819, {}>>;, <<< Unknown tree: empty_class_expr >>>;) >>>>>;
}


;; Function void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_destroy(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type) [with _CharT = char16_t; _Traits = std::char_traits<char16_t>; _Alloc = std::allocator<char16_t>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::allocator_traits<std::allocator<char16_t> >::deallocate ((struct allocator_type &) std::__cxx11::basic_string<char16_t>::_M_get_allocator ((struct basic_string *) this), std::__cxx11::basic_string<char16_t>::_M_data ((struct basic_string *) this), __size + 1) >>>>>
   >>>;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_pointer std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_local_data() const [with _CharT = char16_t; _Traits = std::char_traits<char16_t>; _Alloc = std::allocator<char16_t>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_pointer = const char16_t*] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = (const char16_t *) std::pointer_traits<const char16_t*>::pointer_to ((const __make_not_void &) &((const struct basic_string *) this)->D.22012._M_local_buf)>>;


;; Function static _Tp* std::pointer_traits<_Tp*>::pointer_to(std::__make_not_void<_Tp>&) [with _Tp = char32_t; std::pointer_traits<_Tp*>::pointer = char32_t*; std::__make_not_void<_Tp> = char32_t] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (char32_t *) std::addressof<char32_t> ((char32_t &) __r)>>
   >>>;


;; Function std::allocator< <template-parameter-1-1> >::allocator(const std::allocator< <template-parameter-1-1> >&) [with _Tp = char32_t] (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::new_allocator<char32_t>::new_allocator ((struct new_allocator *) this, (const struct new_allocator &) __a) >>>>>;
    try
      {
        
      }
    catch
      {
        __gnu_cxx::new_allocator<char32_t>::~new_allocator ((struct new_allocator *) this);
      }
  }
   >>>;


;; Function void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_construct_aux(_InIterator, _InIterator, std::__false_type) [with _InIterator = const char32_t*; _CharT = char32_t; _Traits = std::char_traits<char32_t>; _Alloc = std::allocator<char32_t>] (null)
;; enabled by -tree-original


{
  typedef struct _Tag _Tag;

  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char32_t>::_M_construct<const char32_t*> ((struct basic_string *) this, __beg, __end, TARGET_EXPR <D.42905, *(struct forward_iterator_tag &) &TARGET_EXPR <D.42894, {}>>;, <<< Unknown tree: empty_class_expr >>>;) >>>>>;
}


;; Function void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_destroy(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type) [with _CharT = char32_t; _Traits = std::char_traits<char32_t>; _Alloc = std::allocator<char32_t>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::allocator_traits<std::allocator<char32_t> >::deallocate ((struct allocator_type &) std::__cxx11::basic_string<char32_t>::_M_get_allocator ((struct basic_string *) this), std::__cxx11::basic_string<char32_t>::_M_data ((struct basic_string *) this), __size + 1) >>>>>
   >>>;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_pointer std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_local_data() const [with _CharT = char32_t; _Traits = std::char_traits<char32_t>; _Alloc = std::allocator<char32_t>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_pointer = const char32_t*] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = (const char32_t *) std::pointer_traits<const char32_t*>::pointer_to ((const __make_not_void &) &((const struct basic_string *) this)->D.23329._M_local_buf)>>;


;; Function static _Tp* std::pointer_traits<_Tp*>::pointer_to(std::__make_not_void<_Tp>&) [with _Tp = unsigned char; std::pointer_traits<_Tp*>::pointer = unsigned char*; std::__make_not_void<_Tp> = unsigned char] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (unsigned char *) std::addressof<unsigned char> ((unsigned char &) __r)>>
   >>>;


;; Function __gnu_cxx::new_allocator<_Tp>::new_allocator() [with _Tp = unsigned char] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    
  }
   >>>;


;; Function __gnu_cxx::new_allocator<_Tp>::~new_allocator() [with _Tp = unsigned char] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    
  }
  <D.42951>:;
   >>>;


;; Function std::allocator< <template-parameter-1-1> >::allocator(const std::allocator< <template-parameter-1-1> >&) [with _Tp = unsigned char] (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::new_allocator<unsigned char>::new_allocator ((struct new_allocator *) this, (const struct new_allocator &) __a) >>>>>;
    try
      {
        
      }
    catch
      {
        __gnu_cxx::new_allocator<unsigned char>::~new_allocator ((struct new_allocator *) this);
      }
  }
   >>>;


;; Function void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_length(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type) [with _CharT = unsigned char; _Traits = std::char_traits<unsigned char>; _Alloc = std::allocator<unsigned char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct basic_string *) this)->_M_string_length = __length) >>>>>;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_data() const [with _CharT = unsigned char; _Traits = std::char_traits<unsigned char>; _Alloc = std::allocator<unsigned char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer = unsigned char*] (null)
;; enabled by -tree-original


return <retval> = (unsigned char *) ((const struct basic_string *) this)->_M_dataplus._M_p;


;; Function static constexpr void __gnu_cxx::char_traits<_CharT>::assign(__gnu_cxx::char_traits<_CharT>::char_type&, const char_type&) [with _CharT = unsigned char; __gnu_cxx::char_traits<_CharT>::char_type = unsigned char] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__c1 = (char_type) *__c2) >>>>>;


;; Function bool std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_is_local() const [with _CharT = unsigned char; _Traits = std::char_traits<unsigned char>; _Alloc = std::allocator<unsigned char>] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = (const unsigned char *) std::__cxx11::basic_string<unsigned char>::_M_data ((const struct basic_string *) this) == std::__cxx11::basic_string<unsigned char>::_M_local_data ((const struct basic_string *) this)>>;


;; Function void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_destroy(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type) [with _CharT = unsigned char; _Traits = std::char_traits<unsigned char>; _Alloc = std::allocator<unsigned char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::allocator_traits<std::allocator<unsigned char> >::deallocate ((struct allocator_type &) std::__cxx11::basic_string<unsigned char>::_M_get_allocator ((struct basic_string *) this), std::__cxx11::basic_string<unsigned char>::_M_data ((struct basic_string *) this), __size + 1) >>>>>
   >>>;


;; Function std::_Vector_base<_Tp, _Alloc>::_Vector_impl::_Vector_impl() [with _Tp = outBuff; _Alloc = std::allocator<outBuff>] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  *(struct 
  {
    struct outBuff * _M_start;
    struct outBuff * _M_finish;
    struct outBuff * _M_end_of_storage;
  } &) this = {CLOBBER} >>>>>;
{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::allocator<outBuff>::allocator ((struct allocator *) this) >>>>>;
  try
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Vector_impl *) this)->_M_start = 0B) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Vector_impl *) this)->_M_finish = 0B) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Vector_impl *) this)->_M_end_of_storage = 0B) >>>>>;
    }
  catch
    {
      std::allocator<outBuff>::~allocator ((struct allocator *) this);
    }
}


;; Function std::allocator< <template-parameter-1-1> >::~allocator() [with _Tp = outBuff] (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  {
    try
      {
        
      }
    finally
      {
        __gnu_cxx::new_allocator<outBuff>::~new_allocator ((struct new_allocator *) this);
      }
  }
  <D.42978>:;
   >>>;


;; Function void std::_Vector_base<_Tp, _Alloc>::_M_deallocate(std::_Vector_base<_Tp, _Alloc>::pointer, std::size_t) [with _Tp = outBuff; _Alloc = std::allocator<outBuff>; std::_Vector_base<_Tp, _Alloc>::pointer = outBuff*; std::size_t = long unsigned int] (null)
;; enabled by -tree-original


{
  typedef struct _Tr _Tr;

  if (__p != 0B)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::allocator_traits<std::allocator<outBuff> >::deallocate ((struct allocator_type &) &((struct _Vector_base *) this)->_M_impl, __p, __n) >>>>>;
    }
}


;; Function std::vector<_Tp, _Alloc>::size_type std::vector<_Tp, _Alloc>::capacity() const [with _Tp = outBuff; _Alloc = std::allocator<outBuff>; std::vector<_Tp, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (size_type) (((long int) ((const struct vector *) this)->D.38528._M_impl._M_end_of_storage - (long int) ((const struct vector *) this)->D.38528._M_impl._M_start) /[ex] 40)
   >>>;


;; Function std::_Vector_base<_Tp, _Alloc>::_Tp_alloc_type& std::_Vector_base<_Tp, _Alloc>::_M_get_Tp_allocator() [with _Tp = outBuff; _Alloc = std::allocator<outBuff>; std::_Vector_base<_Tp, _Alloc>::_Tp_alloc_type = std::allocator<outBuff>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct _Tp_alloc_type &) &((struct _Vector_base *) this)->_M_impl
   >>>;


;; Function std::vector<_Tp, _Alloc>::vector(std::vector<_Tp, _Alloc>::size_type, const value_type&, const allocator_type&) [with _Tp = outBuff; _Alloc = std::allocator<outBuff>; std::vector<_Tp, _Alloc>::size_type = long unsigned int; std::vector<_Tp, _Alloc>::value_type = outBuff; std::vector<_Tp, _Alloc>::allocator_type = std::allocator<outBuff>] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  *(struct 
  {
    struct 
    {
      struct _Vector_impl _M_impl;
    } D.38529;
  } &) this = {CLOBBER} >>>>>;
{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Vector_base<outBuff, std::allocator<outBuff> >::_Vector_base (&((struct vector *) this)->D.38528, __n, (const struct allocator_type &) __a) >>>>>;
  try
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::vector<outBuff>::_M_fill_initialize ((struct vector *) this, __n, __value) >>>>>;
    }
  catch
    {
      std::_Vector_base<outBuff, std::allocator<outBuff> >::~_Vector_base (&((struct vector *) this)->D.38528);
    }
}


;; Function std::vector<_Tp, _Alloc>::~vector() [with _Tp = outBuff; _Alloc = std::allocator<outBuff>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    try
      {
        try
          {
            <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Destroy<outBuff*, outBuff> (((struct vector *) this)->D.38528._M_impl._M_start, ((struct vector *) this)->D.38528._M_impl._M_finish, (struct allocator &) std::_Vector_base<outBuff, std::allocator<outBuff> >::_M_get_Tp_allocator (&((struct vector *) this)->D.38528)) >>>>>;
          }
        finally
          {
            std::_Vector_base<outBuff, std::allocator<outBuff> >::~_Vector_base (&((struct vector *) this)->D.38528);
          }
      }
    finally
      {
        *(struct 
        {
          struct 
          {
            struct _Vector_impl _M_impl;
          } D.38529;
        } &) this = {CLOBBER};
      }
  }
  <D.42992>:;
   >>>;


;; Function void std::_Vector_base<_Tp, _Alloc>::_Vector_impl::_M_swap_data(std::_Vector_base<_Tp, _Alloc>::_Vector_impl&) [with _Tp = outBuff; _Alloc = std::allocator<outBuff>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::swap<outBuff*> ((struct outBuff * &) &((struct _Vector_impl *) this)->_M_start, (struct outBuff * &) &__x->_M_start) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::swap<outBuff*> ((struct outBuff * &) &((struct _Vector_impl *) this)->_M_finish, (struct outBuff * &) &__x->_M_finish) >>>>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::swap<outBuff*> ((struct outBuff * &) &((struct _Vector_impl *) this)->_M_end_of_storage, (struct outBuff * &) &__x->_M_end_of_storage) >>>>>;
   >>>;


;; Function std::vector<_Tp, _Alloc>::iterator std::vector<_Tp, _Alloc>::begin() [with _Tp = outBuff; _Alloc = std::allocator<outBuff>; std::vector<_Tp, _Alloc>::iterator = __gnu_cxx::__normal_iterator<outBuff*, std::vector<outBuff> >; typename std::_Vector_base<_Tp, _Alloc>::pointer = outBuff*] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = TARGET_EXPR <D.43352, <<< Unknown tree: aggr_init_expr
  5
  __comp_ctor 
  D.43352
  (struct __normal_iterator *) <<< Unknown tree: void_cst >>>
  (struct outBuff * const &) &((struct vector *) this)->D.38528._M_impl._M_start >>>>;, D.43352>>
   >>>;


;; Function std::vector<_Tp, _Alloc>::iterator std::vector<_Tp, _Alloc>::end() [with _Tp = outBuff; _Alloc = std::allocator<outBuff>; std::vector<_Tp, _Alloc>::iterator = __gnu_cxx::__normal_iterator<outBuff*, std::vector<outBuff> >; typename std::_Vector_base<_Tp, _Alloc>::pointer = outBuff*] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = TARGET_EXPR <D.43354, <<< Unknown tree: aggr_init_expr
  5
  __comp_ctor 
  D.43354
  (struct __normal_iterator *) <<< Unknown tree: void_cst >>>
  (struct outBuff * const &) &((struct vector *) this)->D.38528._M_impl._M_finish >>>>;, D.43354>>
   >>>;


;; Function void std::fill(_ForwardIterator, _ForwardIterator, const _Tp&) [with _ForwardIterator = __gnu_cxx::__normal_iterator<outBuff*, std::vector<outBuff> >; _Tp = outBuff] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  std::__fill_a<outBuff*, outBuff> (std::__niter_base<outBuff*, std::vector<outBuff> > (TARGET_EXPR <D.43360, __first>), std::__niter_base<outBuff*, std::vector<outBuff> > (TARGET_EXPR <D.43361, __last>), __value) >>>>>;


;; Function _ForwardIterator std::__uninitialized_fill_n_a(_ForwardIterator, _Size, const _Tp&, std::allocator<_Tp2>&) [with _ForwardIterator = outBuff*; _Size = long unsigned int; _Tp = outBuff; _Tp2 = outBuff] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = std::uninitialized_fill_n<outBuff*, long unsigned int, outBuff> (__first, __n, __x)>>;


;; Function _OI std::fill_n(_OI, _Size, const _Tp&) [with _OI = outBuff*; _Size = long unsigned int; _Tp = outBuff] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = (struct outBuff *) std::__fill_n_a<outBuff*, long unsigned int, outBuff> (std::__niter_base<outBuff*> (__first), __n, __value)>>;


;; Function static void std::allocator_traits<std::allocator<_CharT> >::deallocate(std::allocator_traits<std::allocator<_CharT> >::allocator_type&, std::allocator_traits<std::allocator<_CharT> >::pointer, std::allocator_traits<std::allocator<_CharT> >::size_type) [with _Tp = char; std::allocator_traits<std::allocator<_CharT> >::allocator_type = std::allocator<char>; std::allocator_traits<std::allocator<_CharT> >::pointer = char*; std::allocator_traits<std::allocator<_CharT> >::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::new_allocator<char>::deallocate ((struct new_allocator *) __a, __p, __n) >>>>>;


;; Function void std::__do_alloc_on_move(_Alloc&, _Alloc&, std::true_type) [with _Alloc = std::allocator<char>; std::true_type = std::integral_constant<bool, true>] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (const struct allocator &) std::move<std::allocator<char>&> (__two);, <<< Unknown tree: void_cst >>> >>>>>;


;; Function _ForwardIterator1 std::__search(_ForwardIterator1, _ForwardIterator1, _ForwardIterator2, _ForwardIterator2, _BinaryPredicate) [with _ForwardIterator1 = unsigned char*; _ForwardIterator2 = char*; _BinaryPredicate = __gnu_cxx::__ops::_Iter_equal_to_iter] (null)
;; enabled by -tree-original


{
  char * __p1 = __first2;
  char * __p;
  unsigned char * __current = __first1;

  if (__first1 == __last1 || __first2 == __last2)
    {
      return <retval> = __first1;
    }
    char * __p1 = __first2;
  if (<<cleanup_point  ++__p1 == __last2>>)
    {
      <<cleanup_point return <retval> = std::__find_if<unsigned char*, __gnu_cxx::__ops::_Iter_equals_iter<char*> > (__first1, __last1, TARGET_EXPR <D.43466, __gnu_cxx::__ops::__iter_comp_iter<char*> (TARGET_EXPR <D.43443, __predicate>;, <<< Unknown tree: empty_class_expr >>>;, __first2)>)>>;
    }
    char * __p;
    unsigned char * __current = __first1;
  while (1)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__first1 = std::__find_if<unsigned char*, __gnu_cxx::__ops::_Iter_equals_iter<char*> > (__first1, __last1, TARGET_EXPR <D.43502, __gnu_cxx::__ops::__iter_comp_iter<char*> (TARGET_EXPR <D.43500, __predicate>;, <<< Unknown tree: empty_class_expr >>>;, __first2)>)) >>>>>;
      if (__first1 == __last1)
        {
          return <retval> = __last1;
        }
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__p = __p1) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__current = __first1) >>>>>;
      if (<<cleanup_point  ++__current == __last1>>)
        {
          return <retval> = __last1;
        }
      while (1)
        {
          if (<<cleanup_point __gnu_cxx::__ops::_Iter_equal_to_iter::operator()<unsigned char*, char*> (&__predicate, __current, __p)>>) (void) 0; else goto <D.43509>;
          if (<<cleanup_point  ++__p == __last2>>)
            {
              return <retval> = __first1;
            }
          if (<<cleanup_point  ++__current == __last1>>)
            {
              return <retval> = __last1;
            }
        }
      <D.43509>:;
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void)  ++__first1 >>>>>;
    }
  return <retval> = __first1;
}


;; Function _ForwardIterator1 std::__search(_ForwardIterator1, _ForwardIterator1, _ForwardIterator2, _ForwardIterator2, _BinaryPredicate) [with _ForwardIterator1 = unsigned char*; _ForwardIterator2 = unsigned char*; _BinaryPredicate = __gnu_cxx::__ops::_Iter_equal_to_iter] (null)
;; enabled by -tree-original


{
  unsigned char * __p1 = __first2;
  unsigned char * __p;
  unsigned char * __current = __first1;

  if (__first1 == __last1 || __first2 == __last2)
    {
      return <retval> = __first1;
    }
    unsigned char * __p1 = __first2;
  if (<<cleanup_point  ++__p1 == __last2>>)
    {
      <<cleanup_point return <retval> = std::__find_if<unsigned char*, __gnu_cxx::__ops::_Iter_equals_iter<unsigned char*> > (__first1, __last1, TARGET_EXPR <D.43540, __gnu_cxx::__ops::__iter_comp_iter<unsigned char*> (TARGET_EXPR <D.43517, __predicate>;, <<< Unknown tree: empty_class_expr >>>;, __first2)>)>>;
    }
    unsigned char * __p;
    unsigned char * __current = __first1;
  while (1)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__first1 = std::__find_if<unsigned char*, __gnu_cxx::__ops::_Iter_equals_iter<unsigned char*> > (__first1, __last1, TARGET_EXPR <D.43576, __gnu_cxx::__ops::__iter_comp_iter<unsigned char*> (TARGET_EXPR <D.43574, __predicate>;, <<< Unknown tree: empty_class_expr >>>;, __first2)>)) >>>>>;
      if (__first1 == __last1)
        {
          return <retval> = __last1;
        }
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__p = __p1) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__current = __first1) >>>>>;
      if (<<cleanup_point  ++__current == __last1>>)
        {
          return <retval> = __last1;
        }
      while (1)
        {
          if (<<cleanup_point __gnu_cxx::__ops::_Iter_equal_to_iter::operator()<unsigned char*, unsigned char*> (&__predicate, __current, __p)>>) (void) 0; else goto <D.43583>;
          if (<<cleanup_point  ++__p == __last2>>)
            {
              return <retval> = __first1;
            }
          if (<<cleanup_point  ++__current == __last1>>)
            {
              return <retval> = __last1;
            }
        }
      <D.43583>:;
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void)  ++__first1 >>>>>;
    }
  return <retval> = __first1;
}


;; Function void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_check_length(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type, const char*) const [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


if (<<cleanup_point std::__cxx11::basic_string<char>::max_size ((const struct basic_string *) this) + (__n1 - std::__cxx11::basic_string<char>::size ((const struct basic_string *) this)) < __n2>>)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_length_error (*(const char * &) &__s) >>>>>;
  }


;; Function void std::_Destroy(_ForwardIterator, _ForwardIterator, std::allocator<_T2>&) [with _ForwardIterator = outBuff*; _Tp = outBuff] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  std::_Destroy<outBuff*> (__first, __last) >>>>>;


;; Function void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_construct_aux(_InIterator, _InIterator, std::__false_type) [with _InIterator = char*; _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>] (null)
;; enabled by -tree-original


{
  typedef struct _Tag _Tag;

  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char>::_M_construct<char*> ((struct basic_string *) this, __beg, __end, TARGET_EXPR <D.43603, *(struct forward_iterator_tag &) &TARGET_EXPR <D.43592, {}>>;, <<< Unknown tree: empty_class_expr >>>;) >>>>>;
}


;; Function constexpr _Tp* std::__addressof(_Tp&) [with _Tp = char] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (char *) __r
   >>>;


;; Function _Tp* std::addressof(_Tp&) [with _Tp = char] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::__addressof<char> (__r)>>
   >>>;


;; Function __gnu_cxx::new_allocator<_Tp>::new_allocator(const __gnu_cxx::new_allocator<_Tp>&) [with _Tp = char] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    
  }
   >>>;


;; Function static _Tp* std::pointer_traits<_Tp*>::pointer_to(std::__make_not_void<_Tp>&) [with _Tp = const char; std::pointer_traits<_Tp*>::pointer = const char*; std::__make_not_void<_Tp> = const char] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (const char *) std::addressof<const char> ((const char &) __r)>>
   >>>;


;; Function void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_construct_aux(_InIterator, _InIterator, std::__false_type) [with _InIterator = wchar_t*; _CharT = wchar_t; _Traits = std::char_traits<wchar_t>; _Alloc = std::allocator<wchar_t>] (null)
;; enabled by -tree-original


{
  typedef struct _Tag _Tag;

  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<wchar_t>::_M_construct<wchar_t*> ((struct basic_string *) this, __beg, __end, TARGET_EXPR <D.43628, *(struct forward_iterator_tag &) &TARGET_EXPR <D.43617, {}>>;, <<< Unknown tree: empty_class_expr >>>;) >>>>>;
}


;; Function static void std::allocator_traits<std::allocator<_CharT> >::deallocate(std::allocator_traits<std::allocator<_CharT> >::allocator_type&, std::allocator_traits<std::allocator<_CharT> >::pointer, std::allocator_traits<std::allocator<_CharT> >::size_type) [with _Tp = wchar_t; std::allocator_traits<std::allocator<_CharT> >::allocator_type = std::allocator<wchar_t>; std::allocator_traits<std::allocator<_CharT> >::pointer = wchar_t*; std::allocator_traits<std::allocator<_CharT> >::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::new_allocator<wchar_t>::deallocate ((struct new_allocator *) __a, __p, __n) >>>>>;


;; Function constexpr _Tp* std::__addressof(_Tp&) [with _Tp = wchar_t] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (wchar_t *) __r
   >>>;


;; Function _Tp* std::addressof(_Tp&) [with _Tp = wchar_t] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::__addressof<wchar_t> (__r)>>
   >>>;


;; Function __gnu_cxx::new_allocator<_Tp>::new_allocator(const __gnu_cxx::new_allocator<_Tp>&) [with _Tp = wchar_t] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    
  }
   >>>;


;; Function static _Tp* std::pointer_traits<_Tp*>::pointer_to(std::__make_not_void<_Tp>&) [with _Tp = const wchar_t; std::pointer_traits<_Tp*>::pointer = const wchar_t*; std::__make_not_void<_Tp> = const wchar_t] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (const wchar_t *) std::addressof<const wchar_t> ((const wchar_t &) __r)>>
   >>>;


;; Function void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_construct(_InIterator, _InIterator, std::forward_iterator_tag) [with _FwdIterator = const char*; _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>] (null)
;; enabled by -tree-original


{
  size_type __dnew;

  if (<<cleanup_point __gnu_cxx::__is_null_pointer<const char> (__beg) && __beg != __end>>)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_logic_error ((const char *) "basic_string::_M_construct null not valid") >>>>>;
    }
    size_type __dnew;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__dnew = (size_type) std::distance<const char*> (__beg, __end)) >>>>>;
  if (__dnew > 15)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char>::_M_data ((struct basic_string *) this, std::__cxx11::basic_string<char>::_M_create ((struct basic_string *) this, (size_type &) &__dnew, 0)) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char>::_M_capacity ((struct basic_string *) this, __dnew) >>>>>;
    }
  <<< Unknown tree: try_block
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char>::_S_copy_chars (std::__cxx11::basic_string<char>::_M_data ((struct basic_string *) this), __beg, __end) >>>>>
  <<< Unknown tree: handler
  
  try
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) __cxa_begin_catch (__builtin_eh_pointer (0)) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char>::_M_dispose ((struct basic_string *) this) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  <<< Unknown tree: throw_expr
  __cxa_rethrow () >>> >>>>>;
    }
  finally
    {
      __cxa_end_catch ();
    } >>> >>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char>::_M_set_length ((struct basic_string *) this, __dnew) >>>>>;
}


;; Function void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_construct(_InIterator, _InIterator, std::forward_iterator_tag) [with _FwdIterator = const wchar_t*; _CharT = wchar_t; _Traits = std::char_traits<wchar_t>; _Alloc = std::allocator<wchar_t>] (null)
;; enabled by -tree-original


{
  size_type __dnew;

  if (<<cleanup_point __gnu_cxx::__is_null_pointer<const wchar_t> (__beg) && __beg != __end>>)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_logic_error ((const char *) "basic_string::_M_construct null not valid") >>>>>;
    }
    size_type __dnew;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__dnew = (size_type) std::distance<const wchar_t*> (__beg, __end)) >>>>>;
  if (__dnew > 3)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<wchar_t>::_M_data ((struct basic_string *) this, std::__cxx11::basic_string<wchar_t>::_M_create ((struct basic_string *) this, (size_type &) &__dnew, 0)) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<wchar_t>::_M_capacity ((struct basic_string *) this, __dnew) >>>>>;
    }
  <<< Unknown tree: try_block
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<wchar_t>::_S_copy_chars (std::__cxx11::basic_string<wchar_t>::_M_data ((struct basic_string *) this), __beg, __end) >>>>>
  <<< Unknown tree: handler
  
  try
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) __cxa_begin_catch (__builtin_eh_pointer (0)) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<wchar_t>::_M_dispose ((struct basic_string *) this) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  <<< Unknown tree: throw_expr
  __cxa_rethrow () >>> >>>>>;
    }
  finally
    {
      __cxa_end_catch ();
    } >>> >>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<wchar_t>::_M_set_length ((struct basic_string *) this, __dnew) >>>>>;
}


;; Function constexpr _Tp* std::__addressof(_Tp&) [with _Tp = char16_t] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (char16_t *) __r
   >>>;


;; Function _Tp* std::addressof(_Tp&) [with _Tp = char16_t] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::__addressof<char16_t> (__r)>>
   >>>;


;; Function __gnu_cxx::new_allocator<_Tp>::new_allocator(const __gnu_cxx::new_allocator<_Tp>&) [with _Tp = char16_t] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    
  }
   >>>;


;; Function void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_construct(_InIterator, _InIterator, std::forward_iterator_tag) [with _FwdIterator = const char16_t*; _CharT = char16_t; _Traits = std::char_traits<char16_t>; _Alloc = std::allocator<char16_t>] (null)
;; enabled by -tree-original


{
  size_type __dnew;

  if (<<cleanup_point __gnu_cxx::__is_null_pointer<const char16_t> (__beg) && __beg != __end>>)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_logic_error ((const char *) "basic_string::_M_construct null not valid") >>>>>;
    }
    size_type __dnew;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__dnew = (size_type) std::distance<const char16_t*> (__beg, __end)) >>>>>;
  if (__dnew > 7)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char16_t>::_M_data ((struct basic_string *) this, std::__cxx11::basic_string<char16_t>::_M_create ((struct basic_string *) this, (size_type &) &__dnew, 0)) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char16_t>::_M_capacity ((struct basic_string *) this, __dnew) >>>>>;
    }
  <<< Unknown tree: try_block
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char16_t>::_S_copy_chars (std::__cxx11::basic_string<char16_t>::_M_data ((struct basic_string *) this), __beg, __end) >>>>>
  <<< Unknown tree: handler
  
  try
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) __cxa_begin_catch (__builtin_eh_pointer (0)) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char16_t>::_M_dispose ((struct basic_string *) this) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  <<< Unknown tree: throw_expr
  __cxa_rethrow () >>> >>>>>;
    }
  finally
    {
      __cxa_end_catch ();
    } >>> >>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char16_t>::_M_set_length ((struct basic_string *) this, __dnew) >>>>>;
}


;; Function static void std::allocator_traits<std::allocator<_CharT> >::deallocate(std::allocator_traits<std::allocator<_CharT> >::allocator_type&, std::allocator_traits<std::allocator<_CharT> >::pointer, std::allocator_traits<std::allocator<_CharT> >::size_type) [with _Tp = char16_t; std::allocator_traits<std::allocator<_CharT> >::allocator_type = std::allocator<char16_t>; std::allocator_traits<std::allocator<_CharT> >::pointer = char16_t*; std::allocator_traits<std::allocator<_CharT> >::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::new_allocator<char16_t>::deallocate ((struct new_allocator *) __a, __p, __n) >>>>>;


;; Function static _Tp* std::pointer_traits<_Tp*>::pointer_to(std::__make_not_void<_Tp>&) [with _Tp = const char16_t; std::pointer_traits<_Tp*>::pointer = const char16_t*; std::__make_not_void<_Tp> = const char16_t] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (const char16_t *) std::addressof<const char16_t> ((const char16_t &) __r)>>
   >>>;


;; Function constexpr _Tp* std::__addressof(_Tp&) [with _Tp = char32_t] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (char32_t *) __r
   >>>;


;; Function _Tp* std::addressof(_Tp&) [with _Tp = char32_t] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::__addressof<char32_t> (__r)>>
   >>>;


;; Function __gnu_cxx::new_allocator<_Tp>::new_allocator(const __gnu_cxx::new_allocator<_Tp>&) [with _Tp = char32_t] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    
  }
   >>>;


;; Function void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_construct(_InIterator, _InIterator, std::forward_iterator_tag) [with _FwdIterator = const char32_t*; _CharT = char32_t; _Traits = std::char_traits<char32_t>; _Alloc = std::allocator<char32_t>] (null)
;; enabled by -tree-original


{
  size_type __dnew;

  if (<<cleanup_point __gnu_cxx::__is_null_pointer<const char32_t> (__beg) && __beg != __end>>)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_logic_error ((const char *) "basic_string::_M_construct null not valid") >>>>>;
    }
    size_type __dnew;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__dnew = (size_type) std::distance<const char32_t*> (__beg, __end)) >>>>>;
  if (__dnew > 3)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char32_t>::_M_data ((struct basic_string *) this, std::__cxx11::basic_string<char32_t>::_M_create ((struct basic_string *) this, (size_type &) &__dnew, 0)) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char32_t>::_M_capacity ((struct basic_string *) this, __dnew) >>>>>;
    }
  <<< Unknown tree: try_block
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char32_t>::_S_copy_chars (std::__cxx11::basic_string<char32_t>::_M_data ((struct basic_string *) this), __beg, __end) >>>>>
  <<< Unknown tree: handler
  
  try
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) __cxa_begin_catch (__builtin_eh_pointer (0)) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char32_t>::_M_dispose ((struct basic_string *) this) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  <<< Unknown tree: throw_expr
  __cxa_rethrow () >>> >>>>>;
    }
  finally
    {
      __cxa_end_catch ();
    } >>> >>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char32_t>::_M_set_length ((struct basic_string *) this, __dnew) >>>>>;
}


;; Function static void std::allocator_traits<std::allocator<_CharT> >::deallocate(std::allocator_traits<std::allocator<_CharT> >::allocator_type&, std::allocator_traits<std::allocator<_CharT> >::pointer, std::allocator_traits<std::allocator<_CharT> >::size_type) [with _Tp = char32_t; std::allocator_traits<std::allocator<_CharT> >::allocator_type = std::allocator<char32_t>; std::allocator_traits<std::allocator<_CharT> >::pointer = char32_t*; std::allocator_traits<std::allocator<_CharT> >::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::new_allocator<char32_t>::deallocate ((struct new_allocator *) __a, __p, __n) >>>>>;


;; Function static _Tp* std::pointer_traits<_Tp*>::pointer_to(std::__make_not_void<_Tp>&) [with _Tp = const char32_t; std::pointer_traits<_Tp*>::pointer = const char32_t*; std::__make_not_void<_Tp> = const char32_t] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (const char32_t *) std::addressof<const char32_t> ((const char32_t &) __r)>>
   >>>;


;; Function constexpr _Tp* std::__addressof(_Tp&) [with _Tp = unsigned char] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (unsigned char *) __r
   >>>;


;; Function _Tp* std::addressof(_Tp&) [with _Tp = unsigned char] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::__addressof<unsigned char> (__r)>>
   >>>;


;; Function __gnu_cxx::new_allocator<_Tp>::new_allocator(const __gnu_cxx::new_allocator<_Tp>&) [with _Tp = unsigned char] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    
  }
   >>>;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_pointer std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_local_data() const [with _CharT = unsigned char; _Traits = std::char_traits<unsigned char>; _Alloc = std::allocator<unsigned char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::const_pointer = const unsigned char*] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = (const unsigned char *) std::pointer_traits<const unsigned char*>::pointer_to ((const __make_not_void &) &((const struct basic_string *) this)->D.29808._M_local_buf)>>;


;; Function static void std::allocator_traits<std::allocator<_CharT> >::deallocate(std::allocator_traits<std::allocator<_CharT> >::allocator_type&, std::allocator_traits<std::allocator<_CharT> >::pointer, std::allocator_traits<std::allocator<_CharT> >::size_type) [with _Tp = unsigned char; std::allocator_traits<std::allocator<_CharT> >::allocator_type = std::allocator<unsigned char>; std::allocator_traits<std::allocator<_CharT> >::pointer = unsigned char*; std::allocator_traits<std::allocator<_CharT> >::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::new_allocator<unsigned char>::deallocate ((struct new_allocator *) __a, __p, __n) >>>>>;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::allocator_type& std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_get_allocator() [with _CharT = unsigned char; _Traits = std::char_traits<unsigned char>; _Alloc = std::allocator<unsigned char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::allocator_type = std::allocator<unsigned char>] (null)
;; enabled by -tree-original


return <retval> = (struct allocator_type &) &((struct basic_string *) this)->_M_dataplus;


;; Function std::allocator< <template-parameter-1-1> >::allocator() [with _Tp = outBuff] (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::new_allocator<outBuff>::new_allocator ((struct new_allocator *) this) >>>>>;
    try
      {
        
      }
    catch
      {
        __gnu_cxx::new_allocator<outBuff>::~new_allocator ((struct new_allocator *) this);
      }
  }
   >>>;


;; Function __gnu_cxx::new_allocator<_Tp>::~new_allocator() [with _Tp = outBuff] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    
  }
  <D.44589>:;
   >>>;


;; Function static void std::allocator_traits<std::allocator<_CharT> >::deallocate(std::allocator_traits<std::allocator<_CharT> >::allocator_type&, std::allocator_traits<std::allocator<_CharT> >::pointer, std::allocator_traits<std::allocator<_CharT> >::size_type) [with _Tp = outBuff; std::allocator_traits<std::allocator<_CharT> >::allocator_type = std::allocator<outBuff>; std::allocator_traits<std::allocator<_CharT> >::pointer = outBuff*; std::allocator_traits<std::allocator<_CharT> >::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::new_allocator<outBuff>::deallocate ((struct new_allocator *) __a, __p, __n) >>>>>;


;; Function std::_Vector_base<_Tp, _Alloc>::_Vector_base(std::size_t, const allocator_type&) [with _Tp = outBuff; _Alloc = std::allocator<outBuff>; std::size_t = long unsigned int; std::_Vector_base<_Tp, _Alloc>::allocator_type = std::allocator<outBuff>] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  *(struct 
  {
    struct _Vector_impl _M_impl;
  } &) this = {CLOBBER} >>>>>;
{
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Vector_base<outBuff, std::allocator<outBuff> >::_Vector_impl::_Vector_impl (&((struct _Vector_base *) this)->_M_impl, (const struct _Tp_alloc_type &) __a) >>>>>;
  try
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Vector_base<outBuff, std::allocator<outBuff> >::_M_create_storage ((struct _Vector_base *) this, __n) >>>>>;
    }
  catch
    {
      std::_Vector_base<outBuff, std::allocator<outBuff> >::_Vector_impl::~_Vector_impl (&((struct _Vector_base *) this)->_M_impl);
    }
}


;; Function void std::vector<_Tp, _Alloc>::_M_fill_initialize(std::vector<_Tp, _Alloc>::size_type, const value_type&) [with _Tp = outBuff; _Alloc = std::allocator<outBuff>; std::vector<_Tp, _Alloc>::size_type = long unsigned int; std::vector<_Tp, _Alloc>::value_type = outBuff] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct vector *) this)->D.38528._M_impl._M_finish = std::__uninitialized_fill_n_a<outBuff*, long unsigned int, outBuff, outBuff> (((struct vector *) this)->D.38528._M_impl._M_start, __n, (const struct outBuff &) __value, (struct allocator &) std::_Vector_base<outBuff, std::allocator<outBuff> >::_M_get_Tp_allocator (&((struct vector *) this)->D.38528))) >>>>>;


;; Function constexpr typename std::remove_reference< <template-parameter-1-1> >::type&& std::move(_Tp&&) [with _Tp = outBuff*&; typename std::remove_reference< <template-parameter-1-1> >::type = outBuff*] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct outBuff * &) __t
   >>>;


;; Function typename std::enable_if<std::__and_<std::__not_<std::__is_tuple_like<_Tp> >, std::is_move_constructible<_Tp>, std::is_move_assignable<_Tp> >::value>::type std::swap(_Tp&, _Tp&) [with _Tp = outBuff*; typename std::enable_if<std::__and_<std::__not_<std::__is_tuple_like<_Tp> >, std::is_move_constructible<_Tp>, std::is_move_assignable<_Tp> >::value>::type = void] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    struct outBuff * __tmp;

        struct outBuff * __tmp;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__tmp = *std::move<outBuff*&> (__a)) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__a = *std::move<outBuff*&> (__b)) >>>>>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__b = *std::move<outBuff*&> ((struct outBuff * &) &__tmp)) >>>>>;
  }
   >>>;


;; Function __gnu_cxx::__normal_iterator<_Iterator, _Container>::__normal_iterator(const _Iterator&) [with _Iterator = outBuff*; _Container = std::vector<outBuff>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point <<< Unknown tree: expr_stmt
  *(struct 
  {
    struct outBuff * _M_current;
  } &) this = {CLOBBER} >>>>>;
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct __normal_iterator *) this)->_M_current = (struct outBuff *) *__i) >>>>>;
  }
   >>>;


;; Function _Iterator std::__niter_base(__gnu_cxx::__normal_iterator<_Iterator, _Container>) [with _Iterator = outBuff*; _Container = std::vector<outBuff>] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = (struct outBuff *) *__gnu_cxx::__normal_iterator<outBuff*, std::vector<outBuff> >::base (&__it)>>;


;; Function typename __gnu_cxx::__enable_if<(! std::__is_scalar<_Tp>::__value), void>::__type std::__fill_a(_ForwardIterator, _ForwardIterator, const _Tp&) [with _ForwardIterator = outBuff*; _Tp = outBuff; typename __gnu_cxx::__enable_if<(! std::__is_scalar<_Tp>::__value), void>::__type = void] (null)
;; enabled by -tree-original


while (1)
  {
    if (__first == __last) goto <D.44614>;
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*NON_LVALUE_EXPR <__first> = *__value) >>>>>;
    <<cleanup_point (void)  ++__first>>;
  }
<D.44614>:;


;; Function _ForwardIterator std::uninitialized_fill_n(_ForwardIterator, _Size, const _Tp&) [with _ForwardIterator = outBuff*; _Size = long unsigned int; _Tp = outBuff] (null)
;; enabled by -tree-original


{
  typedef struct _ValueType _ValueType;
  const bool __assignable = 1;

  <<cleanup_point   const bool __assignable = 1;>>;
  <<cleanup_point return <retval> = std::__uninitialized_fill_n<false>::__uninit_fill_n<outBuff*, long unsigned int, outBuff> (__first, __n, __x)>>;
}


;; Function _Iterator std::__niter_base(_Iterator) [with _Iterator = outBuff*] (null)
;; enabled by -tree-original


return <retval> = __it;


;; Function typename __gnu_cxx::__enable_if<(! std::__is_scalar<_Tp>::__value), _OutputIterator>::__type std::__fill_n_a(_OutputIterator, _Size, const _Tp&) [with _OutputIterator = outBuff*; _Size = long unsigned int; _Tp = outBuff; typename __gnu_cxx::__enable_if<(! std::__is_scalar<_Tp>::__value), _OutputIterator>::__type = outBuff*] (null)
;; enabled by -tree-original


{
  {
    long unsigned int __niter = __n;

        long unsigned int __niter = __n;
    while (1)
      {
        if (__niter == 0) goto <D.44829>;
        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*NON_LVALUE_EXPR <__first> = *__value) >>>>>;
        <<cleanup_point (void)  --__niter;, (void)  ++__first;>>;
      }
    <D.44829>:;
  }
  return <retval> = (struct outBuff *) __first;
}


;; Function void __gnu_cxx::new_allocator<_Tp>::deallocate(__gnu_cxx::new_allocator<_Tp>::pointer, __gnu_cxx::new_allocator<_Tp>::size_type) [with _Tp = char; __gnu_cxx::new_allocator<_Tp>::pointer = char*; __gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  operator delete ((void *) __p) >>>>>;


;; Function __gnu_cxx::__ops::_Iter_equals_iter<_Iterator> __gnu_cxx::__ops::__iter_comp_iter(__gnu_cxx::__ops::_Iter_equal_to_iter, _Iterator) [with _Iterator = char*] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = TARGET_EXPR <D.44833, <<< Unknown tree: aggr_init_expr
  5
  __comp_ctor 
  D.44833
  (struct _Iter_equals_iter *) <<< Unknown tree: void_cst >>>
  __it >>>>;, D.44833>>;


;; Function constexpr typename std::iterator_traits<_Iterator>::iterator_category std::__iterator_category(const _Iter&) [with _Iter = unsigned char*; typename std::iterator_traits<_Iterator>::iterator_category = std::random_access_iterator_tag] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = TARGET_EXPR <D.44858, {}>>>;


;; Function _Iterator std::__find_if(_Iterator, _Iterator, _Predicate) [with _Iterator = unsigned char*; _Predicate = __gnu_cxx::__ops::_Iter_equals_iter<char*>] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = std::__find_if<unsigned char*, __gnu_cxx::__ops::_Iter_equals_iter<char*> > (__first, __last, TARGET_EXPR <D.44856, __pred>, TARGET_EXPR <D.44845, TARGET_EXPR <D.44860, {}>>;, <<< Unknown tree: empty_class_expr >>>;)>>;


;; Function bool __gnu_cxx::__ops::_Iter_equal_to_iter::operator()(_Iterator1, _Iterator2) const [with _Iterator1 = unsigned char*; _Iterator2 = char*] (null)
;; enabled by -tree-original


return <retval> = (int) *__it1 == (int) *__it2;


;; Function __gnu_cxx::__ops::_Iter_equals_iter<_Iterator> __gnu_cxx::__ops::__iter_comp_iter(__gnu_cxx::__ops::_Iter_equal_to_iter, _Iterator) [with _Iterator = unsigned char*] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = TARGET_EXPR <D.44863, <<< Unknown tree: aggr_init_expr
  5
  __comp_ctor 
  D.44863
  (struct _Iter_equals_iter *) <<< Unknown tree: void_cst >>>
  __it >>>>;, D.44863>>;


;; Function _Iterator std::__find_if(_Iterator, _Iterator, _Predicate) [with _Iterator = unsigned char*; _Predicate = __gnu_cxx::__ops::_Iter_equals_iter<unsigned char*>] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = std::__find_if<unsigned char*, __gnu_cxx::__ops::_Iter_equals_iter<unsigned char*> > (__first, __last, TARGET_EXPR <D.44876, __pred>, TARGET_EXPR <D.44865, TARGET_EXPR <D.44878, {}>>;, <<< Unknown tree: empty_class_expr >>>;)>>;


;; Function bool __gnu_cxx::__ops::_Iter_equal_to_iter::operator()(_Iterator1, _Iterator2) const [with _Iterator1 = unsigned char*; _Iterator2 = unsigned char*] (null)
;; enabled by -tree-original


return <retval> = *__it1 == *__it2;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::max_size() const [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (std::allocator_traits<std::allocator<char> >::max_size ((const struct allocator_type &) std::__cxx11::basic_string<char>::_M_get_allocator ((const struct basic_string *) this)) + 18446744073709551615) / 2>>
   >>>;


;; Function void std::_Destroy(_ForwardIterator, _ForwardIterator) [with _ForwardIterator = outBuff*] (null)
;; enabled by -tree-original


{
  typedef struct _Value_type _Value_type;

  <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Destroy_aux<true>::__destroy<outBuff*> (__first, __last) >>>>>;
}


;; Function void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_construct(_InIterator, _InIterator, std::forward_iterator_tag) [with _FwdIterator = char*; _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>] (null)
;; enabled by -tree-original


{
  size_type __dnew;

  if (<<cleanup_point __gnu_cxx::__is_null_pointer<char> (__beg) && __beg != __end>>)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_logic_error ((const char *) "basic_string::_M_construct null not valid") >>>>>;
    }
    size_type __dnew;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__dnew = (size_type) std::distance<char*> (__beg, __end)) >>>>>;
  if (__dnew > 15)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char>::_M_data ((struct basic_string *) this, std::__cxx11::basic_string<char>::_M_create ((struct basic_string *) this, (size_type &) &__dnew, 0)) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char>::_M_capacity ((struct basic_string *) this, __dnew) >>>>>;
    }
  <<< Unknown tree: try_block
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char>::_S_copy_chars (std::__cxx11::basic_string<char>::_M_data ((struct basic_string *) this), __beg, __end) >>>>>
  <<< Unknown tree: handler
  
  try
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) __cxa_begin_catch (__builtin_eh_pointer (0)) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char>::_M_dispose ((struct basic_string *) this) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  <<< Unknown tree: throw_expr
  __cxa_rethrow () >>> >>>>>;
    }
  finally
    {
      __cxa_end_catch ();
    } >>> >>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char>::_M_set_length ((struct basic_string *) this, __dnew) >>>>>;
}


;; Function constexpr _Tp* std::__addressof(_Tp&) [with _Tp = const char] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (const char *) __r
   >>>;


;; Function _Tp* std::addressof(_Tp&) [with _Tp = const char] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::__addressof<const char> (__r)>>
   >>>;


;; Function void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_construct(_InIterator, _InIterator, std::forward_iterator_tag) [with _FwdIterator = wchar_t*; _CharT = wchar_t; _Traits = std::char_traits<wchar_t>; _Alloc = std::allocator<wchar_t>] (null)
;; enabled by -tree-original


{
  size_type __dnew;

  if (<<cleanup_point __gnu_cxx::__is_null_pointer<wchar_t> (__beg) && __beg != __end>>)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_logic_error ((const char *) "basic_string::_M_construct null not valid") >>>>>;
    }
    size_type __dnew;
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (__dnew = (size_type) std::distance<wchar_t*> (__beg, __end)) >>>>>;
  if (__dnew > 3)
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<wchar_t>::_M_data ((struct basic_string *) this, std::__cxx11::basic_string<wchar_t>::_M_create ((struct basic_string *) this, (size_type &) &__dnew, 0)) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<wchar_t>::_M_capacity ((struct basic_string *) this, __dnew) >>>>>;
    }
  <<< Unknown tree: try_block
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<wchar_t>::_S_copy_chars (std::__cxx11::basic_string<wchar_t>::_M_data ((struct basic_string *) this), __beg, __end) >>>>>
  <<< Unknown tree: handler
  
  try
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) __cxa_begin_catch (__builtin_eh_pointer (0)) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<wchar_t>::_M_dispose ((struct basic_string *) this) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  <<< Unknown tree: throw_expr
  __cxa_rethrow () >>> >>>>>;
    }
  finally
    {
      __cxa_end_catch ();
    } >>> >>>;
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<wchar_t>::_M_set_length ((struct basic_string *) this, __dnew) >>>>>;
}


;; Function void __gnu_cxx::new_allocator<_Tp>::deallocate(__gnu_cxx::new_allocator<_Tp>::pointer, __gnu_cxx::new_allocator<_Tp>::size_type) [with _Tp = wchar_t; __gnu_cxx::new_allocator<_Tp>::pointer = wchar_t*; __gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  operator delete ((void *) __p) >>>>>;


;; Function constexpr _Tp* std::__addressof(_Tp&) [with _Tp = const wchar_t] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (const wchar_t *) __r
   >>>;


;; Function _Tp* std::addressof(_Tp&) [with _Tp = const wchar_t] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::__addressof<const wchar_t> (__r)>>
   >>>;


;; Function bool __gnu_cxx::__is_null_pointer(_Type*) [with _Type = const char] (null)
;; enabled by -tree-original


return <retval> = __ptr == 0B;


;; Function constexpr typename std::iterator_traits<_Iterator>::iterator_category std::__iterator_category(const _Iter&) [with _Iter = const char*; typename std::iterator_traits<_Iterator>::iterator_category = std::random_access_iterator_tag] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = TARGET_EXPR <D.45035, {}>>>;


;; Function constexpr typename std::iterator_traits<_Iterator>::difference_type std::__distance(_RandomAccessIterator, _RandomAccessIterator, std::random_access_iterator_tag) [with _RandomAccessIterator = const char*; typename std::iterator_traits<_Iterator>::difference_type = long int] (null)
;; enabled by -tree-original


return <retval> = (long int) __last - (long int) __first;


;; Function typename std::iterator_traits<_Iterator>::difference_type std::distance(_InputIterator, _InputIterator) [with _InputIterator = const char*; typename std::iterator_traits<_Iterator>::difference_type = long int] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = std::__distance<const char*> (__first, __last, TARGET_EXPR <D.45025, TARGET_EXPR <D.45038, {}>>;, <<< Unknown tree: empty_class_expr >>>;)>>;


;; Function static void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_S_copy_chars(_CharT*, const _CharT*, const _CharT*) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char>::_S_copy (__p, __k1, (size_type) ((long int) __k2 - (long int) __k1)) >>>>>
   >>>;


;; Function bool __gnu_cxx::__is_null_pointer(_Type*) [with _Type = const wchar_t] (null)
;; enabled by -tree-original


return <retval> = __ptr == 0B;


;; Function constexpr typename std::iterator_traits<_Iterator>::iterator_category std::__iterator_category(const _Iter&) [with _Iter = const wchar_t*; typename std::iterator_traits<_Iterator>::iterator_category = std::random_access_iterator_tag] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = TARGET_EXPR <D.45054, {}>>>;


;; Function constexpr typename std::iterator_traits<_Iterator>::difference_type std::__distance(_RandomAccessIterator, _RandomAccessIterator, std::random_access_iterator_tag) [with _RandomAccessIterator = const wchar_t*; typename std::iterator_traits<_Iterator>::difference_type = long int] (null)
;; enabled by -tree-original


return <retval> = ((long int) __last - (long int) __first) /[ex] 4;


;; Function typename std::iterator_traits<_Iterator>::difference_type std::distance(_InputIterator, _InputIterator) [with _InputIterator = const wchar_t*; typename std::iterator_traits<_Iterator>::difference_type = long int] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = std::__distance<const wchar_t*> (__first, __last, TARGET_EXPR <D.45044, TARGET_EXPR <D.45057, {}>>;, <<< Unknown tree: empty_class_expr >>>;)>>;


;; Function static void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_S_copy_chars(_CharT*, const _CharT*, const _CharT*) [with _CharT = wchar_t; _Traits = std::char_traits<wchar_t>; _Alloc = std::allocator<wchar_t>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<wchar_t>::_S_copy (__p, __k1, (size_type) (((long int) __k2 - (long int) __k1) /[ex] 4)) >>>>>
   >>>;


;; Function bool __gnu_cxx::__is_null_pointer(_Type*) [with _Type = const char16_t] (null)
;; enabled by -tree-original


return <retval> = __ptr == 0B;


;; Function constexpr typename std::iterator_traits<_Iterator>::iterator_category std::__iterator_category(const _Iter&) [with _Iter = const char16_t*; typename std::iterator_traits<_Iterator>::iterator_category = std::random_access_iterator_tag] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = TARGET_EXPR <D.45073, {}>>>;


;; Function constexpr typename std::iterator_traits<_Iterator>::difference_type std::__distance(_RandomAccessIterator, _RandomAccessIterator, std::random_access_iterator_tag) [with _RandomAccessIterator = const char16_t*; typename std::iterator_traits<_Iterator>::difference_type = long int] (null)
;; enabled by -tree-original


return <retval> = ((long int) __last - (long int) __first) /[ex] 2;


;; Function typename std::iterator_traits<_Iterator>::difference_type std::distance(_InputIterator, _InputIterator) [with _InputIterator = const char16_t*; typename std::iterator_traits<_Iterator>::difference_type = long int] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = std::__distance<const char16_t*> (__first, __last, TARGET_EXPR <D.45063, TARGET_EXPR <D.45076, {}>>;, <<< Unknown tree: empty_class_expr >>>;)>>;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_create(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type&, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type) [with _CharT = char16_t; _Traits = std::char_traits<char16_t>; _Alloc = std::allocator<char16_t>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer = char16_t*; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


if (<<cleanup_point *__capacity > std::__cxx11::basic_string<char16_t>::max_size ((struct basic_string *) this)>>)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_length_error ((const char *) "basic_string::_M_create") >>>>>;
  }
if (*__capacity > __old_capacity && *__capacity < __old_capacity * 2)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__capacity = __old_capacity * 2) >>>>>;
    if (<<cleanup_point *__capacity > std::__cxx11::basic_string<char16_t>::max_size ((struct basic_string *) this)>>)
      {
        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__capacity = std::__cxx11::basic_string<char16_t>::max_size ((struct basic_string *) this)) >>>>>;
      }
  }
<<cleanup_point return <retval> = (char16_t *) std::allocator_traits<std::allocator<char16_t> >::allocate ((struct allocator_type &) std::__cxx11::basic_string<char16_t>::_M_get_allocator ((struct basic_string *) this), *__capacity + 1)>>;


;; Function static void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_S_copy_chars(_CharT*, const _CharT*, const _CharT*) [with _CharT = char16_t; _Traits = std::char_traits<char16_t>; _Alloc = std::allocator<char16_t>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char16_t>::_S_copy (__p, __k1, (size_type) (((long int) __k2 - (long int) __k1) /[ex] 2)) >>>>>
   >>>;


;; Function void __gnu_cxx::new_allocator<_Tp>::deallocate(__gnu_cxx::new_allocator<_Tp>::pointer, __gnu_cxx::new_allocator<_Tp>::size_type) [with _Tp = char16_t; __gnu_cxx::new_allocator<_Tp>::pointer = char16_t*; __gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  operator delete ((void *) __p) >>>>>;


;; Function constexpr _Tp* std::__addressof(_Tp&) [with _Tp = const char16_t] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (const char16_t *) __r
   >>>;


;; Function _Tp* std::addressof(_Tp&) [with _Tp = const char16_t] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::__addressof<const char16_t> (__r)>>
   >>>;


;; Function bool __gnu_cxx::__is_null_pointer(_Type*) [with _Type = const char32_t] (null)
;; enabled by -tree-original


return <retval> = __ptr == 0B;


;; Function constexpr typename std::iterator_traits<_Iterator>::iterator_category std::__iterator_category(const _Iter&) [with _Iter = const char32_t*; typename std::iterator_traits<_Iterator>::iterator_category = std::random_access_iterator_tag] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = TARGET_EXPR <D.45098, {}>>>;


;; Function constexpr typename std::iterator_traits<_Iterator>::difference_type std::__distance(_RandomAccessIterator, _RandomAccessIterator, std::random_access_iterator_tag) [with _RandomAccessIterator = const char32_t*; typename std::iterator_traits<_Iterator>::difference_type = long int] (null)
;; enabled by -tree-original


return <retval> = ((long int) __last - (long int) __first) /[ex] 4;


;; Function typename std::iterator_traits<_Iterator>::difference_type std::distance(_InputIterator, _InputIterator) [with _InputIterator = const char32_t*; typename std::iterator_traits<_Iterator>::difference_type = long int] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = std::__distance<const char32_t*> (__first, __last, TARGET_EXPR <D.45088, TARGET_EXPR <D.45101, {}>>;, <<< Unknown tree: empty_class_expr >>>;)>>;


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_create(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type&, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type) [with _CharT = char32_t; _Traits = std::char_traits<char32_t>; _Alloc = std::allocator<char32_t>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::pointer = char32_t*; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


if (<<cleanup_point *__capacity > std::__cxx11::basic_string<char32_t>::max_size ((struct basic_string *) this)>>)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_length_error ((const char *) "basic_string::_M_create") >>>>>;
  }
if (*__capacity > __old_capacity && *__capacity < __old_capacity * 2)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__capacity = __old_capacity * 2) >>>>>;
    if (<<cleanup_point *__capacity > std::__cxx11::basic_string<char32_t>::max_size ((struct basic_string *) this)>>)
      {
        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (*__capacity = std::__cxx11::basic_string<char32_t>::max_size ((struct basic_string *) this)) >>>>>;
      }
  }
<<cleanup_point return <retval> = (char32_t *) std::allocator_traits<std::allocator<char32_t> >::allocate ((struct allocator_type &) std::__cxx11::basic_string<char32_t>::_M_get_allocator ((struct basic_string *) this), *__capacity + 1)>>;


;; Function static void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_S_copy_chars(_CharT*, const _CharT*, const _CharT*) [with _CharT = char32_t; _Traits = std::char_traits<char32_t>; _Alloc = std::allocator<char32_t>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char32_t>::_S_copy (__p, __k1, (size_type) (((long int) __k2 - (long int) __k1) /[ex] 4)) >>>>>
   >>>;


;; Function void __gnu_cxx::new_allocator<_Tp>::deallocate(__gnu_cxx::new_allocator<_Tp>::pointer, __gnu_cxx::new_allocator<_Tp>::size_type) [with _Tp = char32_t; __gnu_cxx::new_allocator<_Tp>::pointer = char32_t*; __gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  operator delete ((void *) __p) >>>>>;


;; Function constexpr _Tp* std::__addressof(_Tp&) [with _Tp = const char32_t] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (const char32_t *) __r
   >>>;


;; Function _Tp* std::addressof(_Tp&) [with _Tp = const char32_t] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::__addressof<const char32_t> (__r)>>
   >>>;


;; Function static _Tp* std::pointer_traits<_Tp*>::pointer_to(std::__make_not_void<_Tp>&) [with _Tp = const unsigned char; std::pointer_traits<_Tp*>::pointer = const unsigned char*; std::__make_not_void<_Tp> = const unsigned char] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (const unsigned char *) std::addressof<const unsigned char> ((const unsigned char &) __r)>>
   >>>;


;; Function void __gnu_cxx::new_allocator<_Tp>::deallocate(__gnu_cxx::new_allocator<_Tp>::pointer, __gnu_cxx::new_allocator<_Tp>::size_type) [with _Tp = unsigned char; __gnu_cxx::new_allocator<_Tp>::pointer = unsigned char*; __gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  operator delete ((void *) __p) >>>>>;


;; Function __gnu_cxx::new_allocator<_Tp>::new_allocator() [with _Tp = outBuff] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    
  }
   >>>;


;; Function void __gnu_cxx::new_allocator<_Tp>::deallocate(__gnu_cxx::new_allocator<_Tp>::pointer, __gnu_cxx::new_allocator<_Tp>::size_type) [with _Tp = outBuff; __gnu_cxx::new_allocator<_Tp>::pointer = outBuff*; __gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  operator delete ((void *) __p) >>>>>;


;; Function std::_Vector_base<_Tp, _Alloc>::_Vector_impl::_Vector_impl(const _Tp_alloc_type&) [with _Tp = outBuff; _Alloc = std::allocator<outBuff>; std::_Vector_base<_Tp, _Alloc>::_Tp_alloc_type = std::allocator<outBuff>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point <<< Unknown tree: expr_stmt
  *(struct 
  {
    struct outBuff * _M_start;
    struct outBuff * _M_finish;
    struct outBuff * _M_end_of_storage;
  } &) this = {CLOBBER} >>>>>;
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::allocator<outBuff>::allocator ((struct allocator *) this, (const struct allocator &) __a) >>>>>;
    try
      {
        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Vector_impl *) this)->_M_start = 0B) >>>>>;
        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Vector_impl *) this)->_M_finish = 0B) >>>>>;
        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Vector_impl *) this)->_M_end_of_storage = 0B) >>>>>;
      }
    catch
      {
        std::allocator<outBuff>::~allocator ((struct allocator *) this);
      }
  }
   >>>;


;; Function void std::_Vector_base<_Tp, _Alloc>::_M_create_storage(std::size_t) [with _Tp = outBuff; _Alloc = std::allocator<outBuff>; std::size_t = long unsigned int] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Vector_base *) this)->_M_impl._M_start = std::_Vector_base<outBuff, std::allocator<outBuff> >::_M_allocate ((struct _Vector_base *) this, __n)) >>>>>;
<<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Vector_base *) this)->_M_impl._M_finish = ((struct _Vector_base *) this)->_M_impl._M_start) >>>>>;
<<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Vector_base *) this)->_M_impl._M_end_of_storage = ((struct _Vector_base *) this)->_M_impl._M_start + (sizetype) (__n * 40)) >>>>>;


;; Function const _Iterator& __gnu_cxx::__normal_iterator<_Iterator, _Container>::base() const [with _Iterator = outBuff*; _Container = std::vector<outBuff>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct outBuff * const &) &((const struct __normal_iterator *) this)->_M_current
   >>>;


;; Function static _ForwardIterator std::__uninitialized_fill_n<_TrivialValueType>::__uninit_fill_n(_ForwardIterator, _Size, const _Tp&) [with _ForwardIterator = outBuff*; _Size = long unsigned int; _Tp = outBuff; bool _TrivialValueType = false] (null)
;; enabled by -tree-original


{
  struct outBuff * __cur = __first;

    struct outBuff * __cur = __first;
  <<< Unknown tree: try_block
  while (1)
    {
      if (__n == 0) goto <D.45129>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Construct<outBuff, const outBuff&> (std::__addressof<outBuff> ((struct outBuff &) NON_LVALUE_EXPR <__cur>), __x) >>>>>;
      <<cleanup_point (void)  --__n;, (void)  ++__cur;>>;
    }
  <D.45129>:;
  return <retval> = __cur;
  <<< Unknown tree: handler
  
  try
    {
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void) __cxa_begin_catch (__builtin_eh_pointer (0)) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  std::_Destroy<outBuff*> (__first, __cur) >>>>>;
      <<cleanup_point <<< Unknown tree: expr_stmt
  <<< Unknown tree: throw_expr
  __cxa_rethrow () >>> >>>>>;
    }
  finally
    {
      __cxa_end_catch ();
    } >>> >>>;
}


;; Function __gnu_cxx::__ops::_Iter_equals_iter<_Iterator1>::_Iter_equals_iter(_Iterator1) [with _Iterator1 = char*] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  *(struct 
  {
    char * _M_it1;
  } &) this = {CLOBBER} >>>>>;
{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Iter_equals_iter *) this)->_M_it1 = __it1) >>>>>;
}


;; Function _RandomAccessIterator std::__find_if(_RandomAccessIterator, _RandomAccessIterator, _Predicate, std::random_access_iterator_tag) [with _RandomAccessIterator = unsigned char*; _Predicate = __gnu_cxx::__ops::_Iter_equals_iter<char*>] (null)
;; enabled by -tree-original


{
  difference_type __trip_count = (long int) __last - (long int) __first >> 2;

    difference_type __trip_count = (long int) __last - (long int) __first >> 2;
  while (1)
    {
      if (__trip_count <= 0) goto <D.45144>;
      if (<<cleanup_point __gnu_cxx::__ops::_Iter_equals_iter<char*>::operator()<unsigned char*> (&__pred, __first)>>)
        {
          return <retval> = __first;
        }
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void)  ++__first >>>>>;
      if (<<cleanup_point __gnu_cxx::__ops::_Iter_equals_iter<char*>::operator()<unsigned char*> (&__pred, __first)>>)
        {
          return <retval> = __first;
        }
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void)  ++__first >>>>>;
      if (<<cleanup_point __gnu_cxx::__ops::_Iter_equals_iter<char*>::operator()<unsigned char*> (&__pred, __first)>>)
        {
          return <retval> = __first;
        }
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void)  ++__first >>>>>;
      if (<<cleanup_point __gnu_cxx::__ops::_Iter_equals_iter<char*>::operator()<unsigned char*> (&__pred, __first)>>)
        {
          return <retval> = __first;
        }
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void)  ++__first >>>>>;
      <<cleanup_point (void)  --__trip_count>>;
    }
  <D.45144>:;
  switch ((long int) __last - (long int) __first)
    {
      case 3:;
      if (<<cleanup_point __gnu_cxx::__ops::_Iter_equals_iter<char*>::operator()<unsigned char*> (&__pred, __first)>>)
        {
          return <retval> = __first;
        }
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void)  ++__first >>>>>;
      case 2:;
      if (<<cleanup_point __gnu_cxx::__ops::_Iter_equals_iter<char*>::operator()<unsigned char*> (&__pred, __first)>>)
        {
          return <retval> = __first;
        }
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void)  ++__first >>>>>;
      case 1:;
      if (<<cleanup_point __gnu_cxx::__ops::_Iter_equals_iter<char*>::operator()<unsigned char*> (&__pred, __first)>>)
        {
          return <retval> = __first;
        }
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void)  ++__first >>>>>;
      case 0:;
      default:;
      return <retval> = __last;
    }
}


;; Function __gnu_cxx::__ops::_Iter_equals_iter<_Iterator1>::_Iter_equals_iter(_Iterator1) [with _Iterator1 = unsigned char*] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  *(struct 
  {
    unsigned char * _M_it1;
  } &) this = {CLOBBER} >>>>>;
{
  <<cleanup_point <<< Unknown tree: expr_stmt
  (void) (((struct _Iter_equals_iter *) this)->_M_it1 = __it1) >>>>>;
}


;; Function _RandomAccessIterator std::__find_if(_RandomAccessIterator, _RandomAccessIterator, _Predicate, std::random_access_iterator_tag) [with _RandomAccessIterator = unsigned char*; _Predicate = __gnu_cxx::__ops::_Iter_equals_iter<unsigned char*>] (null)
;; enabled by -tree-original


{
  difference_type __trip_count = (long int) __last - (long int) __first >> 2;

    difference_type __trip_count = (long int) __last - (long int) __first >> 2;
  while (1)
    {
      if (__trip_count <= 0) goto <D.45160>;
      if (<<cleanup_point __gnu_cxx::__ops::_Iter_equals_iter<unsigned char*>::operator()<unsigned char*> (&__pred, __first)>>)
        {
          return <retval> = __first;
        }
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void)  ++__first >>>>>;
      if (<<cleanup_point __gnu_cxx::__ops::_Iter_equals_iter<unsigned char*>::operator()<unsigned char*> (&__pred, __first)>>)
        {
          return <retval> = __first;
        }
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void)  ++__first >>>>>;
      if (<<cleanup_point __gnu_cxx::__ops::_Iter_equals_iter<unsigned char*>::operator()<unsigned char*> (&__pred, __first)>>)
        {
          return <retval> = __first;
        }
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void)  ++__first >>>>>;
      if (<<cleanup_point __gnu_cxx::__ops::_Iter_equals_iter<unsigned char*>::operator()<unsigned char*> (&__pred, __first)>>)
        {
          return <retval> = __first;
        }
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void)  ++__first >>>>>;
      <<cleanup_point (void)  --__trip_count>>;
    }
  <D.45160>:;
  switch ((long int) __last - (long int) __first)
    {
      case 3:;
      if (<<cleanup_point __gnu_cxx::__ops::_Iter_equals_iter<unsigned char*>::operator()<unsigned char*> (&__pred, __first)>>)
        {
          return <retval> = __first;
        }
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void)  ++__first >>>>>;
      case 2:;
      if (<<cleanup_point __gnu_cxx::__ops::_Iter_equals_iter<unsigned char*>::operator()<unsigned char*> (&__pred, __first)>>)
        {
          return <retval> = __first;
        }
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void)  ++__first >>>>>;
      case 1:;
      if (<<cleanup_point __gnu_cxx::__ops::_Iter_equals_iter<unsigned char*>::operator()<unsigned char*> (&__pred, __first)>>)
        {
          return <retval> = __first;
        }
      <<cleanup_point <<< Unknown tree: expr_stmt
  (void)  ++__first >>>>>;
      case 0:;
      default:;
      return <retval> = __last;
    }
}


;; Function static std::allocator_traits<std::allocator<_CharT> >::size_type std::allocator_traits<std::allocator<_CharT> >::max_size(const allocator_type&) [with _Tp = char; std::allocator_traits<std::allocator<_CharT> >::size_type = long unsigned int; std::allocator_traits<std::allocator<_CharT> >::allocator_type = std::allocator<char>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = __gnu_cxx::new_allocator<char>::max_size ((const struct new_allocator *) __a)>>
   >>>;


;; Function const allocator_type& std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_get_allocator() const [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::allocator_type = std::allocator<char>] (null)
;; enabled by -tree-original


return <retval> = (const struct allocator_type &) &((const struct basic_string *) this)->_M_dataplus;


;; Function static void std::_Destroy_aux<true>::__destroy(_ForwardIterator, _ForwardIterator) [with _ForwardIterator = outBuff*] (null)
;; enabled by -tree-original





;; Function bool __gnu_cxx::__is_null_pointer(_Type*) [with _Type = char] (null)
;; enabled by -tree-original


return <retval> = __ptr == 0B;


;; Function constexpr typename std::iterator_traits<_Iterator>::iterator_category std::__iterator_category(const _Iter&) [with _Iter = char*; typename std::iterator_traits<_Iterator>::iterator_category = std::random_access_iterator_tag] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = TARGET_EXPR <D.45180, {}>>>;


;; Function constexpr typename std::iterator_traits<_Iterator>::difference_type std::__distance(_RandomAccessIterator, _RandomAccessIterator, std::random_access_iterator_tag) [with _RandomAccessIterator = char*; typename std::iterator_traits<_Iterator>::difference_type = long int] (null)
;; enabled by -tree-original


return <retval> = (long int) __last - (long int) __first;


;; Function typename std::iterator_traits<_Iterator>::difference_type std::distance(_InputIterator, _InputIterator) [with _InputIterator = char*; typename std::iterator_traits<_Iterator>::difference_type = long int] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = std::__distance<char*> (__first, __last, TARGET_EXPR <D.45170, TARGET_EXPR <D.45183, {}>>;, <<< Unknown tree: empty_class_expr >>>;)>>;


;; Function static void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_S_copy_chars(_CharT*, _CharT*, _CharT*) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<char>::_S_copy (__p, (const char *) __k1, (size_type) ((long int) __k2 - (long int) __k1)) >>>>>
   >>>;


;; Function bool __gnu_cxx::__is_null_pointer(_Type*) [with _Type = wchar_t] (null)
;; enabled by -tree-original


return <retval> = __ptr == 0B;


;; Function constexpr typename std::iterator_traits<_Iterator>::iterator_category std::__iterator_category(const _Iter&) [with _Iter = wchar_t*; typename std::iterator_traits<_Iterator>::iterator_category = std::random_access_iterator_tag] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = TARGET_EXPR <D.45199, {}>>>;


;; Function constexpr typename std::iterator_traits<_Iterator>::difference_type std::__distance(_RandomAccessIterator, _RandomAccessIterator, std::random_access_iterator_tag) [with _RandomAccessIterator = wchar_t*; typename std::iterator_traits<_Iterator>::difference_type = long int] (null)
;; enabled by -tree-original


return <retval> = ((long int) __last - (long int) __first) /[ex] 4;


;; Function typename std::iterator_traits<_Iterator>::difference_type std::distance(_InputIterator, _InputIterator) [with _InputIterator = wchar_t*; typename std::iterator_traits<_Iterator>::difference_type = long int] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = std::__distance<wchar_t*> (__first, __last, TARGET_EXPR <D.45189, TARGET_EXPR <D.45202, {}>>;, <<< Unknown tree: empty_class_expr >>>;)>>;


;; Function static void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_S_copy_chars(_CharT*, _CharT*, _CharT*) [with _CharT = wchar_t; _Traits = std::char_traits<wchar_t>; _Alloc = std::allocator<wchar_t>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point <<< Unknown tree: expr_stmt
  std::__cxx11::basic_string<wchar_t>::_S_copy (__p, (const wchar_t *) __k1, (size_type) (((long int) __k2 - (long int) __k1) /[ex] 4)) >>>>>
   >>>;


;; Function static void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_S_copy(_CharT*, const _CharT*, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type) [with _CharT = wchar_t; _Traits = std::char_traits<wchar_t>; _Alloc = std::allocator<wchar_t>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


if (__n == 1)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::char_traits<wchar_t>::assign ((char_type &) NON_LVALUE_EXPR <__d>, (const char_type &) NON_LVALUE_EXPR <__s>) >>>>>;
  }
else
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) std::char_traits<wchar_t>::copy (__d, __s, __n) >>>>>;
  }


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::max_size() const [with _CharT = char16_t; _Traits = std::char_traits<char16_t>; _Alloc = std::allocator<char16_t>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (std::allocator_traits<std::allocator<char16_t> >::max_size ((const struct allocator_type &) std::__cxx11::basic_string<char16_t>::_M_get_allocator ((const struct basic_string *) this)) + 18446744073709551615) / 2>>
   >>>;


;; Function static _Tp* std::allocator_traits<std::allocator<_CharT> >::allocate(std::allocator_traits<std::allocator<_CharT> >::allocator_type&, std::allocator_traits<std::allocator<_CharT> >::size_type) [with _Tp = char16_t; std::allocator_traits<std::allocator<_CharT> >::pointer = char16_t*; std::allocator_traits<std::allocator<_CharT> >::allocator_type = std::allocator<char16_t>; std::allocator_traits<std::allocator<_CharT> >::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = (char16_t *) __gnu_cxx::new_allocator<char16_t>::allocate ((struct new_allocator *) __a, __n, 0B)>>;


;; Function static void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_S_copy(_CharT*, const _CharT*, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type) [with _CharT = char16_t; _Traits = std::char_traits<char16_t>; _Alloc = std::allocator<char16_t>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


if (__n == 1)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::char_traits<char16_t>::assign ((char_type &) NON_LVALUE_EXPR <__d>, (const char_type &) NON_LVALUE_EXPR <__s>) >>>>>;
  }
else
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) std::char_traits<char16_t>::copy (__d, __s, __n) >>>>>;
  }


;; Function std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::max_size() const [with _CharT = char32_t; _Traits = std::char_traits<char32_t>; _Alloc = std::allocator<char32_t>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = (std::allocator_traits<std::allocator<char32_t> >::max_size ((const struct allocator_type &) std::__cxx11::basic_string<char32_t>::_M_get_allocator ((const struct basic_string *) this)) + 18446744073709551615) / 2>>
   >>>;


;; Function static _Tp* std::allocator_traits<std::allocator<_CharT> >::allocate(std::allocator_traits<std::allocator<_CharT> >::allocator_type&, std::allocator_traits<std::allocator<_CharT> >::size_type) [with _Tp = char32_t; std::allocator_traits<std::allocator<_CharT> >::pointer = char32_t*; std::allocator_traits<std::allocator<_CharT> >::allocator_type = std::allocator<char32_t>; std::allocator_traits<std::allocator<_CharT> >::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = (char32_t *) __gnu_cxx::new_allocator<char32_t>::allocate ((struct new_allocator *) __a, __n, 0B)>>;


;; Function static void std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_S_copy(_CharT*, const _CharT*, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type) [with _CharT = char32_t; _Traits = std::char_traits<char32_t>; _Alloc = std::allocator<char32_t>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int] (null)
;; enabled by -tree-original


if (__n == 1)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::char_traits<char32_t>::assign ((char_type &) NON_LVALUE_EXPR <__d>, (const char_type &) NON_LVALUE_EXPR <__s>) >>>>>;
  }
else
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  (void) std::char_traits<char32_t>::copy (__d, __s, __n) >>>>>;
  }


;; Function constexpr _Tp* std::__addressof(_Tp&) [with _Tp = const unsigned char] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (const unsigned char *) __r
   >>>;


;; Function _Tp* std::addressof(_Tp&) [with _Tp = const unsigned char] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = std::__addressof<const unsigned char> (__r)>>
   >>>;


;; Function std::allocator< <template-parameter-1-1> >::allocator(const std::allocator< <template-parameter-1-1> >&) [with _Tp = outBuff] (null)
;; enabled by -tree-original


<<< Unknown tree: eh_spec_block
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  __gnu_cxx::new_allocator<outBuff>::new_allocator ((struct new_allocator *) this, (const struct new_allocator &) __a) >>>>>;
    try
      {
        
      }
    catch
      {
        __gnu_cxx::new_allocator<outBuff>::~new_allocator ((struct new_allocator *) this);
      }
  }
   >>>;


;; Function std::_Vector_base<_Tp, _Alloc>::pointer std::_Vector_base<_Tp, _Alloc>::_M_allocate(std::size_t) [with _Tp = outBuff; _Alloc = std::allocator<outBuff>; std::_Vector_base<_Tp, _Alloc>::pointer = outBuff*; std::size_t = long unsigned int] (null)
;; enabled by -tree-original


{
  typedef struct _Tr _Tr;

  <<cleanup_point return <retval> = __n != 0 ? (struct outBuff *) std::allocator_traits<std::allocator<outBuff> >::allocate ((struct allocator_type &) &((struct _Vector_base *) this)->_M_impl, __n) : 0B>>;
}


;; Function constexpr _Tp* std::__addressof(_Tp&) [with _Tp = outBuff] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (struct outBuff *) __r
   >>>;


;; Function constexpr _Tp&& std::forward(typename std::remove_reference<_From>::type&) [with _Tp = const outBuff&; typename std::remove_reference<_From>::type = const outBuff] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = (const struct outBuff &) __t
   >>>;


;; Function void std::_Construct(_T1*, _Args&& ...) [with _T1 = outBuff; _Args = {const outBuff&}] (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  (void) (TARGET_EXPR <D.45258, (const struct outBuff *) std::forward<const outBuff&> ((const struct type &) __args#0)>;, TARGET_EXPR <D.45255, (void *) __p>;, TARGET_EXPR <D.45256, operator new (40, NON_LVALUE_EXPR <D.45255>)>;;, (struct outBuff *) D.45256 != 0B ? try
    {
      *(struct outBuff *) D.45256 = *D.45258;
    }
  catch
    {
      operator delete (D.45256, NON_LVALUE_EXPR <D.45255>);
    }, (struct outBuff *) D.45256; : (struct outBuff *) D.45256;) >>>>>;


;; Function bool __gnu_cxx::__ops::_Iter_equals_iter<_Iterator1>::operator()(_Iterator2) [with _Iterator2 = unsigned char*; _Iterator1 = char*] (null)
;; enabled by -tree-original


return <retval> = (int) *__it2 == (int) *((struct _Iter_equals_iter *) this)->_M_it1;


;; Function bool __gnu_cxx::__ops::_Iter_equals_iter<_Iterator1>::operator()(_Iterator2) [with _Iterator2 = unsigned char*; _Iterator1 = unsigned char*] (null)
;; enabled by -tree-original


return <retval> = *__it2 == *((struct _Iter_equals_iter *) this)->_M_it1;


;; Function __gnu_cxx::new_allocator<_Tp>::size_type __gnu_cxx::new_allocator<_Tp>::max_size() const [with _Tp = char; __gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 18446744073709551615
   >>>;


;; Function static std::allocator_traits<std::allocator<_CharT> >::size_type std::allocator_traits<std::allocator<_CharT> >::max_size(const allocator_type&) [with _Tp = char16_t; std::allocator_traits<std::allocator<_CharT> >::size_type = long unsigned int; std::allocator_traits<std::allocator<_CharT> >::allocator_type = std::allocator<char16_t>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = __gnu_cxx::new_allocator<char16_t>::max_size ((const struct new_allocator *) __a)>>
   >>>;


;; Function const allocator_type& std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_get_allocator() const [with _CharT = char16_t; _Traits = std::char_traits<char16_t>; _Alloc = std::allocator<char16_t>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::allocator_type = std::allocator<char16_t>] (null)
;; enabled by -tree-original


return <retval> = (const struct allocator_type &) &((const struct basic_string *) this)->_M_dataplus;


;; Function _Tp* __gnu_cxx::new_allocator<_Tp>::allocate(__gnu_cxx::new_allocator<_Tp>::size_type, const void*) [with _Tp = char16_t; __gnu_cxx::new_allocator<_Tp>::pointer = char16_t*; __gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int] (null)
;; enabled by -tree-original


if (<<cleanup_point __gnu_cxx::new_allocator<char16_t>::max_size ((struct new_allocator *) this) < __n>>)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_bad_alloc () >>>>>;
  }
<<cleanup_point return <retval> = (char16_t *) operator new (__n * 2)>>;


;; Function static std::allocator_traits<std::allocator<_CharT> >::size_type std::allocator_traits<std::allocator<_CharT> >::max_size(const allocator_type&) [with _Tp = char32_t; std::allocator_traits<std::allocator<_CharT> >::size_type = long unsigned int; std::allocator_traits<std::allocator<_CharT> >::allocator_type = std::allocator<char32_t>] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  <<cleanup_point return <retval> = __gnu_cxx::new_allocator<char32_t>::max_size ((const struct new_allocator *) __a)>>
   >>>;


;; Function const allocator_type& std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::_M_get_allocator() const [with _CharT = char32_t; _Traits = std::char_traits<char32_t>; _Alloc = std::allocator<char32_t>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::allocator_type = std::allocator<char32_t>] (null)
;; enabled by -tree-original


return <retval> = (const struct allocator_type &) &((const struct basic_string *) this)->_M_dataplus;


;; Function _Tp* __gnu_cxx::new_allocator<_Tp>::allocate(__gnu_cxx::new_allocator<_Tp>::size_type, const void*) [with _Tp = char32_t; __gnu_cxx::new_allocator<_Tp>::pointer = char32_t*; __gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int] (null)
;; enabled by -tree-original


if (<<cleanup_point __gnu_cxx::new_allocator<char32_t>::max_size ((struct new_allocator *) this) < __n>>)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_bad_alloc () >>>>>;
  }
<<cleanup_point return <retval> = (char32_t *) operator new (__n * 4)>>;


;; Function __gnu_cxx::new_allocator<_Tp>::new_allocator(const __gnu_cxx::new_allocator<_Tp>&) [with _Tp = outBuff] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  {
    
  }
   >>>;


;; Function static _Tp* std::allocator_traits<std::allocator<_CharT> >::allocate(std::allocator_traits<std::allocator<_CharT> >::allocator_type&, std::allocator_traits<std::allocator<_CharT> >::size_type) [with _Tp = outBuff; std::allocator_traits<std::allocator<_CharT> >::pointer = outBuff*; std::allocator_traits<std::allocator<_CharT> >::allocator_type = std::allocator<outBuff>; std::allocator_traits<std::allocator<_CharT> >::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<cleanup_point return <retval> = (struct outBuff *) __gnu_cxx::new_allocator<outBuff>::allocate ((struct new_allocator *) __a, __n, 0B)>>;


;; Function __gnu_cxx::new_allocator<_Tp>::size_type __gnu_cxx::new_allocator<_Tp>::max_size() const [with _Tp = char16_t; __gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 9223372036854775807
   >>>;


;; Function __gnu_cxx::new_allocator<_Tp>::size_type __gnu_cxx::new_allocator<_Tp>::max_size() const [with _Tp = char32_t; __gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 4611686018427387903
   >>>;


;; Function _Tp* __gnu_cxx::new_allocator<_Tp>::allocate(__gnu_cxx::new_allocator<_Tp>::size_type, const void*) [with _Tp = outBuff; __gnu_cxx::new_allocator<_Tp>::pointer = outBuff*; __gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int] (null)
;; enabled by -tree-original


if (<<cleanup_point __gnu_cxx::new_allocator<outBuff>::max_size ((struct new_allocator *) this) < __n>>)
  {
    <<cleanup_point <<< Unknown tree: expr_stmt
  std::__throw_bad_alloc () >>>>>;
  }
<<cleanup_point return <retval> = (struct outBuff *) operator new (__n * 40)>>;


;; Function __gnu_cxx::new_allocator<_Tp>::size_type __gnu_cxx::new_allocator<_Tp>::max_size() const [with _Tp = outBuff; __gnu_cxx::new_allocator<_Tp>::size_type = long unsigned int] (null)
;; enabled by -tree-original


<<< Unknown tree: must_not_throw_expr
  return <retval> = 461168601842738790
   >>>;


;; Function void __static_initialization_and_destruction_0(int, int) (null)
;; enabled by -tree-original


if (__initialize_p == 1)
  {
    if (__priority == 65535)
      {
        <<cleanup_point <<< Unknown tree: expr_stmt
  std::vector<outBuff>::vector (&OutputBuffer) >>>>>;
        <<cleanup_point <<< Unknown tree: expr_stmt
  (void) __cxa_atexit ((void (*<Tf2>) (void *)) __comp_dtor , (void *) &OutputBuffer, (void *) &__dso_handle) >>>>>;
      }
  }


;; Function (static initializers for pbzip2.cpp) (null)
;; enabled by -tree-original


<<cleanup_point <<< Unknown tree: expr_stmt
  __static_initialization_and_destruction_0 (1, 65535) >>>>>;

