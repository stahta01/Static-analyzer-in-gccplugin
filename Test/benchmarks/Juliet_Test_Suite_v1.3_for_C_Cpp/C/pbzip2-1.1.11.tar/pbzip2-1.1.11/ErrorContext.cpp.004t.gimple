static pbzip2::ErrorContext* pbzip2::ErrorContext::getInstance() ()
{
  void * D.26670;
  struct ErrorContext * iftmp.1;
  struct ErrorContext * D.30394;

  pthread_mutex_lock (&_err_ctx_mutex);
  _instance.0_1 = _instance;
  if (_instance.0_1 == 0B) goto <D.30384>; else goto <D.30385>;
  <D.30384>:
  D.26670 = operator new (8, &nothrow);
  if (D.26670 != 0B) goto <D.30387>; else goto <D.30388>;
  <D.30387>:
  try
    {
      pbzip2::ErrorContext::ErrorContext (D.26670);
    }
  catch
    {
      operator delete (D.26670, &nothrow);
    }
  iftmp.1 = D.26670;
  goto <D.30389>;
  <D.30388>:
  iftmp.1 = D.26670;
  <D.30389>:
  _instance = iftmp.1;
  _instance.2_2 = _instance;
  if (_instance.2_2 == 0B) goto <D.30390>; else goto <D.30391>;
  <D.30390>:
  stderr.3_3 = stderr;
  fprintf (stderr.3_3, "pbzip2: *ERROR: Can\'t initialize error context - out of memory!\n");
  goto <D.30392>;
  <D.30391>:
  <D.30392>:
  goto <D.30393>;
  <D.30385>:
  <D.30393>:
  pthread_mutex_unlock (&_err_ctx_mutex);
  D.30394 = _instance;
  return D.30394;
}


pbzip2::ErrorContext::ErrorContext() (struct ErrorContext * const this)
{
  MEM[(struct  &)this] = {CLOBBER};
  {
    this->_first_kernel_err_no = 0;
    this->_last_kernel_err_no = 0;
  }
}


__attribute__((__artificial__, __gnu_inline__, __always_inline__))
int fprintf(FILE*, const char*, ...) (struct FILE * restrict __stream, const char * restrict __fmt)
{
  int D.30396;

  D.30396 = __fprintf_chk (__stream, 1, __fmt, __builtin_va_arg_pack ());
  return D.30396;
}


static void pbzip2::ErrorContext::printErrnoMsg(FILE*, int) (struct FILE * out, int err)
{
  if (err != 0) goto <D.30399>; else goto <D.30400>;
  <D.30399>:
  _1 = strerror (err);
  fprintf (out, "pbzip2: *ERROR: system call failed with errno=[%d: %s]!\n", err, _1);
  goto <D.30401>;
  <D.30400>:
  <D.30401>:
}


static void pbzip2::ErrorContext::syncPrintErrnoMsg(FILE*, int) (struct FILE * out, int err)
{
  pthread_mutex_lock (&_err_ctx_mutex);
  pbzip2::ErrorContext::printErrnoMsg (out, err);
  pthread_mutex_unlock (&_err_ctx_mutex);
}


void pbzip2::ErrorContext::printErrorMessages(FILE*) (struct ErrorContext * const this, struct FILE * out)
{
  pthread_mutex_lock (&_err_ctx_mutex);
  _1 = this->_first_kernel_err_no;
  pbzip2::ErrorContext::printErrnoMsg (out, _1);
  _2 = this->_last_kernel_err_no;
  pbzip2::ErrorContext::printErrnoMsg (out, _2);
  pthread_mutex_unlock (&_err_ctx_mutex);
}


void pbzip2::ErrorContext::saveError() (struct ErrorContext * const this)
{
  int * iftmp.4;
  int newerr;

  _1 = __errno_location ();
  newerr = *_1;
  pthread_mutex_lock (&_err_ctx_mutex);
  {
    if (newerr != 0) goto <D.30402>; else goto <D.30403>;
    <D.30402>:
    {
      int & err_ref;

      _2 = this->_first_kernel_err_no;
      if (_2 == 0) goto <D.30405>; else goto <D.30406>;
      <D.30405>:
      iftmp.4 = &this->_first_kernel_err_no;
      goto <D.30407>;
      <D.30406>:
      iftmp.4 = &this->_last_kernel_err_no;
      <D.30407>:
      err_ref = iftmp.4;
      *err_ref = newerr;
    }
    goto <D.30408>;
    <D.30403>:
    <D.30408>:
  }
  _3 = __errno_location ();
  _4 = *_3;
  this->_last_kernel_err_no = _4;
  pthread_mutex_unlock (&_err_ctx_mutex);
}


void pbzip2::ErrorContext::reset() (struct ErrorContext * const this)
{
  pthread_mutex_lock (&_err_ctx_mutex);
  this->_last_kernel_err_no = 0;
  _1 = this->_last_kernel_err_no;
  this->_first_kernel_err_no = _1;
  pthread_mutex_unlock (&_err_ctx_mutex);
}


