./benchmarks/binutils/leak_7/binutils_leak_7.c: In function â€˜ldirnameâ€™:
./benchmarks/binutils/leak_7/binutils_leak_7.c:44:3: warning: implicit declaration of function â€˜memcpyâ€™ [-Wimplicit-function-declaration]
   44 |   memcpy (dirname, filename, base - filename);
      |   ^~~~~~
./benchmarks/binutils/leak_7/binutils_leak_7.c:9:1: note: include â€˜<string.h>â€™ or provide a declaration of â€˜memcpyâ€™
    8 | #include "../include/binutils.h"
  +++ |+#include <string.h>
    9 | 
./benchmarks/binutils/leak_7/binutils_leak_7.c:44:3: warning: incompatible implicit declaration of built-in function â€˜memcpyâ€™ [-Wbuiltin-declaration-mismatch]
   44 |   memcpy (dirname, filename, base - filename);
      |   ^~~~~~
./benchmarks/binutils/leak_7/binutils_leak_7.c:44:3: note: include â€˜<string.h>â€™ or provide a declaration of â€˜memcpyâ€™
./benchmarks/binutils/leak_7/binutils_leak_7.c: In function â€˜vconcat_copyâ€™:
./benchmarks/binutils/leak_7/binutils_leak_7.c:61:32: warning: implicit declaration of function â€˜strlenâ€™ [-Wimplicit-function-declaration]
   61 |         unsigned long length = strlen (arg);
      |                                ^~~~~~
./benchmarks/binutils/leak_7/binutils_leak_7.c:61:32: note: include â€˜<string.h>â€™ or provide a declaration of â€˜strlenâ€™
./benchmarks/binutils/leak_7/binutils_leak_7.c:61:32: warning: incompatible implicit declaration of built-in function â€˜strlenâ€™ [-Wbuiltin-declaration-mismatch]
./benchmarks/binutils/leak_7/binutils_leak_7.c:61:32: note: include â€˜<string.h>â€™ or provide a declaration of â€˜strlenâ€™
./benchmarks/binutils/leak_7/binutils_leak_7.c:62:9: warning: incompatible implicit declaration of built-in function â€˜memcpyâ€™ [-Wbuiltin-declaration-mismatch]
   62 |         memcpy (end, arg, length);
      |         ^~~~~~
./benchmarks/binutils/leak_7/binutils_leak_7.c:62:9: note: include â€˜<string.h>â€™ or provide a declaration of â€˜memcpyâ€™
In file included from ./benchmarks/binutils/leak_7/binutils_leak_7.c:7:
./benchmarks/binutils/leak_7/binutils_leak_7.c: In function â€˜do_start_initializationâ€™:
./benchmarks/binutils/leak_7/../include/common.h:22:20: warning: implicit declaration of function â€˜strdupâ€™ [-Wimplicit-function-declaration]
   22 | #define xstrdup(a) strdup(a)
      |                    ^~~~~~
./benchmarks/binutils/leak_7/binutils_leak_7.c:110:12: note: in expansion of macro â€˜xstrdupâ€™
  110 |   oldloc = xstrdup (setlocale (LC_ALL, NULL));
      |            ^~~~~~~
./benchmarks/binutils/leak_7/../include/common.h:22:20: warning: incompatible implicit declaration of built-in function â€˜strdupâ€™ [-Wbuiltin-declaration-mismatch]
   22 | #define xstrdup(a) strdup(a)
      |                    ^~~~~~
./benchmarks/binutils/leak_7/binutils_leak_7.c:110:12: note: in expansion of macro â€˜xstrdupâ€™
  110 |   oldloc = xstrdup (setlocale (LC_ALL, NULL));
      |            ^~~~~~~
./benchmarks/binutils/leak_7/binutils_leak_7.c:110:21: warning: implicit declaration of function â€˜setlocaleâ€™ [-Wimplicit-function-declaration]
  110 |   oldloc = xstrdup (setlocale (LC_ALL, NULL));
      |                     ^~~~~~~~~
./benchmarks/binutils/leak_7/../include/common.h:22:27: note: in definition of macro â€˜xstrdupâ€™
   22 | #define xstrdup(a) strdup(a)
      |                           ^
./benchmarks/binutils/leak_7/binutils_leak_7.c:110:21: warning: passing argument 1 of â€˜strdupâ€™ makes pointer from integer without a cast [-Wint-conversion]
  110 |   oldloc = xstrdup (setlocale (LC_ALL, NULL));
      |                     ^~~~~~~~~~~~~~~~~~~~~~~~
      |                     |
      |                     int
./benchmarks/binutils/leak_7/../include/common.h:22:27: note: in definition of macro â€˜xstrdupâ€™
   22 | #define xstrdup(a) strdup(a)
      |                           ^
./benchmarks/binutils/leak_7/binutils_leak_7.c:110:21: note: expected â€˜const char *â€™ but argument is of type â€˜intâ€™
  110 |   oldloc = xstrdup (setlocale (LC_ALL, NULL));
      |                     ^~~~~~~~~~~~~~~~~~~~~~~~
./benchmarks/binutils/leak_7/../include/common.h:22:27: note: in definition of macro â€˜xstrdupâ€™
   22 | #define xstrdup(a) strdup(a)
      |                           ^
./benchmarks/binutils/leak_7/binutils_leak_7.c:112:14: warning: incompatible implicit declaration of built-in function â€˜strlenâ€™ [-Wbuiltin-declaration-mismatch]
  112 |   progsize = strlen (progname);
      |              ^~~~~~
./benchmarks/binutils/leak_7/binutils_leak_7.c:112:14: note: include â€˜<string.h>â€™ or provide a declaration of â€˜strlenâ€™
Profile consistency report:

                                 |mismatch     |mismatch     |                     |
Pass name                        |IN    |IN    |OUT   |OUT   |overall              |
                                 |freq  |count |freq  |count |size      |time      |
cfg                  ------------|      |      |      |      |          |          |
ompexp                           |      |      |      |      |   +100.0%|          |
fixup_cfg            ------------|      |      |      |      |          |          |
ssa                              |      |      |      |      |     -2.5%|          |
nothrow                          |      |      |      |      |     -2.6%|          |
fixup_cfg            ------------|      |      |      |      |          |          |
local-fnsummary      ------------|      |      |      |      |          |          |
einline              ------------|      |      |      |      |          |          |
early_optimizations  ------------|      |      |      |      |          |          |
objsz                ------------|      |      |      |      |          |          |
ccp                              |      |      |      |      |     -0.2%|          |
forwprop                         |      |      |      |      |     -0.4%|          |
ethread                          |      |      |      |      |     -0.2%|          |
esra                 ------------|      |      |      |      |          |          |
ealias               ------------|      |      |      |      |          |          |
mergephi             ------------|      |      |      |      |          |          |
cddce                ------------|      |      |      |      |          |          |
phiopt               ------------|      |      |      |      |          |          |
modref               ------------|      |      |      |      |          |          |
iftoswitch           ------------|      |      |      |      |          |          |
profile_estimate     ------------|      |      |      |      |          |          |
local-pure-const                 |      |      |      |      |          |   +100.0%|
release_ssa          ------------|      |      |      |      |          |          |
local-fnsummary      ------------|      |      |      |      |          |          |
=======ipa_pta=========
===============The first stage : Point of interest stmt collect=================
=======node_fun:main=========
=======node_fun:do_start_initialization=========
--------GIMPLE Cond -------
--------GIMPLE Cond -------
=======node_fun:Py_SetProgramName=========
=======node_fun:PyMem_Malloc=========
=======node_fun:concat=========
=======node_fun:vconcat_copy=========
=======node_fun:ldirname=========
--------GIMPLE Cond -------
--------GIMPLE Cond -------
--------GIMPLE Cond -------
--------GIMPLE Cond -------
--------GIMPLE Cond -------
--------GIMPLE Cond -------
=======node_fun:lbasename=========
=======node_fun:unix_lbasename=========
--------GIMPLE Cond -------
===============The first stage : Point of interest stmt collect=================
start PointerConstraint
pointer ftable is 1 
pointer ptable is 1 
===============The second stage : Mapping stmt=================
# .MEM_2 = VDEF <.MEM_1(D)>
do_start_initialization ();
# .MEM_3 = VDEF <.MEM_2>
concat ("dummy", "");
# .MEM_4 = VDEF <.MEM_3>
printf ("%d\n", 1835890020);
# .MEM_40 = VDEF <.MEM_39(D)>
_2 = ldirname (_1);
# .MEM_41 = VDEF <.MEM_40>
progname_16 = concat (_2, "bin");
# .MEM_42 = VDEF <.MEM_41>
_3 = setlocale ("LC_ALL", 0B);
# .MEM_43 = VDEF <.MEM_42>
oldloc_19 = strdup (_5);
# .MEM_44 = VDEF <.MEM_43>
setlocale ("LC_ALL", "");
# VUSE <.MEM_44>
progsize_21 = strlen (progname_16);
# .MEM_45 = VDEF <.MEM_44>
progname_copy_23 = PyMem_Malloc (_7);
# .MEM_55 = VDEF <.MEM_54>
__builtin_fwrite ("out of memory\n", 1, 14, _8);
# .MEM_46 = VDEF <.MEM_45>
count_25 = mbstowcs (progname_copy_23, progname_16, _9);
# .MEM_53 = VDEF <.MEM_52>
__builtin_fwrite ("Could not convert python path to string\n", 1, 40, _10);
# .MEM_47 = VDEF <.MEM_46>
setlocale ("LC_ALL", oldloc_19);
# .MEM_49 = VDEF <.MEM_48>
Py_SetProgramName (progname_copy_23);
# .MEM_5 = VDEF <.MEM_4(D)>
printf ("%d\n", _1);
# .MEM_6 = VDEF <.MEM_5(D)>
ret_4 = malloc (size_2(D));
# .MEM_7 = VDEF <.MEM_6(D)>
newstr_3 = malloc (1);
# .MEM_8 = VDEF <.MEM_7>
vconcat_copy (newstr_3, first_4(D), arg_5(D));
# VUSE <.MEM_7(D)>
length_4 = strlen (arg_3(D));
# .MEM_8 = VDEF <.MEM_7(D)>
memcpy (dst_1(D), arg_3(D), length_4);
# VUSE <.MEM_31(D)>
base_23 = lbasename (filename_22(D));
# .MEM_32 = VDEF <.MEM_31(D)>
dirname_26 = malloc (_4);
# .MEM_33 = VDEF <.MEM_32>
memcpy (dirname_26, filename_22(D), _6);
# VUSE <.MEM_4(D)>
_3 = unix_lbasename (name_2(D));
start collect similar stmtstart collect similar stmtstart collect similar stmtstart collect similar stmt
start collect similar stmtstart collect similar stmtstart collect similar stmtstart collect similar stmt
start collect similar stmtstart collect similar stmtstart collect similar stmtstart collect similar stmt
start collect similar stmtstart collect similar stmtstart collect similar stmtstart collect similar stmt
start collect similar stmtstart collect similar stmtstart collect similar stmtstart collect similar stmt
===============The second stage : build fucntion type=================
[40;41mSTART CHECKSTART CHECKSTART CHECKSTART CHECKSTART CHECK[0m
[40;41mSTART CHECKSTART CHECKSTART CHECKSTART CHECKSTART CHECK[0m
    =()=
 ,/'_||_
  (___  `.
 ./  `=='
      |||
      |||
      |||
      |||
[40;41mSTART CHECKSTART CHECKSTART CHECKSTART CHECKSTART CHECK[0m
[40;41mSTART CHECKSTART CHECKSTART CHECKSTART CHECKSTART CHECK[0m
===============The second stage : record fucntion =================

=============== The third stage : Start detection  =================
[40;44m =======node_fun:main========= [0m
[40;44m fucntion collect path  [0m
[40;44m =======print_function_path main  function_call count: 3 level :0========  [0m
[40;44m =======print_function_type 0  ========  [0m
[40;42m =======pre add _ fucntion:printf========= [0m
[40;33m =======POP node_fun stack:printf========= [0m
[40;42m =======pre add _ fucntion:concat========= [0m
[40;44m =======print_function_type 2  ========  [0m
[40;44m =======print_function_path concat  function_call count: 2 level :1========  [0m
[40;44m =======print_function_type 2  ========  [0m
[40;42m =======pre add _ fucntion:vconcat_copy========= [0m
[40;44m =======print_function_type 0  ========  [0m
[40;44m =======print_function_path vconcat_copy  function_call count: 2 level :2========  [0m
[40;44m =======print_function_type 0  ========  [0m
[40;42m =======pre add _ fucntion:memcpy========= [0m
[40;33m =======POP node_fun stack:memcpy========= [0m
[40;42m =======pre add _ fucntion:strlen========= [0m
[40;33m =======POP node_fun stack:strlen========= [0m
[40;42m =======pre_check_funciton:vconcat_copy========= [0m
[40;42m =======start_check_funciton:vconcat_copy========= [0m

dot graph START

======================================================================
 <ssa_name 0x7fe1771d5678
    type <pointer_type 0x7fe1771b5b28
        type <integer_type 0x7fe1771b5a80 char readonly public QI
            size <integer_cst 0x7fe17768cca8 constant 8>
            unit-size <integer_cst 0x7fe17768ccc0 constant 1>
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7fe1776a13f0 precision:8 min <integer_cst 0x7fe1771ac720 -128> max <integer_cst 0x7fe1771ac708 127>
            pointer_to_this <pointer_type 0x7fe1771b5b28>>
        public unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
    var <parm_decl 0x7fe1771c5580 arg>
    def_stmt GIMPLE_NOP
    version:3
    ptr-info 0x7fe1771ca8e8>
GIMPLE_NOP

 ================== trace ptable================== 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr--------
this other function -----------
 
 Start check Pointer Collect  

======================================================================
length_4 = strlen (arg_3(D));
In function â€˜mainâ€™:
./benchmarks/binutils/leak_7/binutils_leak_7.c:61:32: warning: use location
   61 |         unsigned long length = strlen (arg);
      |                                ^
this stmt is child function---strlen-----

 ================== trace ================== 
trace fucntion name:strlen 

 ================== trace ================== 
trace fucntion free:0 
end_6 = dst_1(D) + length_4;
./benchmarks/binutils/leak_7/binutils_leak_7.c:63:13: warning: use location
   63 |         end += length;
      |             ^
*end_6 = 0;
./benchmarks/binutils/leak_7/binutils_leak_7.c:65:14: warning: use location
   65 |         *end = '\000';
      |              ^
memcpy (dst_1(D), arg_3(D), length_4);
./benchmarks/binutils/leak_7/binutils_leak_7.c:62:9: warning: use location
   62 |         memcpy (end, arg, length);
      |         ^
this stmt is child function---memcpy-----

 ================== trace ================== 
trace fucntion name:memcpy 

 ================== trace ================== 
trace fucntion free:0 

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7fe1771d5678
    type <pointer_type 0x7fe1771b5b28
        type <integer_type 0x7fe1771b5a80 char readonly public QI
            size <integer_cst 0x7fe17768cca8 constant 8>
            unit-size <integer_cst 0x7fe17768ccc0 constant 1>
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7fe1776a13f0 precision:8 min <integer_cst 0x7fe1771ac720 -128> max <integer_cst 0x7fe1771ac708 127>
            pointer_to_this <pointer_type 0x7fe1771b5b28>>
        public unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
    var <parm_decl 0x7fe1771c5580 arg>
    def_stmt GIMPLE_NOP
    version:3
    ptr-info 0x7fe1771ca8e8>

 ================== Start Use after free Check ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:0 [0m
[40;31m  	free count:0 [0m

======================================================================

======================================================================
[40;31m    no free stmt possible memory leak [0m

======================================================================

dot graph START

======================================================================
 <ssa_name 0x7fe1771d5630
    type <pointer_type 0x7fe1771b5c78
        type <integer_type 0x7fe1771b59d8 char public QI
            size <integer_cst 0x7fe17768cca8 constant 8>
            unit-size <integer_cst 0x7fe17768ccc0 constant 1>
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7fe1776a13f0 precision:8 min <integer_cst 0x7fe1771ac720 -128> max <integer_cst 0x7fe1771ac708 127>
            pointer_to_this <pointer_type 0x7fe1771b5c78>>
        public unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality context <translation_unit_decl 0x7fe177697168 ./benchmarks/binutils/leak_7/binutils_leak_7.c>
        pointer_to_this <pointer_type 0x7fe1771bfbd0>>
    var <parm_decl 0x7fe1771c5480 dst>
    def_stmt GIMPLE_NOP
    version:1
    ptr-info 0x7fe1771ca8d0>
GIMPLE_NOP

 ================== trace ptable================== 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr--------
this other function -----------
 
 Start check Pointer Collect  

======================================================================
return dst_1(D);
./benchmarks/binutils/leak_7/binutils_leak_7.c:67:16: warning: use location
   67 |         return dst;
      |                ^
end_6 = dst_1(D) + length_4;
./benchmarks/binutils/leak_7/binutils_leak_7.c:63:13: warning: use location
   63 |         end += length;
      |             ^
*end_6 = 0;
./benchmarks/binutils/leak_7/binutils_leak_7.c:65:14: warning: use location
   65 |         *end = '\000';
      |              ^
# .MEM_8 = VDEF <.MEM_7(D)>
memcpy (dst_1(D), arg_3(D), length_4);
memcpy (dst_1(D), arg_3(D), length_4);
./benchmarks/binutils/leak_7/binutils_leak_7.c:62:9: warning: use location
   62 |         memcpy (end, arg, length);
      |         ^
this stmt is child function---memcpy-----

 ================== trace ================== 
trace fucntion name:memcpy 

 ================== trace ================== 
trace fucntion free:0 
# .MEM_8 = VDEF <.MEM_7(D)>
memcpy (dst_1(D), arg_3(D), length_4);
memcpy (dst_1(D), arg_3(D), length_4);
./benchmarks/binutils/leak_7/binutils_leak_7.c:62:9: warning: use location
this stmt is child function---memcpy-----

 ================== trace ================== 
trace fucntion name:memcpy 

 ================== trace ================== 
trace fucntion free:0 

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7fe1771d5630
    type <pointer_type 0x7fe1771b5c78
        type <integer_type 0x7fe1771b59d8 char public QI
            size <integer_cst 0x7fe17768cca8 constant 8>
            unit-size <integer_cst 0x7fe17768ccc0 constant 1>
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7fe1776a13f0 precision:8 min <integer_cst 0x7fe1771ac720 -128> max <integer_cst 0x7fe1771ac708 127>
            pointer_to_this <pointer_type 0x7fe1771b5c78>>
        public unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality context <translation_unit_decl 0x7fe177697168 ./benchmarks/binutils/leak_7/binutils_leak_7.c>
        pointer_to_this <pointer_type 0x7fe1771bfbd0>>
    var <parm_decl 0x7fe1771c5480 dst>
    def_stmt GIMPLE_NOP
    version:1
    ptr-info 0x7fe1771ca8d0>

 ================== Start Use after free Check ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:0 [0m
[40;31m  	free count:0 [0m

======================================================================

======================================================================
[40;31m    no free stmt possible memory leak [0m

======================================================================
[40;33m =======POP node_fun stack:vconcat_copy========= [0m
[40;42m =======pre add _ fucntion:malloc========= [0m
[40;33m =======POP node_fun stack:malloc========= [0m
[40;42m =======pre_check_funciton:concat========= [0m
[40;42m =======start_check_funciton:concat========= [0m

dot graph START

======================================================================
 <ssa_name 0x7fe1771d5438
    type <pointer_type 0x7fe1771b5c78
        type <integer_type 0x7fe1771b59d8 char public QI
            size <integer_cst 0x7fe17768cca8 constant 8>
            unit-size <integer_cst 0x7fe17768ccc0 constant 1>
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7fe1776a13f0 precision:8 min <integer_cst 0x7fe1771ac720 -128> max <integer_cst 0x7fe1771ac708 127>
            pointer_to_this <pointer_type 0x7fe1771b5c78>>
        public unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality context <translation_unit_decl 0x7fe177697168 ./benchmarks/binutils/leak_7/binutils_leak_7.c>
        pointer_to_this <pointer_type 0x7fe1771bfbd0>>
    var <var_decl 0x7fe1771cff30 newstr>
    def_stmt newstr_3 = malloc (1);
    version:3
    ptr-info 0x7fe1771ca888>
# .MEM_7 = VDEF <.MEM_6(D)>
newstr_3 = malloc (1);

 ================== trace ptable================== 
trace fucntion name:malloc 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr---malloc-----
this Reserved word function ------malloc-----
 
 Start check Pointer Collect  

======================================================================
return newstr_3;
./benchmarks/binutils/leak_7/binutils_leak_7.c:81:10: warning: use location
   81 |   return newstr;
      |          ^
vconcat_copy (newstr_3, first_4(D), arg_5(D));
./benchmarks/binutils/leak_7/binutils_leak_7.c:79:3: warning: use location
   79 |   vconcat_copy (newstr, first, arg);
      |   ^
this stmt is child function---vconcat_copy-----

 ================== trace ================== 
trace fucntion name:vconcat_copy 
[40;44m =======trace_function_path vconcat_copy  function_call count: 2 level :0========  [0m
[40;36m ======= node_fun:vconcat_copy========= [0m
[40;36m ======= find relate stmt with newstr ========= [0m
[40;36m ======= relate stmt argument:newstr ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:memcpy========= [0m
[40;46m =======add node_fun stack:memcpy========= [0m
[40;42m =======pre add _ fucntion:strlen========= [0m
[40;46m =======add node_fun stack:strlen========= [0m

 ================== trace ================== 
trace fucntion free:0 
newstr_3 = malloc (1);
./benchmarks/binutils/leak_7/binutils_leak_7.c:76:12: warning: use location
   76 |   newstr = XNEWVEC (char, 1);
      |            ^
this stmt is child function---malloc-----

 ================== trace ================== 

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7fe1771d5438
    type <pointer_type 0x7fe1771b5c78
        type <integer_type 0x7fe1771b59d8 char public QI
            size <integer_cst 0x7fe17768cca8 constant 8>
            unit-size <integer_cst 0x7fe17768ccc0 constant 1>
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7fe1776a13f0 precision:8 min <integer_cst 0x7fe1771ac720 -128> max <integer_cst 0x7fe1771ac708 127>
            pointer_to_this <pointer_type 0x7fe1771b5c78>>
        public unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality context <translation_unit_decl 0x7fe177697168 ./benchmarks/binutils/leak_7/binutils_leak_7.c>
        pointer_to_this <pointer_type 0x7fe1771bfbd0>>
    var <var_decl 0x7fe1771cff30 newstr>
    def_stmt newstr_3 = malloc (1);
    version:3
    ptr-info 0x7fe1771ca888>

 ================== Start Use after free Check ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:0 [0m
[40;31m  	free count:0 [0m

======================================================================

======================================================================
[40;31m    no free stmt possible memory leak [0m

======================================================================

dot graph START

======================================================================

 ================== collect possiable invalid ================== 
 <integer_cst 0x7fe1771ca5e8 type <integer_type 0x7fe1776a17e0 long unsigned int> constant 1>
[40;33m =======POP node_fun stack:concat========= [0m
[40;42m =======pre add _ fucntion:do_start_initialization========= [0m
[40;44m =======print_function_type 2  ========  [0m
[40;44m =======print_function_path do_start_initialization  function_call count: 10 level :1========  [0m
[40;44m =======print_function_type 2  ========  [0m
[40;42m =======pre add _ fucntion:free========= [0m
[40;33m =======POP node_fun stack:free========= [0m
[40;42m =======pre add _ fucntion:Py_SetProgramName========= [0m
[40;44m =======print_function_type 0  ========  [0m
[40;44m =======print_function_path Py_SetProgramName  function_call count: 1 level :2========  [0m
[40;44m =======print_function_type 0  ========  [0m
[40;42m =======pre add _ fucntion:printf========= [0m
[40;33m =======POP node_fun stack:printf========= [0m
[40;42m =======pre_check_funciton:Py_SetProgramName========= [0m
[40;42m =======start_check_funciton:Py_SetProgramName========= [0m

dot graph START

======================================================================
 <addr_expr 0x7fe1771d6080
    type <pointer_type 0x7fe1771bfa80
        type <array_type 0x7fe1771bf9d8 type <integer_type 0x7fe1771b59d8 char>
            SI
            size <integer_cst 0x7fe17768cdf8 constant 32>
            unit-size <integer_cst 0x7fe17768ce10 constant 4>
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality domain <integer_type 0x7fe1771bf930>
            pointer_to_this <pointer_type 0x7fe1771bfa80>>
        unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
    readonly constant
    arg:0 <string_cst 0x7fe1771d6060 type <array_type 0x7fe1771bf9d8>
        readonly constant static "%d\012\000">
    ./benchmarks/binutils/leak_7/binutils_leak_7.c:91:2 start: ./benchmarks/binutils/leak_7/binutils_leak_7.c:91:2 finish: ./benchmarks/binutils/leak_7/binutils_leak_7.c:91:2>

 ================== trace ptable================== 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr--------
this other function -----------

======================================================================
[40;35m  	Looserules free count:0 [0m
[40;31m  	free count:0 [0m

======================================================================

======================================================================
[40;31m 	Can't find this fucntion in Pointer table [0m
[40;31m 	Possiable no other stmt relate with this stmt [0m

======================================================================
[40;33m =======POP node_fun stack:Py_SetProgramName========= [0m
[40;42m =======pre add _ fucntion:setlocale========= [0m
[40;33m =======POP node_fun stack:setlocale========= [0m
[40;42m =======pre add _ fucntion:__builtin_fwrite========= [0m
[40;33m =======POP node_fun stack:__builtin_fwrite========= [0m
[40;42m =======pre add _ fucntion:mbstowcs========= [0m
[40;33m =======POP node_fun stack:mbstowcs========= [0m
[40;42m =======pre add _ fucntion:PyMem_Malloc========= [0m
[40;44m =======print_function_type 2  ========  [0m
[40;44m =======print_function_path PyMem_Malloc  function_call count: 1 level :2========  [0m
[40;44m =======print_function_type 2  ========  [0m
[40;42m =======pre add _ fucntion:malloc========= [0m
[40;33m =======POP node_fun stack:malloc========= [0m
[40;42m =======pre_check_funciton:PyMem_Malloc========= [0m
[40;42m =======start_check_funciton:PyMem_Malloc========= [0m

dot graph START

======================================================================
 <ssa_name 0x7fe1771d5360
    type <pointer_type 0x7fe1776a8000
        type <void_type 0x7fe1776a1f18 void VOID
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality
            pointer_to_this <pointer_type 0x7fe1776a8000>>
        public unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality
        pointer_to_this <pointer_type 0x7fe1776ad9d8>>
    var <var_decl 0x7fe1771cfd80 ret>
    def_stmt ret_4 = malloc (size_2(D));
    version:4
    ptr-info 0x7fe1771ca870>
# .MEM_6 = VDEF <.MEM_5(D)>
ret_4 = malloc (size_2(D));

 ================== trace ptable================== 
trace fucntion name:malloc 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr---malloc-----
this Reserved word function ------malloc-----
 
 Start check Pointer Collect  

======================================================================
return ret_4;
./benchmarks/binutils/leak_7/binutils_leak_7.c:87:16: warning: use location
   87 |         return ret;
      |                ^
ret_4 = malloc (size_2(D));
./benchmarks/binutils/leak_7/binutils_leak_7.c:86:21: warning: use location
   86 |         void *ret = malloc(size);
      |                     ^
this stmt is child function---malloc-----

 ================== trace ================== 

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7fe1771d5360
    type <pointer_type 0x7fe1776a8000
        type <void_type 0x7fe1776a1f18 void VOID
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality
            pointer_to_this <pointer_type 0x7fe1776a8000>>
        public unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality
        pointer_to_this <pointer_type 0x7fe1776ad9d8>>
    var <var_decl 0x7fe1771cfd80 ret>
    def_stmt ret_4 = malloc (size_2(D));
    version:4
    ptr-info 0x7fe1771ca870>

 ================== Start Use after free Check ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:0 [0m
[40;31m  	free count:0 [0m

======================================================================

======================================================================
[40;31m    no free stmt possible memory leak [0m

======================================================================

dot graph START

======================================================================
 <ssa_name 0x7fe1771d5318
    type <integer_type 0x7fe1771b5f18 size_t public unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7fe1776a1738 precision:64 min <integer_cst 0x7fe17768ce88 0> max <integer_cst 0x7fe17768d500 18446744073709551615> context <translation_unit_decl 0x7fe177697168 ./benchmarks/binutils/leak_7/binutils_leak_7.c>>
    var <parm_decl 0x7fe1771c5300 size>
    def_stmt GIMPLE_NOP
    version:2>
GIMPLE_NOP

 ================== trace ptable================== 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr--------
this other function -----------
 
 Start check Pointer Collect  

======================================================================
ret_4 = malloc (size_2(D));
./benchmarks/binutils/leak_7/binutils_leak_7.c:86:21: warning: use location
this stmt is child function---malloc-----

 ================== trace ================== 
ret_4 = malloc (size_2(D));
./benchmarks/binutils/leak_7/binutils_leak_7.c:86:21: warning: use location
this stmt is child function---malloc-----

 ================== trace ================== 

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7fe1771d5318
    type <integer_type 0x7fe1771b5f18 size_t public unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7fe1776a1738 precision:64 min <integer_cst 0x7fe17768ce88 0> max <integer_cst 0x7fe17768d500 18446744073709551615> context <translation_unit_decl 0x7fe177697168 ./benchmarks/binutils/leak_7/binutils_leak_7.c>>
    var <parm_decl 0x7fe1771c5300 size>
    def_stmt GIMPLE_NOP
    version:2>

 ================== Start Use after free Check ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:0 [0m
[40;31m  	free count:0 [0m

======================================================================

======================================================================
[40;31m    no free stmt possible memory leak [0m

======================================================================
[40;33m =======POP node_fun stack:PyMem_Malloc========= [0m
[40;42m =======pre add _ fucntion:strlen========= [0m
[40;33m =======POP node_fun stack:strlen========= [0m
[40;42m =======pre add _ fucntion:strdup========= [0m
[40;33m =======POP node_fun stack:strdup========= [0m
[40;42m =======pre add _ fucntion:concat========= [0m
[40;44m =======print_function_type 2  ========  [0m
[40;44m =======print_function_path concat  function_call count: 2 level :2========  [0m
[40;44m =======print_function_type 2  ========  [0m
[40;42m =======pre add _ fucntion:vconcat_copy========= [0m
[40;44m =======print_function_type 0  ========  [0m
[40;44m =======print_function_path vconcat_copy  function_call count: 2 level :3========  [0m
[40;44m =======print_function_type 0  ========  [0m
[40;42m =======pre add _ fucntion:memcpy========= [0m
[40;33m =======POP node_fun stack:memcpy========= [0m
[40;42m =======pre add _ fucntion:strlen========= [0m
[40;33m =======POP node_fun stack:strlen========= [0m
[40;42m =======pre_check_funciton:vconcat_copy========= [0m
[40;42m =======start_check_funciton:vconcat_copy========= [0m

dot graph START

======================================================================
 <ssa_name 0x7fe1771d5678
    type <pointer_type 0x7fe1771b5b28
        type <integer_type 0x7fe1771b5a80 char readonly public QI
            size <integer_cst 0x7fe17768cca8 constant 8>
            unit-size <integer_cst 0x7fe17768ccc0 constant 1>
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7fe1776a13f0 precision:8 min <integer_cst 0x7fe1771ac720 -128> max <integer_cst 0x7fe1771ac708 127>
            pointer_to_this <pointer_type 0x7fe1771b5b28>>
        public unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
    var <parm_decl 0x7fe1771c5580 arg>
    def_stmt GIMPLE_NOP
    version:3
    ptr-info 0x7fe1771ca8e8>
GIMPLE_NOP

 ================== trace ptable================== 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr--------
this other function -----------
 
 Start check Pointer Collect  

======================================================================
length_4 = strlen (arg_3(D));
./benchmarks/binutils/leak_7/binutils_leak_7.c:61:32: warning: use location
   61 |         unsigned long length = strlen (arg);
      |                                ^
this stmt is child function---strlen-----

 ================== trace ================== 
trace fucntion name:strlen 

 ================== trace ================== 
trace fucntion free:0 
end_6 = dst_1(D) + length_4;
./benchmarks/binutils/leak_7/binutils_leak_7.c:63:13: warning: use location
   63 |         end += length;
      |             ^
*end_6 = 0;
./benchmarks/binutils/leak_7/binutils_leak_7.c:65:14: warning: use location
   65 |         *end = '\000';
      |              ^
memcpy (dst_1(D), arg_3(D), length_4);
./benchmarks/binutils/leak_7/binutils_leak_7.c:62:9: warning: use location
   62 |         memcpy (end, arg, length);
      |         ^
this stmt is child function---memcpy-----

 ================== trace ================== 
trace fucntion name:memcpy 

 ================== trace ================== 
trace fucntion free:0 

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7fe1771d5678
    type <pointer_type 0x7fe1771b5b28
        type <integer_type 0x7fe1771b5a80 char readonly public QI
            size <integer_cst 0x7fe17768cca8 constant 8>
            unit-size <integer_cst 0x7fe17768ccc0 constant 1>
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7fe1776a13f0 precision:8 min <integer_cst 0x7fe1771ac720 -128> max <integer_cst 0x7fe1771ac708 127>
            pointer_to_this <pointer_type 0x7fe1771b5b28>>
        public unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
    var <parm_decl 0x7fe1771c5580 arg>
    def_stmt GIMPLE_NOP
    version:3
    ptr-info 0x7fe1771ca8e8>

 ================== Start Use after free Check ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:0 [0m
[40;31m  	free count:0 [0m

======================================================================

======================================================================
[40;31m    no free stmt possible memory leak [0m

======================================================================

dot graph START

======================================================================
 <ssa_name 0x7fe1771d5630
    type <pointer_type 0x7fe1771b5c78
        type <integer_type 0x7fe1771b59d8 char public QI
            size <integer_cst 0x7fe17768cca8 constant 8>
            unit-size <integer_cst 0x7fe17768ccc0 constant 1>
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7fe1776a13f0 precision:8 min <integer_cst 0x7fe1771ac720 -128> max <integer_cst 0x7fe1771ac708 127>
            pointer_to_this <pointer_type 0x7fe1771b5c78>>
        public unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality context <translation_unit_decl 0x7fe177697168 ./benchmarks/binutils/leak_7/binutils_leak_7.c>
        pointer_to_this <pointer_type 0x7fe1771bfbd0>>
    var <parm_decl 0x7fe1771c5480 dst>
    def_stmt GIMPLE_NOP
    version:1
    ptr-info 0x7fe1771ca8d0>
GIMPLE_NOP

 ================== trace ptable================== 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr--------
this other function -----------
 
 Start check Pointer Collect  

======================================================================
return dst_1(D);
./benchmarks/binutils/leak_7/binutils_leak_7.c:67:16: warning: use location
   67 |         return dst;
      |                ^
end_6 = dst_1(D) + length_4;
./benchmarks/binutils/leak_7/binutils_leak_7.c:63:13: warning: use location
   63 |         end += length;
      |             ^
*end_6 = 0;
./benchmarks/binutils/leak_7/binutils_leak_7.c:65:14: warning: use location
   65 |         *end = '\000';
      |              ^
# .MEM_8 = VDEF <.MEM_7(D)>
memcpy (dst_1(D), arg_3(D), length_4);
memcpy (dst_1(D), arg_3(D), length_4);
./benchmarks/binutils/leak_7/binutils_leak_7.c:62:9: warning: use location
   62 |         memcpy (end, arg, length);
      |         ^
this stmt is child function---memcpy-----

 ================== trace ================== 
trace fucntion name:memcpy 

 ================== trace ================== 
trace fucntion free:0 
# .MEM_8 = VDEF <.MEM_7(D)>
memcpy (dst_1(D), arg_3(D), length_4);
memcpy (dst_1(D), arg_3(D), length_4);
./benchmarks/binutils/leak_7/binutils_leak_7.c:62:9: warning: use location
this stmt is child function---memcpy-----

 ================== trace ================== 
trace fucntion name:memcpy 

 ================== trace ================== 
trace fucntion free:0 

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7fe1771d5630
    type <pointer_type 0x7fe1771b5c78
        type <integer_type 0x7fe1771b59d8 char public QI
            size <integer_cst 0x7fe17768cca8 constant 8>
            unit-size <integer_cst 0x7fe17768ccc0 constant 1>
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7fe1776a13f0 precision:8 min <integer_cst 0x7fe1771ac720 -128> max <integer_cst 0x7fe1771ac708 127>
            pointer_to_this <pointer_type 0x7fe1771b5c78>>
        public unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality context <translation_unit_decl 0x7fe177697168 ./benchmarks/binutils/leak_7/binutils_leak_7.c>
        pointer_to_this <pointer_type 0x7fe1771bfbd0>>
    var <parm_decl 0x7fe1771c5480 dst>
    def_stmt GIMPLE_NOP
    version:1
    ptr-info 0x7fe1771ca8d0>

 ================== Start Use after free Check ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:0 [0m
[40;31m  	free count:0 [0m

======================================================================

======================================================================
[40;31m    no free stmt possible memory leak [0m

======================================================================
[40;33m =======POP node_fun stack:vconcat_copy========= [0m
[40;42m =======pre add _ fucntion:malloc========= [0m
[40;33m =======POP node_fun stack:malloc========= [0m
[40;42m =======pre_check_funciton:concat========= [0m
[40;42m =======start_check_funciton:concat========= [0m

dot graph START

======================================================================
 <ssa_name 0x7fe1771d5438
    type <pointer_type 0x7fe1771b5c78
        type <integer_type 0x7fe1771b59d8 char public QI
            size <integer_cst 0x7fe17768cca8 constant 8>
            unit-size <integer_cst 0x7fe17768ccc0 constant 1>
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7fe1776a13f0 precision:8 min <integer_cst 0x7fe1771ac720 -128> max <integer_cst 0x7fe1771ac708 127>
            pointer_to_this <pointer_type 0x7fe1771b5c78>>
        public unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality context <translation_unit_decl 0x7fe177697168 ./benchmarks/binutils/leak_7/binutils_leak_7.c>
        pointer_to_this <pointer_type 0x7fe1771bfbd0>>
    var <var_decl 0x7fe1771cff30 newstr>
    def_stmt newstr_3 = malloc (1);
    version:3
    ptr-info 0x7fe1771ca888>
# .MEM_7 = VDEF <.MEM_6(D)>
newstr_3 = malloc (1);

 ================== trace ptable================== 
trace fucntion name:malloc 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr---malloc-----
this Reserved word function ------malloc-----
 
 Start check Pointer Collect  

======================================================================
return newstr_3;
./benchmarks/binutils/leak_7/binutils_leak_7.c:81:10: warning: use location
   81 |   return newstr;
      |          ^
vconcat_copy (newstr_3, first_4(D), arg_5(D));
./benchmarks/binutils/leak_7/binutils_leak_7.c:79:3: warning: use location
   79 |   vconcat_copy (newstr, first, arg);
      |   ^
this stmt is child function---vconcat_copy-----

 ================== trace ================== 
trace fucntion name:vconcat_copy 
[40;44m =======trace_function_path vconcat_copy  function_call count: 2 level :0========  [0m
[40;36m ======= node_fun:vconcat_copy========= [0m
[40;36m ======= find relate stmt with newstr ========= [0m
[40;36m ======= relate stmt argument:newstr ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:memcpy========= [0m
[40;46m =======add node_fun stack:memcpy========= [0m
[40;42m =======pre add _ fucntion:strlen========= [0m
[40;46m =======add node_fun stack:strlen========= [0m

 ================== trace ================== 
trace fucntion free:0 
newstr_3 = malloc (1);
./benchmarks/binutils/leak_7/binutils_leak_7.c:76:12: warning: use location
   76 |   newstr = XNEWVEC (char, 1);
      |            ^
this stmt is child function---malloc-----

 ================== trace ================== 

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7fe1771d5438
    type <pointer_type 0x7fe1771b5c78
        type <integer_type 0x7fe1771b59d8 char public QI
            size <integer_cst 0x7fe17768cca8 constant 8>
            unit-size <integer_cst 0x7fe17768ccc0 constant 1>
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7fe1776a13f0 precision:8 min <integer_cst 0x7fe1771ac720 -128> max <integer_cst 0x7fe1771ac708 127>
            pointer_to_this <pointer_type 0x7fe1771b5c78>>
        public unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality context <translation_unit_decl 0x7fe177697168 ./benchmarks/binutils/leak_7/binutils_leak_7.c>
        pointer_to_this <pointer_type 0x7fe1771bfbd0>>
    var <var_decl 0x7fe1771cff30 newstr>
    def_stmt newstr_3 = malloc (1);
    version:3
    ptr-info 0x7fe1771ca888>

 ================== Start Use after free Check ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:0 [0m
[40;31m  	free count:0 [0m

======================================================================

======================================================================
[40;31m    no free stmt possible memory leak [0m

======================================================================

dot graph START

======================================================================

 ================== collect possiable invalid ================== 
 <integer_cst 0x7fe1771ca5e8 type <integer_type 0x7fe1776a17e0 long unsigned int> constant 1>
[40;33m =======POP node_fun stack:concat========= [0m
[40;42m =======pre add _ fucntion:ldirname========= [0m
[40;44m =======print_function_type 2  ========  [0m
[40;44m =======print_function_path ldirname  function_call count: 3 level :2========  [0m
[40;44m =======print_function_type 2  ========  [0m
[40;42m =======pre add _ fucntion:memcpy========= [0m
[40;33m =======POP node_fun stack:memcpy========= [0m
[40;42m =======pre add _ fucntion:malloc========= [0m
[40;33m =======POP node_fun stack:malloc========= [0m
[40;42m =======pre add _ fucntion:lbasename========= [0m
[40;44m =======print_function_type 0  ========  [0m
[40;44m =======print_function_path lbasename  function_call count: 1 level :3========  [0m
[40;44m =======print_function_type 0  ========  [0m
[40;42m =======pre add _ fucntion:unix_lbasename========= [0m
[40;44m =======print_function_type 0  ========  [0m
[40;44m =======print_function_path unix_lbasename  function_call count: 0 level :4========  [0m
[40;44m =======print_function_type 0  ========  [0m
[40;42m =======pre_check_funciton:unix_lbasename========= [0m
[40;42m =======start_check_funciton:unix_lbasename========= [0m
[40;33m =======POP node_fun stack:unix_lbasename========= [0m
[40;42m =======pre_check_funciton:lbasename========= [0m
[40;42m =======start_check_funciton:lbasename========= [0m

dot graph START

======================================================================
 <ssa_name 0x7fe1771de048
    type <pointer_type 0x7fe1771b5b28
        type <integer_type 0x7fe1771b5a80 char readonly public QI
            size <integer_cst 0x7fe17768cca8 constant 8>
            unit-size <integer_cst 0x7fe17768ccc0 constant 1>
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7fe1776a13f0 precision:8 min <integer_cst 0x7fe1771ac720 -128> max <integer_cst 0x7fe1771ac708 127>
            pointer_to_this <pointer_type 0x7fe1771b5b28>>
        public unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
    var <parm_decl 0x7fe1771c5680 name>
    def_stmt GIMPLE_NOP
    version:2
    ptr-info 0x7fe1771caa08>
GIMPLE_NOP

 ================== trace ptable================== 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr--------
this other function -----------

======================================================================
[40;35m  	Looserules free count:0 [0m
[40;31m  	free count:0 [0m

======================================================================

======================================================================
[40;31m 	Can't find this fucntion in Pointer table [0m
[40;31m 	Possiable no other stmt relate with this stmt [0m

======================================================================
[40;33m =======POP node_fun stack:lbasename========= [0m
[40;42m =======pre_check_funciton:ldirname========= [0m
[40;42m =======start_check_funciton:ldirname========= [0m

dot graph START

======================================================================
 <ssa_name 0x7fe1771d5e10
    type <pointer_type 0x7fe1771b5c78
        type <integer_type 0x7fe1771b59d8 char public QI
            size <integer_cst 0x7fe17768cca8 constant 8>
            unit-size <integer_cst 0x7fe17768ccc0 constant 1>
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7fe1776a13f0 precision:8 min <integer_cst 0x7fe1771ac720 -128> max <integer_cst 0x7fe1771ac708 127>
            pointer_to_this <pointer_type 0x7fe1771b5c78>>
        public unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality context <translation_unit_decl 0x7fe177697168 ./benchmarks/binutils/leak_7/binutils_leak_7.c>
        pointer_to_this <pointer_type 0x7fe1771bfbd0>>
    var <var_decl 0x7fe1771d7360 dirname>
    def_stmt dirname_26 = malloc (_4);
    version:26
    ptr-info 0x7fe1771ca9d8>
# .MEM_32 = VDEF <.MEM_31(D)>
dirname_26 = malloc (_4);

 ================== trace ptable================== 
trace fucntion name:malloc 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr---malloc-----
this Reserved word function ------malloc-----
 
 Start check Pointer Collect  

======================================================================
_18 = PHI <0B(6), dirname_26(11)>
lto1: warning: use location
this stmt have mutiple branch --------
_15 = dirname_26 + _14;
./benchmarks/binutils/leak_7/binutils_leak_7.c:52:10: warning: use location
   52 |   dirname[base - filename] = '\0';
      |          ^
*_15 = 0;
./benchmarks/binutils/leak_7/binutils_leak_7.c:52:28: warning: use location
   52 |   dirname[base - filename] = '\0';
      |                            ^
_12 = dirname_26 + _11;
./benchmarks/binutils/leak_7/binutils_leak_7.c:50:12: warning: use location
   50 |     dirname[base++ - filename] = '.';
      |            ^
*_12 = 46;
./benchmarks/binutils/leak_7/binutils_leak_7.c:50:32: warning: use location
   50 |     dirname[base++ - filename] = '.';
      |                                ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_33 = VDEF <.MEM_32>
memcpy (dirname_26, filename_22(D), _6);
bb index := 7
# VUSE <.MEM_30>
return _18;
In function â€˜ldirnameâ€™:
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 7 ,possiable got to succ := 12

======================================================================
memcpy (dirname_26, filename_22(D), _6);
In function â€˜mainâ€™:
./benchmarks/binutils/leak_7/binutils_leak_7.c:44:3: warning: use location
   44 |   memcpy (dirname, filename, base - filename);
      |   ^
this stmt is child function---memcpy-----

 ================== trace ================== 
trace fucntion name:memcpy 

 ================== trace ================== 
trace fucntion free:0 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_32 = VDEF <.MEM_31(D)>
dirname_26 = malloc (_4);
bb index := 7
# VUSE <.MEM_30>
return _18;
In function â€˜ldirnameâ€™:
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 7 ,possiable got to succ := 12

======================================================================
dirname_26 = malloc (_4);
In function â€˜mainâ€™:
./benchmarks/binutils/leak_7/binutils_leak_7.c:43:22: warning: use location
   43 |   dirname = (char *) xmalloc (base - filename + 2);         /* allocation site */
      |                      ^
this stmt is child function---malloc-----

 ================== trace ================== 

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7fe1771d5e10
    type <pointer_type 0x7fe1771b5c78
        type <integer_type 0x7fe1771b59d8 char public QI
            size <integer_cst 0x7fe17768cca8 constant 8>
            unit-size <integer_cst 0x7fe17768ccc0 constant 1>
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7fe1776a13f0 precision:8 min <integer_cst 0x7fe1771ac720 -128> max <integer_cst 0x7fe1771ac708 127>
            pointer_to_this <pointer_type 0x7fe1771b5c78>>
        public unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality context <translation_unit_decl 0x7fe177697168 ./benchmarks/binutils/leak_7/binutils_leak_7.c>
        pointer_to_this <pointer_type 0x7fe1771bfbd0>>
    var <var_decl 0x7fe1771d7360 dirname>
    def_stmt dirname_26 = malloc (_4);
    version:26
    ptr-info 0x7fe1771ca9d8>

 ================== Start Use after free Check ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:0 [0m
[40;31m  	free count:0 [0m

======================================================================

======================================================================
[40;31m    no free stmt possible memory leak [0m

======================================================================

dot graph START

======================================================================
 <ssa_name 0x7fe1771d5d38
    type <pointer_type 0x7fe1771b5b28
        type <integer_type 0x7fe1771b5a80 char readonly public QI
            size <integer_cst 0x7fe17768cca8 constant 8>
            unit-size <integer_cst 0x7fe17768ccc0 constant 1>
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7fe1776a13f0 precision:8 min <integer_cst 0x7fe1771ac720 -128> max <integer_cst 0x7fe1771ac708 127>
            pointer_to_this <pointer_type 0x7fe1771b5b28>>
        public unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
    var <parm_decl 0x7fe1771c5600 filename>
    def_stmt GIMPLE_NOP
    version:22
    ptr-info 0x7fe1771ca990>
GIMPLE_NOP

 ================== trace ptable================== 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr--------
this other function -----------
 
 Start check Pointer Collect  

======================================================================
base_23 = lbasename (filename_22(D));
./benchmarks/binutils/leak_7/binutils_leak_7.c:34:22: warning: use location
   34 |   const char *base = lbasename (filename);
      |                      ^
this stmt is child function---lbasename-----

 ================== trace ================== 
trace fucntion name:lbasename 
[40;44m =======trace_function_path lbasename  function_call count: 1 level :0========  [0m
[40;36m ======= node_fun:lbasename========= [0m
[40;36m ======= find relate stmt with filename ========= [0m
[40;36m ======= relate stmt argument:filename ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:unix_lbasename========= [0m
[40;46m =======add node_fun stack:unix_lbasename========= [0m
[40;44m =======trace_function_path unix_lbasename  function_call count: 0 level :1========  [0m
[40;36m ======= node_fun:unix_lbasename========= [0m
[40;36m ======= find relate stmt with filename ========= [0m
[40;36m ======= relate stmt argument:filename ========= [0m
fucntion collect path finsh

 ================== trace ================== 
trace fucntion free:0 

======================================================================
[40;31m    branch possiable have return or exit  [0m
base_16 = PHI <base_23(2), base_24(3)>
bb index := 4
# VUSE <.MEM_30>
return _18;
In function â€˜ldirnameâ€™:
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 4 ,possiable got to succ := 12

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
base_16 = PHI <base_23(2), base_24(3)>
bb index := 4
# VUSE <.MEM_8(D)>
return base_3;
./benchmarks/binutils/leak_7/binutils_leak_7.c:22:10: warning: use location
   22 |   return base;
      |          ^
beacuse in succ := 5 have return or exit
# VUSE <.MEM_8(D)>
return base_3;
./benchmarks/binutils/leak_7/binutils_leak_7.c:22:10: warning: use location
gimple stmt in succ := 4 ,possiable got to succ := 5

======================================================================

======================================================================
[40;31m    collect Stmt in loop [0m

======================================================================
base_16 = PHI <base_23(2), base_24(3)>
In function â€˜mainâ€™:
lto1: warning: use location
this stmt have mutiple branch --------
base_17 = PHI <base_16(7), base_16(8), base_16(9), base_28(10)>
lto1: warning: use location
this stmt have mutiple branch --------
_13 = base_17 - filename_22(D);
./benchmarks/binutils/leak_7/binutils_leak_7.c:52:16: warning: use location
   52 |   dirname[base - filename] = '\0';
      |                ^
_14 = (sizetype) _13;
./benchmarks/binutils/leak_7/binutils_leak_7.c:52:16: warning: use location
_15 = dirname_26 + _14;
./benchmarks/binutils/leak_7/binutils_leak_7.c:52:10: warning: use location
   52 |   dirname[base - filename] = '\0';
      |          ^
*_15 = 0;
./benchmarks/binutils/leak_7/binutils_leak_7.c:52:28: warning: use location
   52 |   dirname[base - filename] = '\0';
      |                            ^
_10 = base_16 - filename_22(D);
./benchmarks/binutils/leak_7/binutils_leak_7.c:50:20: warning: use location
   50 |     dirname[base++ - filename] = '.';
      |                    ^
_11 = (sizetype) _10;
./benchmarks/binutils/leak_7/binutils_leak_7.c:50:20: warning: use location
_12 = dirname_26 + _11;
./benchmarks/binutils/leak_7/binutils_leak_7.c:50:12: warning: use location
   50 |     dirname[base++ - filename] = '.';
      |            ^
*_12 = 46;
./benchmarks/binutils/leak_7/binutils_leak_7.c:50:32: warning: use location
   50 |     dirname[base++ - filename] = '.';
      |                                ^
base_28 = base_16 + 1;
./benchmarks/binutils/leak_7/binutils_leak_7.c:50:17: warning: use location
   50 |     dirname[base++ - filename] = '.';
      |                 ^
_8 = *base_16;
./benchmarks/binutils/leak_7/binutils_leak_7.c:48:31: warning: use location
   48 |   if (base - filename == 2 && IS_ABSOLUTE_PATH (base)
      |                               ^
if (_8 == 47)
./benchmarks/binutils/leak_7/binutils_leak_7.c:48:28: warning: use location
   48 |   if (base - filename == 2 && IS_ABSOLUTE_PATH (base)
      |                            ^
if (_8 == 47)

 ================== find cond branch ================= 
./benchmarks/binutils/leak_7/binutils_leak_7.c:48:28: warning: use location
Cond in fucntion ldirname basic block 8
 ================== possible direct basic block ================= 
from ldirname basic block 9
 ================== possible direct basic block ================= 
from ldirname basic block 11
 ================== warring ================== 
[40;35m    need check this branch possible have return or exit stmt [0m

 ================== warring ================== 

 ================== find cond branch ================= 

======================================================================
[40;31m    branch possiable have return or exit  [0m
_7 = base_16 - filename_22(D);
bb index := 7
# VUSE <.MEM_30>
return _18;
In function â€˜ldirnameâ€™:
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 7 ,possiable got to succ := 12

======================================================================
_7 = base_16 - filename_22(D);
In function â€˜mainâ€™:
./benchmarks/binutils/leak_7/binutils_leak_7.c:48:12: warning: use location
   48 |   if (base - filename == 2 && IS_ABSOLUTE_PATH (base)
      |            ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
if (_7 == 2)
bb index := 7
# VUSE <.MEM_30>
return _18;
In function â€˜ldirnameâ€™:
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 7 ,possiable got to succ := 12

======================================================================
if (_7 == 2)
In function â€˜mainâ€™:
./benchmarks/binutils/leak_7/binutils_leak_7.c:48:6: warning: use location
   48 |   if (base - filename == 2 && IS_ABSOLUTE_PATH (base)
      |      ^
if (_7 == 2)

 ================== find cond branch ================= 
./benchmarks/binutils/leak_7/binutils_leak_7.c:48:6: warning: use location
Cond in fucntion ldirname basic block 7
 ================== possible direct basic block ================= 
from ldirname basic block 8
 ================== possible direct basic block ================= 
from ldirname basic block 11
 ================== warring ================== 
[40;35m    need check this branch possible have return or exit stmt [0m

 ================== warring ================== 

 ================== find cond branch ================= 

======================================================================
[40;31m    branch possiable have return or exit  [0m
_5 = base_16 - filename_22(D);
bb index := 7
# VUSE <.MEM_30>
return _18;
In function â€˜ldirnameâ€™:
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 7 ,possiable got to succ := 12

======================================================================
_5 = base_16 - filename_22(D);
In function â€˜mainâ€™:
./benchmarks/binutils/leak_7/binutils_leak_7.c:44:35: warning: use location
   44 |   memcpy (dirname, filename, base - filename);
      |                                   ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
_6 = (long unsigned int) _5;
bb index := 7
# VUSE <.MEM_30>
return _18;
In function â€˜ldirnameâ€™:
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 7 ,possiable got to succ := 12

======================================================================
_6 = (long unsigned int) _5;
In function â€˜mainâ€™:
./benchmarks/binutils/leak_7/binutils_leak_7.c:44:3: warning: use location
   44 |   memcpy (dirname, filename, base - filename);
      |   ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_33 = VDEF <.MEM_32>
memcpy (dirname_26, filename_22(D), _6);
bb index := 7
# VUSE <.MEM_30>
return _18;
In function â€˜ldirnameâ€™:
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 7 ,possiable got to succ := 12

======================================================================
memcpy (dirname_26, filename_22(D), _6);
In function â€˜mainâ€™:
./benchmarks/binutils/leak_7/binutils_leak_7.c:44:3: warning: use location
this stmt is child function---memcpy-----

 ================== trace ================== 
trace fucntion name:memcpy 

 ================== trace ================== 
trace fucntion free:0 

======================================================================
[40;31m    branch possiable have return or exit  [0m
_2 = base_16 - filename_22(D);
bb index := 7
# VUSE <.MEM_30>
return _18;
In function â€˜ldirnameâ€™:
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 7 ,possiable got to succ := 12

======================================================================
_2 = base_16 - filename_22(D);
In function â€˜mainâ€™:
./benchmarks/binutils/leak_7/binutils_leak_7.c:43:22: warning: use location
   43 |   dirname = (char *) xmalloc (base - filename + 2);         /* allocation site */
      |                      ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
_3 = _2 + 2;
bb index := 7
# VUSE <.MEM_30>
return _18;
In function â€˜ldirnameâ€™:
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 7 ,possiable got to succ := 12

======================================================================
_3 = _2 + 2;
In function â€˜mainâ€™:
./benchmarks/binutils/leak_7/binutils_leak_7.c:43:22: warning: use location

======================================================================
[40;31m    branch possiable have return or exit  [0m
_4 = (long unsigned int) _3;
bb index := 7
# VUSE <.MEM_30>
return _18;
In function â€˜ldirnameâ€™:
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 7 ,possiable got to succ := 12

======================================================================
_4 = (long unsigned int) _3;
In function â€˜mainâ€™:
./benchmarks/binutils/leak_7/binutils_leak_7.c:43:22: warning: use location

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_32 = VDEF <.MEM_31(D)>
dirname_26 = malloc (_4);
bb index := 7
# VUSE <.MEM_30>
return _18;
In function â€˜ldirnameâ€™:
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 7 ,possiable got to succ := 12

======================================================================
dirname_26 = malloc (_4);
In function â€˜mainâ€™:
./benchmarks/binutils/leak_7/binutils_leak_7.c:43:22: warning: use location
this stmt is child function---malloc-----

 ================== trace ================== 
_18 = PHI <0B(6), dirname_26(11)>
lto1: warning: use location
this stmt have mutiple branch --------

======================================================================
[40;31m    branch possiable have return or exit  [0m
if (base_16 == filename_22(D))
bb index := 6
# VUSE <.MEM_30>
return _18;
In function â€˜ldirnameâ€™:
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 6 ,possiable got to succ := 12

======================================================================
if (base_16 == filename_22(D))
In function â€˜mainâ€™:
./benchmarks/binutils/leak_7/binutils_leak_7.c:40:6: warning: use location
   40 |   if (base == filename)
      |      ^
if (base_16 == filename_22(D))

 ================== find cond branch ================= 
./benchmarks/binutils/leak_7/binutils_leak_7.c:40:6: warning: use location
Cond in fucntion ldirname basic block 6
 ================== possible direct basic block ================= 
from ldirname basic block 12
 ================== possible direct basic block ================= 
from ldirname basic block 7
 ================== warring ================== 
[40;35m    need check this branch possible have return or exit stmt [0m

 ================== warring ================== 

 ================== find cond branch ================= 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# VUSE <.MEM_31(D)>
_1 = MEM[(const char *)base_16 + -1B];
bb index := 5
# VUSE <.MEM_30>
return _18;
In function â€˜ldirnameâ€™:
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 5 ,possiable got to succ := 12

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# VUSE <.MEM_31(D)>
_1 = MEM[(const char *)base_16 + -1B];
bb index := 5
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 5 ,possiable got to succ := 12

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# VUSE <.MEM_31(D)>
_1 = MEM[(const char *)base_16 + -1B];
bb index := 5
# VUSE <.MEM_8(D)>
return base_3;
./benchmarks/binutils/leak_7/binutils_leak_7.c:22:10: warning: use location
   22 |   return base;
      |          ^
beacuse in succ := 5 have return or exit
# VUSE <.MEM_8(D)>
return base_3;
./benchmarks/binutils/leak_7/binutils_leak_7.c:22:10: warning: use location
gimple stmt in succ := 5 ,possiable got to succ := 5

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# VUSE <.MEM_31(D)>
_1 = MEM[(const char *)base_16 + -1B];
bb index := 5
# VUSE <.MEM_8(D)>
return base_3;
./benchmarks/binutils/leak_7/binutils_leak_7.c:22:10: warning: use location
beacuse in succ := 5 have return or exit
# VUSE <.MEM_8(D)>
return base_3;
./benchmarks/binutils/leak_7/binutils_leak_7.c:22:10: warning: use location
gimple stmt in succ := 5 ,possiable got to succ := 5

======================================================================

======================================================================
[40;31m    collect Stmt in loop [0m

======================================================================
_1 = MEM[(const char *)base_16 + -1B];
In function â€˜mainâ€™:
./benchmarks/binutils/leak_7/binutils_leak_7.c:37:29: warning: use location
   37 |   while (base > filename && IS_DIR_SEPARATOR (base[-1]))
      |                             ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
base_24 = base_16 + 18446744073709551615;
bb index := 3
# VUSE <.MEM_30>
return _18;
In function â€˜ldirnameâ€™:
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 3 ,possiable got to succ := 12

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
base_24 = base_16 + 18446744073709551615;
bb index := 3
# VUSE <.MEM_8(D)>
return base_3;
./benchmarks/binutils/leak_7/binutils_leak_7.c:22:10: warning: use location
   22 |   return base;
      |          ^
beacuse in succ := 5 have return or exit
# VUSE <.MEM_8(D)>
return base_3;
./benchmarks/binutils/leak_7/binutils_leak_7.c:22:10: warning: use location
gimple stmt in succ := 3 ,possiable got to succ := 5

======================================================================

======================================================================
[40;31m    collect Stmt in loop [0m

======================================================================
base_24 = base_16 + 18446744073709551615;
In function â€˜mainâ€™:
./benchmarks/binutils/leak_7/binutils_leak_7.c:38:5: warning: use location
   38 |     --base;
      |     ^
_9 = *filename_22(D);
./benchmarks/binutils/leak_7/binutils_leak_7.c:49:11: warning: use location
   49 |       && !IS_DIR_SEPARATOR (filename[0]))
      |           ^

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7fe1771d5d38
    type <pointer_type 0x7fe1771b5b28
        type <integer_type 0x7fe1771b5a80 char readonly public QI
            size <integer_cst 0x7fe17768cca8 constant 8>
            unit-size <integer_cst 0x7fe17768ccc0 constant 1>
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7fe1776a13f0 precision:8 min <integer_cst 0x7fe1771ac720 -128> max <integer_cst 0x7fe1771ac708 127>
            pointer_to_this <pointer_type 0x7fe1771b5b28>>
        public unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
    var <parm_decl 0x7fe1771c5600 filename>
    def_stmt GIMPLE_NOP
    version:22
    ptr-info 0x7fe1771ca990>

 ================== Start Use after free Check ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:0 [0m
[40;31m  	free count:0 [0m

======================================================================

======================================================================
[40;31m 	this stmt need double check [0m

======================================================================

dot graph START

======================================================================
 <ssa_name 0x7fe1771d5900
    type <integer_type 0x7fe1776a17e0 long unsigned int public unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7fe1776a1738 precision:64 min <integer_cst 0x7fe17768ce88 0> max <integer_cst 0x7fe17768d500 18446744073709551615>
        pointer_to_this <pointer_type 0x7fe1776ad7e0>>
   
    def_stmt _4 = (long unsigned int) _3;
    version:4>
_4 = (long unsigned int) _3;

 ================== trace ptable================== 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr--------
this other function -----------
 
 Start check Pointer Collect  

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_32 = VDEF <.MEM_31(D)>
dirname_26 = malloc (_4);
bb index := 7
# VUSE <.MEM_30>
return _18;
In function â€˜ldirnameâ€™:
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 7 ,possiable got to succ := 12

======================================================================
dirname_26 = malloc (_4);
In function â€˜mainâ€™:
./benchmarks/binutils/leak_7/binutils_leak_7.c:43:22: warning: use location
   43 |   dirname = (char *) xmalloc (base - filename + 2);         /* allocation site */
      |                      ^
this stmt is child function---malloc-----

 ================== trace ================== 
_18 = PHI <0B(6), dirname_26(11)>
lto1: warning: use location
this stmt have mutiple branch --------
_15 = dirname_26 + _14;
./benchmarks/binutils/leak_7/binutils_leak_7.c:52:10: warning: use location
   52 |   dirname[base - filename] = '\0';
      |          ^
*_15 = 0;
./benchmarks/binutils/leak_7/binutils_leak_7.c:52:28: warning: use location
   52 |   dirname[base - filename] = '\0';
      |                            ^
_12 = dirname_26 + _11;
./benchmarks/binutils/leak_7/binutils_leak_7.c:50:12: warning: use location
   50 |     dirname[base++ - filename] = '.';
      |            ^
*_12 = 46;
./benchmarks/binutils/leak_7/binutils_leak_7.c:50:32: warning: use location
   50 |     dirname[base++ - filename] = '.';
      |                                ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_33 = VDEF <.MEM_32>
memcpy (dirname_26, filename_22(D), _6);
bb index := 7
# VUSE <.MEM_30>
return _18;
In function â€˜ldirnameâ€™:
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 7 ,possiable got to succ := 12

======================================================================
memcpy (dirname_26, filename_22(D), _6);
In function â€˜mainâ€™:
./benchmarks/binutils/leak_7/binutils_leak_7.c:44:3: warning: use location
   44 |   memcpy (dirname, filename, base - filename);
      |   ^
this stmt is child function---memcpy-----

 ================== trace ================== 
trace fucntion name:memcpy 

 ================== trace ================== 
trace fucntion free:0 

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7fe1771d5900
    type <integer_type 0x7fe1776a17e0 long unsigned int public unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7fe1776a1738 precision:64 min <integer_cst 0x7fe17768ce88 0> max <integer_cst 0x7fe17768d500 18446744073709551615>
        pointer_to_this <pointer_type 0x7fe1776ad7e0>>
   
    def_stmt _4 = (long unsigned int) _3;
    version:4>

 ================== Start Use after free Check ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:0 [0m
[40;31m  	free count:0 [0m

======================================================================

======================================================================
[40;31m    no free stmt possible memory leak [0m

======================================================================
[40;33m =======POP node_fun stack:ldirname========= [0m
[40;42m =======pre_check_funciton:do_start_initialization========= [0m
[40;42m =======start_check_funciton:do_start_initialization========= [0m

dot graph START

======================================================================
 <ssa_name 0x7fe177694ab0
    type <pointer_type 0x7fe1771b5c78
        type <integer_type 0x7fe1771b59d8 char public QI
            size <integer_cst 0x7fe17768cca8 constant 8>
            unit-size <integer_cst 0x7fe17768ccc0 constant 1>
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7fe1776a13f0 precision:8 min <integer_cst 0x7fe1771ac720 -128> max <integer_cst 0x7fe1771ac708 127>
            pointer_to_this <pointer_type 0x7fe1771b5c78>>
        public unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality context <translation_unit_decl 0x7fe177697168 ./benchmarks/binutils/leak_7/binutils_leak_7.c>
        pointer_to_this <pointer_type 0x7fe1771bfbd0>>
    var <var_decl 0x7fe1771cf1b0 oldloc>
    def_stmt oldloc_19 = strdup (_5);
    version:19
    ptr-info 0x7fe1771ca828>
# .MEM_43 = VDEF <.MEM_42>
oldloc_19 = strdup (_5);

 ================== trace ptable================== 
trace fucntion name:strdup 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr---strdup-----
this Reserved word function ------strdup-----
 
 Start check Pointer Collect  

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_43 = VDEF <.MEM_42>
oldloc_19 = strdup (_5);
bb index := 2
# VUSE <.MEM_30>
return _18;
In function â€˜do_start_initializationâ€™:
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 12

======================================================================
oldloc_19 = strdup (_5);
In function â€˜mainâ€™:
./benchmarks/binutils/leak_7/binutils_leak_7.c:110:12: warning: use location
  110 |   oldloc = xstrdup (setlocale (LC_ALL, NULL));
      |            ^
this stmt is child function---strdup-----

 ================== trace ================== 
free (oldloc_19);
./benchmarks/binutils/leak_7/binutils_leak_7.c:129:3: warning: use location
  129 |   xfree (oldloc);
      |   ^
this stmt is child function---free-----

 ================== find ================== 
free (oldloc_19);
./benchmarks/binutils/leak_7/binutils_leak_7.c:129:3: warning: use location
[40;32m    HAS FREE STMT count:1 name:free [0m

 ================== find ================== 
setlocale ("LC_ALL", oldloc_19);
./benchmarks/binutils/leak_7/binutils_leak_7.c:128:3: warning: use location
  128 |   setlocale (LC_ALL, oldloc);
      |   ^
this stmt is child function---setlocale-----

 ================== trace ================== 
trace fucntion name:setlocale 

 ================== trace ================== 
trace fucntion free:1 
free (oldloc_19);
./benchmarks/binutils/leak_7/binutils_leak_7.c:123:7: warning: use location
  123 |       xfree (oldloc);
      |       ^
this stmt is child function---free-----

 ================== find ================== 
free (oldloc_19);
./benchmarks/binutils/leak_7/binutils_leak_7.c:123:7: warning: use location
[40;32m    HAS FREE STMT count:2 name:free [0m

 ================== find ================== 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_54 = VDEF <.MEM_45>
free (oldloc_19);
bb index := 3
# VUSE <.MEM_30>
return _18;
In function â€˜do_start_initializationâ€™:
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 3 ,possiable got to succ := 12

======================================================================
free (oldloc_19);
In function â€˜mainâ€™:
./benchmarks/binutils/leak_7/binutils_leak_7.c:116:7: warning: use location
  116 |       xfree (oldloc);
      |       ^
this stmt is child function---free-----

 ================== find ================== 
free (oldloc_19);
./benchmarks/binutils/leak_7/binutils_leak_7.c:116:7: warning: use location
[40;32m    HAS FREE STMT count:3 name:free [0m

 ================== find ================== 

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7fe177694ab0
    type <pointer_type 0x7fe1771b5c78
        type <integer_type 0x7fe1771b59d8 char public QI
            size <integer_cst 0x7fe17768cca8 constant 8>
            unit-size <integer_cst 0x7fe17768ccc0 constant 1>
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7fe1776a13f0 precision:8 min <integer_cst 0x7fe1771ac720 -128> max <integer_cst 0x7fe1771ac708 127>
            pointer_to_this <pointer_type 0x7fe1771b5c78>>
        public unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality context <translation_unit_decl 0x7fe177697168 ./benchmarks/binutils/leak_7/binutils_leak_7.c>
        pointer_to_this <pointer_type 0x7fe1771bfbd0>>
    var <var_decl 0x7fe1771cf1b0 oldloc>
    def_stmt oldloc_19 = strdup (_5);
    version:19
    ptr-info 0x7fe1771ca828>
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_54 = VDEF <.MEM_45>
free (oldloc_19);
./benchmarks/binutils/leak_7/binutils_leak_7.c:116:7: warning: use location
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_51 = VDEF <.MEM_46>
free (oldloc_19);
./benchmarks/binutils/leak_7/binutils_leak_7.c:123:7: warning: use location
  123 |       xfree (oldloc);
      |       ^
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_48 = VDEF <.MEM_47>
free (oldloc_19);
./benchmarks/binutils/leak_7/binutils_leak_7.c:129:3: warning: use location
  129 |   xfree (oldloc);
      |   ^

 ================== Start Use after free Check ================== 

============================================================
# .MEM_51 = VDEF <.MEM_46>
free (oldloc_19);
./benchmarks/binutils/leak_7/binutils_leak_7.c:123:7: warning: Use after free error!: free location 
  123 |       xfree (oldloc);
      |       ^
# .MEM_47 = VDEF <.MEM_46>
setlocale ("LC_ALL", oldloc_19);
./benchmarks/binutils/leak_7/binutils_leak_7.c:128:3: warning: use location
  128 |   setlocale (LC_ALL, oldloc);
      |   ^

 ================== warring ================== 
[40;35m    Use after free error! [0m
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
# .MEM_54 = VDEF <.MEM_45>
free (oldloc_19);
./benchmarks/binutils/leak_7/binutils_leak_7.c:116:7: warning: Use after free error!: free location 
  116 |       xfree (oldloc);
      |       ^
# .MEM_47 = VDEF <.MEM_46>
setlocale ("LC_ALL", oldloc_19);
./benchmarks/binutils/leak_7/binutils_leak_7.c:128:3: warning: use location
  128 |   setlocale (LC_ALL, oldloc);
      |   ^

 ================== warring ================== 
[40;35m    Use after free error! [0m
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_54 = VDEF <.MEM_45>
free (oldloc_19);
./benchmarks/binutils/leak_7/binutils_leak_7.c:116:7: warning: Use after free error!: free location 
  116 |       xfree (oldloc);
      |       ^
# .MEM_47 = VDEF <.MEM_46>
setlocale ("LC_ALL", oldloc_19);
./benchmarks/binutils/leak_7/binutils_leak_7.c:128:3: warning: use location
  128 |   setlocale (LC_ALL, oldloc);
      |   ^

 ================== warring ================== 
[40;35m    Use after free error! [0m
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_51 = VDEF <.MEM_46>
free (oldloc_19);
./benchmarks/binutils/leak_7/binutils_leak_7.c:123:7: warning: Use after free error!: free location 
  123 |       xfree (oldloc);
      |       ^
# .MEM_47 = VDEF <.MEM_46>
setlocale ("LC_ALL", oldloc_19);
./benchmarks/binutils/leak_7/binutils_leak_7.c:128:3: warning: use location
  128 |   setlocale (LC_ALL, oldloc);
      |   ^

 ================== warring ================== 
[40;35m    Use after free error! [0m
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:3 [0m
[40;31m  	free count:3 [0m
[40;31m  	possible double free [Looserules]:3 [0m
[40;31m  	possible double free [rigorous]:3 [0m

======================================================================

======================================================================
[40;31m  	possible double free [rigorous]:3 [0m

======================================================================

dot graph START

======================================================================
 <ssa_name 0x7fe177694750
    type <pointer_type 0x7fe1771b5c78
        type <integer_type 0x7fe1771b59d8 char public QI
            size <integer_cst 0x7fe17768cca8 constant 8>
            unit-size <integer_cst 0x7fe17768ccc0 constant 1>
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7fe1776a13f0 precision:8 min <integer_cst 0x7fe1771ac720 -128> max <integer_cst 0x7fe1771ac708 127>
            pointer_to_this <pointer_type 0x7fe1771b5c78>>
        public unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality context <translation_unit_decl 0x7fe177697168 ./benchmarks/binutils/leak_7/binutils_leak_7.c>
        pointer_to_this <pointer_type 0x7fe1771bfbd0>>
   
    def_stmt _1 = python_libdir;
    version:1
    ptr-info 0x7fe1771ca798>
# VUSE <.MEM_39(D)>
_1 = python_libdir;

 ================== trace ptable================== 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr--------
this other function -----------
 
 Start check Pointer Collect  

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_40 = VDEF <.MEM_39(D)>
_2 = ldirname (_1);
bb index := 2
# VUSE <.MEM_30>
return _18;
In function â€˜do_start_initializationâ€™:
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 12

======================================================================
_2 = ldirname (_1);
In function â€˜mainâ€™:
./benchmarks/binutils/leak_7/binutils_leak_7.c:109:22: warning: use location
  109 |   progname = concat (ldirname (python_libdir), "bin");
      |                      ^
this stmt is child function---ldirname-----

 ================== trace ================== 
trace fucntion name:ldirname 
[40;44m =======trace_function_path ldirname  function_call count: 3 level :0========  [0m
[40;36m ======= node_fun:ldirname========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:memcpy========= [0m
[40;46m =======add node_fun stack:memcpy========= [0m
[40;42m =======pre add _ fucntion:malloc========= [0m
[40;46m =======add node_fun stack:malloc========= [0m
[40;42m =======pre add _ fucntion:lbasename========= [0m
[40;46m =======add node_fun stack:lbasename========= [0m
[40;44m =======trace_function_path lbasename  function_call count: 1 level :1========  [0m
[40;36m ======= node_fun:lbasename========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:unix_lbasename========= [0m
[40;46m =======add node_fun stack:unix_lbasename========= [0m
[40;44m =======trace_function_path unix_lbasename  function_call count: 0 level :2========  [0m
[40;36m ======= node_fun:unix_lbasename========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
fucntion collect path finsh

 ================== trace ================== 
trace fucntion free:0 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_41 = VDEF <.MEM_40>
progname_16 = concat (_2, "bin");
bb index := 2
# VUSE <.MEM_30>
return _18;
In function â€˜do_start_initializationâ€™:
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 12

======================================================================
progname_16 = concat (_2, "bin");
In function â€˜mainâ€™:
./benchmarks/binutils/leak_7/binutils_leak_7.c:109:14: warning: use location
  109 |   progname = concat (ldirname (python_libdir), "bin");
      |              ^
this stmt is child function---concat-----

 ================== trace ================== 
trace fucntion name:concat 
[40;44m =======trace_function_path concat  function_call count: 2 level :0========  [0m
[40;36m ======= node_fun:concat========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:vconcat_copy========= [0m
[40;46m =======add node_fun stack:vconcat_copy========= [0m
[40;44m =======trace_function_path vconcat_copy  function_call count: 2 level :1========  [0m
[40;36m ======= node_fun:vconcat_copy========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:memcpy========= [0m
[40;46m =======add node_fun stack:memcpy========= [0m
[40;42m =======pre add _ fucntion:strlen========= [0m
[40;46m =======add node_fun stack:strlen========= [0m
[40;42m =======pre add _ fucntion:malloc========= [0m
[40;46m =======add node_fun stack:malloc========= [0m

 ================== trace ================== 
trace fucntion free:0 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# VUSE <.MEM_44>
progsize_21 = strlen (progname_16);
bb index := 2
# VUSE <.MEM_30>
return _18;
In function â€˜do_start_initializationâ€™:
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 12

======================================================================
progsize_21 = strlen (progname_16);
In function â€˜mainâ€™:
./benchmarks/binutils/leak_7/binutils_leak_7.c:112:14: warning: use location
  112 |   progsize = strlen (progname);
      |              ^
this stmt is child function---strlen-----

 ================== trace ================== 
trace fucntion name:strlen 

 ================== trace ================== 
trace fucntion free:0 
_9 = progsize_21 + 1;
./benchmarks/binutils/leak_7/binutils_leak_7.c:120:11: warning: use location
  120 |   count = mbstowcs (progname_copy, progname, progsize + 1);
      |           ^
count_25 = mbstowcs (progname_copy_23, progname_16, _9);
./benchmarks/binutils/leak_7/binutils_leak_7.c:120:11: warning: use location
this stmt is child function---mbstowcs-----

 ================== trace ================== 
trace fucntion name:mbstowcs 

 ================== trace ================== 
trace fucntion free:0 
if (count_25 == 18446744073709551615)
./benchmarks/binutils/leak_7/binutils_leak_7.c:121:6: warning: use location
  121 |   if (count == (size_t) -1)
      |      ^
if (count_25 == 18446744073709551615)

 ================== find cond branch ================= 
./benchmarks/binutils/leak_7/binutils_leak_7.c:121:6: warning: use location
Cond in fucntion do_start_initialization basic block 4
 ================== possible direct basic block ================= 
from do_start_initialization basic block 5
 ================== possible direct basic block ================= 
from do_start_initialization basic block 6
 ================== warring ================== 
[40;35m    need check this branch possible have return or exit stmt [0m

 ================== warring ================== 

 ================== find cond branch ================= 
free (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:135:9: warning: use location
  135 |         xfree(progname_copy);
      |         ^
this stmt is child function---free-----

 ================== find ================== 
free (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:135:9: warning: use location
[40;32m    HAS FREE STMT count:1 name:free [0m

 ================== find ================== 
Py_SetProgramName (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:134:3: warning: use location
  134 |   Py_SetProgramName (progname_copy);
      |   ^
this stmt is child function---Py_SetProgramName-----

 ================== trace ================== 
trace fucntion name:Py_SetProgramName 
[40;44m =======trace_function_path Py_SetProgramName  function_call count: 1 level :0========  [0m
[40;36m ======= node_fun:Py_SetProgramName========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:printf========= [0m
[40;46m =======add node_fun stack:printf========= [0m

 ================== trace ================== 
trace fucntion free:1 
free (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:124:25: warning: use location
  124 |                         xfree(progname_copy);
      |                         ^
this stmt is child function---free-----

 ================== find ================== 
free (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:124:25: warning: use location
[40;32m    HAS FREE STMT count:2 name:free [0m

 ================== find ================== 

======================================================================
[40;31m    branch possiable have return or exit  [0m
if (progname_copy_23 == 0B)
bb index := 2
# VUSE <.MEM_30>
return _18;
In function â€˜do_start_initializationâ€™:
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 12

======================================================================
if (progname_copy_23 == 0B)
In function â€˜mainâ€™:
./benchmarks/binutils/leak_7/binutils_leak_7.c:114:6: warning: use location
  114 |   if (!progname_copy)
      |      ^
if (progname_copy_23 == 0B)

 ================== find cond branch ================= 
./benchmarks/binutils/leak_7/binutils_leak_7.c:114:6: warning: use location
Cond in fucntion do_start_initialization basic block 2
 ================== possible direct basic block ================= 
from do_start_initialization basic block 3
 ================== possible direct basic block ================= 
from do_start_initialization basic block 4
 ================== warring ================== 
[40;35m    need check this branch possible have return or exit stmt [0m

 ================== warring ================== 

 ================== find cond branch ================= 

======================================================================
[40;31m    branch possiable have return or exit  [0m
_6 = progsize_21 + 1;
bb index := 2
# VUSE <.MEM_30>
return _18;
In function â€˜do_start_initializationâ€™:
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 12

======================================================================
_6 = progsize_21 + 1;
In function â€˜mainâ€™:
./benchmarks/binutils/leak_7/binutils_leak_7.c:113:55: warning: use location
  113 |   progname_copy = (wchar_t *) PyMem_Malloc ((progsize + 1) * sizeof (wchar_t));
      |                                                       ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
_7 = _6 * 4;
bb index := 2
# VUSE <.MEM_30>
return _18;
In function â€˜do_start_initializationâ€™:
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 12

======================================================================
_7 = _6 * 4;
In function â€˜mainâ€™:
./benchmarks/binutils/leak_7/binutils_leak_7.c:113:31: warning: use location
  113 |   progname_copy = (wchar_t *) PyMem_Malloc ((progsize + 1) * sizeof (wchar_t));
      |                               ^

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7fe177694750
    type <pointer_type 0x7fe1771b5c78
        type <integer_type 0x7fe1771b59d8 char public QI
            size <integer_cst 0x7fe17768cca8 constant 8>
            unit-size <integer_cst 0x7fe17768ccc0 constant 1>
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7fe1776a13f0 precision:8 min <integer_cst 0x7fe1771ac720 -128> max <integer_cst 0x7fe1771ac708 127>
            pointer_to_this <pointer_type 0x7fe1771b5c78>>
        public unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality context <translation_unit_decl 0x7fe177697168 ./benchmarks/binutils/leak_7/binutils_leak_7.c>
        pointer_to_this <pointer_type 0x7fe1771bfbd0>>
   
    def_stmt _1 = python_libdir;
    version:1
    ptr-info 0x7fe1771ca798>

 ================== Start Use after free Check ================== 

============================================================
# .MEM_52 = VDEF <.MEM_51>
free (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:124:25: warning: Use after free error!: free location 
  124 |                         xfree(progname_copy);
      |                         ^
# .MEM_49 = VDEF <.MEM_48>
Py_SetProgramName (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:134:3: warning: use location
  134 |   Py_SetProgramName (progname_copy);
      |   ^

 ================== warring ================== 
[40;35m    Use after free error! [0m
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:0 [0m
[40;31m  	free count:2 [0m
[40;31m  	possible double free [rigorous]:2 [0m

======================================================================

======================================================================
[40;31m 	this stmt need double check [0m

======================================================================

dot graph START

======================================================================
 <ssa_name 0x7fe177694798
    type <pointer_type 0x7fe1771b5c78
        type <integer_type 0x7fe1771b59d8 char public QI
            size <integer_cst 0x7fe17768cca8 constant 8>
            unit-size <integer_cst 0x7fe17768ccc0 constant 1>
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7fe1776a13f0 precision:8 min <integer_cst 0x7fe1771ac720 -128> max <integer_cst 0x7fe1771ac708 127>
            pointer_to_this <pointer_type 0x7fe1771b5c78>>
        public unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality context <translation_unit_decl 0x7fe177697168 ./benchmarks/binutils/leak_7/binutils_leak_7.c>
        pointer_to_this <pointer_type 0x7fe1771bfbd0>>
   
    def_stmt _2 = ldirname (_1);
    version:2
    ptr-info 0x7fe1771ca7b0>
# .MEM_40 = VDEF <.MEM_39(D)>
_2 = ldirname (_1);

 ================== trace ptable================== 
trace fucntion name:ldirname 
[40;44m =======trace_function_path ldirname  function_call count: 3 level :888========  [0m
[40;36m ======= node_fun:ldirname========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:memcpy========= [0m
[40;46m =======add node_fun stack:memcpy========= [0m
[40;42m =======pre add _ fucntion:malloc========= [0m
[40;46m =======add node_fun stack:malloc========= [0m
[40;42m =======pre add _ fucntion:lbasename========= [0m
[40;46m =======add node_fun stack:lbasename========= [0m
[40;44m =======trace_function_path lbasename  function_call count: 1 level :889========  [0m
[40;36m ======= node_fun:lbasename========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:unix_lbasename========= [0m
[40;46m =======add node_fun stack:unix_lbasename========= [0m
[40;44m =======trace_function_path unix_lbasename  function_call count: 0 level :890========  [0m
[40;36m ======= node_fun:unix_lbasename========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
fucntion collect path finsh

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr---ldirname-----
this other function ------ldirname-----
 
 Start check Pointer Collect  

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_40 = VDEF <.MEM_39(D)>
_2 = ldirname (_1);
bb index := 2
# VUSE <.MEM_30>
return _18;
In function â€˜do_start_initializationâ€™:
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 12

======================================================================
_2 = ldirname (_1);
In function â€˜mainâ€™:
./benchmarks/binutils/leak_7/binutils_leak_7.c:109:22: warning: use location
  109 |   progname = concat (ldirname (python_libdir), "bin");
      |                      ^
this stmt is child function---ldirname-----

 ================== trace ================== 
trace fucntion name:ldirname 
[40;44m =======trace_function_path ldirname  function_call count: 3 level :0========  [0m
[40;36m ======= node_fun:ldirname========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:memcpy========= [0m
[40;46m =======add node_fun stack:memcpy========= [0m
[40;42m =======pre add _ fucntion:malloc========= [0m
[40;46m =======add node_fun stack:malloc========= [0m
[40;42m =======pre add _ fucntion:lbasename========= [0m
[40;46m =======add node_fun stack:lbasename========= [0m
[40;44m =======trace_function_path lbasename  function_call count: 1 level :1========  [0m
[40;36m ======= node_fun:lbasename========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:unix_lbasename========= [0m
[40;46m =======add node_fun stack:unix_lbasename========= [0m
[40;44m =======trace_function_path unix_lbasename  function_call count: 0 level :2========  [0m
[40;36m ======= node_fun:unix_lbasename========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
fucntion collect path finsh

 ================== trace ================== 
trace fucntion free:0 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_41 = VDEF <.MEM_40>
progname_16 = concat (_2, "bin");
bb index := 2
# VUSE <.MEM_30>
return _18;
In function â€˜do_start_initializationâ€™:
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 12

======================================================================
progname_16 = concat (_2, "bin");
In function â€˜mainâ€™:
./benchmarks/binutils/leak_7/binutils_leak_7.c:109:14: warning: use location
  109 |   progname = concat (ldirname (python_libdir), "bin");
      |              ^
this stmt is child function---concat-----

 ================== trace ================== 
trace fucntion name:concat 
[40;44m =======trace_function_path concat  function_call count: 2 level :0========  [0m
[40;36m ======= node_fun:concat========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:vconcat_copy========= [0m
[40;46m =======add node_fun stack:vconcat_copy========= [0m
[40;44m =======trace_function_path vconcat_copy  function_call count: 2 level :1========  [0m
[40;36m ======= node_fun:vconcat_copy========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:memcpy========= [0m
[40;46m =======add node_fun stack:memcpy========= [0m
[40;42m =======pre add _ fucntion:strlen========= [0m
[40;46m =======add node_fun stack:strlen========= [0m
[40;42m =======pre add _ fucntion:malloc========= [0m
[40;46m =======add node_fun stack:malloc========= [0m

 ================== trace ================== 
trace fucntion free:0 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# VUSE <.MEM_44>
progsize_21 = strlen (progname_16);
bb index := 2
# VUSE <.MEM_30>
return _18;
In function â€˜do_start_initializationâ€™:
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 12

======================================================================
progsize_21 = strlen (progname_16);
In function â€˜mainâ€™:
./benchmarks/binutils/leak_7/binutils_leak_7.c:112:14: warning: use location
  112 |   progsize = strlen (progname);
      |              ^
this stmt is child function---strlen-----

 ================== trace ================== 
trace fucntion name:strlen 

 ================== trace ================== 
trace fucntion free:0 
_9 = progsize_21 + 1;
./benchmarks/binutils/leak_7/binutils_leak_7.c:120:11: warning: use location
  120 |   count = mbstowcs (progname_copy, progname, progsize + 1);
      |           ^
count_25 = mbstowcs (progname_copy_23, progname_16, _9);
./benchmarks/binutils/leak_7/binutils_leak_7.c:120:11: warning: use location
this stmt is child function---mbstowcs-----

 ================== trace ================== 
trace fucntion name:mbstowcs 

 ================== trace ================== 
trace fucntion free:0 
if (count_25 == 18446744073709551615)
./benchmarks/binutils/leak_7/binutils_leak_7.c:121:6: warning: use location
  121 |   if (count == (size_t) -1)
      |      ^
if (count_25 == 18446744073709551615)

 ================== find cond branch ================= 
./benchmarks/binutils/leak_7/binutils_leak_7.c:121:6: warning: use location
Cond in fucntion do_start_initialization basic block 4
 ================== possible direct basic block ================= 
from do_start_initialization basic block 5
 ================== possible direct basic block ================= 
from do_start_initialization basic block 6
 ================== warring ================== 
[40;35m    need check this branch possible have return or exit stmt [0m

 ================== warring ================== 

 ================== find cond branch ================= 
free (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:135:9: warning: use location
  135 |         xfree(progname_copy);
      |         ^
this stmt is child function---free-----

 ================== find ================== 
free (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:135:9: warning: use location
[40;32m    HAS FREE STMT count:1 name:free [0m

 ================== find ================== 
Py_SetProgramName (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:134:3: warning: use location
  134 |   Py_SetProgramName (progname_copy);
      |   ^
this stmt is child function---Py_SetProgramName-----

 ================== trace ================== 
trace fucntion name:Py_SetProgramName 
[40;44m =======trace_function_path Py_SetProgramName  function_call count: 1 level :0========  [0m
[40;36m ======= node_fun:Py_SetProgramName========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:printf========= [0m
[40;46m =======add node_fun stack:printf========= [0m

 ================== trace ================== 
trace fucntion free:1 
free (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:124:25: warning: use location
  124 |                         xfree(progname_copy);
      |                         ^
this stmt is child function---free-----

 ================== find ================== 
free (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:124:25: warning: use location
[40;32m    HAS FREE STMT count:2 name:free [0m

 ================== find ================== 

======================================================================
[40;31m    branch possiable have return or exit  [0m
if (progname_copy_23 == 0B)
bb index := 2
# VUSE <.MEM_30>
return _18;
In function â€˜do_start_initializationâ€™:
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 12

======================================================================
if (progname_copy_23 == 0B)
In function â€˜mainâ€™:
./benchmarks/binutils/leak_7/binutils_leak_7.c:114:6: warning: use location
  114 |   if (!progname_copy)
      |      ^
if (progname_copy_23 == 0B)

 ================== find cond branch ================= 
./benchmarks/binutils/leak_7/binutils_leak_7.c:114:6: warning: use location
Cond in fucntion do_start_initialization basic block 2
 ================== possible direct basic block ================= 
from do_start_initialization basic block 3
 ================== possible direct basic block ================= 
from do_start_initialization basic block 4
 ================== warring ================== 
[40;35m    need check this branch possible have return or exit stmt [0m

 ================== warring ================== 

 ================== find cond branch ================= 

======================================================================
[40;31m    branch possiable have return or exit  [0m
_6 = progsize_21 + 1;
bb index := 2
# VUSE <.MEM_30>
return _18;
In function â€˜do_start_initializationâ€™:
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 12

======================================================================
_6 = progsize_21 + 1;
In function â€˜mainâ€™:
./benchmarks/binutils/leak_7/binutils_leak_7.c:113:55: warning: use location
  113 |   progname_copy = (wchar_t *) PyMem_Malloc ((progsize + 1) * sizeof (wchar_t));
      |                                                       ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
_7 = _6 * 4;
bb index := 2
# VUSE <.MEM_30>
return _18;
In function â€˜do_start_initializationâ€™:
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 12

======================================================================
_7 = _6 * 4;
In function â€˜mainâ€™:
./benchmarks/binutils/leak_7/binutils_leak_7.c:113:31: warning: use location
  113 |   progname_copy = (wchar_t *) PyMem_Malloc ((progsize + 1) * sizeof (wchar_t));
      |                               ^

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7fe177694798
    type <pointer_type 0x7fe1771b5c78
        type <integer_type 0x7fe1771b59d8 char public QI
            size <integer_cst 0x7fe17768cca8 constant 8>
            unit-size <integer_cst 0x7fe17768ccc0 constant 1>
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7fe1776a13f0 precision:8 min <integer_cst 0x7fe1771ac720 -128> max <integer_cst 0x7fe1771ac708 127>
            pointer_to_this <pointer_type 0x7fe1771b5c78>>
        public unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality context <translation_unit_decl 0x7fe177697168 ./benchmarks/binutils/leak_7/binutils_leak_7.c>
        pointer_to_this <pointer_type 0x7fe1771bfbd0>>
   
    def_stmt _2 = ldirname (_1);
    version:2
    ptr-info 0x7fe1771ca7b0>

 ================== Start Use after free Check ================== 

============================================================
# .MEM_52 = VDEF <.MEM_51>
free (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:124:25: warning: Use after free error!: free location 
  124 |                         xfree(progname_copy);
      |                         ^
# .MEM_49 = VDEF <.MEM_48>
Py_SetProgramName (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:134:3: warning: use location
  134 |   Py_SetProgramName (progname_copy);
      |   ^

 ================== warring ================== 
[40;35m    Use after free error! [0m
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:0 [0m
[40;31m  	free count:2 [0m
[40;31m  	possible double free [rigorous]:2 [0m

======================================================================

======================================================================
[40;31m 	this stmt need double check [0m

======================================================================

dot graph START

======================================================================
 <addr_expr 0x7fe177888ca0
    type <pointer_type 0x7fe1771c1000
        type <array_type 0x7fe1771bff18 type <integer_type 0x7fe1771b59d8 char>
            BLK
            size <integer_cst 0x7fe1771ac930 constant 56>
            unit-size <integer_cst 0x7fe1771ac918 constant 7>
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality domain <integer_type 0x7fe1771bfe70>
            pointer_to_this <pointer_type 0x7fe1771c1000>>
        unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
    readonly constant
    arg:0 <string_cst 0x7fe177888c80 type <array_type 0x7fe1771bff18>
        readonly constant static "LC_ALL\000">
    ./benchmarks/binutils/leak_7/binutils_leak_7.c:110:12 start: ./benchmarks/binutils/leak_7/binutils_leak_7.c:110:12 finish: ./benchmarks/binutils/leak_7/binutils_leak_7.c:110:12>

 ================== trace ptable================== 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr--------
this other function -----------

======================================================================
[40;35m  	Looserules free count:0 [0m
[40;31m  	free count:0 [0m

======================================================================

======================================================================
[40;31m 	Can't find this fucntion in Pointer table [0m
[40;31m 	Possiable no other stmt relate with this stmt [0m

======================================================================

dot graph START

======================================================================
 <ssa_name 0x7fe177694870
    type <pointer_type 0x7fe1771b5b28
        type <integer_type 0x7fe1771b5a80 char readonly public QI
            size <integer_cst 0x7fe17768cca8 constant 8>
            unit-size <integer_cst 0x7fe17768ccc0 constant 1>
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7fe1776a13f0 precision:8 min <integer_cst 0x7fe1771ac720 -128> max <integer_cst 0x7fe1771ac708 127>
            pointer_to_this <pointer_type 0x7fe1771b5b28>>
        public unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
   
    def_stmt _5 = (const char *) _4;
    version:5
    ptr-info 0x7fe1771ca7c8>
_5 = (const char *) _4;

 ================== trace ptable================== 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr--------
this other function -----------
 
 Start check Pointer Collect  

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_43 = VDEF <.MEM_42>
oldloc_19 = strdup (_5);
bb index := 2
# VUSE <.MEM_30>
return _18;
In function â€˜do_start_initializationâ€™:
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 12

======================================================================
oldloc_19 = strdup (_5);
In function â€˜mainâ€™:
./benchmarks/binutils/leak_7/binutils_leak_7.c:110:12: warning: use location
  110 |   oldloc = xstrdup (setlocale (LC_ALL, NULL));
      |            ^
this stmt is child function---strdup-----

 ================== trace ================== 
free (oldloc_19);
./benchmarks/binutils/leak_7/binutils_leak_7.c:129:3: warning: use location
  129 |   xfree (oldloc);
      |   ^
this stmt is child function---free-----

 ================== find ================== 
free (oldloc_19);
./benchmarks/binutils/leak_7/binutils_leak_7.c:129:3: warning: use location
[40;32m    HAS FREE STMT count:1 name:free [0m

 ================== find ================== 
setlocale ("LC_ALL", oldloc_19);
./benchmarks/binutils/leak_7/binutils_leak_7.c:128:3: warning: use location
  128 |   setlocale (LC_ALL, oldloc);
      |   ^
this stmt is child function---setlocale-----

 ================== trace ================== 
trace fucntion name:setlocale 

 ================== trace ================== 
trace fucntion free:1 
free (oldloc_19);
./benchmarks/binutils/leak_7/binutils_leak_7.c:123:7: warning: use location
  123 |       xfree (oldloc);
      |       ^
this stmt is child function---free-----

 ================== find ================== 
free (oldloc_19);
./benchmarks/binutils/leak_7/binutils_leak_7.c:123:7: warning: use location
[40;32m    HAS FREE STMT count:2 name:free [0m

 ================== find ================== 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_54 = VDEF <.MEM_45>
free (oldloc_19);
bb index := 3
# VUSE <.MEM_30>
return _18;
In function â€˜do_start_initializationâ€™:
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 3 ,possiable got to succ := 12

======================================================================
free (oldloc_19);
In function â€˜mainâ€™:
./benchmarks/binutils/leak_7/binutils_leak_7.c:116:7: warning: use location
  116 |       xfree (oldloc);
      |       ^
this stmt is child function---free-----

 ================== find ================== 
free (oldloc_19);
./benchmarks/binutils/leak_7/binutils_leak_7.c:116:7: warning: use location
[40;32m    HAS FREE STMT count:3 name:free [0m

 ================== find ================== 

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7fe177694870
    type <pointer_type 0x7fe1771b5b28
        type <integer_type 0x7fe1771b5a80 char readonly public QI
            size <integer_cst 0x7fe17768cca8 constant 8>
            unit-size <integer_cst 0x7fe17768ccc0 constant 1>
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7fe1776a13f0 precision:8 min <integer_cst 0x7fe1771ac720 -128> max <integer_cst 0x7fe1771ac708 127>
            pointer_to_this <pointer_type 0x7fe1771b5b28>>
        public unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
   
    def_stmt _5 = (const char *) _4;
    version:5
    ptr-info 0x7fe1771ca7c8>
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_54 = VDEF <.MEM_45>
free (oldloc_19);
./benchmarks/binutils/leak_7/binutils_leak_7.c:116:7: warning: use location
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_51 = VDEF <.MEM_46>
free (oldloc_19);
./benchmarks/binutils/leak_7/binutils_leak_7.c:123:7: warning: use location
  123 |       xfree (oldloc);
      |       ^
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_52 = VDEF <.MEM_51>
free (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:124:25: warning: use location
  124 |                         xfree(progname_copy);
      |                         ^
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_48 = VDEF <.MEM_47>
free (oldloc_19);
./benchmarks/binutils/leak_7/binutils_leak_7.c:129:3: warning: use location
  129 |   xfree (oldloc);
      |   ^
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_50 = VDEF <.MEM_49>
free (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:135:9: warning: use location
  135 |         xfree(progname_copy);
      |         ^

 ================== Start Use after free Check ================== 

============================================================
# .MEM_51 = VDEF <.MEM_46>
free (oldloc_19);
./benchmarks/binutils/leak_7/binutils_leak_7.c:123:7: warning: Use after free error!: free location 
  123 |       xfree (oldloc);
      |       ^
# .MEM_47 = VDEF <.MEM_46>
setlocale ("LC_ALL", oldloc_19);
./benchmarks/binutils/leak_7/binutils_leak_7.c:128:3: warning: use location
  128 |   setlocale (LC_ALL, oldloc);
      |   ^

 ================== warring ================== 
[40;35m    Use after free error! [0m
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
# .MEM_54 = VDEF <.MEM_45>
free (oldloc_19);
./benchmarks/binutils/leak_7/binutils_leak_7.c:116:7: warning: Use after free error!: free location 
  116 |       xfree (oldloc);
      |       ^
# .MEM_47 = VDEF <.MEM_46>
setlocale ("LC_ALL", oldloc_19);
./benchmarks/binutils/leak_7/binutils_leak_7.c:128:3: warning: use location
  128 |   setlocale (LC_ALL, oldloc);
      |   ^

 ================== warring ================== 
[40;35m    Use after free error! [0m
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_54 = VDEF <.MEM_45>
free (oldloc_19);
./benchmarks/binutils/leak_7/binutils_leak_7.c:116:7: warning: Use after free error!: free location 
  116 |       xfree (oldloc);
      |       ^
# .MEM_47 = VDEF <.MEM_46>
setlocale ("LC_ALL", oldloc_19);
./benchmarks/binutils/leak_7/binutils_leak_7.c:128:3: warning: use location
  128 |   setlocale (LC_ALL, oldloc);
      |   ^

 ================== warring ================== 
[40;35m    Use after free error! [0m
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_51 = VDEF <.MEM_46>
free (oldloc_19);
./benchmarks/binutils/leak_7/binutils_leak_7.c:123:7: warning: Use after free error!: free location 
  123 |       xfree (oldloc);
      |       ^
# .MEM_47 = VDEF <.MEM_46>
setlocale ("LC_ALL", oldloc_19);
./benchmarks/binutils/leak_7/binutils_leak_7.c:128:3: warning: use location
  128 |   setlocale (LC_ALL, oldloc);
      |   ^

 ================== warring ================== 
[40;35m    Use after free error! [0m
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_52 = VDEF <.MEM_51>
free (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:124:25: warning: Use after free error!: free location 
  124 |                         xfree(progname_copy);
      |                         ^
# .MEM_47 = VDEF <.MEM_46>
setlocale ("LC_ALL", oldloc_19);
./benchmarks/binutils/leak_7/binutils_leak_7.c:128:3: warning: use location
  128 |   setlocale (LC_ALL, oldloc);
      |   ^

 ================== warring ================== 
[40;35m    Use after free error! [0m
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:5 [0m
[40;31m  	free count:3 [0m
[40;31m  	possible double free [Looserules]:5 [0m
[40;31m  	possible double free [rigorous]:3 [0m

======================================================================

======================================================================
[40;31m  	possible double free [rigorous]:3 [0m

======================================================================

dot graph START

======================================================================
 <addr_expr 0x7fe177888d20
    type <pointer_type 0x7fe1771c1000
        type <array_type 0x7fe1771bff18 type <integer_type 0x7fe1771b59d8 char>
            BLK
            size <integer_cst 0x7fe1771ac930 constant 56>
            unit-size <integer_cst 0x7fe1771ac918 constant 7>
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality domain <integer_type 0x7fe1771bfe70>
            pointer_to_this <pointer_type 0x7fe1771c1000>>
        unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
    readonly constant
    arg:0 <string_cst 0x7fe177888d00 type <array_type 0x7fe1771bff18>
        readonly constant static "LC_ALL\000">
    ./benchmarks/binutils/leak_7/binutils_leak_7.c:111:14 start: ./benchmarks/binutils/leak_7/binutils_leak_7.c:111:14 finish: ./benchmarks/binutils/leak_7/binutils_leak_7.c:111:14>

 ================== trace ptable================== 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr--------
this other function -----------

======================================================================
[40;35m  	Looserules free count:0 [0m
[40;31m  	free count:0 [0m

======================================================================

======================================================================
[40;31m 	Can't find this fucntion in Pointer table [0m
[40;31m 	Possiable no other stmt relate with this stmt [0m

======================================================================

dot graph START

======================================================================
 <ssa_name 0x7fe177694a68
    type <pointer_type 0x7fe1771b5c78
        type <integer_type 0x7fe1771b59d8 char public QI
            size <integer_cst 0x7fe17768cca8 constant 8>
            unit-size <integer_cst 0x7fe17768ccc0 constant 1>
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7fe1776a13f0 precision:8 min <integer_cst 0x7fe1771ac720 -128> max <integer_cst 0x7fe1771ac708 127>
            pointer_to_this <pointer_type 0x7fe1771b5c78>>
        public unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality context <translation_unit_decl 0x7fe177697168 ./benchmarks/binutils/leak_7/binutils_leak_7.c>
        pointer_to_this <pointer_type 0x7fe1771bfbd0>>
    var <var_decl 0x7fe1771cf360 progname>
    def_stmt progname_16 = concat (_2, "bin");
    version:16
    ptr-info 0x7fe1771ca810>
# .MEM_41 = VDEF <.MEM_40>
progname_16 = concat (_2, "bin");

 ================== trace ptable================== 
trace fucntion name:concat 
[40;44m =======trace_function_path concat  function_call count: 2 level :888========  [0m
[40;36m ======= node_fun:concat========= [0m
[40;36m ======= find relate stmt with progname ========= [0m
[40;36m ======= relate stmt argument:progname ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:vconcat_copy========= [0m
[40;46m =======add node_fun stack:vconcat_copy========= [0m
[40;44m =======trace_function_path vconcat_copy  function_call count: 2 level :889========  [0m
[40;36m ======= node_fun:vconcat_copy========= [0m
[40;36m ======= find relate stmt with progname ========= [0m
[40;36m ======= relate stmt argument:progname ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:memcpy========= [0m
[40;46m =======add node_fun stack:memcpy========= [0m
[40;42m =======pre add _ fucntion:strlen========= [0m
[40;46m =======add node_fun stack:strlen========= [0m
[40;42m =======pre add _ fucntion:malloc========= [0m
[40;46m =======add node_fun stack:malloc========= [0m

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr---concat-----
this other function ------concat-----
 
 Start check Pointer Collect  

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_41 = VDEF <.MEM_40>
progname_16 = concat (_2, "bin");
bb index := 2
# VUSE <.MEM_30>
return _18;
In function â€˜do_start_initializationâ€™:
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 12

======================================================================
progname_16 = concat (_2, "bin");
In function â€˜mainâ€™:
./benchmarks/binutils/leak_7/binutils_leak_7.c:109:14: warning: use location
  109 |   progname = concat (ldirname (python_libdir), "bin");
      |              ^
this stmt is child function---concat-----

 ================== trace ================== 
trace fucntion name:concat 
[40;44m =======trace_function_path concat  function_call count: 2 level :0========  [0m
[40;36m ======= node_fun:concat========= [0m
[40;36m ======= find relate stmt with progname ========= [0m
[40;36m ======= relate stmt argument:progname ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:vconcat_copy========= [0m
[40;46m =======add node_fun stack:vconcat_copy========= [0m
[40;44m =======trace_function_path vconcat_copy  function_call count: 2 level :1========  [0m
[40;36m ======= node_fun:vconcat_copy========= [0m
[40;36m ======= find relate stmt with progname ========= [0m
[40;36m ======= relate stmt argument:progname ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:memcpy========= [0m
[40;46m =======add node_fun stack:memcpy========= [0m
[40;42m =======pre add _ fucntion:strlen========= [0m
[40;46m =======add node_fun stack:strlen========= [0m
[40;42m =======pre add _ fucntion:malloc========= [0m
[40;46m =======add node_fun stack:malloc========= [0m

 ================== trace ================== 
trace fucntion free:0 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# VUSE <.MEM_44>
progsize_21 = strlen (progname_16);
bb index := 2
# VUSE <.MEM_30>
return _18;
In function â€˜do_start_initializationâ€™:
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 12

======================================================================
progsize_21 = strlen (progname_16);
In function â€˜mainâ€™:
./benchmarks/binutils/leak_7/binutils_leak_7.c:112:14: warning: use location
  112 |   progsize = strlen (progname);
      |              ^
this stmt is child function---strlen-----

 ================== trace ================== 
trace fucntion name:strlen 

 ================== trace ================== 
trace fucntion free:0 
_9 = progsize_21 + 1;
./benchmarks/binutils/leak_7/binutils_leak_7.c:120:11: warning: use location
  120 |   count = mbstowcs (progname_copy, progname, progsize + 1);
      |           ^
count_25 = mbstowcs (progname_copy_23, progname_16, _9);
./benchmarks/binutils/leak_7/binutils_leak_7.c:120:11: warning: use location
this stmt is child function---mbstowcs-----

 ================== trace ================== 
trace fucntion name:mbstowcs 

 ================== trace ================== 
trace fucntion free:0 
if (count_25 == 18446744073709551615)
./benchmarks/binutils/leak_7/binutils_leak_7.c:121:6: warning: use location
  121 |   if (count == (size_t) -1)
      |      ^
if (count_25 == 18446744073709551615)

 ================== find cond branch ================= 
./benchmarks/binutils/leak_7/binutils_leak_7.c:121:6: warning: use location
Cond in fucntion do_start_initialization basic block 4
 ================== possible direct basic block ================= 
from do_start_initialization basic block 5
 ================== possible direct basic block ================= 
from do_start_initialization basic block 6
 ================== warring ================== 
[40;35m    need check this branch possible have return or exit stmt [0m

 ================== warring ================== 

 ================== find cond branch ================= 
free (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:135:9: warning: use location
  135 |         xfree(progname_copy);
      |         ^
this stmt is child function---free-----

 ================== find ================== 
free (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:135:9: warning: use location
[40;32m    HAS FREE STMT count:1 name:free [0m

 ================== find ================== 
Py_SetProgramName (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:134:3: warning: use location
  134 |   Py_SetProgramName (progname_copy);
      |   ^
this stmt is child function---Py_SetProgramName-----

 ================== trace ================== 
trace fucntion name:Py_SetProgramName 
[40;44m =======trace_function_path Py_SetProgramName  function_call count: 1 level :0========  [0m
[40;36m ======= node_fun:Py_SetProgramName========= [0m
[40;36m ======= find relate stmt with progname ========= [0m
[40;36m ======= relate stmt argument:progname ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:printf========= [0m
[40;46m =======add node_fun stack:printf========= [0m

 ================== trace ================== 
trace fucntion free:1 
free (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:124:25: warning: use location
  124 |                         xfree(progname_copy);
      |                         ^
this stmt is child function---free-----

 ================== find ================== 
free (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:124:25: warning: use location
[40;32m    HAS FREE STMT count:2 name:free [0m

 ================== find ================== 

======================================================================
[40;31m    branch possiable have return or exit  [0m
if (progname_copy_23 == 0B)
bb index := 2
# VUSE <.MEM_30>
return _18;
In function â€˜do_start_initializationâ€™:
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 12

======================================================================
if (progname_copy_23 == 0B)
In function â€˜mainâ€™:
./benchmarks/binutils/leak_7/binutils_leak_7.c:114:6: warning: use location
  114 |   if (!progname_copy)
      |      ^
if (progname_copy_23 == 0B)

 ================== find cond branch ================= 
./benchmarks/binutils/leak_7/binutils_leak_7.c:114:6: warning: use location
Cond in fucntion do_start_initialization basic block 2
 ================== possible direct basic block ================= 
from do_start_initialization basic block 3
 ================== possible direct basic block ================= 
from do_start_initialization basic block 4
 ================== warring ================== 
[40;35m    need check this branch possible have return or exit stmt [0m

 ================== warring ================== 

 ================== find cond branch ================= 

======================================================================
[40;31m    branch possiable have return or exit  [0m
_6 = progsize_21 + 1;
bb index := 2
# VUSE <.MEM_30>
return _18;
In function â€˜do_start_initializationâ€™:
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 12

======================================================================
_6 = progsize_21 + 1;
In function â€˜mainâ€™:
./benchmarks/binutils/leak_7/binutils_leak_7.c:113:55: warning: use location
  113 |   progname_copy = (wchar_t *) PyMem_Malloc ((progsize + 1) * sizeof (wchar_t));
      |                                                       ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
_7 = _6 * 4;
bb index := 2
# VUSE <.MEM_30>
return _18;
In function â€˜do_start_initializationâ€™:
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 12

======================================================================
_7 = _6 * 4;
In function â€˜mainâ€™:
./benchmarks/binutils/leak_7/binutils_leak_7.c:113:31: warning: use location
  113 |   progname_copy = (wchar_t *) PyMem_Malloc ((progsize + 1) * sizeof (wchar_t));
      |                               ^

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7fe177694a68
    type <pointer_type 0x7fe1771b5c78
        type <integer_type 0x7fe1771b59d8 char public QI
            size <integer_cst 0x7fe17768cca8 constant 8>
            unit-size <integer_cst 0x7fe17768ccc0 constant 1>
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7fe1776a13f0 precision:8 min <integer_cst 0x7fe1771ac720 -128> max <integer_cst 0x7fe1771ac708 127>
            pointer_to_this <pointer_type 0x7fe1771b5c78>>
        public unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality context <translation_unit_decl 0x7fe177697168 ./benchmarks/binutils/leak_7/binutils_leak_7.c>
        pointer_to_this <pointer_type 0x7fe1771bfbd0>>
    var <var_decl 0x7fe1771cf360 progname>
    def_stmt progname_16 = concat (_2, "bin");
    version:16
    ptr-info 0x7fe1771ca810>

 ================== Start Use after free Check ================== 

============================================================
# .MEM_52 = VDEF <.MEM_51>
free (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:124:25: warning: Use after free error!: free location 
  124 |                         xfree(progname_copy);
      |                         ^
# .MEM_49 = VDEF <.MEM_48>
Py_SetProgramName (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:134:3: warning: use location
  134 |   Py_SetProgramName (progname_copy);
      |   ^

 ================== warring ================== 
[40;35m    Use after free error! [0m
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:0 [0m
[40;31m  	free count:2 [0m
[40;31m  	possible double free [rigorous]:2 [0m

======================================================================

======================================================================
[40;31m 	this stmt need double check [0m

======================================================================

dot graph START

======================================================================
 <ssa_name 0x7fe177694900
    type <integer_type 0x7fe1776a17e0 long unsigned int public unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7fe1776a1738 precision:64 min <integer_cst 0x7fe17768ce88 0> max <integer_cst 0x7fe17768d500 18446744073709551615>
        pointer_to_this <pointer_type 0x7fe1776ad7e0>>
   
    def_stmt _7 = _6 * 4;
    version:7>
_7 = _6 * 4;

 ================== trace ptable================== 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr--------
this other function -----------
 
 Start check Pointer Collect  

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_45 = VDEF <.MEM_44>
progname_copy_23 = PyMem_Malloc (_7);
bb index := 2
# VUSE <.MEM_30>
return _18;
In function â€˜do_start_initializationâ€™:
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 12

======================================================================
progname_copy_23 = PyMem_Malloc (_7);
In function â€˜mainâ€™:
./benchmarks/binutils/leak_7/binutils_leak_7.c:113:31: warning: use location
  113 |   progname_copy = (wchar_t *) PyMem_Malloc ((progsize + 1) * sizeof (wchar_t));
      |                               ^
this stmt is child function---PyMem_Malloc-----

 ================== trace ================== 
trace fucntion name:PyMem_Malloc 
[40;44m =======trace_function_path PyMem_Malloc  function_call count: 1 level :0========  [0m
[40;42m =======pre add _ fucntion:malloc========= [0m
[40;46m =======add node_fun stack:malloc========= [0m

 ================== trace ================== 
trace fucntion free:0 
free (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:135:9: warning: use location
  135 |         xfree(progname_copy);
      |         ^
this stmt is child function---free-----

 ================== find ================== 
free (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:135:9: warning: use location
[40;32m    HAS FREE STMT count:1 name:free [0m

 ================== find ================== 
Py_SetProgramName (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:134:3: warning: use location
  134 |   Py_SetProgramName (progname_copy);
      |   ^
this stmt is child function---Py_SetProgramName-----

 ================== trace ================== 
trace fucntion name:Py_SetProgramName 
[40;44m =======trace_function_path Py_SetProgramName  function_call count: 1 level :0========  [0m
[40;42m =======pre add _ fucntion:printf========= [0m
[40;46m =======add node_fun stack:printf========= [0m

 ================== trace ================== 
trace fucntion free:1 
free (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:124:25: warning: use location
  124 |                         xfree(progname_copy);
      |                         ^
this stmt is child function---free-----

 ================== find ================== 
free (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:124:25: warning: use location
[40;32m    HAS FREE STMT count:2 name:free [0m

 ================== find ================== 
count_25 = mbstowcs (progname_copy_23, progname_16, _9);
./benchmarks/binutils/leak_7/binutils_leak_7.c:120:11: warning: use location
  120 |   count = mbstowcs (progname_copy, progname, progsize + 1);
      |           ^
this stmt is child function---mbstowcs-----

 ================== trace ================== 
trace fucntion name:mbstowcs 

 ================== trace ================== 
trace fucntion free:2 
if (count_25 == 18446744073709551615)
./benchmarks/binutils/leak_7/binutils_leak_7.c:121:6: warning: use location
  121 |   if (count == (size_t) -1)
      |      ^
if (count_25 == 18446744073709551615)

 ================== find cond branch ================= 
./benchmarks/binutils/leak_7/binutils_leak_7.c:121:6: warning: use location
Cond in fucntion do_start_initialization basic block 4
 ================== possible direct basic block ================= 
from do_start_initialization basic block 5
 ================== possible direct basic block ================= 
from do_start_initialization basic block 6
 ================== warring ================== 
[40;35m    need check this branch possible have return or exit stmt [0m

 ================== warring ================== 

 ================== find cond branch ================= 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# VUSE <.MEM_44>
progsize_21 = strlen (progname_16);
bb index := 2
# VUSE <.MEM_30>
return _18;
In function â€˜do_start_initializationâ€™:
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 12

======================================================================
progsize_21 = strlen (progname_16);
In function â€˜mainâ€™:
./benchmarks/binutils/leak_7/binutils_leak_7.c:112:14: warning: use location
  112 |   progsize = strlen (progname);
      |              ^
this stmt is child function---strlen-----

 ================== trace ================== 
trace fucntion name:strlen 

 ================== trace ================== 
trace fucntion free:2 
_9 = progsize_21 + 1;
./benchmarks/binutils/leak_7/binutils_leak_7.c:120:11: warning: use location
  120 |   count = mbstowcs (progname_copy, progname, progsize + 1);
      |           ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
_6 = progsize_21 + 1;
bb index := 2
# VUSE <.MEM_30>
return _18;
In function â€˜do_start_initializationâ€™:
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 12

======================================================================
_6 = progsize_21 + 1;
In function â€˜mainâ€™:
./benchmarks/binutils/leak_7/binutils_leak_7.c:113:55: warning: use location
  113 |   progname_copy = (wchar_t *) PyMem_Malloc ((progsize + 1) * sizeof (wchar_t));
      |                                                       ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
_7 = _6 * 4;
bb index := 2
# VUSE <.MEM_30>
return _18;
In function â€˜do_start_initializationâ€™:
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 12

======================================================================
_7 = _6 * 4;
In function â€˜mainâ€™:
./benchmarks/binutils/leak_7/binutils_leak_7.c:113:31: warning: use location
  113 |   progname_copy = (wchar_t *) PyMem_Malloc ((progsize + 1) * sizeof (wchar_t));
      |                               ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
if (progname_copy_23 == 0B)
bb index := 2
# VUSE <.MEM_30>
return _18;
In function â€˜do_start_initializationâ€™:
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 12

======================================================================
if (progname_copy_23 == 0B)
In function â€˜mainâ€™:
./benchmarks/binutils/leak_7/binutils_leak_7.c:114:6: warning: use location
  114 |   if (!progname_copy)
      |      ^
if (progname_copy_23 == 0B)

 ================== find cond branch ================= 
./benchmarks/binutils/leak_7/binutils_leak_7.c:114:6: warning: use location
Cond in fucntion do_start_initialization basic block 2
 ================== possible direct basic block ================= 
from do_start_initialization basic block 3
 ================== possible direct basic block ================= 
from do_start_initialization basic block 4
 ================== warring ================== 
[40;35m    need check this branch possible have return or exit stmt [0m

 ================== warring ================== 

 ================== find cond branch ================= 

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7fe177694900
    type <integer_type 0x7fe1776a17e0 long unsigned int public unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7fe1776a1738 precision:64 min <integer_cst 0x7fe17768ce88 0> max <integer_cst 0x7fe17768d500 18446744073709551615>
        pointer_to_this <pointer_type 0x7fe1776ad7e0>>
   
    def_stmt _7 = _6 * 4;
    version:7>
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_54 = VDEF <.MEM_45>
free (oldloc_19);
./benchmarks/binutils/leak_7/binutils_leak_7.c:116:7: warning: use location
  116 |       xfree (oldloc);
      |       ^
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_51 = VDEF <.MEM_46>
free (oldloc_19);
./benchmarks/binutils/leak_7/binutils_leak_7.c:123:7: warning: use location
  123 |       xfree (oldloc);
      |       ^
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_52 = VDEF <.MEM_51>
free (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:124:25: warning: use location
  124 |                         xfree(progname_copy);
      |                         ^
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_48 = VDEF <.MEM_47>
free (oldloc_19);
./benchmarks/binutils/leak_7/binutils_leak_7.c:129:3: warning: use location
  129 |   xfree (oldloc);
      |   ^
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_50 = VDEF <.MEM_49>
free (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:135:9: warning: use location
  135 |         xfree(progname_copy);
      |         ^

 ================== Start Use after free Check ================== 

============================================================
# .MEM_52 = VDEF <.MEM_51>
free (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:124:25: warning: Use after free error!: free location 
  124 |                         xfree(progname_copy);
      |                         ^
# .MEM_49 = VDEF <.MEM_48>
Py_SetProgramName (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:134:3: warning: use location
  134 |   Py_SetProgramName (progname_copy);
      |   ^

 ================== warring ================== 
[40;35m    Use after free error! [0m
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_54 = VDEF <.MEM_45>
free (oldloc_19);
./benchmarks/binutils/leak_7/binutils_leak_7.c:116:7: warning: Use after free error!: free location 
  116 |       xfree (oldloc);
      |       ^
# .MEM_49 = VDEF <.MEM_48>
Py_SetProgramName (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:134:3: warning: use location
  134 |   Py_SetProgramName (progname_copy);
      |   ^

 ================== warring ================== 
[40;35m    Use after free error! [0m
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_51 = VDEF <.MEM_46>
free (oldloc_19);
./benchmarks/binutils/leak_7/binutils_leak_7.c:123:7: warning: Use after free error!: free location 
  123 |       xfree (oldloc);
      |       ^
# .MEM_49 = VDEF <.MEM_48>
Py_SetProgramName (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:134:3: warning: use location
  134 |   Py_SetProgramName (progname_copy);
      |   ^

 ================== warring ================== 
[40;35m    Use after free error! [0m
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_52 = VDEF <.MEM_51>
free (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:124:25: warning: Use after free error!: free location 
  124 |                         xfree(progname_copy);
      |                         ^
# .MEM_49 = VDEF <.MEM_48>
Py_SetProgramName (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:134:3: warning: use location
  134 |   Py_SetProgramName (progname_copy);
      |   ^

 ================== warring ================== 
[40;35m    Use after free error! [0m
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_48 = VDEF <.MEM_47>
free (oldloc_19);
./benchmarks/binutils/leak_7/binutils_leak_7.c:129:3: warning: Use after free error!: free location 
  129 |   xfree (oldloc);
      |   ^
# .MEM_49 = VDEF <.MEM_48>
Py_SetProgramName (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:134:3: warning: use location
  134 |   Py_SetProgramName (progname_copy);
      |   ^

 ================== warring ================== 
[40;35m    Use after free error! [0m
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_54 = VDEF <.MEM_45>
free (oldloc_19);
./benchmarks/binutils/leak_7/binutils_leak_7.c:116:7: warning: Use after free error!: free location 
  116 |       xfree (oldloc);
      |       ^
# .MEM_46 = VDEF <.MEM_45>
count_25 = mbstowcs (progname_copy_23, progname_16, _9);
./benchmarks/binutils/leak_7/binutils_leak_7.c:120:11: warning: use location
  120 |   count = mbstowcs (progname_copy, progname, progsize + 1);
      |           ^

 ================== warring ================== 
[40;35m    Use after free error! [0m
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_54 = VDEF <.MEM_45>
free (oldloc_19);
./benchmarks/binutils/leak_7/binutils_leak_7.c:116:7: warning: Use after free error!: free location 
  116 |       xfree (oldloc);
      |       ^
if (count_25 == 18446744073709551615)
./benchmarks/binutils/leak_7/binutils_leak_7.c:121:6: warning: use location
  121 |   if (count == (size_t) -1)
      |      ^

 ================== warring ================== 
[40;35m    Use after free error! [0m
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_54 = VDEF <.MEM_45>
free (oldloc_19);
./benchmarks/binutils/leak_7/binutils_leak_7.c:116:7: warning: Use after free error!: free location 
  116 |       xfree (oldloc);
      |       ^
_9 = progsize_21 + 1;
./benchmarks/binutils/leak_7/binutils_leak_7.c:120:11: warning: use location
  120 |   count = mbstowcs (progname_copy, progname, progsize + 1);
      |           ^

 ================== warring ================== 
[40;35m    Use after free error! [0m
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:5 [0m
[40;31m  	free count:2 [0m
[40;31m  	possible double free [Looserules]:5 [0m
[40;31m  	possible double free [rigorous]:2 [0m

======================================================================

======================================================================
[40;31m 	this stmt need double check [0m

======================================================================

dot graph START

======================================================================
 <addr_expr 0x7fe177888e00
    type <pointer_type 0x7fe1771c15e8
        type <array_type 0x7fe1771c1540 type <integer_type 0x7fe1771b59d8 char>
            BLK
            size <integer_cst 0x7fe1771ac978 constant 120>
            unit-size <integer_cst 0x7fe1771ac960 constant 15>
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality domain <integer_type 0x7fe1771c1498>
            pointer_to_this <pointer_type 0x7fe1771c15e8>>
        unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
    readonly constant
    arg:0 <string_cst 0x7fe1771cb9d8 type <array_type 0x7fe1771c1540>
        readonly constant static "out of memory\012\000">
    ./benchmarks/binutils/leak_7/binutils_leak_7.c:117:24 start: ./benchmarks/binutils/leak_7/binutils_leak_7.c:117:24 finish: ./benchmarks/binutils/leak_7/binutils_leak_7.c:117:24>

 ================== trace ptable================== 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr--------
this other function -----------

======================================================================
[40;35m  	Looserules free count:0 [0m
[40;31m  	free count:0 [0m

======================================================================

======================================================================
[40;31m 	Can't find this fucntion in Pointer table [0m
[40;31m 	Possiable no other stmt relate with this stmt [0m

======================================================================

dot graph START

======================================================================
 <ssa_name 0x7fe177694b40
    type <pointer_type 0x7fe1771bf2a0
        type <integer_type 0x7fe1771bf1f8 wchar_t SI
            size <integer_cst 0x7fe17768cdf8 constant 32>
            unit-size <integer_cst 0x7fe17768ce10 constant 4>
            align:32 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7fe1776a15e8 precision:32 min <integer_cst 0x7fe17768cdb0 -2147483648> max <integer_cst 0x7fe17768cdc8 2147483647> context <translation_unit_decl 0x7fe177697168 ./benchmarks/binutils/leak_7/binutils_leak_7.c>
            pointer_to_this <pointer_type 0x7fe1771bf2a0>>
        public unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
    var <var_decl 0x7fe1771cf120 progname_copy>
    def_stmt progname_copy_23 = PyMem_Malloc (_7);
    version:23
    ptr-info 0x7fe1771ca840>
# .MEM_45 = VDEF <.MEM_44>
progname_copy_23 = PyMem_Malloc (_7);

 ================== trace ptable================== 
trace fucntion name:PyMem_Malloc 
[40;44m =======trace_function_path PyMem_Malloc  function_call count: 1 level :888========  [0m
[40;36m ======= node_fun:PyMem_Malloc========= [0m
[40;36m ======= find relate stmt with progname_copy ========= [0m
[40;36m ======= relate stmt argument:progname_copy ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:malloc========= [0m
[40;46m =======add node_fun stack:malloc========= [0m

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr---PyMem_Malloc-----
this other function ------PyMem_Malloc-----
 
 Start check Pointer Collect  

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_45 = VDEF <.MEM_44>
progname_copy_23 = PyMem_Malloc (_7);
bb index := 2
# VUSE <.MEM_30>
return _18;
In function â€˜do_start_initializationâ€™:
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 12

======================================================================
progname_copy_23 = PyMem_Malloc (_7);
In function â€˜mainâ€™:
./benchmarks/binutils/leak_7/binutils_leak_7.c:113:31: warning: use location
  113 |   progname_copy = (wchar_t *) PyMem_Malloc ((progsize + 1) * sizeof (wchar_t));
      |                               ^
this stmt is child function---PyMem_Malloc-----

 ================== trace ================== 
trace fucntion name:PyMem_Malloc 
[40;44m =======trace_function_path PyMem_Malloc  function_call count: 1 level :0========  [0m
[40;36m ======= node_fun:PyMem_Malloc========= [0m
[40;36m ======= find relate stmt with progname_copy ========= [0m
[40;36m ======= relate stmt argument:progname_copy ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:malloc========= [0m
[40;46m =======add node_fun stack:malloc========= [0m

 ================== trace ================== 
trace fucntion free:0 
free (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:135:9: warning: use location
  135 |         xfree(progname_copy);
      |         ^
this stmt is child function---free-----

 ================== find ================== 
free (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:135:9: warning: use location
[40;32m    HAS FREE STMT count:1 name:free [0m

 ================== find ================== 
Py_SetProgramName (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:134:3: warning: use location
  134 |   Py_SetProgramName (progname_copy);
      |   ^
this stmt is child function---Py_SetProgramName-----

 ================== trace ================== 
trace fucntion name:Py_SetProgramName 
[40;44m =======trace_function_path Py_SetProgramName  function_call count: 1 level :0========  [0m
[40;36m ======= node_fun:Py_SetProgramName========= [0m
[40;36m ======= find relate stmt with progname_copy ========= [0m
[40;36m ======= relate stmt argument:progname_copy ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:printf========= [0m
[40;46m =======add node_fun stack:printf========= [0m

 ================== trace ================== 
trace fucntion free:1 
free (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:124:25: warning: use location
  124 |                         xfree(progname_copy);
      |                         ^
this stmt is child function---free-----

 ================== find ================== 
free (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:124:25: warning: use location
[40;32m    HAS FREE STMT count:2 name:free [0m

 ================== find ================== 
count_25 = mbstowcs (progname_copy_23, progname_16, _9);
./benchmarks/binutils/leak_7/binutils_leak_7.c:120:11: warning: use location
  120 |   count = mbstowcs (progname_copy, progname, progsize + 1);
      |           ^
this stmt is child function---mbstowcs-----

 ================== trace ================== 
trace fucntion name:mbstowcs 

 ================== trace ================== 
trace fucntion free:2 
if (count_25 == 18446744073709551615)
./benchmarks/binutils/leak_7/binutils_leak_7.c:121:6: warning: use location
  121 |   if (count == (size_t) -1)
      |      ^
if (count_25 == 18446744073709551615)

 ================== find cond branch ================= 
./benchmarks/binutils/leak_7/binutils_leak_7.c:121:6: warning: use location
Cond in fucntion do_start_initialization basic block 4
 ================== possible direct basic block ================= 
from do_start_initialization basic block 5
 ================== possible direct basic block ================= 
from do_start_initialization basic block 6
 ================== warring ================== 
[40;35m    need check this branch possible have return or exit stmt [0m

 ================== warring ================== 

 ================== find cond branch ================= 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# VUSE <.MEM_44>
progsize_21 = strlen (progname_16);
bb index := 2
# VUSE <.MEM_30>
return _18;
In function â€˜do_start_initializationâ€™:
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 12

======================================================================
progsize_21 = strlen (progname_16);
In function â€˜mainâ€™:
./benchmarks/binutils/leak_7/binutils_leak_7.c:112:14: warning: use location
  112 |   progsize = strlen (progname);
      |              ^
this stmt is child function---strlen-----

 ================== trace ================== 
trace fucntion name:strlen 

 ================== trace ================== 
trace fucntion free:2 
_9 = progsize_21 + 1;
./benchmarks/binutils/leak_7/binutils_leak_7.c:120:11: warning: use location
  120 |   count = mbstowcs (progname_copy, progname, progsize + 1);
      |           ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
_6 = progsize_21 + 1;
bb index := 2
# VUSE <.MEM_30>
return _18;
In function â€˜do_start_initializationâ€™:
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 12

======================================================================
_6 = progsize_21 + 1;
In function â€˜mainâ€™:
./benchmarks/binutils/leak_7/binutils_leak_7.c:113:55: warning: use location
  113 |   progname_copy = (wchar_t *) PyMem_Malloc ((progsize + 1) * sizeof (wchar_t));
      |                                                       ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
if (progname_copy_23 == 0B)
bb index := 2
# VUSE <.MEM_30>
return _18;
In function â€˜do_start_initializationâ€™:
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 12

======================================================================
if (progname_copy_23 == 0B)
In function â€˜mainâ€™:
./benchmarks/binutils/leak_7/binutils_leak_7.c:114:6: warning: use location
  114 |   if (!progname_copy)
      |      ^
if (progname_copy_23 == 0B)

 ================== find cond branch ================= 
./benchmarks/binutils/leak_7/binutils_leak_7.c:114:6: warning: use location
Cond in fucntion do_start_initialization basic block 2
 ================== possible direct basic block ================= 
from do_start_initialization basic block 3
 ================== possible direct basic block ================= 
from do_start_initialization basic block 4
 ================== warring ================== 
[40;35m    need check this branch possible have return or exit stmt [0m

 ================== warring ================== 

 ================== find cond branch ================= 

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7fe177694b40
    type <pointer_type 0x7fe1771bf2a0
        type <integer_type 0x7fe1771bf1f8 wchar_t SI
            size <integer_cst 0x7fe17768cdf8 constant 32>
            unit-size <integer_cst 0x7fe17768ce10 constant 4>
            align:32 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7fe1776a15e8 precision:32 min <integer_cst 0x7fe17768cdb0 -2147483648> max <integer_cst 0x7fe17768cdc8 2147483647> context <translation_unit_decl 0x7fe177697168 ./benchmarks/binutils/leak_7/binutils_leak_7.c>
            pointer_to_this <pointer_type 0x7fe1771bf2a0>>
        public unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
    var <var_decl 0x7fe1771cf120 progname_copy>
    def_stmt progname_copy_23 = PyMem_Malloc (_7);
    version:23
    ptr-info 0x7fe1771ca840>
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_52 = VDEF <.MEM_51>
free (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:124:25: warning: use location
  124 |                         xfree(progname_copy);
      |                         ^
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_50 = VDEF <.MEM_49>
free (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:135:9: warning: use location
  135 |         xfree(progname_copy);
      |         ^

 ================== Start Use after free Check ================== 

============================================================
# .MEM_52 = VDEF <.MEM_51>
free (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:124:25: warning: Use after free error!: free location 
  124 |                         xfree(progname_copy);
      |                         ^
# .MEM_49 = VDEF <.MEM_48>
Py_SetProgramName (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:134:3: warning: use location
  134 |   Py_SetProgramName (progname_copy);
      |   ^

 ================== warring ================== 
[40;35m    Use after free error! [0m
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_52 = VDEF <.MEM_51>
free (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:124:25: warning: Use after free error!: free location 
  124 |                         xfree(progname_copy);
      |                         ^
# .MEM_49 = VDEF <.MEM_48>
Py_SetProgramName (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:134:3: warning: use location
  134 |   Py_SetProgramName (progname_copy);
      |   ^

 ================== warring ================== 
[40;35m    Use after free error! [0m
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:2 [0m
[40;31m  	free count:2 [0m
[40;31m  	possible double free [Looserules]:2 [0m
[40;31m  	possible double free [rigorous]:2 [0m

======================================================================

======================================================================
[40;31m 	this stmt need double check [0m

======================================================================

dot graph START

======================================================================
 <addr_expr 0x7fe177888f00
    type <pointer_type 0x7fe1771c1930
        type <array_type 0x7fe1771c1888 type <integer_type 0x7fe1771b59d8 char>
            BLK
            size <integer_cst 0x7fe1771ac8a0 constant 328>
            unit-size <integer_cst 0x7fe1771ac9a8 constant 41>
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality domain <integer_type 0x7fe1771c17e0>
            pointer_to_this <pointer_type 0x7fe1771c1930>>
        unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
    readonly constant
    arg:0 <string_cst 0x7fe17769f040 type <array_type 0x7fe1771c1888>
        readonly constant static "Could not convert python path to string\012\000">
    ./benchmarks/binutils/leak_7/binutils_leak_7.c:125:24 start: ./benchmarks/binutils/leak_7/binutils_leak_7.c:125:24 finish: ./benchmarks/binutils/leak_7/binutils_leak_7.c:125:24>

 ================== trace ptable================== 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr--------
this other function -----------

======================================================================
[40;35m  	Looserules free count:0 [0m
[40;31m  	free count:0 [0m

======================================================================

======================================================================
[40;31m 	Can't find this fucntion in Pointer table [0m
[40;31m 	Possiable no other stmt relate with this stmt [0m

======================================================================

dot graph START

======================================================================
 <addr_expr 0x7fe177888f80
    type <pointer_type 0x7fe1771c1000
        type <array_type 0x7fe1771bff18 type <integer_type 0x7fe1771b59d8 char>
            BLK
            size <integer_cst 0x7fe1771ac930 constant 56>
            unit-size <integer_cst 0x7fe1771ac918 constant 7>
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality domain <integer_type 0x7fe1771bfe70>
            pointer_to_this <pointer_type 0x7fe1771c1000>>
        unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
    readonly constant
    arg:0 <string_cst 0x7fe177888f60 type <array_type 0x7fe1771bff18>
        readonly constant static "LC_ALL\000">
    ./benchmarks/binutils/leak_7/binutils_leak_7.c:128:14 start: ./benchmarks/binutils/leak_7/binutils_leak_7.c:128:14 finish: ./benchmarks/binutils/leak_7/binutils_leak_7.c:128:14>

 ================== trace ptable================== 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr--------
this other function -----------

======================================================================
[40;35m  	Looserules free count:0 [0m
[40;31m  	free count:0 [0m

======================================================================

======================================================================
[40;31m 	Can't find this fucntion in Pointer table [0m
[40;31m 	Possiable no other stmt relate with this stmt [0m

======================================================================
[40;33m =======POP node_fun stack:do_start_initialization========= [0m
[40;42m =======pre_check_funciton:main========= [0m
[40;42m =======start_check_funciton:main========= [0m

dot graph START

======================================================================
 <addr_expr 0x7fe177888ae0
    type <pointer_type 0x7fe1771c1c78
        type <array_type 0x7fe1771c1bd0 type <integer_type 0x7fe1771b59d8 char>
            BLK
            size <integer_cst 0x7fe1771ac9f0 constant 48>
            unit-size <integer_cst 0x7fe1771ac900 constant 6>
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality domain <integer_type 0x7fe1771c1b28>
            pointer_to_this <pointer_type 0x7fe1771c1c78>>
        unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
    readonly constant
    arg:0 <string_cst 0x7fe177888ac0 type <array_type 0x7fe1771c1bd0>
        readonly constant static "dummy\000">
    ./benchmarks/binutils/leak_7/binutils_leak_7.c:147:17 start: ./benchmarks/binutils/leak_7/binutils_leak_7.c:147:17 finish: ./benchmarks/binutils/leak_7/binutils_leak_7.c:147:17>

 ================== trace ptable================== 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr--------
this other function -----------

======================================================================
[40;35m  	Looserules free count:0 [0m
[40;31m  	free count:0 [0m

======================================================================

======================================================================
[40;31m 	Can't find this fucntion in Pointer table [0m
[40;31m 	Possiable no other stmt relate with this stmt [0m

======================================================================

dot graph START

======================================================================
 <addr_expr 0x7fe177888b60
    type <pointer_type 0x7fe1771bfa80
        type <array_type 0x7fe1771bf9d8 type <integer_type 0x7fe1771b59d8 char>
            SI
            size <integer_cst 0x7fe17768cdf8 constant 32>
            unit-size <integer_cst 0x7fe17768ce10 constant 4>
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality domain <integer_type 0x7fe1771bf930>
            pointer_to_this <pointer_type 0x7fe1771bfa80>>
        unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
    readonly constant
    arg:0 <string_cst 0x7fe177888b40 type <array_type 0x7fe1771bf9d8>
        readonly constant static "%d\012\000">
    ./benchmarks/binutils/leak_7/binutils_leak_7.c:149:3 start: ./benchmarks/binutils/leak_7/binutils_leak_7.c:149:3 finish: ./benchmarks/binutils/leak_7/binutils_leak_7.c:149:3>

 ================== trace ptable================== 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr--------
this other function -----------

======================================================================
[40;35m  	Looserules free count:0 [0m
[40;31m  	free count:0 [0m

======================================================================

======================================================================
[40;31m 	Can't find this fucntion in Pointer table [0m
[40;31m 	Possiable no other stmt relate with this stmt [0m

======================================================================
[40;33m =======POP node_fun stack:main========= [0m
[40;44m =======node_fun:do_start_initialization========= [0m
[40;44m fucntion collect path  [0m
[40;44m =======print_function_path do_start_initialization  function_call count: 10 level :0========  [0m
[40;44m =======print_function_type 2  ========  [0m
[40;42m =======pre add _ fucntion:free========= [0m
[40;33m =======POP node_fun stack:free========= [0m
[40;42m =======pre add _ fucntion:Py_SetProgramName========= [0m
[40;44m =======print_function_type 0  ========  [0m
[40;44m =======print_function_path Py_SetProgramName  function_call count: 1 level :1========  [0m
[40;44m =======print_function_type 0  ========  [0m
[40;42m =======pre add _ fucntion:printf========= [0m
[40;33m =======POP node_fun stack:printf========= [0m
[40;42m =======pre_check_funciton:Py_SetProgramName========= [0m
[40;42m =======start_check_funciton:Py_SetProgramName========= [0m

dot graph START

======================================================================
 <addr_expr 0x7fe1771d6080
    type <pointer_type 0x7fe1771bfa80
        type <array_type 0x7fe1771bf9d8 type <integer_type 0x7fe1771b59d8 char>
            SI
            size <integer_cst 0x7fe17768cdf8 constant 32>
            unit-size <integer_cst 0x7fe17768ce10 constant 4>
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality domain <integer_type 0x7fe1771bf930>
            pointer_to_this <pointer_type 0x7fe1771bfa80>>
        unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
    readonly constant
    arg:0 <string_cst 0x7fe1771d6060 type <array_type 0x7fe1771bf9d8>
        readonly constant static "%d\012\000">
    ./benchmarks/binutils/leak_7/binutils_leak_7.c:91:2 start: ./benchmarks/binutils/leak_7/binutils_leak_7.c:91:2 finish: ./benchmarks/binutils/leak_7/binutils_leak_7.c:91:2>

 ================== trace ptable================== 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr--------
this other function -----------

======================================================================
[40;35m  	Looserules free count:0 [0m
[40;31m  	free count:0 [0m

======================================================================

======================================================================
[40;31m 	Can't find this fucntion in Pointer table [0m
[40;31m 	Possiable no other stmt relate with this stmt [0m

======================================================================
[40;33m =======POP node_fun stack:Py_SetProgramName========= [0m
[40;42m =======pre add _ fucntion:setlocale========= [0m
[40;33m =======POP node_fun stack:setlocale========= [0m
[40;42m =======pre add _ fucntion:__builtin_fwrite========= [0m
[40;33m =======POP node_fun stack:__builtin_fwrite========= [0m
[40;42m =======pre add _ fucntion:mbstowcs========= [0m
[40;33m =======POP node_fun stack:mbstowcs========= [0m
[40;42m =======pre add _ fucntion:PyMem_Malloc========= [0m
[40;44m =======print_function_type 2  ========  [0m
[40;44m =======print_function_path PyMem_Malloc  function_call count: 1 level :1========  [0m
[40;44m =======print_function_type 2  ========  [0m
[40;42m =======pre add _ fucntion:malloc========= [0m
[40;33m =======POP node_fun stack:malloc========= [0m
[40;42m =======pre_check_funciton:PyMem_Malloc========= [0m
[40;42m =======start_check_funciton:PyMem_Malloc========= [0m

dot graph START

======================================================================
 <ssa_name 0x7fe1771d5360
    type <pointer_type 0x7fe1776a8000
        type <void_type 0x7fe1776a1f18 void VOID
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality
            pointer_to_this <pointer_type 0x7fe1776a8000>>
        public unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality
        pointer_to_this <pointer_type 0x7fe1776ad9d8>>
    var <var_decl 0x7fe1771cfd80 ret>
    def_stmt ret_4 = malloc (size_2(D));
    version:4
    ptr-info 0x7fe1771ca870>
# .MEM_6 = VDEF <.MEM_5(D)>
ret_4 = malloc (size_2(D));

 ================== trace ptable================== 
trace fucntion name:malloc 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr---malloc-----
this Reserved word function ------malloc-----
 
 Start check Pointer Collect  

======================================================================
return ret_4;
In function â€˜do_start_initializationâ€™:
./benchmarks/binutils/leak_7/binutils_leak_7.c:87:16: warning: use location
   87 |         return ret;
      |                ^
ret_4 = malloc (size_2(D));
./benchmarks/binutils/leak_7/binutils_leak_7.c:86:21: warning: use location
   86 |         void *ret = malloc(size);
      |                     ^
this stmt is child function---malloc-----

 ================== trace ================== 

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7fe1771d5360
    type <pointer_type 0x7fe1776a8000
        type <void_type 0x7fe1776a1f18 void VOID
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality
            pointer_to_this <pointer_type 0x7fe1776a8000>>
        public unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality
        pointer_to_this <pointer_type 0x7fe1776ad9d8>>
    var <var_decl 0x7fe1771cfd80 ret>
    def_stmt ret_4 = malloc (size_2(D));
    version:4
    ptr-info 0x7fe1771ca870>

 ================== Start Use after free Check ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:0 [0m
[40;31m  	free count:0 [0m

======================================================================

======================================================================
[40;31m    no free stmt possible memory leak [0m

======================================================================

dot graph START

======================================================================
 <ssa_name 0x7fe1771d5318
    type <integer_type 0x7fe1771b5f18 size_t public unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7fe1776a1738 precision:64 min <integer_cst 0x7fe17768ce88 0> max <integer_cst 0x7fe17768d500 18446744073709551615> context <translation_unit_decl 0x7fe177697168 ./benchmarks/binutils/leak_7/binutils_leak_7.c>>
    var <parm_decl 0x7fe1771c5300 size>
    def_stmt GIMPLE_NOP
    version:2>
GIMPLE_NOP

 ================== trace ptable================== 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr--------
this other function -----------
 
 Start check Pointer Collect  

======================================================================
ret_4 = malloc (size_2(D));
./benchmarks/binutils/leak_7/binutils_leak_7.c:86:21: warning: use location
this stmt is child function---malloc-----

 ================== trace ================== 
ret_4 = malloc (size_2(D));
./benchmarks/binutils/leak_7/binutils_leak_7.c:86:21: warning: use location
this stmt is child function---malloc-----

 ================== trace ================== 

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7fe1771d5318
    type <integer_type 0x7fe1771b5f18 size_t public unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7fe1776a1738 precision:64 min <integer_cst 0x7fe17768ce88 0> max <integer_cst 0x7fe17768d500 18446744073709551615> context <translation_unit_decl 0x7fe177697168 ./benchmarks/binutils/leak_7/binutils_leak_7.c>>
    var <parm_decl 0x7fe1771c5300 size>
    def_stmt GIMPLE_NOP
    version:2>

 ================== Start Use after free Check ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:0 [0m
[40;31m  	free count:0 [0m

======================================================================

======================================================================
[40;31m    no free stmt possible memory leak [0m

======================================================================
[40;33m =======POP node_fun stack:PyMem_Malloc========= [0m
[40;42m =======pre add _ fucntion:strlen========= [0m
[40;33m =======POP node_fun stack:strlen========= [0m
[40;42m =======pre add _ fucntion:strdup========= [0m
[40;33m =======POP node_fun stack:strdup========= [0m
[40;42m =======pre add _ fucntion:concat========= [0m
[40;44m =======print_function_type 2  ========  [0m
[40;44m =======print_function_path concat  function_call count: 2 level :1========  [0m
[40;44m =======print_function_type 2  ========  [0m
[40;42m =======pre add _ fucntion:vconcat_copy========= [0m
[40;44m =======print_function_type 0  ========  [0m
[40;44m =======print_function_path vconcat_copy  function_call count: 2 level :2========  [0m
[40;44m =======print_function_type 0  ========  [0m
[40;42m =======pre add _ fucntion:memcpy========= [0m
[40;33m =======POP node_fun stack:memcpy========= [0m
[40;42m =======pre add _ fucntion:strlen========= [0m
[40;33m =======POP node_fun stack:strlen========= [0m
[40;42m =======pre_check_funciton:vconcat_copy========= [0m
[40;42m =======start_check_funciton:vconcat_copy========= [0m

dot graph START

======================================================================
 <ssa_name 0x7fe1771d5678
    type <pointer_type 0x7fe1771b5b28
        type <integer_type 0x7fe1771b5a80 char readonly public QI
            size <integer_cst 0x7fe17768cca8 constant 8>
            unit-size <integer_cst 0x7fe17768ccc0 constant 1>
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7fe1776a13f0 precision:8 min <integer_cst 0x7fe1771ac720 -128> max <integer_cst 0x7fe1771ac708 127>
            pointer_to_this <pointer_type 0x7fe1771b5b28>>
        public unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
    var <parm_decl 0x7fe1771c5580 arg>
    def_stmt GIMPLE_NOP
    version:3
    ptr-info 0x7fe1771ca8e8>
GIMPLE_NOP

 ================== trace ptable================== 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr--------
this other function -----------
 
 Start check Pointer Collect  

======================================================================
length_4 = strlen (arg_3(D));
./benchmarks/binutils/leak_7/binutils_leak_7.c:61:32: warning: use location
   61 |         unsigned long length = strlen (arg);
      |                                ^
this stmt is child function---strlen-----

 ================== trace ================== 
trace fucntion name:strlen 

 ================== trace ================== 
trace fucntion free:0 
end_6 = dst_1(D) + length_4;
./benchmarks/binutils/leak_7/binutils_leak_7.c:63:13: warning: use location
   63 |         end += length;
      |             ^
*end_6 = 0;
./benchmarks/binutils/leak_7/binutils_leak_7.c:65:14: warning: use location
   65 |         *end = '\000';
      |              ^
memcpy (dst_1(D), arg_3(D), length_4);
./benchmarks/binutils/leak_7/binutils_leak_7.c:62:9: warning: use location
   62 |         memcpy (end, arg, length);
      |         ^
this stmt is child function---memcpy-----

 ================== trace ================== 
trace fucntion name:memcpy 

 ================== trace ================== 
trace fucntion free:0 

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7fe1771d5678
    type <pointer_type 0x7fe1771b5b28
        type <integer_type 0x7fe1771b5a80 char readonly public QI
            size <integer_cst 0x7fe17768cca8 constant 8>
            unit-size <integer_cst 0x7fe17768ccc0 constant 1>
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7fe1776a13f0 precision:8 min <integer_cst 0x7fe1771ac720 -128> max <integer_cst 0x7fe1771ac708 127>
            pointer_to_this <pointer_type 0x7fe1771b5b28>>
        public unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
    var <parm_decl 0x7fe1771c5580 arg>
    def_stmt GIMPLE_NOP
    version:3
    ptr-info 0x7fe1771ca8e8>

 ================== Start Use after free Check ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:0 [0m
[40;31m  	free count:0 [0m

======================================================================

======================================================================
[40;31m    no free stmt possible memory leak [0m

======================================================================

dot graph START

======================================================================
 <ssa_name 0x7fe1771d5630
    type <pointer_type 0x7fe1771b5c78
        type <integer_type 0x7fe1771b59d8 char public QI
            size <integer_cst 0x7fe17768cca8 constant 8>
            unit-size <integer_cst 0x7fe17768ccc0 constant 1>
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7fe1776a13f0 precision:8 min <integer_cst 0x7fe1771ac720 -128> max <integer_cst 0x7fe1771ac708 127>
            pointer_to_this <pointer_type 0x7fe1771b5c78>>
        public unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality context <translation_unit_decl 0x7fe177697168 ./benchmarks/binutils/leak_7/binutils_leak_7.c>
        pointer_to_this <pointer_type 0x7fe1771bfbd0>>
    var <parm_decl 0x7fe1771c5480 dst>
    def_stmt GIMPLE_NOP
    version:1
    ptr-info 0x7fe1771ca8d0>
GIMPLE_NOP

 ================== trace ptable================== 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr--------
this other function -----------
 
 Start check Pointer Collect  

======================================================================
return dst_1(D);
./benchmarks/binutils/leak_7/binutils_leak_7.c:67:16: warning: use location
   67 |         return dst;
      |                ^
end_6 = dst_1(D) + length_4;
./benchmarks/binutils/leak_7/binutils_leak_7.c:63:13: warning: use location
   63 |         end += length;
      |             ^
*end_6 = 0;
./benchmarks/binutils/leak_7/binutils_leak_7.c:65:14: warning: use location
   65 |         *end = '\000';
      |              ^
# .MEM_8 = VDEF <.MEM_7(D)>
memcpy (dst_1(D), arg_3(D), length_4);
memcpy (dst_1(D), arg_3(D), length_4);
./benchmarks/binutils/leak_7/binutils_leak_7.c:62:9: warning: use location
   62 |         memcpy (end, arg, length);
      |         ^
this stmt is child function---memcpy-----

 ================== trace ================== 
trace fucntion name:memcpy 

 ================== trace ================== 
trace fucntion free:0 
# .MEM_8 = VDEF <.MEM_7(D)>
memcpy (dst_1(D), arg_3(D), length_4);
memcpy (dst_1(D), arg_3(D), length_4);
./benchmarks/binutils/leak_7/binutils_leak_7.c:62:9: warning: use location
this stmt is child function---memcpy-----

 ================== trace ================== 
trace fucntion name:memcpy 

 ================== trace ================== 
trace fucntion free:0 

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7fe1771d5630
    type <pointer_type 0x7fe1771b5c78
        type <integer_type 0x7fe1771b59d8 char public QI
            size <integer_cst 0x7fe17768cca8 constant 8>
            unit-size <integer_cst 0x7fe17768ccc0 constant 1>
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7fe1776a13f0 precision:8 min <integer_cst 0x7fe1771ac720 -128> max <integer_cst 0x7fe1771ac708 127>
            pointer_to_this <pointer_type 0x7fe1771b5c78>>
        public unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality context <translation_unit_decl 0x7fe177697168 ./benchmarks/binutils/leak_7/binutils_leak_7.c>
        pointer_to_this <pointer_type 0x7fe1771bfbd0>>
    var <parm_decl 0x7fe1771c5480 dst>
    def_stmt GIMPLE_NOP
    version:1
    ptr-info 0x7fe1771ca8d0>

 ================== Start Use after free Check ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:0 [0m
[40;31m  	free count:0 [0m

======================================================================

======================================================================
[40;31m    no free stmt possible memory leak [0m

======================================================================
[40;33m =======POP node_fun stack:vconcat_copy========= [0m
[40;42m =======pre add _ fucntion:malloc========= [0m
[40;33m =======POP node_fun stack:malloc========= [0m
[40;42m =======pre_check_funciton:concat========= [0m
[40;42m =======start_check_funciton:concat========= [0m

dot graph START

======================================================================
 <ssa_name 0x7fe1771d5438
    type <pointer_type 0x7fe1771b5c78
        type <integer_type 0x7fe1771b59d8 char public QI
            size <integer_cst 0x7fe17768cca8 constant 8>
            unit-size <integer_cst 0x7fe17768ccc0 constant 1>
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7fe1776a13f0 precision:8 min <integer_cst 0x7fe1771ac720 -128> max <integer_cst 0x7fe1771ac708 127>
            pointer_to_this <pointer_type 0x7fe1771b5c78>>
        public unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality context <translation_unit_decl 0x7fe177697168 ./benchmarks/binutils/leak_7/binutils_leak_7.c>
        pointer_to_this <pointer_type 0x7fe1771bfbd0>>
    var <var_decl 0x7fe1771cff30 newstr>
    def_stmt newstr_3 = malloc (1);
    version:3
    ptr-info 0x7fe1771ca888>
# .MEM_7 = VDEF <.MEM_6(D)>
newstr_3 = malloc (1);

 ================== trace ptable================== 
trace fucntion name:malloc 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr---malloc-----
this Reserved word function ------malloc-----
 
 Start check Pointer Collect  

======================================================================
return newstr_3;
./benchmarks/binutils/leak_7/binutils_leak_7.c:81:10: warning: use location
   81 |   return newstr;
      |          ^
vconcat_copy (newstr_3, first_4(D), arg_5(D));
./benchmarks/binutils/leak_7/binutils_leak_7.c:79:3: warning: use location
   79 |   vconcat_copy (newstr, first, arg);
      |   ^
this stmt is child function---vconcat_copy-----

 ================== trace ================== 
trace fucntion name:vconcat_copy 
[40;44m =======trace_function_path vconcat_copy  function_call count: 2 level :0========  [0m
[40;36m ======= node_fun:vconcat_copy========= [0m
[40;36m ======= find relate stmt with newstr ========= [0m
[40;36m ======= relate stmt argument:newstr ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:memcpy========= [0m
[40;46m =======add node_fun stack:memcpy========= [0m
[40;42m =======pre add _ fucntion:strlen========= [0m
[40;46m =======add node_fun stack:strlen========= [0m

 ================== trace ================== 
trace fucntion free:0 
newstr_3 = malloc (1);
./benchmarks/binutils/leak_7/binutils_leak_7.c:76:12: warning: use location
   76 |   newstr = XNEWVEC (char, 1);
      |            ^
this stmt is child function---malloc-----

 ================== trace ================== 

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7fe1771d5438
    type <pointer_type 0x7fe1771b5c78
        type <integer_type 0x7fe1771b59d8 char public QI
            size <integer_cst 0x7fe17768cca8 constant 8>
            unit-size <integer_cst 0x7fe17768ccc0 constant 1>
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7fe1776a13f0 precision:8 min <integer_cst 0x7fe1771ac720 -128> max <integer_cst 0x7fe1771ac708 127>
            pointer_to_this <pointer_type 0x7fe1771b5c78>>
        public unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality context <translation_unit_decl 0x7fe177697168 ./benchmarks/binutils/leak_7/binutils_leak_7.c>
        pointer_to_this <pointer_type 0x7fe1771bfbd0>>
    var <var_decl 0x7fe1771cff30 newstr>
    def_stmt newstr_3 = malloc (1);
    version:3
    ptr-info 0x7fe1771ca888>

 ================== Start Use after free Check ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:0 [0m
[40;31m  	free count:0 [0m

======================================================================

======================================================================
[40;31m    no free stmt possible memory leak [0m

======================================================================

dot graph START

======================================================================

 ================== collect possiable invalid ================== 
 <integer_cst 0x7fe1771ca5e8 type <integer_type 0x7fe1776a17e0 long unsigned int> constant 1>
[40;33m =======POP node_fun stack:concat========= [0m
[40;42m =======pre add _ fucntion:ldirname========= [0m
[40;44m =======print_function_type 2  ========  [0m
[40;44m =======print_function_path ldirname  function_call count: 3 level :1========  [0m
[40;44m =======print_function_type 2  ========  [0m
[40;42m =======pre add _ fucntion:memcpy========= [0m
[40;33m =======POP node_fun stack:memcpy========= [0m
[40;42m =======pre add _ fucntion:malloc========= [0m
[40;33m =======POP node_fun stack:malloc========= [0m
[40;42m =======pre add _ fucntion:lbasename========= [0m
[40;44m =======print_function_type 0  ========  [0m
[40;44m =======print_function_path lbasename  function_call count: 1 level :2========  [0m
[40;44m =======print_function_type 0  ========  [0m
[40;42m =======pre add _ fucntion:unix_lbasename========= [0m
[40;44m =======print_function_type 0  ========  [0m
[40;44m =======print_function_path unix_lbasename  function_call count: 0 level :3========  [0m
[40;44m =======print_function_type 0  ========  [0m
[40;42m =======pre_check_funciton:unix_lbasename========= [0m
[40;42m =======start_check_funciton:unix_lbasename========= [0m
[40;33m =======POP node_fun stack:unix_lbasename========= [0m
[40;42m =======pre_check_funciton:lbasename========= [0m
[40;42m =======start_check_funciton:lbasename========= [0m

dot graph START

======================================================================
 <ssa_name 0x7fe1771de048
    type <pointer_type 0x7fe1771b5b28
        type <integer_type 0x7fe1771b5a80 char readonly public QI
            size <integer_cst 0x7fe17768cca8 constant 8>
            unit-size <integer_cst 0x7fe17768ccc0 constant 1>
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7fe1776a13f0 precision:8 min <integer_cst 0x7fe1771ac720 -128> max <integer_cst 0x7fe1771ac708 127>
            pointer_to_this <pointer_type 0x7fe1771b5b28>>
        public unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
    var <parm_decl 0x7fe1771c5680 name>
    def_stmt GIMPLE_NOP
    version:2
    ptr-info 0x7fe1771caa08>
GIMPLE_NOP

 ================== trace ptable================== 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr--------
this other function -----------

======================================================================
[40;35m  	Looserules free count:0 [0m
[40;31m  	free count:0 [0m

======================================================================

======================================================================
[40;31m 	Can't find this fucntion in Pointer table [0m
[40;31m 	Possiable no other stmt relate with this stmt [0m

======================================================================
[40;33m =======POP node_fun stack:lbasename========= [0m
[40;42m =======pre_check_funciton:ldirname========= [0m
[40;42m =======start_check_funciton:ldirname========= [0m

dot graph START

======================================================================
 <ssa_name 0x7fe1771d5e10
    type <pointer_type 0x7fe1771b5c78
        type <integer_type 0x7fe1771b59d8 char public QI
            size <integer_cst 0x7fe17768cca8 constant 8>
            unit-size <integer_cst 0x7fe17768ccc0 constant 1>
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7fe1776a13f0 precision:8 min <integer_cst 0x7fe1771ac720 -128> max <integer_cst 0x7fe1771ac708 127>
            pointer_to_this <pointer_type 0x7fe1771b5c78>>
        public unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality context <translation_unit_decl 0x7fe177697168 ./benchmarks/binutils/leak_7/binutils_leak_7.c>
        pointer_to_this <pointer_type 0x7fe1771bfbd0>>
    var <var_decl 0x7fe1771d7360 dirname>
    def_stmt dirname_26 = malloc (_4);
    version:26
    ptr-info 0x7fe1771ca9d8>
# .MEM_32 = VDEF <.MEM_31(D)>
dirname_26 = malloc (_4);

 ================== trace ptable================== 
trace fucntion name:malloc 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr---malloc-----
this Reserved word function ------malloc-----
 
 Start check Pointer Collect  

======================================================================
_18 = PHI <0B(6), dirname_26(11)>
lto1: warning: use location
this stmt have mutiple branch --------
_15 = dirname_26 + _14;
./benchmarks/binutils/leak_7/binutils_leak_7.c:52:10: warning: use location
   52 |   dirname[base - filename] = '\0';
      |          ^
*_15 = 0;
./benchmarks/binutils/leak_7/binutils_leak_7.c:52:28: warning: use location
   52 |   dirname[base - filename] = '\0';
      |                            ^
_12 = dirname_26 + _11;
./benchmarks/binutils/leak_7/binutils_leak_7.c:50:12: warning: use location
   50 |     dirname[base++ - filename] = '.';
      |            ^
*_12 = 46;
./benchmarks/binutils/leak_7/binutils_leak_7.c:50:32: warning: use location
   50 |     dirname[base++ - filename] = '.';
      |                                ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_33 = VDEF <.MEM_32>
memcpy (dirname_26, filename_22(D), _6);
bb index := 7
# VUSE <.MEM_30>
return _18;
In function â€˜ldirnameâ€™:
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 7 ,possiable got to succ := 12

======================================================================
memcpy (dirname_26, filename_22(D), _6);
In function â€˜do_start_initializationâ€™:
./benchmarks/binutils/leak_7/binutils_leak_7.c:44:3: warning: use location
   44 |   memcpy (dirname, filename, base - filename);
      |   ^
this stmt is child function---memcpy-----

 ================== trace ================== 
trace fucntion name:memcpy 

 ================== trace ================== 
trace fucntion free:0 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_32 = VDEF <.MEM_31(D)>
dirname_26 = malloc (_4);
bb index := 7
# VUSE <.MEM_30>
return _18;
In function â€˜ldirnameâ€™:
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 7 ,possiable got to succ := 12

======================================================================
dirname_26 = malloc (_4);
In function â€˜do_start_initializationâ€™:
./benchmarks/binutils/leak_7/binutils_leak_7.c:43:22: warning: use location
   43 |   dirname = (char *) xmalloc (base - filename + 2);         /* allocation site */
      |                      ^
this stmt is child function---malloc-----

 ================== trace ================== 

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7fe1771d5e10
    type <pointer_type 0x7fe1771b5c78
        type <integer_type 0x7fe1771b59d8 char public QI
            size <integer_cst 0x7fe17768cca8 constant 8>
            unit-size <integer_cst 0x7fe17768ccc0 constant 1>
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7fe1776a13f0 precision:8 min <integer_cst 0x7fe1771ac720 -128> max <integer_cst 0x7fe1771ac708 127>
            pointer_to_this <pointer_type 0x7fe1771b5c78>>
        public unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality context <translation_unit_decl 0x7fe177697168 ./benchmarks/binutils/leak_7/binutils_leak_7.c>
        pointer_to_this <pointer_type 0x7fe1771bfbd0>>
    var <var_decl 0x7fe1771d7360 dirname>
    def_stmt dirname_26 = malloc (_4);
    version:26
    ptr-info 0x7fe1771ca9d8>

 ================== Start Use after free Check ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:0 [0m
[40;31m  	free count:0 [0m

======================================================================

======================================================================
[40;31m    no free stmt possible memory leak [0m

======================================================================

dot graph START

======================================================================
 <ssa_name 0x7fe1771d5d38
    type <pointer_type 0x7fe1771b5b28
        type <integer_type 0x7fe1771b5a80 char readonly public QI
            size <integer_cst 0x7fe17768cca8 constant 8>
            unit-size <integer_cst 0x7fe17768ccc0 constant 1>
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7fe1776a13f0 precision:8 min <integer_cst 0x7fe1771ac720 -128> max <integer_cst 0x7fe1771ac708 127>
            pointer_to_this <pointer_type 0x7fe1771b5b28>>
        public unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
    var <parm_decl 0x7fe1771c5600 filename>
    def_stmt GIMPLE_NOP
    version:22
    ptr-info 0x7fe1771ca990>
GIMPLE_NOP

 ================== trace ptable================== 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr--------
this other function -----------
 
 Start check Pointer Collect  

======================================================================
base_23 = lbasename (filename_22(D));
./benchmarks/binutils/leak_7/binutils_leak_7.c:34:22: warning: use location
   34 |   const char *base = lbasename (filename);
      |                      ^
this stmt is child function---lbasename-----

 ================== trace ================== 
trace fucntion name:lbasename 
[40;44m =======trace_function_path lbasename  function_call count: 1 level :0========  [0m
[40;36m ======= node_fun:lbasename========= [0m
[40;36m ======= find relate stmt with filename ========= [0m
[40;36m ======= relate stmt argument:filename ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:unix_lbasename========= [0m
[40;46m =======add node_fun stack:unix_lbasename========= [0m
[40;44m =======trace_function_path unix_lbasename  function_call count: 0 level :1========  [0m
[40;36m ======= node_fun:unix_lbasename========= [0m
[40;36m ======= find relate stmt with filename ========= [0m
[40;36m ======= relate stmt argument:filename ========= [0m
fucntion collect path finsh

 ================== trace ================== 
trace fucntion free:0 

======================================================================
[40;31m    branch possiable have return or exit  [0m
base_16 = PHI <base_23(2), base_24(3)>
bb index := 4
# VUSE <.MEM_30>
return _18;
In function â€˜ldirnameâ€™:
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 4 ,possiable got to succ := 12

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
base_16 = PHI <base_23(2), base_24(3)>
bb index := 4
# VUSE <.MEM_8(D)>
return base_3;
./benchmarks/binutils/leak_7/binutils_leak_7.c:22:10: warning: use location
   22 |   return base;
      |          ^
beacuse in succ := 5 have return or exit
# VUSE <.MEM_8(D)>
return base_3;
./benchmarks/binutils/leak_7/binutils_leak_7.c:22:10: warning: use location
gimple stmt in succ := 4 ,possiable got to succ := 5

======================================================================

======================================================================
[40;31m    collect Stmt in loop [0m

======================================================================
base_16 = PHI <base_23(2), base_24(3)>
In function â€˜do_start_initializationâ€™:
lto1: warning: use location
this stmt have mutiple branch --------
base_17 = PHI <base_16(7), base_16(8), base_16(9), base_28(10)>
lto1: warning: use location
this stmt have mutiple branch --------
_13 = base_17 - filename_22(D);
./benchmarks/binutils/leak_7/binutils_leak_7.c:52:16: warning: use location
   52 |   dirname[base - filename] = '\0';
      |                ^
_14 = (sizetype) _13;
./benchmarks/binutils/leak_7/binutils_leak_7.c:52:16: warning: use location
_15 = dirname_26 + _14;
./benchmarks/binutils/leak_7/binutils_leak_7.c:52:10: warning: use location
   52 |   dirname[base - filename] = '\0';
      |          ^
*_15 = 0;
./benchmarks/binutils/leak_7/binutils_leak_7.c:52:28: warning: use location
   52 |   dirname[base - filename] = '\0';
      |                            ^
_10 = base_16 - filename_22(D);
./benchmarks/binutils/leak_7/binutils_leak_7.c:50:20: warning: use location
   50 |     dirname[base++ - filename] = '.';
      |                    ^
_11 = (sizetype) _10;
./benchmarks/binutils/leak_7/binutils_leak_7.c:50:20: warning: use location
_12 = dirname_26 + _11;
./benchmarks/binutils/leak_7/binutils_leak_7.c:50:12: warning: use location
   50 |     dirname[base++ - filename] = '.';
      |            ^
*_12 = 46;
./benchmarks/binutils/leak_7/binutils_leak_7.c:50:32: warning: use location
   50 |     dirname[base++ - filename] = '.';
      |                                ^
base_28 = base_16 + 1;
./benchmarks/binutils/leak_7/binutils_leak_7.c:50:17: warning: use location
   50 |     dirname[base++ - filename] = '.';
      |                 ^
_8 = *base_16;
./benchmarks/binutils/leak_7/binutils_leak_7.c:48:31: warning: use location
   48 |   if (base - filename == 2 && IS_ABSOLUTE_PATH (base)
      |                               ^
if (_8 == 47)
./benchmarks/binutils/leak_7/binutils_leak_7.c:48:28: warning: use location
   48 |   if (base - filename == 2 && IS_ABSOLUTE_PATH (base)
      |                            ^
if (_8 == 47)

 ================== find cond branch ================= 
./benchmarks/binutils/leak_7/binutils_leak_7.c:48:28: warning: use location
Cond in fucntion ldirname basic block 8
 ================== possible direct basic block ================= 
from ldirname basic block 9
 ================== possible direct basic block ================= 
from ldirname basic block 11
 ================== warring ================== 
[40;35m    need check this branch possible have return or exit stmt [0m

 ================== warring ================== 

 ================== find cond branch ================= 

======================================================================
[40;31m    branch possiable have return or exit  [0m
_7 = base_16 - filename_22(D);
bb index := 7
# VUSE <.MEM_30>
return _18;
In function â€˜ldirnameâ€™:
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 7 ,possiable got to succ := 12

======================================================================
_7 = base_16 - filename_22(D);
In function â€˜do_start_initializationâ€™:
./benchmarks/binutils/leak_7/binutils_leak_7.c:48:12: warning: use location
   48 |   if (base - filename == 2 && IS_ABSOLUTE_PATH (base)
      |            ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
if (_7 == 2)
bb index := 7
# VUSE <.MEM_30>
return _18;
In function â€˜ldirnameâ€™:
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 7 ,possiable got to succ := 12

======================================================================
if (_7 == 2)
In function â€˜do_start_initializationâ€™:
./benchmarks/binutils/leak_7/binutils_leak_7.c:48:6: warning: use location
   48 |   if (base - filename == 2 && IS_ABSOLUTE_PATH (base)
      |      ^
if (_7 == 2)

 ================== find cond branch ================= 
./benchmarks/binutils/leak_7/binutils_leak_7.c:48:6: warning: use location
Cond in fucntion ldirname basic block 7
 ================== possible direct basic block ================= 
from ldirname basic block 8
 ================== possible direct basic block ================= 
from ldirname basic block 11
 ================== warring ================== 
[40;35m    need check this branch possible have return or exit stmt [0m

 ================== warring ================== 

 ================== find cond branch ================= 

======================================================================
[40;31m    branch possiable have return or exit  [0m
_5 = base_16 - filename_22(D);
bb index := 7
# VUSE <.MEM_30>
return _18;
In function â€˜ldirnameâ€™:
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 7 ,possiable got to succ := 12

======================================================================
_5 = base_16 - filename_22(D);
In function â€˜do_start_initializationâ€™:
./benchmarks/binutils/leak_7/binutils_leak_7.c:44:35: warning: use location
   44 |   memcpy (dirname, filename, base - filename);
      |                                   ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
_6 = (long unsigned int) _5;
bb index := 7
# VUSE <.MEM_30>
return _18;
In function â€˜ldirnameâ€™:
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 7 ,possiable got to succ := 12

======================================================================
_6 = (long unsigned int) _5;
In function â€˜do_start_initializationâ€™:
./benchmarks/binutils/leak_7/binutils_leak_7.c:44:3: warning: use location
   44 |   memcpy (dirname, filename, base - filename);
      |   ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_33 = VDEF <.MEM_32>
memcpy (dirname_26, filename_22(D), _6);
bb index := 7
# VUSE <.MEM_30>
return _18;
In function â€˜ldirnameâ€™:
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 7 ,possiable got to succ := 12

======================================================================
memcpy (dirname_26, filename_22(D), _6);
In function â€˜do_start_initializationâ€™:
./benchmarks/binutils/leak_7/binutils_leak_7.c:44:3: warning: use location
this stmt is child function---memcpy-----

 ================== trace ================== 
trace fucntion name:memcpy 

 ================== trace ================== 
trace fucntion free:0 

======================================================================
[40;31m    branch possiable have return or exit  [0m
_2 = base_16 - filename_22(D);
bb index := 7
# VUSE <.MEM_30>
return _18;
In function â€˜ldirnameâ€™:
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 7 ,possiable got to succ := 12

======================================================================
_2 = base_16 - filename_22(D);
In function â€˜do_start_initializationâ€™:
./benchmarks/binutils/leak_7/binutils_leak_7.c:43:22: warning: use location
   43 |   dirname = (char *) xmalloc (base - filename + 2);         /* allocation site */
      |                      ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
_3 = _2 + 2;
bb index := 7
# VUSE <.MEM_30>
return _18;
In function â€˜ldirnameâ€™:
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 7 ,possiable got to succ := 12

======================================================================
_3 = _2 + 2;
In function â€˜do_start_initializationâ€™:
./benchmarks/binutils/leak_7/binutils_leak_7.c:43:22: warning: use location

======================================================================
[40;31m    branch possiable have return or exit  [0m
_4 = (long unsigned int) _3;
bb index := 7
# VUSE <.MEM_30>
return _18;
In function â€˜ldirnameâ€™:
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 7 ,possiable got to succ := 12

======================================================================
_4 = (long unsigned int) _3;
In function â€˜do_start_initializationâ€™:
./benchmarks/binutils/leak_7/binutils_leak_7.c:43:22: warning: use location

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_32 = VDEF <.MEM_31(D)>
dirname_26 = malloc (_4);
bb index := 7
# VUSE <.MEM_30>
return _18;
In function â€˜ldirnameâ€™:
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 7 ,possiable got to succ := 12

======================================================================
dirname_26 = malloc (_4);
In function â€˜do_start_initializationâ€™:
./benchmarks/binutils/leak_7/binutils_leak_7.c:43:22: warning: use location
this stmt is child function---malloc-----

 ================== trace ================== 
_18 = PHI <0B(6), dirname_26(11)>
lto1: warning: use location
this stmt have mutiple branch --------

======================================================================
[40;31m    branch possiable have return or exit  [0m
if (base_16 == filename_22(D))
bb index := 6
# VUSE <.MEM_30>
return _18;
In function â€˜ldirnameâ€™:
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 6 ,possiable got to succ := 12

======================================================================
if (base_16 == filename_22(D))
In function â€˜do_start_initializationâ€™:
./benchmarks/binutils/leak_7/binutils_leak_7.c:40:6: warning: use location
   40 |   if (base == filename)
      |      ^
if (base_16 == filename_22(D))

 ================== find cond branch ================= 
./benchmarks/binutils/leak_7/binutils_leak_7.c:40:6: warning: use location
Cond in fucntion ldirname basic block 6
 ================== possible direct basic block ================= 
from ldirname basic block 12
 ================== possible direct basic block ================= 
from ldirname basic block 7
 ================== warring ================== 
[40;35m    need check this branch possible have return or exit stmt [0m

 ================== warring ================== 

 ================== find cond branch ================= 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# VUSE <.MEM_31(D)>
_1 = MEM[(const char *)base_16 + -1B];
bb index := 5
# VUSE <.MEM_30>
return _18;
In function â€˜ldirnameâ€™:
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 5 ,possiable got to succ := 12

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# VUSE <.MEM_31(D)>
_1 = MEM[(const char *)base_16 + -1B];
bb index := 5
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 5 ,possiable got to succ := 12

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# VUSE <.MEM_31(D)>
_1 = MEM[(const char *)base_16 + -1B];
bb index := 5
# VUSE <.MEM_8(D)>
return base_3;
./benchmarks/binutils/leak_7/binutils_leak_7.c:22:10: warning: use location
   22 |   return base;
      |          ^
beacuse in succ := 5 have return or exit
# VUSE <.MEM_8(D)>
return base_3;
./benchmarks/binutils/leak_7/binutils_leak_7.c:22:10: warning: use location
gimple stmt in succ := 5 ,possiable got to succ := 5

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# VUSE <.MEM_31(D)>
_1 = MEM[(const char *)base_16 + -1B];
bb index := 5
# VUSE <.MEM_8(D)>
return base_3;
./benchmarks/binutils/leak_7/binutils_leak_7.c:22:10: warning: use location
beacuse in succ := 5 have return or exit
# VUSE <.MEM_8(D)>
return base_3;
./benchmarks/binutils/leak_7/binutils_leak_7.c:22:10: warning: use location
gimple stmt in succ := 5 ,possiable got to succ := 5

======================================================================

======================================================================
[40;31m    collect Stmt in loop [0m

======================================================================
_1 = MEM[(const char *)base_16 + -1B];
In function â€˜do_start_initializationâ€™:
./benchmarks/binutils/leak_7/binutils_leak_7.c:37:29: warning: use location
   37 |   while (base > filename && IS_DIR_SEPARATOR (base[-1]))
      |                             ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
base_24 = base_16 + 18446744073709551615;
bb index := 3
# VUSE <.MEM_30>
return _18;
In function â€˜ldirnameâ€™:
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 3 ,possiable got to succ := 12

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
base_24 = base_16 + 18446744073709551615;
bb index := 3
# VUSE <.MEM_8(D)>
return base_3;
./benchmarks/binutils/leak_7/binutils_leak_7.c:22:10: warning: use location
   22 |   return base;
      |          ^
beacuse in succ := 5 have return or exit
# VUSE <.MEM_8(D)>
return base_3;
./benchmarks/binutils/leak_7/binutils_leak_7.c:22:10: warning: use location
gimple stmt in succ := 3 ,possiable got to succ := 5

======================================================================

======================================================================
[40;31m    collect Stmt in loop [0m

======================================================================
base_24 = base_16 + 18446744073709551615;
In function â€˜do_start_initializationâ€™:
./benchmarks/binutils/leak_7/binutils_leak_7.c:38:5: warning: use location
   38 |     --base;
      |     ^
_9 = *filename_22(D);
./benchmarks/binutils/leak_7/binutils_leak_7.c:49:11: warning: use location
   49 |       && !IS_DIR_SEPARATOR (filename[0]))
      |           ^

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7fe1771d5d38
    type <pointer_type 0x7fe1771b5b28
        type <integer_type 0x7fe1771b5a80 char readonly public QI
            size <integer_cst 0x7fe17768cca8 constant 8>
            unit-size <integer_cst 0x7fe17768ccc0 constant 1>
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7fe1776a13f0 precision:8 min <integer_cst 0x7fe1771ac720 -128> max <integer_cst 0x7fe1771ac708 127>
            pointer_to_this <pointer_type 0x7fe1771b5b28>>
        public unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
    var <parm_decl 0x7fe1771c5600 filename>
    def_stmt GIMPLE_NOP
    version:22
    ptr-info 0x7fe1771ca990>

 ================== Start Use after free Check ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:0 [0m
[40;31m  	free count:0 [0m

======================================================================

======================================================================
[40;31m 	this stmt need double check [0m

======================================================================

dot graph START

======================================================================
 <ssa_name 0x7fe1771d5900
    type <integer_type 0x7fe1776a17e0 long unsigned int public unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7fe1776a1738 precision:64 min <integer_cst 0x7fe17768ce88 0> max <integer_cst 0x7fe17768d500 18446744073709551615>
        pointer_to_this <pointer_type 0x7fe1776ad7e0>>
   
    def_stmt _4 = (long unsigned int) _3;
    version:4>
_4 = (long unsigned int) _3;

 ================== trace ptable================== 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr--------
this other function -----------
 
 Start check Pointer Collect  

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_32 = VDEF <.MEM_31(D)>
dirname_26 = malloc (_4);
bb index := 7
# VUSE <.MEM_30>
return _18;
In function â€˜ldirnameâ€™:
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 7 ,possiable got to succ := 12

======================================================================
dirname_26 = malloc (_4);
In function â€˜do_start_initializationâ€™:
./benchmarks/binutils/leak_7/binutils_leak_7.c:43:22: warning: use location
   43 |   dirname = (char *) xmalloc (base - filename + 2);         /* allocation site */
      |                      ^
this stmt is child function---malloc-----

 ================== trace ================== 
_18 = PHI <0B(6), dirname_26(11)>
lto1: warning: use location
this stmt have mutiple branch --------
_15 = dirname_26 + _14;
./benchmarks/binutils/leak_7/binutils_leak_7.c:52:10: warning: use location
   52 |   dirname[base - filename] = '\0';
      |          ^
*_15 = 0;
./benchmarks/binutils/leak_7/binutils_leak_7.c:52:28: warning: use location
   52 |   dirname[base - filename] = '\0';
      |                            ^
_12 = dirname_26 + _11;
./benchmarks/binutils/leak_7/binutils_leak_7.c:50:12: warning: use location
   50 |     dirname[base++ - filename] = '.';
      |            ^
*_12 = 46;
./benchmarks/binutils/leak_7/binutils_leak_7.c:50:32: warning: use location
   50 |     dirname[base++ - filename] = '.';
      |                                ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_33 = VDEF <.MEM_32>
memcpy (dirname_26, filename_22(D), _6);
bb index := 7
# VUSE <.MEM_30>
return _18;
In function â€˜ldirnameâ€™:
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 7 ,possiable got to succ := 12

======================================================================
memcpy (dirname_26, filename_22(D), _6);
In function â€˜do_start_initializationâ€™:
./benchmarks/binutils/leak_7/binutils_leak_7.c:44:3: warning: use location
   44 |   memcpy (dirname, filename, base - filename);
      |   ^
this stmt is child function---memcpy-----

 ================== trace ================== 
trace fucntion name:memcpy 

 ================== trace ================== 
trace fucntion free:0 

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7fe1771d5900
    type <integer_type 0x7fe1776a17e0 long unsigned int public unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7fe1776a1738 precision:64 min <integer_cst 0x7fe17768ce88 0> max <integer_cst 0x7fe17768d500 18446744073709551615>
        pointer_to_this <pointer_type 0x7fe1776ad7e0>>
   
    def_stmt _4 = (long unsigned int) _3;
    version:4>

 ================== Start Use after free Check ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:0 [0m
[40;31m  	free count:0 [0m

======================================================================

======================================================================
[40;31m    no free stmt possible memory leak [0m

======================================================================
[40;33m =======POP node_fun stack:ldirname========= [0m
[40;42m =======pre_check_funciton:do_start_initialization========= [0m
[40;42m =======start_check_funciton:do_start_initialization========= [0m

dot graph START

======================================================================
 <ssa_name 0x7fe177694ab0
    type <pointer_type 0x7fe1771b5c78
        type <integer_type 0x7fe1771b59d8 char public QI
            size <integer_cst 0x7fe17768cca8 constant 8>
            unit-size <integer_cst 0x7fe17768ccc0 constant 1>
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7fe1776a13f0 precision:8 min <integer_cst 0x7fe1771ac720 -128> max <integer_cst 0x7fe1771ac708 127>
            pointer_to_this <pointer_type 0x7fe1771b5c78>>
        public unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality context <translation_unit_decl 0x7fe177697168 ./benchmarks/binutils/leak_7/binutils_leak_7.c>
        pointer_to_this <pointer_type 0x7fe1771bfbd0>>
    var <var_decl 0x7fe1771cf1b0 oldloc>
    def_stmt oldloc_19 = strdup (_5);
    version:19
    ptr-info 0x7fe1771ca828>
# .MEM_43 = VDEF <.MEM_42>
oldloc_19 = strdup (_5);

 ================== trace ptable================== 
trace fucntion name:strdup 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr---strdup-----
this Reserved word function ------strdup-----
 
 Start check Pointer Collect  

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_43 = VDEF <.MEM_42>
oldloc_19 = strdup (_5);
bb index := 2
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 12

======================================================================
oldloc_19 = strdup (_5);
./benchmarks/binutils/leak_7/binutils_leak_7.c:110:12: warning: use location
  110 |   oldloc = xstrdup (setlocale (LC_ALL, NULL));
      |            ^
this stmt is child function---strdup-----

 ================== trace ================== 
free (oldloc_19);
./benchmarks/binutils/leak_7/binutils_leak_7.c:129:3: warning: use location
  129 |   xfree (oldloc);
      |   ^
this stmt is child function---free-----

 ================== find ================== 
free (oldloc_19);
./benchmarks/binutils/leak_7/binutils_leak_7.c:129:3: warning: use location
[40;32m    HAS FREE STMT count:1 name:free [0m

 ================== find ================== 
setlocale ("LC_ALL", oldloc_19);
./benchmarks/binutils/leak_7/binutils_leak_7.c:128:3: warning: use location
  128 |   setlocale (LC_ALL, oldloc);
      |   ^
this stmt is child function---setlocale-----

 ================== trace ================== 
trace fucntion name:setlocale 

 ================== trace ================== 
trace fucntion free:1 
free (oldloc_19);
./benchmarks/binutils/leak_7/binutils_leak_7.c:123:7: warning: use location
  123 |       xfree (oldloc);
      |       ^
this stmt is child function---free-----

 ================== find ================== 
free (oldloc_19);
./benchmarks/binutils/leak_7/binutils_leak_7.c:123:7: warning: use location
[40;32m    HAS FREE STMT count:2 name:free [0m

 ================== find ================== 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_54 = VDEF <.MEM_45>
free (oldloc_19);
bb index := 3
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 3 ,possiable got to succ := 12

======================================================================
free (oldloc_19);
./benchmarks/binutils/leak_7/binutils_leak_7.c:116:7: warning: use location
  116 |       xfree (oldloc);
      |       ^
this stmt is child function---free-----

 ================== find ================== 
free (oldloc_19);
./benchmarks/binutils/leak_7/binutils_leak_7.c:116:7: warning: use location
[40;32m    HAS FREE STMT count:3 name:free [0m

 ================== find ================== 

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7fe177694ab0
    type <pointer_type 0x7fe1771b5c78
        type <integer_type 0x7fe1771b59d8 char public QI
            size <integer_cst 0x7fe17768cca8 constant 8>
            unit-size <integer_cst 0x7fe17768ccc0 constant 1>
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7fe1776a13f0 precision:8 min <integer_cst 0x7fe1771ac720 -128> max <integer_cst 0x7fe1771ac708 127>
            pointer_to_this <pointer_type 0x7fe1771b5c78>>
        public unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality context <translation_unit_decl 0x7fe177697168 ./benchmarks/binutils/leak_7/binutils_leak_7.c>
        pointer_to_this <pointer_type 0x7fe1771bfbd0>>
    var <var_decl 0x7fe1771cf1b0 oldloc>
    def_stmt oldloc_19 = strdup (_5);
    version:19
    ptr-info 0x7fe1771ca828>
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_54 = VDEF <.MEM_45>
free (oldloc_19);
./benchmarks/binutils/leak_7/binutils_leak_7.c:116:7: warning: use location
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_51 = VDEF <.MEM_46>
free (oldloc_19);
./benchmarks/binutils/leak_7/binutils_leak_7.c:123:7: warning: use location
  123 |       xfree (oldloc);
      |       ^
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_48 = VDEF <.MEM_47>
free (oldloc_19);
./benchmarks/binutils/leak_7/binutils_leak_7.c:129:3: warning: use location
  129 |   xfree (oldloc);
      |   ^

 ================== Start Use after free Check ================== 

============================================================
# .MEM_51 = VDEF <.MEM_46>
free (oldloc_19);
./benchmarks/binutils/leak_7/binutils_leak_7.c:123:7: warning: Use after free error!: free location 
  123 |       xfree (oldloc);
      |       ^
# .MEM_47 = VDEF <.MEM_46>
setlocale ("LC_ALL", oldloc_19);
./benchmarks/binutils/leak_7/binutils_leak_7.c:128:3: warning: use location
  128 |   setlocale (LC_ALL, oldloc);
      |   ^

 ================== warring ================== 
[40;35m    Use after free error! [0m
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
# .MEM_54 = VDEF <.MEM_45>
free (oldloc_19);
./benchmarks/binutils/leak_7/binutils_leak_7.c:116:7: warning: Use after free error!: free location 
  116 |       xfree (oldloc);
      |       ^
# .MEM_47 = VDEF <.MEM_46>
setlocale ("LC_ALL", oldloc_19);
./benchmarks/binutils/leak_7/binutils_leak_7.c:128:3: warning: use location
  128 |   setlocale (LC_ALL, oldloc);
      |   ^

 ================== warring ================== 
[40;35m    Use after free error! [0m
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_54 = VDEF <.MEM_45>
free (oldloc_19);
./benchmarks/binutils/leak_7/binutils_leak_7.c:116:7: warning: Use after free error!: free location 
  116 |       xfree (oldloc);
      |       ^
# .MEM_47 = VDEF <.MEM_46>
setlocale ("LC_ALL", oldloc_19);
./benchmarks/binutils/leak_7/binutils_leak_7.c:128:3: warning: use location
  128 |   setlocale (LC_ALL, oldloc);
      |   ^

 ================== warring ================== 
[40;35m    Use after free error! [0m
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_51 = VDEF <.MEM_46>
free (oldloc_19);
./benchmarks/binutils/leak_7/binutils_leak_7.c:123:7: warning: Use after free error!: free location 
  123 |       xfree (oldloc);
      |       ^
# .MEM_47 = VDEF <.MEM_46>
setlocale ("LC_ALL", oldloc_19);
./benchmarks/binutils/leak_7/binutils_leak_7.c:128:3: warning: use location
  128 |   setlocale (LC_ALL, oldloc);
      |   ^

 ================== warring ================== 
[40;35m    Use after free error! [0m
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:3 [0m
[40;31m  	free count:3 [0m
[40;31m  	possible double free [Looserules]:3 [0m
[40;31m  	possible double free [rigorous]:3 [0m

======================================================================

======================================================================
[40;31m  	possible double free [rigorous]:3 [0m

======================================================================

dot graph START

======================================================================
 <ssa_name 0x7fe177694750
    type <pointer_type 0x7fe1771b5c78
        type <integer_type 0x7fe1771b59d8 char public QI
            size <integer_cst 0x7fe17768cca8 constant 8>
            unit-size <integer_cst 0x7fe17768ccc0 constant 1>
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7fe1776a13f0 precision:8 min <integer_cst 0x7fe1771ac720 -128> max <integer_cst 0x7fe1771ac708 127>
            pointer_to_this <pointer_type 0x7fe1771b5c78>>
        public unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality context <translation_unit_decl 0x7fe177697168 ./benchmarks/binutils/leak_7/binutils_leak_7.c>
        pointer_to_this <pointer_type 0x7fe1771bfbd0>>
   
    def_stmt _1 = python_libdir;
    version:1
    ptr-info 0x7fe1771ca798>
# VUSE <.MEM_39(D)>
_1 = python_libdir;

 ================== trace ptable================== 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr--------
this other function -----------
 
 Start check Pointer Collect  

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_40 = VDEF <.MEM_39(D)>
_2 = ldirname (_1);
bb index := 2
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 12

======================================================================
_2 = ldirname (_1);
./benchmarks/binutils/leak_7/binutils_leak_7.c:109:22: warning: use location
  109 |   progname = concat (ldirname (python_libdir), "bin");
      |                      ^
this stmt is child function---ldirname-----

 ================== trace ================== 
trace fucntion name:ldirname 
[40;44m =======trace_function_path ldirname  function_call count: 3 level :0========  [0m
[40;36m ======= node_fun:ldirname========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:memcpy========= [0m
[40;46m =======add node_fun stack:memcpy========= [0m
[40;42m =======pre add _ fucntion:malloc========= [0m
[40;46m =======add node_fun stack:malloc========= [0m
[40;42m =======pre add _ fucntion:lbasename========= [0m
[40;46m =======add node_fun stack:lbasename========= [0m
[40;44m =======trace_function_path lbasename  function_call count: 1 level :1========  [0m
[40;36m ======= node_fun:lbasename========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:unix_lbasename========= [0m
[40;46m =======add node_fun stack:unix_lbasename========= [0m
[40;44m =======trace_function_path unix_lbasename  function_call count: 0 level :2========  [0m
[40;36m ======= node_fun:unix_lbasename========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
fucntion collect path finsh

 ================== trace ================== 
trace fucntion free:0 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_41 = VDEF <.MEM_40>
progname_16 = concat (_2, "bin");
bb index := 2
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 12

======================================================================
progname_16 = concat (_2, "bin");
./benchmarks/binutils/leak_7/binutils_leak_7.c:109:14: warning: use location
  109 |   progname = concat (ldirname (python_libdir), "bin");
      |              ^
this stmt is child function---concat-----

 ================== trace ================== 
trace fucntion name:concat 
[40;44m =======trace_function_path concat  function_call count: 2 level :0========  [0m
[40;36m ======= node_fun:concat========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:vconcat_copy========= [0m
[40;46m =======add node_fun stack:vconcat_copy========= [0m
[40;44m =======trace_function_path vconcat_copy  function_call count: 2 level :1========  [0m
[40;36m ======= node_fun:vconcat_copy========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:memcpy========= [0m
[40;46m =======add node_fun stack:memcpy========= [0m
[40;42m =======pre add _ fucntion:strlen========= [0m
[40;46m =======add node_fun stack:strlen========= [0m
[40;42m =======pre add _ fucntion:malloc========= [0m
[40;46m =======add node_fun stack:malloc========= [0m

 ================== trace ================== 
trace fucntion free:0 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# VUSE <.MEM_44>
progsize_21 = strlen (progname_16);
bb index := 2
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 12

======================================================================
progsize_21 = strlen (progname_16);
./benchmarks/binutils/leak_7/binutils_leak_7.c:112:14: warning: use location
  112 |   progsize = strlen (progname);
      |              ^
this stmt is child function---strlen-----

 ================== trace ================== 
trace fucntion name:strlen 

 ================== trace ================== 
trace fucntion free:0 
_9 = progsize_21 + 1;
./benchmarks/binutils/leak_7/binutils_leak_7.c:120:11: warning: use location
  120 |   count = mbstowcs (progname_copy, progname, progsize + 1);
      |           ^
count_25 = mbstowcs (progname_copy_23, progname_16, _9);
./benchmarks/binutils/leak_7/binutils_leak_7.c:120:11: warning: use location
this stmt is child function---mbstowcs-----

 ================== trace ================== 
trace fucntion name:mbstowcs 

 ================== trace ================== 
trace fucntion free:0 
if (count_25 == 18446744073709551615)
./benchmarks/binutils/leak_7/binutils_leak_7.c:121:6: warning: use location
  121 |   if (count == (size_t) -1)
      |      ^
if (count_25 == 18446744073709551615)

 ================== find cond branch ================= 
./benchmarks/binutils/leak_7/binutils_leak_7.c:121:6: warning: use location
Cond in fucntion do_start_initialization basic block 4
 ================== possible direct basic block ================= 
from do_start_initialization basic block 5
 ================== possible direct basic block ================= 
from do_start_initialization basic block 6
 ================== warring ================== 
[40;35m    need check this branch possible have return or exit stmt [0m

 ================== warring ================== 

 ================== find cond branch ================= 
free (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:135:9: warning: use location
  135 |         xfree(progname_copy);
      |         ^
this stmt is child function---free-----

 ================== find ================== 
free (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:135:9: warning: use location
[40;32m    HAS FREE STMT count:1 name:free [0m

 ================== find ================== 
Py_SetProgramName (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:134:3: warning: use location
  134 |   Py_SetProgramName (progname_copy);
      |   ^
this stmt is child function---Py_SetProgramName-----

 ================== trace ================== 
trace fucntion name:Py_SetProgramName 
[40;44m =======trace_function_path Py_SetProgramName  function_call count: 1 level :0========  [0m
[40;36m ======= node_fun:Py_SetProgramName========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:printf========= [0m
[40;46m =======add node_fun stack:printf========= [0m

 ================== trace ================== 
trace fucntion free:1 
free (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:124:25: warning: use location
  124 |                         xfree(progname_copy);
      |                         ^
this stmt is child function---free-----

 ================== find ================== 
free (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:124:25: warning: use location
[40;32m    HAS FREE STMT count:2 name:free [0m

 ================== find ================== 

======================================================================
[40;31m    branch possiable have return or exit  [0m
if (progname_copy_23 == 0B)
bb index := 2
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 12

======================================================================
if (progname_copy_23 == 0B)
./benchmarks/binutils/leak_7/binutils_leak_7.c:114:6: warning: use location
  114 |   if (!progname_copy)
      |      ^
if (progname_copy_23 == 0B)

 ================== find cond branch ================= 
./benchmarks/binutils/leak_7/binutils_leak_7.c:114:6: warning: use location
Cond in fucntion do_start_initialization basic block 2
 ================== possible direct basic block ================= 
from do_start_initialization basic block 3
 ================== possible direct basic block ================= 
from do_start_initialization basic block 4
 ================== warring ================== 
[40;35m    need check this branch possible have return or exit stmt [0m

 ================== warring ================== 

 ================== find cond branch ================= 

======================================================================
[40;31m    branch possiable have return or exit  [0m
_6 = progsize_21 + 1;
bb index := 2
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 12

======================================================================
_6 = progsize_21 + 1;
./benchmarks/binutils/leak_7/binutils_leak_7.c:113:55: warning: use location
  113 |   progname_copy = (wchar_t *) PyMem_Malloc ((progsize + 1) * sizeof (wchar_t));
      |                                                       ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
_7 = _6 * 4;
bb index := 2
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 12

======================================================================
_7 = _6 * 4;
./benchmarks/binutils/leak_7/binutils_leak_7.c:113:31: warning: use location
  113 |   progname_copy = (wchar_t *) PyMem_Malloc ((progsize + 1) * sizeof (wchar_t));
      |                               ^

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7fe177694750
    type <pointer_type 0x7fe1771b5c78
        type <integer_type 0x7fe1771b59d8 char public QI
            size <integer_cst 0x7fe17768cca8 constant 8>
            unit-size <integer_cst 0x7fe17768ccc0 constant 1>
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7fe1776a13f0 precision:8 min <integer_cst 0x7fe1771ac720 -128> max <integer_cst 0x7fe1771ac708 127>
            pointer_to_this <pointer_type 0x7fe1771b5c78>>
        public unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality context <translation_unit_decl 0x7fe177697168 ./benchmarks/binutils/leak_7/binutils_leak_7.c>
        pointer_to_this <pointer_type 0x7fe1771bfbd0>>
   
    def_stmt _1 = python_libdir;
    version:1
    ptr-info 0x7fe1771ca798>

 ================== Start Use after free Check ================== 

============================================================
# .MEM_52 = VDEF <.MEM_51>
free (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:124:25: warning: Use after free error!: free location 
  124 |                         xfree(progname_copy);
      |                         ^
# .MEM_49 = VDEF <.MEM_48>
Py_SetProgramName (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:134:3: warning: use location
  134 |   Py_SetProgramName (progname_copy);
      |   ^

 ================== warring ================== 
[40;35m    Use after free error! [0m
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:0 [0m
[40;31m  	free count:2 [0m
[40;31m  	possible double free [rigorous]:2 [0m

======================================================================

======================================================================
[40;31m 	this stmt need double check [0m

======================================================================

dot graph START

======================================================================
 <ssa_name 0x7fe177694798
    type <pointer_type 0x7fe1771b5c78
        type <integer_type 0x7fe1771b59d8 char public QI
            size <integer_cst 0x7fe17768cca8 constant 8>
            unit-size <integer_cst 0x7fe17768ccc0 constant 1>
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7fe1776a13f0 precision:8 min <integer_cst 0x7fe1771ac720 -128> max <integer_cst 0x7fe1771ac708 127>
            pointer_to_this <pointer_type 0x7fe1771b5c78>>
        public unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality context <translation_unit_decl 0x7fe177697168 ./benchmarks/binutils/leak_7/binutils_leak_7.c>
        pointer_to_this <pointer_type 0x7fe1771bfbd0>>
   
    def_stmt _2 = ldirname (_1);
    version:2
    ptr-info 0x7fe1771ca7b0>
# .MEM_40 = VDEF <.MEM_39(D)>
_2 = ldirname (_1);

 ================== trace ptable================== 
trace fucntion name:ldirname 
[40;44m =======trace_function_path ldirname  function_call count: 3 level :888========  [0m
[40;36m ======= node_fun:ldirname========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:memcpy========= [0m
[40;46m =======add node_fun stack:memcpy========= [0m
[40;42m =======pre add _ fucntion:malloc========= [0m
[40;46m =======add node_fun stack:malloc========= [0m
[40;42m =======pre add _ fucntion:lbasename========= [0m
[40;46m =======add node_fun stack:lbasename========= [0m
[40;44m =======trace_function_path lbasename  function_call count: 1 level :889========  [0m
[40;36m ======= node_fun:lbasename========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:unix_lbasename========= [0m
[40;46m =======add node_fun stack:unix_lbasename========= [0m
[40;44m =======trace_function_path unix_lbasename  function_call count: 0 level :890========  [0m
[40;36m ======= node_fun:unix_lbasename========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
fucntion collect path finsh

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr---ldirname-----
this other function ------ldirname-----
 
 Start check Pointer Collect  

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_40 = VDEF <.MEM_39(D)>
_2 = ldirname (_1);
bb index := 2
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 12

======================================================================
_2 = ldirname (_1);
./benchmarks/binutils/leak_7/binutils_leak_7.c:109:22: warning: use location
  109 |   progname = concat (ldirname (python_libdir), "bin");
      |                      ^
this stmt is child function---ldirname-----

 ================== trace ================== 
trace fucntion name:ldirname 
[40;44m =======trace_function_path ldirname  function_call count: 3 level :0========  [0m
[40;36m ======= node_fun:ldirname========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:memcpy========= [0m
[40;46m =======add node_fun stack:memcpy========= [0m
[40;42m =======pre add _ fucntion:malloc========= [0m
[40;46m =======add node_fun stack:malloc========= [0m
[40;42m =======pre add _ fucntion:lbasename========= [0m
[40;46m =======add node_fun stack:lbasename========= [0m
[40;44m =======trace_function_path lbasename  function_call count: 1 level :1========  [0m
[40;36m ======= node_fun:lbasename========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:unix_lbasename========= [0m
[40;46m =======add node_fun stack:unix_lbasename========= [0m
[40;44m =======trace_function_path unix_lbasename  function_call count: 0 level :2========  [0m
[40;36m ======= node_fun:unix_lbasename========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
fucntion collect path finsh

 ================== trace ================== 
trace fucntion free:0 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_41 = VDEF <.MEM_40>
progname_16 = concat (_2, "bin");
bb index := 2
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 12

======================================================================
progname_16 = concat (_2, "bin");
./benchmarks/binutils/leak_7/binutils_leak_7.c:109:14: warning: use location
  109 |   progname = concat (ldirname (python_libdir), "bin");
      |              ^
this stmt is child function---concat-----

 ================== trace ================== 
trace fucntion name:concat 
[40;44m =======trace_function_path concat  function_call count: 2 level :0========  [0m
[40;36m ======= node_fun:concat========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:vconcat_copy========= [0m
[40;46m =======add node_fun stack:vconcat_copy========= [0m
[40;44m =======trace_function_path vconcat_copy  function_call count: 2 level :1========  [0m
[40;36m ======= node_fun:vconcat_copy========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:memcpy========= [0m
[40;46m =======add node_fun stack:memcpy========= [0m
[40;42m =======pre add _ fucntion:strlen========= [0m
[40;46m =======add node_fun stack:strlen========= [0m
[40;42m =======pre add _ fucntion:malloc========= [0m
[40;46m =======add node_fun stack:malloc========= [0m

 ================== trace ================== 
trace fucntion free:0 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# VUSE <.MEM_44>
progsize_21 = strlen (progname_16);
bb index := 2
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 12

======================================================================
progsize_21 = strlen (progname_16);
./benchmarks/binutils/leak_7/binutils_leak_7.c:112:14: warning: use location
  112 |   progsize = strlen (progname);
      |              ^
this stmt is child function---strlen-----

 ================== trace ================== 
trace fucntion name:strlen 

 ================== trace ================== 
trace fucntion free:0 
_9 = progsize_21 + 1;
./benchmarks/binutils/leak_7/binutils_leak_7.c:120:11: warning: use location
  120 |   count = mbstowcs (progname_copy, progname, progsize + 1);
      |           ^
count_25 = mbstowcs (progname_copy_23, progname_16, _9);
./benchmarks/binutils/leak_7/binutils_leak_7.c:120:11: warning: use location
this stmt is child function---mbstowcs-----

 ================== trace ================== 
trace fucntion name:mbstowcs 

 ================== trace ================== 
trace fucntion free:0 
if (count_25 == 18446744073709551615)
./benchmarks/binutils/leak_7/binutils_leak_7.c:121:6: warning: use location
  121 |   if (count == (size_t) -1)
      |      ^
if (count_25 == 18446744073709551615)

 ================== find cond branch ================= 
./benchmarks/binutils/leak_7/binutils_leak_7.c:121:6: warning: use location
Cond in fucntion do_start_initialization basic block 4
 ================== possible direct basic block ================= 
from do_start_initialization basic block 5
 ================== possible direct basic block ================= 
from do_start_initialization basic block 6
 ================== warring ================== 
[40;35m    need check this branch possible have return or exit stmt [0m

 ================== warring ================== 

 ================== find cond branch ================= 
free (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:135:9: warning: use location
  135 |         xfree(progname_copy);
      |         ^
this stmt is child function---free-----

 ================== find ================== 
free (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:135:9: warning: use location
[40;32m    HAS FREE STMT count:1 name:free [0m

 ================== find ================== 
Py_SetProgramName (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:134:3: warning: use location
  134 |   Py_SetProgramName (progname_copy);
      |   ^
this stmt is child function---Py_SetProgramName-----

 ================== trace ================== 
trace fucntion name:Py_SetProgramName 
[40;44m =======trace_function_path Py_SetProgramName  function_call count: 1 level :0========  [0m
[40;36m ======= node_fun:Py_SetProgramName========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:printf========= [0m
[40;46m =======add node_fun stack:printf========= [0m

 ================== trace ================== 
trace fucntion free:1 
free (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:124:25: warning: use location
  124 |                         xfree(progname_copy);
      |                         ^
this stmt is child function---free-----

 ================== find ================== 
free (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:124:25: warning: use location
[40;32m    HAS FREE STMT count:2 name:free [0m

 ================== find ================== 

======================================================================
[40;31m    branch possiable have return or exit  [0m
if (progname_copy_23 == 0B)
bb index := 2
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 12

======================================================================
if (progname_copy_23 == 0B)
./benchmarks/binutils/leak_7/binutils_leak_7.c:114:6: warning: use location
  114 |   if (!progname_copy)
      |      ^
if (progname_copy_23 == 0B)

 ================== find cond branch ================= 
./benchmarks/binutils/leak_7/binutils_leak_7.c:114:6: warning: use location
Cond in fucntion do_start_initialization basic block 2
 ================== possible direct basic block ================= 
from do_start_initialization basic block 3
 ================== possible direct basic block ================= 
from do_start_initialization basic block 4
 ================== warring ================== 
[40;35m    need check this branch possible have return or exit stmt [0m

 ================== warring ================== 

 ================== find cond branch ================= 

======================================================================
[40;31m    branch possiable have return or exit  [0m
_6 = progsize_21 + 1;
bb index := 2
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 12

======================================================================
_6 = progsize_21 + 1;
./benchmarks/binutils/leak_7/binutils_leak_7.c:113:55: warning: use location
  113 |   progname_copy = (wchar_t *) PyMem_Malloc ((progsize + 1) * sizeof (wchar_t));
      |                                                       ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
_7 = _6 * 4;
bb index := 2
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 12

======================================================================
_7 = _6 * 4;
./benchmarks/binutils/leak_7/binutils_leak_7.c:113:31: warning: use location
  113 |   progname_copy = (wchar_t *) PyMem_Malloc ((progsize + 1) * sizeof (wchar_t));
      |                               ^

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7fe177694798
    type <pointer_type 0x7fe1771b5c78
        type <integer_type 0x7fe1771b59d8 char public QI
            size <integer_cst 0x7fe17768cca8 constant 8>
            unit-size <integer_cst 0x7fe17768ccc0 constant 1>
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7fe1776a13f0 precision:8 min <integer_cst 0x7fe1771ac720 -128> max <integer_cst 0x7fe1771ac708 127>
            pointer_to_this <pointer_type 0x7fe1771b5c78>>
        public unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality context <translation_unit_decl 0x7fe177697168 ./benchmarks/binutils/leak_7/binutils_leak_7.c>
        pointer_to_this <pointer_type 0x7fe1771bfbd0>>
   
    def_stmt _2 = ldirname (_1);
    version:2
    ptr-info 0x7fe1771ca7b0>

 ================== Start Use after free Check ================== 

============================================================
# .MEM_52 = VDEF <.MEM_51>
free (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:124:25: warning: Use after free error!: free location 
  124 |                         xfree(progname_copy);
      |                         ^
# .MEM_49 = VDEF <.MEM_48>
Py_SetProgramName (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:134:3: warning: use location
  134 |   Py_SetProgramName (progname_copy);
      |   ^

 ================== warring ================== 
[40;35m    Use after free error! [0m
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:0 [0m
[40;31m  	free count:2 [0m
[40;31m  	possible double free [rigorous]:2 [0m

======================================================================

======================================================================
[40;31m 	this stmt need double check [0m

======================================================================

dot graph START

======================================================================
 <addr_expr 0x7fe177888ca0
    type <pointer_type 0x7fe1771c1000
        type <array_type 0x7fe1771bff18 type <integer_type 0x7fe1771b59d8 char>
            BLK
            size <integer_cst 0x7fe1771ac930 constant 56>
            unit-size <integer_cst 0x7fe1771ac918 constant 7>
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality domain <integer_type 0x7fe1771bfe70>
            pointer_to_this <pointer_type 0x7fe1771c1000>>
        unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
    readonly constant
    arg:0 <string_cst 0x7fe177888c80 type <array_type 0x7fe1771bff18>
        readonly constant static "LC_ALL\000">
    ./benchmarks/binutils/leak_7/binutils_leak_7.c:110:12 start: ./benchmarks/binutils/leak_7/binutils_leak_7.c:110:12 finish: ./benchmarks/binutils/leak_7/binutils_leak_7.c:110:12>

 ================== trace ptable================== 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr--------
this other function -----------

======================================================================
[40;35m  	Looserules free count:0 [0m
[40;31m  	free count:0 [0m

======================================================================

======================================================================
[40;31m 	Can't find this fucntion in Pointer table [0m
[40;31m 	Possiable no other stmt relate with this stmt [0m

======================================================================

dot graph START

======================================================================
 <ssa_name 0x7fe177694870
    type <pointer_type 0x7fe1771b5b28
        type <integer_type 0x7fe1771b5a80 char readonly public QI
            size <integer_cst 0x7fe17768cca8 constant 8>
            unit-size <integer_cst 0x7fe17768ccc0 constant 1>
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7fe1776a13f0 precision:8 min <integer_cst 0x7fe1771ac720 -128> max <integer_cst 0x7fe1771ac708 127>
            pointer_to_this <pointer_type 0x7fe1771b5b28>>
        public unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
   
    def_stmt _5 = (const char *) _4;
    version:5
    ptr-info 0x7fe1771ca7c8>
_5 = (const char *) _4;

 ================== trace ptable================== 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr--------
this other function -----------
 
 Start check Pointer Collect  

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_43 = VDEF <.MEM_42>
oldloc_19 = strdup (_5);
bb index := 2
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 12

======================================================================
oldloc_19 = strdup (_5);
./benchmarks/binutils/leak_7/binutils_leak_7.c:110:12: warning: use location
  110 |   oldloc = xstrdup (setlocale (LC_ALL, NULL));
      |            ^
this stmt is child function---strdup-----

 ================== trace ================== 
free (oldloc_19);
./benchmarks/binutils/leak_7/binutils_leak_7.c:129:3: warning: use location
  129 |   xfree (oldloc);
      |   ^
this stmt is child function---free-----

 ================== find ================== 
free (oldloc_19);
./benchmarks/binutils/leak_7/binutils_leak_7.c:129:3: warning: use location
[40;32m    HAS FREE STMT count:1 name:free [0m

 ================== find ================== 
setlocale ("LC_ALL", oldloc_19);
./benchmarks/binutils/leak_7/binutils_leak_7.c:128:3: warning: use location
  128 |   setlocale (LC_ALL, oldloc);
      |   ^
this stmt is child function---setlocale-----

 ================== trace ================== 
trace fucntion name:setlocale 

 ================== trace ================== 
trace fucntion free:1 
free (oldloc_19);
./benchmarks/binutils/leak_7/binutils_leak_7.c:123:7: warning: use location
  123 |       xfree (oldloc);
      |       ^
this stmt is child function---free-----

 ================== find ================== 
free (oldloc_19);
./benchmarks/binutils/leak_7/binutils_leak_7.c:123:7: warning: use location
[40;32m    HAS FREE STMT count:2 name:free [0m

 ================== find ================== 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_54 = VDEF <.MEM_45>
free (oldloc_19);
bb index := 3
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 3 ,possiable got to succ := 12

======================================================================
free (oldloc_19);
./benchmarks/binutils/leak_7/binutils_leak_7.c:116:7: warning: use location
  116 |       xfree (oldloc);
      |       ^
this stmt is child function---free-----

 ================== find ================== 
free (oldloc_19);
./benchmarks/binutils/leak_7/binutils_leak_7.c:116:7: warning: use location
[40;32m    HAS FREE STMT count:3 name:free [0m

 ================== find ================== 

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7fe177694870
    type <pointer_type 0x7fe1771b5b28
        type <integer_type 0x7fe1771b5a80 char readonly public QI
            size <integer_cst 0x7fe17768cca8 constant 8>
            unit-size <integer_cst 0x7fe17768ccc0 constant 1>
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7fe1776a13f0 precision:8 min <integer_cst 0x7fe1771ac720 -128> max <integer_cst 0x7fe1771ac708 127>
            pointer_to_this <pointer_type 0x7fe1771b5b28>>
        public unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
   
    def_stmt _5 = (const char *) _4;
    version:5
    ptr-info 0x7fe1771ca7c8>
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_54 = VDEF <.MEM_45>
free (oldloc_19);
./benchmarks/binutils/leak_7/binutils_leak_7.c:116:7: warning: use location
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_51 = VDEF <.MEM_46>
free (oldloc_19);
./benchmarks/binutils/leak_7/binutils_leak_7.c:123:7: warning: use location
  123 |       xfree (oldloc);
      |       ^
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_52 = VDEF <.MEM_51>
free (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:124:25: warning: use location
  124 |                         xfree(progname_copy);
      |                         ^
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_48 = VDEF <.MEM_47>
free (oldloc_19);
./benchmarks/binutils/leak_7/binutils_leak_7.c:129:3: warning: use location
  129 |   xfree (oldloc);
      |   ^
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_50 = VDEF <.MEM_49>
free (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:135:9: warning: use location
  135 |         xfree(progname_copy);
      |         ^

 ================== Start Use after free Check ================== 

============================================================
# .MEM_51 = VDEF <.MEM_46>
free (oldloc_19);
./benchmarks/binutils/leak_7/binutils_leak_7.c:123:7: warning: Use after free error!: free location 
  123 |       xfree (oldloc);
      |       ^
# .MEM_47 = VDEF <.MEM_46>
setlocale ("LC_ALL", oldloc_19);
./benchmarks/binutils/leak_7/binutils_leak_7.c:128:3: warning: use location
  128 |   setlocale (LC_ALL, oldloc);
      |   ^

 ================== warring ================== 
[40;35m    Use after free error! [0m
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
# .MEM_54 = VDEF <.MEM_45>
free (oldloc_19);
./benchmarks/binutils/leak_7/binutils_leak_7.c:116:7: warning: Use after free error!: free location 
  116 |       xfree (oldloc);
      |       ^
# .MEM_47 = VDEF <.MEM_46>
setlocale ("LC_ALL", oldloc_19);
./benchmarks/binutils/leak_7/binutils_leak_7.c:128:3: warning: use location
  128 |   setlocale (LC_ALL, oldloc);
      |   ^

 ================== warring ================== 
[40;35m    Use after free error! [0m
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_54 = VDEF <.MEM_45>
free (oldloc_19);
./benchmarks/binutils/leak_7/binutils_leak_7.c:116:7: warning: Use after free error!: free location 
  116 |       xfree (oldloc);
      |       ^
# .MEM_47 = VDEF <.MEM_46>
setlocale ("LC_ALL", oldloc_19);
./benchmarks/binutils/leak_7/binutils_leak_7.c:128:3: warning: use location
  128 |   setlocale (LC_ALL, oldloc);
      |   ^

 ================== warring ================== 
[40;35m    Use after free error! [0m
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_51 = VDEF <.MEM_46>
free (oldloc_19);
./benchmarks/binutils/leak_7/binutils_leak_7.c:123:7: warning: Use after free error!: free location 
  123 |       xfree (oldloc);
      |       ^
# .MEM_47 = VDEF <.MEM_46>
setlocale ("LC_ALL", oldloc_19);
./benchmarks/binutils/leak_7/binutils_leak_7.c:128:3: warning: use location
  128 |   setlocale (LC_ALL, oldloc);
      |   ^

 ================== warring ================== 
[40;35m    Use after free error! [0m
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_52 = VDEF <.MEM_51>
free (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:124:25: warning: Use after free error!: free location 
  124 |                         xfree(progname_copy);
      |                         ^
# .MEM_47 = VDEF <.MEM_46>
setlocale ("LC_ALL", oldloc_19);
./benchmarks/binutils/leak_7/binutils_leak_7.c:128:3: warning: use location
  128 |   setlocale (LC_ALL, oldloc);
      |   ^

 ================== warring ================== 
[40;35m    Use after free error! [0m
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:5 [0m
[40;31m  	free count:3 [0m
[40;31m  	possible double free [Looserules]:5 [0m
[40;31m  	possible double free [rigorous]:3 [0m

======================================================================

======================================================================
[40;31m  	possible double free [rigorous]:3 [0m

======================================================================

dot graph START

======================================================================
 <addr_expr 0x7fe177888d20
    type <pointer_type 0x7fe1771c1000
        type <array_type 0x7fe1771bff18 type <integer_type 0x7fe1771b59d8 char>
            BLK
            size <integer_cst 0x7fe1771ac930 constant 56>
            unit-size <integer_cst 0x7fe1771ac918 constant 7>
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality domain <integer_type 0x7fe1771bfe70>
            pointer_to_this <pointer_type 0x7fe1771c1000>>
        unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
    readonly constant
    arg:0 <string_cst 0x7fe177888d00 type <array_type 0x7fe1771bff18>
        readonly constant static "LC_ALL\000">
    ./benchmarks/binutils/leak_7/binutils_leak_7.c:111:14 start: ./benchmarks/binutils/leak_7/binutils_leak_7.c:111:14 finish: ./benchmarks/binutils/leak_7/binutils_leak_7.c:111:14>

 ================== trace ptable================== 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr--------
this other function -----------

======================================================================
[40;35m  	Looserules free count:0 [0m
[40;31m  	free count:0 [0m

======================================================================

======================================================================
[40;31m 	Can't find this fucntion in Pointer table [0m
[40;31m 	Possiable no other stmt relate with this stmt [0m

======================================================================

dot graph START

======================================================================
 <ssa_name 0x7fe177694a68
    type <pointer_type 0x7fe1771b5c78
        type <integer_type 0x7fe1771b59d8 char public QI
            size <integer_cst 0x7fe17768cca8 constant 8>
            unit-size <integer_cst 0x7fe17768ccc0 constant 1>
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7fe1776a13f0 precision:8 min <integer_cst 0x7fe1771ac720 -128> max <integer_cst 0x7fe1771ac708 127>
            pointer_to_this <pointer_type 0x7fe1771b5c78>>
        public unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality context <translation_unit_decl 0x7fe177697168 ./benchmarks/binutils/leak_7/binutils_leak_7.c>
        pointer_to_this <pointer_type 0x7fe1771bfbd0>>
    var <var_decl 0x7fe1771cf360 progname>
    def_stmt progname_16 = concat (_2, "bin");
    version:16
    ptr-info 0x7fe1771ca810>
# .MEM_41 = VDEF <.MEM_40>
progname_16 = concat (_2, "bin");

 ================== trace ptable================== 
trace fucntion name:concat 
[40;44m =======trace_function_path concat  function_call count: 2 level :888========  [0m
[40;36m ======= node_fun:concat========= [0m
[40;36m ======= find relate stmt with progname ========= [0m
[40;36m ======= relate stmt argument:progname ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:vconcat_copy========= [0m
[40;46m =======add node_fun stack:vconcat_copy========= [0m
[40;44m =======trace_function_path vconcat_copy  function_call count: 2 level :889========  [0m
[40;36m ======= node_fun:vconcat_copy========= [0m
[40;36m ======= find relate stmt with progname ========= [0m
[40;36m ======= relate stmt argument:progname ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:memcpy========= [0m
[40;46m =======add node_fun stack:memcpy========= [0m
[40;42m =======pre add _ fucntion:strlen========= [0m
[40;46m =======add node_fun stack:strlen========= [0m
[40;42m =======pre add _ fucntion:malloc========= [0m
[40;46m =======add node_fun stack:malloc========= [0m

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr---concat-----
this other function ------concat-----
 
 Start check Pointer Collect  

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_41 = VDEF <.MEM_40>
progname_16 = concat (_2, "bin");
bb index := 2
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 12

======================================================================
progname_16 = concat (_2, "bin");
./benchmarks/binutils/leak_7/binutils_leak_7.c:109:14: warning: use location
  109 |   progname = concat (ldirname (python_libdir), "bin");
      |              ^
this stmt is child function---concat-----

 ================== trace ================== 
trace fucntion name:concat 
[40;44m =======trace_function_path concat  function_call count: 2 level :0========  [0m
[40;36m ======= node_fun:concat========= [0m
[40;36m ======= find relate stmt with progname ========= [0m
[40;36m ======= relate stmt argument:progname ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:vconcat_copy========= [0m
[40;46m =======add node_fun stack:vconcat_copy========= [0m
[40;44m =======trace_function_path vconcat_copy  function_call count: 2 level :1========  [0m
[40;36m ======= node_fun:vconcat_copy========= [0m
[40;36m ======= find relate stmt with progname ========= [0m
[40;36m ======= relate stmt argument:progname ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:memcpy========= [0m
[40;46m =======add node_fun stack:memcpy========= [0m
[40;42m =======pre add _ fucntion:strlen========= [0m
[40;46m =======add node_fun stack:strlen========= [0m
[40;42m =======pre add _ fucntion:malloc========= [0m
[40;46m =======add node_fun stack:malloc========= [0m

 ================== trace ================== 
trace fucntion free:0 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# VUSE <.MEM_44>
progsize_21 = strlen (progname_16);
bb index := 2
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 12

======================================================================
progsize_21 = strlen (progname_16);
./benchmarks/binutils/leak_7/binutils_leak_7.c:112:14: warning: use location
  112 |   progsize = strlen (progname);
      |              ^
this stmt is child function---strlen-----

 ================== trace ================== 
trace fucntion name:strlen 

 ================== trace ================== 
trace fucntion free:0 
_9 = progsize_21 + 1;
./benchmarks/binutils/leak_7/binutils_leak_7.c:120:11: warning: use location
  120 |   count = mbstowcs (progname_copy, progname, progsize + 1);
      |           ^
count_25 = mbstowcs (progname_copy_23, progname_16, _9);
./benchmarks/binutils/leak_7/binutils_leak_7.c:120:11: warning: use location
this stmt is child function---mbstowcs-----

 ================== trace ================== 
trace fucntion name:mbstowcs 

 ================== trace ================== 
trace fucntion free:0 
if (count_25 == 18446744073709551615)
./benchmarks/binutils/leak_7/binutils_leak_7.c:121:6: warning: use location
  121 |   if (count == (size_t) -1)
      |      ^
if (count_25 == 18446744073709551615)

 ================== find cond branch ================= 
./benchmarks/binutils/leak_7/binutils_leak_7.c:121:6: warning: use location
Cond in fucntion do_start_initialization basic block 4
 ================== possible direct basic block ================= 
from do_start_initialization basic block 5
 ================== possible direct basic block ================= 
from do_start_initialization basic block 6
 ================== warring ================== 
[40;35m    need check this branch possible have return or exit stmt [0m

 ================== warring ================== 

 ================== find cond branch ================= 
free (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:135:9: warning: use location
  135 |         xfree(progname_copy);
      |         ^
this stmt is child function---free-----

 ================== find ================== 
free (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:135:9: warning: use location
[40;32m    HAS FREE STMT count:1 name:free [0m

 ================== find ================== 
Py_SetProgramName (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:134:3: warning: use location
  134 |   Py_SetProgramName (progname_copy);
      |   ^
this stmt is child function---Py_SetProgramName-----

 ================== trace ================== 
trace fucntion name:Py_SetProgramName 
[40;44m =======trace_function_path Py_SetProgramName  function_call count: 1 level :0========  [0m
[40;36m ======= node_fun:Py_SetProgramName========= [0m
[40;36m ======= find relate stmt with progname ========= [0m
[40;36m ======= relate stmt argument:progname ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:printf========= [0m
[40;46m =======add node_fun stack:printf========= [0m

 ================== trace ================== 
trace fucntion free:1 
free (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:124:25: warning: use location
  124 |                         xfree(progname_copy);
      |                         ^
this stmt is child function---free-----

 ================== find ================== 
free (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:124:25: warning: use location
[40;32m    HAS FREE STMT count:2 name:free [0m

 ================== find ================== 

======================================================================
[40;31m    branch possiable have return or exit  [0m
if (progname_copy_23 == 0B)
bb index := 2
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 12

======================================================================
if (progname_copy_23 == 0B)
./benchmarks/binutils/leak_7/binutils_leak_7.c:114:6: warning: use location
  114 |   if (!progname_copy)
      |      ^
if (progname_copy_23 == 0B)

 ================== find cond branch ================= 
./benchmarks/binutils/leak_7/binutils_leak_7.c:114:6: warning: use location
Cond in fucntion do_start_initialization basic block 2
 ================== possible direct basic block ================= 
from do_start_initialization basic block 3
 ================== possible direct basic block ================= 
from do_start_initialization basic block 4
 ================== warring ================== 
[40;35m    need check this branch possible have return or exit stmt [0m

 ================== warring ================== 

 ================== find cond branch ================= 

======================================================================
[40;31m    branch possiable have return or exit  [0m
_6 = progsize_21 + 1;
bb index := 2
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 12

======================================================================
_6 = progsize_21 + 1;
./benchmarks/binutils/leak_7/binutils_leak_7.c:113:55: warning: use location
  113 |   progname_copy = (wchar_t *) PyMem_Malloc ((progsize + 1) * sizeof (wchar_t));
      |                                                       ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
_7 = _6 * 4;
bb index := 2
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 12

======================================================================
_7 = _6 * 4;
./benchmarks/binutils/leak_7/binutils_leak_7.c:113:31: warning: use location
  113 |   progname_copy = (wchar_t *) PyMem_Malloc ((progsize + 1) * sizeof (wchar_t));
      |                               ^

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7fe177694a68
    type <pointer_type 0x7fe1771b5c78
        type <integer_type 0x7fe1771b59d8 char public QI
            size <integer_cst 0x7fe17768cca8 constant 8>
            unit-size <integer_cst 0x7fe17768ccc0 constant 1>
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7fe1776a13f0 precision:8 min <integer_cst 0x7fe1771ac720 -128> max <integer_cst 0x7fe1771ac708 127>
            pointer_to_this <pointer_type 0x7fe1771b5c78>>
        public unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality context <translation_unit_decl 0x7fe177697168 ./benchmarks/binutils/leak_7/binutils_leak_7.c>
        pointer_to_this <pointer_type 0x7fe1771bfbd0>>
    var <var_decl 0x7fe1771cf360 progname>
    def_stmt progname_16 = concat (_2, "bin");
    version:16
    ptr-info 0x7fe1771ca810>

 ================== Start Use after free Check ================== 

============================================================
# .MEM_52 = VDEF <.MEM_51>
free (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:124:25: warning: Use after free error!: free location 
  124 |                         xfree(progname_copy);
      |                         ^
# .MEM_49 = VDEF <.MEM_48>
Py_SetProgramName (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:134:3: warning: use location
  134 |   Py_SetProgramName (progname_copy);
      |   ^

 ================== warring ================== 
[40;35m    Use after free error! [0m
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:0 [0m
[40;31m  	free count:2 [0m
[40;31m  	possible double free [rigorous]:2 [0m

======================================================================

======================================================================
[40;31m 	this stmt need double check [0m

======================================================================

dot graph START

======================================================================
 <ssa_name 0x7fe177694900
    type <integer_type 0x7fe1776a17e0 long unsigned int public unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7fe1776a1738 precision:64 min <integer_cst 0x7fe17768ce88 0> max <integer_cst 0x7fe17768d500 18446744073709551615>
        pointer_to_this <pointer_type 0x7fe1776ad7e0>>
   
    def_stmt _7 = _6 * 4;
    version:7>
_7 = _6 * 4;

 ================== trace ptable================== 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr--------
this other function -----------
 
 Start check Pointer Collect  

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_45 = VDEF <.MEM_44>
progname_copy_23 = PyMem_Malloc (_7);
bb index := 2
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 12

======================================================================
progname_copy_23 = PyMem_Malloc (_7);
./benchmarks/binutils/leak_7/binutils_leak_7.c:113:31: warning: use location
  113 |   progname_copy = (wchar_t *) PyMem_Malloc ((progsize + 1) * sizeof (wchar_t));
      |                               ^
this stmt is child function---PyMem_Malloc-----

 ================== trace ================== 
trace fucntion name:PyMem_Malloc 
[40;44m =======trace_function_path PyMem_Malloc  function_call count: 1 level :0========  [0m
[40;42m =======pre add _ fucntion:malloc========= [0m
[40;46m =======add node_fun stack:malloc========= [0m

 ================== trace ================== 
trace fucntion free:0 
free (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:135:9: warning: use location
  135 |         xfree(progname_copy);
      |         ^
this stmt is child function---free-----

 ================== find ================== 
free (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:135:9: warning: use location
[40;32m    HAS FREE STMT count:1 name:free [0m

 ================== find ================== 
Py_SetProgramName (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:134:3: warning: use location
  134 |   Py_SetProgramName (progname_copy);
      |   ^
this stmt is child function---Py_SetProgramName-----

 ================== trace ================== 
trace fucntion name:Py_SetProgramName 
[40;44m =======trace_function_path Py_SetProgramName  function_call count: 1 level :0========  [0m
[40;42m =======pre add _ fucntion:printf========= [0m
[40;46m =======add node_fun stack:printf========= [0m

 ================== trace ================== 
trace fucntion free:1 
free (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:124:25: warning: use location
  124 |                         xfree(progname_copy);
      |                         ^
this stmt is child function---free-----

 ================== find ================== 
free (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:124:25: warning: use location
[40;32m    HAS FREE STMT count:2 name:free [0m

 ================== find ================== 
count_25 = mbstowcs (progname_copy_23, progname_16, _9);
./benchmarks/binutils/leak_7/binutils_leak_7.c:120:11: warning: use location
  120 |   count = mbstowcs (progname_copy, progname, progsize + 1);
      |           ^
this stmt is child function---mbstowcs-----

 ================== trace ================== 
trace fucntion name:mbstowcs 

 ================== trace ================== 
trace fucntion free:2 
if (count_25 == 18446744073709551615)
./benchmarks/binutils/leak_7/binutils_leak_7.c:121:6: warning: use location
  121 |   if (count == (size_t) -1)
      |      ^
if (count_25 == 18446744073709551615)

 ================== find cond branch ================= 
./benchmarks/binutils/leak_7/binutils_leak_7.c:121:6: warning: use location
Cond in fucntion do_start_initialization basic block 4
 ================== possible direct basic block ================= 
from do_start_initialization basic block 5
 ================== possible direct basic block ================= 
from do_start_initialization basic block 6
 ================== warring ================== 
[40;35m    need check this branch possible have return or exit stmt [0m

 ================== warring ================== 

 ================== find cond branch ================= 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# VUSE <.MEM_44>
progsize_21 = strlen (progname_16);
bb index := 2
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 12

======================================================================
progsize_21 = strlen (progname_16);
./benchmarks/binutils/leak_7/binutils_leak_7.c:112:14: warning: use location
  112 |   progsize = strlen (progname);
      |              ^
this stmt is child function---strlen-----

 ================== trace ================== 
trace fucntion name:strlen 

 ================== trace ================== 
trace fucntion free:2 
_9 = progsize_21 + 1;
./benchmarks/binutils/leak_7/binutils_leak_7.c:120:11: warning: use location
  120 |   count = mbstowcs (progname_copy, progname, progsize + 1);
      |           ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
_6 = progsize_21 + 1;
bb index := 2
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 12

======================================================================
_6 = progsize_21 + 1;
./benchmarks/binutils/leak_7/binutils_leak_7.c:113:55: warning: use location
  113 |   progname_copy = (wchar_t *) PyMem_Malloc ((progsize + 1) * sizeof (wchar_t));
      |                                                       ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
_7 = _6 * 4;
bb index := 2
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 12

======================================================================
_7 = _6 * 4;
./benchmarks/binutils/leak_7/binutils_leak_7.c:113:31: warning: use location
  113 |   progname_copy = (wchar_t *) PyMem_Malloc ((progsize + 1) * sizeof (wchar_t));
      |                               ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
if (progname_copy_23 == 0B)
bb index := 2
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 12

======================================================================
if (progname_copy_23 == 0B)
./benchmarks/binutils/leak_7/binutils_leak_7.c:114:6: warning: use location
  114 |   if (!progname_copy)
      |      ^
if (progname_copy_23 == 0B)

 ================== find cond branch ================= 
./benchmarks/binutils/leak_7/binutils_leak_7.c:114:6: warning: use location
Cond in fucntion do_start_initialization basic block 2
 ================== possible direct basic block ================= 
from do_start_initialization basic block 3
 ================== possible direct basic block ================= 
from do_start_initialization basic block 4
 ================== warring ================== 
[40;35m    need check this branch possible have return or exit stmt [0m

 ================== warring ================== 

 ================== find cond branch ================= 

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7fe177694900
    type <integer_type 0x7fe1776a17e0 long unsigned int public unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7fe1776a1738 precision:64 min <integer_cst 0x7fe17768ce88 0> max <integer_cst 0x7fe17768d500 18446744073709551615>
        pointer_to_this <pointer_type 0x7fe1776ad7e0>>
   
    def_stmt _7 = _6 * 4;
    version:7>
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_54 = VDEF <.MEM_45>
free (oldloc_19);
./benchmarks/binutils/leak_7/binutils_leak_7.c:116:7: warning: use location
  116 |       xfree (oldloc);
      |       ^
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_51 = VDEF <.MEM_46>
free (oldloc_19);
./benchmarks/binutils/leak_7/binutils_leak_7.c:123:7: warning: use location
  123 |       xfree (oldloc);
      |       ^
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_52 = VDEF <.MEM_51>
free (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:124:25: warning: use location
  124 |                         xfree(progname_copy);
      |                         ^
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_48 = VDEF <.MEM_47>
free (oldloc_19);
./benchmarks/binutils/leak_7/binutils_leak_7.c:129:3: warning: use location
  129 |   xfree (oldloc);
      |   ^
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_50 = VDEF <.MEM_49>
free (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:135:9: warning: use location
  135 |         xfree(progname_copy);
      |         ^

 ================== Start Use after free Check ================== 

============================================================
# .MEM_52 = VDEF <.MEM_51>
free (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:124:25: warning: Use after free error!: free location 
  124 |                         xfree(progname_copy);
      |                         ^
# .MEM_49 = VDEF <.MEM_48>
Py_SetProgramName (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:134:3: warning: use location
  134 |   Py_SetProgramName (progname_copy);
      |   ^

 ================== warring ================== 
[40;35m    Use after free error! [0m
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_54 = VDEF <.MEM_45>
free (oldloc_19);
./benchmarks/binutils/leak_7/binutils_leak_7.c:116:7: warning: Use after free error!: free location 
  116 |       xfree (oldloc);
      |       ^
# .MEM_49 = VDEF <.MEM_48>
Py_SetProgramName (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:134:3: warning: use location
  134 |   Py_SetProgramName (progname_copy);
      |   ^

 ================== warring ================== 
[40;35m    Use after free error! [0m
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_51 = VDEF <.MEM_46>
free (oldloc_19);
./benchmarks/binutils/leak_7/binutils_leak_7.c:123:7: warning: Use after free error!: free location 
  123 |       xfree (oldloc);
      |       ^
# .MEM_49 = VDEF <.MEM_48>
Py_SetProgramName (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:134:3: warning: use location
  134 |   Py_SetProgramName (progname_copy);
      |   ^

 ================== warring ================== 
[40;35m    Use after free error! [0m
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_52 = VDEF <.MEM_51>
free (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:124:25: warning: Use after free error!: free location 
  124 |                         xfree(progname_copy);
      |                         ^
# .MEM_49 = VDEF <.MEM_48>
Py_SetProgramName (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:134:3: warning: use location
  134 |   Py_SetProgramName (progname_copy);
      |   ^

 ================== warring ================== 
[40;35m    Use after free error! [0m
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_48 = VDEF <.MEM_47>
free (oldloc_19);
./benchmarks/binutils/leak_7/binutils_leak_7.c:129:3: warning: Use after free error!: free location 
  129 |   xfree (oldloc);
      |   ^
# .MEM_49 = VDEF <.MEM_48>
Py_SetProgramName (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:134:3: warning: use location
  134 |   Py_SetProgramName (progname_copy);
      |   ^

 ================== warring ================== 
[40;35m    Use after free error! [0m
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_54 = VDEF <.MEM_45>
free (oldloc_19);
./benchmarks/binutils/leak_7/binutils_leak_7.c:116:7: warning: Use after free error!: free location 
  116 |       xfree (oldloc);
      |       ^
# .MEM_46 = VDEF <.MEM_45>
count_25 = mbstowcs (progname_copy_23, progname_16, _9);
./benchmarks/binutils/leak_7/binutils_leak_7.c:120:11: warning: use location
  120 |   count = mbstowcs (progname_copy, progname, progsize + 1);
      |           ^

 ================== warring ================== 
[40;35m    Use after free error! [0m
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_54 = VDEF <.MEM_45>
free (oldloc_19);
./benchmarks/binutils/leak_7/binutils_leak_7.c:116:7: warning: Use after free error!: free location 
  116 |       xfree (oldloc);
      |       ^
if (count_25 == 18446744073709551615)
./benchmarks/binutils/leak_7/binutils_leak_7.c:121:6: warning: use location
  121 |   if (count == (size_t) -1)
      |      ^

 ================== warring ================== 
[40;35m    Use after free error! [0m
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_54 = VDEF <.MEM_45>
free (oldloc_19);
./benchmarks/binutils/leak_7/binutils_leak_7.c:116:7: warning: Use after free error!: free location 
  116 |       xfree (oldloc);
      |       ^
_9 = progsize_21 + 1;
./benchmarks/binutils/leak_7/binutils_leak_7.c:120:11: warning: use location
  120 |   count = mbstowcs (progname_copy, progname, progsize + 1);
      |           ^

 ================== warring ================== 
[40;35m    Use after free error! [0m
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:5 [0m
[40;31m  	free count:2 [0m
[40;31m  	possible double free [Looserules]:5 [0m
[40;31m  	possible double free [rigorous]:2 [0m

======================================================================

======================================================================
[40;31m 	this stmt need double check [0m

======================================================================

dot graph START

======================================================================
 <addr_expr 0x7fe177888e00
    type <pointer_type 0x7fe1771c15e8
        type <array_type 0x7fe1771c1540 type <integer_type 0x7fe1771b59d8 char>
            BLK
            size <integer_cst 0x7fe1771ac978 constant 120>
            unit-size <integer_cst 0x7fe1771ac960 constant 15>
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality domain <integer_type 0x7fe1771c1498>
            pointer_to_this <pointer_type 0x7fe1771c15e8>>
        unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
    readonly constant
    arg:0 <string_cst 0x7fe1771cb9d8 type <array_type 0x7fe1771c1540>
        readonly constant static "out of memory\012\000">
    ./benchmarks/binutils/leak_7/binutils_leak_7.c:117:24 start: ./benchmarks/binutils/leak_7/binutils_leak_7.c:117:24 finish: ./benchmarks/binutils/leak_7/binutils_leak_7.c:117:24>

 ================== trace ptable================== 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr--------
this other function -----------

======================================================================
[40;35m  	Looserules free count:0 [0m
[40;31m  	free count:0 [0m

======================================================================

======================================================================
[40;31m 	Can't find this fucntion in Pointer table [0m
[40;31m 	Possiable no other stmt relate with this stmt [0m

======================================================================

dot graph START

======================================================================
 <ssa_name 0x7fe177694b40
    type <pointer_type 0x7fe1771bf2a0
        type <integer_type 0x7fe1771bf1f8 wchar_t SI
            size <integer_cst 0x7fe17768cdf8 constant 32>
            unit-size <integer_cst 0x7fe17768ce10 constant 4>
            align:32 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7fe1776a15e8 precision:32 min <integer_cst 0x7fe17768cdb0 -2147483648> max <integer_cst 0x7fe17768cdc8 2147483647> context <translation_unit_decl 0x7fe177697168 ./benchmarks/binutils/leak_7/binutils_leak_7.c>
            pointer_to_this <pointer_type 0x7fe1771bf2a0>>
        public unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
    var <var_decl 0x7fe1771cf120 progname_copy>
    def_stmt progname_copy_23 = PyMem_Malloc (_7);
    version:23
    ptr-info 0x7fe1771ca840>
# .MEM_45 = VDEF <.MEM_44>
progname_copy_23 = PyMem_Malloc (_7);

 ================== trace ptable================== 
trace fucntion name:PyMem_Malloc 
[40;44m =======trace_function_path PyMem_Malloc  function_call count: 1 level :888========  [0m
[40;36m ======= node_fun:PyMem_Malloc========= [0m
[40;36m ======= find relate stmt with progname_copy ========= [0m
[40;36m ======= relate stmt argument:progname_copy ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:malloc========= [0m
[40;46m =======add node_fun stack:malloc========= [0m

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr---PyMem_Malloc-----
this other function ------PyMem_Malloc-----
 
 Start check Pointer Collect  

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_45 = VDEF <.MEM_44>
progname_copy_23 = PyMem_Malloc (_7);
bb index := 2
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 12

======================================================================
progname_copy_23 = PyMem_Malloc (_7);
./benchmarks/binutils/leak_7/binutils_leak_7.c:113:31: warning: use location
  113 |   progname_copy = (wchar_t *) PyMem_Malloc ((progsize + 1) * sizeof (wchar_t));
      |                               ^
this stmt is child function---PyMem_Malloc-----

 ================== trace ================== 
trace fucntion name:PyMem_Malloc 
[40;44m =======trace_function_path PyMem_Malloc  function_call count: 1 level :0========  [0m
[40;36m ======= node_fun:PyMem_Malloc========= [0m
[40;36m ======= find relate stmt with progname_copy ========= [0m
[40;36m ======= relate stmt argument:progname_copy ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:malloc========= [0m
[40;46m =======add node_fun stack:malloc========= [0m

 ================== trace ================== 
trace fucntion free:0 
free (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:135:9: warning: use location
  135 |         xfree(progname_copy);
      |         ^
this stmt is child function---free-----

 ================== find ================== 
free (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:135:9: warning: use location
[40;32m    HAS FREE STMT count:1 name:free [0m

 ================== find ================== 
Py_SetProgramName (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:134:3: warning: use location
  134 |   Py_SetProgramName (progname_copy);
      |   ^
this stmt is child function---Py_SetProgramName-----

 ================== trace ================== 
trace fucntion name:Py_SetProgramName 
[40;44m =======trace_function_path Py_SetProgramName  function_call count: 1 level :0========  [0m
[40;36m ======= node_fun:Py_SetProgramName========= [0m
[40;36m ======= find relate stmt with progname_copy ========= [0m
[40;36m ======= relate stmt argument:progname_copy ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:printf========= [0m
[40;46m =======add node_fun stack:printf========= [0m

 ================== trace ================== 
trace fucntion free:1 
free (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:124:25: warning: use location
  124 |                         xfree(progname_copy);
      |                         ^
this stmt is child function---free-----

 ================== find ================== 
free (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:124:25: warning: use location
[40;32m    HAS FREE STMT count:2 name:free [0m

 ================== find ================== 
count_25 = mbstowcs (progname_copy_23, progname_16, _9);
./benchmarks/binutils/leak_7/binutils_leak_7.c:120:11: warning: use location
  120 |   count = mbstowcs (progname_copy, progname, progsize + 1);
      |           ^
this stmt is child function---mbstowcs-----

 ================== trace ================== 
trace fucntion name:mbstowcs 

 ================== trace ================== 
trace fucntion free:2 
if (count_25 == 18446744073709551615)
./benchmarks/binutils/leak_7/binutils_leak_7.c:121:6: warning: use location
  121 |   if (count == (size_t) -1)
      |      ^
if (count_25 == 18446744073709551615)

 ================== find cond branch ================= 
./benchmarks/binutils/leak_7/binutils_leak_7.c:121:6: warning: use location
Cond in fucntion do_start_initialization basic block 4
 ================== possible direct basic block ================= 
from do_start_initialization basic block 5
 ================== possible direct basic block ================= 
from do_start_initialization basic block 6
 ================== warring ================== 
[40;35m    need check this branch possible have return or exit stmt [0m

 ================== warring ================== 

 ================== find cond branch ================= 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# VUSE <.MEM_44>
progsize_21 = strlen (progname_16);
bb index := 2
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 12

======================================================================
progsize_21 = strlen (progname_16);
./benchmarks/binutils/leak_7/binutils_leak_7.c:112:14: warning: use location
  112 |   progsize = strlen (progname);
      |              ^
this stmt is child function---strlen-----

 ================== trace ================== 
trace fucntion name:strlen 

 ================== trace ================== 
trace fucntion free:2 
_9 = progsize_21 + 1;
./benchmarks/binutils/leak_7/binutils_leak_7.c:120:11: warning: use location
  120 |   count = mbstowcs (progname_copy, progname, progsize + 1);
      |           ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
_6 = progsize_21 + 1;
bb index := 2
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 12

======================================================================
_6 = progsize_21 + 1;
./benchmarks/binutils/leak_7/binutils_leak_7.c:113:55: warning: use location
  113 |   progname_copy = (wchar_t *) PyMem_Malloc ((progsize + 1) * sizeof (wchar_t));
      |                                                       ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
if (progname_copy_23 == 0B)
bb index := 2
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 12

======================================================================
if (progname_copy_23 == 0B)
./benchmarks/binutils/leak_7/binutils_leak_7.c:114:6: warning: use location
  114 |   if (!progname_copy)
      |      ^
if (progname_copy_23 == 0B)

 ================== find cond branch ================= 
./benchmarks/binutils/leak_7/binutils_leak_7.c:114:6: warning: use location
Cond in fucntion do_start_initialization basic block 2
 ================== possible direct basic block ================= 
from do_start_initialization basic block 3
 ================== possible direct basic block ================= 
from do_start_initialization basic block 4
 ================== warring ================== 
[40;35m    need check this branch possible have return or exit stmt [0m

 ================== warring ================== 

 ================== find cond branch ================= 

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7fe177694b40
    type <pointer_type 0x7fe1771bf2a0
        type <integer_type 0x7fe1771bf1f8 wchar_t SI
            size <integer_cst 0x7fe17768cdf8 constant 32>
            unit-size <integer_cst 0x7fe17768ce10 constant 4>
            align:32 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7fe1776a15e8 precision:32 min <integer_cst 0x7fe17768cdb0 -2147483648> max <integer_cst 0x7fe17768cdc8 2147483647> context <translation_unit_decl 0x7fe177697168 ./benchmarks/binutils/leak_7/binutils_leak_7.c>
            pointer_to_this <pointer_type 0x7fe1771bf2a0>>
        public unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
    var <var_decl 0x7fe1771cf120 progname_copy>
    def_stmt progname_copy_23 = PyMem_Malloc (_7);
    version:23
    ptr-info 0x7fe1771ca840>
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_52 = VDEF <.MEM_51>
free (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:124:25: warning: use location
  124 |                         xfree(progname_copy);
      |                         ^
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_50 = VDEF <.MEM_49>
free (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:135:9: warning: use location
  135 |         xfree(progname_copy);
      |         ^

 ================== Start Use after free Check ================== 

============================================================
# .MEM_52 = VDEF <.MEM_51>
free (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:124:25: warning: Use after free error!: free location 
  124 |                         xfree(progname_copy);
      |                         ^
# .MEM_49 = VDEF <.MEM_48>
Py_SetProgramName (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:134:3: warning: use location
  134 |   Py_SetProgramName (progname_copy);
      |   ^

 ================== warring ================== 
[40;35m    Use after free error! [0m
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_52 = VDEF <.MEM_51>
free (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:124:25: warning: Use after free error!: free location 
  124 |                         xfree(progname_copy);
      |                         ^
# .MEM_49 = VDEF <.MEM_48>
Py_SetProgramName (progname_copy_23);
./benchmarks/binutils/leak_7/binutils_leak_7.c:134:3: warning: use location
  134 |   Py_SetProgramName (progname_copy);
      |   ^

 ================== warring ================== 
[40;35m    Use after free error! [0m
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:2 [0m
[40;31m  	free count:2 [0m
[40;31m  	possible double free [Looserules]:2 [0m
[40;31m  	possible double free [rigorous]:2 [0m

======================================================================

======================================================================
[40;31m 	this stmt need double check [0m

======================================================================

dot graph START

======================================================================
 <addr_expr 0x7fe177888f00
    type <pointer_type 0x7fe1771c1930
        type <array_type 0x7fe1771c1888 type <integer_type 0x7fe1771b59d8 char>
            BLK
            size <integer_cst 0x7fe1771ac8a0 constant 328>
            unit-size <integer_cst 0x7fe1771ac9a8 constant 41>
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality domain <integer_type 0x7fe1771c17e0>
            pointer_to_this <pointer_type 0x7fe1771c1930>>
        unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
    readonly constant
    arg:0 <string_cst 0x7fe17769f040 type <array_type 0x7fe1771c1888>
        readonly constant static "Could not convert python path to string\012\000">
    ./benchmarks/binutils/leak_7/binutils_leak_7.c:125:24 start: ./benchmarks/binutils/leak_7/binutils_leak_7.c:125:24 finish: ./benchmarks/binutils/leak_7/binutils_leak_7.c:125:24>

 ================== trace ptable================== 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr--------
this other function -----------

======================================================================
[40;35m  	Looserules free count:0 [0m
[40;31m  	free count:0 [0m

======================================================================

======================================================================
[40;31m 	Can't find this fucntion in Pointer table [0m
[40;31m 	Possiable no other stmt relate with this stmt [0m

======================================================================

dot graph START

======================================================================
 <addr_expr 0x7fe177888f80
    type <pointer_type 0x7fe1771c1000
        type <array_type 0x7fe1771bff18 type <integer_type 0x7fe1771b59d8 char>
            BLK
            size <integer_cst 0x7fe1771ac930 constant 56>
            unit-size <integer_cst 0x7fe1771ac918 constant 7>
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality domain <integer_type 0x7fe1771bfe70>
            pointer_to_this <pointer_type 0x7fe1771c1000>>
        unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
    readonly constant
    arg:0 <string_cst 0x7fe177888f60 type <array_type 0x7fe1771bff18>
        readonly constant static "LC_ALL\000">
    ./benchmarks/binutils/leak_7/binutils_leak_7.c:128:14 start: ./benchmarks/binutils/leak_7/binutils_leak_7.c:128:14 finish: ./benchmarks/binutils/leak_7/binutils_leak_7.c:128:14>

 ================== trace ptable================== 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr--------
this other function -----------

======================================================================
[40;35m  	Looserules free count:0 [0m
[40;31m  	free count:0 [0m

======================================================================

======================================================================
[40;31m 	Can't find this fucntion in Pointer table [0m
[40;31m 	Possiable no other stmt relate with this stmt [0m

======================================================================
[40;33m =======POP node_fun stack:do_start_initialization========= [0m
[40;44m =======node_fun:Py_SetProgramName========= [0m
[40;44m fucntion collect path  [0m
[40;44m =======print_function_path Py_SetProgramName  function_call count: 1 level :0========  [0m
[40;44m =======print_function_type 0  ========  [0m
[40;42m =======pre add _ fucntion:printf========= [0m
[40;33m =======POP node_fun stack:printf========= [0m
[40;42m =======pre_check_funciton:Py_SetProgramName========= [0m
[40;42m =======start_check_funciton:Py_SetProgramName========= [0m

dot graph START

======================================================================
 <addr_expr 0x7fe1771d6080
    type <pointer_type 0x7fe1771bfa80
        type <array_type 0x7fe1771bf9d8 type <integer_type 0x7fe1771b59d8 char>
            SI
            size <integer_cst 0x7fe17768cdf8 constant 32>
            unit-size <integer_cst 0x7fe17768ce10 constant 4>
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality domain <integer_type 0x7fe1771bf930>
            pointer_to_this <pointer_type 0x7fe1771bfa80>>
        unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
    readonly constant
    arg:0 <string_cst 0x7fe1771d6060 type <array_type 0x7fe1771bf9d8>
        readonly constant static "%d\012\000">
    ./benchmarks/binutils/leak_7/binutils_leak_7.c:91:2 start: ./benchmarks/binutils/leak_7/binutils_leak_7.c:91:2 finish: ./benchmarks/binutils/leak_7/binutils_leak_7.c:91:2>

 ================== trace ptable================== 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr--------
this other function -----------

======================================================================
[40;35m  	Looserules free count:0 [0m
[40;31m  	free count:0 [0m

======================================================================

======================================================================
[40;31m 	Can't find this fucntion in Pointer table [0m
[40;31m 	Possiable no other stmt relate with this stmt [0m

======================================================================
[40;33m =======POP node_fun stack:Py_SetProgramName========= [0m
[40;44m =======node_fun:PyMem_Malloc========= [0m
[40;44m fucntion collect path  [0m
[40;44m =======print_function_path PyMem_Malloc  function_call count: 1 level :0========  [0m
[40;44m =======print_function_type 2  ========  [0m
[40;42m =======pre add _ fucntion:malloc========= [0m
[40;33m =======POP node_fun stack:malloc========= [0m
[40;42m =======pre_check_funciton:PyMem_Malloc========= [0m
[40;42m =======start_check_funciton:PyMem_Malloc========= [0m

dot graph START

======================================================================
 <ssa_name 0x7fe1771d5360
    type <pointer_type 0x7fe1776a8000
        type <void_type 0x7fe1776a1f18 void VOID
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality
            pointer_to_this <pointer_type 0x7fe1776a8000>>
        public unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality
        pointer_to_this <pointer_type 0x7fe1776ad9d8>>
    var <var_decl 0x7fe1771cfd80 ret>
    def_stmt ret_4 = malloc (size_2(D));
    version:4
    ptr-info 0x7fe1771ca870>
# .MEM_6 = VDEF <.MEM_5(D)>
ret_4 = malloc (size_2(D));

 ================== trace ptable================== 
trace fucntion name:malloc 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr---malloc-----
this Reserved word function ------malloc-----
 
 Start check Pointer Collect  

======================================================================
return ret_4;
In function â€˜PyMem_Mallocâ€™:
./benchmarks/binutils/leak_7/binutils_leak_7.c:87:16: warning: use location
   87 |         return ret;
      |                ^
ret_4 = malloc (size_2(D));
./benchmarks/binutils/leak_7/binutils_leak_7.c:86:21: warning: use location
   86 |         void *ret = malloc(size);
      |                     ^
this stmt is child function---malloc-----

 ================== trace ================== 

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7fe1771d5360
    type <pointer_type 0x7fe1776a8000
        type <void_type 0x7fe1776a1f18 void VOID
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality
            pointer_to_this <pointer_type 0x7fe1776a8000>>
        public unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality
        pointer_to_this <pointer_type 0x7fe1776ad9d8>>
    var <var_decl 0x7fe1771cfd80 ret>
    def_stmt ret_4 = malloc (size_2(D));
    version:4
    ptr-info 0x7fe1771ca870>

 ================== Start Use after free Check ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:0 [0m
[40;31m  	free count:0 [0m

======================================================================

======================================================================
[40;31m    no free stmt possible memory leak [0m

======================================================================

dot graph START

======================================================================
 <ssa_name 0x7fe1771d5318
    type <integer_type 0x7fe1771b5f18 size_t public unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7fe1776a1738 precision:64 min <integer_cst 0x7fe17768ce88 0> max <integer_cst 0x7fe17768d500 18446744073709551615> context <translation_unit_decl 0x7fe177697168 ./benchmarks/binutils/leak_7/binutils_leak_7.c>>
    var <parm_decl 0x7fe1771c5300 size>
    def_stmt GIMPLE_NOP
    version:2>
GIMPLE_NOP

 ================== trace ptable================== 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr--------
this other function -----------
 
 Start check Pointer Collect  

======================================================================
ret_4 = malloc (size_2(D));
./benchmarks/binutils/leak_7/binutils_leak_7.c:86:21: warning: use location
this stmt is child function---malloc-----

 ================== trace ================== 
ret_4 = malloc (size_2(D));
./benchmarks/binutils/leak_7/binutils_leak_7.c:86:21: warning: use location
this stmt is child function---malloc-----

 ================== trace ================== 

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7fe1771d5318
    type <integer_type 0x7fe1771b5f18 size_t public unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7fe1776a1738 precision:64 min <integer_cst 0x7fe17768ce88 0> max <integer_cst 0x7fe17768d500 18446744073709551615> context <translation_unit_decl 0x7fe177697168 ./benchmarks/binutils/leak_7/binutils_leak_7.c>>
    var <parm_decl 0x7fe1771c5300 size>
    def_stmt GIMPLE_NOP
    version:2>

 ================== Start Use after free Check ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:0 [0m
[40;31m  	free count:0 [0m

======================================================================

======================================================================
[40;31m    no free stmt possible memory leak [0m

======================================================================
[40;33m =======POP node_fun stack:PyMem_Malloc========= [0m
[40;44m =======node_fun:concat========= [0m
[40;44m fucntion collect path  [0m
[40;44m =======print_function_path concat  function_call count: 2 level :0========  [0m
[40;44m =======print_function_type 2  ========  [0m
[40;42m =======pre add _ fucntion:vconcat_copy========= [0m
[40;44m =======print_function_type 0  ========  [0m
[40;44m =======print_function_path vconcat_copy  function_call count: 2 level :1========  [0m
[40;44m =======print_function_type 0  ========  [0m
[40;42m =======pre add _ fucntion:memcpy========= [0m
[40;33m =======POP node_fun stack:memcpy========= [0m
[40;42m =======pre add _ fucntion:strlen========= [0m
[40;33m =======POP node_fun stack:strlen========= [0m
[40;42m =======pre_check_funciton:vconcat_copy========= [0m
[40;42m =======start_check_funciton:vconcat_copy========= [0m

dot graph START

======================================================================
 <ssa_name 0x7fe1771d5678
    type <pointer_type 0x7fe1771b5b28
        type <integer_type 0x7fe1771b5a80 char readonly public QI
            size <integer_cst 0x7fe17768cca8 constant 8>
            unit-size <integer_cst 0x7fe17768ccc0 constant 1>
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7fe1776a13f0 precision:8 min <integer_cst 0x7fe1771ac720 -128> max <integer_cst 0x7fe1771ac708 127>
            pointer_to_this <pointer_type 0x7fe1771b5b28>>
        public unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
    var <parm_decl 0x7fe1771c5580 arg>
    def_stmt GIMPLE_NOP
    version:3
    ptr-info 0x7fe1771ca8e8>
GIMPLE_NOP

 ================== trace ptable================== 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr--------
this other function -----------
 
 Start check Pointer Collect  

======================================================================
length_4 = strlen (arg_3(D));
In function â€˜concatâ€™:
./benchmarks/binutils/leak_7/binutils_leak_7.c:61:32: warning: use location
   61 |         unsigned long length = strlen (arg);
      |                                ^
this stmt is child function---strlen-----

 ================== trace ================== 
trace fucntion name:strlen 

 ================== trace ================== 
trace fucntion free:0 
end_6 = dst_1(D) + length_4;
./benchmarks/binutils/leak_7/binutils_leak_7.c:63:13: warning: use location
   63 |         end += length;
      |             ^
*end_6 = 0;
./benchmarks/binutils/leak_7/binutils_leak_7.c:65:14: warning: use location
   65 |         *end = '\000';
      |              ^
memcpy (dst_1(D), arg_3(D), length_4);
./benchmarks/binutils/leak_7/binutils_leak_7.c:62:9: warning: use location
   62 |         memcpy (end, arg, length);
      |         ^
this stmt is child function---memcpy-----

 ================== trace ================== 
trace fucntion name:memcpy 

 ================== trace ================== 
trace fucntion free:0 

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7fe1771d5678
    type <pointer_type 0x7fe1771b5b28
        type <integer_type 0x7fe1771b5a80 char readonly public QI
            size <integer_cst 0x7fe17768cca8 constant 8>
            unit-size <integer_cst 0x7fe17768ccc0 constant 1>
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7fe1776a13f0 precision:8 min <integer_cst 0x7fe1771ac720 -128> max <integer_cst 0x7fe1771ac708 127>
            pointer_to_this <pointer_type 0x7fe1771b5b28>>
        public unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
    var <parm_decl 0x7fe1771c5580 arg>
    def_stmt GIMPLE_NOP
    version:3
    ptr-info 0x7fe1771ca8e8>

 ================== Start Use after free Check ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:0 [0m
[40;31m  	free count:0 [0m

======================================================================

======================================================================
[40;31m    no free stmt possible memory leak [0m

======================================================================

dot graph START

======================================================================
 <ssa_name 0x7fe1771d5630
    type <pointer_type 0x7fe1771b5c78
        type <integer_type 0x7fe1771b59d8 char public QI
            size <integer_cst 0x7fe17768cca8 constant 8>
            unit-size <integer_cst 0x7fe17768ccc0 constant 1>
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7fe1776a13f0 precision:8 min <integer_cst 0x7fe1771ac720 -128> max <integer_cst 0x7fe1771ac708 127>
            pointer_to_this <pointer_type 0x7fe1771b5c78>>
        public unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality context <translation_unit_decl 0x7fe177697168 ./benchmarks/binutils/leak_7/binutils_leak_7.c>
        pointer_to_this <pointer_type 0x7fe1771bfbd0>>
    var <parm_decl 0x7fe1771c5480 dst>
    def_stmt GIMPLE_NOP
    version:1
    ptr-info 0x7fe1771ca8d0>
GIMPLE_NOP

 ================== trace ptable================== 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr--------
this other function -----------
 
 Start check Pointer Collect  

======================================================================
return dst_1(D);
./benchmarks/binutils/leak_7/binutils_leak_7.c:67:16: warning: use location
   67 |         return dst;
      |                ^
end_6 = dst_1(D) + length_4;
./benchmarks/binutils/leak_7/binutils_leak_7.c:63:13: warning: use location
   63 |         end += length;
      |             ^
*end_6 = 0;
./benchmarks/binutils/leak_7/binutils_leak_7.c:65:14: warning: use location
   65 |         *end = '\000';
      |              ^
# .MEM_8 = VDEF <.MEM_7(D)>
memcpy (dst_1(D), arg_3(D), length_4);
memcpy (dst_1(D), arg_3(D), length_4);
./benchmarks/binutils/leak_7/binutils_leak_7.c:62:9: warning: use location
   62 |         memcpy (end, arg, length);
      |         ^
this stmt is child function---memcpy-----

 ================== trace ================== 
trace fucntion name:memcpy 

 ================== trace ================== 
trace fucntion free:0 
# .MEM_8 = VDEF <.MEM_7(D)>
memcpy (dst_1(D), arg_3(D), length_4);
memcpy (dst_1(D), arg_3(D), length_4);
./benchmarks/binutils/leak_7/binutils_leak_7.c:62:9: warning: use location
this stmt is child function---memcpy-----

 ================== trace ================== 
trace fucntion name:memcpy 

 ================== trace ================== 
trace fucntion free:0 

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7fe1771d5630
    type <pointer_type 0x7fe1771b5c78
        type <integer_type 0x7fe1771b59d8 char public QI
            size <integer_cst 0x7fe17768cca8 constant 8>
            unit-size <integer_cst 0x7fe17768ccc0 constant 1>
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7fe1776a13f0 precision:8 min <integer_cst 0x7fe1771ac720 -128> max <integer_cst 0x7fe1771ac708 127>
            pointer_to_this <pointer_type 0x7fe1771b5c78>>
        public unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality context <translation_unit_decl 0x7fe177697168 ./benchmarks/binutils/leak_7/binutils_leak_7.c>
        pointer_to_this <pointer_type 0x7fe1771bfbd0>>
    var <parm_decl 0x7fe1771c5480 dst>
    def_stmt GIMPLE_NOP
    version:1
    ptr-info 0x7fe1771ca8d0>

 ================== Start Use after free Check ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:0 [0m
[40;31m  	free count:0 [0m

======================================================================

======================================================================
[40;31m    no free stmt possible memory leak [0m

======================================================================
[40;33m =======POP node_fun stack:vconcat_copy========= [0m
[40;42m =======pre add _ fucntion:malloc========= [0m
[40;33m =======POP node_fun stack:malloc========= [0m
[40;42m =======pre_check_funciton:concat========= [0m
[40;42m =======start_check_funciton:concat========= [0m

dot graph START

======================================================================
 <ssa_name 0x7fe1771d5438
    type <pointer_type 0x7fe1771b5c78
        type <integer_type 0x7fe1771b59d8 char public QI
            size <integer_cst 0x7fe17768cca8 constant 8>
            unit-size <integer_cst 0x7fe17768ccc0 constant 1>
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7fe1776a13f0 precision:8 min <integer_cst 0x7fe1771ac720 -128> max <integer_cst 0x7fe1771ac708 127>
            pointer_to_this <pointer_type 0x7fe1771b5c78>>
        public unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality context <translation_unit_decl 0x7fe177697168 ./benchmarks/binutils/leak_7/binutils_leak_7.c>
        pointer_to_this <pointer_type 0x7fe1771bfbd0>>
    var <var_decl 0x7fe1771cff30 newstr>
    def_stmt newstr_3 = malloc (1);
    version:3
    ptr-info 0x7fe1771ca888>
# .MEM_7 = VDEF <.MEM_6(D)>
newstr_3 = malloc (1);

 ================== trace ptable================== 
trace fucntion name:malloc 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr---malloc-----
this Reserved word function ------malloc-----
 
 Start check Pointer Collect  

======================================================================
return newstr_3;
./benchmarks/binutils/leak_7/binutils_leak_7.c:81:10: warning: use location
   81 |   return newstr;
      |          ^
vconcat_copy (newstr_3, first_4(D), arg_5(D));
./benchmarks/binutils/leak_7/binutils_leak_7.c:79:3: warning: use location
   79 |   vconcat_copy (newstr, first, arg);
      |   ^
this stmt is child function---vconcat_copy-----

 ================== trace ================== 
trace fucntion name:vconcat_copy 
[40;44m =======trace_function_path vconcat_copy  function_call count: 2 level :0========  [0m
[40;36m ======= node_fun:vconcat_copy========= [0m
[40;36m ======= find relate stmt with newstr ========= [0m
[40;36m ======= relate stmt argument:newstr ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:memcpy========= [0m
[40;46m =======add node_fun stack:memcpy========= [0m
[40;42m =======pre add _ fucntion:strlen========= [0m
[40;46m =======add node_fun stack:strlen========= [0m

 ================== trace ================== 
trace fucntion free:0 
newstr_3 = malloc (1);
./benchmarks/binutils/leak_7/binutils_leak_7.c:76:12: warning: use location
   76 |   newstr = XNEWVEC (char, 1);
      |            ^
this stmt is child function---malloc-----

 ================== trace ================== 

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7fe1771d5438
    type <pointer_type 0x7fe1771b5c78
        type <integer_type 0x7fe1771b59d8 char public QI
            size <integer_cst 0x7fe17768cca8 constant 8>
            unit-size <integer_cst 0x7fe17768ccc0 constant 1>
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7fe1776a13f0 precision:8 min <integer_cst 0x7fe1771ac720 -128> max <integer_cst 0x7fe1771ac708 127>
            pointer_to_this <pointer_type 0x7fe1771b5c78>>
        public unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality context <translation_unit_decl 0x7fe177697168 ./benchmarks/binutils/leak_7/binutils_leak_7.c>
        pointer_to_this <pointer_type 0x7fe1771bfbd0>>
    var <var_decl 0x7fe1771cff30 newstr>
    def_stmt newstr_3 = malloc (1);
    version:3
    ptr-info 0x7fe1771ca888>

 ================== Start Use after free Check ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:0 [0m
[40;31m  	free count:0 [0m

======================================================================

======================================================================
[40;31m    no free stmt possible memory leak [0m

======================================================================

dot graph START

======================================================================

 ================== collect possiable invalid ================== 
 <integer_cst 0x7fe1771ca5e8 type <integer_type 0x7fe1776a17e0 long unsigned int> constant 1>
[40;33m =======POP node_fun stack:concat========= [0m
[40;44m =======node_fun:vconcat_copy========= [0m
[40;44m fucntion collect path  [0m
[40;44m =======print_function_path vconcat_copy  function_call count: 2 level :0========  [0m
[40;44m =======print_function_type 0  ========  [0m
[40;42m =======pre add _ fucntion:memcpy========= [0m
[40;33m =======POP node_fun stack:memcpy========= [0m
[40;42m =======pre add _ fucntion:strlen========= [0m
[40;33m =======POP node_fun stack:strlen========= [0m
[40;42m =======pre_check_funciton:vconcat_copy========= [0m
[40;42m =======start_check_funciton:vconcat_copy========= [0m

dot graph START

======================================================================
 <ssa_name 0x7fe1771d5678
    type <pointer_type 0x7fe1771b5b28
        type <integer_type 0x7fe1771b5a80 char readonly public QI
            size <integer_cst 0x7fe17768cca8 constant 8>
            unit-size <integer_cst 0x7fe17768ccc0 constant 1>
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7fe1776a13f0 precision:8 min <integer_cst 0x7fe1771ac720 -128> max <integer_cst 0x7fe1771ac708 127>
            pointer_to_this <pointer_type 0x7fe1771b5b28>>
        public unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
    var <parm_decl 0x7fe1771c5580 arg>
    def_stmt GIMPLE_NOP
    version:3
    ptr-info 0x7fe1771ca8e8>
GIMPLE_NOP

 ================== trace ptable================== 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr--------
this other function -----------
 
 Start check Pointer Collect  

======================================================================
length_4 = strlen (arg_3(D));
In function â€˜vconcat_copyâ€™:
./benchmarks/binutils/leak_7/binutils_leak_7.c:61:32: warning: use location
   61 |         unsigned long length = strlen (arg);
      |                                ^
this stmt is child function---strlen-----

 ================== trace ================== 
trace fucntion name:strlen 

 ================== trace ================== 
trace fucntion free:0 
end_6 = dst_1(D) + length_4;
./benchmarks/binutils/leak_7/binutils_leak_7.c:63:13: warning: use location
   63 |         end += length;
      |             ^
*end_6 = 0;
./benchmarks/binutils/leak_7/binutils_leak_7.c:65:14: warning: use location
   65 |         *end = '\000';
      |              ^
memcpy (dst_1(D), arg_3(D), length_4);
./benchmarks/binutils/leak_7/binutils_leak_7.c:62:9: warning: use location
   62 |         memcpy (end, arg, length);
      |         ^
this stmt is child function---memcpy-----

 ================== trace ================== 
trace fucntion name:memcpy 

 ================== trace ================== 
trace fucntion free:0 

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7fe1771d5678
    type <pointer_type 0x7fe1771b5b28
        type <integer_type 0x7fe1771b5a80 char readonly public QI
            size <integer_cst 0x7fe17768cca8 constant 8>
            unit-size <integer_cst 0x7fe17768ccc0 constant 1>
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7fe1776a13f0 precision:8 min <integer_cst 0x7fe1771ac720 -128> max <integer_cst 0x7fe1771ac708 127>
            pointer_to_this <pointer_type 0x7fe1771b5b28>>
        public unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
    var <parm_decl 0x7fe1771c5580 arg>
    def_stmt GIMPLE_NOP
    version:3
    ptr-info 0x7fe1771ca8e8>

 ================== Start Use after free Check ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:0 [0m
[40;31m  	free count:0 [0m

======================================================================

======================================================================
[40;31m    no free stmt possible memory leak [0m

======================================================================

dot graph START

======================================================================
 <ssa_name 0x7fe1771d5630
    type <pointer_type 0x7fe1771b5c78
        type <integer_type 0x7fe1771b59d8 char public QI
            size <integer_cst 0x7fe17768cca8 constant 8>
            unit-size <integer_cst 0x7fe17768ccc0 constant 1>
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7fe1776a13f0 precision:8 min <integer_cst 0x7fe1771ac720 -128> max <integer_cst 0x7fe1771ac708 127>
            pointer_to_this <pointer_type 0x7fe1771b5c78>>
        public unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality context <translation_unit_decl 0x7fe177697168 ./benchmarks/binutils/leak_7/binutils_leak_7.c>
        pointer_to_this <pointer_type 0x7fe1771bfbd0>>
    var <parm_decl 0x7fe1771c5480 dst>
    def_stmt GIMPLE_NOP
    version:1
    ptr-info 0x7fe1771ca8d0>
GIMPLE_NOP

 ================== trace ptable================== 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr--------
this other function -----------
 
 Start check Pointer Collect  

======================================================================
return dst_1(D);
./benchmarks/binutils/leak_7/binutils_leak_7.c:67:16: warning: use location
   67 |         return dst;
      |                ^
end_6 = dst_1(D) + length_4;
./benchmarks/binutils/leak_7/binutils_leak_7.c:63:13: warning: use location
   63 |         end += length;
      |             ^
*end_6 = 0;
./benchmarks/binutils/leak_7/binutils_leak_7.c:65:14: warning: use location
   65 |         *end = '\000';
      |              ^
# .MEM_8 = VDEF <.MEM_7(D)>
memcpy (dst_1(D), arg_3(D), length_4);
memcpy (dst_1(D), arg_3(D), length_4);
./benchmarks/binutils/leak_7/binutils_leak_7.c:62:9: warning: use location
   62 |         memcpy (end, arg, length);
      |         ^
this stmt is child function---memcpy-----

 ================== trace ================== 
trace fucntion name:memcpy 

 ================== trace ================== 
trace fucntion free:0 
# .MEM_8 = VDEF <.MEM_7(D)>
memcpy (dst_1(D), arg_3(D), length_4);
memcpy (dst_1(D), arg_3(D), length_4);
./benchmarks/binutils/leak_7/binutils_leak_7.c:62:9: warning: use location
this stmt is child function---memcpy-----

 ================== trace ================== 
trace fucntion name:memcpy 

 ================== trace ================== 
trace fucntion free:0 

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7fe1771d5630
    type <pointer_type 0x7fe1771b5c78
        type <integer_type 0x7fe1771b59d8 char public QI
            size <integer_cst 0x7fe17768cca8 constant 8>
            unit-size <integer_cst 0x7fe17768ccc0 constant 1>
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7fe1776a13f0 precision:8 min <integer_cst 0x7fe1771ac720 -128> max <integer_cst 0x7fe1771ac708 127>
            pointer_to_this <pointer_type 0x7fe1771b5c78>>
        public unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality context <translation_unit_decl 0x7fe177697168 ./benchmarks/binutils/leak_7/binutils_leak_7.c>
        pointer_to_this <pointer_type 0x7fe1771bfbd0>>
    var <parm_decl 0x7fe1771c5480 dst>
    def_stmt GIMPLE_NOP
    version:1
    ptr-info 0x7fe1771ca8d0>

 ================== Start Use after free Check ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:0 [0m
[40;31m  	free count:0 [0m

======================================================================

======================================================================
[40;31m    no free stmt possible memory leak [0m

======================================================================
[40;33m =======POP node_fun stack:vconcat_copy========= [0m
[40;44m =======node_fun:ldirname========= [0m
[40;44m fucntion collect path  [0m
[40;44m =======print_function_path ldirname  function_call count: 3 level :0========  [0m
[40;44m =======print_function_type 2  ========  [0m
[40;42m =======pre add _ fucntion:memcpy========= [0m
[40;33m =======POP node_fun stack:memcpy========= [0m
[40;42m =======pre add _ fucntion:malloc========= [0m
[40;33m =======POP node_fun stack:malloc========= [0m
[40;42m =======pre add _ fucntion:lbasename========= [0m
[40;44m =======print_function_type 0  ========  [0m
[40;44m =======print_function_path lbasename  function_call count: 1 level :1========  [0m
[40;44m =======print_function_type 0  ========  [0m
[40;42m =======pre add _ fucntion:unix_lbasename========= [0m
[40;44m =======print_function_type 0  ========  [0m
[40;44m =======print_function_path unix_lbasename  function_call count: 0 level :2========  [0m
[40;44m =======print_function_type 0  ========  [0m
[40;42m =======pre_check_funciton:unix_lbasename========= [0m
[40;42m =======start_check_funciton:unix_lbasename========= [0m
[40;33m =======POP node_fun stack:unix_lbasename========= [0m
[40;42m =======pre_check_funciton:lbasename========= [0m
[40;42m =======start_check_funciton:lbasename========= [0m

dot graph START

======================================================================
 <ssa_name 0x7fe1771de048
    type <pointer_type 0x7fe1771b5b28
        type <integer_type 0x7fe1771b5a80 char readonly public QI
            size <integer_cst 0x7fe17768cca8 constant 8>
            unit-size <integer_cst 0x7fe17768ccc0 constant 1>
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7fe1776a13f0 precision:8 min <integer_cst 0x7fe1771ac720 -128> max <integer_cst 0x7fe1771ac708 127>
            pointer_to_this <pointer_type 0x7fe1771b5b28>>
        public unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
    var <parm_decl 0x7fe1771c5680 name>
    def_stmt GIMPLE_NOP
    version:2
    ptr-info 0x7fe1771caa08>
GIMPLE_NOP

 ================== trace ptable================== 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr--------
this other function -----------

======================================================================
[40;35m  	Looserules free count:0 [0m
[40;31m  	free count:0 [0m

======================================================================

======================================================================
[40;31m 	Can't find this fucntion in Pointer table [0m
[40;31m 	Possiable no other stmt relate with this stmt [0m

======================================================================
[40;33m =======POP node_fun stack:lbasename========= [0m
[40;42m =======pre_check_funciton:ldirname========= [0m
[40;42m =======start_check_funciton:ldirname========= [0m

dot graph START

======================================================================
 <ssa_name 0x7fe1771d5e10
    type <pointer_type 0x7fe1771b5c78
        type <integer_type 0x7fe1771b59d8 char public QI
            size <integer_cst 0x7fe17768cca8 constant 8>
            unit-size <integer_cst 0x7fe17768ccc0 constant 1>
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7fe1776a13f0 precision:8 min <integer_cst 0x7fe1771ac720 -128> max <integer_cst 0x7fe1771ac708 127>
            pointer_to_this <pointer_type 0x7fe1771b5c78>>
        public unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality context <translation_unit_decl 0x7fe177697168 ./benchmarks/binutils/leak_7/binutils_leak_7.c>
        pointer_to_this <pointer_type 0x7fe1771bfbd0>>
    var <var_decl 0x7fe1771d7360 dirname>
    def_stmt dirname_26 = malloc (_4);
    version:26
    ptr-info 0x7fe1771ca9d8>
# .MEM_32 = VDEF <.MEM_31(D)>
dirname_26 = malloc (_4);

 ================== trace ptable================== 
trace fucntion name:malloc 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr---malloc-----
this Reserved word function ------malloc-----
 
 Start check Pointer Collect  

======================================================================
_18 = PHI <0B(6), dirname_26(11)>
In function â€˜ldirnameâ€™:
lto1: warning: use location
this stmt have mutiple branch --------
_15 = dirname_26 + _14;
./benchmarks/binutils/leak_7/binutils_leak_7.c:52:10: warning: use location
   52 |   dirname[base - filename] = '\0';
      |          ^
*_15 = 0;
./benchmarks/binutils/leak_7/binutils_leak_7.c:52:28: warning: use location
   52 |   dirname[base - filename] = '\0';
      |                            ^
_12 = dirname_26 + _11;
./benchmarks/binutils/leak_7/binutils_leak_7.c:50:12: warning: use location
   50 |     dirname[base++ - filename] = '.';
      |            ^
*_12 = 46;
./benchmarks/binutils/leak_7/binutils_leak_7.c:50:32: warning: use location
   50 |     dirname[base++ - filename] = '.';
      |                                ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_33 = VDEF <.MEM_32>
memcpy (dirname_26, filename_22(D), _6);
bb index := 7
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 7 ,possiable got to succ := 12

======================================================================
memcpy (dirname_26, filename_22(D), _6);
./benchmarks/binutils/leak_7/binutils_leak_7.c:44:3: warning: use location
   44 |   memcpy (dirname, filename, base - filename);
      |   ^
this stmt is child function---memcpy-----

 ================== trace ================== 
trace fucntion name:memcpy 

 ================== trace ================== 
trace fucntion free:0 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_32 = VDEF <.MEM_31(D)>
dirname_26 = malloc (_4);
bb index := 7
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 7 ,possiable got to succ := 12

======================================================================
dirname_26 = malloc (_4);
./benchmarks/binutils/leak_7/binutils_leak_7.c:43:22: warning: use location
   43 |   dirname = (char *) xmalloc (base - filename + 2);         /* allocation site */
      |                      ^
this stmt is child function---malloc-----

 ================== trace ================== 

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7fe1771d5e10
    type <pointer_type 0x7fe1771b5c78
        type <integer_type 0x7fe1771b59d8 char public QI
            size <integer_cst 0x7fe17768cca8 constant 8>
            unit-size <integer_cst 0x7fe17768ccc0 constant 1>
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7fe1776a13f0 precision:8 min <integer_cst 0x7fe1771ac720 -128> max <integer_cst 0x7fe1771ac708 127>
            pointer_to_this <pointer_type 0x7fe1771b5c78>>
        public unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality context <translation_unit_decl 0x7fe177697168 ./benchmarks/binutils/leak_7/binutils_leak_7.c>
        pointer_to_this <pointer_type 0x7fe1771bfbd0>>
    var <var_decl 0x7fe1771d7360 dirname>
    def_stmt dirname_26 = malloc (_4);
    version:26
    ptr-info 0x7fe1771ca9d8>

 ================== Start Use after free Check ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:0 [0m
[40;31m  	free count:0 [0m

======================================================================

======================================================================
[40;31m    no free stmt possible memory leak [0m

======================================================================

dot graph START

======================================================================
 <ssa_name 0x7fe1771d5d38
    type <pointer_type 0x7fe1771b5b28
        type <integer_type 0x7fe1771b5a80 char readonly public QI
            size <integer_cst 0x7fe17768cca8 constant 8>
            unit-size <integer_cst 0x7fe17768ccc0 constant 1>
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7fe1776a13f0 precision:8 min <integer_cst 0x7fe1771ac720 -128> max <integer_cst 0x7fe1771ac708 127>
            pointer_to_this <pointer_type 0x7fe1771b5b28>>
        public unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
    var <parm_decl 0x7fe1771c5600 filename>
    def_stmt GIMPLE_NOP
    version:22
    ptr-info 0x7fe1771ca990>
GIMPLE_NOP

 ================== trace ptable================== 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr--------
this other function -----------
 
 Start check Pointer Collect  

======================================================================
base_23 = lbasename (filename_22(D));
./benchmarks/binutils/leak_7/binutils_leak_7.c:34:22: warning: use location
   34 |   const char *base = lbasename (filename);
      |                      ^
this stmt is child function---lbasename-----

 ================== trace ================== 
trace fucntion name:lbasename 
[40;44m =======trace_function_path lbasename  function_call count: 1 level :0========  [0m
[40;36m ======= node_fun:lbasename========= [0m
[40;36m ======= find relate stmt with filename ========= [0m
[40;36m ======= relate stmt argument:filename ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:unix_lbasename========= [0m
[40;46m =======add node_fun stack:unix_lbasename========= [0m
[40;44m =======trace_function_path unix_lbasename  function_call count: 0 level :1========  [0m
[40;36m ======= node_fun:unix_lbasename========= [0m
[40;36m ======= find relate stmt with filename ========= [0m
[40;36m ======= relate stmt argument:filename ========= [0m
fucntion collect path finsh

 ================== trace ================== 
trace fucntion free:0 

======================================================================
[40;31m    branch possiable have return or exit  [0m
base_16 = PHI <base_23(2), base_24(3)>
bb index := 4
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 4 ,possiable got to succ := 12

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
base_16 = PHI <base_23(2), base_24(3)>
bb index := 4
# VUSE <.MEM_8(D)>
return base_3;
./benchmarks/binutils/leak_7/binutils_leak_7.c:22:10: warning: use location
   22 |   return base;
      |          ^
beacuse in succ := 5 have return or exit
# VUSE <.MEM_8(D)>
return base_3;
./benchmarks/binutils/leak_7/binutils_leak_7.c:22:10: warning: use location
gimple stmt in succ := 4 ,possiable got to succ := 5

======================================================================

======================================================================
[40;31m    collect Stmt in loop [0m

======================================================================
base_16 = PHI <base_23(2), base_24(3)>
lto1: warning: use location
this stmt have mutiple branch --------
base_17 = PHI <base_16(7), base_16(8), base_16(9), base_28(10)>
lto1: warning: use location
this stmt have mutiple branch --------
_13 = base_17 - filename_22(D);
./benchmarks/binutils/leak_7/binutils_leak_7.c:52:16: warning: use location
   52 |   dirname[base - filename] = '\0';
      |                ^
_14 = (sizetype) _13;
./benchmarks/binutils/leak_7/binutils_leak_7.c:52:16: warning: use location
_15 = dirname_26 + _14;
./benchmarks/binutils/leak_7/binutils_leak_7.c:52:10: warning: use location
   52 |   dirname[base - filename] = '\0';
      |          ^
*_15 = 0;
./benchmarks/binutils/leak_7/binutils_leak_7.c:52:28: warning: use location
   52 |   dirname[base - filename] = '\0';
      |                            ^
_10 = base_16 - filename_22(D);
./benchmarks/binutils/leak_7/binutils_leak_7.c:50:20: warning: use location
   50 |     dirname[base++ - filename] = '.';
      |                    ^
_11 = (sizetype) _10;
./benchmarks/binutils/leak_7/binutils_leak_7.c:50:20: warning: use location
_12 = dirname_26 + _11;
./benchmarks/binutils/leak_7/binutils_leak_7.c:50:12: warning: use location
   50 |     dirname[base++ - filename] = '.';
      |            ^
*_12 = 46;
./benchmarks/binutils/leak_7/binutils_leak_7.c:50:32: warning: use location
   50 |     dirname[base++ - filename] = '.';
      |                                ^
base_28 = base_16 + 1;
./benchmarks/binutils/leak_7/binutils_leak_7.c:50:17: warning: use location
   50 |     dirname[base++ - filename] = '.';
      |                 ^
_8 = *base_16;
./benchmarks/binutils/leak_7/binutils_leak_7.c:48:31: warning: use location
   48 |   if (base - filename == 2 && IS_ABSOLUTE_PATH (base)
      |                               ^
if (_8 == 47)
./benchmarks/binutils/leak_7/binutils_leak_7.c:48:28: warning: use location
   48 |   if (base - filename == 2 && IS_ABSOLUTE_PATH (base)
      |                            ^
if (_8 == 47)

 ================== find cond branch ================= 
./benchmarks/binutils/leak_7/binutils_leak_7.c:48:28: warning: use location
Cond in fucntion ldirname basic block 8
 ================== possible direct basic block ================= 
from ldirname basic block 9
 ================== possible direct basic block ================= 
from ldirname basic block 11
 ================== warring ================== 
[40;35m    need check this branch possible have return or exit stmt [0m

 ================== warring ================== 

 ================== find cond branch ================= 

======================================================================
[40;31m    branch possiable have return or exit  [0m
_7 = base_16 - filename_22(D);
bb index := 7
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 7 ,possiable got to succ := 12

======================================================================
_7 = base_16 - filename_22(D);
./benchmarks/binutils/leak_7/binutils_leak_7.c:48:12: warning: use location
   48 |   if (base - filename == 2 && IS_ABSOLUTE_PATH (base)
      |            ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
if (_7 == 2)
bb index := 7
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 7 ,possiable got to succ := 12

======================================================================
if (_7 == 2)
./benchmarks/binutils/leak_7/binutils_leak_7.c:48:6: warning: use location
   48 |   if (base - filename == 2 && IS_ABSOLUTE_PATH (base)
      |      ^
if (_7 == 2)

 ================== find cond branch ================= 
./benchmarks/binutils/leak_7/binutils_leak_7.c:48:6: warning: use location
Cond in fucntion ldirname basic block 7
 ================== possible direct basic block ================= 
from ldirname basic block 8
 ================== possible direct basic block ================= 
from ldirname basic block 11
 ================== warring ================== 
[40;35m    need check this branch possible have return or exit stmt [0m

 ================== warring ================== 

 ================== find cond branch ================= 

======================================================================
[40;31m    branch possiable have return or exit  [0m
_5 = base_16 - filename_22(D);
bb index := 7
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 7 ,possiable got to succ := 12

======================================================================
_5 = base_16 - filename_22(D);
./benchmarks/binutils/leak_7/binutils_leak_7.c:44:35: warning: use location
   44 |   memcpy (dirname, filename, base - filename);
      |                                   ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
_6 = (long unsigned int) _5;
bb index := 7
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 7 ,possiable got to succ := 12

======================================================================
_6 = (long unsigned int) _5;
./benchmarks/binutils/leak_7/binutils_leak_7.c:44:3: warning: use location
   44 |   memcpy (dirname, filename, base - filename);
      |   ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_33 = VDEF <.MEM_32>
memcpy (dirname_26, filename_22(D), _6);
bb index := 7
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 7 ,possiable got to succ := 12

======================================================================
memcpy (dirname_26, filename_22(D), _6);
./benchmarks/binutils/leak_7/binutils_leak_7.c:44:3: warning: use location
this stmt is child function---memcpy-----

 ================== trace ================== 
trace fucntion name:memcpy 

 ================== trace ================== 
trace fucntion free:0 

======================================================================
[40;31m    branch possiable have return or exit  [0m
_2 = base_16 - filename_22(D);
bb index := 7
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 7 ,possiable got to succ := 12

======================================================================
_2 = base_16 - filename_22(D);
./benchmarks/binutils/leak_7/binutils_leak_7.c:43:22: warning: use location
   43 |   dirname = (char *) xmalloc (base - filename + 2);         /* allocation site */
      |                      ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
_3 = _2 + 2;
bb index := 7
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 7 ,possiable got to succ := 12

======================================================================
_3 = _2 + 2;
./benchmarks/binutils/leak_7/binutils_leak_7.c:43:22: warning: use location

======================================================================
[40;31m    branch possiable have return or exit  [0m
_4 = (long unsigned int) _3;
bb index := 7
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 7 ,possiable got to succ := 12

======================================================================
_4 = (long unsigned int) _3;
./benchmarks/binutils/leak_7/binutils_leak_7.c:43:22: warning: use location

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_32 = VDEF <.MEM_31(D)>
dirname_26 = malloc (_4);
bb index := 7
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 7 ,possiable got to succ := 12

======================================================================
dirname_26 = malloc (_4);
./benchmarks/binutils/leak_7/binutils_leak_7.c:43:22: warning: use location
this stmt is child function---malloc-----

 ================== trace ================== 
_18 = PHI <0B(6), dirname_26(11)>
lto1: warning: use location
this stmt have mutiple branch --------

======================================================================
[40;31m    branch possiable have return or exit  [0m
if (base_16 == filename_22(D))
bb index := 6
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 6 ,possiable got to succ := 12

======================================================================
if (base_16 == filename_22(D))
./benchmarks/binutils/leak_7/binutils_leak_7.c:40:6: warning: use location
   40 |   if (base == filename)
      |      ^
if (base_16 == filename_22(D))

 ================== find cond branch ================= 
./benchmarks/binutils/leak_7/binutils_leak_7.c:40:6: warning: use location
Cond in fucntion ldirname basic block 6
 ================== possible direct basic block ================= 
from ldirname basic block 12
 ================== possible direct basic block ================= 
from ldirname basic block 7
 ================== warring ================== 
[40;35m    need check this branch possible have return or exit stmt [0m

 ================== warring ================== 

 ================== find cond branch ================= 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# VUSE <.MEM_31(D)>
_1 = MEM[(const char *)base_16 + -1B];
bb index := 5
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 5 ,possiable got to succ := 12

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# VUSE <.MEM_31(D)>
_1 = MEM[(const char *)base_16 + -1B];
bb index := 5
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 5 ,possiable got to succ := 12

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# VUSE <.MEM_31(D)>
_1 = MEM[(const char *)base_16 + -1B];
bb index := 5
# VUSE <.MEM_8(D)>
return base_3;
./benchmarks/binutils/leak_7/binutils_leak_7.c:22:10: warning: use location
   22 |   return base;
      |          ^
beacuse in succ := 5 have return or exit
# VUSE <.MEM_8(D)>
return base_3;
./benchmarks/binutils/leak_7/binutils_leak_7.c:22:10: warning: use location
gimple stmt in succ := 5 ,possiable got to succ := 5

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# VUSE <.MEM_31(D)>
_1 = MEM[(const char *)base_16 + -1B];
bb index := 5
# VUSE <.MEM_8(D)>
return base_3;
./benchmarks/binutils/leak_7/binutils_leak_7.c:22:10: warning: use location
beacuse in succ := 5 have return or exit
# VUSE <.MEM_8(D)>
return base_3;
./benchmarks/binutils/leak_7/binutils_leak_7.c:22:10: warning: use location
gimple stmt in succ := 5 ,possiable got to succ := 5

======================================================================

======================================================================
[40;31m    collect Stmt in loop [0m

======================================================================
_1 = MEM[(const char *)base_16 + -1B];
./benchmarks/binutils/leak_7/binutils_leak_7.c:37:29: warning: use location
   37 |   while (base > filename && IS_DIR_SEPARATOR (base[-1]))
      |                             ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
base_24 = base_16 + 18446744073709551615;
bb index := 3
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 3 ,possiable got to succ := 12

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
base_24 = base_16 + 18446744073709551615;
bb index := 3
# VUSE <.MEM_8(D)>
return base_3;
./benchmarks/binutils/leak_7/binutils_leak_7.c:22:10: warning: use location
   22 |   return base;
      |          ^
beacuse in succ := 5 have return or exit
# VUSE <.MEM_8(D)>
return base_3;
./benchmarks/binutils/leak_7/binutils_leak_7.c:22:10: warning: use location
gimple stmt in succ := 3 ,possiable got to succ := 5

======================================================================

======================================================================
[40;31m    collect Stmt in loop [0m

======================================================================
base_24 = base_16 + 18446744073709551615;
./benchmarks/binutils/leak_7/binutils_leak_7.c:38:5: warning: use location
   38 |     --base;
      |     ^
_9 = *filename_22(D);
./benchmarks/binutils/leak_7/binutils_leak_7.c:49:11: warning: use location
   49 |       && !IS_DIR_SEPARATOR (filename[0]))
      |           ^

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7fe1771d5d38
    type <pointer_type 0x7fe1771b5b28
        type <integer_type 0x7fe1771b5a80 char readonly public QI
            size <integer_cst 0x7fe17768cca8 constant 8>
            unit-size <integer_cst 0x7fe17768ccc0 constant 1>
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7fe1776a13f0 precision:8 min <integer_cst 0x7fe1771ac720 -128> max <integer_cst 0x7fe1771ac708 127>
            pointer_to_this <pointer_type 0x7fe1771b5b28>>
        public unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
    var <parm_decl 0x7fe1771c5600 filename>
    def_stmt GIMPLE_NOP
    version:22
    ptr-info 0x7fe1771ca990>

 ================== Start Use after free Check ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:0 [0m
[40;31m  	free count:0 [0m

======================================================================

======================================================================
[40;31m 	this stmt need double check [0m

======================================================================

dot graph START

======================================================================
 <ssa_name 0x7fe1771d5900
    type <integer_type 0x7fe1776a17e0 long unsigned int public unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7fe1776a1738 precision:64 min <integer_cst 0x7fe17768ce88 0> max <integer_cst 0x7fe17768d500 18446744073709551615>
        pointer_to_this <pointer_type 0x7fe1776ad7e0>>
   
    def_stmt _4 = (long unsigned int) _3;
    version:4>
_4 = (long unsigned int) _3;

 ================== trace ptable================== 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr--------
this other function -----------
 
 Start check Pointer Collect  

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_32 = VDEF <.MEM_31(D)>
dirname_26 = malloc (_4);
bb index := 7
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 7 ,possiable got to succ := 12

======================================================================
dirname_26 = malloc (_4);
./benchmarks/binutils/leak_7/binutils_leak_7.c:43:22: warning: use location
   43 |   dirname = (char *) xmalloc (base - filename + 2);         /* allocation site */
      |                      ^
this stmt is child function---malloc-----

 ================== trace ================== 
_18 = PHI <0B(6), dirname_26(11)>
lto1: warning: use location
this stmt have mutiple branch --------
_15 = dirname_26 + _14;
./benchmarks/binutils/leak_7/binutils_leak_7.c:52:10: warning: use location
   52 |   dirname[base - filename] = '\0';
      |          ^
*_15 = 0;
./benchmarks/binutils/leak_7/binutils_leak_7.c:52:28: warning: use location
   52 |   dirname[base - filename] = '\0';
      |                            ^
_12 = dirname_26 + _11;
./benchmarks/binutils/leak_7/binutils_leak_7.c:50:12: warning: use location
   50 |     dirname[base++ - filename] = '.';
      |            ^
*_12 = 46;
./benchmarks/binutils/leak_7/binutils_leak_7.c:50:32: warning: use location
   50 |     dirname[base++ - filename] = '.';
      |                                ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_33 = VDEF <.MEM_32>
memcpy (dirname_26, filename_22(D), _6);
bb index := 7
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
beacuse in succ := 12 have return or exit
# VUSE <.MEM_30>
return _18;
lto1: warning: use location
gimple stmt in succ := 7 ,possiable got to succ := 12

======================================================================
memcpy (dirname_26, filename_22(D), _6);
./benchmarks/binutils/leak_7/binutils_leak_7.c:44:3: warning: use location
   44 |   memcpy (dirname, filename, base - filename);
      |   ^
this stmt is child function---memcpy-----

 ================== trace ================== 
trace fucntion name:memcpy 

 ================== trace ================== 
trace fucntion free:0 

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7fe1771d5900
    type <integer_type 0x7fe1776a17e0 long unsigned int public unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7fe1776a1738 precision:64 min <integer_cst 0x7fe17768ce88 0> max <integer_cst 0x7fe17768d500 18446744073709551615>
        pointer_to_this <pointer_type 0x7fe1776ad7e0>>
   
    def_stmt _4 = (long unsigned int) _3;
    version:4>

 ================== Start Use after free Check ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:0 [0m
[40;31m  	free count:0 [0m

======================================================================

======================================================================
[40;31m    no free stmt possible memory leak [0m

======================================================================
[40;33m =======POP node_fun stack:ldirname========= [0m
[40;44m =======node_fun:lbasename========= [0m
[40;44m fucntion collect path  [0m
[40;44m =======print_function_path lbasename  function_call count: 1 level :0========  [0m
[40;44m =======print_function_type 0  ========  [0m
[40;42m =======pre add _ fucntion:unix_lbasename========= [0m
[40;44m =======print_function_type 0  ========  [0m
[40;44m =======print_function_path unix_lbasename  function_call count: 0 level :1========  [0m
[40;44m =======print_function_type 0  ========  [0m
[40;42m =======pre_check_funciton:unix_lbasename========= [0m
[40;42m =======start_check_funciton:unix_lbasename========= [0m
[40;33m =======POP node_fun stack:unix_lbasename========= [0m
[40;42m =======pre_check_funciton:lbasename========= [0m
[40;42m =======start_check_funciton:lbasename========= [0m

dot graph START

======================================================================
 <ssa_name 0x7fe1771de048
    type <pointer_type 0x7fe1771b5b28
        type <integer_type 0x7fe1771b5a80 char readonly public QI
            size <integer_cst 0x7fe17768cca8 constant 8>
            unit-size <integer_cst 0x7fe17768ccc0 constant 1>
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7fe1776a13f0 precision:8 min <integer_cst 0x7fe1771ac720 -128> max <integer_cst 0x7fe1771ac708 127>
            pointer_to_this <pointer_type 0x7fe1771b5b28>>
        public unsigned DI
        size <integer_cst 0x7fe17768cbb8 constant 64>
        unit-size <integer_cst 0x7fe17768cbd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
    var <parm_decl 0x7fe1771c5680 name>
    def_stmt GIMPLE_NOP
    version:2
    ptr-info 0x7fe1771caa08>
GIMPLE_NOP

 ================== trace ptable================== 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr--------
this other function -----------

======================================================================
[40;35m  	Looserules free count:0 [0m
[40;31m  	free count:0 [0m

======================================================================

======================================================================
[40;31m 	Can't find this fucntion in Pointer table [0m
[40;31m 	Possiable no other stmt relate with this stmt [0m

======================================================================
[40;33m =======POP node_fun stack:lbasename========= [0m
[40;44m =======node_fun:unix_lbasename========= [0m
[40;44m fucntion collect path  [0m
[40;44m =======print_function_path unix_lbasename  function_call count: 0 level :0========  [0m
[40;44m =======print_function_type 0  ========  [0m
[40;42m =======pre_check_funciton:unix_lbasename========= [0m
[40;42m =======start_check_funciton:unix_lbasename========= [0m
[40;33m =======POP node_fun stack:unix_lbasename========= [0m
fucntion collect path finsh

=============== The third stage : detection  End=================

===============Print ALL GIMPLE IR=================
=======Mapping node_fun:main=========
=======is loop:0=========

 bb index 2 
<bb 2> [local count: 1073741824]:
do_start_initialization ();
concat ("dummy", "");
printf ("%d\n", 1835890020);
return 0;

=======Mapping node_fun:do_start_initialization=========
=======is loop:0=========

 bb index 2 
<bb 2> [local count: 1073741824]:
_1 = python_libdir;
_2 = ldirname (_1);
progname_16 = concat (_2, "bin");
_3 = setlocale ("LC_ALL", 0B);
_4 = (long int) _3;
_5 = (const char *) _4;
oldloc_19 = strdup (_5);
setlocale ("LC_ALL", "");
progsize_21 = strlen (progname_16);
_6 = progsize_21 + 1;
_7 = _6 * 4;
progname_copy_23 = PyMem_Malloc (_7);
if (progname_copy_23 == 0B)
  goto <bb 3>; [0.04%]
else
  goto <bb 4>; [99.96%]

=======is loop:0=========

 bb index 3 
<bb 3> [local count: 429496]:
free (oldloc_19);
_8 = stderr;
__builtin_fwrite ("out of memory\n", 1, 14, _8);
_37 = false;
goto <bb 7>; [100.00%]

=======is loop:0=========

 bb index 4 
<bb 4> [local count: 1073312329]:
_9 = progsize_21 + 1;
count_25 = mbstowcs (progname_copy_23, progname_16, _9);
if (count_25 == 18446744073709551615)
  goto <bb 5>; [20.97%]
else
  goto <bb 6>; [79.03%]

=======is loop:0=========

 bb index 5 
<bb 5> [local count: 225073599]:
free (oldloc_19);
free (progname_copy_23);
_10 = stderr;
__builtin_fwrite ("Could not convert python path to string\n", 1, 40, _10);
_34 = false;
goto <bb 7>; [100.00%]

=======is loop:0=========

 bb index 6 
<bb 6> [local count: 848238730]:
setlocale ("LC_ALL", oldloc_19);
free (oldloc_19);
Py_SetProgramName (progname_copy_23);
free (progname_copy_23);
_30 = true;

=======is loop:0=========

 bb index 7 
<bb 7> [local count: 1073741824]:
# _11 = PHI <_37(3), _34(5), _30(6)>
return _11;

=======Mapping node_fun:Py_SetProgramName=========
=======is loop:0=========

 bb index 2 
<bb 2> [local count: 1073741824]:
_1 = MEM[(int *)progname_3(D)];
printf ("%d\n", _1);
return;

=======Mapping node_fun:PyMem_Malloc=========
=======is loop:0=========

 bb index 2 
<bb 2> [local count: 1073741824]:
ret_4 = malloc (size_2(D));
return ret_4;

=======Mapping node_fun:concat=========
=======is loop:0=========

 bb index 2 
<bb 2> [local count: 1073741824]:
newstr_3 = malloc (1);
vconcat_copy (newstr_3, first_4(D), arg_5(D));
return newstr_3;

=======Mapping node_fun:vconcat_copy=========
=======is loop:0=========

 bb index 2 
<bb 2> [local count: 1073741824]:
length_4 = strlen (arg_3(D));
memcpy (dst_1(D), arg_3(D), length_4);
end_6 = dst_1(D) + length_4;
*end_6 = 0;
return dst_1(D);

=======Mapping node_fun:ldirname=========
=======is loop:0=========

 bb index 2 
<bb 2> [local count: 114863530]:
base_23 = lbasename (filename_22(D));
goto <bb 4>; [100.00%]

=======is loop:1=========

 bb index 3 
<bb 3> [local count: 958878296]:
base_24 = base_16 + 18446744073709551615;

=======is loop:1=========

 bb index 4 
<bb 4> [local count: 1073741824]:
# base_16 = PHI <base_23(2), base_24(3)>
if (base_16 > filename_22(D))
  goto <bb 5>; [94.50%]
else
  goto <bb 6>; [5.50%]

=======is loop:1=========

 bb index 5 
<bb 5> [local count: 1014686026]:
_1 = MEM[(const char *)base_16 + -1B];
if (_1 == 47)
  goto <bb 3>; [94.50%]
else
  goto <bb 6>; [5.50%]

=======is loop:0=========

 bb index 6 
<bb 6> [local count: 114863531]:
if (base_16 == filename_22(D))
  goto <bb 12>; [15.47%]
else
  goto <bb 7>; [84.53%]

=======is loop:0=========

 bb index 7 
<bb 7> [local count: 97094143]:
_2 = base_16 - filename_22(D);
_3 = _2 + 2;
_4 = (long unsigned int) _3;
dirname_26 = malloc (_4);
_5 = base_16 - filename_22(D);
_6 = (long unsigned int) _5;
memcpy (dirname_26, filename_22(D), _6);
_7 = base_16 - filename_22(D);
if (_7 == 2)
  goto <bb 8>; [34.00%]
else
  goto <bb 11>; [66.00%]

=======is loop:0=========

 bb index 8 
<bb 8> [local count: 33012009]:
_8 = *base_16;
if (_8 == 47)
  goto <bb 9>; [34.00%]
else
  goto <bb 11>; [66.00%]

=======is loop:0=========

 bb index 9 
<bb 9> [local count: 11224083]:
_9 = *filename_22(D);
if (_9 != 47)
  goto <bb 10>; [66.00%]
else
  goto <bb 11>; [34.00%]

=======is loop:0=========

 bb index 10 
<bb 10> [local count: 7407895]:
base_28 = base_16 + 1;
_10 = base_16 - filename_22(D);
_11 = (sizetype) _10;
_12 = dirname_26 + _11;
*_12 = 46;

=======is loop:0=========

 bb index 11 
<bb 11> [local count: 97094143]:
# base_17 = PHI <base_16(7), base_16(8), base_16(9), base_28(10)>
_13 = base_17 - filename_22(D);
_14 = (sizetype) _13;
_15 = dirname_26 + _14;
*_15 = 0;

=======is loop:0=========

 bb index 12 
<bb 12> [local count: 114863532]:
# _18 = PHI <0B(6), dirname_26(11)>
return _18;

=======Mapping node_fun:lbasename=========
=======is loop:0=========

 bb index 2 
<bb 2> [local count: 1073741824]:
_3 = unix_lbasename (name_2(D));
return _3;

=======Mapping node_fun:unix_lbasename=========
=======is loop:0=========

 bb index 2 
<bb 2> [local count: 118111600]:
goto <bb 4>; [100.00%]

=======is loop:1=========

 bb index 3 
<bb 3> [local count: 955630225]:
base_6 = name_2 + 1;
name_7 = name_2 + 1;

=======is loop:1=========

 bb index 4 
<bb 4> [local count: 1073741824]:
# name_2 = PHI <name_4(D)(2), name_7(3)>
# base_3 = PHI <name_4(D)(2), base_6(3)>
_1 = *name_2;
if (_1 != 0)
  goto <bb 3>; [89.00%]
else
  goto <bb 5>; [11.00%]

=======is loop:0=========

 bb index 5 
<bb 5> [local count: 118111600]:
return base_3;


===============Print ALL GIMPLE IR=================
[40;32mSTART CHECKSTART CHECKSTART CHECKSTART CHECKSTART CHECK[0m
    =()=
 ,/'_||_
  (___  `.
 ./  `=='
                   
    ~~~~~~~~~~~  
 ~~~~~~
           ~~~~~~~
[40;34m    gimple malloc count : 4 [0m
[40;34m    gimple free   count : 5 [0m
[40;34m    find Entry point : 15 [0m
[40;34m    used_stmt array stack totalsize of : 0.003128 mb[0m
[40;34m    collect time: : 0.000198 s [0m
[40;34m    algorithm time: 0.164317 s [0m
[40;34m    gimple stmt count : : 84 [0m
[40;32mSTART CHECKSTART CHECKSTART CHECKSTART CHECKSTART CHECK[0m
Profile consistency report:

                                 |mismatch     |mismatch     |                     |
Pass name                        |IN    |IN    |OUT   |OUT   |overall              |
                                 |freq  |count |freq  |count |size      |time      |
cp                   ------------|      |      |      |      |          |          |
inline               ------------|      |      |      |      |          |          |
fixup_cfg            ------------|      |      |      |      |          |          |
adjust_alignment     ------------|      |      |      |      |          |          |
ccp                              |      |      |      |      |     -1.3%|     -0.3%|
backprop                         |      |      |      |      |     -1.4%|     -0.3%|
phiprop              ------------|      |      |      |      |          |          |
forwprop             ------------|      |      |      |      |          |          |
objsz                ------------|      |      |      |      |          |          |
alias                ------------|      |      |      |      |          |          |
retslot              ------------|      |      |      |      |          |          |
mergephi             ------------|      |      |      |      |          |          |
dce                  ------------|      |      |      |      |          |          |
stdarg               ------------|      |      |      |      |          |          |
cdce                 ------------|      |      |      |      |          |          |
cselim               ------------|      |      |      |      |          |          |
copyprop             ------------|      |      |      |      |          |          |
ifcombine            ------------|      |      |      |      |          |          |
mergephi             ------------|      |      |      |      |          |          |
phiopt               ------------|      |      |      |      |          |          |
ch                               |      |      |      |      |     +1.7%|     +0.0%|
cplxlower                        |      |      |      |      |     +1.7%|     +0.0%|
sra                  ------------|      |      |      |      |          |          |
dom                              |      |      |      |      |     -1.7%|     -0.3%|
copyprop                         |      |      |      |      |     -1.7%|     -0.3%|
reassoc              ------------|      |      |      |      |          |          |
dce                  ------------|      |      |      |      |          |          |
forwprop                         |      |      |      |      |     -0.3%|     -0.0%|
phiopt                           |      |      |      |      |     -0.3%|     -0.0%|
ccp                  ------------|      |      |      |      |          |          |
sincos               ------------|      |      |      |      |          |          |
laddress             ------------|      |      |      |      |          |          |
lim                  ------------|      |      |      |      |          |          |
walloca              ------------|      |      |      |      |          |          |
sink                 ------------|      |      |      |      |          |          |
dce                  ------------|      |      |      |      |          |          |
fix_loops            ------------|      |      |      |      |          |          |
loop                 ------------|      |      |      |      |          |          |
loopinit                         |      |      |      |      |    -69.7%|    -95.2%|
sccp                 ------------|      |      |      |      |          |          |
cddce                ------------|      |      |      |      |          |          |
ivcanon              ------------|      |      |      |      |          |          |
copyprop             ------------|      |      |      |      |          |          |
cunroll              ------------|      |      |      |      |          |          |
ivopts               ------------|      |      |      |      |          |          |
lim                  ------------|      |      |      |      |          |          |
loopdone             ------------|      |      |      |      |          |          |
no_loop                          |      |      |      |      |   +229.5%|  +1963.6%|
veclower2            ------------|      |      |      |      |          |          |
switchlower          ------------|      |      |      |      |          |          |
reassoc              ------------|      |      |      |      |          |          |
slsr                 ------------|      |      |      |      |          |          |
dom                              |      |      |      |      |          |     -0.0%|
strlen                           |      |    +2|      |      |          |     -0.0%|
copyprop             ------------|      |      |      |      |          |          |
wrestrict            ------------|      |      |      |      |          |          |
cddce                ------------|      |      |      |      |          |          |
forwprop             ------------|      |      |      |      |          |          |
phiopt               ------------|      |      |      |      |          |          |
fab                  ------------|      |      |      |      |          |          |
dce                  ------------|      |      |      |      |          |          |
crited               ------------|      |      |      |      |          |          |
uncprop              ------------|      |      |      |      |          |          |
local-pure-const     ------------|      |      |      |      |          |          |
modref               ------------|      |      |      |      |          |          |
nrv                  ------------|      |      |      |      |          |          |
isel                 ------------|      |      |      |      |          |          |
optimized            ------------|      |      |      |      |          |          |
expand                           |      |      |      |      |----------|----------|
vregs                            |      |      |      |      |    +72.8%|    +33.6%|
into_cfglayout                   |      |      |      |      |     -1.1%|     -0.1%|
jump                             |      |      |      |      |     -2.2%|     -1.2%|
subreg1                          |      |      |      |      |     -1.1%|     -1.1%|
dfinit               ------------|      |      |      |      |          |          |
cse1                 ------------|      |      |      |      |          |          |
fwprop1                          |      |      |      |      |     -4.1%|     -4.6%|
ce1                              |      |      |      |      |     -4.3%|     -4.8%|
reginfo              ------------|      |      |      |      |          |          |
loop2                ------------|      |      |      |      |          |          |
loop2_init           ------------|      |      |      |      |          |          |
loop2_invariant      ------------|      |      |      |      |          |          |
loop2_done           ------------|      |      |      |      |          |          |
dse1                 ------------|      |      |      |      |          |          |
fwprop2              ------------|      |      |      |      |          |          |
init-regs            ------------|      |      |      |      |          |          |
combine                          |      |      |      |      |     +4.5%|     +5.4%|
ce2                              |      |      |      |      |     +4.3%|     +5.1%|
outof_cfglayout                  |      |      |      |      |     +1.1%|     +0.1%|
split1                           |      |      |      |      |     +1.1%|     +0.1%|
subreg3              ------------|      |      |      |      |          |          |
mode_sw              ------------|      |      |      |      |          |          |
asmcons              ------------|      |      |      |      |          |          |
ira                  ------------|      |      |      |      |          |          |
reload                           |      |      |      |      |     -7.8%|    -10.2%|
postreload                       |      |      |      |      |     -8.4%|    -11.4%|
split2                           |      |      |      |      |          |     +1.3%|
cmpelim                          |      |      |      |      |          |     +1.2%|
pro_and_epilogue                 |      |      |      |      |    +13.4%|    +16.2%|
dse2                             |      |      |      |      |    +11.8%|    +13.9%|
csa                  ------------|      |      |      |      |          |          |
jump2                ------------|      |      |      |      |          |          |
ce3                  ------------|      |      |      |      |          |          |
cprop_hardreg                    |      |      |      |      |     -0.2%|     -0.3%|
rtl_dce                          |      |      |      |      |     -0.2%|     -0.3%|
bbro                             |      |      |      |      |          |     -0.0%|
split4                           |      |      |      |      |          |     -0.0%|
stack                ------------|      |      |      |      |          |          |
zero_call_used_regs  ------------|      |      |      |      |          |          |
alignments           ------------|      |      |      |      |          |          |
