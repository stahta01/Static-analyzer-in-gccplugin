./benchmarks/tmux/leak_1/tmux_leak_1.c: In function â€˜xvasprintfâ€™:
./benchmarks/tmux/leak_1/tmux_leak_1.c:91:6: warning: implicit declaration of function â€˜vasprintfâ€™; did you mean â€˜xvasprintfâ€™? [-Wimplicit-function-declaration]
  i = vasprintf(ret, fmt, ap);
      ^~~~~~~~~
      xvasprintf
./benchmarks/tmux/leak_1/tmux_leak_1.c: In function â€˜screen_write_cnputsâ€™:
./benchmarks/tmux/leak_1/tmux_leak_1.c:111:2: warning: implicit declaration of function â€˜memcpyâ€™ [-Wimplicit-function-declaration]
  memcpy(&gc, gcp, sizeof gc);
  ^~~~~~
./benchmarks/tmux/leak_1/tmux_leak_1.c:111:2: warning: incompatible implicit declaration of built-in function â€˜memcpyâ€™
./benchmarks/tmux/leak_1/tmux_leak_1.c:111:2: note: include â€˜<string.h>â€™ or provide a declaration of â€˜memcpyâ€™
./benchmarks/tmux/leak_1/tmux_leak_1.c:119:17: warning: implicit declaration of function â€˜strcspnâ€™ [-Wimplicit-function-declaration]
    last = ptr + strcspn(ptr, "]");
                 ^~~~~~~
./benchmarks/tmux/leak_1/tmux_leak_1.c:119:17: warning: incompatible implicit declaration of built-in function â€˜strcspnâ€™
./benchmarks/tmux/leak_1/tmux_leak_1.c:119:17: note: include â€˜<string.h>â€™ or provide a declaration of â€˜strcspnâ€™
./benchmarks/tmux/leak_1/tmux_leak_1.c:133:11: warning: implicit declaration of function â€˜strlenâ€™ [-Wimplicit-function-declaration]
    left = strlen(ptr);
           ^~~~~~
./benchmarks/tmux/leak_1/tmux_leak_1.c:133:11: warning: incompatible implicit declaration of built-in function â€˜strlenâ€™
./benchmarks/tmux/leak_1/tmux_leak_1.c:133:11: note: include â€˜<string.h>â€™ or provide a declaration of â€˜strlenâ€™
In file included from ./benchmarks/tmux/leak_1/tmux_leak_1.c:10:0:
./benchmarks/tmux/leak_1/tmux_leak_1.c: In function â€˜screen_write_cstrlenâ€™:
./benchmarks/tmux/leak_1/tmux_leak_1.c:169:17: warning: incompatible implicit declaration of built-in function â€˜strlenâ€™
  msg2 = xmalloc(strlen(msg) + 1);
                 ^
./benchmarks/tmux/leak_1/../stdio.h:137:27: note: in definition of macro â€˜xmallocâ€™
 #define xmalloc(a) malloc(a)
                           ^
./benchmarks/tmux/leak_1/tmux_leak_1.c:169:17: note: include â€˜<string.h>â€™ or provide a declaration of â€˜strlenâ€™
  msg2 = xmalloc(strlen(msg) + 1);
                 ^
./benchmarks/tmux/leak_1/../stdio.h:137:27: note: in definition of macro â€˜xmallocâ€™
 #define xmalloc(a) malloc(a)
                           ^
./benchmarks/tmux/leak_1/tmux_leak_1.c: In function â€˜screen_redraw_make_pane_statusâ€™:
./benchmarks/tmux/leak_1/tmux_leak_1.c:218:2: warning: incompatible implicit declaration of built-in function â€˜memcpyâ€™
  memcpy(&old, &wp->status_screen, sizeof old);
  ^~~~~~
./benchmarks/tmux/leak_1/tmux_leak_1.c:218:2: note: include â€˜<string.h>â€™ or provide a declaration of â€˜memcpyâ€™
./benchmarks/tmux/leak_1/tmux_leak_1.c:221:15: warning: incompatible implicit declaration of built-in function â€˜strlenâ€™
  out = malloc(strlen(fmt));                      /* allocation site */
               ^~~~~~
./benchmarks/tmux/leak_1/tmux_leak_1.c:221:15: note: include â€˜<string.h>â€™ or provide a declaration of â€˜strlenâ€™
=======ipa_pta=========
===============The first stage : Point of interest stmt collect=================
--------GIMPLE Cond -------
succs:= 2
--------GIMPLE Cond -------
succs:= 2
succs:= 3
succs:= 3
--------GIMPLE Cond -------
succs:= 3
--------GIMPLE Cond -------
succs:= 4
--------GIMPLE Cond -------
succs:= 7
--------GIMPLE Cond -------
succs:= 8
--------GIMPLE Cond -------
succs:= 8
succs:= 10
succs:= 3
succs:= 4
--------GIMPLE Cond -------
succs:= 13
--------GIMPLE Cond -------
succs:= 15
--------GIMPLE Cond -------
succs:= 16
--------GIMPLE Cond -------
succs:= 17
--------GIMPLE Cond -------
succs:= 18
succs:= 15
succs:= 16
--------GIMPLE Cond -------
succs:= 19
--------GIMPLE Cond -------
succs:= 20
--------GIMPLE Cond -------
--------GIMPLE Cond -------
succs:= 21
--------GIMPLE Cond -------
succs:= 21
succs:= 22
succs:= 23
--------GIMPLE Cond -------
succs:= 24
--------GIMPLE Cond -------
succs:= 23
succs:= 24
--------GIMPLE Cond -------
succs:= 19
succs:= 28
--------GIMPLE Cond -------
succs:= 28
succs:= 29
--------GIMPLE Cond -------
succs:= 30
succs:= 30
--------GIMPLE Cond -------
succs:= 17
succs:= 20
succs:= 26
succs:= 29
succs:= 34
--------GIMPLE Cond -------
succs:= 35
--------GIMPLE Cond -------
succs:= 35
succs:= 36
--------GIMPLE Cond -------
succs:= 38
===============The first stage : Point of interest stmt collect=================
start PointerConstraint
pointer ftable is 1 
pointer ptable is 1 
===============The second stage : Mapping stmt=================
# .MEM_11 = VDEF <.MEM_10(D)>
i_7 = vasprintf (ret_3(D), fmt_4(D), ap_5(D));
# .MEM_12 = VDEF <.MEM_11>
_9 = __printf_chk (1, "xasprintf: %s", "");
# .MEM_95 = VDEF <.MEM_1(D)>
memcpy (&old, _6, 136);
# VUSE <.MEM_96>
_8 = strlen (fmt_7(D));
# .MEM_97 = VDEF <.MEM_96>
out_9 = malloc (_8);
# .MEM_98 = VDEF <.MEM_97>
xvasprintf (&msg, "%s", out_9);
# VUSE <.MEM_98>
_62 = strlen (_61);
# .MEM_99 = VDEF <.MEM_98>
msg2_64 = malloc (_63);
 <var_decl 0x7f9b1154f510 msg
    type <pointer_type 0x7f9b11502930
        type <integer_type 0x7f9b11502888 char public string-flag QI
            size <integer_cst 0x7f9b119d8cd8 constant 8>
            unit size <integer_cst 0x7f9b119d8cf0 constant 1>
            align 8 symtab 0 alias set -1 canonical type 0x7f9b119ec3f0 precision 8 min <integer_cst 0x7f9b115051b0 -128> max <integer_cst 0x7f9b11505198 127> context <translation_unit_decl 0x7f9b119e3168 ./benchmarks/tmux/leak_1/tmux_leak_1.c>
            pointer_to_this <pointer_type 0x7f9b11502930>>
        public unsigned DI
        size <integer_cst 0x7f9b119d8be8 constant 64>
        unit size <integer_cst 0x7f9b119d8c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality context <translation_unit_decl 0x7f9b119e3168 ./benchmarks/tmux/leak_1/tmux_leak_1.c>
        pointer_to_this <pointer_type 0x7f9b1150e000>>
    addressable used unsigned DI file ./benchmarks/tmux/leak_1/tmux_leak_1.c line 165 col 10 size <integer_cst 0x7f9b119d8be8 64> unit size <integer_cst 0x7f9b119d8c00 8>
    align 64 context <function_decl 0x7f9b11503b00 main> abstract_origin <var_decl 0x7f9b1154f120 msg> chain <var_decl 0x7f9b1154f5a0 msg2>>
# .MEM_106 = VDEF <.MEM_105>
xvasprintf (&msg, "%s", out_9);
# VUSE <.MEM_94>
_26 = strcspn (ptr_25, "]");
# VUSE <.MEM_94>
left_33 = strlen (ptr_32);
 <var_decl 0x7f9b11543990 msg
    type <pointer_type 0x7f9b11502930
        type <integer_type 0x7f9b11502888 char public string-flag QI
            size <integer_cst 0x7f9b119d8cd8 constant 8>
            unit size <integer_cst 0x7f9b119d8cf0 constant 1>
            align 8 symtab 0 alias set -1 canonical type 0x7f9b119ec3f0 precision 8 min <integer_cst 0x7f9b115051b0 -128> max <integer_cst 0x7f9b11505198 127> context <translation_unit_decl 0x7f9b119e3168 ./benchmarks/tmux/leak_1/tmux_leak_1.c>
            pointer_to_this <pointer_type 0x7f9b11502930>>
        public unsigned DI
        size <integer_cst 0x7f9b119d8be8 constant 64>
        unit size <integer_cst 0x7f9b119d8c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality context <translation_unit_decl 0x7f9b119e3168 ./benchmarks/tmux/leak_1/tmux_leak_1.c>
        pointer_to_this <pointer_type 0x7f9b1150e000>>
    addressable used unsigned DI file ./benchmarks/tmux/leak_1/tmux_leak_1.c line 106 col 10 size <integer_cst 0x7f9b119d8be8 64> unit size <integer_cst 0x7f9b119d8c00 8>
    align 64 context <function_decl 0x7f9b11503b00 main> abstract_origin <var_decl 0x7f9b115432d0 msg> chain <var_decl 0x7f9b11543a20 ptr>>
start collect similar stmtstart collect similar stmtstart collect similar stmtstart collect similar stmt
start collect similar stmtstart collect similar stmtstart collect similar stmtstart collect similar stmt
start collect similar stmtstart collect similar stmtstart collect similar stmtstart collect similar stmt
start collect similar stmtstart collect similar stmtstart collect similar stmtstart collect similar stmt
start collect similar stmtstart collect similar stmtstart collect similar stmtstart collect similar stmt
===============The second stage : build fucntion type=================
[40;41mSTART CHECKSTART CHECKSTART CHECKSTART CHECKSTART CHECK[0m
[40;41mSTART CHECKSTART CHECKSTART CHECKSTART CHECKSTART CHECK[0m
    =()=
 ,/'_||_
  (___  `.
 ./  `=='
      |||
      |||
      |||
      |||
[40;41mSTART CHECKSTART CHECKSTART CHECKSTART CHECKSTART CHECK[0m
[40;41mSTART CHECKSTART CHECKSTART CHECKSTART CHECKSTART CHECK[0m
===============The second stage : record fucntion =================

=============== The third stage : Start detection  =================
[40;44m =======node_fun:xvasprintf========= [0m
[40;44m fucntion collect path  [0m
[40;44m =======print_function_path xvasprintf  function_call count: 3 level :0========  [0m
[40;44m =======print_function_type 0  ========  [0m
[40;42m =======pre add _ fucntion:exit========= [0m
[40;33m =======POP node_fun stack:exit========= [0m
[40;42m =======pre add _ fucntion:__printf_chk========= [0m
[40;33m =======POP node_fun stack:__printf_chk========= [0m
[40;42m =======pre add _ fucntion:vasprintf========= [0m
[40;33m =======POP node_fun stack:vasprintf========= [0m
[40;42m =======pre_check_funciton:xvasprintf========= [0m
[40;42m =======start_check_funciton:xvasprintf========= [0m

dot graph START

======================================================================
 <ssa_name 0x7f9b119e0870
    type <pointer_type 0x7f9b1150e000
        type <pointer_type 0x7f9b11502930 type <integer_type 0x7f9b11502888 char>
            public unsigned DI
            size <integer_cst 0x7f9b119d8be8 constant 64>
            unit size <integer_cst 0x7f9b119d8c00 constant 8>
            align 64 symtab 0 alias set -1 structural equality context <translation_unit_decl 0x7f9b119e3168 ./benchmarks/tmux/leak_1/tmux_leak_1.c>
            pointer_to_this <pointer_type 0x7f9b1150e000>>
        public unsigned DI size <integer_cst 0x7f9b119d8be8 64> unit size <integer_cst 0x7f9b119d8c00 8>
        align 64 symtab 0 alias set -1 structural equality>
    var <parm_decl 0x7f9b1152f000 ret>
    def_stmt GIMPLE_NOP
    version 3
    ptr-info 0x7f9b115328e8>
GIMPLE_NOP

 ================== trace ptable================== 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr--------
this other function -----------
 
 Start check Pointer Collect  

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# VUSE <.MEM_11>
_1 = *ret_3(D);
bb index := 3
# VUSE <.MEM_11>
return i_7;
In function â€˜xvasprintfâ€™:
./benchmarks/tmux/leak_1/tmux_leak_1.c:96:9: warning: use location
  return i;
         ^
beacuse in succ := 5 have return or exit
gimple stmt in succ := 3 ,possiable got to succ := 5

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# VUSE <.MEM_11>
_1 = *ret_3(D);
bb index := 3
# VUSE <.MEM_11>
return i_7;
./benchmarks/tmux/leak_1/tmux_leak_1.c:96:9: warning: use location
beacuse in succ := 5 have return or exit
gimple stmt in succ := 3 ,possiable got to succ := 5

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# VUSE <.MEM_11>
_1 = *ret_3(D);
bb index := 3
# VUSE <.MEM_11>
return i_7;
./benchmarks/tmux/leak_1/tmux_leak_1.c:96:9: warning: use location
beacuse in succ := 5 have return or exit
gimple stmt in succ := 3 ,possiable got to succ := 5

======================================================================
_1 = *ret_3(D);
./benchmarks/tmux/leak_1/tmux_leak_1.c:93:15: warning: use location
  if (i < 0 || *ret == NULL)
               ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
if (_1 == 0B)
bb index := 3
# VUSE <.MEM_11>
return i_7;
./benchmarks/tmux/leak_1/tmux_leak_1.c:96:9: warning: use location
  return i;
         ^
beacuse in succ := 5 have return or exit
gimple stmt in succ := 3 ,possiable got to succ := 5

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
if (_1 == 0B)
bb index := 3
# VUSE <.MEM_11>
return i_7;
./benchmarks/tmux/leak_1/tmux_leak_1.c:96:9: warning: use location
beacuse in succ := 5 have return or exit
gimple stmt in succ := 3 ,possiable got to succ := 5

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
if (_1 == 0B)
bb index := 3
# VUSE <.MEM_11>
return i_7;
./benchmarks/tmux/leak_1/tmux_leak_1.c:96:9: warning: use location
beacuse in succ := 5 have return or exit
gimple stmt in succ := 3 ,possiable got to succ := 5

======================================================================
if (_1 == 0B)
./benchmarks/tmux/leak_1/tmux_leak_1.c:93:12: warning: use location
  if (i < 0 || *ret == NULL)
            ^
if (_1 == 0B)

 ================== find cond branch ================= 
./benchmarks/tmux/leak_1/tmux_leak_1.c:93:12: warning: use location
Cond in fucntion xvasprintf basic block 3
 ================== possible direct basic block ================= 
from xvasprintf basic block 4
 ================== possible direct basic block ================= 
from xvasprintf basic block 5
 ================== warring ================== 
[40;35m    need check this branch possible have return or exit stmt [0m

 ================== warring ================== 

 ================== find cond branch ================= 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_11 = VDEF <.MEM_10(D)>
i_7 = vasprintf (ret_3(D), fmt_4(D), ap_5(D));
bb index := 2
# VUSE <.MEM_11>
return i_7;
./benchmarks/tmux/leak_1/tmux_leak_1.c:96:9: warning: use location
  return i;
         ^
beacuse in succ := 5 have return or exit
gimple stmt in succ := 2 ,possiable got to succ := 5

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_11 = VDEF <.MEM_10(D)>
i_7 = vasprintf (ret_3(D), fmt_4(D), ap_5(D));
bb index := 2
# VUSE <.MEM_11>
return i_7;
./benchmarks/tmux/leak_1/tmux_leak_1.c:96:9: warning: use location
beacuse in succ := 5 have return or exit
gimple stmt in succ := 2 ,possiable got to succ := 5

======================================================================
i_7 = vasprintf (ret_3(D), fmt_4(D), ap_5(D));
./benchmarks/tmux/leak_1/tmux_leak_1.c:91:4: warning: use location
  i = vasprintf(ret, fmt, ap);
    ^
this stmt is child function---vasprintf-----

 ================== trace ================== 
 <ssa_name 0x7f9b119e0870
    type <pointer_type 0x7f9b1150e000
        type <pointer_type 0x7f9b11502930 type <integer_type 0x7f9b11502888 char>
            public unsigned DI
            size <integer_cst 0x7f9b119d8be8 constant 64>
            unit size <integer_cst 0x7f9b119d8c00 constant 8>
            align 64 symtab 0 alias set -1 structural equality context <translation_unit_decl 0x7f9b119e3168 ./benchmarks/tmux/leak_1/tmux_leak_1.c>
            pointer_to_this <pointer_type 0x7f9b1150e000>>
        public unsigned DI size <integer_cst 0x7f9b119d8be8 64> unit size <integer_cst 0x7f9b119d8c00 8>
        align 64 symtab 0 alias set -1 structural equality>
    var <parm_decl 0x7f9b1152f000 ret>
    def_stmt GIMPLE_NOP
    version 3
    ptr-info 0x7f9b115328e8>
trace fucntion name:vasprintf 

 ================== trace ================== 
trace fucntion free:0 

======================================================================
[40;31m    branch possiable have return or exit  [0m
if (i_7 < 0)
bb index := 2
# VUSE <.MEM_11>
return i_7;
./benchmarks/tmux/leak_1/tmux_leak_1.c:96:9: warning: use location
  return i;
         ^
beacuse in succ := 5 have return or exit
gimple stmt in succ := 2 ,possiable got to succ := 5

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
if (i_7 < 0)
bb index := 2
# VUSE <.MEM_11>
return i_7;
./benchmarks/tmux/leak_1/tmux_leak_1.c:96:9: warning: use location
beacuse in succ := 5 have return or exit
gimple stmt in succ := 2 ,possiable got to succ := 5

======================================================================
if (i_7 < 0)
./benchmarks/tmux/leak_1/tmux_leak_1.c:93:5: warning: use location
  if (i < 0 || *ret == NULL)
     ^
if (i_7 < 0)

 ================== find cond branch ================= 
./benchmarks/tmux/leak_1/tmux_leak_1.c:93:5: warning: use location
Cond in fucntion xvasprintf basic block 2
 ================== possible direct basic block ================= 
from xvasprintf basic block 4
 ================== possible direct basic block ================= 
from xvasprintf basic block 3
 ================== warring ================== 
[40;35m    need check this branch possible have return or exit stmt [0m

 ================== warring ================== 

 ================== find cond branch ================= 

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7f9b119e0870
    type <pointer_type 0x7f9b1150e000
        type <pointer_type 0x7f9b11502930 type <integer_type 0x7f9b11502888 char>
            public unsigned DI
            size <integer_cst 0x7f9b119d8be8 constant 64>
            unit size <integer_cst 0x7f9b119d8c00 constant 8>
            align 64 symtab 0 alias set -1 structural equality context <translation_unit_decl 0x7f9b119e3168 ./benchmarks/tmux/leak_1/tmux_leak_1.c>
            pointer_to_this <pointer_type 0x7f9b1150e000>>
        public unsigned DI size <integer_cst 0x7f9b119d8be8 64> unit size <integer_cst 0x7f9b119d8c00 8>
        align 64 symtab 0 alias set -1 structural equality>
    var <parm_decl 0x7f9b1152f000 ret>
    def_stmt GIMPLE_NOP
    version 3
    ptr-info 0x7f9b115328e8>

 ================== Start Use after free Check ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:0 [0m

======================================================================

======================================================================
[40;31m 	this stmt need double check [0m

======================================================================

dot graph START

======================================================================

 ================== collect possiable invalid ================== 
 <integer_cst 0x7f9b119d8f90 type <integer_type 0x7f9b119ec5e8 int> constant 1>
[40;33m =======POP node_fun stack:xvasprintf========= [0m
[40;44m =======node_fun:main========= [0m
[40;44m fucntion collect path  [0m
[40;44m =======print_function_path main  function_call count: 6 level :0========  [0m
[40;44m =======print_function_type 0  ========  [0m
[40;42m =======pre add _ fucntion:free========= [0m
[40;33m =======POP node_fun stack:free========= [0m
[40;42m =======pre add _ fucntion:strlen========= [0m
[40;33m =======POP node_fun stack:strlen========= [0m
[40;42m =======pre add _ fucntion:strcspn========= [0m
[40;33m =======POP node_fun stack:strcspn========= [0m
[40;42m =======pre add _ fucntion:xvasprintf========= [0m
[40;44m =======print_function_type 0  ========  [0m
[40;44m =======print_function_path xvasprintf  function_call count: 3 level :1========  [0m
[40;44m =======print_function_type 0  ========  [0m
[40;42m =======pre add _ fucntion:exit========= [0m
[40;33m =======POP node_fun stack:exit========= [0m
[40;42m =======pre add _ fucntion:__printf_chk========= [0m
[40;33m =======POP node_fun stack:__printf_chk========= [0m
[40;42m =======pre add _ fucntion:vasprintf========= [0m
[40;33m =======POP node_fun stack:vasprintf========= [0m
[40;42m =======pre_check_funciton:xvasprintf========= [0m
[40;42m =======start_check_funciton:xvasprintf========= [0m

dot graph START

======================================================================
 <ssa_name 0x7f9b119e0870
    type <pointer_type 0x7f9b1150e000
        type <pointer_type 0x7f9b11502930 type <integer_type 0x7f9b11502888 char>
            public unsigned DI
            size <integer_cst 0x7f9b119d8be8 constant 64>
            unit size <integer_cst 0x7f9b119d8c00 constant 8>
            align 64 symtab 0 alias set -1 structural equality context <translation_unit_decl 0x7f9b119e3168 ./benchmarks/tmux/leak_1/tmux_leak_1.c>
            pointer_to_this <pointer_type 0x7f9b1150e000>>
        public unsigned DI size <integer_cst 0x7f9b119d8be8 64> unit size <integer_cst 0x7f9b119d8c00 8>
        align 64 symtab 0 alias set -1 structural equality>
    var <parm_decl 0x7f9b1152f000 ret>
    def_stmt GIMPLE_NOP
    version 3
    ptr-info 0x7f9b115328e8>
GIMPLE_NOP

 ================== trace ptable================== 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr--------
this other function -----------
 
 Start check Pointer Collect  

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# VUSE <.MEM_11>
_1 = *ret_3(D);
bb index := 3
# VUSE <.MEM_11>
return i_7;
In function â€˜mainâ€™:
./benchmarks/tmux/leak_1/tmux_leak_1.c:96:9: warning: use location
  return i;
         ^
beacuse in succ := 5 have return or exit
gimple stmt in succ := 3 ,possiable got to succ := 5

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# VUSE <.MEM_11>
_1 = *ret_3(D);
bb index := 3
# VUSE <.MEM_11>
return i_7;
./benchmarks/tmux/leak_1/tmux_leak_1.c:96:9: warning: use location
beacuse in succ := 5 have return or exit
gimple stmt in succ := 3 ,possiable got to succ := 5

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# VUSE <.MEM_11>
_1 = *ret_3(D);
bb index := 3
# VUSE <.MEM_11>
return i_7;
./benchmarks/tmux/leak_1/tmux_leak_1.c:96:9: warning: use location
beacuse in succ := 5 have return or exit
gimple stmt in succ := 3 ,possiable got to succ := 5

======================================================================
_1 = *ret_3(D);
./benchmarks/tmux/leak_1/tmux_leak_1.c:93:15: warning: use location
  if (i < 0 || *ret == NULL)
               ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
if (_1 == 0B)
bb index := 3
# VUSE <.MEM_11>
return i_7;
./benchmarks/tmux/leak_1/tmux_leak_1.c:96:9: warning: use location
  return i;
         ^
beacuse in succ := 5 have return or exit
gimple stmt in succ := 3 ,possiable got to succ := 5

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
if (_1 == 0B)
bb index := 3
# VUSE <.MEM_11>
return i_7;
./benchmarks/tmux/leak_1/tmux_leak_1.c:96:9: warning: use location
beacuse in succ := 5 have return or exit
gimple stmt in succ := 3 ,possiable got to succ := 5

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
if (_1 == 0B)
bb index := 3
# VUSE <.MEM_11>
return i_7;
./benchmarks/tmux/leak_1/tmux_leak_1.c:96:9: warning: use location
beacuse in succ := 5 have return or exit
gimple stmt in succ := 3 ,possiable got to succ := 5

======================================================================
if (_1 == 0B)
./benchmarks/tmux/leak_1/tmux_leak_1.c:93:12: warning: use location
  if (i < 0 || *ret == NULL)
            ^
if (_1 == 0B)

 ================== find cond branch ================= 
./benchmarks/tmux/leak_1/tmux_leak_1.c:93:12: warning: use location
Cond in fucntion xvasprintf basic block 3
 ================== possible direct basic block ================= 
from xvasprintf basic block 4
 ================== possible direct basic block ================= 
from xvasprintf basic block 5
 ================== warring ================== 
[40;35m    need check this branch possible have return or exit stmt [0m

 ================== warring ================== 

 ================== find cond branch ================= 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_11 = VDEF <.MEM_10(D)>
i_7 = vasprintf (ret_3(D), fmt_4(D), ap_5(D));
bb index := 2
# VUSE <.MEM_11>
return i_7;
./benchmarks/tmux/leak_1/tmux_leak_1.c:96:9: warning: use location
  return i;
         ^
beacuse in succ := 5 have return or exit
gimple stmt in succ := 2 ,possiable got to succ := 5

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_11 = VDEF <.MEM_10(D)>
i_7 = vasprintf (ret_3(D), fmt_4(D), ap_5(D));
bb index := 2
# VUSE <.MEM_11>
return i_7;
./benchmarks/tmux/leak_1/tmux_leak_1.c:96:9: warning: use location
beacuse in succ := 5 have return or exit
gimple stmt in succ := 2 ,possiable got to succ := 5

======================================================================
i_7 = vasprintf (ret_3(D), fmt_4(D), ap_5(D));
./benchmarks/tmux/leak_1/tmux_leak_1.c:91:4: warning: use location
  i = vasprintf(ret, fmt, ap);
    ^
this stmt is child function---vasprintf-----

 ================== trace ================== 
 <ssa_name 0x7f9b119e0870
    type <pointer_type 0x7f9b1150e000
        type <pointer_type 0x7f9b11502930 type <integer_type 0x7f9b11502888 char>
            public unsigned DI
            size <integer_cst 0x7f9b119d8be8 constant 64>
            unit size <integer_cst 0x7f9b119d8c00 constant 8>
            align 64 symtab 0 alias set -1 structural equality context <translation_unit_decl 0x7f9b119e3168 ./benchmarks/tmux/leak_1/tmux_leak_1.c>
            pointer_to_this <pointer_type 0x7f9b1150e000>>
        public unsigned DI size <integer_cst 0x7f9b119d8be8 64> unit size <integer_cst 0x7f9b119d8c00 8>
        align 64 symtab 0 alias set -1 structural equality>
    var <parm_decl 0x7f9b1152f000 ret>
    def_stmt GIMPLE_NOP
    version 3
    ptr-info 0x7f9b115328e8>
trace fucntion name:vasprintf 

 ================== trace ================== 
trace fucntion free:0 

======================================================================
[40;31m    branch possiable have return or exit  [0m
if (i_7 < 0)
bb index := 2
# VUSE <.MEM_11>
return i_7;
./benchmarks/tmux/leak_1/tmux_leak_1.c:96:9: warning: use location
  return i;
         ^
beacuse in succ := 5 have return or exit
gimple stmt in succ := 2 ,possiable got to succ := 5

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
if (i_7 < 0)
bb index := 2
# VUSE <.MEM_11>
return i_7;
./benchmarks/tmux/leak_1/tmux_leak_1.c:96:9: warning: use location
beacuse in succ := 5 have return or exit
gimple stmt in succ := 2 ,possiable got to succ := 5

======================================================================
if (i_7 < 0)
./benchmarks/tmux/leak_1/tmux_leak_1.c:93:5: warning: use location
  if (i < 0 || *ret == NULL)
     ^
if (i_7 < 0)

 ================== find cond branch ================= 
./benchmarks/tmux/leak_1/tmux_leak_1.c:93:5: warning: use location
Cond in fucntion xvasprintf basic block 2
 ================== possible direct basic block ================= 
from xvasprintf basic block 4
 ================== possible direct basic block ================= 
from xvasprintf basic block 3
 ================== warring ================== 
[40;35m    need check this branch possible have return or exit stmt [0m

 ================== warring ================== 

 ================== find cond branch ================= 

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7f9b119e0870
    type <pointer_type 0x7f9b1150e000
        type <pointer_type 0x7f9b11502930 type <integer_type 0x7f9b11502888 char>
            public unsigned DI
            size <integer_cst 0x7f9b119d8be8 constant 64>
            unit size <integer_cst 0x7f9b119d8c00 constant 8>
            align 64 symtab 0 alias set -1 structural equality context <translation_unit_decl 0x7f9b119e3168 ./benchmarks/tmux/leak_1/tmux_leak_1.c>
            pointer_to_this <pointer_type 0x7f9b1150e000>>
        public unsigned DI size <integer_cst 0x7f9b119d8be8 64> unit size <integer_cst 0x7f9b119d8c00 8>
        align 64 symtab 0 alias set -1 structural equality>
    var <parm_decl 0x7f9b1152f000 ret>
    def_stmt GIMPLE_NOP
    version 3
    ptr-info 0x7f9b115328e8>

 ================== Start Use after free Check ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:0 [0m

======================================================================

======================================================================
[40;31m 	this stmt need double check [0m

======================================================================

dot graph START

======================================================================

 ================== collect possiable invalid ================== 
 <integer_cst 0x7f9b119d8f90 type <integer_type 0x7f9b119ec5e8 int> constant 1>
[40;33m =======POP node_fun stack:xvasprintf========= [0m
[40;42m =======pre add _ fucntion:malloc========= [0m
[40;33m =======POP node_fun stack:malloc========= [0m
[40;42m =======pre add _ fucntion:memcpy========= [0m
[40;33m =======POP node_fun stack:memcpy========= [0m
[40;42m =======pre_check_funciton:main========= [0m
[40;42m =======start_check_funciton:main========= [0m

dot graph START

======================================================================
 <ssa_name 0x7f9b1153f2d0
    type <pointer_type 0x7f9b11502930
        type <integer_type 0x7f9b11502888 char public string-flag QI
            size <integer_cst 0x7f9b119d8cd8 constant 8>
            unit size <integer_cst 0x7f9b119d8cf0 constant 1>
            align 8 symtab 0 alias set -1 canonical type 0x7f9b119ec3f0 precision 8 min <integer_cst 0x7f9b115051b0 -128> max <integer_cst 0x7f9b11505198 127> context <translation_unit_decl 0x7f9b119e3168 ./benchmarks/tmux/leak_1/tmux_leak_1.c>
            pointer_to_this <pointer_type 0x7f9b11502930>>
        public unsigned DI
        size <integer_cst 0x7f9b119d8be8 constant 64>
        unit size <integer_cst 0x7f9b119d8c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality context <translation_unit_decl 0x7f9b119e3168 ./benchmarks/tmux/leak_1/tmux_leak_1.c>
        pointer_to_this <pointer_type 0x7f9b1150e000>>
    var <var_decl 0x7f9b1153c870 out>
    def_stmt out_9 = malloc (_8);
    version 9
    ptr-info 0x7f9b11532960>
# .MEM_97 = VDEF <.MEM_96>
out_9 = malloc (_8);

 ================== trace ptable================== 
trace fucntion name:malloc 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr---malloc-----
this Reserved word function ------malloc-----
 
 Start check Pointer Collect  

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_98 = VDEF <.MEM_97>
xvasprintf (&msg, "%s", out_9);
bb index := 2
# VUSE <.MEM_11>
return i_7;
./benchmarks/tmux/leak_1/tmux_leak_1.c:96:9: warning: use location
  return i;
         ^
beacuse in succ := 5 have return or exit
gimple stmt in succ := 2 ,possiable got to succ := 5

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_98 = VDEF <.MEM_97>
xvasprintf (&msg, "%s", out_9);
bb index := 2
# VUSE <.MEM_5>
return 0;
lto1: warning: use location
beacuse in succ := 40 have return or exit
gimple stmt in succ := 2 ,possiable got to succ := 40

======================================================================
xvasprintf (&msg, "%s", out_9);
./benchmarks/tmux/leak_1/tmux_leak_1.c:168:2: warning: use location
  xvasprintf(&msg, fmt, ap);
  ^
this stmt is child function---xvasprintf-----

 ================== trace ================== 
 <ssa_name 0x7f9b1153f2d0
    type <pointer_type 0x7f9b11502930
        type <integer_type 0x7f9b11502888 char public string-flag QI
            size <integer_cst 0x7f9b119d8cd8 constant 8>
            unit size <integer_cst 0x7f9b119d8cf0 constant 1>
            align 8 symtab 0 alias set -1 canonical type 0x7f9b119ec3f0 precision 8 min <integer_cst 0x7f9b115051b0 -128> max <integer_cst 0x7f9b11505198 127> context <translation_unit_decl 0x7f9b119e3168 ./benchmarks/tmux/leak_1/tmux_leak_1.c>
            pointer_to_this <pointer_type 0x7f9b11502930>>
        public unsigned DI
        size <integer_cst 0x7f9b119d8be8 constant 64>
        unit size <integer_cst 0x7f9b119d8c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality context <translation_unit_decl 0x7f9b119e3168 ./benchmarks/tmux/leak_1/tmux_leak_1.c>
        pointer_to_this <pointer_type 0x7f9b1150e000>>
    var <var_decl 0x7f9b1153c870 out>
    def_stmt out_9 = malloc (_8);
    version 9
    ptr-info 0x7f9b11532960>
trace fucntion name:xvasprintf 
[40;44m =======trace_function_path xvasprintf  function_call count: 3 level :0========  [0m
[40;42m =======pre add _ fucntion:exit========= [0m
[40;46m =======add node_fun stack:exit========= [0m
[40;42m =======pre add _ fucntion:__printf_chk========= [0m
[40;46m =======add node_fun stack:__printf_chk========= [0m
[40;42m =======pre add _ fucntion:vasprintf========= [0m
[40;46m =======add node_fun stack:vasprintf========= [0m

 ================== trace ================== 
trace fucntion free:0 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_106 = VDEF <.MEM_105>
xvasprintf (&msg, "%s", out_9);
bb index := 14
# VUSE <.MEM_11>
return i_7;
./benchmarks/tmux/leak_1/tmux_leak_1.c:96:9: warning: use location
  return i;
         ^
beacuse in succ := 5 have return or exit
gimple stmt in succ := 14 ,possiable got to succ := 5

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_106 = VDEF <.MEM_105>
xvasprintf (&msg, "%s", out_9);
bb index := 14
# VUSE <.MEM_11>
return i_7;
./benchmarks/tmux/leak_1/tmux_leak_1.c:96:9: warning: use location
beacuse in succ := 5 have return or exit
gimple stmt in succ := 14 ,possiable got to succ := 5

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_106 = VDEF <.MEM_105>
xvasprintf (&msg, "%s", out_9);
bb index := 14
# VUSE <.MEM_5>
return 0;
lto1: warning: use location
beacuse in succ := 40 have return or exit
gimple stmt in succ := 14 ,possiable got to succ := 40

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_106 = VDEF <.MEM_105>
xvasprintf (&msg, "%s", out_9);
bb index := 14
# VUSE <.MEM_5>
return 0;
lto1: warning: use location
beacuse in succ := 40 have return or exit
gimple stmt in succ := 14 ,possiable got to succ := 40

======================================================================
xvasprintf (&msg, "%s", out_9);
./benchmarks/tmux/leak_1/tmux_leak_1.c:113:2: warning: use location
  xvasprintf(&msg, fmt, ap);
  ^
this stmt is child function---xvasprintf-----

 ================== trace ================== 
 <ssa_name 0x7f9b1153f2d0
    type <pointer_type 0x7f9b11502930
        type <integer_type 0x7f9b11502888 char public string-flag QI
            size <integer_cst 0x7f9b119d8cd8 constant 8>
            unit size <integer_cst 0x7f9b119d8cf0 constant 1>
            align 8 symtab 0 alias set -1 canonical type 0x7f9b119ec3f0 precision 8 min <integer_cst 0x7f9b115051b0 -128> max <integer_cst 0x7f9b11505198 127> context <translation_unit_decl 0x7f9b119e3168 ./benchmarks/tmux/leak_1/tmux_leak_1.c>
            pointer_to_this <pointer_type 0x7f9b11502930>>
        public unsigned DI
        size <integer_cst 0x7f9b119d8be8 constant 64>
        unit size <integer_cst 0x7f9b119d8c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality context <translation_unit_decl 0x7f9b119e3168 ./benchmarks/tmux/leak_1/tmux_leak_1.c>
        pointer_to_this <pointer_type 0x7f9b1150e000>>
    var <var_decl 0x7f9b1153c870 out>
    def_stmt out_9 = malloc (_8);
    version 9
    ptr-info 0x7f9b11532960>
trace fucntion name:xvasprintf 
[40;44m =======trace_function_path xvasprintf  function_call count: 3 level :0========  [0m
[40;42m =======pre add _ fucntion:exit========= [0m
[40;46m =======add node_fun stack:exit========= [0m
[40;42m =======pre add _ fucntion:__printf_chk========= [0m
[40;46m =======add node_fun stack:__printf_chk========= [0m
[40;42m =======pre add _ fucntion:vasprintf========= [0m
[40;46m =======add node_fun stack:vasprintf========= [0m

 ================== trace ================== 
trace fucntion free:0 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_97 = VDEF <.MEM_96>
out_9 = malloc (_8);
bb index := 2
# VUSE <.MEM_11>
return i_7;
./benchmarks/tmux/leak_1/tmux_leak_1.c:96:9: warning: use location
  return i;
         ^
beacuse in succ := 5 have return or exit
gimple stmt in succ := 2 ,possiable got to succ := 5

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_97 = VDEF <.MEM_96>
out_9 = malloc (_8);
bb index := 2
# VUSE <.MEM_5>
return 0;
lto1: warning: use location
beacuse in succ := 40 have return or exit
gimple stmt in succ := 2 ,possiable got to succ := 40

======================================================================
out_9 = malloc (_8);
./benchmarks/tmux/leak_1/tmux_leak_1.c:221:6: warning: use location
  out = malloc(strlen(fmt));                      /* allocation site */
      ^
this stmt is child function---malloc-----

 ================== trace ================== 
 <ssa_name 0x7f9b1153f2d0
    type <pointer_type 0x7f9b11502930
        type <integer_type 0x7f9b11502888 char public string-flag QI
            size <integer_cst 0x7f9b119d8cd8 constant 8>
            unit size <integer_cst 0x7f9b119d8cf0 constant 1>
            align 8 symtab 0 alias set -1 canonical type 0x7f9b119ec3f0 precision 8 min <integer_cst 0x7f9b115051b0 -128> max <integer_cst 0x7f9b11505198 127> context <translation_unit_decl 0x7f9b119e3168 ./benchmarks/tmux/leak_1/tmux_leak_1.c>
            pointer_to_this <pointer_type 0x7f9b11502930>>
        public unsigned DI
        size <integer_cst 0x7f9b119d8be8 constant 64>
        unit size <integer_cst 0x7f9b119d8c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality context <translation_unit_decl 0x7f9b119e3168 ./benchmarks/tmux/leak_1/tmux_leak_1.c>
        pointer_to_this <pointer_type 0x7f9b1150e000>>
    var <var_decl 0x7f9b1153c870 out>
    def_stmt out_9 = malloc (_8);
    version 9
    ptr-info 0x7f9b11532960>
trace fucntion name:malloc 

 ================== trace ================== 
trace fucntion free:0 

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7f9b1153f2d0
    type <pointer_type 0x7f9b11502930
        type <integer_type 0x7f9b11502888 char public string-flag QI
            size <integer_cst 0x7f9b119d8cd8 constant 8>
            unit size <integer_cst 0x7f9b119d8cf0 constant 1>
            align 8 symtab 0 alias set -1 canonical type 0x7f9b119ec3f0 precision 8 min <integer_cst 0x7f9b115051b0 -128> max <integer_cst 0x7f9b11505198 127> context <translation_unit_decl 0x7f9b119e3168 ./benchmarks/tmux/leak_1/tmux_leak_1.c>
            pointer_to_this <pointer_type 0x7f9b11502930>>
        public unsigned DI
        size <integer_cst 0x7f9b119d8be8 constant 64>
        unit size <integer_cst 0x7f9b119d8c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality context <translation_unit_decl 0x7f9b119e3168 ./benchmarks/tmux/leak_1/tmux_leak_1.c>
        pointer_to_this <pointer_type 0x7f9b1150e000>>
    var <var_decl 0x7f9b1153c870 out>
    def_stmt out_9 = malloc (_8);
    version 9
    ptr-info 0x7f9b11532960>
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_101 = VDEF <.MEM_100>
free (_85);
./benchmarks/tmux/leak_1/tmux_leak_1.c:185:2: warning: use location
  free(msg);
  ^
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_108 = VDEF <.MEM_94>
free (_57);
./benchmarks/tmux/leak_1/tmux_leak_1.c:158:2: warning: use location
  free(msg);
  ^

 ================== Start Use after free Check ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_101 = VDEF <.MEM_100>
free (_85);
./benchmarks/tmux/leak_1/tmux_leak_1.c:185:2: warning: Use after free error!: free location 
  free(msg);
  ^
# .MEM_106 = VDEF <.MEM_105>
xvasprintf (&msg, "%s", out_9);
./benchmarks/tmux/leak_1/tmux_leak_1.c:113:2: warning: use location
  xvasprintf(&msg, fmt, ap);
  ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:2 [0m

======================================================================

======================================================================
[40;31m    no free stmt possible memory leak [0m

======================================================================

dot graph START

======================================================================
 <ssa_name 0x7f9b11553048
    type <pointer_type 0x7f9b11502930
        type <integer_type 0x7f9b11502888 char public string-flag QI
            size <integer_cst 0x7f9b119d8cd8 constant 8>
            unit size <integer_cst 0x7f9b119d8cf0 constant 1>
            align 8 symtab 0 alias set -1 canonical type 0x7f9b119ec3f0 precision 8 min <integer_cst 0x7f9b115051b0 -128> max <integer_cst 0x7f9b11505198 127> context <translation_unit_decl 0x7f9b119e3168 ./benchmarks/tmux/leak_1/tmux_leak_1.c>
            pointer_to_this <pointer_type 0x7f9b11502930>>
        public unsigned DI
        size <integer_cst 0x7f9b119d8be8 constant 64>
        unit size <integer_cst 0x7f9b119d8c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality context <translation_unit_decl 0x7f9b119e3168 ./benchmarks/tmux/leak_1/tmux_leak_1.c>
        pointer_to_this <pointer_type 0x7f9b1150e000>>
    var <var_decl 0x7f9b1154f5a0 msg2>
    def_stmt msg2_64 = malloc (_63);
    version 64
    ptr-info 0x7f9b11532ab0>
# .MEM_99 = VDEF <.MEM_98>
msg2_64 = malloc (_63);

 ================== trace ptable================== 
trace fucntion name:malloc 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr---malloc-----
this Reserved word function ------malloc-----
 
 Start check Pointer Collect  

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
ptr2_80 = PHI <msg2_64(2), ptr2_90(12)>
bb index := 13
# VUSE <.MEM_11>
return i_7;
./benchmarks/tmux/leak_1/tmux_leak_1.c:96:9: warning: use location
  return i;
         ^
beacuse in succ := 5 have return or exit
gimple stmt in succ := 13 ,possiable got to succ := 5

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
ptr2_80 = PHI <msg2_64(2), ptr2_90(12)>
bb index := 13
# VUSE <.MEM_11>
return i_7;
./benchmarks/tmux/leak_1/tmux_leak_1.c:96:9: warning: use location
beacuse in succ := 5 have return or exit
gimple stmt in succ := 13 ,possiable got to succ := 5

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
ptr2_80 = PHI <msg2_64(2), ptr2_90(12)>
bb index := 13
# VUSE <.MEM_11>
return i_7;
./benchmarks/tmux/leak_1/tmux_leak_1.c:96:9: warning: use location
beacuse in succ := 5 have return or exit
gimple stmt in succ := 13 ,possiable got to succ := 5

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
ptr2_80 = PHI <msg2_64(2), ptr2_90(12)>
bb index := 13
# VUSE <.MEM_11>
return i_7;
./benchmarks/tmux/leak_1/tmux_leak_1.c:96:9: warning: use location
beacuse in succ := 5 have return or exit
gimple stmt in succ := 13 ,possiable got to succ := 5

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
ptr2_80 = PHI <msg2_64(2), ptr2_90(12)>
bb index := 13
# VUSE <.MEM_5>
return 0;
lto1: warning: use location
beacuse in succ := 40 have return or exit
gimple stmt in succ := 13 ,possiable got to succ := 40

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
ptr2_80 = PHI <msg2_64(2), ptr2_90(12)>
bb index := 13
# VUSE <.MEM_5>
return 0;
lto1: warning: use location
beacuse in succ := 40 have return or exit
gimple stmt in succ := 13 ,possiable got to succ := 40

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
ptr2_80 = PHI <msg2_64(2), ptr2_90(12)>
bb index := 13
# VUSE <.MEM_5>
return 0;
lto1: warning: use location
beacuse in succ := 40 have return or exit
gimple stmt in succ := 13 ,possiable got to succ := 40

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
ptr2_80 = PHI <msg2_64(2), ptr2_90(12)>
bb index := 13
# VUSE <.MEM_5>
return 0;
lto1: warning: use location
beacuse in succ := 40 have return or exit
gimple stmt in succ := 13 ,possiable got to succ := 40

======================================================================

======================================================================
[40;31m    collect Stmt in loop [0m

======================================================================
ptr2_80 = PHI <msg2_64(2), ptr2_90(12)>
lto1: warning: use location
this stmt have mutiple branch --------

======================================================================
[40;31m    branch possiable have return or exit  [0m
ptr2_90 = PHI <ptr2_80(10), ptr2_82(11)>
bb index := 12
# VUSE <.MEM_11>
return i_7;
./benchmarks/tmux/leak_1/tmux_leak_1.c:96:9: warning: use location
beacuse in succ := 5 have return or exit
gimple stmt in succ := 12 ,possiable got to succ := 5

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
ptr2_90 = PHI <ptr2_80(10), ptr2_82(11)>
bb index := 12
# VUSE <.MEM_5>
return 0;
lto1: warning: use location
beacuse in succ := 40 have return or exit
gimple stmt in succ := 12 ,possiable got to succ := 40

======================================================================

======================================================================
[40;31m    collect Stmt in loop [0m

======================================================================
ptr2_90 = PHI <ptr2_80(10), ptr2_82(11)>
lto1: warning: use location
this stmt have mutiple branch --------

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_100 = VDEF <.MEM_92>
*ptr2_80 = 0;
bb index := 14
# VUSE <.MEM_11>
return i_7;
./benchmarks/tmux/leak_1/tmux_leak_1.c:96:9: warning: use location
beacuse in succ := 5 have return or exit
gimple stmt in succ := 14 ,possiable got to succ := 5

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_100 = VDEF <.MEM_92>
*ptr2_80 = 0;
bb index := 14
# VUSE <.MEM_11>
return i_7;
./benchmarks/tmux/leak_1/tmux_leak_1.c:96:9: warning: use location
beacuse in succ := 5 have return or exit
gimple stmt in succ := 14 ,possiable got to succ := 5

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_100 = VDEF <.MEM_92>
*ptr2_80 = 0;
bb index := 14
# VUSE <.MEM_5>
return 0;
lto1: warning: use location
beacuse in succ := 40 have return or exit
gimple stmt in succ := 14 ,possiable got to succ := 40

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_100 = VDEF <.MEM_92>
*ptr2_80 = 0;
bb index := 14
# VUSE <.MEM_5>
return 0;
lto1: warning: use location
beacuse in succ := 40 have return or exit
gimple stmt in succ := 14 ,possiable got to succ := 40

======================================================================
*ptr2_80 = 0;
./benchmarks/tmux/leak_1/tmux_leak_1.c:183:8: warning: use location
  *ptr2 = '\0';
        ^

======================================================================
[40;31m    collect Stmt in loop [0m

======================================================================
_81 = ptr2_80;
./benchmarks/tmux/leak_1/tmux_leak_1.c:181:8: warning: use location
   *ptr2++ = *ptr++;
        ^

======================================================================
[40;31m    collect Stmt in loop [0m

======================================================================
*_81 = _83;
./benchmarks/tmux/leak_1/tmux_leak_1.c:181:11: warning: use location
   *ptr2++ = *ptr++;
           ^

======================================================================
[40;31m    collect Stmt in loop [0m

======================================================================
*_81 = _83;
./benchmarks/tmux/leak_1/tmux_leak_1.c:181:11: warning: use location

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_102 = VDEF <.MEM_101>
free (msg2_64);
bb index := 14
# VUSE <.MEM_11>
return i_7;
./benchmarks/tmux/leak_1/tmux_leak_1.c:96:9: warning: use location
  return i;
         ^
beacuse in succ := 5 have return or exit
gimple stmt in succ := 14 ,possiable got to succ := 5

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_102 = VDEF <.MEM_101>
free (msg2_64);
bb index := 14
# VUSE <.MEM_11>
return i_7;
./benchmarks/tmux/leak_1/tmux_leak_1.c:96:9: warning: use location
beacuse in succ := 5 have return or exit
gimple stmt in succ := 14 ,possiable got to succ := 5

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_102 = VDEF <.MEM_101>
free (msg2_64);
bb index := 14
# VUSE <.MEM_5>
return 0;
lto1: warning: use location
beacuse in succ := 40 have return or exit
gimple stmt in succ := 14 ,possiable got to succ := 40

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_102 = VDEF <.MEM_101>
free (msg2_64);
bb index := 14
# VUSE <.MEM_5>
return 0;
lto1: warning: use location
beacuse in succ := 40 have return or exit
gimple stmt in succ := 14 ,possiable got to succ := 40

======================================================================
free (msg2_64);
./benchmarks/tmux/leak_1/tmux_leak_1.c:186:2: warning: use location
  free(msg2);
  ^
this stmt is child function---free-----

 ================== find ================== 
free (msg2_64);
./benchmarks/tmux/leak_1/tmux_leak_1.c:186:2: warning: use location
[40;32m    HAS FREE STMT count:1 name:free [0m

 ================== find ================== 

======================================================================
[40;31m    branch possiable have return or exit  [0m
ptr2_66 = msg2_64;
bb index := 2
# VUSE <.MEM_11>
return i_7;
./benchmarks/tmux/leak_1/tmux_leak_1.c:96:9: warning: use location
  return i;
         ^
beacuse in succ := 5 have return or exit
gimple stmt in succ := 2 ,possiable got to succ := 5

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
ptr2_66 = msg2_64;
bb index := 2
# VUSE <.MEM_5>
return 0;
lto1: warning: use location
beacuse in succ := 40 have return or exit
gimple stmt in succ := 2 ,possiable got to succ := 40

======================================================================
ptr2_66 = msg2_64;
./benchmarks/tmux/leak_1/tmux_leak_1.c:172:7: warning: use location
  ptr2 = msg2;
       ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_99 = VDEF <.MEM_98>
msg2_64 = malloc (_63);
bb index := 2
# VUSE <.MEM_11>
return i_7;
./benchmarks/tmux/leak_1/tmux_leak_1.c:96:9: warning: use location
  return i;
         ^
beacuse in succ := 5 have return or exit
gimple stmt in succ := 2 ,possiable got to succ := 5

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_99 = VDEF <.MEM_98>
msg2_64 = malloc (_63);
bb index := 2
# VUSE <.MEM_5>
return 0;
lto1: warning: use location
beacuse in succ := 40 have return or exit
gimple stmt in succ := 2 ,possiable got to succ := 40

======================================================================
msg2_64 = malloc (_63);
./benchmarks/tmux/leak_1/tmux_leak_1.c:169:7: warning: use location
  msg2 = xmalloc(strlen(msg) + 1);
       ^
this stmt is child function---malloc-----

 ================== trace ================== 
 <ssa_name 0x7f9b11553048
    type <pointer_type 0x7f9b11502930
        type <integer_type 0x7f9b11502888 char public string-flag QI
            size <integer_cst 0x7f9b119d8cd8 constant 8>
            unit size <integer_cst 0x7f9b119d8cf0 constant 1>
            align 8 symtab 0 alias set -1 canonical type 0x7f9b119ec3f0 precision 8 min <integer_cst 0x7f9b115051b0 -128> max <integer_cst 0x7f9b11505198 127> context <translation_unit_decl 0x7f9b119e3168 ./benchmarks/tmux/leak_1/tmux_leak_1.c>
            pointer_to_this <pointer_type 0x7f9b11502930>>
        public unsigned DI
        size <integer_cst 0x7f9b119d8be8 constant 64>
        unit size <integer_cst 0x7f9b119d8c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality context <translation_unit_decl 0x7f9b119e3168 ./benchmarks/tmux/leak_1/tmux_leak_1.c>
        pointer_to_this <pointer_type 0x7f9b1150e000>>
    var <var_decl 0x7f9b1154f5a0 msg2>
    def_stmt msg2_64 = malloc (_63);
    version 64
    ptr-info 0x7f9b11532ab0>
trace fucntion name:malloc 

 ================== trace ================== 
trace fucntion free:1 

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7f9b11553048
    type <pointer_type 0x7f9b11502930
        type <integer_type 0x7f9b11502888 char public string-flag QI
            size <integer_cst 0x7f9b119d8cd8 constant 8>
            unit size <integer_cst 0x7f9b119d8cf0 constant 1>
            align 8 symtab 0 alias set -1 canonical type 0x7f9b119ec3f0 precision 8 min <integer_cst 0x7f9b115051b0 -128> max <integer_cst 0x7f9b11505198 127> context <translation_unit_decl 0x7f9b119e3168 ./benchmarks/tmux/leak_1/tmux_leak_1.c>
            pointer_to_this <pointer_type 0x7f9b11502930>>
        public unsigned DI
        size <integer_cst 0x7f9b119d8be8 constant 64>
        unit size <integer_cst 0x7f9b119d8c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality context <translation_unit_decl 0x7f9b119e3168 ./benchmarks/tmux/leak_1/tmux_leak_1.c>
        pointer_to_this <pointer_type 0x7f9b1150e000>>
    var <var_decl 0x7f9b1154f5a0 msg2>
    def_stmt msg2_64 = malloc (_63);
    version 64
    ptr-info 0x7f9b11532ab0>
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_101 = VDEF <.MEM_100>
free (_85);
./benchmarks/tmux/leak_1/tmux_leak_1.c:185:2: warning: use location
  free(msg);
  ^
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_102 = VDEF <.MEM_101>
free (msg2_64);
./benchmarks/tmux/leak_1/tmux_leak_1.c:186:2: warning: use location
  free(msg2);
  ^
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_108 = VDEF <.MEM_94>
free (_57);
./benchmarks/tmux/leak_1/tmux_leak_1.c:158:2: warning: use location
  free(msg);
  ^

 ================== Start Use after free Check ================== 

============================================================
# .MEM_102 = VDEF <.MEM_101>
free (msg2_64);
./benchmarks/tmux/leak_1/tmux_leak_1.c:186:2: warning: Use after free error!: free location 
  free(msg2);
  ^
ptr2_80 = PHI <msg2_64(2), ptr2_90(12)>
lto1: warning: use location

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_101 = VDEF <.MEM_100>
free (_85);
./benchmarks/tmux/leak_1/tmux_leak_1.c:185:2: warning: Use after free error!: free location 
  free(msg);
  ^
ptr2_80 = PHI <msg2_64(2), ptr2_90(12)>
lto1: warning: use location

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_102 = VDEF <.MEM_101>
free (msg2_64);
./benchmarks/tmux/leak_1/tmux_leak_1.c:186:2: warning: Use after free error!: free location 
  free(msg2);
  ^
ptr2_80 = PHI <msg2_64(2), ptr2_90(12)>
lto1: warning: use location

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_108 = VDEF <.MEM_94>
free (_57);
./benchmarks/tmux/leak_1/tmux_leak_1.c:158:2: warning: Use after free error!: free location 
  free(msg);
  ^
ptr2_80 = PHI <msg2_64(2), ptr2_90(12)>
lto1: warning: use location

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
# .MEM_102 = VDEF <.MEM_101>
free (msg2_64);
./benchmarks/tmux/leak_1/tmux_leak_1.c:186:2: warning: Use after free error!: free location 
  free(msg2);
  ^
ptr2_90 = PHI <ptr2_80(10), ptr2_82(11)>
lto1: warning: use location

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_101 = VDEF <.MEM_100>
free (_85);
./benchmarks/tmux/leak_1/tmux_leak_1.c:185:2: warning: Use after free error!: free location 
  free(msg);
  ^
ptr2_90 = PHI <ptr2_80(10), ptr2_82(11)>
lto1: warning: use location

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_102 = VDEF <.MEM_101>
free (msg2_64);
./benchmarks/tmux/leak_1/tmux_leak_1.c:186:2: warning: Use after free error!: free location 
  free(msg2);
  ^
ptr2_90 = PHI <ptr2_80(10), ptr2_82(11)>
lto1: warning: use location

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_108 = VDEF <.MEM_94>
free (_57);
./benchmarks/tmux/leak_1/tmux_leak_1.c:158:2: warning: Use after free error!: free location 
  free(msg);
  ^
ptr2_90 = PHI <ptr2_80(10), ptr2_82(11)>
lto1: warning: use location

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:3 [0m

======================================================================

======================================================================
[40;31m   need check branch because multiple direction varible[0m

======================================================================


dot graph START

======================================================================
 <addr_expr 0x7f9b114f6e20
    type <pointer_type 0x7f9b11511a80
        type <record_type 0x7f9b115119d8 screen BLK
            size <integer_cst 0x7f9b11505438 constant 1088>
            unit size <integer_cst 0x7f9b11505450 constant 136>
            align 64 symtab 0 alias set -1 canonical type 0x7f9b115119d8 fields <field_decl 0x7f9b11513980 title> context <translation_unit_decl 0x7f9b119e3168 ./benchmarks/tmux/leak_1/tmux_leak_1.c>
            pointer_to_this <pointer_type 0x7f9b11511a80> chain <type_decl 0x7f9b11513a18 D.4157>>
        unsigned DI
        size <integer_cst 0x7f9b119d8be8 constant 64>
        unit size <integer_cst 0x7f9b119d8c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality>
   
    arg 0 <var_decl 0x7f9b1153ca20 old type <record_type 0x7f9b115119d8 screen>
        addressable used BLK file ./benchmarks/tmux/leak_1/tmux_leak_1.c line 216 col 18 size <integer_cst 0x7f9b11505438 1088> unit size <integer_cst 0x7f9b11505450 136>
        align 128 context <function_decl 0x7f9b11503b00 main> abstract_origin <var_decl 0x7f9b1276db40 old>>
    ./benchmarks/tmux/leak_1/tmux_leak_1.c:218:9 start: ./benchmarks/tmux/leak_1/tmux_leak_1.c:218:9 finish: ./benchmarks/tmux/leak_1/tmux_leak_1.c:218:9>

 ================== trace ptable================== 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr--------
this other function -----------

======================================================================
[40;35m  	Looserules free count:0 [0m

======================================================================

======================================================================
[40;31m 	Can't find this fucntion in Pointer table [0m
[40;31m 	Possiable no other stmt relate with this stmt [0m

======================================================================

dot graph START

======================================================================
 <ssa_name 0x7f9b1153f240
    type <pointer_type 0x7f9b11502d20
        type <integer_type 0x7f9b11502c78 char readonly string-flag QI
            size <integer_cst 0x7f9b119d8cd8 constant 8>
            unit size <integer_cst 0x7f9b119d8cf0 constant 1>
            align 8 symtab 0 alias set -1 canonical type 0x7f9b119ec3f0 precision 8 min <integer_cst 0x7f9b115051b0 -128> max <integer_cst 0x7f9b11505198 127> context <translation_unit_decl 0x7f9b119e3168 ./benchmarks/tmux/leak_1/tmux_leak_1.c>
            pointer_to_this <pointer_type 0x7f9b11502d20>>
        unsigned DI
        size <integer_cst 0x7f9b119d8be8 constant 64>
        unit size <integer_cst 0x7f9b119d8c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality>
    var <var_decl 0x7f9b1153c7e0 fmt>
    def_stmt GIMPLE_NOP
    version 7
    ptr-info 0x7f9b11532948>
GIMPLE_NOP

 ================== trace ptable================== 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr--------
this other function -----------
 
 Start check Pointer Collect  

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# VUSE <.MEM_96>
_8 = strlen (fmt_7(D));
bb index := 2
# VUSE <.MEM_11>
return i_7;
./benchmarks/tmux/leak_1/tmux_leak_1.c:96:9: warning: use location
  return i;
         ^
beacuse in succ := 5 have return or exit
gimple stmt in succ := 2 ,possiable got to succ := 5

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# VUSE <.MEM_96>
_8 = strlen (fmt_7(D));
bb index := 2
# VUSE <.MEM_5>
return 0;
lto1: warning: use location
beacuse in succ := 40 have return or exit
gimple stmt in succ := 2 ,possiable got to succ := 40

======================================================================
_8 = strlen (fmt_7(D));
./benchmarks/tmux/leak_1/tmux_leak_1.c:221:8: warning: use location
  out = malloc(strlen(fmt));                      /* allocation site */
        ^
this stmt is child function---strlen-----

 ================== trace ================== 
 <ssa_name 0x7f9b1153f240
    type <pointer_type 0x7f9b11502d20
        type <integer_type 0x7f9b11502c78 char readonly string-flag QI
            size <integer_cst 0x7f9b119d8cd8 constant 8>
            unit size <integer_cst 0x7f9b119d8cf0 constant 1>
            align 8 symtab 0 alias set -1 canonical type 0x7f9b119ec3f0 precision 8 min <integer_cst 0x7f9b115051b0 -128> max <integer_cst 0x7f9b11505198 127> context <translation_unit_decl 0x7f9b119e3168 ./benchmarks/tmux/leak_1/tmux_leak_1.c>
            pointer_to_this <pointer_type 0x7f9b11502d20>>
        unsigned DI
        size <integer_cst 0x7f9b119d8be8 constant 64>
        unit size <integer_cst 0x7f9b119d8c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality>
    var <var_decl 0x7f9b1153c7e0 fmt>
    def_stmt GIMPLE_NOP
    version 7
    ptr-info 0x7f9b11532948>
trace fucntion name:strlen 

 ================== trace ================== 
trace fucntion free:0 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_97 = VDEF <.MEM_96>
out_9 = malloc (_8);
bb index := 2
# VUSE <.MEM_11>
return i_7;
./benchmarks/tmux/leak_1/tmux_leak_1.c:96:9: warning: use location
  return i;
         ^
beacuse in succ := 5 have return or exit
gimple stmt in succ := 2 ,possiable got to succ := 5

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_97 = VDEF <.MEM_96>
out_9 = malloc (_8);
bb index := 2
# VUSE <.MEM_5>
return 0;
lto1: warning: use location
beacuse in succ := 40 have return or exit
gimple stmt in succ := 2 ,possiable got to succ := 40

======================================================================
out_9 = malloc (_8);
./benchmarks/tmux/leak_1/tmux_leak_1.c:221:6: warning: use location
  out = malloc(strlen(fmt));                      /* allocation site */
      ^
this stmt is child function---malloc-----

 ================== trace ================== 
 <ssa_name 0x7f9b1153f240
    type <pointer_type 0x7f9b11502d20
        type <integer_type 0x7f9b11502c78 char readonly string-flag QI
            size <integer_cst 0x7f9b119d8cd8 constant 8>
            unit size <integer_cst 0x7f9b119d8cf0 constant 1>
            align 8 symtab 0 alias set -1 canonical type 0x7f9b119ec3f0 precision 8 min <integer_cst 0x7f9b115051b0 -128> max <integer_cst 0x7f9b11505198 127> context <translation_unit_decl 0x7f9b119e3168 ./benchmarks/tmux/leak_1/tmux_leak_1.c>
            pointer_to_this <pointer_type 0x7f9b11502d20>>
        unsigned DI
        size <integer_cst 0x7f9b119d8be8 constant 64>
        unit size <integer_cst 0x7f9b119d8c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality>
    var <var_decl 0x7f9b1153c7e0 fmt>
    def_stmt GIMPLE_NOP
    version 7
    ptr-info 0x7f9b11532948>
trace fucntion name:malloc 

 ================== trace ================== 
trace fucntion free:0 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_98 = VDEF <.MEM_97>
xvasprintf (&msg, "%s", out_9);
bb index := 2
# VUSE <.MEM_11>
return i_7;
./benchmarks/tmux/leak_1/tmux_leak_1.c:96:9: warning: use location
  return i;
         ^
beacuse in succ := 5 have return or exit
gimple stmt in succ := 2 ,possiable got to succ := 5

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_98 = VDEF <.MEM_97>
xvasprintf (&msg, "%s", out_9);
bb index := 2
# VUSE <.MEM_5>
return 0;
lto1: warning: use location
beacuse in succ := 40 have return or exit
gimple stmt in succ := 2 ,possiable got to succ := 40

======================================================================
xvasprintf (&msg, "%s", out_9);
./benchmarks/tmux/leak_1/tmux_leak_1.c:168:2: warning: use location
  xvasprintf(&msg, fmt, ap);
  ^
this stmt is child function---xvasprintf-----

 ================== trace ================== 
 <ssa_name 0x7f9b1153f240
    type <pointer_type 0x7f9b11502d20
        type <integer_type 0x7f9b11502c78 char readonly string-flag QI
            size <integer_cst 0x7f9b119d8cd8 constant 8>
            unit size <integer_cst 0x7f9b119d8cf0 constant 1>
            align 8 symtab 0 alias set -1 canonical type 0x7f9b119ec3f0 precision 8 min <integer_cst 0x7f9b115051b0 -128> max <integer_cst 0x7f9b11505198 127> context <translation_unit_decl 0x7f9b119e3168 ./benchmarks/tmux/leak_1/tmux_leak_1.c>
            pointer_to_this <pointer_type 0x7f9b11502d20>>
        unsigned DI
        size <integer_cst 0x7f9b119d8be8 constant 64>
        unit size <integer_cst 0x7f9b119d8c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality>
    var <var_decl 0x7f9b1153c7e0 fmt>
    def_stmt GIMPLE_NOP
    version 7
    ptr-info 0x7f9b11532948>
trace fucntion name:xvasprintf 
[40;44m =======trace_function_path xvasprintf  function_call count: 3 level :0========  [0m
[40;36m ======= node_fun:xvasprintf========= [0m
[40;36m ======= find relate stmt with fmt ========= [0m
[40;36m ======= relate stmt argument:fmt ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:exit========= [0m
[40;46m =======add node_fun stack:exit========= [0m
[40;42m =======pre add _ fucntion:__printf_chk========= [0m
[40;46m =======add node_fun stack:__printf_chk========= [0m
[40;42m =======pre add _ fucntion:vasprintf========= [0m
[40;46m =======add node_fun stack:vasprintf========= [0m

 ================== trace ================== 
trace fucntion free:0 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_106 = VDEF <.MEM_105>
xvasprintf (&msg, "%s", out_9);
bb index := 14
# VUSE <.MEM_11>
return i_7;
./benchmarks/tmux/leak_1/tmux_leak_1.c:96:9: warning: use location
  return i;
         ^
beacuse in succ := 5 have return or exit
gimple stmt in succ := 14 ,possiable got to succ := 5

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_106 = VDEF <.MEM_105>
xvasprintf (&msg, "%s", out_9);
bb index := 14
# VUSE <.MEM_11>
return i_7;
./benchmarks/tmux/leak_1/tmux_leak_1.c:96:9: warning: use location
beacuse in succ := 5 have return or exit
gimple stmt in succ := 14 ,possiable got to succ := 5

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_106 = VDEF <.MEM_105>
xvasprintf (&msg, "%s", out_9);
bb index := 14
# VUSE <.MEM_5>
return 0;
lto1: warning: use location
beacuse in succ := 40 have return or exit
gimple stmt in succ := 14 ,possiable got to succ := 40

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_106 = VDEF <.MEM_105>
xvasprintf (&msg, "%s", out_9);
bb index := 14
# VUSE <.MEM_5>
return 0;
lto1: warning: use location
beacuse in succ := 40 have return or exit
gimple stmt in succ := 14 ,possiable got to succ := 40

======================================================================
xvasprintf (&msg, "%s", out_9);
./benchmarks/tmux/leak_1/tmux_leak_1.c:113:2: warning: use location
  xvasprintf(&msg, fmt, ap);
  ^
this stmt is child function---xvasprintf-----

 ================== trace ================== 
 <ssa_name 0x7f9b1153f240
    type <pointer_type 0x7f9b11502d20
        type <integer_type 0x7f9b11502c78 char readonly string-flag QI
            size <integer_cst 0x7f9b119d8cd8 constant 8>
            unit size <integer_cst 0x7f9b119d8cf0 constant 1>
            align 8 symtab 0 alias set -1 canonical type 0x7f9b119ec3f0 precision 8 min <integer_cst 0x7f9b115051b0 -128> max <integer_cst 0x7f9b11505198 127> context <translation_unit_decl 0x7f9b119e3168 ./benchmarks/tmux/leak_1/tmux_leak_1.c>
            pointer_to_this <pointer_type 0x7f9b11502d20>>
        unsigned DI
        size <integer_cst 0x7f9b119d8be8 constant 64>
        unit size <integer_cst 0x7f9b119d8c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality>
    var <var_decl 0x7f9b1153c7e0 fmt>
    def_stmt GIMPLE_NOP
    version 7
    ptr-info 0x7f9b11532948>
trace fucntion name:xvasprintf 
[40;44m =======trace_function_path xvasprintf  function_call count: 3 level :0========  [0m
[40;36m ======= node_fun:xvasprintf========= [0m
[40;36m ======= find relate stmt with fmt ========= [0m
[40;36m ======= relate stmt argument:fmt ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:exit========= [0m
[40;46m =======add node_fun stack:exit========= [0m
[40;42m =======pre add _ fucntion:__printf_chk========= [0m
[40;46m =======add node_fun stack:__printf_chk========= [0m
[40;42m =======pre add _ fucntion:vasprintf========= [0m
[40;46m =======add node_fun stack:vasprintf========= [0m

 ================== trace ================== 
trace fucntion free:0 

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7f9b1153f240
    type <pointer_type 0x7f9b11502d20
        type <integer_type 0x7f9b11502c78 char readonly string-flag QI
            size <integer_cst 0x7f9b119d8cd8 constant 8>
            unit size <integer_cst 0x7f9b119d8cf0 constant 1>
            align 8 symtab 0 alias set -1 canonical type 0x7f9b119ec3f0 precision 8 min <integer_cst 0x7f9b115051b0 -128> max <integer_cst 0x7f9b11505198 127> context <translation_unit_decl 0x7f9b119e3168 ./benchmarks/tmux/leak_1/tmux_leak_1.c>
            pointer_to_this <pointer_type 0x7f9b11502d20>>
        unsigned DI
        size <integer_cst 0x7f9b119d8be8 constant 64>
        unit size <integer_cst 0x7f9b119d8c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality>
    var <var_decl 0x7f9b1153c7e0 fmt>
    def_stmt GIMPLE_NOP
    version 7
    ptr-info 0x7f9b11532948>

 ================== Start Use after free Check ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:0 [0m

======================================================================

======================================================================
[40;31m    no free stmt possible memory leak [0m

======================================================================

dot graph START

======================================================================
 <ssa_name 0x7f9b1153f288
    type <integer_type 0x7f9b119ec7e0 long unsigned int public unsigned DI
        size <integer_cst 0x7f9b119d8be8 constant 64>
        unit size <integer_cst 0x7f9b119d8c00 constant 8>
        align 64 symtab 0 alias set -1 canonical type 0x7f9b119ec738 precision 64 min <integer_cst 0x7f9b119d8eb8 0> max <integer_cst 0x7f9b119da500 18446744073709551615>
        pointer_to_this <pointer_type 0x7f9b119f89d8>>
   
    def_stmt _8 = strlen (fmt_7(D));
    version 8>
# VUSE <.MEM_96>
_8 = strlen (fmt_7(D));

 ================== trace ptable================== 
trace fucntion name:strlen 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr---strlen-----
this other function ------strlen-----
 
 Start check Pointer Collect  

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# VUSE <.MEM_96>
_8 = strlen (fmt_7(D));
bb index := 2
# VUSE <.MEM_11>
return i_7;
./benchmarks/tmux/leak_1/tmux_leak_1.c:96:9: warning: use location
  return i;
         ^
beacuse in succ := 5 have return or exit
gimple stmt in succ := 2 ,possiable got to succ := 5

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# VUSE <.MEM_96>
_8 = strlen (fmt_7(D));
bb index := 2
# VUSE <.MEM_5>
return 0;
lto1: warning: use location
beacuse in succ := 40 have return or exit
gimple stmt in succ := 2 ,possiable got to succ := 40

======================================================================
_8 = strlen (fmt_7(D));
./benchmarks/tmux/leak_1/tmux_leak_1.c:221:8: warning: use location
  out = malloc(strlen(fmt));                      /* allocation site */
        ^
this stmt is child function---strlen-----

 ================== trace ================== 
 <ssa_name 0x7f9b1153f288
    type <integer_type 0x7f9b119ec7e0 long unsigned int public unsigned DI
        size <integer_cst 0x7f9b119d8be8 constant 64>
        unit size <integer_cst 0x7f9b119d8c00 constant 8>
        align 64 symtab 0 alias set -1 canonical type 0x7f9b119ec738 precision 64 min <integer_cst 0x7f9b119d8eb8 0> max <integer_cst 0x7f9b119da500 18446744073709551615>
        pointer_to_this <pointer_type 0x7f9b119f89d8>>
   
    def_stmt _8 = strlen (fmt_7(D));
    version 8>
trace fucntion name:strlen 

 ================== trace ================== 
trace fucntion free:0 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_97 = VDEF <.MEM_96>
out_9 = malloc (_8);
bb index := 2
# VUSE <.MEM_11>
return i_7;
./benchmarks/tmux/leak_1/tmux_leak_1.c:96:9: warning: use location
  return i;
         ^
beacuse in succ := 5 have return or exit
gimple stmt in succ := 2 ,possiable got to succ := 5

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_97 = VDEF <.MEM_96>
out_9 = malloc (_8);
bb index := 2
# VUSE <.MEM_5>
return 0;
lto1: warning: use location
beacuse in succ := 40 have return or exit
gimple stmt in succ := 2 ,possiable got to succ := 40

======================================================================
out_9 = malloc (_8);
./benchmarks/tmux/leak_1/tmux_leak_1.c:221:6: warning: use location
  out = malloc(strlen(fmt));                      /* allocation site */
      ^
this stmt is child function---malloc-----

 ================== trace ================== 
 <ssa_name 0x7f9b1153f288
    type <integer_type 0x7f9b119ec7e0 long unsigned int public unsigned DI
        size <integer_cst 0x7f9b119d8be8 constant 64>
        unit size <integer_cst 0x7f9b119d8c00 constant 8>
        align 64 symtab 0 alias set -1 canonical type 0x7f9b119ec738 precision 64 min <integer_cst 0x7f9b119d8eb8 0> max <integer_cst 0x7f9b119da500 18446744073709551615>
        pointer_to_this <pointer_type 0x7f9b119f89d8>>
   
    def_stmt _8 = strlen (fmt_7(D));
    version 8>
trace fucntion name:malloc 

 ================== trace ================== 
trace fucntion free:0 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_98 = VDEF <.MEM_97>
xvasprintf (&msg, "%s", out_9);
bb index := 2
# VUSE <.MEM_11>
return i_7;
./benchmarks/tmux/leak_1/tmux_leak_1.c:96:9: warning: use location
  return i;
         ^
beacuse in succ := 5 have return or exit
gimple stmt in succ := 2 ,possiable got to succ := 5

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_98 = VDEF <.MEM_97>
xvasprintf (&msg, "%s", out_9);
bb index := 2
# VUSE <.MEM_5>
return 0;
lto1: warning: use location
beacuse in succ := 40 have return or exit
gimple stmt in succ := 2 ,possiable got to succ := 40

======================================================================
xvasprintf (&msg, "%s", out_9);
./benchmarks/tmux/leak_1/tmux_leak_1.c:168:2: warning: use location
  xvasprintf(&msg, fmt, ap);
  ^
this stmt is child function---xvasprintf-----

 ================== trace ================== 
 <ssa_name 0x7f9b1153f288
    type <integer_type 0x7f9b119ec7e0 long unsigned int public unsigned DI
        size <integer_cst 0x7f9b119d8be8 constant 64>
        unit size <integer_cst 0x7f9b119d8c00 constant 8>
        align 64 symtab 0 alias set -1 canonical type 0x7f9b119ec738 precision 64 min <integer_cst 0x7f9b119d8eb8 0> max <integer_cst 0x7f9b119da500 18446744073709551615>
        pointer_to_this <pointer_type 0x7f9b119f89d8>>
   
    def_stmt _8 = strlen (fmt_7(D));
    version 8>
trace fucntion name:xvasprintf 
[40;44m =======trace_function_path xvasprintf  function_call count: 3 level :0========  [0m
[40;42m =======pre add _ fucntion:exit========= [0m
[40;46m =======add node_fun stack:exit========= [0m
[40;42m =======pre add _ fucntion:__printf_chk========= [0m
[40;46m =======add node_fun stack:__printf_chk========= [0m
[40;42m =======pre add _ fucntion:vasprintf========= [0m
[40;46m =======add node_fun stack:vasprintf========= [0m

 ================== trace ================== 
trace fucntion free:0 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_106 = VDEF <.MEM_105>
xvasprintf (&msg, "%s", out_9);
bb index := 14
# VUSE <.MEM_11>
return i_7;
./benchmarks/tmux/leak_1/tmux_leak_1.c:96:9: warning: use location
  return i;
         ^
beacuse in succ := 5 have return or exit
gimple stmt in succ := 14 ,possiable got to succ := 5

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_106 = VDEF <.MEM_105>
xvasprintf (&msg, "%s", out_9);
bb index := 14
# VUSE <.MEM_11>
return i_7;
./benchmarks/tmux/leak_1/tmux_leak_1.c:96:9: warning: use location
beacuse in succ := 5 have return or exit
gimple stmt in succ := 14 ,possiable got to succ := 5

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_106 = VDEF <.MEM_105>
xvasprintf (&msg, "%s", out_9);
bb index := 14
# VUSE <.MEM_5>
return 0;
lto1: warning: use location
beacuse in succ := 40 have return or exit
gimple stmt in succ := 14 ,possiable got to succ := 40

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_106 = VDEF <.MEM_105>
xvasprintf (&msg, "%s", out_9);
bb index := 14
# VUSE <.MEM_5>
return 0;
lto1: warning: use location
beacuse in succ := 40 have return or exit
gimple stmt in succ := 14 ,possiable got to succ := 40

======================================================================
xvasprintf (&msg, "%s", out_9);
./benchmarks/tmux/leak_1/tmux_leak_1.c:113:2: warning: use location
  xvasprintf(&msg, fmt, ap);
  ^
this stmt is child function---xvasprintf-----

 ================== trace ================== 
 <ssa_name 0x7f9b1153f288
    type <integer_type 0x7f9b119ec7e0 long unsigned int public unsigned DI
        size <integer_cst 0x7f9b119d8be8 constant 64>
        unit size <integer_cst 0x7f9b119d8c00 constant 8>
        align 64 symtab 0 alias set -1 canonical type 0x7f9b119ec738 precision 64 min <integer_cst 0x7f9b119d8eb8 0> max <integer_cst 0x7f9b119da500 18446744073709551615>
        pointer_to_this <pointer_type 0x7f9b119f89d8>>
   
    def_stmt _8 = strlen (fmt_7(D));
    version 8>
trace fucntion name:xvasprintf 
[40;44m =======trace_function_path xvasprintf  function_call count: 3 level :0========  [0m
[40;42m =======pre add _ fucntion:exit========= [0m
[40;46m =======add node_fun stack:exit========= [0m
[40;42m =======pre add _ fucntion:__printf_chk========= [0m
[40;46m =======add node_fun stack:__printf_chk========= [0m
[40;42m =======pre add _ fucntion:vasprintf========= [0m
[40;46m =======add node_fun stack:vasprintf========= [0m

 ================== trace ================== 
trace fucntion free:0 

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7f9b1153f288
    type <integer_type 0x7f9b119ec7e0 long unsigned int public unsigned DI
        size <integer_cst 0x7f9b119d8be8 constant 64>
        unit size <integer_cst 0x7f9b119d8c00 constant 8>
        align 64 symtab 0 alias set -1 canonical type 0x7f9b119ec738 precision 64 min <integer_cst 0x7f9b119d8eb8 0> max <integer_cst 0x7f9b119da500 18446744073709551615>
        pointer_to_this <pointer_type 0x7f9b119f89d8>>
   
    def_stmt _8 = strlen (fmt_7(D));
    version 8>
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_101 = VDEF <.MEM_100>
free (_85);
./benchmarks/tmux/leak_1/tmux_leak_1.c:185:2: warning: use location
  free(msg);
  ^
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_102 = VDEF <.MEM_101>
free (msg2_64);
./benchmarks/tmux/leak_1/tmux_leak_1.c:186:2: warning: use location
  free(msg2);
  ^
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_108 = VDEF <.MEM_94>
free (_57);
./benchmarks/tmux/leak_1/tmux_leak_1.c:158:2: warning: use location
  free(msg);
  ^

 ================== Start Use after free Check ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_101 = VDEF <.MEM_100>
free (_85);
./benchmarks/tmux/leak_1/tmux_leak_1.c:185:2: warning: Use after free error!: free location 
  free(msg);
  ^
# .MEM_106 = VDEF <.MEM_105>
xvasprintf (&msg, "%s", out_9);
./benchmarks/tmux/leak_1/tmux_leak_1.c:113:2: warning: use location
  xvasprintf(&msg, fmt, ap);
  ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_102 = VDEF <.MEM_101>
free (msg2_64);
./benchmarks/tmux/leak_1/tmux_leak_1.c:186:2: warning: Use after free error!: free location 
  free(msg2);
  ^
# .MEM_106 = VDEF <.MEM_105>
xvasprintf (&msg, "%s", out_9);
./benchmarks/tmux/leak_1/tmux_leak_1.c:113:2: warning: use location
  xvasprintf(&msg, fmt, ap);
  ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:3 [0m

======================================================================

======================================================================
[40;31m    no free stmt possible memory leak [0m

======================================================================

dot graph START

======================================================================
 <addr_expr 0x7f9b11541860
    type <pointer_type 0x7f9b1150e000
        type <pointer_type 0x7f9b11502930 type <integer_type 0x7f9b11502888 char>
            public unsigned DI
            size <integer_cst 0x7f9b119d8be8 constant 64>
            unit size <integer_cst 0x7f9b119d8c00 constant 8>
            align 64 symtab 0 alias set -1 structural equality context <translation_unit_decl 0x7f9b119e3168 ./benchmarks/tmux/leak_1/tmux_leak_1.c>
            pointer_to_this <pointer_type 0x7f9b1150e000>>
        public unsigned DI size <integer_cst 0x7f9b119d8be8 64> unit size <integer_cst 0x7f9b119d8c00 8>
        align 64 symtab 0 alias set -1 structural equality>
   
    arg 0 <var_decl 0x7f9b1154f510 msg type <pointer_type 0x7f9b11502930>
        addressable used unsigned DI file ./benchmarks/tmux/leak_1/tmux_leak_1.c line 165 col 10 size <integer_cst 0x7f9b119d8be8 64> unit size <integer_cst 0x7f9b119d8c00 8>
        align 64 context <function_decl 0x7f9b11503b00 main> abstract_origin <var_decl 0x7f9b1154f120 msg>
        chain <var_decl 0x7f9b1154f5a0 msg2 type <pointer_type 0x7f9b11502930>
            used unsigned DI file ./benchmarks/tmux/leak_1/tmux_leak_1.c line 165 col 16 size <integer_cst 0x7f9b119d8be8 64> unit size <integer_cst 0x7f9b119d8c00 8>
            align 64 context <function_decl 0x7f9b11503b00 main> abstract_origin <var_decl 0x7f9b1154f090 msg2> chain <var_decl 0x7f9b1154f630 ptr>>>
    ./benchmarks/tmux/leak_1/tmux_leak_1.c:168:2 start: ./benchmarks/tmux/leak_1/tmux_leak_1.c:168:2 finish: ./benchmarks/tmux/leak_1/tmux_leak_1.c:168:2>

 ================== trace ptable================== 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr--------
this other function -----------

======================================================================
[40;35m  	Looserules free count:0 [0m

======================================================================

======================================================================
[40;31m 	Can't find this fucntion in Pointer table [0m
[40;31m 	Possiable no other stmt relate with this stmt [0m

======================================================================

dot graph START

======================================================================
 <ssa_name 0x7f9b1154cf78
    type <pointer_type 0x7f9b11502930
        type <integer_type 0x7f9b11502888 char public string-flag QI
            size <integer_cst 0x7f9b119d8cd8 constant 8>
            unit size <integer_cst 0x7f9b119d8cf0 constant 1>
            align 8 symtab 0 alias set -1 canonical type 0x7f9b119ec3f0 precision 8 min <integer_cst 0x7f9b115051b0 -128> max <integer_cst 0x7f9b11505198 127> context <translation_unit_decl 0x7f9b119e3168 ./benchmarks/tmux/leak_1/tmux_leak_1.c>
            pointer_to_this <pointer_type 0x7f9b11502930>>
        public unsigned DI
        size <integer_cst 0x7f9b119d8be8 constant 64>
        unit size <integer_cst 0x7f9b119d8c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality context <translation_unit_decl 0x7f9b119e3168 ./benchmarks/tmux/leak_1/tmux_leak_1.c>
        pointer_to_this <pointer_type 0x7f9b1150e000>>
   
    def_stmt _61 = msg;
    version 61
    ptr-info 0x7f9b11532a98>
# VUSE <.MEM_98>
_61 = msg;

 ================== trace ptable================== 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr--------
this other function -----------
 
 Start check Pointer Collect  

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# VUSE <.MEM_98>
_62 = strlen (_61);
bb index := 2
# VUSE <.MEM_11>
return i_7;
./benchmarks/tmux/leak_1/tmux_leak_1.c:96:9: warning: use location
  return i;
         ^
beacuse in succ := 5 have return or exit
gimple stmt in succ := 2 ,possiable got to succ := 5

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# VUSE <.MEM_98>
_62 = strlen (_61);
bb index := 2
# VUSE <.MEM_5>
return 0;
lto1: warning: use location
beacuse in succ := 40 have return or exit
gimple stmt in succ := 2 ,possiable got to succ := 40

======================================================================
_62 = strlen (_61);
./benchmarks/tmux/leak_1/tmux_leak_1.c:169:9: warning: use location
  msg2 = xmalloc(strlen(msg) + 1);
         ^
this stmt is child function---strlen-----

 ================== trace ================== 
 <ssa_name 0x7f9b1154cf78
    type <pointer_type 0x7f9b11502930
        type <integer_type 0x7f9b11502888 char public string-flag QI
            size <integer_cst 0x7f9b119d8cd8 constant 8>
            unit size <integer_cst 0x7f9b119d8cf0 constant 1>
            align 8 symtab 0 alias set -1 canonical type 0x7f9b119ec3f0 precision 8 min <integer_cst 0x7f9b115051b0 -128> max <integer_cst 0x7f9b11505198 127> context <translation_unit_decl 0x7f9b119e3168 ./benchmarks/tmux/leak_1/tmux_leak_1.c>
            pointer_to_this <pointer_type 0x7f9b11502930>>
        public unsigned DI
        size <integer_cst 0x7f9b119d8be8 constant 64>
        unit size <integer_cst 0x7f9b119d8c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality context <translation_unit_decl 0x7f9b119e3168 ./benchmarks/tmux/leak_1/tmux_leak_1.c>
        pointer_to_this <pointer_type 0x7f9b1150e000>>
   
    def_stmt _61 = msg;
    version 61
    ptr-info 0x7f9b11532a98>
trace fucntion name:strlen 

 ================== trace ================== 
trace fucntion free:0 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# VUSE <.MEM_98>
_62 = strlen (_61);
bb index := 2
# VUSE <.MEM_11>
return i_7;
./benchmarks/tmux/leak_1/tmux_leak_1.c:96:9: warning: use location
  return i;
         ^
beacuse in succ := 5 have return or exit
gimple stmt in succ := 2 ,possiable got to succ := 5

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# VUSE <.MEM_98>
_62 = strlen (_61);
bb index := 2
# VUSE <.MEM_5>
return 0;
lto1: warning: use location
beacuse in succ := 40 have return or exit
gimple stmt in succ := 2 ,possiable got to succ := 40

======================================================================
_62 = strlen (_61);
./benchmarks/tmux/leak_1/tmux_leak_1.c:169:9: warning: use location
  msg2 = xmalloc(strlen(msg) + 1);
         ^
this stmt is child function---strlen-----

 ================== trace ================== 
 <ssa_name 0x7f9b1154cf78
    type <pointer_type 0x7f9b11502930
        type <integer_type 0x7f9b11502888 char public string-flag QI
            size <integer_cst 0x7f9b119d8cd8 constant 8>
            unit size <integer_cst 0x7f9b119d8cf0 constant 1>
            align 8 symtab 0 alias set -1 canonical type 0x7f9b119ec3f0 precision 8 min <integer_cst 0x7f9b115051b0 -128> max <integer_cst 0x7f9b11505198 127> context <translation_unit_decl 0x7f9b119e3168 ./benchmarks/tmux/leak_1/tmux_leak_1.c>
            pointer_to_this <pointer_type 0x7f9b11502930>>
        public unsigned DI
        size <integer_cst 0x7f9b119d8be8 constant 64>
        unit size <integer_cst 0x7f9b119d8c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality context <translation_unit_decl 0x7f9b119e3168 ./benchmarks/tmux/leak_1/tmux_leak_1.c>
        pointer_to_this <pointer_type 0x7f9b1150e000>>
   
    def_stmt _61 = msg;
    version 61
    ptr-info 0x7f9b11532a98>
trace fucntion name:strlen 

 ================== trace ================== 
trace fucntion free:0 

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7f9b1154cf78
    type <pointer_type 0x7f9b11502930
        type <integer_type 0x7f9b11502888 char public string-flag QI
            size <integer_cst 0x7f9b119d8cd8 constant 8>
            unit size <integer_cst 0x7f9b119d8cf0 constant 1>
            align 8 symtab 0 alias set -1 canonical type 0x7f9b119ec3f0 precision 8 min <integer_cst 0x7f9b115051b0 -128> max <integer_cst 0x7f9b11505198 127> context <translation_unit_decl 0x7f9b119e3168 ./benchmarks/tmux/leak_1/tmux_leak_1.c>
            pointer_to_this <pointer_type 0x7f9b11502930>>
        public unsigned DI
        size <integer_cst 0x7f9b119d8be8 constant 64>
        unit size <integer_cst 0x7f9b119d8c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality context <translation_unit_decl 0x7f9b119e3168 ./benchmarks/tmux/leak_1/tmux_leak_1.c>
        pointer_to_this <pointer_type 0x7f9b1150e000>>
   
    def_stmt _61 = msg;
    version 61
    ptr-info 0x7f9b11532a98>
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_101 = VDEF <.MEM_100>
free (_85);
./benchmarks/tmux/leak_1/tmux_leak_1.c:185:2: warning: use location
  free(msg);
  ^
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_102 = VDEF <.MEM_101>
free (msg2_64);
./benchmarks/tmux/leak_1/tmux_leak_1.c:186:2: warning: use location
  free(msg2);
  ^
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_108 = VDEF <.MEM_94>
free (_57);
./benchmarks/tmux/leak_1/tmux_leak_1.c:158:2: warning: use location
  free(msg);
  ^

 ================== Start Use after free Check ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:3 [0m

======================================================================

======================================================================
[40;31m    no free stmt possible memory leak [0m

======================================================================

dot graph START

======================================================================
 <ssa_name 0x7f9b11553000
    type <integer_type 0x7f9b119ec7e0 long unsigned int public unsigned DI
        size <integer_cst 0x7f9b119d8be8 constant 64>
        unit size <integer_cst 0x7f9b119d8c00 constant 8>
        align 64 symtab 0 alias set -1 canonical type 0x7f9b119ec738 precision 64 min <integer_cst 0x7f9b119d8eb8 0> max <integer_cst 0x7f9b119da500 18446744073709551615>
        pointer_to_this <pointer_type 0x7f9b119f89d8>>
   
    def_stmt _63 = _62 + 1;
    version 63>
_63 = _62 + 1;

 ================== trace ptable================== 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr--------
this other function -----------
 
 Start check Pointer Collect  

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_99 = VDEF <.MEM_98>
msg2_64 = malloc (_63);
bb index := 2
# VUSE <.MEM_11>
return i_7;
./benchmarks/tmux/leak_1/tmux_leak_1.c:96:9: warning: use location
  return i;
         ^
beacuse in succ := 5 have return or exit
gimple stmt in succ := 2 ,possiable got to succ := 5

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_99 = VDEF <.MEM_98>
msg2_64 = malloc (_63);
bb index := 2
# VUSE <.MEM_5>
return 0;
lto1: warning: use location
beacuse in succ := 40 have return or exit
gimple stmt in succ := 2 ,possiable got to succ := 40

======================================================================
msg2_64 = malloc (_63);
./benchmarks/tmux/leak_1/tmux_leak_1.c:169:7: warning: use location
  msg2 = xmalloc(strlen(msg) + 1);
       ^
this stmt is child function---malloc-----

 ================== trace ================== 
 <ssa_name 0x7f9b11553000
    type <integer_type 0x7f9b119ec7e0 long unsigned int public unsigned DI
        size <integer_cst 0x7f9b119d8be8 constant 64>
        unit size <integer_cst 0x7f9b119d8c00 constant 8>
        align 64 symtab 0 alias set -1 canonical type 0x7f9b119ec738 precision 64 min <integer_cst 0x7f9b119d8eb8 0> max <integer_cst 0x7f9b119da500 18446744073709551615>
        pointer_to_this <pointer_type 0x7f9b119f89d8>>
   
    def_stmt _63 = _62 + 1;
    version 63>
trace fucntion name:malloc 

 ================== trace ================== 
trace fucntion free:0 

======================================================================
[40;31m    branch possiable have return or exit  [0m
ptr2_80 = PHI <msg2_64(2), ptr2_90(12)>
bb index := 13
# VUSE <.MEM_11>
return i_7;
./benchmarks/tmux/leak_1/tmux_leak_1.c:96:9: warning: use location
  return i;
         ^
beacuse in succ := 5 have return or exit
gimple stmt in succ := 13 ,possiable got to succ := 5

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
ptr2_80 = PHI <msg2_64(2), ptr2_90(12)>
bb index := 13
# VUSE <.MEM_11>
return i_7;
./benchmarks/tmux/leak_1/tmux_leak_1.c:96:9: warning: use location
beacuse in succ := 5 have return or exit
gimple stmt in succ := 13 ,possiable got to succ := 5

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
ptr2_80 = PHI <msg2_64(2), ptr2_90(12)>
bb index := 13
# VUSE <.MEM_11>
return i_7;
./benchmarks/tmux/leak_1/tmux_leak_1.c:96:9: warning: use location
beacuse in succ := 5 have return or exit
gimple stmt in succ := 13 ,possiable got to succ := 5

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
ptr2_80 = PHI <msg2_64(2), ptr2_90(12)>
bb index := 13
# VUSE <.MEM_11>
return i_7;
./benchmarks/tmux/leak_1/tmux_leak_1.c:96:9: warning: use location
beacuse in succ := 5 have return or exit
gimple stmt in succ := 13 ,possiable got to succ := 5

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
ptr2_80 = PHI <msg2_64(2), ptr2_90(12)>
bb index := 13
# VUSE <.MEM_5>
return 0;
lto1: warning: use location
beacuse in succ := 40 have return or exit
gimple stmt in succ := 13 ,possiable got to succ := 40

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
ptr2_80 = PHI <msg2_64(2), ptr2_90(12)>
bb index := 13
# VUSE <.MEM_5>
return 0;
lto1: warning: use location
beacuse in succ := 40 have return or exit
gimple stmt in succ := 13 ,possiable got to succ := 40

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
ptr2_80 = PHI <msg2_64(2), ptr2_90(12)>
bb index := 13
# VUSE <.MEM_5>
return 0;
lto1: warning: use location
beacuse in succ := 40 have return or exit
gimple stmt in succ := 13 ,possiable got to succ := 40

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
ptr2_80 = PHI <msg2_64(2), ptr2_90(12)>
bb index := 13
# VUSE <.MEM_5>
return 0;
lto1: warning: use location
beacuse in succ := 40 have return or exit
gimple stmt in succ := 13 ,possiable got to succ := 40

======================================================================

======================================================================
[40;31m    collect Stmt in loop [0m

======================================================================
ptr2_80 = PHI <msg2_64(2), ptr2_90(12)>
lto1: warning: use location
this stmt have mutiple branch --------

======================================================================
[40;31m    branch possiable have return or exit  [0m
ptr2_90 = PHI <ptr2_80(10), ptr2_82(11)>
bb index := 12
# VUSE <.MEM_11>
return i_7;
./benchmarks/tmux/leak_1/tmux_leak_1.c:96:9: warning: use location
beacuse in succ := 5 have return or exit
gimple stmt in succ := 12 ,possiable got to succ := 5

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
ptr2_90 = PHI <ptr2_80(10), ptr2_82(11)>
bb index := 12
# VUSE <.MEM_5>
return 0;
lto1: warning: use location
beacuse in succ := 40 have return or exit
gimple stmt in succ := 12 ,possiable got to succ := 40

======================================================================

======================================================================
[40;31m    collect Stmt in loop [0m

======================================================================
ptr2_90 = PHI <ptr2_80(10), ptr2_82(11)>
lto1: warning: use location
this stmt have mutiple branch --------

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_100 = VDEF <.MEM_92>
*ptr2_80 = 0;
bb index := 14
# VUSE <.MEM_11>
return i_7;
./benchmarks/tmux/leak_1/tmux_leak_1.c:96:9: warning: use location
beacuse in succ := 5 have return or exit
gimple stmt in succ := 14 ,possiable got to succ := 5

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_100 = VDEF <.MEM_92>
*ptr2_80 = 0;
bb index := 14
# VUSE <.MEM_11>
return i_7;
./benchmarks/tmux/leak_1/tmux_leak_1.c:96:9: warning: use location
beacuse in succ := 5 have return or exit
gimple stmt in succ := 14 ,possiable got to succ := 5

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_100 = VDEF <.MEM_92>
*ptr2_80 = 0;
bb index := 14
# VUSE <.MEM_5>
return 0;
lto1: warning: use location
beacuse in succ := 40 have return or exit
gimple stmt in succ := 14 ,possiable got to succ := 40

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_100 = VDEF <.MEM_92>
*ptr2_80 = 0;
bb index := 14
# VUSE <.MEM_5>
return 0;
lto1: warning: use location
beacuse in succ := 40 have return or exit
gimple stmt in succ := 14 ,possiable got to succ := 40

======================================================================
*ptr2_80 = 0;
./benchmarks/tmux/leak_1/tmux_leak_1.c:183:8: warning: use location
  *ptr2 = '\0';
        ^

======================================================================
[40;31m    collect Stmt in loop [0m

======================================================================
_81 = ptr2_80;
./benchmarks/tmux/leak_1/tmux_leak_1.c:181:8: warning: use location
   *ptr2++ = *ptr++;
        ^

======================================================================
[40;31m    collect Stmt in loop [0m

======================================================================
*_81 = _83;
./benchmarks/tmux/leak_1/tmux_leak_1.c:181:11: warning: use location
   *ptr2++ = *ptr++;
           ^

======================================================================
[40;31m    collect Stmt in loop [0m

======================================================================
*_81 = _83;
./benchmarks/tmux/leak_1/tmux_leak_1.c:181:11: warning: use location

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_102 = VDEF <.MEM_101>
free (msg2_64);
bb index := 14
# VUSE <.MEM_11>
return i_7;
./benchmarks/tmux/leak_1/tmux_leak_1.c:96:9: warning: use location
  return i;
         ^
beacuse in succ := 5 have return or exit
gimple stmt in succ := 14 ,possiable got to succ := 5

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_102 = VDEF <.MEM_101>
free (msg2_64);
bb index := 14
# VUSE <.MEM_11>
return i_7;
./benchmarks/tmux/leak_1/tmux_leak_1.c:96:9: warning: use location
beacuse in succ := 5 have return or exit
gimple stmt in succ := 14 ,possiable got to succ := 5

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_102 = VDEF <.MEM_101>
free (msg2_64);
bb index := 14
# VUSE <.MEM_5>
return 0;
lto1: warning: use location
beacuse in succ := 40 have return or exit
gimple stmt in succ := 14 ,possiable got to succ := 40

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_102 = VDEF <.MEM_101>
free (msg2_64);
bb index := 14
# VUSE <.MEM_5>
return 0;
lto1: warning: use location
beacuse in succ := 40 have return or exit
gimple stmt in succ := 14 ,possiable got to succ := 40

======================================================================
free (msg2_64);
./benchmarks/tmux/leak_1/tmux_leak_1.c:186:2: warning: use location
  free(msg2);
  ^
this stmt is child function---free-----

 ================== find ================== 
free (msg2_64);
./benchmarks/tmux/leak_1/tmux_leak_1.c:186:2: warning: use location
[40;32m    HAS FREE STMT count:1 name:free [0m

 ================== find ================== 

======================================================================
[40;31m    branch possiable have return or exit  [0m
ptr2_66 = msg2_64;
bb index := 2
# VUSE <.MEM_11>
return i_7;
./benchmarks/tmux/leak_1/tmux_leak_1.c:96:9: warning: use location
  return i;
         ^
beacuse in succ := 5 have return or exit
gimple stmt in succ := 2 ,possiable got to succ := 5

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
ptr2_66 = msg2_64;
bb index := 2
# VUSE <.MEM_5>
return 0;
lto1: warning: use location
beacuse in succ := 40 have return or exit
gimple stmt in succ := 2 ,possiable got to succ := 40

======================================================================
ptr2_66 = msg2_64;
./benchmarks/tmux/leak_1/tmux_leak_1.c:172:7: warning: use location
  ptr2 = msg2;
       ^

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7f9b11553000
    type <integer_type 0x7f9b119ec7e0 long unsigned int public unsigned DI
        size <integer_cst 0x7f9b119d8be8 constant 64>
        unit size <integer_cst 0x7f9b119d8c00 constant 8>
        align 64 symtab 0 alias set -1 canonical type 0x7f9b119ec738 precision 64 min <integer_cst 0x7f9b119d8eb8 0> max <integer_cst 0x7f9b119da500 18446744073709551615>
        pointer_to_this <pointer_type 0x7f9b119f89d8>>
   
    def_stmt _63 = _62 + 1;
    version 63>
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_101 = VDEF <.MEM_100>
free (_85);
./benchmarks/tmux/leak_1/tmux_leak_1.c:185:2: warning: use location
  free(msg);
  ^
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_102 = VDEF <.MEM_101>
free (msg2_64);
./benchmarks/tmux/leak_1/tmux_leak_1.c:186:2: warning: use location
  free(msg2);
  ^
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_108 = VDEF <.MEM_94>
free (_57);
./benchmarks/tmux/leak_1/tmux_leak_1.c:158:2: warning: use location
  free(msg);
  ^

 ================== Start Use after free Check ================== 

============================================================
# .MEM_102 = VDEF <.MEM_101>
free (msg2_64);
./benchmarks/tmux/leak_1/tmux_leak_1.c:186:2: warning: Use after free error!: free location 
  free(msg2);
  ^
ptr2_80 = PHI <msg2_64(2), ptr2_90(12)>
lto1: warning: use location

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_101 = VDEF <.MEM_100>
free (_85);
./benchmarks/tmux/leak_1/tmux_leak_1.c:185:2: warning: Use after free error!: free location 
  free(msg);
  ^
ptr2_80 = PHI <msg2_64(2), ptr2_90(12)>
lto1: warning: use location

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_102 = VDEF <.MEM_101>
free (msg2_64);
./benchmarks/tmux/leak_1/tmux_leak_1.c:186:2: warning: Use after free error!: free location 
  free(msg2);
  ^
ptr2_80 = PHI <msg2_64(2), ptr2_90(12)>
lto1: warning: use location

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_108 = VDEF <.MEM_94>
free (_57);
./benchmarks/tmux/leak_1/tmux_leak_1.c:158:2: warning: Use after free error!: free location 
  free(msg);
  ^
ptr2_80 = PHI <msg2_64(2), ptr2_90(12)>
lto1: warning: use location

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
# .MEM_102 = VDEF <.MEM_101>
free (msg2_64);
./benchmarks/tmux/leak_1/tmux_leak_1.c:186:2: warning: Use after free error!: free location 
  free(msg2);
  ^
ptr2_90 = PHI <ptr2_80(10), ptr2_82(11)>
lto1: warning: use location

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_101 = VDEF <.MEM_100>
free (_85);
./benchmarks/tmux/leak_1/tmux_leak_1.c:185:2: warning: Use after free error!: free location 
  free(msg);
  ^
ptr2_90 = PHI <ptr2_80(10), ptr2_82(11)>
lto1: warning: use location

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_102 = VDEF <.MEM_101>
free (msg2_64);
./benchmarks/tmux/leak_1/tmux_leak_1.c:186:2: warning: Use after free error!: free location 
  free(msg2);
  ^
ptr2_90 = PHI <ptr2_80(10), ptr2_82(11)>
lto1: warning: use location

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_108 = VDEF <.MEM_94>
free (_57);
./benchmarks/tmux/leak_1/tmux_leak_1.c:158:2: warning: Use after free error!: free location 
  free(msg);
  ^
ptr2_90 = PHI <ptr2_80(10), ptr2_82(11)>
lto1: warning: use location

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:3 [0m

======================================================================

======================================================================
[40;31m 	this stmt need double check [0m

======================================================================

dot graph START

======================================================================
 <addr_expr 0x7f9b11541440
    type <pointer_type 0x7f9b1150e000
        type <pointer_type 0x7f9b11502930 type <integer_type 0x7f9b11502888 char>
            public unsigned DI
            size <integer_cst 0x7f9b119d8be8 constant 64>
            unit size <integer_cst 0x7f9b119d8c00 constant 8>
            align 64 symtab 0 alias set -1 structural equality context <translation_unit_decl 0x7f9b119e3168 ./benchmarks/tmux/leak_1/tmux_leak_1.c>
            pointer_to_this <pointer_type 0x7f9b1150e000>>
        public unsigned DI size <integer_cst 0x7f9b119d8be8 64> unit size <integer_cst 0x7f9b119d8c00 8>
        align 64 symtab 0 alias set -1 structural equality>
   
    arg 0 <var_decl 0x7f9b11543990 msg type <pointer_type 0x7f9b11502930>
        addressable used unsigned DI file ./benchmarks/tmux/leak_1/tmux_leak_1.c line 106 col 10 size <integer_cst 0x7f9b119d8be8 64> unit size <integer_cst 0x7f9b119d8c00 8>
        align 64 context <function_decl 0x7f9b11503b00 main> abstract_origin <var_decl 0x7f9b115432d0 msg>
        chain <var_decl 0x7f9b11543a20 ptr type <pointer_type 0x7f9b11528c78>
            used unsigned DI file ./benchmarks/tmux/leak_1/tmux_leak_1.c line 107 col 13 size <integer_cst 0x7f9b119d8be8 64> unit size <integer_cst 0x7f9b119d8c00 8>
            align 64 context <function_decl 0x7f9b11503b00 main> abstract_origin <var_decl 0x7f9b11543240 ptr> chain <var_decl 0x7f9b11543ab0 last>>>
    ./benchmarks/tmux/leak_1/tmux_leak_1.c:113:2 start: ./benchmarks/tmux/leak_1/tmux_leak_1.c:113:2 finish: ./benchmarks/tmux/leak_1/tmux_leak_1.c:113:2>

 ================== trace ptable================== 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr--------
this other function -----------

======================================================================
[40;35m  	Looserules free count:0 [0m

======================================================================

======================================================================
[40;31m 	Can't find this fucntion in Pointer table [0m
[40;31m 	Possiable no other stmt relate with this stmt [0m

======================================================================

dot graph START

======================================================================
 <ssa_name 0x7f9b11547900
    type <pointer_type 0x7f9b11528c78
        type <integer_type 0x7f9b1150b150 u_char public unsigned string-flag QI
            size <integer_cst 0x7f9b119d8cd8 constant 8>
            unit size <integer_cst 0x7f9b119d8cf0 constant 1>
            align 8 symtab 0 alias set -1 canonical type 0x7f9b119ec3f0 precision 8 min <integer_cst 0x7f9b119d8d08 0> max <integer_cst 0x7f9b119d8ca8 255> context <translation_unit_decl 0x7f9b119e3168 ./benchmarks/tmux/leak_1/tmux_leak_1.c>
            pointer_to_this <pointer_type 0x7f9b11528c78>>
        public unsigned DI
        size <integer_cst 0x7f9b119d8be8 constant 64>
        unit size <integer_cst 0x7f9b119d8c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality>
    var <var_decl 0x7f9b11543a20 ptr>
    def_stmt ptr_25 = ptr_22 + 2;
    version 25
    ptr-info 0x7f9b115329d8>
ptr_25 = ptr_22 + 2;

 ================== trace ptable================== 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr--------
this other function -----------
 
 Start check Pointer Collect  

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# VUSE <.MEM_94>
_26 = strcspn (ptr_25, "]");
bb index := 17
# VUSE <.MEM_11>
return i_7;
./benchmarks/tmux/leak_1/tmux_leak_1.c:96:9: warning: use location
  return i;
         ^
beacuse in succ := 5 have return or exit
gimple stmt in succ := 17 ,possiable got to succ := 5

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# VUSE <.MEM_94>
_26 = strcspn (ptr_25, "]");
bb index := 17
# VUSE <.MEM_11>
return i_7;
./benchmarks/tmux/leak_1/tmux_leak_1.c:96:9: warning: use location
beacuse in succ := 5 have return or exit
gimple stmt in succ := 17 ,possiable got to succ := 5

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# VUSE <.MEM_94>
_26 = strcspn (ptr_25, "]");
bb index := 17
# VUSE <.MEM_5>
return 0;
lto1: warning: use location
beacuse in succ := 40 have return or exit
gimple stmt in succ := 17 ,possiable got to succ := 40

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# VUSE <.MEM_94>
_26 = strcspn (ptr_25, "]");
bb index := 17
# VUSE <.MEM_5>
return 0;
lto1: warning: use location
beacuse in succ := 40 have return or exit
gimple stmt in succ := 17 ,possiable got to succ := 40

======================================================================

======================================================================
[40;31m    collect Stmt in loop [0m

======================================================================
_26 = strcspn (ptr_25, "]");
./benchmarks/tmux/leak_1/tmux_leak_1.c:119:17: warning: use location
    last = ptr + strcspn(ptr, "]");
                 ^
this stmt is child function---strcspn-----

 ================== trace ================== 
 <ssa_name 0x7f9b11547900
    type <pointer_type 0x7f9b11528c78
        type <integer_type 0x7f9b1150b150 u_char public unsigned string-flag QI
            size <integer_cst 0x7f9b119d8cd8 constant 8>
            unit size <integer_cst 0x7f9b119d8cf0 constant 1>
            align 8 symtab 0 alias set -1 canonical type 0x7f9b119ec3f0 precision 8 min <integer_cst 0x7f9b119d8d08 0> max <integer_cst 0x7f9b119d8ca8 255> context <translation_unit_decl 0x7f9b119e3168 ./benchmarks/tmux/leak_1/tmux_leak_1.c>
            pointer_to_this <pointer_type 0x7f9b11528c78>>
        public unsigned DI
        size <integer_cst 0x7f9b119d8be8 constant 64>
        unit size <integer_cst 0x7f9b119d8c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality>
    var <var_decl 0x7f9b11543a20 ptr>
    def_stmt ptr_25 = ptr_22 + 2;
    version 25
    ptr-info 0x7f9b115329d8>
trace fucntion name:strcspn 

 ================== trace ================== 
trace fucntion free:0 

======================================================================
[40;31m    branch possiable have return or exit  [0m
last_27 = ptr_25 + _26;
bb index := 17
# VUSE <.MEM_11>
return i_7;
./benchmarks/tmux/leak_1/tmux_leak_1.c:96:9: warning: use location
  return i;
         ^
beacuse in succ := 5 have return or exit
gimple stmt in succ := 17 ,possiable got to succ := 5

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
last_27 = ptr_25 + _26;
bb index := 17
# VUSE <.MEM_11>
return i_7;
./benchmarks/tmux/leak_1/tmux_leak_1.c:96:9: warning: use location
beacuse in succ := 5 have return or exit
gimple stmt in succ := 17 ,possiable got to succ := 5

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
last_27 = ptr_25 + _26;
bb index := 17
# VUSE <.MEM_5>
return 0;
lto1: warning: use location
beacuse in succ := 40 have return or exit
gimple stmt in succ := 17 ,possiable got to succ := 40

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
last_27 = ptr_25 + _26;
bb index := 17
# VUSE <.MEM_5>
return 0;
lto1: warning: use location
beacuse in succ := 40 have return or exit
gimple stmt in succ := 17 ,possiable got to succ := 40

======================================================================

======================================================================
[40;31m    collect Stmt in loop [0m

======================================================================
last_27 = ptr_25 + _26;
./benchmarks/tmux/leak_1/tmux_leak_1.c:119:9: warning: use location
    last = ptr + strcspn(ptr, "]");
         ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
ptr_29 = last_27 + 1;
bb index := 18
# VUSE <.MEM_11>
return i_7;
./benchmarks/tmux/leak_1/tmux_leak_1.c:96:9: warning: use location
  return i;
         ^
beacuse in succ := 5 have return or exit
gimple stmt in succ := 18 ,possiable got to succ := 5

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
ptr_29 = last_27 + 1;
bb index := 18
# VUSE <.MEM_5>
return 0;
lto1: warning: use location
beacuse in succ := 40 have return or exit
gimple stmt in succ := 18 ,possiable got to succ := 40

======================================================================

======================================================================
[40;31m    collect Stmt in loop [0m

======================================================================
ptr_29 = last_27 + 1;
./benchmarks/tmux/leak_1/tmux_leak_1.c:126:8: warning: use location
    ptr = last + 1;
        ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
ptr_59 = PHI <ptr_29(18), ptr_37(22), ptr_37(27), ptr_55(32)>
bb index := 33
# VUSE <.MEM_11>
return i_7;
./benchmarks/tmux/leak_1/tmux_leak_1.c:96:9: warning: use location
  return i;
         ^
beacuse in succ := 5 have return or exit
gimple stmt in succ := 33 ,possiable got to succ := 5

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
ptr_59 = PHI <ptr_29(18), ptr_37(22), ptr_37(27), ptr_55(32)>
bb index := 33
# VUSE <.MEM_5>
return 0;
lto1: warning: use location
beacuse in succ := 40 have return or exit
gimple stmt in succ := 33 ,possiable got to succ := 40

======================================================================

======================================================================
[40;31m    collect Stmt in loop [0m

======================================================================
ptr_59 = PHI <ptr_29(18), ptr_37(22), ptr_37(27), ptr_55(32)>
lto1: warning: use location
this stmt have mutiple branch --------

======================================================================
[40;31m    branch possiable have return or exit  [0m
ptr_22 = PHI <ptr_21(14), ptr_59(33)>
bb index := 34
# VUSE <.MEM_11>
return i_7;
./benchmarks/tmux/leak_1/tmux_leak_1.c:96:9: warning: use location
beacuse in succ := 5 have return or exit
gimple stmt in succ := 34 ,possiable got to succ := 5

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
ptr_22 = PHI <ptr_21(14), ptr_59(33)>
bb index := 34
# VUSE <.MEM_11>
return i_7;
./benchmarks/tmux/leak_1/tmux_leak_1.c:96:9: warning: use location
beacuse in succ := 5 have return or exit
gimple stmt in succ := 34 ,possiable got to succ := 5

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
ptr_22 = PHI <ptr_21(14), ptr_59(33)>
bb index := 34
# VUSE <.MEM_11>
return i_7;
./benchmarks/tmux/leak_1/tmux_leak_1.c:96:9: warning: use location
beacuse in succ := 5 have return or exit
gimple stmt in succ := 34 ,possiable got to succ := 5

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
ptr_22 = PHI <ptr_21(14), ptr_59(33)>
bb index := 34
# VUSE <.MEM_11>
return i_7;
./benchmarks/tmux/leak_1/tmux_leak_1.c:96:9: warning: use location
beacuse in succ := 5 have return or exit
gimple stmt in succ := 34 ,possiable got to succ := 5

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
ptr_22 = PHI <ptr_21(14), ptr_59(33)>
bb index := 34
# VUSE <.MEM_5>
return 0;
lto1: warning: use location
beacuse in succ := 40 have return or exit
gimple stmt in succ := 34 ,possiable got to succ := 40

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
ptr_22 = PHI <ptr_21(14), ptr_59(33)>
bb index := 34
# VUSE <.MEM_5>
return 0;
lto1: warning: use location
beacuse in succ := 40 have return or exit
gimple stmt in succ := 34 ,possiable got to succ := 40

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
ptr_22 = PHI <ptr_21(14), ptr_59(33)>
bb index := 34
# VUSE <.MEM_5>
return 0;
lto1: warning: use location
beacuse in succ := 40 have return or exit
gimple stmt in succ := 34 ,possiable got to succ := 40

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
ptr_22 = PHI <ptr_21(14), ptr_59(33)>
bb index := 34
# VUSE <.MEM_5>
return 0;
lto1: warning: use location
beacuse in succ := 40 have return or exit
gimple stmt in succ := 34 ,possiable got to succ := 40

======================================================================

======================================================================
[40;31m    collect Stmt in loop [0m

======================================================================
ptr_22 = PHI <ptr_21(14), ptr_59(33)>
lto1: warning: use location
this stmt have mutiple branch --------

======================================================================
[40;31m    branch possiable have return or exit  [0m
# VUSE <.MEM_94>
_56 = *ptr_22;
bb index := 34
# VUSE <.MEM_11>
return i_7;
./benchmarks/tmux/leak_1/tmux_leak_1.c:96:9: warning: use location
beacuse in succ := 5 have return or exit
gimple stmt in succ := 34 ,possiable got to succ := 5

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# VUSE <.MEM_94>
_56 = *ptr_22;
bb index := 34
# VUSE <.MEM_11>
return i_7;
./benchmarks/tmux/leak_1/tmux_leak_1.c:96:9: warning: use location
beacuse in succ := 5 have return or exit
gimple stmt in succ := 34 ,possiable got to succ := 5

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# VUSE <.MEM_94>
_56 = *ptr_22;
bb index := 34
# VUSE <.MEM_11>
return i_7;
./benchmarks/tmux/leak_1/tmux_leak_1.c:96:9: warning: use location
beacuse in succ := 5 have return or exit
gimple stmt in succ := 34 ,possiable got to succ := 5

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# VUSE <.MEM_94>
_56 = *ptr_22;
bb index := 34
# VUSE <.MEM_11>
return i_7;
./benchmarks/tmux/leak_1/tmux_leak_1.c:96:9: warning: use location
beacuse in succ := 5 have return or exit
gimple stmt in succ := 34 ,possiable got to succ := 5

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# VUSE <.MEM_94>
_56 = *ptr_22;
bb index := 34
# VUSE <.MEM_5>
return 0;
lto1: warning: use location
beacuse in succ := 40 have return or exit
gimple stmt in succ := 34 ,possiable got to succ := 40

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# VUSE <.MEM_94>
_56 = *ptr_22;
bb index := 34
# VUSE <.MEM_5>
return 0;
lto1: warning: use location
beacuse in succ := 40 have return or exit
gimple stmt in succ := 34 ,possiable got to succ := 40

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# VUSE <.MEM_94>
_56 = *ptr_22;
bb index := 34
# VUSE <.MEM_5>
return 0;
lto1: warning: use location
beacuse in succ := 40 have return or exit
gimple stmt in succ := 34 ,possiable got to succ := 40

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# VUSE <.MEM_94>
_56 = *ptr_22;
bb index := 34
# VUSE <.MEM_5>
return 0;
lto1: warning: use location
beacuse in succ := 40 have return or exit
gimple stmt in succ := 34 ,possiable got to succ := 40

======================================================================

======================================================================
[40;31m    collect Stmt in loop [0m

======================================================================
_56 = *ptr_22;
./benchmarks/tmux/leak_1/tmux_leak_1.c:116:9: warning: use location
  while (*ptr != '\0') {
         ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
if (_56 != 0)
bb index := 34
# VUSE <.MEM_11>
return i_7;
./benchmarks/tmux/leak_1/tmux_leak_1.c:96:9: warning: use location
  return i;
         ^
beacuse in succ := 5 have return or exit
gimple stmt in succ := 34 ,possiable got to succ := 5

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
if (_56 != 0)
bb index := 34
# VUSE <.MEM_11>
return i_7;
./benchmarks/tmux/leak_1/tmux_leak_1.c:96:9: warning: use location
beacuse in succ := 5 have return or exit
gimple stmt in succ := 34 ,possiable got to succ := 5

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
if (_56 != 0)
bb index := 34
# VUSE <.MEM_11>
return i_7;
./benchmarks/tmux/leak_1/tmux_leak_1.c:96:9: warning: use location
beacuse in succ := 5 have return or exit
gimple stmt in succ := 34 ,possiable got to succ := 5

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
if (_56 != 0)
bb index := 34
# VUSE <.MEM_11>
return i_7;
./benchmarks/tmux/leak_1/tmux_leak_1.c:96:9: warning: use location
beacuse in succ := 5 have return or exit
gimple stmt in succ := 34 ,possiable got to succ := 5

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
if (_56 != 0)
bb index := 34
# VUSE <.MEM_5>
return 0;
lto1: warning: use location
beacuse in succ := 40 have return or exit
gimple stmt in succ := 34 ,possiable got to succ := 40

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
if (_56 != 0)
bb index := 34
# VUSE <.MEM_5>
return 0;
lto1: warning: use location
beacuse in succ := 40 have return or exit
gimple stmt in succ := 34 ,possiable got to succ := 40

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
if (_56 != 0)
bb index := 34
# VUSE <.MEM_5>
return 0;
lto1: warning: use location
beacuse in succ := 40 have return or exit
gimple stmt in succ := 34 ,possiable got to succ := 40

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
if (_56 != 0)
bb index := 34
# VUSE <.MEM_5>
return 0;
lto1: warning: use location
beacuse in succ := 40 have return or exit
gimple stmt in succ := 34 ,possiable got to succ := 40

======================================================================

======================================================================
[40;31m    collect Stmt in loop [0m

======================================================================
if (_56 != 0)
./benchmarks/tmux/leak_1/tmux_leak_1.c:116:8: warning: use location
  while (*ptr != '\0') {
        ^
if (_56 != 0)

 ================== find cond branch ================= 
./benchmarks/tmux/leak_1/tmux_leak_1.c:116:8: warning: use location
Cond in fucntion main basic block 34
 ================== possible direct basic block ================= 
from main basic block 15
 ================== possible direct basic block ================= 
from main basic block 35
 ================== warring ================== 
[40;35m    need check this branch possible have return or exit stmt [0m

 ================== warring ================== 

 ================== find cond branch ================= 

======================================================================
[40;31m    collect Stmt in loop [0m

======================================================================
ptr_55 = ptr_22 + 1;
./benchmarks/tmux/leak_1/tmux_leak_1.c:154:7: warning: use location
    ptr++;
       ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
# VUSE <.MEM_94>
_52 = *ptr_22;
bb index := 30
# VUSE <.MEM_11>
return i_7;
./benchmarks/tmux/leak_1/tmux_leak_1.c:96:9: warning: use location
  return i;
         ^
beacuse in succ := 5 have return or exit
gimple stmt in succ := 30 ,possiable got to succ := 5

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# VUSE <.MEM_94>
_52 = *ptr_22;
bb index := 30
# VUSE <.MEM_5>
return 0;
lto1: warning: use location
beacuse in succ := 40 have return or exit
gimple stmt in succ := 30 ,possiable got to succ := 40

======================================================================

======================================================================
[40;31m    collect Stmt in loop [0m

======================================================================
_52 = *ptr_22;
./benchmarks/tmux/leak_1/tmux_leak_1.c:151:8: warning: use location
    if (*ptr > 0x1f && *ptr < 0x7f) {
        ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
ptr_37 = &MEM[(void *)ptr_22 + 2B];
bb index := 21
# VUSE <.MEM_11>
return i_7;
./benchmarks/tmux/leak_1/tmux_leak_1.c:96:9: warning: use location
  return i;
         ^
beacuse in succ := 5 have return or exit
gimple stmt in succ := 21 ,possiable got to succ := 5

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
ptr_37 = &MEM[(void *)ptr_22 + 2B];
bb index := 21
# VUSE <.MEM_5>
return 0;
lto1: warning: use location
beacuse in succ := 40 have return or exit
gimple stmt in succ := 21 ,possiable got to succ := 40

======================================================================

======================================================================
[40;31m    collect Stmt in loop [0m

======================================================================
ptr_37 = &MEM[(void *)ptr_22 + 2B];
./benchmarks/tmux/leak_1/tmux_leak_1.c:136:7: warning: use location
    ptr++;
       ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
ptr_32 = ptr_22 + 1;
bb index := 20
# VUSE <.MEM_11>
return i_7;
./benchmarks/tmux/leak_1/tmux_leak_1.c:96:9: warning: use location
  return i;
         ^
beacuse in succ := 5 have return or exit
gimple stmt in succ := 20 ,possiable got to succ := 5

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
ptr_32 = ptr_22 + 1;
bb index := 20
# VUSE <.MEM_11>
return i_7;
./benchmarks/tmux/leak_1/tmux_leak_1.c:96:9: warning: use location
beacuse in succ := 5 have return or exit
gimple stmt in succ := 20 ,possiable got to succ := 5

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
ptr_32 = ptr_22 + 1;
bb index := 20
# VUSE <.MEM_5>
return 0;
lto1: warning: use location
beacuse in succ := 40 have return or exit
gimple stmt in succ := 20 ,possiable got to succ := 40

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
ptr_32 = ptr_22 + 1;
bb index := 20
# VUSE <.MEM_5>
return 0;
lto1: warning: use location
beacuse in succ := 40 have return or exit
gimple stmt in succ := 20 ,possiable got to succ := 40

======================================================================

======================================================================
[40;31m    collect Stmt in loop [0m

======================================================================
ptr_32 = ptr_22 + 1;
./benchmarks/tmux/leak_1/tmux_leak_1.c:131:7: warning: use location
    ptr++;
       ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
# VUSE <.MEM_94>
left_33 = strlen (ptr_32);
bb index := 20
# VUSE <.MEM_11>
return i_7;
./benchmarks/tmux/leak_1/tmux_leak_1.c:96:9: warning: use location
  return i;
         ^
beacuse in succ := 5 have return or exit
gimple stmt in succ := 20 ,possiable got to succ := 5

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# VUSE <.MEM_94>
left_33 = strlen (ptr_32);
bb index := 20
# VUSE <.MEM_11>
return i_7;
./benchmarks/tmux/leak_1/tmux_leak_1.c:96:9: warning: use location
beacuse in succ := 5 have return or exit
gimple stmt in succ := 20 ,possiable got to succ := 5

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# VUSE <.MEM_94>
left_33 = strlen (ptr_32);
bb index := 20
# VUSE <.MEM_5>
return 0;
lto1: warning: use location
beacuse in succ := 40 have return or exit
gimple stmt in succ := 20 ,possiable got to succ := 40

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# VUSE <.MEM_94>
left_33 = strlen (ptr_32);
bb index := 20
# VUSE <.MEM_5>
return 0;
lto1: warning: use location
beacuse in succ := 40 have return or exit
gimple stmt in succ := 20 ,possiable got to succ := 40

======================================================================

======================================================================
[40;31m    collect Stmt in loop [0m

======================================================================
left_33 = strlen (ptr_32);
./benchmarks/tmux/leak_1/tmux_leak_1.c:133:9: warning: use location
    left = strlen(ptr);
         ^
this stmt is child function---strlen-----

 ================== trace ================== 
 <ssa_name 0x7f9b11547900
    type <pointer_type 0x7f9b11528c78
        type <integer_type 0x7f9b1150b150 u_char public unsigned string-flag QI
            size <integer_cst 0x7f9b119d8cd8 constant 8>
            unit size <integer_cst 0x7f9b119d8cf0 constant 1>
            align 8 symtab 0 alias set -1 canonical type 0x7f9b119ec3f0 precision 8 min <integer_cst 0x7f9b119d8d08 0> max <integer_cst 0x7f9b119d8ca8 255> context <translation_unit_decl 0x7f9b119e3168 ./benchmarks/tmux/leak_1/tmux_leak_1.c>
            pointer_to_this <pointer_type 0x7f9b11528c78>>
        public unsigned DI
        size <integer_cst 0x7f9b119d8be8 constant 64>
        unit size <integer_cst 0x7f9b119d8c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality>
    var <var_decl 0x7f9b11543a20 ptr>
    def_stmt ptr_25 = ptr_22 + 2;
    version 25
    ptr-info 0x7f9b115329d8>
trace fucntion name:strlen 

 ================== trace ================== 
trace fucntion free:0 

======================================================================
[40;31m    branch possiable have return or exit  [0m
if (left_33 < _36)
bb index := 20
# VUSE <.MEM_11>
return i_7;
./benchmarks/tmux/leak_1/tmux_leak_1.c:96:9: warning: use location
  return i;
         ^
beacuse in succ := 5 have return or exit
gimple stmt in succ := 20 ,possiable got to succ := 5

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
if (left_33 < _36)
bb index := 20
# VUSE <.MEM_11>
return i_7;
./benchmarks/tmux/leak_1/tmux_leak_1.c:96:9: warning: use location
beacuse in succ := 5 have return or exit
gimple stmt in succ := 20 ,possiable got to succ := 5

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
if (left_33 < _36)
bb index := 20
# VUSE <.MEM_5>
return 0;
lto1: warning: use location
beacuse in succ := 40 have return or exit
gimple stmt in succ := 20 ,possiable got to succ := 40

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
if (left_33 < _36)
bb index := 20
# VUSE <.MEM_5>
return 0;
lto1: warning: use location
beacuse in succ := 40 have return or exit
gimple stmt in succ := 20 ,possiable got to succ := 40

======================================================================

======================================================================
[40;31m    collect Stmt in loop [0m

======================================================================
if (left_33 < _36)
./benchmarks/tmux/leak_1/tmux_leak_1.c:134:7: warning: use location
    if (left < (size_t)ud->size - 1)
       ^
if (left_33 < _36)

 ================== find cond branch ================= 
./benchmarks/tmux/leak_1/tmux_leak_1.c:134:7: warning: use location
Cond in fucntion main basic block 20
 ================== possible direct basic block ================= 
from main basic block 35
 ================== possible direct basic block ================= 
from main basic block 21
 ================== warring ================== 
[40;35m    need check this branch possible have return or exit stmt [0m

 ================== warring ================== 

 ================== find cond branch ================= 

======================================================================
[40;31m    collect Stmt in loop [0m

======================================================================
_30 = *ptr_22;
./benchmarks/tmux/leak_1/tmux_leak_1.c:130:7: warning: use location
   if (*ptr > 0x7f) {
       ^

======================================================================
[40;31m    collect Stmt in loop [0m

======================================================================
_31 = (signed char) _30;
./benchmarks/tmux/leak_1/tmux_leak_1.c:130:12: warning: use location
   if (*ptr > 0x7f) {
            ^

======================================================================
[40;31m    collect Stmt in loop [0m

======================================================================
if (_31 < 0)
./benchmarks/tmux/leak_1/tmux_leak_1.c:130:6: warning: use location
   if (*ptr > 0x7f) {
      ^
if (_31 < 0)

 ================== find cond branch ================= 
./benchmarks/tmux/leak_1/tmux_leak_1.c:130:6: warning: use location
Cond in fucntion main basic block 19
 ================== possible direct basic block ================= 
from main basic block 20
 ================== possible direct basic block ================= 
from main basic block 28
 ================== warring ================== 
[40;35m    need check this branch possible have return or exit stmt [0m

 ================== warring ================== 

 ================== find cond branch ================= 

======================================================================
[40;31m    branch possiable have return or exit  [0m
ptr_25 = ptr_22 + 2;
bb index := 17
# VUSE <.MEM_11>
return i_7;
./benchmarks/tmux/leak_1/tmux_leak_1.c:96:9: warning: use location
  return i;
         ^
beacuse in succ := 5 have return or exit
gimple stmt in succ := 17 ,possiable got to succ := 5

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
ptr_25 = ptr_22 + 2;
bb index := 17
# VUSE <.MEM_11>
return i_7;
./benchmarks/tmux/leak_1/tmux_leak_1.c:96:9: warning: use location
beacuse in succ := 5 have return or exit
gimple stmt in succ := 17 ,possiable got to succ := 5

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
ptr_25 = ptr_22 + 2;
bb index := 17
# VUSE <.MEM_5>
return 0;
lto1: warning: use location
beacuse in succ := 40 have return or exit
gimple stmt in succ := 17 ,possiable got to succ := 40

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
ptr_25 = ptr_22 + 2;
bb index := 17
# VUSE <.MEM_5>
return 0;
lto1: warning: use location
beacuse in succ := 40 have return or exit
gimple stmt in succ := 17 ,possiable got to succ := 40

======================================================================

======================================================================
[40;31m    collect Stmt in loop [0m

======================================================================
ptr_25 = ptr_22 + 2;
./benchmarks/tmux/leak_1/tmux_leak_1.c:118:8: warning: use location
    ptr += 2;
        ^

======================================================================
[40;31m    collect Stmt in loop [0m

======================================================================
_24 = MEM[(u_char *)ptr_22 + 1B];
./benchmarks/tmux/leak_1/tmux_leak_1.c:117:27: warning: use location
   if (ptr[0] == '#' && ptr[1] == '[') {
                           ^

======================================================================
[40;31m    collect Stmt in loop [0m

======================================================================
if (_24 == 91)
./benchmarks/tmux/leak_1/tmux_leak_1.c:117:21: warning: use location
   if (ptr[0] == '#' && ptr[1] == '[') {
                     ^
if (_24 == 91)

 ================== find cond branch ================= 
./benchmarks/tmux/leak_1/tmux_leak_1.c:117:21: warning: use location
Cond in fucntion main basic block 16
 ================== possible direct basic block ================= 
from main basic block 17
 ================== possible direct basic block ================= 
from main basic block 19
 ================== warring ================== 
[40;35m    need check this branch possible have return or exit stmt [0m

 ================== warring ================== 

 ================== find cond branch ================= 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# VUSE <.MEM_94>
_23 = *ptr_22;
bb index := 15
# VUSE <.MEM_11>
return i_7;
./benchmarks/tmux/leak_1/tmux_leak_1.c:96:9: warning: use location
  return i;
         ^
beacuse in succ := 5 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 5

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# VUSE <.MEM_94>
_23 = *ptr_22;
bb index := 15
# VUSE <.MEM_5>
return 0;
lto1: warning: use location
beacuse in succ := 40 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 40

======================================================================

======================================================================
[40;31m    collect Stmt in loop [0m

======================================================================
_23 = *ptr_22;
./benchmarks/tmux/leak_1/tmux_leak_1.c:117:10: warning: use location
   if (ptr[0] == '#' && ptr[1] == '[') {
          ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
if (_23 == 35)
bb index := 15
# VUSE <.MEM_11>
return i_7;
./benchmarks/tmux/leak_1/tmux_leak_1.c:96:9: warning: use location
  return i;
         ^
beacuse in succ := 5 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 5

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
if (_23 == 35)
bb index := 15
# VUSE <.MEM_5>
return 0;
lto1: warning: use location
beacuse in succ := 40 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 40

======================================================================

======================================================================
[40;31m    collect Stmt in loop [0m

======================================================================
if (_23 == 35)
./benchmarks/tmux/leak_1/tmux_leak_1.c:117:6: warning: use location
   if (ptr[0] == '#' && ptr[1] == '[') {
      ^
if (_23 == 35)

 ================== find cond branch ================= 
./benchmarks/tmux/leak_1/tmux_leak_1.c:117:6: warning: use location
Cond in fucntion main basic block 15
 ================== possible direct basic block ================= 
from main basic block 16
 ================== possible direct basic block ================= 
from main basic block 19
 ================== warring ================== 
[40;35m    need check this branch possible have return or exit stmt [0m

 ================== warring ================== 

 ================== find cond branch ================= 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_107 = VDEF <.MEM_94>
*last_27 = 0;
bb index := 18
# VUSE <.MEM_11>
return i_7;
./benchmarks/tmux/leak_1/tmux_leak_1.c:96:9: warning: use location
  return i;
         ^
beacuse in succ := 5 have return or exit
gimple stmt in succ := 18 ,possiable got to succ := 5

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_107 = VDEF <.MEM_94>
*last_27 = 0;
bb index := 18
# VUSE <.MEM_5>
return 0;
lto1: warning: use location
beacuse in succ := 40 have return or exit
gimple stmt in succ := 18 ,possiable got to succ := 40

======================================================================

======================================================================
[40;31m    collect Stmt in loop [0m

======================================================================
*last_27 = 0;
./benchmarks/tmux/leak_1/tmux_leak_1.c:124:10: warning: use location
    *last = '\0';
          ^

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7f9b11547900
    type <pointer_type 0x7f9b11528c78
        type <integer_type 0x7f9b1150b150 u_char public unsigned string-flag QI
            size <integer_cst 0x7f9b119d8cd8 constant 8>
            unit size <integer_cst 0x7f9b119d8cf0 constant 1>
            align 8 symtab 0 alias set -1 canonical type 0x7f9b119ec3f0 precision 8 min <integer_cst 0x7f9b119d8d08 0> max <integer_cst 0x7f9b119d8ca8 255> context <translation_unit_decl 0x7f9b119e3168 ./benchmarks/tmux/leak_1/tmux_leak_1.c>
            pointer_to_this <pointer_type 0x7f9b11528c78>>
        public unsigned DI
        size <integer_cst 0x7f9b119d8be8 constant 64>
        unit size <integer_cst 0x7f9b119d8c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality>
    var <var_decl 0x7f9b11543a20 ptr>
    def_stmt ptr_25 = ptr_22 + 2;
    version 25
    ptr-info 0x7f9b115329d8>
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_101 = VDEF <.MEM_100>
free (_85);
./benchmarks/tmux/leak_1/tmux_leak_1.c:185:2: warning: use location
  free(msg);
  ^
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_102 = VDEF <.MEM_101>
free (msg2_64);
./benchmarks/tmux/leak_1/tmux_leak_1.c:186:2: warning: use location
  free(msg2);
  ^
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_108 = VDEF <.MEM_94>
free (_57);
./benchmarks/tmux/leak_1/tmux_leak_1.c:158:2: warning: use location
  free(msg);
  ^

 ================== Start Use after free Check ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_101 = VDEF <.MEM_100>
free (_85);
./benchmarks/tmux/leak_1/tmux_leak_1.c:185:2: warning: Use after free error!: free location 
  free(msg);
  ^
# VUSE <.MEM_94>
_26 = strcspn (ptr_25, "]");
./benchmarks/tmux/leak_1/tmux_leak_1.c:119:17: warning: use location
    last = ptr + strcspn(ptr, "]");
                 ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_102 = VDEF <.MEM_101>
free (msg2_64);
./benchmarks/tmux/leak_1/tmux_leak_1.c:186:2: warning: Use after free error!: free location 
  free(msg2);
  ^
# VUSE <.MEM_94>
_26 = strcspn (ptr_25, "]");
./benchmarks/tmux/leak_1/tmux_leak_1.c:119:17: warning: use location
    last = ptr + strcspn(ptr, "]");
                 ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_101 = VDEF <.MEM_100>
free (_85);
./benchmarks/tmux/leak_1/tmux_leak_1.c:185:2: warning: Use after free error!: free location 
  free(msg);
  ^
last_27 = ptr_25 + _26;
./benchmarks/tmux/leak_1/tmux_leak_1.c:119:9: warning: use location
    last = ptr + strcspn(ptr, "]");
         ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_102 = VDEF <.MEM_101>
free (msg2_64);
./benchmarks/tmux/leak_1/tmux_leak_1.c:186:2: warning: Use after free error!: free location 
  free(msg2);
  ^
last_27 = ptr_25 + _26;
./benchmarks/tmux/leak_1/tmux_leak_1.c:119:9: warning: use location
    last = ptr + strcspn(ptr, "]");
         ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_101 = VDEF <.MEM_100>
free (_85);
./benchmarks/tmux/leak_1/tmux_leak_1.c:185:2: warning: Use after free error!: free location 
  free(msg);
  ^
ptr_29 = last_27 + 1;
./benchmarks/tmux/leak_1/tmux_leak_1.c:126:8: warning: use location
    ptr = last + 1;
        ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_102 = VDEF <.MEM_101>
free (msg2_64);
./benchmarks/tmux/leak_1/tmux_leak_1.c:186:2: warning: Use after free error!: free location 
  free(msg2);
  ^
ptr_29 = last_27 + 1;
./benchmarks/tmux/leak_1/tmux_leak_1.c:126:8: warning: use location
    ptr = last + 1;
        ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_101 = VDEF <.MEM_100>
free (_85);
./benchmarks/tmux/leak_1/tmux_leak_1.c:185:2: warning: Use after free error!: free location 
  free(msg);
  ^
ptr_59 = PHI <ptr_29(18), ptr_37(22), ptr_37(27), ptr_55(32)>
lto1: warning: use location

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_102 = VDEF <.MEM_101>
free (msg2_64);
./benchmarks/tmux/leak_1/tmux_leak_1.c:186:2: warning: Use after free error!: free location 
  free(msg2);
  ^
ptr_59 = PHI <ptr_29(18), ptr_37(22), ptr_37(27), ptr_55(32)>
lto1: warning: use location

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_108 = VDEF <.MEM_94>
free (_57);
./benchmarks/tmux/leak_1/tmux_leak_1.c:158:2: warning: Use after free error!: free location 
  free(msg);
  ^
ptr_59 = PHI <ptr_29(18), ptr_37(22), ptr_37(27), ptr_55(32)>
lto1: warning: use location

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_101 = VDEF <.MEM_100>
free (_85);
./benchmarks/tmux/leak_1/tmux_leak_1.c:185:2: warning: Use after free error!: free location 
  free(msg);
  ^
ptr_22 = PHI <ptr_21(14), ptr_59(33)>
lto1: warning: use location

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_102 = VDEF <.MEM_101>
free (msg2_64);
./benchmarks/tmux/leak_1/tmux_leak_1.c:186:2: warning: Use after free error!: free location 
  free(msg2);
  ^
ptr_22 = PHI <ptr_21(14), ptr_59(33)>
lto1: warning: use location

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_108 = VDEF <.MEM_94>
free (_57);
./benchmarks/tmux/leak_1/tmux_leak_1.c:158:2: warning: Use after free error!: free location 
  free(msg);
  ^
ptr_22 = PHI <ptr_21(14), ptr_59(33)>
lto1: warning: use location

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_101 = VDEF <.MEM_100>
free (_85);
./benchmarks/tmux/leak_1/tmux_leak_1.c:185:2: warning: Use after free error!: free location 
  free(msg);
  ^
# VUSE <.MEM_94>
_56 = *ptr_22;
./benchmarks/tmux/leak_1/tmux_leak_1.c:116:9: warning: use location
  while (*ptr != '\0') {
         ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_102 = VDEF <.MEM_101>
free (msg2_64);
./benchmarks/tmux/leak_1/tmux_leak_1.c:186:2: warning: Use after free error!: free location 
  free(msg2);
  ^
# VUSE <.MEM_94>
_56 = *ptr_22;
./benchmarks/tmux/leak_1/tmux_leak_1.c:116:9: warning: use location
  while (*ptr != '\0') {
         ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_101 = VDEF <.MEM_100>
free (_85);
./benchmarks/tmux/leak_1/tmux_leak_1.c:185:2: warning: Use after free error!: free location 
  free(msg);
  ^
if (_56 != 0)
./benchmarks/tmux/leak_1/tmux_leak_1.c:116:8: warning: use location
  while (*ptr != '\0') {
        ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_102 = VDEF <.MEM_101>
free (msg2_64);
./benchmarks/tmux/leak_1/tmux_leak_1.c:186:2: warning: Use after free error!: free location 
  free(msg2);
  ^
if (_56 != 0)
./benchmarks/tmux/leak_1/tmux_leak_1.c:116:8: warning: use location
  while (*ptr != '\0') {
        ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_101 = VDEF <.MEM_100>
free (_85);
./benchmarks/tmux/leak_1/tmux_leak_1.c:185:2: warning: Use after free error!: free location 
  free(msg);
  ^
ptr_55 = ptr_22 + 1;
./benchmarks/tmux/leak_1/tmux_leak_1.c:154:7: warning: use location
    ptr++;
       ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_102 = VDEF <.MEM_101>
free (msg2_64);
./benchmarks/tmux/leak_1/tmux_leak_1.c:186:2: warning: Use after free error!: free location 
  free(msg2);
  ^
ptr_55 = ptr_22 + 1;
./benchmarks/tmux/leak_1/tmux_leak_1.c:154:7: warning: use location
    ptr++;
       ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_101 = VDEF <.MEM_100>
free (_85);
./benchmarks/tmux/leak_1/tmux_leak_1.c:185:2: warning: Use after free error!: free location 
  free(msg);
  ^
# VUSE <.MEM_94>
_52 = *ptr_22;
./benchmarks/tmux/leak_1/tmux_leak_1.c:151:8: warning: use location
    if (*ptr > 0x1f && *ptr < 0x7f) {
        ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_102 = VDEF <.MEM_101>
free (msg2_64);
./benchmarks/tmux/leak_1/tmux_leak_1.c:186:2: warning: Use after free error!: free location 
  free(msg2);
  ^
# VUSE <.MEM_94>
_52 = *ptr_22;
./benchmarks/tmux/leak_1/tmux_leak_1.c:151:8: warning: use location
    if (*ptr > 0x1f && *ptr < 0x7f) {
        ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_101 = VDEF <.MEM_100>
free (_85);
./benchmarks/tmux/leak_1/tmux_leak_1.c:185:2: warning: Use after free error!: free location 
  free(msg);
  ^
ptr_37 = &MEM[(void *)ptr_22 + 2B];
./benchmarks/tmux/leak_1/tmux_leak_1.c:136:7: warning: use location
    ptr++;
       ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_102 = VDEF <.MEM_101>
free (msg2_64);
./benchmarks/tmux/leak_1/tmux_leak_1.c:186:2: warning: Use after free error!: free location 
  free(msg2);
  ^
ptr_37 = &MEM[(void *)ptr_22 + 2B];
./benchmarks/tmux/leak_1/tmux_leak_1.c:136:7: warning: use location
    ptr++;
       ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_101 = VDEF <.MEM_100>
free (_85);
./benchmarks/tmux/leak_1/tmux_leak_1.c:185:2: warning: Use after free error!: free location 
  free(msg);
  ^
ptr_32 = ptr_22 + 1;
./benchmarks/tmux/leak_1/tmux_leak_1.c:131:7: warning: use location
    ptr++;
       ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_102 = VDEF <.MEM_101>
free (msg2_64);
./benchmarks/tmux/leak_1/tmux_leak_1.c:186:2: warning: Use after free error!: free location 
  free(msg2);
  ^
ptr_32 = ptr_22 + 1;
./benchmarks/tmux/leak_1/tmux_leak_1.c:131:7: warning: use location
    ptr++;
       ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_101 = VDEF <.MEM_100>
free (_85);
./benchmarks/tmux/leak_1/tmux_leak_1.c:185:2: warning: Use after free error!: free location 
  free(msg);
  ^
# VUSE <.MEM_94>
left_33 = strlen (ptr_32);
./benchmarks/tmux/leak_1/tmux_leak_1.c:133:9: warning: use location
    left = strlen(ptr);
         ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_102 = VDEF <.MEM_101>
free (msg2_64);
./benchmarks/tmux/leak_1/tmux_leak_1.c:186:2: warning: Use after free error!: free location 
  free(msg2);
  ^
# VUSE <.MEM_94>
left_33 = strlen (ptr_32);
./benchmarks/tmux/leak_1/tmux_leak_1.c:133:9: warning: use location
    left = strlen(ptr);
         ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_101 = VDEF <.MEM_100>
free (_85);
./benchmarks/tmux/leak_1/tmux_leak_1.c:185:2: warning: Use after free error!: free location 
  free(msg);
  ^
if (left_33 < _36)
./benchmarks/tmux/leak_1/tmux_leak_1.c:134:7: warning: use location
    if (left < (size_t)ud->size - 1)
       ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_102 = VDEF <.MEM_101>
free (msg2_64);
./benchmarks/tmux/leak_1/tmux_leak_1.c:186:2: warning: Use after free error!: free location 
  free(msg2);
  ^
if (left_33 < _36)
./benchmarks/tmux/leak_1/tmux_leak_1.c:134:7: warning: use location
    if (left < (size_t)ud->size - 1)
       ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_101 = VDEF <.MEM_100>
free (_85);
./benchmarks/tmux/leak_1/tmux_leak_1.c:185:2: warning: Use after free error!: free location 
  free(msg);
  ^
# VUSE <.MEM_94>
_30 = *ptr_22;
./benchmarks/tmux/leak_1/tmux_leak_1.c:130:7: warning: use location
   if (*ptr > 0x7f) {
       ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_102 = VDEF <.MEM_101>
free (msg2_64);
./benchmarks/tmux/leak_1/tmux_leak_1.c:186:2: warning: Use after free error!: free location 
  free(msg2);
  ^
# VUSE <.MEM_94>
_30 = *ptr_22;
./benchmarks/tmux/leak_1/tmux_leak_1.c:130:7: warning: use location
   if (*ptr > 0x7f) {
       ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_101 = VDEF <.MEM_100>
free (_85);
./benchmarks/tmux/leak_1/tmux_leak_1.c:185:2: warning: Use after free error!: free location 
  free(msg);
  ^
_31 = (signed char) _30;
./benchmarks/tmux/leak_1/tmux_leak_1.c:130:12: warning: use location
   if (*ptr > 0x7f) {
            ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_102 = VDEF <.MEM_101>
free (msg2_64);
./benchmarks/tmux/leak_1/tmux_leak_1.c:186:2: warning: Use after free error!: free location 
  free(msg2);
  ^
_31 = (signed char) _30;
./benchmarks/tmux/leak_1/tmux_leak_1.c:130:12: warning: use location
   if (*ptr > 0x7f) {
            ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_101 = VDEF <.MEM_100>
free (_85);
./benchmarks/tmux/leak_1/tmux_leak_1.c:185:2: warning: Use after free error!: free location 
  free(msg);
  ^
if (_31 < 0)
./benchmarks/tmux/leak_1/tmux_leak_1.c:130:6: warning: use location
   if (*ptr > 0x7f) {
      ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_102 = VDEF <.MEM_101>
free (msg2_64);
./benchmarks/tmux/leak_1/tmux_leak_1.c:186:2: warning: Use after free error!: free location 
  free(msg2);
  ^
if (_31 < 0)
./benchmarks/tmux/leak_1/tmux_leak_1.c:130:6: warning: use location
   if (*ptr > 0x7f) {
      ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_101 = VDEF <.MEM_100>
free (_85);
./benchmarks/tmux/leak_1/tmux_leak_1.c:185:2: warning: Use after free error!: free location 
  free(msg);
  ^
ptr_25 = ptr_22 + 2;
./benchmarks/tmux/leak_1/tmux_leak_1.c:118:8: warning: use location
    ptr += 2;
        ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_102 = VDEF <.MEM_101>
free (msg2_64);
./benchmarks/tmux/leak_1/tmux_leak_1.c:186:2: warning: Use after free error!: free location 
  free(msg2);
  ^
ptr_25 = ptr_22 + 2;
./benchmarks/tmux/leak_1/tmux_leak_1.c:118:8: warning: use location
    ptr += 2;
        ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_101 = VDEF <.MEM_100>
free (_85);
./benchmarks/tmux/leak_1/tmux_leak_1.c:185:2: warning: Use after free error!: free location 
  free(msg);
  ^
# VUSE <.MEM_94>
_24 = MEM[(u_char *)ptr_22 + 1B];
./benchmarks/tmux/leak_1/tmux_leak_1.c:117:27: warning: use location
   if (ptr[0] == '#' && ptr[1] == '[') {
                           ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_102 = VDEF <.MEM_101>
free (msg2_64);
./benchmarks/tmux/leak_1/tmux_leak_1.c:186:2: warning: Use after free error!: free location 
  free(msg2);
  ^
# VUSE <.MEM_94>
_24 = MEM[(u_char *)ptr_22 + 1B];
./benchmarks/tmux/leak_1/tmux_leak_1.c:117:27: warning: use location
   if (ptr[0] == '#' && ptr[1] == '[') {
                           ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_101 = VDEF <.MEM_100>
free (_85);
./benchmarks/tmux/leak_1/tmux_leak_1.c:185:2: warning: Use after free error!: free location 
  free(msg);
  ^
if (_24 == 91)
./benchmarks/tmux/leak_1/tmux_leak_1.c:117:21: warning: use location
   if (ptr[0] == '#' && ptr[1] == '[') {
                     ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_102 = VDEF <.MEM_101>
free (msg2_64);
./benchmarks/tmux/leak_1/tmux_leak_1.c:186:2: warning: Use after free error!: free location 
  free(msg2);
  ^
if (_24 == 91)
./benchmarks/tmux/leak_1/tmux_leak_1.c:117:21: warning: use location
   if (ptr[0] == '#' && ptr[1] == '[') {
                     ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_101 = VDEF <.MEM_100>
free (_85);
./benchmarks/tmux/leak_1/tmux_leak_1.c:185:2: warning: Use after free error!: free location 
  free(msg);
  ^
# VUSE <.MEM_94>
_23 = *ptr_22;
./benchmarks/tmux/leak_1/tmux_leak_1.c:117:10: warning: use location
   if (ptr[0] == '#' && ptr[1] == '[') {
          ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_102 = VDEF <.MEM_101>
free (msg2_64);
./benchmarks/tmux/leak_1/tmux_leak_1.c:186:2: warning: Use after free error!: free location 
  free(msg2);
  ^
# VUSE <.MEM_94>
_23 = *ptr_22;
./benchmarks/tmux/leak_1/tmux_leak_1.c:117:10: warning: use location
   if (ptr[0] == '#' && ptr[1] == '[') {
          ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_101 = VDEF <.MEM_100>
free (_85);
./benchmarks/tmux/leak_1/tmux_leak_1.c:185:2: warning: Use after free error!: free location 
  free(msg);
  ^
if (_23 == 35)
./benchmarks/tmux/leak_1/tmux_leak_1.c:117:6: warning: use location
   if (ptr[0] == '#' && ptr[1] == '[') {
      ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_102 = VDEF <.MEM_101>
free (msg2_64);
./benchmarks/tmux/leak_1/tmux_leak_1.c:186:2: warning: Use after free error!: free location 
  free(msg2);
  ^
if (_23 == 35)
./benchmarks/tmux/leak_1/tmux_leak_1.c:117:6: warning: use location
   if (ptr[0] == '#' && ptr[1] == '[') {
      ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_101 = VDEF <.MEM_100>
free (_85);
./benchmarks/tmux/leak_1/tmux_leak_1.c:185:2: warning: Use after free error!: free location 
  free(msg);
  ^
# .MEM_107 = VDEF <.MEM_94>
*last_27 = 0;
./benchmarks/tmux/leak_1/tmux_leak_1.c:124:10: warning: use location
    *last = '\0';
          ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_102 = VDEF <.MEM_101>
free (msg2_64);
./benchmarks/tmux/leak_1/tmux_leak_1.c:186:2: warning: Use after free error!: free location 
  free(msg2);
  ^
# .MEM_107 = VDEF <.MEM_94>
*last_27 = 0;
./benchmarks/tmux/leak_1/tmux_leak_1.c:124:10: warning: use location
    *last = '\0';
          ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:3 [0m

======================================================================

======================================================================
[40;31m 	this stmt need double check [0m

======================================================================

dot graph START

======================================================================
 <ssa_name 0x7f9b11547af8
    type <pointer_type 0x7f9b11528c78
        type <integer_type 0x7f9b1150b150 u_char public unsigned string-flag QI
            size <integer_cst 0x7f9b119d8cd8 constant 8>
            unit size <integer_cst 0x7f9b119d8cf0 constant 1>
            align 8 symtab 0 alias set -1 canonical type 0x7f9b119ec3f0 precision 8 min <integer_cst 0x7f9b119d8d08 0> max <integer_cst 0x7f9b119d8ca8 255> context <translation_unit_decl 0x7f9b119e3168 ./benchmarks/tmux/leak_1/tmux_leak_1.c>
            pointer_to_this <pointer_type 0x7f9b11528c78>>
        public unsigned DI
        size <integer_cst 0x7f9b119d8be8 constant 64>
        unit size <integer_cst 0x7f9b119d8c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality>
    var <var_decl 0x7f9b11543a20 ptr>
    def_stmt ptr_32 = ptr_22 + 1;
    version 32
    ptr-info 0x7f9b11532a20>
ptr_32 = ptr_22 + 1;

 ================== trace ptable================== 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr--------
this other function -----------

======================================================================
[40;35m  	Looserules free count:0 [0m

======================================================================

======================================================================
[40;31m 	Can't find this fucntion in Pointer table [0m
[40;31m 	Possiable no other stmt relate with this stmt [0m

======================================================================
[40;33m =======POP node_fun stack:main========= [0m
fucntion collect path finsh

=============== The third stage : detection  End=================

===============Print ALL GIMPLE IR=================
=======Mapping node_fun:xvasprintf=========
=======is loop:0=========

 bb index 2 
<bb 2> [100.00%]:
i_7 = vasprintf (ret_3(D), fmt_4(D), ap_5(D));
if (i_7 < 0)
  goto <bb 4>; [0.04%]
else
  goto <bb 3>; [99.96%]

=======is loop:0=========

 bb index 3 
<bb 3> [99.96%]:
_1 = *ret_3(D);
if (_1 == 0B)
  goto <bb 4>; [0.04%]
else
  goto <bb 5>; [99.96%]

=======is loop:0=========

 bb index 4 
<bb 4> [0.08%]:
_9 = __printf_chk (1, "xasprintf: %s", "");
exit (1);

=======is loop:0=========

 bb index 5 
<bb 5> [99.92%]:
return i_7;

=======Mapping node_fun:main=========
=======is loop:0=========

 bb index 2 
<bb 2> [12.38%]:
_6 = &wp.status_screen;
memcpy (&old, _6, 136);
wp.status_screen.mode = 0;
_8 = strlen (fmt_7(D));
out_9 = malloc (_8);
xvasprintf (&msg, "%s", out_9);
_61 = msg;
_62 = strlen (_61);
_63 = _62 + 1;
msg2_64 = malloc (_63);
ptr_65 = msg;
ptr2_66 = msg2_64;
goto <bb 13>; [100.00%]

=======is loop:1=========

 bb index 3 
<bb 3> [70.15%]:
_68 = *ptr_67;
if (_68 == 35)
  goto <bb 4>; [34.00%]
else
  goto <bb 11>; [66.00%]

=======is loop:1=========

 bb index 4 
<bb 4> [23.85%]:
_69 = MEM[(char *)ptr_67 + 1B];
if (_69 == 91)
  goto <bb 5>; [11.56%]
else
  goto <bb 11>; [88.44%]

=======is loop:1=========

 bb index 5 
<bb 5> [2.76%]:
goto <bb 7>; [100.00%]

=======is loop:1=========

 bb index 6 
<bb 6> [15.62%]:
ptr_71 = ptr_70 + 1;

=======is loop:1=========

 bb index 7 
<bb 7> [18.38%]:
# ptr_70 = PHI <ptr_67(5), ptr_71(6)>
_72 = *ptr_70;
_73 = _72 != 93;
_74 = _72 != 0;
_75 = _73 & _74;
if (_75 != 0)
  goto <bb 6>; [85.00%]
else
  goto <bb 8>; [15.00%]

=======is loop:1=========

 bb index 8 
<bb 8> [2.76%]:
_76 = *ptr_70;
if (_76 == 93)
  goto <bb 9>; [34.00%]
else
  goto <bb 10>; [66.00%]

=======is loop:1=========

 bb index 9 
<bb 9> [0.94%]:
ptr_77 = ptr_70 + 1;

=======is loop:1=========

 bb index 10 
<bb 10> [2.76%]:
# ptr_88 = PHI <ptr_70(8), ptr_77(9)>
// predicted unlikely by continue predictor.
goto <bb 12>; [100.00%]

=======is loop:1=========

 bb index 11 
<bb 11> [67.39%]:
_78 = ptr_67;
ptr_79 = ptr_67 + 1;
_81 = ptr2_80;
ptr2_82 = ptr2_80 + 1;
_83 = *_78;
*_81 = _83;

=======is loop:1=========

 bb index 12 
<bb 12> [70.15%]:
# ptr_89 = PHI <ptr_88(10), ptr_79(11)>
# ptr2_90 = PHI <ptr2_80(10), ptr2_82(11)>

=======is loop:1=========

 bb index 13 
<bb 13> [82.53%]:
# ptr_67 = PHI <ptr_65(2), ptr_89(12)>
# ptr2_80 = PHI <msg2_64(2), ptr2_90(12)>
_84 = *ptr_67;
if (_84 != 0)
  goto <bb 3>; [85.00%]
else
  goto <bb 14>; [15.00%]

=======is loop:0=========

 bb index 14 
<bb 14> [12.38%]:
*ptr2_80 = 0;
_85 = msg;
free (_85);
free (msg2_64);
_87 = size_86(D);
msg ={v} {CLOBBER};
_104 = size_86(D);
outlen_10 = _104;
_11 = (long int) outlen_10;
MEM[(char * {ref-all})&gc] = MEM[(char * {ref-all})&gc];
xvasprintf (&msg, "%s", out_9);
ptr_21 = msg;
goto <bb 34>; [100.00%]

=======is loop:1=========

 bb index 15 
<bb 15> [97.00%]:
_23 = *ptr_22;
if (_23 == 35)
  goto <bb 16>; [34.00%]
else
  goto <bb 19>; [66.00%]

=======is loop:1=========

 bb index 16 
<bb 16> [32.98%]:
_24 = MEM[(u_char *)ptr_22 + 1B];
if (_24 == 91)
  goto <bb 17>; [34.00%]
else
  goto <bb 19>; [66.00%]

=======is loop:1=========

 bb index 17 
<bb 17> [11.21%]:
ptr_25 = ptr_22 + 2;
_26 = strcspn (ptr_25, "]");
last_27 = ptr_25 + _26;
_28 = *last_27;
if (_28 == 0)
  goto <bb 35>; [63.36%]
else
  goto <bb 18>; [36.64%]

=======is loop:1=========

 bb index 18 
<bb 18> [4.11%]:
*last_27 = 0;
ptr_29 = last_27 + 1;
// predicted unlikely by continue predictor.
goto <bb 33>; [100.00%]

=======is loop:1=========

 bb index 19 
<bb 19> [85.79%]:
_30 = *ptr_22;
_31 = (signed char) _30;
if (_31 < 0)
  goto <bb 20>; [36.00%]
else
  goto <bb 28>; [64.00%]

=======is loop:1=========

 bb index 20 
<bb 20> [30.88%]:
ptr_32 = ptr_22 + 1;
left_33 = strlen (ptr_32);
_34 = MEM[(struct utf8_data *)&gc + 12B].size;
_35 = (long unsigned int) _34;
_36 = _35 + 18446744073709551615;
if (left_33 < _36)
  goto <bb 35>; [3.00%]
else
  goto <bb 21>; [97.00%]

=======is loop:1=========

 bb index 21 
<bb 21> [29.96%]:
ptr_37 = &MEM[(void *)ptr_22 + 2B];
if (more_38(D) != 1)
  goto <bb 22>; [48.88%]
else
  goto <bb 23>; [51.12%]

=======is loop:1=========

 bb index 22 
<bb 22> [14.64%]:
// predicted unlikely by continue predictor.
goto <bb 33>; [100.00%]

=======is loop:1=========

 bb index 23 
<bb 23> [15.31%]:
if (_11 > 0)
  goto <bb 24>; [64.00%]
else
  goto <bb 27>; [36.00%]

=======is loop:1=========

 bb index 24 
<bb 24> [9.80%]:
_39 = MEM[(struct utf8_data *)&gc + 12B].width;
_40 = (long unsigned int) _39;
_42 = _40 + size_41;
_43 = (long unsigned int) _11;
if (_42 > _43)
  goto <bb 26>; [3.00%]
else
  goto <bb 27>; [97.00%]

=======is loop:1=========

 bb index 25 
<bb 25> [1.67%]:
size_45 = size_44 + 1;

=======is loop:1=========

 bb index 26 
<bb 26> [1.96%]:
# size_44 = PHI <size_41(24), size_45(25)>
_46 = (long unsigned int) _11;
if (size_44 < _46)
  goto <bb 25>; [85.00%]
else
  goto <bb 35>; [15.00%]

=======is loop:1=========

 bb index 27 
<bb 27> [15.02%]:
_47 = MEM[(struct utf8_data *)&gc + 12B].width;
_48 = (long unsigned int) _47;
size_49 = size_41 + _48;
goto <bb 33>; [100.00%]

=======is loop:1=========

 bb index 28 
<bb 28> [54.90%]:
if (_11 > 0)
  goto <bb 29>; [64.00%]
else
  goto <bb 30>; [36.00%]

=======is loop:1=========

 bb index 29 
<bb 29> [35.14%]:
_50 = size_41 + 1;
_51 = (long unsigned int) _11;
if (_50 > _51)
  goto <bb 35>; [3.00%]
else
  goto <bb 30>; [97.00%]

=======is loop:1=========

 bb index 30 
<bb 30> [53.85%]:
_52 = *ptr_22;
_53 = _52 + 224;
if (_53 <= 94)
  goto <bb 31>; [50.00%]
else
  goto <bb 32>; [50.00%]

=======is loop:1=========

 bb index 31 
<bb 31> [26.92%]:
size_54 = size_41 + 1;

=======is loop:1=========

 bb index 32 
<bb 32> [53.85%]:
# size_58 = PHI <size_41(30), size_54(31)>
ptr_55 = ptr_22 + 1;

=======is loop:1=========

 bb index 33 
<bb 33> [87.62%]:
# ptr_59 = PHI <ptr_29(18), ptr_37(22), ptr_37(27), ptr_55(32)>
# size_60 = PHI <size_41(18), size_41(22), size_49(27), size_58(32)>

=======is loop:1=========

 bb index 34 
<bb 34> [100.00%]:
# ptr_22 = PHI <ptr_21(14), ptr_59(33)>
# size_41 = PHI <0(14), size_60(33)>
_56 = *ptr_22;
if (_56 != 0)
  goto <bb 15>; [97.00%]
else
  goto <bb 35>; [3.00%]

=======is loop:0=========

 bb index 35 
<bb 35> [12.38%]:
_57 = msg;
free (_57);
gc ={v} {CLOBBER};
msg ={v} {CLOBBER};
_12 = old.grid;
_13 = wp.status_screen.grid;
_16 = _13->sx;
_17 = _12->sx;
if (_16 != _17)
  goto <bb 38>; [62.32%]
else
  goto <bb 36>; [37.68%]

=======is loop:0=========

 bb index 36 
<bb 36> [4.66%]:
_18 = _13->sy;
_19 = _12->sy;
if (_18 != _19)
  goto <bb 38>; [62.32%]
else
  goto <bb 37>; [37.68%]

=======is loop:0=========

 bb index 37 
<bb 37> [1.76%]:

=======is loop:0=========

 bb index 38 
<bb 38> [12.38%]:
# _20 = PHI <1(35), 1(36), 0(37)>
_111 = _20;
_14 = _111;
if (_14 == 0)
  goto <bb 40>; [46.00%]
else
  goto <bb 39>; [54.00%]

=======is loop:0=========

 bb index 39 
<bb 39> [6.68%]:

=======is loop:0=========

 bb index 40 
<bb 40> [12.38%]:
# _15 = PHI <0(38), 1(39)>
gc ={v} {CLOBBER};
old ={v} {CLOBBER};
_115 = _15;
wp ={v} {CLOBBER};
return 0;


===============Print ALL GIMPLE IR=================
[40;32mSTART CHECKSTART CHECKSTART CHECKSTART CHECKSTART CHECK[0m
    =()=
 ,/'_||_
  (___  `.
 ./  `=='
                   
    ~~~~~~~~~~~  
 ~~~~~~
           ~~~~~~~
[40;34m    find Entry point : 8 [0m
[40;34m    used_stmt array stack totalsize of : 1408 [0m
[40;34m    collect time: : 0.000105 s [0m
[40;34m    algorithm time: 0.019166 s [0m
[40;34m    gimple stmt count : : 120 [0m
[40;32mSTART CHECKSTART CHECKSTART CHECKSTART CHECKSTART CHECK[0m
