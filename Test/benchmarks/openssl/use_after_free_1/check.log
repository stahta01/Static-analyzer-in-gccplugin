../Compiler/newplugin.so 11.2.0 
./benchmarks/openssl/use_after_free_1/openssl_uaf_1.c: In function ‘getrn’:
./benchmarks/openssl/use_after_free_1/openssl_uaf_1.c:87:23: warning: passing argument 1 of ‘CRYPTO_atomic_add’ from incompatible pointer type [-Wincompatible-pointer-types]
   87 |     CRYPTO_atomic_add(&lh->num_hash_calls, 1, &scratch);
      |                       ^~~~~~~~~~~~~~~~~~~
      |                       |
      |                       long unsigned int *
./benchmarks/openssl/use_after_free_1/openssl_uaf_1.c:70:28: note: expected ‘int *’ but argument is of type ‘long unsigned int *’
   70 | int CRYPTO_atomic_add(int *val, int amount, int *ret)
      |                       ~~~~~^~~
./benchmarks/openssl/use_after_free_1/openssl_uaf_1.c:97:27: warning: passing argument 1 of ‘CRYPTO_atomic_add’ from incompatible pointer type [-Wincompatible-pointer-types]
   97 |         CRYPTO_atomic_add(&lh->num_hash_comps, 1, &scratch);
      |                           ^~~~~~~~~~~~~~~~~~~
      |                           |
      |                           long unsigned int *
./benchmarks/openssl/use_after_free_1/openssl_uaf_1.c:70:28: note: expected ‘int *’ but argument is of type ‘long unsigned int *’
   70 | int CRYPTO_atomic_add(int *val, int amount, int *ret)
      |                       ~~~~~^~~
./benchmarks/openssl/use_after_free_1/openssl_uaf_1.c:102:27: warning: passing argument 1 of ‘CRYPTO_atomic_add’ from incompatible pointer type [-Wincompatible-pointer-types]
  102 |         CRYPTO_atomic_add(&lh->num_comp_calls, 1, &scratch);
      |                           ^~~~~~~~~~~~~~~~~~~
      |                           |
      |                           long unsigned int *
./benchmarks/openssl/use_after_free_1/openssl_uaf_1.c:70:28: note: expected ‘int *’ but argument is of type ‘long unsigned int *’
   70 | int CRYPTO_atomic_add(int *val, int amount, int *ret)
      |                       ~~~~~^~~
./benchmarks/openssl/use_after_free_1/openssl_uaf_1.c: In function ‘lh_CONF_VALUE_new’:
./benchmarks/openssl/use_after_free_1/openssl_uaf_1.c:139:12: warning: returning ‘OPENSSL_LHASH *’ {aka ‘struct lhash_st *’} from a function with incompatible return type ‘CONF_VALUE *’ [-Wincompatible-pointer-types]
  139 |     return (ret);
      |            ^
./benchmarks/openssl/use_after_free_1/openssl_uaf_1.c: In function ‘lh_CONF_VALUE_retrieve’:
./benchmarks/openssl/use_after_free_1/openssl_uaf_1.c:158:27: warning: passing argument 1 of ‘CRYPTO_atomic_add’ from incompatible pointer type [-Wincompatible-pointer-types]
  158 |         CRYPTO_atomic_add(&lh->num_retrieve_miss, 1, &scratch);
      |                           ^~~~~~~~~~~~~~~~~~~~~~
      |                           |
      |                           long unsigned int *
./benchmarks/openssl/use_after_free_1/openssl_uaf_1.c:70:28: note: expected ‘int *’ but argument is of type ‘long unsigned int *’
   70 | int CRYPTO_atomic_add(int *val, int amount, int *ret)
      |                       ~~~~~^~~
./benchmarks/openssl/use_after_free_1/openssl_uaf_1.c:162:27: warning: passing argument 1 of ‘CRYPTO_atomic_add’ from incompatible pointer type [-Wincompatible-pointer-types]
  162 |         CRYPTO_atomic_add(&lh->num_retrieve, 1, &scratch);
      |                           ^~~~~~~~~~~~~~~~~
      |                           |
      |                           long unsigned int *
./benchmarks/openssl/use_after_free_1/openssl_uaf_1.c:70:28: note: expected ‘int *’ but argument is of type ‘long unsigned int *’
   70 | int CRYPTO_atomic_add(int *val, int amount, int *ret)
      |                       ~~~~~^~~
./benchmarks/openssl/use_after_free_1/openssl_uaf_1.c: In function ‘_CONF_get_string’:
./benchmarks/openssl/use_after_free_1/openssl_uaf_1.c:179:44: warning: passing argument 1 of ‘lh_CONF_VALUE_retrieve’ from incompatible pointer type [-Wincompatible-pointer-types]
  179 |             v = lh_CONF_VALUE_retrieve(conf->data, &vv);
      |                                        ~~~~^~~~~~
      |                                            |
      |                                            struct lhash_st_CONF_VALUE *
./benchmarks/openssl/use_after_free_1/openssl_uaf_1.c:147:45: note: expected ‘OPENSSL_LHASH *’ {aka ‘struct lhash_st *’} but argument is of type ‘struct lhash_st_CONF_VALUE *’
  147 | void *lh_CONF_VALUE_retrieve(OPENSSL_LHASH *lh, const void *data)
      |                              ~~~~~~~~~~~~~~~^~
./benchmarks/openssl/use_after_free_1/openssl_uaf_1.c:186:40: warning: passing argument 1 of ‘lh_CONF_VALUE_retrieve’ from incompatible pointer type [-Wincompatible-pointer-types]
  186 |         v = lh_CONF_VALUE_retrieve(conf->data, &vv);
      |                                    ~~~~^~~~~~
      |                                        |
      |                                        struct lhash_st_CONF_VALUE *
./benchmarks/openssl/use_after_free_1/openssl_uaf_1.c:147:45: note: expected ‘OPENSSL_LHASH *’ {aka ‘struct lhash_st *’} but argument is of type ‘struct lhash_st_CONF_VALUE *’
  147 | void *lh_CONF_VALUE_retrieve(OPENSSL_LHASH *lh, const void *data)
      |                              ~~~~~~~~~~~~~~~^~
./benchmarks/openssl/use_after_free_1/openssl_uaf_1.c: In function ‘app_RAND_write’:
./benchmarks/openssl/use_after_free_1/openssl_uaf_1.c:224:9: warning: implicit declaration of function ‘RAND_write_file’ [-Wimplicit-function-declaration]
  224 |     if (RAND_write_file(save_rand_file) == -1) {
      |         ^~~~~~~~~~~~~~~
./benchmarks/openssl/use_after_free_1/openssl_uaf_1.c: In function ‘_CONF_new_data’:
./benchmarks/openssl/use_after_free_1/openssl_uaf_1.c:235:20: warning: assignment to ‘struct lhash_st_CONF_VALUE *’ from incompatible pointer type ‘CONF_VALUE *’ [-Wincompatible-pointer-types]
  235 |         conf->data = lh_CONF_VALUE_new();
      |                    ^
./benchmarks/openssl/use_after_free_1/openssl_uaf_1.c: In function ‘CONF_free’:
./benchmarks/openssl/use_after_free_1/openssl_uaf_1.c:247:32: warning: passing argument 1 of ‘lh_CONF_VALUE_free’ from incompatible pointer type [-Wincompatible-pointer-types]
  247 |         lh_CONF_VALUE_free(conf->data);
      |                            ~~~~^~~~~~
      |                                |
      |                                struct lhash_st_CONF_VALUE *
./benchmarks/openssl/use_after_free_1/openssl_uaf_1.c:111:40: note: expected ‘OPENSSL_LHASH *’ {aka ‘struct lhash_st *’} but argument is of type ‘struct lhash_st_CONF_VALUE *’
  111 | void lh_CONF_VALUE_free(OPENSSL_LHASH *lh)
      |                         ~~~~~~~~~~~~~~~^~

Time variable                                   usr           sys          wall           GGC
 phase setup                        :   0.01 ( 25%)   0.00 (  0%)   0.01 ( 12%)  1298k ( 36%)
 phase parsing                      :   0.03 ( 75%)   0.02 ( 67%)   0.05 ( 63%)  2011k ( 56%)
 phase opt and generate             :   0.00 (  0%)   0.01 ( 33%)   0.02 ( 25%)   251k (  7%)
 callgraph ipa passes               :   0.00 (  0%)   0.01 ( 33%)   0.01 ( 12%)   137k (  4%)
 ipa function summary               :   0.00 (  0%)   0.01 ( 33%)   0.00 (  0%)    21k (  1%)
 lto stream output                  :   0.00 (  0%)   0.00 (  0%)   0.01 ( 12%)     0  (  0%)
 preprocessing                      :   0.00 (  0%)   0.01 ( 33%)   0.01 ( 12%)  1087k ( 30%)
 lexical analysis                   :   0.01 ( 25%)   0.01 ( 33%)   0.03 ( 38%)     0  (  0%)
 parser struct body                 :   0.01 ( 25%)   0.00 (  0%)   0.00 (  0%)   107k (  3%)
 parser function body               :   0.01 ( 25%)   0.00 (  0%)   0.00 (  0%)   116k (  3%)
 parser inl. func. body             :   0.00 (  0%)   0.00 (  0%)   0.01 ( 12%)  8640  (  0%)
 tree CFG cleanup                   :   0.00 (  0%)   0.00 (  0%)   0.01 ( 12%)     0  (  0%)
 TOTAL                              :   0.04          0.03          0.08         3571k
../Compiler/newplugin.so 11.2.0 

Time variable                                   usr           sys          wall           GGC
 phase setup                        :   0.00 (  0%)   0.00 (  0%)   0.01 (100%)  2157k ( 97%)
 TOTAL                              :   0.00          0.00          0.01         2223k
../Compiler/newplugin.so 11.2.0 
--------plugin argument-----------
contextsentive 1
debugoutput 0
debugmod 0
=======ipa_pta=========
=============== The first stage : Point of interest stmt collect =================
=======node_fun:main=========
=======node_fun:foo=========
=======node_fun:CONF_new=========
=======node_fun:CONF_free=========
=======node_fun:_CONF_new_data=========
=======node_fun:app_RAND_write=========
=======node_fun:app_RAND_load_conf=========
=======node_fun:NCONF_get_string=========
=======node_fun:_CONF_get_string=========
=======node_fun:lh_CONF_VALUE_retrieve=========
=======node_fun:lh_CONF_VALUE_new=========
=======node_fun:lh_CONF_VALUE_free=========
=======node_fun:getrn=========
=======node_fun:CRYPTO_atomic_add=========
=============== The first stage :  record fucntion =================
start PointerConstraint
ptable point 45 
===============The second stage : Mapping stmt=================
# .MEM_2 = VDEF <.MEM_1(D)>
foo ();
# .MEM_3 = VDEF <.MEM_2>
app_RAND_write ();
# .MEM_8 = VDEF <.MEM_7(D)>
conf_5 = CONF_new ();
# .MEM_10 = VDEF <.MEM_9>
_1 = _CONF_new_data (conf_5);
# .MEM_11 = VDEF <.MEM_10>
app_RAND_load_conf (conf_5, "section");
# .MEM_12 = VDEF <.MEM_6>
CONF_free (conf_5);
# .MEM_5 = VDEF <.MEM_4(D)>
ret_3 = malloc (16);
# .MEM_7 = VDEF <.MEM_6(D)>
lh_CONF_VALUE_free (_2);
# .MEM_9 = VDEF <.MEM_8(D)>
_2 = lh_CONF_VALUE_new ();
# .MEM_6 = VDEF <.MEM_5(D)>
_3 = RAND_write_file (_2);
# .MEM_7 = VDEF <.MEM_6>
__builtin_puts (&"RAND_write_file error"[0]);
# .MEM_10 = VDEF <.MEM_9(D)>
randfile_7 = NCONF_get_string (c_4(D), section_5(D), "RANDFILE");
# .MEM_9 = VDEF <.MEM_8(D)>
s_7 = _CONF_get_string (conf_3(D), group_4(D), name_5(D));
# .MEM_29 = VDEF <.MEM_28>
v_19 = lh_CONF_VALUE_retrieve (_1, &vv);
# .MEM_26 = VDEF <.MEM_25>
v_14 = lh_CONF_VALUE_retrieve (_2, &vv);
# .MEM_23 = VDEF <.MEM_22(D)>
_9 = getenv (name_5(D));
# .MEM_17 = VDEF <.MEM_16>
rn_12 = getrn (lh_8(D), data_10(D), &hash);
# .MEM_19 = VDEF <.MEM_17>
CRYPTO_atomic_add (_2, 1, &scratch);
# .MEM_18 = VDEF <.MEM_17>
CRYPTO_atomic_add (_4, 1, &scratch);
# .MEM_11 = VDEF <.MEM_10(D)>
ret_8 = malloc (176);
# .MEM_12 = VDEF <.MEM_11>
_1 = malloc (8);
# .MEM_49 = VDEF <.MEM_48>
CRYPTO_atomic_add (_2, 1, &scratch);
# .MEM_51 = VDEF <.MEM_45>
CRYPTO_atomic_add (_13, 1, &scratch);
# .MEM_52 = VDEF <.MEM_51>
CRYPTO_atomic_add (_15, 1, &scratch);
===============The second stage : Program slicing=================
===============The second stage : build fucntion type=================
[40;41mSTART CHECKSTART CHECKSTART CHECKSTART CHECKSTART CHECK[0m
[40;41mSTART CHECKSTART CHECKSTART CHECKSTART CHECKSTART CHECK[0m
    =()=
 ,/'_||_
  (___  `.
 ./  `=='
      |||
      |||
      |||
      |||
[40;41mSTART CHECKSTART CHECKSTART CHECKSTART CHECKSTART CHECK[0m
[40;41mSTART CHECKSTART CHECKSTART CHECKSTART CHECKSTART CHECK[0m

=============== The third stage : Start detection  =================

=============== The third stage : detection  End=================

===============Print ALL GIMPLE IR=================
=======Mapping node_fun:main=========
=======is loop:0=========

 bb index 2 
<bb 2> [local count: 1073741824]:
foo ();
app_RAND_write ();
return 0;

=======Mapping node_fun:foo=========
=======is loop:0=========

 bb index 2 
<bb 2> [local count: 1073741823]:
conf_5 = CONF_new ();
if (conf_5 == 0B)
  goto <bb 3>; [0.04%]
else
  goto <bb 4>; [99.96%]

=======is loop:0=========

 bb index 3 
<bb 3> [local count: 429496]:
// predicted unlikely by goto predictor.
goto <bb 7>; [100.00%]

=======is loop:0=========

 bb index 4 
<bb 4> [local count: 1073312327]:
conf_5->data = 0B;
_1 = _CONF_new_data (conf_5);
if (_1 == 0)
  goto <bb 5>; [51.12%]
else
  goto <bb 6>; [48.88%]

=======is loop:0=========

 bb index 5 
<bb 5> [local count: 548677266]:
// predicted unlikely by goto predictor.
goto <bb 7>; [100.00%]

=======is loop:0=========

 bb index 6 
<bb 6> [local count: 524635062]:
app_RAND_load_conf (conf_5, "section");

=======is loop:0=========

 bb index 7 
<bb 7> [local count: 1073741824]:
end:
CONF_free (conf_5);
return;

=======Mapping node_fun:CONF_new=========
=======is loop:0=========

 bb index 2 
<bb 2> [local count: 1073741824]:
ret_3 = malloc (16);
return ret_3;

=======Mapping node_fun:CONF_free=========
=======is loop:0=========

 bb index 2 
<bb 2> [local count: 1073741824]:
if (conf_4(D) == 0B)
  goto <bb 5>; [18.09%]
else
  goto <bb 3>; [81.91%]

=======is loop:0=========

 bb index 3 
<bb 3> [local count: 879501929]:
_1 = conf_4(D)->data;
if (_1 == 0B)
  goto <bb 5>; [30.95%]
else
  goto <bb 4>; [69.05%]

=======is loop:0=========

 bb index 4 
<bb 4> [local count: 607296081]:
_2 = conf_4(D)->data;
lh_CONF_VALUE_free (_2);
free (conf_4(D));

=======is loop:0=========

 bb index 5 
<bb 5> [local count: 1073741824]:
return;

=======Mapping node_fun:_CONF_new_data=========
=======is loop:0=========

 bb index 2 
<bb 2> [local count: 1073741824]:
if (conf_6(D) == 0B)
  goto <bb 6>; [18.09%]
else
  goto <bb 3>; [81.91%]

=======is loop:0=========

 bb index 3 
<bb 3> [local count: 879501929]:
_1 = conf_6(D)->data;
if (_1 == 0B)
  goto <bb 4>; [17.43%]
else
  goto <bb 6>; [82.57%]

=======is loop:0=========

 bb index 4 
<bb 4> [local count: 153297186]:
_2 = lh_CONF_VALUE_new ();
conf_6(D)->data = _2;
_3 = conf_6(D)->data;
if (_3 == 0B)
  goto <bb 5>; [18.09%]
else
  goto <bb 6>; [81.91%]

=======is loop:0=========

 bb index 5 
<bb 5> [local count: 27731461]:

=======is loop:0=========

 bb index 6 
<bb 6> [local count: 1073741824]:
# _4 = PHI <0(2), 1(3), 1(4), 0(5)>
return _4;

=======Mapping node_fun:app_RAND_write=========
=======is loop:0=========

 bb index 2 
<bb 2> [local count: 1073741824]:
_1 = save_rand_file;
if (_1 == 0B)
  goto <bb 5>; [30.95%]
else
  goto <bb 3>; [69.05%]

=======is loop:0=========

 bb index 3 
<bb 3> [local count: 741418729]:
_2 = save_rand_file;
_3 = RAND_write_file (_2);
if (_3 == -1)
  goto <bb 4>; [20.24%]
else
  goto <bb 5>; [79.76%]

=======is loop:0=========

 bb index 4 
<bb 4> [local count: 150063150]:
__builtin_puts (&"RAND_write_file error"[0]);

=======is loop:0=========

 bb index 5 
<bb 5> [local count: 1073741824]:
return;

=======Mapping node_fun:app_RAND_load_conf=========
=======is loop:0=========

 bb index 2 
<bb 2> [local count: 1073741824]:
randfile_7 = NCONF_get_string (c_4(D), section_5(D), "RANDFILE");
if (randfile_7 == 0B)
  goto <bb 5>; [18.09%]
else
  goto <bb 3>; [81.91%]

=======is loop:0=========

 bb index 3 
<bb 3> [local count: 879501929]:
_1 = save_rand_file;
if (_1 == 0B)
  goto <bb 4>; [30.00%]
else
  goto <bb 5>; [70.00%]

=======is loop:0=========

 bb index 4 
<bb 4> [local count: 263850576]:
save_rand_file = randfile_7;

=======is loop:0=========

 bb index 5 
<bb 5> [local count: 1073741824]:
return;

=======Mapping node_fun:NCONF_get_string=========
=======is loop:0=========

 bb index 2 
<bb 2> [local count: 1073741824]:
s_7 = _CONF_get_string (conf_3(D), group_4(D), name_5(D));
if (s_7 != 0B)
  goto <bb 4>; [54.59%]
else
  goto <bb 3>; [45.41%]

=======is loop:0=========

 bb index 3 
<bb 3> [local count: 487586160]:

=======is loop:0=========

 bb index 4 
<bb 4> [local count: 1073741824]:
# _1 = PHI <s_7(2), 0B(3)>
return _1;

=======Mapping node_fun:_CONF_get_string=========
=======is loop:0=========

 bb index 2 
<bb 2> [local count: 1073741824]:
if (name_5(D) == 0B)
  goto <bb 10>; [8.27%]
else
  goto <bb 3>; [91.73%]

=======is loop:0=========

 bb index 3 
<bb 3> [local count: 984943377]:
if (conf_6(D) != 0B)
  goto <bb 4>; [90.19%]
else
  goto <bb 9>; [9.81%]

=======is loop:0=========

 bb index 4 
<bb 4> [local count: 888320433]:
if (section_10(D) != 0B)
  goto <bb 5>; [70.00%]
else
  goto <bb 7>; [30.00%]

=======is loop:0=========

 bb index 5 
<bb 5> [local count: 621824306]:
vv.name = name_5(D);
vv.section = section_10(D);
_1 = conf_6(D)->data;
v_19 = lh_CONF_VALUE_retrieve (_1, &vv);
if (v_19 != 0B)
  goto <bb 6>; [85.10%]
else
  goto <bb 10>; [14.90%]

=======is loop:0=========

 bb index 6 
<bb 6> [local count: 529172486]:
_20 = v_19->value;
goto <bb 10>; [100.00%]

=======is loop:0=========

 bb index 7 
<bb 7> [local count: 266496127]:
vv.section = "default";
vv.name = name_5(D);
_2 = conf_6(D)->data;
v_14 = lh_CONF_VALUE_retrieve (_2, &vv);
if (v_14 != 0B)
  goto <bb 8>; [85.10%]
else
  goto <bb 10>; [14.90%]

=======is loop:0=========

 bb index 8 
<bb 8> [local count: 226788205]:
_15 = v_14->value;
goto <bb 10>; [100.00%]

=======is loop:0=========

 bb index 9 
<bb 9> [local count: 96622944]:
_9 = getenv (name_5(D));

=======is loop:0=========

 bb index 10 
<bb 10> [local count: 1073741824]:
# _3 = PHI <0B(2), 0B(5), _20(6), 0B(7), _15(8), _9(9)>
vv ={v} {CLOBBER};
return _3;

=======Mapping node_fun:lh_CONF_VALUE_retrieve=========
=======is loop:0=========

 bb index 2 
<bb 2> [local count: 1073741824]:
lh_8(D)->error = 0;
rn_12 = getrn (lh_8(D), data_10(D), &hash);
_1 = *rn_12;
if (_1 == 0B)
  goto <bb 3>; [8.27%]
else
  goto <bb 4>; [91.73%]

=======is loop:0=========

 bb index 3 
<bb 3> [local count: 88798448]:
_2 = &lh_8(D)->num_retrieve_miss;
CRYPTO_atomic_add (_2, 1, &scratch);
goto <bb 5>; [100.00%]

=======is loop:0=========

 bb index 4 
<bb 4> [local count: 984943377]:
_3 = *rn_12;
ret_13 = _3->data;
_4 = &lh_8(D)->num_retrieve;
CRYPTO_atomic_add (_4, 1, &scratch);

=======is loop:0=========

 bb index 5 
<bb 5> [local count: 1073741824]:
# _5 = PHI <0B(3), ret_13(4)>
hash ={v} {CLOBBER};
scratch ={v} {CLOBBER};
return _5;

=======Mapping node_fun:lh_CONF_VALUE_new=========
=======is loop:0=========

 bb index 2 
<bb 2> [local count: 1073741824]:
ret_8 = malloc (176);
if (ret_8 == 0B)
  goto <bb 5>; [0.04%]
else
  goto <bb 3>; [99.96%]

=======is loop:0=========

 bb index 3 
<bb 3> [local count: 1073312329]:
_1 = malloc (8);
ret_8->b = _1;
_2 = ret_8->b;
if (_2 == 0B)
  goto <bb 4>; [4.25%]
else
  goto <bb 5>; [95.75%]

=======is loop:0=========

 bb index 4 
<bb 4> [local count: 45615770]:
// predicted unlikely by goto predictor.
_3 = ret_8->b;
free (_3);
free (ret_8);

=======is loop:0=========

 bb index 5 
<bb 5> [local count: 1073741824]:
# _4 = PHI <0B(2), ret_8(3), 0B(4)>
return _4;

=======Mapping node_fun:lh_CONF_VALUE_free=========
=======is loop:0=========

 bb index 2 
<bb 2> [local count: 17822076]:
if (lh_12(D) == 0B)
  goto <bb 9>; [18.09%]
else
  goto <bb 10>; [81.91%]

=======is loop:0=========

 bb index 10 
<bb 10> [local count: 14598062]:
goto <bb 7>; [100.00%]

=======is loop:1=========

 bb index 3 
<bb 3> [local count: 118111600]:
_1 = lh_12(D)->b;
_2 = (long unsigned int) i_7;
_3 = _2 * 8;
_4 = _1 + _3;
n_16 = *_4;
goto <bb 5>; [100.00%]

=======is loop:1=========

 bb index 4 
<bb 4> [local count: 955630226]:
nn_18 = n_8->next;
free (n_8);

=======is loop:1=========

 bb index 5 
<bb 5> [local count: 1073741824]:
# n_8 = PHI <n_16(3), nn_18(4)>
if (n_8 != 0B)
  goto <bb 4>; [89.00%]
else
  goto <bb 6>; [11.00%]

=======is loop:1=========

 bb index 6 
<bb 6> [local count: 118111600]:
i_17 = i_7 + 1;

=======is loop:1=========

 bb index 7 
<bb 7> [local count: 132709663]:
# i_7 = PHI <0(10), i_17(6)>
_5 = lh_12(D)->num_nodes;
if (_5 > i_7)
  goto <bb 3>; [89.00%]
else
  goto <bb 8>; [11.00%]

=======is loop:0=========

 bb index 8 
<bb 8> [local count: 14598063]:
_6 = lh_12(D)->b;
free (_6);
free (lh_12(D));

=======is loop:0=========

 bb index 9 
<bb 9> [local count: 17822076]:
return;

=======Mapping node_fun:getrn=========
=======is loop:0=========

 bb index 2 
<bb 2> [local count: 78030428]:
_1 = lh_26(D)->hash;
hash_29 = _1 (data_27(D));
_2 = &lh_26(D)->num_hash_calls;
CRYPTO_atomic_add (_2, 1, &scratch);
*rhash_31(D) = hash_29;
_3 = lh_26(D)->pmax;
_4 = (long unsigned int) _3;
nn_33 = hash_29 % _4;
_5 = lh_26(D)->p;
_6 = (long unsigned int) _5;
if (_6 > nn_33)
  goto <bb 3>; [50.00%]
else
  goto <bb 4>; [50.00%]

=======is loop:0=========

 bb index 3 
<bb 3> [local count: 39015214]:
_7 = lh_26(D)->num_alloc_nodes;
_8 = (long unsigned int) _7;
nn_34 = hash_29 % _8;

=======is loop:0=========

 bb index 4 
<bb 4> [local count: 78030428]:
# nn_21 = PHI <nn_33(2), nn_34(3)>
cf_35 = lh_26(D)->comp;
_9 = lh_26(D)->b;
_10 = (int) nn_21;
_11 = (long unsigned int) _10;
_12 = _11 * 8;
ret_36 = _9 + _12;
n1_37 = *ret_36;
goto <bb 10>; [100.00%]

=======is loop:1=========

 bb index 5 
<bb 5> [local count: 1014686025]:
_13 = &lh_26(D)->num_hash_comps;
CRYPTO_atomic_add (_13, 1, &scratch);
_14 = n1_20->hash;
if (_14 != hash_29)
  goto <bb 6>; [66.00%]
else
  goto <bb 7>; [34.00%]

=======is loop:1=========

 bb index 6 
<bb 6> [local count: 669692774]:
ret_42 = &n1_20->next;
// predicted unlikely by continue predictor.
goto <bb 9>; [100.00%]

=======is loop:1=========

 bb index 7 
<bb 7> [local count: 344993252]:
_15 = &lh_26(D)->num_comp_calls;
CRYPTO_atomic_add (_15, 1, &scratch);
_16 = n1_20->data;
_17 = cf_35 (_16, data_27(D));
if (_17 == 0)
  goto <bb 11>; [5.50%]
else
  goto <bb 8>; [94.50%]

=======is loop:1=========

 bb index 8 
<bb 8> [local count: 326018623]:
ret_41 = &n1_20->next;

=======is loop:1=========

 bb index 9 
<bb 9> [local count: 995711397]:
# ret_18 = PHI <ret_42(6), ret_41(8)>
n1_43 = n1_20->next;

=======is loop:1=========

 bb index 10 
<bb 10> [local count: 1073741824]:
# ret_19 = PHI <ret_36(4), ret_18(9)>
# n1_20 = PHI <n1_37(4), n1_43(9)>
if (n1_20 != 0B)
  goto <bb 5>; [94.50%]
else
  goto <bb 11>; [5.50%]

=======is loop:0=========

 bb index 11 
<bb 11> [local count: 78030429]:
scratch ={v} {CLOBBER};
return ret_19;

=======Mapping node_fun:CRYPTO_atomic_add=========
=======is loop:0=========

 bb index 2 
<bb 2> [local count: 1073741824]:
_1 = *val_5(D);
_2 = _1 + amount_6(D);
*val_5(D) = _2;
_3 = *val_5(D);
*ret_8(D) = _3;
return 1;


===============Print ALL GIMPLE IR=================
[40;32mSTART CHECKSTART CHECKSTART CHECKSTART CHECKSTART CHECK[0m
[40;32mSTART CHECKSTART CHECKSTART CHECKSTART CHECKSTART CHECK[0m
    =()=
 ,/'_||_
  (___  `.
 ./  `=='
                   
    ~~~~~~~~~~~  
 ~~~~~~
           ~~~~~~~
[40;34m    gimple malloc count : 3 [0m
[40;34m    gimple free   count : 6 [0m
[40;34m    all ptable point : 45 [0m
[40;34m    analyzable ptable point : 38 [0m
[40;34m    analyzable ptable all point stmt : 108 [0m
[40;34m    used_stmt array stack totalsize of : 0.003248 mb[0m
[40;34m    collect time: : 0.000825 s [0m
[40;34m    mapping time: : 0.001007 s [0m
[40;34m    algorithm time: 0.010640 s [0m
[40;34m    gimple stmt count : : 148 [0m
[40;34m    this report analysis in Sun Jun 26 13:53:31 2022
 [0m
[40;32mSTART CHECKSTART CHECKSTART CHECKSTART CHECKSTART CHECK[0m
[40;32mSTART CHECKSTART CHECKSTART CHECKSTART CHECKSTART CHECK[0m

Time variable                                   usr           sys          wall           GGC
 phase setup                        :   0.00 (  0%)   0.01 (100%)   0.00 (  0%)  2157k ( 69%)
 phase opt and generate             :   0.05 (100%)   0.00 (  0%)   0.06 (100%)   926k ( 29%)
 callgraph functions expansion      :   0.04 ( 80%)   0.00 (  0%)   0.04 ( 67%)   760k ( 24%)
 df live regs                       :   0.01 ( 20%)   0.00 (  0%)   0.00 (  0%)     0  (  0%)
 rebuild jump labels                :   0.00 (  0%)   0.00 (  0%)   0.01 ( 17%)     0  (  0%)
 dominator optimization             :   0.01 ( 20%)   0.00 (  0%)   0.02 ( 33%)    19k (  1%)
 expand                             :   0.01 ( 20%)   0.00 (  0%)   0.00 (  0%)    75k (  2%)
 if-conversion                      :   0.00 (  0%)   0.00 (  0%)   0.01 ( 17%)  1320  (  0%)
 plugin execution                   :   0.01 ( 20%)   0.00 (  0%)   0.02 ( 33%)  2920  (  0%)
 rest of compilation                :   0.01 ( 20%)   0.00 (  0%)   0.00 (  0%)    37k (  1%)
 TOTAL                              :   0.05          0.01          0.06         3144k
/usr/bin/ld: /tmp/ccjBy14y.ltrans0.ltrans.o: in function `app_RAND_write':
<artificial>:(.text+0x348): undefined reference to `RAND_write_file'
collect2: error: ld returned 1 exit status
