
;; Function printf (printf, funcdef_no=15, decl_uid=798, cgraph_uid=15, symbol_order=15)

__attribute__((__artificial__, __gnu_inline__, __always_inline__))
printf (const char * restrict __fmt)
{
  int _4;

  <bb 2> [0.00%]:
  _4 = __printf_chk (1, __fmt_2(D), __builtin_va_arg_pack ());
  return _4;

}



;; Function lstat (lstat, funcdef_no=40, decl_uid=3041, cgraph_uid=40, symbol_order=40)

__attribute__((__gnu_inline__, __leaf__, __nothrow__))
lstat (const char * __path, struct stat * __statbuf)
{
  int _5;

  <bb 2> [0.00%]:
  _5 = __lxstat (1, __path_2(D), __statbuf_3(D));
  return _5;

}



;; Function strbuf_swap (strbuf_swap, funcdef_no=48, decl_uid=3408, cgraph_uid=48, symbol_order=49)

No longer having address taken: _swap_buffer
strbuf_swap (struct strbuf * a, struct strbuf * b)
{
  unsigned char _swap_buffer[24];
  void * _swap_b_ptr;
  void * _swap_a_ptr;

  <bb 2> [0.00%]:
  MEM[(char * {ref-all})&_swap_buffer] = MEM[(char * {ref-all})a_1(D)];
  memcpy (a_1(D), b_3(D), 24);
  MEM[(char * {ref-all})b_3(D)] = MEM[(char * {ref-all})&_swap_buffer];
  _swap_buffer ={v} {CLOBBER};
  return;

}



;; Function xrealloc (xrealloc, funcdef_no=49, decl_uid=3416, cgraph_uid=49, symbol_order=50)

xrealloc (void * ptr, size_t size)
{
  int D.3725;
  void * ret;
  _Bool _1;
  _Bool _2;
  _Bool _3;
  _Bool _4;
  _Bool _5;
  _Bool _6;
  void * _26;
  int _27;

  <bb 2> [0.00%]:
  ret_17 = realloc (ptr_14(D), size_15(D));
  _1 = ret_17 == 0B;
  _2 = size_15(D) == 0;
  _3 = _1 & _2;
  if (_3 != 0)
    goto <bb 3>; [0.00%]
  else
    goto <bb 4>; [0.00%]

  <bb 3> [0.00%]:
  ret_19 = realloc (ptr_14(D), 1);

  <bb 4> [0.00%]:
  # ret_7 = PHI <ret_17(2), ret_19(3)>
  if (ret_7 == 0B)
    goto <bb 5>; [0.00%]
  else
    goto <bb 9>; [0.00%]

  <bb 5> [0.00%]:
  ret_21 = realloc (ptr_14(D), size_15(D));
  _4 = ret_21 == 0B;
  _5 = size_15(D) == 0;
  _6 = _4 & _5;
  if (_6 != 0)
    goto <bb 6>; [0.00%]
  else
    goto <bb 7>; [0.00%]

  <bb 6> [0.00%]:
  ret_23 = realloc (ptr_14(D), 1);

  <bb 7> [0.00%]:
  # ret_8 = PHI <ret_21(5), ret_23(6)>
  if (ret_8 == 0B)
    goto <bb 8>; [0.00%]
  else
    goto <bb 9>; [0.00%]

  <bb 8> [100.00%]:
  _27 = __printf_chk (1, "Out of memory, realloc failed%s", "");
  exit (1);

  <bb 9> [0.00%]:
  # ret_9 = PHI <ret_7(4), ret_8(7)>
  _26 = ret_9;
  return _26;

}



;; Function strbuf_grow (strbuf_grow, funcdef_no=50, decl_uid=3453, cgraph_uid=50, symbol_order=51)

strbuf_grow (struct strbuf * sb, size_t extra)
{
  int D.3731;
  int new_buf;
  long unsigned int _1;
  _Bool _2;
  int _3;
  long unsigned int _4;
  long unsigned int _5;
  int _6;
  long unsigned int _7;
  long unsigned int _8;
  long unsigned int _9;
  long unsigned int _10;
  long unsigned int _11;
  int _12;
  long unsigned int _13;
  long unsigned int _14;
  long unsigned int _15;
  long unsigned int _16;
  long unsigned int _17;
  long unsigned int _18;
  long unsigned int _19;
  long unsigned int _20;
  int _21;
  long unsigned int _22;
  long unsigned int _23;
  int _24;
  long unsigned int _25;
  char * _26;
  void * _27;
  char * _28;
  int _51;

  <bb 2> [0.00%]:
  _1 = sb_35(D)->alloc;
  _2 = _1 == 0;
  new_buf_36 = (int) _2;
  _3 = unsigned_add_overflows (extra_37(D), 1);
  if (_3 != 0)
    goto <bb 4>; [0.00%]
  else
    goto <bb 3>; [0.00%]

  <bb 3> [0.00%]:
  _4 = extra_37(D) + 1;
  _5 = sb_35(D)->len;
  _6 = unsigned_add_overflows (_5, _4);
  if (_6 != 0)
    goto <bb 4>; [0.00%]
  else
    goto <bb 5>; [0.00%]

  <bb 4> [100.00%]:
  _51 = __printf_chk (1, "you want to use way too much memory%s", "");
  exit (1);

  <bb 5> [0.00%]:
  if (new_buf_36 != 0)
    goto <bb 6>; [0.00%]
  else
    goto <bb 7>; [0.00%]

  <bb 6> [0.00%]:
  sb_35(D)->buf = 0B;

  <bb 7> [0.00%]:
  _7 = sb_35(D)->len;
  _8 = extra_37(D) + _7;
  _9 = _8 + 1;
  _10 = sb_35(D)->alloc;
  if (_9 > _10)
    goto <bb 8>; [0.00%]
  else
    goto <bb 12>; [0.00%]

  <bb 8> [0.00%]:
  _11 = sb_35(D)->alloc;
  _12 = alloc_nr (_11);
  _13 = (long unsigned int) _12;
  _14 = sb_35(D)->len;
  _15 = extra_37(D) + _14;
  _16 = _15 + 1;
  if (_13 < _16)
    goto <bb 9>; [0.00%]
  else
    goto <bb 10>; [0.00%]

  <bb 9> [0.00%]:
  _17 = sb_35(D)->len;
  _18 = extra_37(D) + _17;
  _19 = _18 + 1;
  sb_35(D)->alloc = _19;
  goto <bb 11>; [0.00%]

  <bb 10> [0.00%]:
  _20 = sb_35(D)->alloc;
  _21 = alloc_nr (_20);
  _22 = (long unsigned int) _21;
  sb_35(D)->alloc = _22;

  <bb 11> [0.00%]:
  _23 = sb_35(D)->alloc;
  _24 = st_mult (1, _23);
  _25 = (long unsigned int) _24;
  _26 = sb_35(D)->buf;
  _27 = xrealloc (_26, _25);
  sb_35(D)->buf = _27;

  <bb 12> [0.00%]:
  if (new_buf_36 != 0)
    goto <bb 13>; [0.00%]
  else
    goto <bb 14>; [0.00%]

  <bb 13> [0.00%]:
  _28 = sb_35(D)->buf;
  *_28 = 0;

  <bb 14> [0.00%]:
  return;

}



;; Function strbuf_release (strbuf_release, funcdef_no=51, decl_uid=3462, cgraph_uid=51, symbol_order=52)

strbuf_release (struct strbuf * sb)
{
  long unsigned int _1;
  char * _2;

  <bb 2> [0.00%]:
  _1 = sb_5(D)->alloc;
  if (_1 != 0)
    goto <bb 3>; [0.00%]
  else
    goto <bb 4>; [0.00%]

  <bb 3> [0.00%]:
  _2 = sb_5(D)->buf;
  free (_2);
  strbuf_init (sb_5(D), 0);

  <bb 4> [0.00%]:
  return;

}



;; Function strbuf_readlink (strbuf_readlink, funcdef_no=52, decl_uid=3469, cgraph_uid=52, symbol_order=53)

strbuf_readlink (struct strbuf * sb, const char * path, size_t hint)
{
  int len;
  size_t oldalloc;
  char * _1;
  int * _2;
  int _3;
  long unsigned int _4;
  int _6;

  <bb 2> [0.00%]:
  oldalloc_13 = sb_12(D)->alloc;
  if (hint_14(D) <= 31)
    goto <bb 3>; [0.00%]
  else
    goto <bb 9>; [0.00%]

  <bb 3> [0.00%]:
  goto <bb 9>; [0.00%]

  <bb 4> [0.00%]:
  strbuf_grow (sb_12(D), hint_5);
  _1 = sb_12(D)->buf;
  len_19 = readlink (path_17(D), _1, hint_5);
  if (len_19 < 0)
    goto <bb 5>; [0.00%]
  else
    goto <bb 6>; [0.00%]

  <bb 5> [0.00%]:
  _2 = __errno_location ();
  _3 = *_2;
  if (_3 != 34)
    goto <bb 11>; [0.00%]
  else
    goto <bb 8>; [0.00%]

  <bb 6> [0.00%]:
  _4 = (long unsigned int) len_19;
  if (hint_5 > _4)
    goto <bb 7>; [0.00%]
  else
    goto <bb 8>; [0.00%]

  <bb 7> [0.00%]:
  strbuf_setlen (sb_12(D), len_19);
  goto <bb 14>; [0.00%]

  <bb 8> [0.00%]:
  hint_22 = hint_5 * 2;
  goto <bb 10>; [0.00%]

  <bb 9> [0.00%]:
  # hint_25 = PHI <32(3), hint_14(D)(2)>

  <bb 10> [0.00%]:
  # hint_5 = PHI <hint_25(9), hint_22(8)>
  if (hint_5 <= 8191)
    goto <bb 4>; [0.00%]
  else
    goto <bb 11>; [0.00%]

  <bb 11> [0.00%]:
  if (oldalloc_13 == 0)
    goto <bb 12>; [0.00%]
  else
    goto <bb 13>; [0.00%]

  <bb 12> [0.00%]:
  strbuf_release (sb_12(D));

  <bb 13> [0.00%]:

  <bb 14> [0.00%]:
  # _6 = PHI <0(7), -1(13)>
  return _6;

}



;; Function files_read_raw_ref (files_read_raw_ref, funcdef_no=53, decl_uid=3485, cgraph_uid=53, symbol_order=54)

Removing basic block 8
Removing basic block 25
files_read_raw_ref (struct ref_store * ref_store, const char * refname, unsigned char * sha1, struct strbuf * referent, unsigned int * type)
{
  int D.3734;
  int save_errno;
  struct stat st;
  int remaining_retries;
  int save_errno;
  int ret;
  int fd;
  const char * buf;
  const char * path;
  struct strbuf sb_path;
  struct strbuf sb_contents;
  struct files_ref_store * refs;
  int _1;
  long int _2;
  int remaining_retries.7_3;
  int * _5;
  int _6;
  int _7;
  int * _8;
  int _9;
  int * _10;
  _Bool _11;
  _Bool _12;
  _Bool _13;
  char * _14;
  int _15;
  char * _16;
  int _17;
  unsigned int _18;
  unsigned int _19;
  int _20;
  int * _21;
  int * _22;
  int _23;
  char _24;
  int _25;
  int _26;
  unsigned int _27;
  unsigned int _28;
  int _29;
  const char * _30;
  char _31;
  const char * _32;
  char _33;
  int _34;
  int _35;
  unsigned int _36;
  unsigned int _37;
  int * _38;
  int * _39;
  int * _40;
  int _95;
  int _107;

  <bb 2> [0.00%]:
  _1 = files_downcast (ref_store_48(D), 1, "read_raw_ref");
  _2 = (long int) _1;
  refs_50 = (struct files_ref_store *) _2;
  sb_contents.alloc = 0;
  sb_contents.len = 0;
  sb_contents.buf = &strbuf_slopbuf;
  sb_path.alloc = 0;
  sb_path.len = 0;
  sb_path.buf = &strbuf_slopbuf;
  *type_59(D) = 0;
  strbuf_reset (&sb_path);
  files_ref_path (refs_50, &sb_path, refname_62(D));
  path_64 = sb_path.buf;

  # remaining_retries_43 = PHI <3(2), remaining_retries_65(9)>
stat_ref [0.00%]:
  remaining_retries.7_3 = remaining_retries_43;
  remaining_retries_65 = remaining_retries.7_3 + -1;
  if (remaining_retries.7_3 <= 0)
    goto <bb 24> (out); [0.00%]
  else
    goto <bb 4>; [0.00%]

  <bb 4> [100.00%]:
  _107 = __lxstat (1, path_64, &st);
  if (_107 < 0)
    goto <bb 5>; [0.00%]
  else
    goto <bb 8>; [0.00%]

  <bb 5> [0.00%]:
  _5 = __errno_location ();
  _6 = *_5;
  if (_6 != 2)
    goto <bb 24> (out); [0.00%]
  else
    goto <bb 6>; [0.00%]

  <bb 6> [0.00%]:
  _7 = resolve_packed_ref (refs_50, refname_62(D), sha1_81(D), type_59(D));
  if (_7 != 0)
    goto <bb 7>; [0.00%]
  else
    goto <bb 24> (out); [0.00%]

  <bb 7> [0.00%]:
  _8 = __errno_location ();
  *_8 = 2;
  goto <bb 24> (out); [0.00%]

  <bb 8> [0.00%]:
  strbuf_reset (&sb_contents);
  _9 = strbuf_readlink (&sb_contents, path_64, 0);
  if (_9 < 0)
    goto <bb 9>; [0.00%]
  else
    goto <bb 10>; [0.00%]

  <bb 9> [0.00%]:
  _10 = __errno_location ();
  _95 = *_10;
  _11 = _95 == 2;
  _12 = _95 == 22;
  _13 = _11 | _12;
  if (_13 != 0)
    goto <bb 3> (stat_ref); [0.00%]
  else
    goto <bb 24> (out); [0.00%]

  <bb 10> [0.00%]:
  _14 = sb_contents.buf;
  _15 = starts_with (_14, "refs/");
  if (_15 != 0)
    goto <bb 11>; [0.00%]
  else
    goto <bb 13>; [0.00%]

  <bb 11> [0.00%]:
  _16 = sb_contents.buf;
  _17 = check_refname_format (_16, 0);
  if (_17 == 0)
    goto <bb 12>; [0.00%]
  else
    goto <bb 13>; [0.00%]

  <bb 12> [0.00%]:
  strbuf_swap (&sb_contents, referent_71(D));
  _18 = *type_59(D);
  _19 = _18 | 1;
  *type_59(D) = _19;
  goto <bb 24> (out); [0.00%]

  <bb 13> [0.00%]:
  strbuf_reset (&sb_contents);
  _20 = strbuf_read (&sb_contents, fd_76(D), 256);
  if (_20 < 0)
    goto <bb 14>; [0.00%]
  else
    goto <bb 15>; [0.00%]

  <bb 14> [0.00%]:
  _21 = __errno_location ();
  save_errno_92 = *_21;
  close (fd_76(D));
  _22 = __errno_location ();
  *_22 = save_errno_92;
  goto <bb 24> (out); [0.00%]

  <bb 15> [0.00%]:
  strbuf_rtrim (&sb_contents);
  buf_79 = sb_contents.buf;
  _23 = starts_with (buf_79, "ref:");
  if (_23 != 0)
    goto <bb 16>; [0.00%]
  else
    goto <bb 20>; [0.00%]

  <bb 16> [0.00%]:
  buf_86 = buf_79 + 4;
  goto <bb 18>; [0.00%]

  <bb 17> [0.00%]:
  buf_91 = buf_41 + 1;

  <bb 18> [0.00%]:
  # buf_41 = PHI <buf_86(16), buf_91(17)>
  _24 = *buf_41;
  _25 = (int) _24;
  _26 = isspace (_25);
  if (_26 != 0)
    goto <bb 17>; [0.00%]
  else
    goto <bb 19>; [0.00%]

  <bb 19> [0.00%]:
  strbuf_reset (referent_71(D));
  strbuf_addstr (referent_71(D), buf_41);
  _27 = *type_59(D);
  _28 = _27 | 1;
  *type_59(D) = _28;
  goto <bb 24> (out); [0.00%]

  <bb 20> [0.00%]:
  _29 = get_sha1_hex (buf_79, sha1_81(D));
  if (_29 != 0)
    goto <bb 23>; [0.00%]
  else
    goto <bb 21>; [0.00%]

  <bb 21> [0.00%]:
  _30 = buf_79 + 40;
  _31 = *_30;
  if (_31 != 0)
    goto <bb 22>; [0.00%]
  else
    goto <bb 24> (out); [0.00%]

  <bb 22> [0.00%]:
  _32 = buf_79 + 40;
  _33 = *_32;
  _34 = (int) _33;
  _35 = isspace (_34);
  if (_35 == 0)
    goto <bb 23>; [0.00%]
  else
    goto <bb 24> (out); [0.00%]

  <bb 23> [0.00%]:
  _36 = *type_59(D);
  _37 = _36 | 4;
  *type_59(D) = _37;
  _38 = __errno_location ();
  *_38 = 22;

  # ret_42 = PHI <-1(3), -1(5), -1(7), 0(6), -1(9), 0(12), -1(14), 0(19), -1(23), 0(22), 0(21)>
out [0.00%]:
  _39 = __errno_location ();
  save_errno_99 = *_39;
  strbuf_release (&sb_path);
  strbuf_release (&sb_contents);
  _40 = __errno_location ();
  *_40 = save_errno_99;
  sb_contents ={v} {CLOBBER};
  sb_path ={v} {CLOBBER};
  st ={v} {CLOBBER};
  return ret_42;

}



;; Function lock_raw_ref (lock_raw_ref, funcdef_no=54, decl_uid=3537, cgraph_uid=54, symbol_order=55)

Removing basic block 6
lock_raw_ref (struct files_ref_store * refs, const char * refname, int mustexist, const struct string_list * extras, const struct string_list * skip, struct ref_lock * * lock_p, struct strbuf * referent, unsigned int * type, struct strbuf * err)
{
  int ret;
  int attempts_remaining;
  struct strbuf ref_file;
  struct ref_lock * lock;
  char * _1;
  unsigned char[20] * _2;
  struct ref_store * _3;
  int _4;
  int * _5;
  int _6;
  int _35;

  <bb 2> [0.00%]:
  ref_file.alloc = 0;
  ref_file.len = 0;
  ref_file.buf = &strbuf_slopbuf;
  *type_15(D) = 0;
  lock_18 = calloc (1, 40);
  *lock_p_19(D) = lock_18;
  _1 = strdup (refname_21(D));
  lock_18->ref_name = _1;
  files_ref_path (refs_24(D), &ref_file, refname_21(D));
  _2 = &lock_18->old_oid.hash;
  _3 = &refs_24(D)->base;
  _4 = files_read_raw_ref (_3, refname_21(D), _2, referent_26(D), type_15(D));
  if (_4 != 0)
    goto <bb 3>; [0.00%]
  else
    goto <bb 6> (out); [0.00%]

  <bb 3> [0.00%]:
  _5 = __errno_location ();
  _6 = *_5;
  if (_6 == 2)
    goto <bb 4>; [0.00%]
  else
    goto <bb 6> (out); [0.00%]

  <bb 4> [0.00%]:
  if (mustexist_28(D) != 0)
    goto <bb 5>; [0.00%]
  else
    goto <bb 6> (out); [0.00%]

  <bb 5> [0.00%]:
  strbuf_addf (err_29(D), "unable to resolve reference \'%s\'", refname_21(D));
  unlock_ref (lock_18);
  *lock_p_19(D) = 0B;

  # ret_7 = PHI <0(3), -2(5), 0(2), 0(4)>
out [0.00%]:
  strbuf_release (&ref_file);
  _35 = ret_7;
  ref_file ={v} {CLOBBER};
  return _35;

}



;; Function lock_ref_for_update (lock_ref_for_update, funcdef_no=55, decl_uid=3557, cgraph_uid=55, symbol_order=56)

Removing basic block 4
Removing basic block 13
Removing basic block 15
Removing basic block 17
Removing basic block 26
lock_ref_for_update (struct files_ref_store * refs, struct ref_update * update, struct ref_transaction * transaction, const char * head_ref, struct string_list * affected_refnames, struct strbuf * err)
{
  char * write_err;
  char * reason;
  struct ref_lock * lock;
  int ret;
  int mustexist;
  struct strbuf referent;
  unsigned int * _1;
  const char[0:] * _2;
  int _3;
  long int _4;
  int _5;
  struct ref_lock * lock.0_6;
  unsigned int _7;
  unsigned int _8;
  unsigned int _9;
  unsigned int _10;
  struct ref_lock * lock.1_11;
  unsigned char[20] * _12;
  char * _13;
  struct ref_store * _14;
  int _15;
  unsigned int _16;
  unsigned int _17;
  int _18;
  struct ref_lock * lock.2_19;
  struct object_id * _20;
  int _21;
  char * _22;
  struct ref_lock * lock.3_23;
  struct object_id * _24;
  int _25;
  unsigned int _26;
  unsigned int _27;
  unsigned int _28;
  unsigned int _29;
  struct object_id * _30;
  struct ref_lock * lock.4_31;
  struct object_id * _32;
  int _33;
  struct object_id * _34;
  struct ref_lock * lock.5_35;
  int _36;
  int _37;
  long int _38;
  unsigned int _39;
  unsigned int _40;
  unsigned int _41;
  unsigned int _42;
  struct ref_lock * lock.6_43;
  int _44;
  int _45;

  <bb 2> [0.00%]:
  referent.alloc = 0;
  referent.len = 0;
  referent.buf = &strbuf_slopbuf;
  if (head_ref_56(D) != 0B)
    goto <bb 3>; [0.00%]
  else
    goto <bb 4>; [0.00%]

  <bb 3> [0.00%]:
  ret_62 = split_head_update (update_57(D), transaction_58(D), head_ref_56(D), affected_refnames_59(D), err_60(D));
  if (ret_62 != 0)
    goto <bb 23>; [0.00%]
  else
    goto <bb 4>; [0.00%]

  <bb 4> [0.00%]:
  _1 = &update_57(D)->type;
  _2 = &update_57(D)->refname;
  ret_67 = lock_raw_ref (refs_64(D), _2, mustexist_65(D), affected_refnames_59(D), 0B, &lock, &referent, _1, err_60(D));
  if (ret_67 != 0)
    goto <bb 5>; [0.00%]
  else
    goto <bb 6>; [0.00%]

  <bb 5> [0.00%]:
  _3 = strbuf_detach (err_60(D), 0B);
  _4 = (long int) _3;
  reason_91 = (char *) _4;
  _5 = original_update_refname (update_57(D));
  strbuf_addf (err_60(D), "cannot lock ref \'%s\': %s", _5, reason_91);
  free (reason_91);
  goto <bb 23>; [0.00%]

  <bb 6> [0.00%]:
  lock.0_6 = lock;
  update_57(D)->backend_data = lock.0_6;
  _7 = update_57(D)->type;
  _8 = _7 & 1;
  if (_8 != 0)
    goto <bb 7>; [0.00%]
  else
    goto <bb 13>; [0.00%]

  <bb 7> [0.00%]:
  _9 = update_57(D)->flags;
  _10 = _9 & 1;
  if (_10 != 0)
    goto <bb 8>; [0.00%]
  else
    goto <bb 12>; [0.00%]

  <bb 8> [0.00%]:
  lock.1_11 = lock;
  _12 = &lock.1_11->old_oid.hash;
  _13 = referent.buf;
  _14 = &refs_64(D)->base;
  _15 = refs_read_ref_full (_14, _13, 0, _12, 0B);
  if (_15 != 0)
    goto <bb 9>; [0.00%]
  else
    goto <bb 11>; [0.00%]

  <bb 9> [0.00%]:
  _16 = update_57(D)->flags;
  _17 = _16 & 16;
  if (_17 != 0)
    goto <bb 10>; [0.00%]
  else
    goto <bb 14>; [0.00%]

  <bb 10> [0.00%]:
  _18 = original_update_refname (update_57(D));
  strbuf_addf (err_60(D), "cannot lock ref \'%s\': error reading reference", _18);
  goto <bb 23>; [0.00%]

  <bb 11> [0.00%]:
  lock.2_19 = lock;
  _20 = &lock.2_19->old_oid;
  _21 = check_old_oid (update_57(D), _20, err_60(D));
  if (_21 != 0)
    goto <bb 23>; [0.00%]
  else
    goto <bb 14>; [0.00%]

  <bb 12> [0.00%]:
  _22 = referent.buf;
  ret_72 = split_symref_update (refs_64(D), update_57(D), _22, transaction_58(D), affected_refnames_59(D), err_60(D));
  if (ret_72 != 0)
    goto <bb 23>; [0.00%]
  else
    goto <bb 14>; [0.00%]

  <bb 13> [0.00%]:
  lock.3_23 = lock;
  _24 = &lock.3_23->old_oid;
  _25 = check_old_oid (update_57(D), _24, err_60(D));
  if (_25 != 0)
    goto <bb 23>; [0.00%]
  else
    goto <bb 14>; [0.00%]

  <bb 14> [0.00%]:
  _26 = BIT_FIELD_REF <*update_57(D), 32, 320>;
  _27 = _26 & 138;
  if (_27 == 8)
    goto <bb 15>; [0.00%]
  else
    goto <bb 20>; [0.00%]

  <bb 15> [0.00%]:
  _28 = update_57(D)->type;
  _29 = _28 & 1;
  if (_29 == 0)
    goto <bb 16>; [0.00%]
  else
    goto <bb 17>; [0.00%]

  <bb 16> [0.00%]:
  _30 = &update_57(D)->new_oid;
  lock.4_31 = lock;
  _32 = &lock.4_31->old_oid;
  _33 = oidcmp (_32, _30);
  if (_33 == 0)
    goto <bb 20>; [0.00%]
  else
    goto <bb 17>; [0.00%]

  <bb 17> [0.00%]:
  _34 = &update_57(D)->new_oid;
  lock.5_35 = lock;
  _36 = write_ref_to_lockfile (lock.5_35, _34, err_60(D));
  if (_36 != 0)
    goto <bb 18>; [0.00%]
  else
    goto <bb 19>; [0.00%]

  <bb 18> [0.00%]:
  _37 = strbuf_detach (err_60(D), 0B);
  _38 = (long int) _37;
  write_err_84 = (char *) _38;
  update_57(D)->backend_data = 0B;
  goto <bb 23>; [0.00%]

  <bb 19> [0.00%]:
  _39 = update_57(D)->flags;
  _40 = _39 | 32;
  update_57(D)->flags = _40;

  <bb 20> [0.00%]:
  _41 = update_57(D)->flags;
  _42 = _41 & 32;
  if (_42 == 0)
    goto <bb 21>; [0.00%]
  else
    goto <bb 22>; [0.00%]

  <bb 21> [0.00%]:
  lock.6_43 = lock;
  _44 = close_ref (lock.6_43);
  if (_44 != 0)
    goto <bb 23>; [0.00%]
  else
    goto <bb 22>; [0.00%]

  <bb 22> [0.00%]:

  <bb 23> [0.00%]:
  # _45 = PHI <ret_62(3), ret_67(5), -1(10), -2(11), ret_72(12), -2(13), -2(18), -2(21), 0(22)>
  referent ={v} {CLOBBER};
  lock ={v} {CLOBBER};
  return _45;

}



;; Function main (main, funcdef_no=56, decl_uid=3589, cgraph_uid=56, symbol_order=57)

main ()
{
  struct strbuf err;
  struct string_list affected_refnames;
  char * head_ref;
  struct ref_transaction transaction;
  struct ref_update update;
  struct files_ref_store refs;

  <bb 2> [0.00%]:
  lock_ref_for_update (&refs, &update, &transaction, head_ref_2(D), &affected_refnames, &err);
  refs ={v} {CLOBBER};
  update ={v} {CLOBBER};
  transaction ={v} {CLOBBER};
  affected_refnames ={v} {CLOBBER};
  err ={v} {CLOBBER};
  return 0;

}


