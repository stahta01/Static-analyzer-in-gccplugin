
;; Function key_new (key_new, funcdef_no=22, decl_uid=3486, cgraph_uid=23, symbol_order=22)

Removing basic block 3
Merging blocks 5 and 6
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4
;; 2 succs { 3 4 }
;; 3 succs { }
;; 4 succs { 1 }
struct Key * key_new (int type)
{
  struct DSA * dsa;
  struct RSA * rsa;
  struct Key * k;
  struct Key * D.3564;

  <bb 2> :
  k = calloc (1, 64);
  k->type = type;
  k->ecdsa = 0B;
  k->ecdsa_nid = -1;
  k->dsa = 0B;
  k->rsa = 0B;
  k->cert = 0B;
  _1 = k->type;
  if (_1 == 11)
    goto <bb 4>; [INV]
  else
    goto <bb 3>; [INV]

  <bb 3> :
<L1>:
  _2 = k->type;
  printf ("key_new: bad key type %d", _2);
  exit (1);

  <bb 4> :
  D.3564 = k;
  return D.3564;

}



;; Function key_free (key_free, funcdef_no=23, decl_uid=3495, cgraph_uid=24, symbol_order=23)

Removing basic block 11
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12
;; 2 succs { 3 4 }
;; 3 succs { }
;; 4 succs { 11 5 8 12 }
;; 5 succs { 6 7 }
;; 6 succs { 7 }
;; 7 succs { 12 }
;; 8 succs { 9 10 }
;; 9 succs { 10 }
;; 10 succs { 12 }
;; 11 succs { }
;; 12 succs { 1 }
void key_free (struct Key * k)
{
  <bb 2> :
  if (k == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  printf ("key_free: key is NULL%s", "");
  exit (1);

  <bb 4> :
  _1 = k->type;
  switch (_1) <default: <L14> [INV], case 0 ... 1: <L2> [INV], case 2: <L8> [INV], case 5: <L2> [INV], case 6: <L8> [INV], case 9: <L2> [INV], case 10: <L8> [INV], case 11: <L16> [INV]>

  <bb 5> :
<L2>:
  _2 = k->rsa;
  if (_2 != 0B)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  _3 = k->rsa;
  free (_3);

  <bb 7> :
  k->rsa = 0B;
  goto <bb 12>; [INV]

  <bb 8> :
<L8>:
  _4 = k->dsa;
  if (_4 != 0B)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  _5 = k->dsa;
  free (_5);

  <bb 10> :
  k->dsa = 0B;
  goto <bb 12>; [INV]

  <bb 11> :
<L14>:
  _6 = k->type;
  printf ("key_free: bad key type %d", _6);
  exit (1);

  <bb 12> :
<L16>:
  free (k);
  return;

}



;; Function key_load_private_type (key_load_private_type, funcdef_no=26, decl_uid=3536, cgraph_uid=27, symbol_order=26)

Merging blocks 4 and 5
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4
;; 2 succs { 3 4 }
;; 3 succs { 4 }
;; 4 succs { 1 }
struct Key * key_load_private_type (int type, const char * filename, const char * passphrase, char * * commentp, int * perm_ok)
{
  struct Key * ret;
  int fd;
  struct Key * D.3575;

  <bb 2> :
  _1 = rand ();
  _2 = _1 % 2;
  if (_2 == 1)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  *perm_ok = 1;

  <bb 4> :
  ret = key_parse_private_type (0B, type, passphrase, commentp);
  D.3575 = ret;
  return D.3575;

}



;; Function key_parse_private_type (key_parse_private_type, funcdef_no=25, decl_uid=3519, cgraph_uid=26, symbol_order=25)

Merging blocks 5 and 6
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6
;; 2 succs { 5 3 4 }
;; 3 succs { 6 }
;; 4 succs { 6 }
;; 5 succs { 6 }
;; 6 succs { 1 }
struct Key * key_parse_private_type (struct Buffer * blob, int type, const char * passphrase, char * * commentp)
{
  static const char __func__[23] = "key_parse_private_type";
  struct Key * D.3577;

  <bb 2> :
  switch (type) <default: <L5> [INV], case 0: <L0> [INV], case 1 ... 3: <L1> [INV], case 11: <L1> [INV]>

  <bb 3> :
<L0>:
  _1 = key_parse_private_rsa1 (blob, passphrase, commentp);
  _2 = (long int) _1;
  D.3577 = (struct Key *) _2;
  goto <bb 6>; [INV]

  <bb 4> :
<L1>:
  D.3577 = key_parse_private_pem (blob, type, passphrase, commentp);
  goto <bb 6>; [INV]

  <bb 5> :
<L5>:
  printf ("%s: cannot parse key type %d\n", &__func__, type);
  D.3577 = 0B;

  <bb 6> :
  return D.3577;

}



;; Function key_parse_private_pem (key_parse_private_pem, funcdef_no=24, decl_uid=3511, cgraph_uid=25, symbol_order=24)

Removing basic block 8
Merging blocks 13 and 14
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12
;; 2 succs { 3 4 }
;; 3 succs { 12 }
;; 4 succs { 5 8 }
;; 5 succs { 6 8 }
;; 6 succs { 7 12 }
;; 7 succs { 12 }
;; 8 succs { 9 11 }
;; 9 succs { 10 11 }
;; 10 succs { 12 }
;; 11 succs { 12 }
;; 12 succs { 1 }
struct Key * key_parse_private_pem (struct Buffer * blob, int type, const char * passphrase, char * * commentp)
{
  static const char __func__[22] = "key_parse_private_pem";
  struct Key * prv;
  struct Key * D.3592;

  <bb 2> :
  prv = 0B;
  _1 = rand ();
  _2 = _1 % 2;
  if (_2 == 1)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  printf ("%s: PEM_read_PrivateKey failed\n", &__func__);
  goto <bb 12>; [INV]

  <bb 4> :
  _3 = rand ();
  _4 = _3 % 2;
  if (_4 == 1)
    goto <bb 5>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 5> :
  _5 = type == 11;
  _6 = type == 1;
  _7 = _5 | _6;
  if (_7 != 0)
    goto <bb 6>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 6> :
  prv = key_new (11);
  _8 = malloc (168);
  prv->rsa = _8;
  prv->type = 1;
  _9 = rand ();
  _10 = _9 % 5;
  if (_10 == 0)
    goto <bb 7>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 7> :
  printf ("%s: RSA_blinding_on failed\n", &__func__);
  key_free (prv);
  prv = 0B;
  goto <bb 12>; [INV]

  <bb 8> :
  _11 = rand ();
  _12 = _11 % 2;
  if (_12 == 1)
    goto <bb 9>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 9> :
  _13 = type == 11;
  _14 = type == 2;
  _15 = _13 | _14;
  if (_15 != 0)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  prv = key_new (11);
  _16 = malloc (24);
  prv->dsa = _16;
  prv->type = 2;
  goto <bb 12>; [INV]

  <bb 11> :
  printf ("%s: PEM_read_PrivateKey: mismatch or unknown EVP_PKEY save_type\n");

  <bb 12> :
  D.3592 = prv;
  return D.3592;

}



;; Function main (main, funcdef_no=28, decl_uid=3558, cgraph_uid=29, symbol_order=28)

Removing basic block 5
Merging blocks 4 and 6
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4
;; 2 succs { 3 4 }
;; 3 succs { 4 }
;; 4 succs { 1 }
int main (int argc, char * * argv)
{
  struct Identity * id;
  int D.3596;

  <bb 2> :
  id = malloc (56);
  _1 = time (0B);
  _2 = (unsigned int) _1;
  srand (_2);
  _3 = *argv;
  id->filename = _3;
  _4 = id->userprovided;
  _5 = id->filename;
  _6 = load_identity_file (_5, _4);
  id->key = _6;
  _7 = id->key;
  _8 = _7->rsa;
  printf ("%d\n", _8);
  _9 = id->key;
  if (_9 != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  _10 = id->key;
  key_free (_10);

  <bb 4> :
  free (id);
  D.3596 = 0;
  return D.3596;

}



;; Function load_identity_file (load_identity_file, funcdef_no=27, decl_uid=3542, cgraph_uid=28, symbol_order=27)

Merging blocks 15 and 16
;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
;;
;; Loop 1
;;  header 13, latch 12
;;  depth 1, outer 0
;;  nodes: 13 12 11 9 10 8
;; 2 succs { 3 4 }
;; 3 succs { 15 }
;; 4 succs { 5 14 }
;; 5 succs { 6 7 }
;; 6 succs { 15 }
;; 7 succs { 13 }
;; 8 succs { 9 10 }
;; 9 succs { 11 }
;; 10 succs { 11 }
;; 11 succs { 14 12 }
;; 12 succs { 13 }
;; 13 succs { 8 14 }
;; 14 succs { 15 }
;; 15 succs { 1 }
struct Key * load_identity_file (char * filename, int userprovided)
{
  const unsigned char D.3610;
  int quit;
  int i;
  int perm_ok;
  char * passphrase;
  struct Key * private;
  struct Key * D.3600;

  <bb 2> :
  perm_ok = 0;
  private = key_load_private_type (11, filename, "", 0B, &perm_ok);
  perm_ok.0_1 = perm_ok;
  if (perm_ok.0_1 == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  D.3600 = 0B;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 15>; [INV]

  <bb 4> :
  if (private == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 5> :
  _2 = rand ();
  _3 = _2 % 2;
  if (_3 == 1)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  D.3600 = 0B;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 15>; [INV]

  <bb 7> :
  i = 0;
  goto <bb 13>; [INV]

  <bb 8> :
  D.3610 = MEM[(const unsigned char * {ref-all})passphrase];
  _4 = (int) D.3610;
  if (_4 != 0)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  private = key_load_private_type (11, filename, passphrase, 0B, 0B);
  quit = 0;
  goto <bb 11>; [INV]

  <bb 10> :
  debug2 ("no passphrase given, try next key");
  quit = 1;

  <bb 11> :
  _5 = private != 0B;
  _6 = quit != 0;
  _7 = _5 | _6;
  if (_7 != 0)
    goto <bb 14>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 12> :
  i = i + 1;

  <bb 13> :
  if (i <= 99)
    goto <bb 8>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 14> :
  D.3600 = private;

  <bb 15> :
  perm_ok = {CLOBBER};
  return D.3600;

}


