
;; Function xrealloc (xrealloc, funcdef_no=49, decl_uid=3416, cgraph_uid=49, symbol_order=50)

xrealloc (void * ptr, size_t size)
{
  void * D.3606;
  void * ret;

  ret = realloc (ptr, size);
  _1 = ret == 0B;
  _2 = size == 0;
  _3 = _1 & _2;
  if (_3 != 0) goto <D.3598>; else goto <D.3599>;
  <D.3598>:
  ret = realloc (ptr, 1);
  <D.3599>:
  if (ret == 0B) goto <D.3600>; else goto <D.3601>;
  <D.3600>:
  ret = realloc (ptr, size);
  _4 = ret == 0B;
  _5 = size == 0;
  _6 = _4 & _5;
  if (_6 != 0) goto <D.3602>; else goto <D.3603>;
  <D.3602>:
  ret = realloc (ptr, 1);
  <D.3603>:
  if (ret == 0B) goto <D.3604>; else goto <D.3605>;
  <D.3604>:
  printf ("Out of memory, realloc failed%s", "");
  exit (1);
  <D.3605>:
  <D.3601>:
  D.3606 = ret;
  return D.3606;
}



;; Function printf (<unset-asm-name>, funcdef_no=15, decl_uid=798, cgraph_uid=15, symbol_order=15)

__attribute__((__artificial__, __gnu_inline__, __always_inline__))
printf (const char * restrict __fmt)
{
  int D.3608;

  D.3608 = __printf_chk (1, __fmt, __builtin_va_arg_pack ());
  return D.3608;
}



;; Function strbuf_grow (strbuf_grow, funcdef_no=50, decl_uid=3453, cgraph_uid=50, symbol_order=51)

strbuf_grow (struct strbuf * sb, size_t extra)
{
  int new_buf;

  _1 = sb->alloc;
  _2 = _1 == 0;
  new_buf = (int) _2;
  {
    extern int unsigned_add_overflows ();

    _3 = unsigned_add_overflows (extra, 1);
    if (_3 != 0) goto <D.3610>; else goto <D.3612>;
    <D.3612>:
    _4 = extra + 1;
    _5 = sb->len;
    _6 = unsigned_add_overflows (_5, _4);
    if (_6 != 0) goto <D.3610>; else goto <D.3611>;
    <D.3610>:
    printf ("you want to use way too much memory%s", "");
    exit (1);
    <D.3611>:
  }
  if (new_buf != 0) goto <D.3613>; else goto <D.3614>;
  <D.3613>:
  sb->buf = 0B;
  <D.3614>:
  _7 = sb->len;
  _8 = extra + _7;
  _9 = _8 + 1;
  _10 = sb->alloc;
  if (_9 > _10) goto <D.3615>; else goto <D.3616>;
  <D.3615>:
  {
    extern int st_mult ();

    {
      extern int alloc_nr ();

      _11 = sb->alloc;
      _12 = alloc_nr (_11);
      _13 = (long unsigned int) _12;
      _14 = sb->len;
      _15 = extra + _14;
      _16 = _15 + 1;
      if (_13 < _16) goto <D.3617>; else goto <D.3618>;
      <D.3617>:
      _17 = sb->len;
      _18 = extra + _17;
      _19 = _18 + 1;
      sb->alloc = _19;
      goto <D.3619>;
      <D.3618>:
      _20 = sb->alloc;
      _21 = alloc_nr (_20);
      _22 = (long unsigned int) _21;
      sb->alloc = _22;
      <D.3619>:
    }
    _23 = sb->alloc;
    _24 = st_mult (1, _23);
    _25 = (long unsigned int) _24;
    _26 = sb->buf;
    _27 = xrealloc (_26, _25);
    sb->buf = _27;
  }
  <D.3616>:
  if (new_buf != 0) goto <D.3620>; else goto <D.3621>;
  <D.3620>:
  _28 = sb->buf;
  *_28 = 0;
  <D.3621>:
}



;; Function strbuf_release (strbuf_release, funcdef_no=51, decl_uid=3462, cgraph_uid=51, symbol_order=52)

strbuf_release (struct strbuf * sb)
{
  _1 = sb->alloc;
  if (_1 != 0) goto <D.3622>; else goto <D.3623>;
  <D.3622>:
  {
    extern int strbuf_init ();

    _2 = sb->buf;
    free (_2);
    strbuf_init (sb, 0);
  }
  <D.3623>:
}



;; Function strbuf_readlink (strbuf_readlink, funcdef_no=52, decl_uid=3469, cgraph_uid=52, symbol_order=53)

strbuf_readlink (struct strbuf * sb, const char * path, size_t hint)
{
  int D.3632;
  size_t oldalloc;

  oldalloc = sb->alloc;
  if (hint <= 31) goto <D.3624>; else goto <D.3625>;
  <D.3624>:
  hint = 32;
  <D.3625>:
  goto <D.3479>;
  <D.3478>:
  {
    int len;
    extern int readlink ();

    strbuf_grow (sb, hint);
    _1 = sb->buf;
    len = readlink (path, _1, hint);
    if (len < 0) goto <D.3626>; else goto <D.3627>;
    <D.3626>:
    _2 = __errno_location ();
    _3 = *_2;
    if (_3 != 34) goto <D.3474>; else goto <D.3628>;
    <D.3628>:
    goto <D.3629>;
    <D.3627>:
    _4 = (long unsigned int) len;
    if (hint > _4) goto <D.3630>; else goto <D.3631>;
    <D.3630>:
    {
      extern int strbuf_setlen ();

      strbuf_setlen (sb, len);
      D.3632 = 0;
      return D.3632;
    }
    <D.3631>:
    <D.3629>:
    hint = hint * 2;
  }
  <D.3479>:
  if (hint <= 8191) goto <D.3478>; else goto <D.3474>;
  <D.3474>:
  if (oldalloc == 0) goto <D.3633>; else goto <D.3634>;
  <D.3633>:
  strbuf_release (sb);
  <D.3634>:
  D.3632 = -1;
  return D.3632;
}



;; Function main (main, funcdef_no=56, decl_uid=3589, cgraph_uid=56, symbol_order=57)

main ()
{
  int D.3636;

  {
    struct files_ref_store refs;
    struct ref_update update;
    struct ref_transaction transaction;
    char * head_ref;
    struct string_list affected_refnames;
    struct strbuf err;

    try
      {
        lock_ref_for_update (&refs, &update, &transaction, head_ref, &affected_refnames, &err);
        D.3636 = 0;
        return D.3636;
      }
    finally
      {
        refs = {CLOBBER};
        update = {CLOBBER};
        transaction = {CLOBBER};
        affected_refnames = {CLOBBER};
        err = {CLOBBER};
      }
  }
  D.3636 = 0;
  return D.3636;
}



;; Function lock_ref_for_update (lock_ref_for_update, funcdef_no=55, decl_uid=3557, cgraph_uid=55, symbol_order=56)

lock_ref_for_update (struct files_ref_store * refs, struct ref_update * update, struct ref_transaction * transaction, const char * head_ref, struct string_list * affected_refnames, struct strbuf * err)
{
  int D.3643;
  struct strbuf referent;
  int mustexist;
  int ret;
  struct ref_lock * lock;

  try
    {
      referent.alloc = 0;
      referent.len = 0;
      referent.buf = &strbuf_slopbuf;
      if (head_ref != 0B) goto <D.3639>; else goto <D.3640>;
      <D.3639>:
      {
        extern int split_head_update ();

        ret = split_head_update (update, transaction, head_ref, affected_refnames, err);
        if (ret != 0) goto <D.3641>; else goto <D.3642>;
        <D.3641>:
        D.3643 = ret;
        return D.3643;
        <D.3642>:
      }
      <D.3640>:
      _1 = &update->type;
      _2 = &update->refname;
      ret = lock_raw_ref (refs, _2, mustexist, affected_refnames, 0B, &lock, &referent, _1, err);
      if (ret != 0) goto <D.3644>; else goto <D.3645>;
      <D.3644>:
      {
        char * reason;
        extern int strbuf_detach ();
        extern int strbuf_addf ();
        extern int original_update_refname ();

        _3 = strbuf_detach (err, 0B);
        _4 = (long int) _3;
        reason = (char *) _4;
        _5 = original_update_refname (update);
        strbuf_addf (err, "cannot lock ref \'%s\': %s", _5, reason);
        free (reason);
        D.3643 = ret;
        return D.3643;
      }
      <D.3645>:
      lock.0_6 = lock;
      update->backend_data = lock.0_6;
      _7 = update->type;
      _8 = _7 & 1;
      if (_8 != 0) goto <D.3646>; else goto <D.3647>;
      <D.3646>:
      _9 = update->flags;
      _10 = _9 & 1;
      if (_10 != 0) goto <D.3648>; else goto <D.3649>;
      <D.3648>:
      {
        extern int refs_read_ref_full ();

        lock.1_11 = lock;
        _12 = &lock.1_11->old_oid.hash;
        _13 = referent.buf;
        _14 = &refs->base;
        _15 = refs_read_ref_full (_14, _13, 0, _12, 0B);
        if (_15 != 0) goto <D.3650>; else goto <D.3651>;
        <D.3650>:
        _16 = update->flags;
        _17 = _16 & 16;
        if (_17 != 0) goto <D.3652>; else goto <D.3653>;
        <D.3652>:
        {
          extern int strbuf_addf ();
          extern int original_update_refname ();

          _18 = original_update_refname (update);
          strbuf_addf (err, "cannot lock ref \'%s\': error reading reference", _18);
          D.3643 = -1;
          return D.3643;
        }
        <D.3653>:
        goto <D.3654>;
        <D.3651>:
        {
          extern int check_old_oid ();

          lock.2_19 = lock;
          _20 = &lock.2_19->old_oid;
          _21 = check_old_oid (update, _20, err);
          if (_21 != 0) goto <D.3655>; else goto <D.3656>;
          <D.3655>:
          D.3643 = -2;
          return D.3643;
          <D.3656>:
        }
        <D.3654>:
      }
      goto <D.3657>;
      <D.3649>:
      {
        extern int split_symref_update ();

        _22 = referent.buf;
        ret = split_symref_update (refs, update, _22, transaction, affected_refnames, err);
        if (ret != 0) goto <D.3658>; else goto <D.3659>;
        <D.3658>:
        D.3643 = ret;
        return D.3643;
        <D.3659>:
      }
      <D.3657>:
      goto <D.3660>;
      <D.3647>:
      {
        struct ref_update * parent_update;

        {
          extern int check_old_oid ();

          lock.3_23 = lock;
          _24 = &lock.3_23->old_oid;
          _25 = check_old_oid (update, _24, err);
          if (_25 != 0) goto <D.3661>; else goto <D.3662>;
          <D.3661>:
          D.3643 = -2;
          return D.3643;
          <D.3662>:
        }
      }
      <D.3660>:
      _26 = BIT_FIELD_REF <*update, 32, 320>;
      _27 = _26 & 138;
      if (_27 == 8) goto <D.3663>; else goto <D.3664>;
      <D.3663>:
      {
        extern int oidcmp ();

        _28 = update->type;
        _29 = _28 & 1;
        if (_29 == 0) goto <D.3667>; else goto <D.3665>;
        <D.3667>:
        _30 = &update->new_oid;
        lock.4_31 = lock;
        _32 = &lock.4_31->old_oid;
        _33 = oidcmp (_32, _30);
        if (_33 == 0) goto <D.3668>; else goto <D.3665>;
        <D.3668>:
        goto <D.3666>;
        <D.3665>:
        {
          extern int write_ref_to_lockfile ();

          _34 = &update->new_oid;
          lock.5_35 = lock;
          _36 = write_ref_to_lockfile (lock.5_35, _34, err);
          if (_36 != 0) goto <D.3669>; else goto <D.3670>;
          <D.3669>:
          {
            char * write_err;
            extern int strbuf_detach ();

            _37 = strbuf_detach (err, 0B);
            _38 = (long int) _37;
            write_err = (char *) _38;
            update->backend_data = 0B;
            D.3643 = -2;
            return D.3643;
          }
          <D.3670>:
          _39 = update->flags;
          _40 = _39 | 32;
          update->flags = _40;
        }
        <D.3666>:
      }
      <D.3664>:
      _41 = update->flags;
      _42 = _41 & 32;
      if (_42 == 0) goto <D.3671>; else goto <D.3672>;
      <D.3671>:
      {
        extern int close_ref ();

        lock.6_43 = lock;
        _44 = close_ref (lock.6_43);
        if (_44 != 0) goto <D.3673>; else goto <D.3674>;
        <D.3673>:
        D.3643 = -2;
        return D.3643;
        <D.3674>:
      }
      <D.3672>:
      D.3643 = 0;
      return D.3643;
    }
  finally
    {
      referent = {CLOBBER};
      lock = {CLOBBER};
    }
}



;; Function lock_raw_ref (lock_raw_ref, funcdef_no=54, decl_uid=3537, cgraph_uid=54, symbol_order=55)

lock_raw_ref (struct files_ref_store * refs, const char * refname, int mustexist, const struct string_list * extras, const struct string_list * skip, struct ref_lock * * lock_p, struct strbuf * referent, unsigned int * type, struct strbuf * err)
{
  int D.3683;
  struct ref_lock * lock;
  struct strbuf ref_file;
  int attempts_remaining;
  int ret;
  extern char * strdup (const char *);
  extern int files_ref_path ();
  void error_return = <<< error >>>;
  void out = <<< error >>>;
  extern int unlock_ref ();

  try
    {
      ref_file.alloc = 0;
      ref_file.len = 0;
      ref_file.buf = &strbuf_slopbuf;
      attempts_remaining = 3;
      ret = -2;
      *type = 0;
      lock = calloc (1, 40);
      *lock_p = lock;
      _1 = strdup (refname);
      lock->ref_name = _1;
      files_ref_path (refs, &ref_file, refname);
      _2 = &lock->old_oid.hash;
      _3 = &refs->base;
      _4 = files_read_raw_ref (_3, refname, _2, referent, type);
      if (_4 != 0) goto <D.3677>; else goto <D.3678>;
      <D.3677>:
      _5 = __errno_location ();
      _6 = *_5;
      if (_6 == 2) goto <D.3679>; else goto <D.3680>;
      <D.3679>:
      if (mustexist != 0) goto <D.3681>; else goto <D.3682>;
      <D.3681>:
      {
        extern int strbuf_addf ();

        strbuf_addf (err, "unable to resolve reference \'%s\'", refname);
        goto error_return;
      }
      <D.3682>:
      <D.3680>:
      <D.3678>:
      ret = 0;
      goto out;
      error_return:
      unlock_ref (lock);
      *lock_p = 0B;
      out:
      strbuf_release (&ref_file);
      D.3683 = ret;
      return D.3683;
    }
  finally
    {
      ref_file = {CLOBBER};
    }
}



;; Function files_read_raw_ref (files_read_raw_ref, funcdef_no=53, decl_uid=3485, cgraph_uid=53, symbol_order=54)

files_read_raw_ref (struct ref_store * ref_store, const char * refname, unsigned char * sha1, struct strbuf * referent, unsigned int * type)
{
  int D.3694;
  int D.3707;
  struct files_ref_store * refs;
  extern int files_downcast ();
  struct strbuf sb_contents;
  struct strbuf sb_path;
  const char * path;
  const char * buf;
  int fd;
  int ret;
  int save_errno;
  int remaining_retries;
  struct stat st;
  extern int strbuf_reset ();
  extern int files_ref_path ();
  void stat_ref = <<< error >>>;
  void out = <<< error >>>;
  extern int strbuf_rtrim ();

  try
    {
      _1 = files_downcast (ref_store, 1, "read_raw_ref");
      _2 = (long int) _1;
      refs = (struct files_ref_store *) _2;
      sb_contents.alloc = 0;
      sb_contents.len = 0;
      sb_contents.buf = &strbuf_slopbuf;
      sb_path.alloc = 0;
      sb_path.len = 0;
      sb_path.buf = &strbuf_slopbuf;
      ret = -1;
      remaining_retries = 3;
      *type = 0;
      strbuf_reset (&sb_path);
      files_ref_path (refs, &sb_path, refname);
      path = sb_path.buf;
      stat_ref:
      remaining_retries.7_3 = remaining_retries;
      remaining_retries = remaining_retries.7_3 + -1;
      if (remaining_retries.7_3 <= 0) goto out; else goto <D.3686>;
      <D.3686>:
      _4 = lstat (path, &st);
      if (_4 < 0) goto <D.3687>; else goto <D.3688>;
      <D.3687>:
      _5 = __errno_location ();
      _6 = *_5;
      if (_6 != 2) goto out; else goto <D.3689>;
      <D.3689>:
      {
        extern int resolve_packed_ref ();

        _7 = resolve_packed_ref (refs, refname, sha1, type);
        if (_7 != 0) goto <D.3690>; else goto <D.3691>;
        <D.3690>:
        _8 = __errno_location ();
        *_8 = 2;
        goto out;
        <D.3691>:
      }
      ret = 0;
      goto out;
      <D.3688>:
      strbuf_reset (&sb_contents);
      _9 = strbuf_readlink (&sb_contents, path, 0);
      if (_9 < 0) goto <D.3692>; else goto <D.3693>;
      <D.3692>:
      _10 = __errno_location ();
      D.3694 = *_10;
      _11 = D.3694 == 2;
      _12 = D.3694 == 22;
      _13 = _11 | _12;
      if (_13 != 0) goto stat_ref; else goto out;
      <D.3693>:
      {
        extern int starts_with ();
        extern int check_refname_format ();

        _14 = sb_contents.buf;
        _15 = starts_with (_14, "refs/");
        if (_15 != 0) goto <D.3695>; else goto <D.3696>;
        <D.3695>:
        _16 = sb_contents.buf;
        _17 = check_refname_format (_16, 0);
        if (_17 == 0) goto <D.3697>; else goto <D.3698>;
        <D.3697>:
        strbuf_swap (&sb_contents, referent);
        _18 = *type;
        _19 = _18 | 1;
        *type = _19;
        ret = 0;
        goto out;
        <D.3698>:
        <D.3696>:
      }
      strbuf_reset (&sb_contents);
      {
        extern int strbuf_read ();

        _20 = strbuf_read (&sb_contents, fd, 256);
        if (_20 < 0) goto <D.3699>; else goto <D.3700>;
        <D.3699>:
        {
          int save_errno;
          extern int close ();

          _21 = __errno_location ();
          save_errno = *_21;
          close (fd);
          _22 = __errno_location ();
          *_22 = save_errno;
          goto out;
        }
        <D.3700>:
      }
      strbuf_rtrim (&sb_contents);
      buf = sb_contents.buf;
      {
        extern int starts_with ();

        _23 = starts_with (buf, "ref:");
        if (_23 != 0) goto <D.3701>; else goto <D.3702>;
        <D.3701>:
        {
          extern int strbuf_addstr ();

          buf = buf + 4;
          {
            extern int isspace ();

            goto <D.3515>;
            <D.3514>:
            buf = buf + 1;
            <D.3515>:
            _24 = *buf;
            _25 = (int) _24;
            _26 = isspace (_25);
            if (_26 != 0) goto <D.3514>; else goto <D.3516>;
            <D.3516>:
          }
          strbuf_reset (referent);
          strbuf_addstr (referent, buf);
          _27 = *type;
          _28 = _27 | 1;
          *type = _28;
          ret = 0;
          goto out;
        }
        <D.3702>:
      }
      {
        extern int get_sha1_hex ();
        extern int isspace ();

        _29 = get_sha1_hex (buf, sha1);
        if (_29 != 0) goto <D.3703>; else goto <D.3705>;
        <D.3705>:
        _30 = buf + 40;
        _31 = *_30;
        if (_31 != 0) goto <D.3706>; else goto <D.3704>;
        <D.3706>:
        _32 = buf + 40;
        _33 = *_32;
        _34 = (int) _33;
        _35 = isspace (_34);
        if (_35 == 0) goto <D.3703>; else goto <D.3704>;
        <D.3703>:
        _36 = *type;
        _37 = _36 | 4;
        *type = _37;
        _38 = __errno_location ();
        *_38 = 22;
        goto out;
        <D.3704>:
      }
      ret = 0;
      out:
      _39 = __errno_location ();
      save_errno = *_39;
      strbuf_release (&sb_path);
      strbuf_release (&sb_contents);
      _40 = __errno_location ();
      *_40 = save_errno;
      D.3707 = ret;
      return D.3707;
    }
  finally
    {
      sb_contents = {CLOBBER};
      sb_path = {CLOBBER};
      st = {CLOBBER};
    }
}



;; Function lstat (lstat, funcdef_no=40, decl_uid=3041, cgraph_uid=40, symbol_order=40)

__attribute__((__gnu_inline__, __leaf__, __nothrow__))
lstat (const char * __path, struct stat * __statbuf)
{
  int D.3710;

  D.3710 = __lxstat (1, __path, __statbuf);
  return D.3710;
}



;; Function strbuf_swap (strbuf_swap, funcdef_no=48, decl_uid=3408, cgraph_uid=48, symbol_order=49)

strbuf_swap (struct strbuf * a, struct strbuf * b)
{
  {
    void * _swap_a_ptr;
    void * _swap_b_ptr;
    unsigned char _swap_buffer[24];
    extern void * memcpy (void *, const void *, long unsigned int);

    try
      {
        _swap_a_ptr = a;
        _swap_b_ptr = b;
        MEM[(char * {ref-all})&_swap_buffer] = MEM[(char * {ref-all})_swap_a_ptr];
        memcpy (_swap_a_ptr, _swap_b_ptr, 24);
        MEM[(char * {ref-all})_swap_b_ptr] = MEM[(char * {ref-all})&_swap_buffer];
      }
    finally
      {
        _swap_buffer = {CLOBBER};
      }
  }
}


