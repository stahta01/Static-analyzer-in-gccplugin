
;; Function xrealloc (xrealloc, funcdef_no=26, decl_uid=3195, cgraph_uid=27, symbol_order=27)

Merging blocks 9 and 10
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9
;; 2 succs { 3 4 }
;; 3 succs { 4 }
;; 4 succs { 5 9 }
;; 5 succs { 6 7 }
;; 6 succs { 7 }
;; 7 succs { 8 9 }
;; 8 succs { }
;; 9 succs { 1 }
void * xrealloc (void * ptr, size_t size)
{
  void * ret;
  void * D.3397;

  <bb 2> :
  ret = realloc (ptr, size);
  _1 = ret == 0B;
  _2 = size == 0;
  _3 = _1 & _2;
  if (_3 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  ret = realloc (ptr, 1);

  <bb 4> :
  if (ret == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 5> :
  ret = realloc (ptr, size);
  _4 = ret == 0B;
  _5 = size == 0;
  _6 = _4 & _5;
  if (_6 != 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  ret = realloc (ptr, 1);

  <bb 7> :
  if (ret == 0B)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  printf ("Out of memory, realloc failed%s", "");
  exit (1);

  <bb 9> :
  D.3397 = ret;
  return D.3397;

}



;; Function string_list_clear (string_list_clear, funcdef_no=27, decl_uid=3277, cgraph_uid=28, symbol_order=29)

;; 3 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12
;;
;; Loop 2
;;  header 10, latch 9
;;  depth 1, outer 0
;;  nodes: 10 9
;;
;; Loop 1
;;  header 6, latch 5
;;  depth 1, outer 0
;;  nodes: 6 5
;; 2 succs { 3 12 }
;; 3 succs { 4 7 }
;; 4 succs { 6 }
;; 5 succs { 6 }
;; 6 succs { 5 7 }
;; 7 succs { 8 11 }
;; 8 succs { 10 }
;; 9 succs { 10 }
;; 10 succs { 9 11 }
;; 11 succs { 12 }
;; 12 succs { 1 }
void string_list_clear (struct string_list * list, int free_util)
{
  int i;

  <bb 2> :
  _1 = list->items;
  if (_1 != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 3> :
  _2 = BIT_FIELD_REF <*list, 8, 128>;
  _3 = _2 & 1;
  if (_3 != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 4> :
  i = 0;
  goto <bb 6>; [INV]

  <bb 5> :
  _4 = list->items;
  _5 = (long unsigned int) i;
  _6 = _5 * 16;
  _7 = _4 + _6;
  _8 = _7->string;
  free (_8);
  i = i + 1;

  <bb 6> :
  _9 = list->nr;
  i.0_10 = (unsigned int) i;
  if (_9 > i.0_10)
    goto <bb 5>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  if (free_util != 0)
    goto <bb 8>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 8> :
  i = 0;
  goto <bb 10>; [INV]

  <bb 9> :
  _11 = list->items;
  _12 = (long unsigned int) i;
  _13 = _12 * 16;
  _14 = _11 + _13;
  _15 = _14->util;
  free (_15);
  i = i + 1;

  <bb 10> :
  _16 = list->nr;
  i.1_17 = (unsigned int) i;
  if (_16 > i.1_17)
    goto <bb 9>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 11> :
  _18 = list->items;
  free (_18);

  <bb 12> :
  list->items = 0B;
  list->alloc = 0;
  _19 = list->alloc;
  list->nr = _19;
  return;

}



;; Function string_list_insert (string_list_insert, funcdef_no=29, decl_uid=3305, cgraph_uid=30, symbol_order=31)

Merging blocks 4 and 5
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4
;; 2 succs { 3 4 }
;; 3 succs { 4 }
;; 4 succs { 1 }
struct string_list_item * string_list_insert (struct string_list * list, const char * string)
{
  int index;
  struct string_list_item * D.3407;

  <bb 2> :
  index = add_entry (-1, list, string);
  if (index < 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  index = ~index;

  <bb 4> :
  _1 = list->items;
  _2 = (long unsigned int) index;
  _3 = _2 * 16;
  D.3407 = _1 + _3;
  return D.3407;

}



;; Function add_entry (add_entry, funcdef_no=28, decl_uid=3291, cgraph_uid=29, symbol_order=30)

Merging blocks 18 and 19
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18
;; 2 succs { 3 4 }
;; 3 succs { 5 }
;; 4 succs { 5 }
;; 5 succs { 6 7 }
;; 6 succs { 18 }
;; 7 succs { 8 12 }
;; 8 succs { 9 10 }
;; 9 succs { 11 }
;; 10 succs { 11 }
;; 11 succs { 12 }
;; 12 succs { 13 14 }
;; 13 succs { 14 }
;; 14 succs { 15 16 }
;; 15 succs { 17 }
;; 16 succs { 17 }
;; 17 succs { 18 }
;; 18 succs { 1 }
int add_entry (int insert_at, struct string_list * list, const char * string)
{
  int index;
  int exact_match;
  char * iftmp.6;
  int D.3415;
  int iftmp.2;

  <bb 2> :
  exact_match = 0;
  if (insert_at == -1)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  iftmp.2 = get_entry_index (list, string, &exact_match);
  goto <bb 5>; [INV]

  <bb 4> :
  iftmp.2 = insert_at;

  <bb 5> :
  index = iftmp.2;
  exact_match.3_1 = exact_match;
  if (exact_match.3_1 != 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  D.3415 = ~index;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 18>; [INV]

  <bb 7> :
  _2 = list->nr;
  _3 = _2 + 1;
  _4 = list->alloc;
  if (_3 > _4)
    goto <bb 8>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 8> :
  _5 = list->alloc;
  _6 = alloc_nr (_5);
  _7 = (unsigned int) _6;
  _8 = list->nr;
  _9 = _8 + 1;
  if (_7 < _9)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  _10 = list->nr;
  _11 = _10 + 1;
  list->alloc = _11;
  goto <bb 11>; [INV]

  <bb 10> :
  _12 = list->alloc;
  _13 = alloc_nr (_12);
  _14 = (unsigned int) _13;
  list->alloc = _14;

  <bb 11> :
  _15 = list->alloc;
  _16 = st_mult (16, _15);
  _17 = (long unsigned int) _16;
  _18 = list->items;
  _19 = xrealloc (_18, _17);
  list->items = _19;

  <bb 12> :
  _20 = list->nr;
  index.4_21 = (unsigned int) index;
  if (_20 > index.4_21)
    goto <bb 13>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 13> :
  _22 = list->nr;
  index.5_23 = (unsigned int) index;
  _24 = _22 - index.5_23;
  _25 = (long unsigned int) _24;
  _26 = list->items;
  _27 = (long unsigned int) index;
  _28 = _27 * 16;
  _29 = _26 + _28;
  _30 = list->items;
  _31 = (sizetype) index;
  _32 = _31 + 1;
  _33 = _32 * 16;
  _34 = _30 + _33;
  move_array (_34, _29, _25, 16);

  <bb 14> :
  _35 = BIT_FIELD_REF <*list, 8, 128>;
  _36 = _35 & 1;
  if (_36 != 0)
    goto <bb 15>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 15> :
  iftmp.6 = strdup (string);
  goto <bb 17>; [INV]

  <bb 16> :
  iftmp.6 = string;

  <bb 17> :
  _37 = list->items;
  _38 = (long unsigned int) index;
  _39 = _38 * 16;
  _40 = _37 + _39;
  _40->string = iftmp.6;
  _41 = list->items;
  _42 = (long unsigned int) index;
  _43 = _42 * 16;
  _44 = _41 + _43;
  _44->util = 0B;
  _45 = list->nr;
  _46 = _45 + 1;
  list->nr = _46;
  D.3415 = index;

  <bb 18> :
  exact_match = {CLOBBER};
  return D.3415;

}



;; Function move_array (move_array, funcdef_no=23, decl_uid=2979, cgraph_uid=24, symbol_order=24)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4
;; 2 succs { 3 4 }
;; 3 succs { 4 }
;; 4 succs { 1 }
void move_array (void * dst, const void * src, size_t n, size_t size)
{
  <bb 2> :
  if (n != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  _1 = st_mult (size, n);
  _2 = (long unsigned int) _1;
  memmove (dst, src, _2);

  <bb 4> :
  return;

}



;; Function merge_trees (merge_trees, funcdef_no=32, decl_uid=3349, cgraph_uid=33, symbol_order=34)

;; 3 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21
;;
;; Loop 2
;;  header 17, latch 16
;;  depth 1, outer 0
;;  nodes: 17 16 14
;;
;; Loop 1
;;  header 12, latch 11
;;  depth 1, outer 0
;;  nodes: 12 11 6 8 9 7
;; 2 succs { 3 19 }
;; 3 succs { 4 5 }
;; 4 succs { 21 }
;; 5 succs { 12 }
;; 6 succs { 7 11 }
;; 7 succs { 8 9 }
;; 8 succs { 11 }
;; 9 succs { 10 11 }
;; 10 succs { 21 }
;; 11 succs { 12 }
;; 12 succs { 6 13 }
;; 13 succs { 17 }
;; 14 succs { 15 16 }
;; 15 succs { }
;; 16 succs { 17 }
;; 17 succs { 14 18 }
;; 18 succs { 20 }
;; 19 succs { 20 }
;; 20 succs { 21 }
;; 21 succs { 1 }
int merge_trees (struct merge_options * o, struct tree * head, struct tree * merge, struct tree * common, struct tree * * result)
{
  struct stage_data * e;
  int ret;
  struct stage_data * e;
  const char * path;
  int i;
  struct string_list * re_merge;
  struct string_list * re_head;
  struct string_list * entries;
  int clean;
  int code;
  int D.3435;

  <bb 2> :
  _1 = o->call_depth;
  code = git_merge_trees (_1, common, head, merge);
  _2 = unmerged_index (&the_index);
  if (_2 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 19>; [INV]

  <bb 3> :
  get_files_dirs (o, head);
  get_files_dirs (o, merge);
  entries = get_unmerged ();
  record_df_conflict_files (o, entries);
  re_head = get_renames (o, head, common, head, merge, entries);
  re_merge = get_renames (o, merge, common, head, merge, entries);
  clean = process_renames (o, re_head, re_merge);
  if (clean < 0)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  D.3435 = clean;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 21>; [INV]

  <bb 5> :
  _3 = entries->nr;
  _4 = _3 + 4294967295;
  i = (int) _4;
  goto <bb 12>; [INV]

  <bb 6> :
  _5 = entries->items;
  _6 = (long unsigned int) i;
  _7 = _6 * 16;
  _8 = _5 + _7;
  path = _8->string;
  _9 = entries->items;
  _10 = (long unsigned int) i;
  _11 = _10 * 16;
  _12 = _9 + _11;
  e = _12->util;
  _13 = BIT_FIELD_REF <*e, 8, 832>;
  _14 = _13 & 1;
  if (_14 == 0)
    goto <bb 7>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 7> :
  ret = process_entry (o, path, e);
  if (ret == 0)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  clean = 0;
  goto <bb 11>; [INV]

  <bb 9> :
  if (ret < 0)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  D.3435 = ret;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 21>; [INV]

  <bb 11> :
  i = i + -1;

  <bb 12> :
  if (i >= 0)
    goto <bb 6>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 13> :
  i = 0;
  goto <bb 17>; [INV]

  <bb 14> :
  _15 = entries->items;
  _16 = (long unsigned int) i;
  _17 = _16 * 16;
  _18 = _15 + _17;
  e = _18->util;
  _19 = BIT_FIELD_REF <*e, 8, 832>;
  _20 = _19 & 1;
  if (_20 == 0)
    goto <bb 15>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 15> :
  _21 = entries->items;
  _22 = (long unsigned int) i;
  _23 = _22 * 16;
  _24 = _21 + _23;
  _25 = _24->string;
  printf ("BUG: unprocessed path??? %s", _25);
  exit (1);

  <bb 16> :
  i = i + 1;

  <bb 17> :
  _26 = entries->nr;
  i.7_27 = (unsigned int) i;
  if (_26 > i.7_27)
    goto <bb 14>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 18> :
  string_list_clear (re_merge, 0);
  string_list_clear (re_head, 0);
  string_list_clear (entries, 1);
  free (re_merge);
  free (re_head);
  free (entries);
  goto <bb 20>; [INV]

  <bb 19> :
  clean = 1;

  <bb 20> :
  D.3435 = clean;

  <bb 21> :
  return D.3435;

}



;; Function get_unmerged (get_unmerged, funcdef_no=30, decl_uid=3309, cgraph_uid=31, symbol_order=32)

Merging blocks 10 and 11
;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10
;;
;; Loop 1
;;  header 9, latch 8
;;  depth 1, outer 0
;;  nodes: 9 8 4 7 5 6 3
;; 2 succs { 9 }
;; 3 succs { 4 5 }
;; 4 succs { 8 }
;; 5 succs { 6 7 }
;; 6 succs { 7 }
;; 7 succs { 8 }
;; 8 succs { 9 }
;; 9 succs { 3 10 }
;; 10 succs { 1 }
struct string_list * get_unmerged ()
{
  const struct cache_entry * ce;
  struct stage_data * e;
  struct string_list_item * item;
  int i;
  struct string_list * unmerged;
  struct string_list * D.3451;

  <bb 2> :
  unmerged = calloc (1, 32);
  unmerged->strdup_strings = 1;
  i = 0;
  goto <bb 9>; [INV]

  <bb 3> :
  _1 = the_index.cache;
  _2 = (long unsigned int) i;
  _3 = _2 * 8;
  _4 = _1 + _3;
  ce = *_4;
  _5 = ce_stage (ce);
  if (_5 == 0)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  // predicted unlikely by continue predictor.
  goto <bb 8>; [INV]

  <bb 5> :
  _6 = &ce->name;
  _7 = string_list_lookup (unmerged, _6);
  _8 = (long int) _7;
  item = (struct string_list_item *) _8;
  if (item == 0B)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  _9 = &ce->name;
  item = string_list_insert (unmerged, _9);
  _10 = calloc (1, 112);
  item->util = _10;

  <bb 7> :
  e = item->util;

  <bb 8> :
  i = i + 1;

  <bb 9> :
  _11 = the_index.cache_nr;
  i.8_12 = (unsigned int) i;
  if (_11 > i.8_12)
    goto <bb 3>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 10> :
  D.3451 = unmerged;
  return D.3451;

}



;; Function get_renames (get_renames, funcdef_no=31, decl_uid=3330, cgraph_uid=32, symbol_order=33)

;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11
;;
;; Loop 1
;;  header 9, latch 8
;;  depth 1, outer 0
;;  nodes: 9 8 6 7 5
;; 2 succs { 3 4 }
;; 3 succs { 11 }
;; 4 succs { 9 }
;; 5 succs { 6 7 }
;; 6 succs { 8 }
;; 7 succs { 8 }
;; 8 succs { 9 }
;; 9 succs { 5 10 }
;; 10 succs { 11 }
;; 11 succs { 1 }
struct string_list * get_renames (struct merge_options * o, struct tree * tree, struct tree * o_tree, struct tree * a_tree, struct tree * b_tree, struct string_list * entries)
{
  struct diff_filepair * pair;
  struct rename * re;
  struct string_list_item * item;
  struct string_list * renames;
  int i;
  struct string_list * D.3455;

  <bb 2> :
  renames = calloc (1, 32);
  _1 = o->detect_rename;
  if (_1 == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  D.3455 = renames;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 11>; [INV]

  <bb 4> :
  i = 0;
  goto <bb 9>; [INV]

  <bb 5> :
  _2 = diff_queued_diff.queue;
  _3 = (long unsigned int) i;
  _4 = _3 * 8;
  _5 = _2 + _4;
  pair = *_5;
  _6 = pair->status;
  if (_6 != 82)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  diff_free_filepair (pair);
  // predicted unlikely by continue predictor.
  goto <bb 8>; [INV]

  <bb 7> :
  re = malloc (32);
  re->processed = 0;
  re->pair = pair;
  _7 = re->pair;
  _8 = _7->two;
  _9 = _8->path;
  _10 = string_list_lookup (entries, _9);
  _11 = (long int) _10;
  item = (struct string_list_item *) _11;
  _12 = pair->one;
  _13 = _12->path;
  item = string_list_insert (renames, _13);
  item->util = re;

  <bb 8> :
  i = i + 1;

  <bb 9> :
  _14 = diff_queued_diff.nr;
  if (i < _14)
    goto <bb 5>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 10> :
  diff_queued_diff.nr = 0;
  D.3455 = renames;

  <bb 11> :
  return D.3455;

}



;; Function main (main, funcdef_no=33, decl_uid=3381, cgraph_uid=34, symbol_order=35)

Removing basic block 4
Merging blocks 2 and 3
Merging blocks 2 and 5
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
int main ()
{
  struct tree * result;
  struct tree common;
  struct tree merge;
  struct tree head;
  struct merge_options o;
  int D.3459;

  <bb 2> :
  merge_trees (&o, &head, &merge, &common, &result);
  D.3459 = 0;
  o = {CLOBBER};
  head = {CLOBBER};
  merge = {CLOBBER};
  common = {CLOBBER};
  result = {CLOBBER};
  return D.3459;

}


