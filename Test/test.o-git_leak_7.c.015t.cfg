
;; Function xrealloc (xrealloc, funcdef_no=26, decl_uid=3195, cgraph_uid=27, symbol_order=27)

Merging blocks 9 and 10
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9
;; 2 succs { 3 4 }
;; 3 succs { 4 }
;; 4 succs { 5 9 }
;; 5 succs { 6 7 }
;; 6 succs { 7 }
;; 7 succs { 8 9 }
;; 8 succs { }
;; 9 succs { 1 }
void * xrealloc (void * ptr, size_t size)
{
  void * ret;
  void * D.3269;

  <bb 2> :
  ret = realloc (ptr, size);
  _1 = ret == 0B;
  _2 = size == 0;
  _3 = _1 & _2;
  if (_3 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  ret = realloc (ptr, 1);

  <bb 4> :
  if (ret == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 5> :
  ret = realloc (ptr, size);
  _4 = ret == 0B;
  _5 = size == 0;
  _6 = _4 & _5;
  if (_6 != 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  ret = realloc (ptr, 1);

  <bb 7> :
  if (ret == 0B)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  printf ("Out of memory, realloc failed%s", "");
  exit (1);

  <bb 9> :
  D.3269 = ret;
  return D.3269;

}



;; Function add_object_array_with_path (add_object_array_with_path, funcdef_no=27, decl_uid=3204, cgraph_uid=28, symbol_order=29)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12
;; 2 succs { 3 4 }
;; 3 succs { 4 }
;; 4 succs { 5 6 }
;; 5 succs { 9 }
;; 6 succs { 7 8 }
;; 7 succs { 9 }
;; 8 succs { 9 }
;; 9 succs { 10 11 }
;; 10 succs { 12 }
;; 11 succs { 12 }
;; 12 succs { 1 }
void add_object_array_with_path (struct object * obj, const char * name, struct object_array * array, unsigned int mode, const char * path)
{
  struct object_array_entry * entry;
  struct object_array_entry * objects;
  unsigned int alloc;
  unsigned int nr;

  <bb 2> :
  nr = array->nr;
  alloc = array->alloc;
  objects = array->objects;
  if (nr >= alloc)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  _1 = alloc + 32;
  alloc = _1 * 2;
  _2 = st_mult (32, alloc);
  _3 = (long unsigned int) _2;
  objects = xrealloc (objects, _3);
  array->alloc = alloc;
  array->objects = objects;

  <bb 4> :
  _4 = (long unsigned int) nr;
  _5 = _4 * 32;
  entry = objects + _5;
  entry->item = obj;
  if (name == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  entry->name = 0B;
  goto <bb 9>; [INV]

  <bb 6> :
  _6 = *name;
  if (_6 == 0)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  entry->name = &object_array_slopbuf;
  goto <bb 9>; [INV]

  <bb 8> :
  _7 = strdup (name);
  entry->name = _7;

  <bb 9> :
  entry->mode = mode;
  if (path != 0B)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  _8 = strdup (path);
  entry->path = _8;
  goto <bb 12>; [INV]

  <bb 11> :
  entry->path = 0B;

  <bb 12> :
  nr = nr + 1;
  array->nr = nr;
  return;

}



;; Function add_object_array (add_object_array, funcdef_no=28, decl_uid=3216, cgraph_uid=29, symbol_order=30)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
void add_object_array (struct object * obj, const char * name, struct object_array * array)
{
  <bb 2> :
  add_object_array_with_path (obj, name, array, 12288, 0B);
  return;

}



;; Function main (main, funcdef_no=30, decl_uid=3257, cgraph_uid=31, symbol_order=32)

Removing basic block 4
Merging blocks 2 and 3
Merging blocks 2 and 5
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
int main ()
{
  struct commit commit;
  int D.3282;

  <bb 2> :
  commit_is_complete (&commit);
  D.3282 = 0;
  commit = {CLOBBER};
  return D.3282;

}



;; Function commit_is_complete (commit_is_complete, funcdef_no=29, decl_uid=3219, cgraph_uid=30, symbol_order=31)

Merging blocks 40 and 41
;; 7 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40
;;
;; Loop 6
;;  header 38, latch 37
;;  depth 1, outer 0
;;  nodes: 38 37
;;
;; Loop 5
;;  header 33, latch 32
;;  depth 1, outer 0
;;  nodes: 33 32
;;
;; Loop 4
;;  header 30, latch 29
;;  depth 1, outer 0
;;  nodes: 30 29
;;
;; Loop 3
;;  header 26, latch 25
;;  depth 1, outer 0
;;  nodes: 26 25 23 24
;;
;; Loop 1
;;  header 20, multiple latches: 13 19
;;  depth 1, outer 0
;;  nodes: 20 13 19 14 18 16 17 15 12 10 7 8 9
;;
;; Loop 2
;;  header 19, latch 18
;;  depth 2, outer 1
;;  nodes: 19 18 16 17 15
;; 2 succs { 3 4 }
;; 3 succs { 40 }
;; 4 succs { 5 6 }
;; 5 succs { 40 }
;; 6 succs { 20 }
;; 7 succs { 8 10 }
;; 8 succs { 9 10 }
;; 9 succs { 10 }
;; 10 succs { 11 12 }
;; 11 succs { 21 }
;; 12 succs { 13 14 }
;; 13 succs { 20 }
;; 14 succs { 19 }
;; 15 succs { 16 17 }
;; 16 succs { 18 }
;; 17 succs { 18 }
;; 18 succs { 19 }
;; 19 succs { 15 20 }
;; 20 succs { 7 21 }
;; 21 succs { 22 31 }
;; 22 succs { 26 }
;; 23 succs { 24 25 }
;; 24 succs { 25 }
;; 25 succs { 26 }
;; 26 succs { 23 27 }
;; 27 succs { 28 31 }
;; 28 succs { 30 }
;; 29 succs { 30 }
;; 30 succs { 29 31 }
;; 31 succs { 33 }
;; 32 succs { 33 }
;; 33 succs { 32 34 }
;; 34 succs { 35 36 }
;; 35 succs { 39 }
;; 36 succs { 38 }
;; 37 succs { 38 }
;; 38 succs { 37 39 }
;; 39 succs { 40 }
;; 40 succs { 1 }
int commit_is_complete (struct commit * commit)
{
  struct commit * c;
  struct commit * p;
  struct commit_list * parent;
  struct commit * c;
  int i;
  int is_incomplete;
  struct object_array found;
  struct object_array study;
  int D.3287;

  <bb 2> :
  is_incomplete = 0;
  _1 = commit->object.flags;
  _2 = (unsigned int) _1;
  _3 = _2 & 1;
  if (_3 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  D.3287 = 1;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 40>; [INV]

  <bb 4> :
  _4 = commit->object.flags;
  _5 = (unsigned int) _4;
  _6 = _5 & 1024;
  if (_6 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  D.3287 = 0;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 40>; [INV]

  <bb 6> :
  memset (&study, 0, 16);
  memset (&found, 0, 16);
  _7 = &commit->object;
  add_object_array (_7, 0B, &study);
  _8 = &commit->object;
  add_object_array (_8, 0B, &found);
  _9 = commit->object.flags;
  _10 = _9 | 2048;
  commit->object.flags = _10;
  goto <bb 20>; [INV]

  <bb 7> :
  _11 = study.objects;
  _12 = study.nr;
  _13 = _12 + 4294967295;
  study.nr = _13;
  _14 = study.nr;
  _15 = (long unsigned int) _14;
  _16 = _15 * 32;
  _17 = _11 + _16;
  c = _17->item;
  _18 = BIT_FIELD_REF <c->object, 8, 0>;
  _19 = _18 & 1;
  if (_19 == 0)
    goto <bb 8>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 8> :
  _20 = &c->object.oid;
  _21 = parse_object (_20);
  if (_21 == 0)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  _22 = c->object.flags;
  _23 = _22 | 1024;
  c->object.flags = _23;

  <bb 10> :
  _24 = c->object.flags;
  _25 = (unsigned int) _24;
  _26 = _25 & 1024;
  if (_26 != 0)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  is_incomplete = 1;
  goto <bb 21>; [INV]

  <bb 12> :
  _27 = c->object.flags;
  _28 = (unsigned int) _27;
  _29 = _28 & 1;
  if (_29 != 0)
    goto <bb 13>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 13> :
  // predicted unlikely by continue predictor.
  goto <bb 20>; [INV]

  <bb 14> :
  parent = c->parents;
  goto <bb 19>; [INV]

  <bb 15> :
  p = parent->item;
  _30 = p->object.flags;
  _31 = (unsigned int) _30;
  _32 = _31 & 2048;
  if (_32 != 0)
    goto <bb 16>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 16> :
  // predicted unlikely by continue predictor.
  goto <bb 18>; [INV]

  <bb 17> :
  _33 = p->object.flags;
  _34 = _33 | 2048;
  p->object.flags = _34;
  _35 = &p->object;
  add_object_array (_35, 0B, &study);
  _36 = &p->object;
  add_object_array (_36, 0B, &found);

  <bb 18> :
  parent = parent->next;

  <bb 19> :
  if (parent != 0B)
    goto <bb 15>; [INV]
  else
    goto <bb 20>; [INV]

  <bb 20> :
  _37 = study.nr;
  if (_37 != 0)
    goto <bb 7>; [INV]
  else
    goto <bb 21>; [INV]

  <bb 21> :
  if (is_incomplete == 0)
    goto <bb 22>; [INV]
  else
    goto <bb 31>; [INV]

  <bb 22> :
  i = 0;
  goto <bb 26>; [INV]

  <bb 23> :
  _38 = found.objects;
  _39 = (long unsigned int) i;
  _40 = _39 * 32;
  _41 = _38 + _40;
  c = _41->item;
  _42 = c->tree;
  _43 = &_42->object.oid;
  _44 = tree_is_complete (_43);
  if (_44 == 0)
    goto <bb 24>; [INV]
  else
    goto <bb 25>; [INV]

  <bb 24> :
  is_incomplete = 1;
  _45 = c->object.flags;
  _46 = _45 | 1024;
  c->object.flags = _46;

  <bb 25> :
  i = i + 1;

  <bb 26> :
  _47 = found.nr;
  i.0_48 = (unsigned int) i;
  if (_47 > i.0_48)
    goto <bb 23>; [INV]
  else
    goto <bb 27>; [INV]

  <bb 27> :
  if (is_incomplete == 0)
    goto <bb 28>; [INV]
  else
    goto <bb 31>; [INV]

  <bb 28> :
  i = 0;
  goto <bb 30>; [INV]

  <bb 29> :
  _49 = found.objects;
  _50 = (long unsigned int) i;
  _51 = _50 * 32;
  _52 = _49 + _51;
  _53 = _52->item;
  _54 = _53->flags;
  _55 = found.objects;
  _56 = (long unsigned int) i;
  _57 = _56 * 32;
  _58 = _55 + _57;
  _59 = _58->item;
  _60 = _54 | 1;
  _59->flags = _60;
  i = i + 1;

  <bb 30> :
  _61 = found.nr;
  i.1_62 = (unsigned int) i;
  if (_61 > i.1_62)
    goto <bb 29>; [INV]
  else
    goto <bb 31>; [INV]

  <bb 31> :
  i = 0;
  goto <bb 33>; [INV]

  <bb 32> :
  _63 = found.objects;
  _64 = (long unsigned int) i;
  _65 = _64 * 32;
  _66 = _63 + _65;
  _67 = _66->item;
  _68 = _67->flags;
  _69 = found.objects;
  _70 = (long unsigned int) i;
  _71 = _70 * 32;
  _72 = _69 + _71;
  _73 = _72->item;
  _74 = _68 & 134215679;
  _73->flags = _74;
  i = i + 1;

  <bb 33> :
  _75 = found.nr;
  i.2_76 = (unsigned int) i;
  if (_75 > i.2_76)
    goto <bb 32>; [INV]
  else
    goto <bb 34>; [INV]

  <bb 34> :
  if (is_incomplete != 0)
    goto <bb 35>; [INV]
  else
    goto <bb 36>; [INV]

  <bb 35> :
  _77 = commit->object.flags;
  _78 = _77 | 1024;
  commit->object.flags = _78;
  goto <bb 39>; [INV]

  <bb 36> :
  i = 0;
  goto <bb 38>; [INV]

  <bb 37> :
  _79 = found.objects;
  _80 = (long unsigned int) i;
  _81 = _80 * 32;
  _82 = _79 + _81;
  _83 = _82->item;
  _84 = _83->flags;
  _85 = found.objects;
  _86 = (long unsigned int) i;
  _87 = _86 * 32;
  _88 = _85 + _87;
  _89 = _88->item;
  _90 = _84 | 1;
  _89->flags = _90;
  i = i + 1;

  <bb 38> :
  _91 = found.nr;
  i.3_92 = (unsigned int) i;
  if (_91 > i.3_92)
    goto <bb 37>; [INV]
  else
    goto <bb 39>; [INV]

  <bb 39> :
  _93 = study.objects;
  free (_93);
  _94 = found.objects;
  free (_94);
  _95 = is_incomplete == 0;
  D.3287 = (int) _95;

  <bb 40> :
  study = {CLOBBER};
  found = {CLOBBER};
  return D.3287;

}


