
;; Function buffer_get_string (buffer_get_string, funcdef_no=22, decl_uid=3496, cgraph_uid=23, symbol_order=25)

Merging blocks 6 and 7
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6
;; 2 succs { 3 4 }
;; 3 succs { }
;; 4 succs { 5 6 }
;; 5 succs { 6 }
;; 6 succs { 1 }
char * buffer_get_string (struct Buffer * buffer, u_int * length_ptr)
{
  char * value;
  u_int len;
  char * D.3634;

  <bb 2> :
  _1 = buffer_get_int (buffer);
  len = (u_int) _1;
  if (len > 262144)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  printf ("Received packet with bad string length %d", len);
  exit (1);

  <bb 4> :
  _2 = len + 1;
  _3 = (long unsigned int) _2;
  value = malloc (_3);
  buffer_get (buffer, value, len);
  _4 = (sizetype) len;
  _5 = value + _4;
  *_5 = 0;
  if (length_ptr != 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  *length_ptr = len;

  <bb 6> :
  D.3634 = value;
  return D.3634;

}



;; Function packet_get_string (packet_get_string, funcdef_no=23, decl_uid=3505, cgraph_uid=24, symbol_order=26)

Merging blocks 2 and 3
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
char * packet_get_string (u_int * length_ptr)
{
  char * D.3636;

  <bb 2> :
  D.3636 = buffer_get_string (&incoming_packet, length_ptr);
  return D.3636;

}



;; Function auth_krb4 (auth_krb4, funcdef_no=24, decl_uid=3510, cgraph_uid=25, symbol_order=27)

Merging blocks 7 and 8
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7
;; 2 succs { 3 4 }
;; 3 succs { 7 }
;; 4 succs { 5 6 }
;; 5 succs { 7 }
;; 6 succs { 7 }
;; 7 succs { 1 }
int auth_krb4 (struct Authctxt * authctxt, int * auth, char * * client)
{
  int s;
  int r;
  u_int cksum;
  char instance[10];
  <<< error >>> foreign;
  <<< error >>> local;
  int adat[10];
  int D.3640;

  <bb 2> :
  adat = {};
  r = krb_rd_req (auth, "rcmd", &instance, 0, &adat, "");
  if (r != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  D.3640 = 0;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 7>; [INV]

  <bb 4> :
  _1 = malloc (10);
  *client = _1;
  _2 = authctxt->user;
  _3 = kuserok (&adat, _2);
  if (_3 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  _4 = *client;
  free (_4);
  D.3640 = 0;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 7>; [INV]

  <bb 6> :
  D.3640 = 1;

  <bb 7> :
  adat = {CLOBBER};
  instance = {CLOBBER};
  return D.3640;

}



;; Function main (main, funcdef_no=26, decl_uid=3626, cgraph_uid=27, symbol_order=29)

Removing basic block 4
Merging blocks 2 and 3
Merging blocks 2 and 5
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
int main ()
{
  struct Authctxt authctxt;
  int D.3645;

  <bb 2> :
  do_authloop (&authctxt);
  D.3645 = 0;
  authctxt = {CLOBBER};
  return D.3645;

}



;; Function do_authloop (do_authloop, funcdef_no=25, decl_uid=3526, cgraph_uid=26, symbol_order=28)

Removing basic block 16
Removing basic block 40
Removing basic block 43
Removing basic block 44
Removing basic block 58
Merging blocks 59 and 60
;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54
;;
;; Loop 1
;;  header 8, multiple latches: 53 38
;;  depth 1, outer 0
;;  nodes: 8 53 38 37 36 51 52 49 47 48 44 45 46 41 42 15 16 18 19 21 29 31 32 34 35 40 10 39 9 33 30 27 28 25 24 22 20 17 11 14 12 13
;; 2 succs { 3 4 }
;; 3 succs { 5 }
;; 4 succs { 5 }
;; 5 succs { 6 7 }
;; 6 succs { 54 }
;; 7 succs { 8 }
;; 8 succs { 41 17 30 33 20 36 39 9 16 }
;; 9 succs { 10 11 }
;; 10 succs { 41 }
;; 11 succs { 12 15 }
;; 12 succs { 13 14 }
;; 13 succs { 14 }
;; 14 succs { 15 }
;; 15 succs { 41 }
;; 16 succs { 41 }
;; 17 succs { 18 19 }
;; 18 succs { 41 }
;; 19 succs { 41 }
;; 20 succs { 21 22 }
;; 21 succs { 41 }
;; 22 succs { 23 24 }
;; 23 succs { }
;; 24 succs { 26 25 }
;; 25 succs { 26 27 }
;; 26 succs { }
;; 27 succs { 28 29 }
;; 28 succs { 29 }
;; 29 succs { 41 }
;; 30 succs { 31 32 }
;; 31 succs { 41 }
;; 32 succs { 41 }
;; 33 succs { 34 35 }
;; 34 succs { 41 }
;; 35 succs { 41 }
;; 36 succs { 37 41 }
;; 37 succs { 38 41 }
;; 38 succs { 8 }
;; 39 succs { 40 41 }
;; 40 succs { 41 }
;; 41 succs { 42 44 }
;; 42 succs { 43 44 }
;; 43 succs { }
;; 44 succs { 45 47 }
;; 45 succs { 46 47 }
;; 46 succs { 47 }
;; 47 succs { 48 49 }
;; 48 succs { 49 }
;; 49 succs { 50 51 }
;; 50 succs { 54 }
;; 51 succs { 52 53 }
;; 52 succs { 53 }
;; 53 succs { 8 }
;; 54 succs { 1 }
void do_authloop (struct Authctxt * authctxt)
{
  char * response;
  char * challenge;
  KTEXT_ST tkt;
  char * kdata;
  struct passwd * pw;
  int type;
  u_int ulen;
  int elen;
  int nlen;
  int plen;
  u_int dlen;
  char info[1024];
  char * password;
  char * client_user;
  struct BIGNUM * n;
  struct RSA * client_host_key;
  u_int bits;
  int authenticated;
  char * iftmp.0;

  <bb 2> :
  authenticated = 0;
  type = 0;
  pw = authctxt->pw;
  _1 = authctxt->user;
  _2 = authctxt->valid;
  if (_2 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  iftmp.0 = "";
  goto <bb 5>; [INV]

  <bb 4> :
  iftmp.0 = "illegal user ";

  <bb 5> :
  debug ("Attempting authentication for %s%.100s.", iftmp.0, _1);
  _3 = auth_password (authctxt, "");
  if (_3 != 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  auth_log (authctxt, 1, "without authentication", "");
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 54>; [INV]

  <bb 7> :
  client_user = 0B;

  <bb 8> :
  authenticated = 0;
  info[0] = 0;
  type = packet_read (&plen);
  switch (type) <default: <L61> [INV], case 5: <L15> [INV], case 6: <L28> [INV], case 9: <L31> [INV], case 35: <L18> [INV], case 39: <L34> [INV], case 41: <L39> [INV], case 42: <L6> [INV], case 65: <L14> [INV]>

  <bb 9> :
<L6>:
  if (type != 0)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  verbose ("Kerberos authentication disabled.");
  goto <bb 41>; [INV]

  <bb 11> :
  kdata = packet_get_string (&dlen);
  dlen.1_4 = dlen;
  _5 = dlen.1_4 + 4;
  plen.2_6 = plen;
  packet_integrity_check (plen.2_6, _5, type);
  _7 = *kdata;
  if (_7 == 4)
    goto <bb 12>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 12> :
  _8 = auth_krb4 (authctxt, &tkt, &client_user);
  if (_8 != 0)
    goto <bb 13>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 13> :
  authenticated = 1;
  client_user.3_9 = client_user;
  snprintf (&info, 1024, " tktuser %.100s", client_user.3_9);
  client_user.4_10 = client_user;
  free (client_user.4_10);

  <bb 14> :
  tkt = {CLOBBER};

  <bb 15> :
  free (kdata);
  goto <bb 41>; [INV]

  <bb 16> :
<L14>:
  packet_send_debug ("AFS token passing disabled before authentication.");
  goto <bb 41>; [INV]

  <bb 17> :
<L15>:
  if (type != 0)
    goto <bb 18>; [INV]
  else
    goto <bb 19>; [INV]

  <bb 18> :
  verbose ("Rhosts authentication disabled.");
  goto <bb 41>; [INV]

  <bb 19> :
  _11 = packet_get_string (&ulen);
  client_user = _11;
  ulen.5_12 = ulen;
  _13 = ulen.5_12 + 4;
  plen.6_14 = plen;
  packet_integrity_check (plen.6_14, _13, type);
  client_user.7_15 = client_user;
  authenticated = auth_rhosts (pw, client_user.7_15);
  client_user.8_16 = client_user;
  snprintf (&info, 1024, " ruser %.100s", client_user.8_16);
  goto <bb 41>; [INV]

  <bb 20> :
<L18>:
  if (type != 0)
    goto <bb 21>; [INV]
  else
    goto <bb 22>; [INV]

  <bb 21> :
  verbose ("Rhosts with RSA authentication disabled.");
  goto <bb 41>; [INV]

  <bb 22> :
  _17 = packet_get_string (&ulen);
  client_user = _17;
  _18 = RSA_new ();
  _19 = (long int) _18;
  client_host_key = (struct RSA *) _19;
  if (client_host_key == 0B)
    goto <bb 23>; [INV]
  else
    goto <bb 24>; [INV]

  <bb 23> :
  printf ("RSA_new failed%s", "");
  exit (1);

  <bb 24> :
  _20 = BN_new ();
  _21 = (long int) _20;
  _22 = (struct BIGNUM *) _21;
  client_host_key->e = _22;
  _23 = BN_new ();
  _24 = (long int) _23;
  _25 = (struct BIGNUM *) _24;
  client_host_key->n = _25;
  _26 = client_host_key->e;
  if (_26 == 0B)
    goto <bb 26>; [INV]
  else
    goto <bb 25>; [INV]

  <bb 25> :
  _27 = client_host_key->n;
  if (_27 == 0B)
    goto <bb 26>; [INV]
  else
    goto <bb 27>; [INV]

  <bb 26> :
  printf ("BN_new failed%s", "");
  exit (1);

  <bb 27> :
  _28 = packet_get_int ();
  bits = (u_int) _28;
  _29 = client_host_key->e;
  packet_get_bignum (_29, &elen);
  _30 = client_host_key->n;
  packet_get_bignum (_30, &nlen);
  _31 = client_host_key->n;
  _32 = BN_num_bits (_31);
  _33 = (unsigned int) _32;
  if (bits != _33)
    goto <bb 28>; [INV]
  else
    goto <bb 29>; [INV]

  <bb 28> :
  _34 = client_host_key->n;
  _35 = BN_num_bits (_34);
  verbose ("Warning: keysize mismatch for client_host_key: actual %d, announced %d", _35, bits);

  <bb 29> :
  ulen.9_36 = ulen;
  elen.10_37 = elen;
  elen.11_38 = (unsigned int) elen.10_37;
  _39 = ulen.9_36 + elen.11_38;
  nlen.12_40 = nlen;
  nlen.13_41 = (unsigned int) nlen.12_40;
  _42 = _39 + nlen.13_41;
  _43 = _42 + 8;
  plen.14_44 = plen;
  packet_integrity_check (plen.14_44, _43, type);
  client_user.15_45 = client_user;
  authenticated = auth_rhosts_rsa (pw, client_user.15_45, client_host_key);
  RSA_free (client_host_key);
  client_user.16_46 = client_user;
  snprintf (&info, 1024, " ruser %.100s", client_user.16_46);
  goto <bb 41>; [INV]

  <bb 30> :
<L28>:
  if (type != 0)
    goto <bb 31>; [INV]
  else
    goto <bb 32>; [INV]

  <bb 31> :
  verbose ("RSA authentication disabled.");
  goto <bb 41>; [INV]

  <bb 32> :
  _47 = BN_new ();
  _48 = (long int) _47;
  n = (struct BIGNUM *) _48;
  packet_get_bignum (n, &nlen);
  nlen.17_49 = nlen;
  plen.18_50 = plen;
  packet_integrity_check (plen.18_50, nlen.17_49, type);
  authenticated = auth_rsa (pw, n);
  BN_clear_free (n);
  goto <bb 41>; [INV]

  <bb 33> :
<L31>:
  if (type != 0)
    goto <bb 34>; [INV]
  else
    goto <bb 35>; [INV]

  <bb 34> :
  verbose ("Password authentication disabled.");
  goto <bb 41>; [INV]

  <bb 35> :
  password = packet_get_string (&dlen);
  dlen.19_51 = dlen;
  _52 = dlen.19_51 + 4;
  plen.20_53 = plen;
  packet_integrity_check (plen.20_53, _52, type);
  authenticated = auth_pam_password (pw, password);
  _54 = strlen (password);
  memset (password, 0, _54);
  free (password);
  goto <bb 41>; [INV]

  <bb 36> :
<L34>:
  debug ("rcvd SSH_CMSG_AUTH_TIS");
  if (type == 1)
    goto <bb 37>; [INV]
  else
    goto <bb 41>; [INV]

  <bb 37> :
  _55 = get_challenge (authctxt);
  _56 = (long int) _55;
  challenge = (char *) _56;
  if (challenge != 0B)
    goto <bb 38>; [INV]
  else
    goto <bb 41>; [INV]

  <bb 38> :
  debug ("sending challenge \'%s\'", challenge);
  packet_start (40);
  packet_put_cstring (challenge);
  free (challenge);
  packet_send ();
  packet_write_wait ();
  // predicted unlikely by continue predictor.
  goto <bb 8>; [INV]

  <bb 39> :
<L39>:
  debug ("rcvd SSH_CMSG_AUTH_TIS_RESPONSE");
  if (type == 1)
    goto <bb 40>; [INV]
  else
    goto <bb 41>; [INV]

  <bb 40> :
  response = packet_get_string (&dlen);
  debug ("got response \'%s\'", response);
  dlen.21_57 = dlen;
  _58 = dlen.21_57 + 4;
  plen.22_59 = plen;
  packet_integrity_check (plen.22_59, _58, type);
  authenticated = verify_response (authctxt, response);
  dlen.23_60 = dlen;
  _61 = (long unsigned int) dlen.23_60;
  memset (response, 114, _61);
  free (response);

  <bb 41> :
<L61>:
  _62 = authctxt->valid;
  if (_62 == 0)
    goto <bb 42>; [INV]
  else
    goto <bb 44>; [INV]

  <bb 42> :
  if (authenticated != 0)
    goto <bb 43>; [INV]
  else
    goto <bb 44>; [INV]

  <bb 43> :
  _63 = authctxt->user;
  printf ("INTERNAL ERROR: authenticated invalid user %s", _63);
  exit (1);

  <bb 44> :
  if (authenticated != 0)
    goto <bb 45>; [INV]
  else
    goto <bb 47>; [INV]

  <bb 45> :
  client_user.24_64 = client_user;
  _65 = pw->pw_name;
  _66 = do_pam_account (_65, client_user.24_64);
  if (_66 == 0)
    goto <bb 46>; [INV]
  else
    goto <bb 47>; [INV]

  <bb 46> :
  authenticated = 0;

  <bb 47> :
  _67 = get_authname (type);
  auth_log (authctxt, authenticated, _67, &info);
  client_user.25_68 = client_user;
  if (client_user.25_68 != 0B)
    goto <bb 48>; [INV]
  else
    goto <bb 49>; [INV]

  <bb 48> :
  client_user.26_69 = client_user;
  free (client_user.26_69);
  client_user = 0B;

  <bb 49> :
  if (authenticated != 0)
    goto <bb 50>; [INV]
  else
    goto <bb 51>; [INV]

  <bb 50> :
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 54>; [INV]

  <bb 51> :
  _70 = authctxt->failures;
  _71 = _70;
  _72 = _71 + 1;
  authctxt->failures = _72;
  if (_71 > 6)
    goto <bb 52>; [INV]
  else
    goto <bb 53>; [INV]

  <bb 52> :
  _73 = authctxt->user;
  packet_disconnect ("Too many authentication failures for %.100s", _73);

  <bb 53> :
  packet_start (15);
  packet_send ();
  packet_write_wait ();
  goto <bb 8>; [INV]

  <bb 54> :
  client_user = {CLOBBER};
  info = {CLOBBER};
  dlen = {CLOBBER};
  plen = {CLOBBER};
  nlen = {CLOBBER};
  elen = {CLOBBER};
  ulen = {CLOBBER};
  return;

}


