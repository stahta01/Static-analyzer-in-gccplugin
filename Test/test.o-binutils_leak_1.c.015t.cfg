
;; Function discard_cleanups (discard_cleanups, funcdef_no=22, decl_uid=3018, cgraph_uid=23, symbol_order=27)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
void discard_cleanups (struct cleanup * old_chain)
{
  <bb 2> :
  discard_my_cleanups (&cleanup_chain, old_chain);
  return;

}



;; Function discard_final_cleanups (discard_final_cleanups, funcdef_no=23, decl_uid=3023, cgraph_uid=24, symbol_order=28)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
void discard_final_cleanups (struct cleanup * old_chain)
{
  <bb 2> :
  discard_my_cleanups (&final_cleanup_chain, old_chain);
  return;

}



;; Function discard_my_cleanups (discard_my_cleanups, funcdef_no=24, decl_uid=3021, cgraph_uid=25, symbol_order=29)

;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7
;;
;; Loop 1
;;  header 6, latch 5
;;  depth 1, outer 0
;;  nodes: 6 5 3 4
;; 2 succs { 6 }
;; 3 succs { 4 5 }
;; 4 succs { 5 }
;; 5 succs { 6 }
;; 6 succs { 3 7 }
;; 7 succs { 1 }
void discard_my_cleanups (struct cleanup * * pmy_chain, struct cleanup * old_chain)
{
  struct cleanup * ptr;

  <bb 2> :
  goto <bb 6>; [INV]

  <bb 3> :
  _1 = ptr->next;
  *pmy_chain = _1;
  _2 = ptr->free_arg;
  if (_2 != 0B)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  _3 = ptr->free_arg;
  _4 = ptr->arg;
  _3 (_4);

  <bb 5> :
  free (ptr);

  <bb 6> :
  ptr = *pmy_chain;
  if (ptr != old_chain)
    goto <bb 3>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  _5 = ptr->arg;
  printf ("freearg: %x\n", _5);
  return;

}



;; Function do_cleanups (do_cleanups, funcdef_no=26, decl_uid=3028, cgraph_uid=27, symbol_order=31)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
void do_cleanups (struct cleanup * old_chain)
{
  <bb 2> :
  do_my_cleanups (&cleanup_chain, old_chain);
  return;

}



;; Function do_my_cleanups (do_my_cleanups, funcdef_no=25, decl_uid=3026, cgraph_uid=26, symbol_order=30)

;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7
;;
;; Loop 1
;;  header 6, latch 5
;;  depth 1, outer 0
;;  nodes: 6 5 3 4
;; 2 succs { 6 }
;; 3 succs { 4 5 }
;; 4 succs { 5 }
;; 5 succs { 6 }
;; 6 succs { 3 7 }
;; 7 succs { 1 }
void do_my_cleanups (struct cleanup * * pmy_chain, struct cleanup * old_chain)
{
  struct cleanup * ptr;

  <bb 2> :
  goto <bb 6>; [INV]

  <bb 3> :
  _1 = ptr->next;
  *pmy_chain = _1;
  _2 = ptr->function;
  _3 = ptr->arg;
  _2 (_3);
  __builtin_puts (&"cleanup!!!!! ========="[0]);
  _4 = ptr->arg;
  printf ("%x\n", _4);
  _5 = ptr->free_arg;
  if (_5 != 0B)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  _6 = ptr->free_arg;
  _7 = ptr->arg;
  _6 (_7);

  <bb 5> :
  free (ptr);

  <bb 6> :
  ptr = *pmy_chain;
  if (ptr != old_chain)
    goto <bb 3>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  return;

}



;; Function make_cleanup (make_cleanup, funcdef_no=29, decl_uid=3041, cgraph_uid=30, symbol_order=34)

Merging blocks 2 and 3
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
struct cleanup * make_cleanup (void (*<T59c>) (void *) function, void * arg)
{
  struct cleanup * D.3386;

  <bb 2> :
  D.3386 = make_my_cleanup (&cleanup_chain, function, arg);
  return D.3386;

}



;; Function make_my_cleanup (make_my_cleanup, funcdef_no=28, decl_uid=3038, cgraph_uid=29, symbol_order=33)

Merging blocks 2 and 3
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
struct cleanup * make_my_cleanup (struct cleanup * * pmy_chain, void (*<T59c>) (void *) function, void * arg)
{
  struct cleanup * D.3388;

  <bb 2> :
  D.3388 = make_my_cleanup2 (pmy_chain, function, arg, 0B);
  return D.3388;

}



;; Function make_my_cleanup2 (make_my_cleanup2, funcdef_no=27, decl_uid=3034, cgraph_uid=28, symbol_order=32)

Merging blocks 4 and 5
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4
;; 2 succs { 3 4 }
;; 3 succs { }
;; 4 succs { 1 }
struct cleanup * make_my_cleanup2 (struct cleanup * * pmy_chain, void (*<T59c>) (void *) function, void * arg, void (*<Tee>) (void *) free_arg)
{
  struct cleanup * old_chain;
  struct cleanup * new;
  struct cleanup * D.3392;

  <bb 2> :
  new = malloc (32);
  old_chain = *pmy_chain;
  _1 = *pmy_chain;
  new->next = _1;
  new->function = function;
  new->free_arg = free_arg;
  new->arg = arg;
  *pmy_chain = new;
  if (old_chain == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  exit (1);

  <bb 4> :
  D.3392 = old_chain;
  return D.3392;

}



;; Function filename_cmp (filename_cmp, funcdef_no=30, decl_uid=3308, cgraph_uid=31, symbol_order=67)

Merging blocks 2 and 3
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
int filename_cmp (const char * s1, const char * s2)
{
  int D.3394;

  <bb 2> :
  D.3394 = strcmp (s1, s2);
  return D.3394;

}



;; Function make_tempname (make_tempname, funcdef_no=32, decl_uid=3321, cgraph_uid=33, symbol_order=69)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5
;; 2 succs { 3 4 }
;; 3 succs { 5 }
;; 4 succs { 5 }
;; 5 succs { 1 }
char * make_tempname (char * filename)
{
  int fd;
  char * tmpname;
  char * D.3398;

  <bb 2> :
  tmpname = template_in_dir (filename);
  fd = mkstemp (tmpname);
  if (fd == -1)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  free (tmpname);
  D.3398 = 0B;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 5>; [INV]

  <bb 4> :
  close (fd);
  D.3398 = tmpname;

  <bb 5> :
  return D.3398;

}



;; Function template_in_dir (template_in_dir, funcdef_no=31, decl_uid=3312, cgraph_uid=32, symbol_order=68)

Merging blocks 5 and 6
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5
;; 2 succs { 3 4 }
;; 3 succs { 5 }
;; 4 succs { 5 }
;; 5 succs { 1 }
char * template_in_dir (const char * path)
{
  size_t len;
  char * tmpname;
  const char * slash;
  char * D.3403;

  <bb 2> :
  slash = strrchr (path, 47);
  if (slash != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  _1 = slash - path;
  len = (size_t) _1;
  _2 = len + 11;
  tmpname = malloc (_2);
  memcpy (tmpname, path, len);
  len.0_3 = len;
  len = len.0_3 + 1;
  _4 = tmpname + len.0_3;
  *_4 = 47;
  goto <bb 5>; [INV]

  <bb 4> :
  tmpname = malloc (9);
  len = 0;

  <bb 5> :
  _5 = tmpname + len;
  memcpy (_5, "stXXXXXX", 9);
  D.3403 = tmpname;
  return D.3403;

}



;; Function set_times (set_times, funcdef_no=33, decl_uid=3329, cgraph_uid=34, symbol_order=70)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4
;; 2 succs { 3 4 }
;; 3 succs { 4 }
;; 4 succs { 1 }
void set_times (const char * destination, const struct stat * statbuf)
{
  long int tb[2];
  int result;

  <bb 2> :
  _1 = statbuf->st_atim.tv_sec;
  tb[0] = _1;
  _2 = statbuf->st_mtim.tv_sec;
  tb[1] = _2;
  result = utime (destination, &tb);
  tb = {CLOBBER};
  if (result != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  printf ("%s: cannot set time:", destination);

  <bb 4> :
  return;

}



;; Function smart_rename (smart_rename, funcdef_no=34, decl_uid=3338, cgraph_uid=35, symbol_order=71)

Removing basic block 9
Removing basic block 11
Merging blocks 17 and 18
Merging blocks 17 and 19
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
;; 2 succs { 5 3 }
;; 3 succs { 4 10 }
;; 4 succs { 5 10 }
;; 5 succs { 6 9 }
;; 6 succs { 7 15 }
;; 7 succs { 8 15 }
;; 8 succs { 15 }
;; 9 succs { 15 }
;; 10 succs { 11 12 }
;; 11 succs { 12 }
;; 12 succs { 13 14 }
;; 13 succs { 14 }
;; 14 succs { 15 }
;; 15 succs { 1 }
int smart_rename (const char * from, const char * to, int preserve_dates)
{
  int ret;
  struct stat s;
  bfd_boolean exists;
  int D.3423;

  <bb 2> :
  ret = 0;
  _1 = lstat (to, &s);
  _2 = _1 == 0;
  exists = (bfd_boolean) _2;
  if (exists == 0)
    goto <bb 5>; [INV]
  else
    goto <bb 3>; [INV]

  <bb 3> :
  _3 = BIT_FIELD_REF <s, 32, 192>;
  _4 = _3 & 61568;
  if (_4 == 32896)
    goto <bb 4>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 4> :
  _5 = s.st_nlink;
  if (_5 == 1)
    goto <bb 5>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 5> :
  ret = rename (from, to);
  if (ret == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 6> :
  if (exists != 0)
    goto <bb 7>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 7> :
  _6 = s.st_mode;
  _7 = _6 & 511;
  chmod (to, _7);
  _8 = s.st_gid;
  _9 = s.st_uid;
  _10 = chown (to, _9, _8);
  if (_10 >= 0)
    goto <bb 8>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 8> :
  _11 = s.st_mode;
  _12 = _11 & 4095;
  chmod (to, _12);
  goto <bb 15>; [INV]

  <bb 9> :
  printf ("unable to rename \'%s\';", to);
  unlink (from);
  goto <bb 15>; [INV]

  <bb 10> :
  if (ret != 0)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  printf ("unable to copy file \'%s\';", to);

  <bb 12> :
  if (preserve_dates != 0)
    goto <bb 13>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 13> :
  set_times (to, &s);

  <bb 14> :
  unlink (from);

  <bb 15> :
  D.3423 = ret;
  s = {CLOBBER};
  return D.3423;

}



;; Function unlink_if_ordinary (unlink_if_ordinary, funcdef_no=35, decl_uid=3349, cgraph_uid=36, symbol_order=72)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
void unlink_if_ordinary (const char * name)
{
  <bb 2> :
  _1 = MEM[(int *)name];
  printf ("%d\n", _1);
  return;

}



;; Function main (main, funcdef_no=38, decl_uid=3379, cgraph_uid=39, symbol_order=75)

Removing basic block 3
Merging blocks 2 and 4
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
__attribute__((access ("^1[ ]", )))
int main (int argc, char * * argv)
{
  int D.3426;

  <bb 2> :
  _1 = *argv;
  program_name = _1;
  copy_main (argc, argv);
  D.3426 = status;
  return D.3426;

}



;; Function copy_main (copy_main, funcdef_no=37, decl_uid=3364, cgraph_uid=38, symbol_order=74)

Removing basic block 14
Merging blocks 16 and 17
Merging blocks 16 and 18
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
;; 2 succs { 3 4 }
;; 3 succs { 4 }
;; 4 succs { 5 6 }
;; 5 succs { 7 }
;; 6 succs { 7 }
;; 7 succs { 8 9 }
;; 8 succs { }
;; 9 succs { 10 14 }
;; 10 succs { 11 12 }
;; 11 succs { 12 }
;; 12 succs { 13 15 }
;; 13 succs { 15 }
;; 14 succs { 15 }
;; 15 succs { 1 }
__attribute__((access ("^1[ ]", )))
int copy_main (int argc, char * * argv)
{
  const struct bfd_arch_info_type * input_arch;
  int statbuf;
  int c;
  bfd_boolean formats_info;
  bfd_boolean change_warn;
  bfd_boolean show_version;
  char * output_target;
  char * input_target;
  char * tmpname;
  char * output_filename;
  char * input_filename;
  int D.3442;

  <bb 2> :
  input_filename = 0B;
  output_filename = 0B;
  input_target = 0B;
  output_target = 0B;
  show_version = 0;
  change_warn = 1;
  formats_info = 0;
  input_arch = 0B;
  optind.1_1 = optind;
  _2 = (long unsigned int) optind.1_1;
  _3 = _2 * 8;
  _4 = argv + _3;
  input_filename = *_4;
  optind.2_5 = optind;
  _6 = optind.2_5 + 1;
  if (argc > _6)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  optind.3_7 = optind;
  _8 = (sizetype) optind.3_7;
  _9 = _8 + 1;
  _10 = _9 * 8;
  _11 = argv + _10;
  output_filename = *_11;

  <bb 4> :
  if (output_filename == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  tmpname = make_tempname (input_filename);
  goto <bb 7>; [INV]

  <bb 6> :
  tmpname = output_filename;

  <bb 7> :
  if (tmpname == 0B)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  printf ("warning: could not create temporary file whilst copying \'%s\'", input_filename);
  exit (1);

  <bb 9> :
  copy_file (input_filename, tmpname, input_target, output_target, input_arch);
  status.4_12 = status;
  if (status.4_12 == 0)
    goto <bb 10>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 10> :
  preserve_dates.5_13 = preserve_dates;
  if (preserve_dates.5_13 != 0)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  set_times (tmpname, &statbuf);

  <bb 12> :
  if (tmpname != output_filename)
    goto <bb 13>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 13> :
  preserve_dates.6_14 = preserve_dates;
  _15 = smart_rename (tmpname, input_filename, preserve_dates.6_14);
  _16 = _15 != 0;
  _17 = (int) _16;
  status = _17;
  goto <bb 15>; [INV]

  <bb 14> :
  unlink_if_ordinary (tmpname);

  <bb 15> :
  D.3442 = 0;
  statbuf = {CLOBBER};
  return D.3442;

}



;; Function copy_file (copy_file, funcdef_no=36, decl_uid=3356, cgraph_uid=37, symbol_order=73)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6
;; 2 succs { 3 6 }
;; 3 succs { 4 5 }
;; 4 succs { 5 }
;; 5 succs { 6 }
;; 6 succs { 1 }
void copy_file (const char * input_filename, const char * output_filename, const char * input_target, const char * output_target, const struct bfd_arch_info_type * input_arch)
{
  off_t size;
  char * * core_matching;
  char * * obj_matching;
  struct bfd * ibfd;

  <bb 2> :
  _1 = rand ();
  _2 = _1 % 2;
  _3 = _2 == 1;
  size = (off_t) _3;
  if (size <= 0)
    goto <bb 3>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 3> :
  if (size == 0)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  printf ("error: the input file \'%s\' is empty", input_filename);

  <bb 5> :
  status = 1;
  // predicted unlikely by early return (on trees) predictor.

  <bb 6> :
  return;

}


