
;; Function xrealloc (xrealloc, funcdef_no=26, decl_uid=3195, cgraph_uid=27, symbol_order=27)

Merging blocks 9 and 10
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9
;; 2 succs { 3 4 }
;; 3 succs { 4 }
;; 4 succs { 5 9 }
;; 5 succs { 6 7 }
;; 6 succs { 7 }
;; 7 succs { 8 9 }
;; 8 succs { }
;; 9 succs { 1 }
void * xrealloc (void * ptr, size_t size)
{
  void * ret;
  void * D.3280;

  <bb 2> :
  ret = realloc (ptr, size);
  _1 = ret == 0B;
  _2 = size == 0;
  _3 = _1 & _2;
  if (_3 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  ret = realloc (ptr, 1);

  <bb 4> :
  if (ret == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 5> :
  ret = realloc (ptr, size);
  _4 = ret == 0B;
  _5 = size == 0;
  _6 = _4 & _5;
  if (_6 != 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  ret = realloc (ptr, 1);

  <bb 7> :
  if (ret == 0B)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  printf ("Out of memory, realloc failed%s", "");
  exit (1);

  <bb 9> :
  D.3280 = ret;
  return D.3280;

}



;; Function main (main, funcdef_no=29, decl_uid=3235, cgraph_uid=30, symbol_order=31)

Removing basic block 19
Merging blocks 18 and 20
;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18
;;
;; Loop 1
;;  header 17, latch 16
;;  depth 1, outer 0
;;  nodes: 17 16 13 14 10 11 12 5 3 4 8 9 6
;; 2 succs { 17 }
;; 3 succs { 4 5 }
;; 4 succs { 5 }
;; 5 succs { 6 11 }
;; 6 succs { 7 8 }
;; 7 succs { }
;; 8 succs { 9 10 }
;; 9 succs { 10 }
;; 10 succs { 13 }
;; 11 succs { 12 13 }
;; 12 succs { 13 }
;; 13 succs { 14 16 }
;; 14 succs { 15 16 }
;; 15 succs { }
;; 16 succs { 17 }
;; 17 succs { 3 18 }
;; 18 succs { 1 }
int main (int argc, const char * * argv)
{
  int len_w_slash;
  int last;
  const char * src_w_slash;
  int first;
  const char * bad;
  int src_is_dir;
  int length;
  const char * src;
  <<< error >>> st;
  const char * * submodule_gitfile;
  const char * * dest_path;
  const char * * destination;
  const char * * source;
  int ignore_errors;
  int force;
  int show_only;
  int verbose;
  int i;
  char * prefix;
  int D.3297;

  <bb 2> :
  i = 0;
  verbose = 0;
  show_only = 0;
  force = 0;
  ignore_errors = 0;
  source = internal_copy_pathspec (prefix, argv, argc, 0);
  i = 0;
  goto <bb 17>; [INV]

  <bb 3> :
  _1 = (long unsigned int) i;
  _2 = _1 * 8;
  _3 = source + _2;
  src = *_3;
  bad = 0B;
  if (show_only != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  _4 = _ ("Checking rename of \'%s\'");
  _5 = (long int) _4;
  _6 = (const char *) _5;
  printf (_6, src);

  <bb 5> :
  _7 = strlen (src);
  length = (int) _7;
  if (src_is_dir != 0)
    goto <bb 6>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 6> :
  first = cache_name_pos (src, length);
  src_w_slash = add_slash (src);
  len_w_slash = length + 1;
  first = cache_name_pos (src_w_slash, len_w_slash);
  if (first >= 0)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  _8 = _ ("Huh? %s is in index?");
  _9 = (long int) _8;
  _10 = (const char *) _9;
  printf (_10, src_w_slash);
  exit (1);

  <bb 8> :
  first = ~first;
  free (src_w_slash);
  _11 = last - first;
  if (_11 <= 0)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  _12 = _ ("source directory is empty");
  _13 = (long int) _12;
  bad = (const char *) _13;

  <bb 10> :
  _14 = last - first;
  argc = argc + _14;
  goto <bb 13>; [INV]

  <bb 11> :
  _15 = cache_name_pos (src, length);
  if (_15 < 0)
    goto <bb 12>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 12> :
  _16 = _ ("not under version control");
  _17 = (long int) _16;
  bad = (const char *) _17;

  <bb 13> :
  if (bad != 0B)
    goto <bb 14>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 14> :
  if (ignore_errors == 0)
    goto <bb 15>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 15> :
  _18 = _ ("source=%s");
  _19 = (long int) _18;
  _20 = (const char *) _19;
  printf (_20, src);
  exit (1);

  <bb 16> :
  i = i + 1;

  <bb 17> :
  if (i < argc)
    goto <bb 3>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 18> :
  D.3297 = 0;
  return D.3297;

}



;; Function internal_copy_pathspec (internal_copy_pathspec, funcdef_no=27, decl_uid=3202, cgraph_uid=28, symbol_order=28)

Merging blocks 15 and 16
;; 3 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
;;
;; Loop 1
;;  header 14, latch 13
;;  depth 1, outer 0
;;  nodes: 14 13 9 11 12 10 8 5 6 7 3 4
;;
;; Loop 2
;;  header 5, latch 4
;;  depth 2, outer 1
;;  nodes: 5 4 7 6
;; 2 succs { 14 }
;; 3 succs { 5 }
;; 4 succs { 5 }
;; 5 succs { 6 8 }
;; 6 succs { 7 8 }
;; 7 succs { 4 8 }
;; 8 succs { 10 9 }
;; 9 succs { 10 13 }
;; 10 succs { 11 12 }
;; 11 succs { 13 }
;; 12 succs { 13 }
;; 13 succs { 14 }
;; 14 succs { 3 15 }
;; 15 succs { 1 }
const char * * internal_copy_pathspec (const char * prefix, const char * * pathspec, int count, unsigned int flags)
{
  char * it;
  int to_copy;
  int length;
  const char * * result;
  int i;
  const char * * D.3307;

  <bb 2> :
  _1 = count + 1;
  _2 = (long unsigned int) _1;
  _3 = _2 * 8;
  result = malloc (_3);
  _4 = (long unsigned int) count;
  _5 = _4 * 8;
  memcpy (result, pathspec, _5);
  _6 = (long unsigned int) count;
  _7 = _6 * 8;
  _8 = result + _7;
  *_8 = 0B;
  i = 0;
  goto <bb 14>; [INV]

  <bb 3> :
  _9 = (long unsigned int) i;
  _10 = _9 * 8;
  _11 = result + _10;
  _12 = *_11;
  _13 = strlen (_12);
  length = (int) _13;
  to_copy = length;
  goto <bb 5>; [INV]

  <bb 4> :
  to_copy = to_copy + -1;

  <bb 5> :
  _14 = flags & 2;
  if (_14 == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 6> :
  if (to_copy > 0)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  _15 = (long unsigned int) i;
  _16 = _15 * 8;
  _17 = result + _16;
  _18 = *_17;
  _19 = (sizetype) to_copy;
  _20 = _19 + 18446744073709551615;
  _21 = _18 + _20;
  _22 = *_21;
  _23 = (int) _22;
  _24 = is_dir_sep (_23);
  if (_24 != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 8> :
  if (to_copy != length)
    goto <bb 10>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 9> :
  _25 = flags & 1;
  if (_25 != 0)
    goto <bb 10>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 10> :
  _26 = (long unsigned int) i;
  _27 = _26 * 8;
  _28 = result + _27;
  _29 = *_28;
  _30 = xmemdupz (_29, to_copy);
  _31 = (long int) _30;
  it = (char *) _31;
  _32 = flags & 1;
  if (_32 != 0)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  _33 = basename (it);
  _34 = (long int) _33;
  _35 = (const char *) _34;
  _36 = (long unsigned int) i;
  _37 = _36 * 8;
  _38 = result + _37;
  _39 = strdup (_35);
  *_38 = _39;
  free (it);
  goto <bb 13>; [INV]

  <bb 12> :
  _40 = (long unsigned int) i;
  _41 = _40 * 8;
  _42 = result + _41;
  *_42 = it;

  <bb 13> :
  i = i + 1;

  <bb 14> :
  if (i < count)
    goto <bb 3>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 15> :
  D.3307 = result;
  return D.3307;

}



;; Function add_slash (add_slash, funcdef_no=28, decl_uid=3226, cgraph_uid=29, symbol_order=29)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5
;; 2 succs { 3 4 }
;; 3 succs { 5 }
;; 4 succs { 5 }
;; 5 succs { 1 }
const char * add_slash (const char * path)
{
  char * with_slash;
  int len;
  const char * D.3311;

  <bb 2> :
  _1 = strlen (path);
  len = (int) _1;
  _2 = (sizetype) len;
  _3 = _2 + 18446744073709551615;
  _4 = path + _3;
  _5 = *_4;
  if (_5 != 47)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  _6 = len + 2;
  _7 = (long unsigned int) _6;
  with_slash = malloc (_7);
  _8 = (long unsigned int) len;
  memcpy (with_slash, path, _8);
  len.0_9 = len;
  len = len.0_9 + 1;
  _10 = (sizetype) len.0_9;
  _11 = with_slash + _10;
  *_11 = 47;
  _12 = (sizetype) len;
  _13 = with_slash + _12;
  *_13 = 0;
  D.3311 = with_slash;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 5>; [INV]

  <bb 4> :
  D.3311 = path;

  <bb 5> :
  return D.3311;

}


