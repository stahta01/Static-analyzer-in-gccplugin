
;; Function main (main, funcdef_no=23, decl_uid=3810, cgraph_uid=24, symbol_order=35)

Removing basic block 67
Removing basic block 46
Merging blocks 58 and 59
Merging blocks 65 and 66
Merging blocks 65 and 68
;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63
;;
;; Loop 1
;;  header 21, multiple latches: 16 18 19 20
;;  depth 1, outer 0
;;  nodes: 21 16 18 19 20 14 12 13 9 10 6 7 3 4
;; 2 succs { 21 }
;; 3 succs { 4 6 }
;; 4 succs { 5 6 }
;; 5 succs { 60 }
;; 6 succs { 7 9 }
;; 7 succs { 8 9 }
;; 8 succs { 60 }
;; 9 succs { 10 12 }
;; 10 succs { 11 12 }
;; 11 succs { 60 }
;; 12 succs { 13 14 }
;; 13 succs { 14 }
;; 14 succs { 15 16 }
;; 15 succs { 60 }
;; 16 succs { 21 17 18 19 20 }
;; 17 succs { 60 }
;; 18 succs { 21 }
;; 19 succs { 21 }
;; 20 succs { 21 }
;; 21 succs { 3 22 }
;; 22 succs { 23 24 }
;; 23 succs { 17 }
;; 24 succs { 25 29 }
;; 25 succs { 26 27 }
;; 26 succs { 17 }
;; 27 succs { 28 29 }
;; 28 succs { 17 }
;; 29 succs { 30 33 }
;; 30 succs { 31 32 }
;; 31 succs { 17 }
;; 32 succs { 35 }
;; 33 succs { 34 35 }
;; 34 succs { 17 }
;; 35 succs { 36 48 }
;; 36 succs { 37 38 }
;; 37 succs { 60 }
;; 38 succs { 39 40 }
;; 39 succs { 60 }
;; 40 succs { 41 42 }
;; 41 succs { 60 }
;; 42 succs { 43 47 }
;; 43 succs { 44 46 }
;; 44 succs { 45 47 }
;; 45 succs { 60 }
;; 46 succs { 47 }
;; 47 succs { 48 }
;; 48 succs { 49 57 }
;; 49 succs { 50 57 }
;; 50 succs { 51 55 }
;; 51 succs { 52 53 }
;; 52 succs { 54 }
;; 53 succs { 54 }
;; 54 succs { 55 }
;; 55 succs { 56 57 }
;; 56 succs { 60 }
;; 57 succs { 58 59 }
;; 58 succs { 59 }
;; 59 succs { 60 }
;; 60 succs { 61 63 }
;; 61 succs { 62 63 }
;; 62 succs { 63 }
;; 63 succs { 1 }
int main (int argc, char * * argv)
{
  const char * sni;
  struct BIO * stmp;
  struct SSL_SESSION * sess;
  char * psksessf;
  int isdtls;
  const char * early_data_file;
  const char * keylog_file;
  int c_status_req;
  int c_tlsextdebug;
  int c_brief;
  int c_ign_eof;
  int c_msg;
  int c_nbio;
  int maxfraglen;
  int count4or6;
  <unnamed type> connect_type;
  unsigned int max_pipelines;
  unsigned int split_send_fragment;
  unsigned int max_send_fragment;
  int async;
  int no_prot_opt;
  int prot_opt;
  int max_version;
  int min_version;
  int ct_validation;
  char * ctlog_file;
  int srp_lateuser;
  char * srppass;
  const char * next_proto_neg_in;
  int len;
  int start;
  int serverinfo_count;
  short unsigned int serverinfo_types[100];
  const char * ssl_config;
  const char * alpn_in;
  int noservername;
  char * servername;
  long int socket_mtu;
  int enable_timeouts;
  OPTION_CHOICE o;
  int fallback_scsv;
  int read_buf_len;
  int at_eof;
  int ssl_pending;
  int tty_on;
  int read_ssl;
  int write_ssl;
  int read_tty;
  int write_tty;
  int crl_download;
  int crl_format;
  int starttls_proto;
  int cmdletters;
  int sbuf_off;
  int sbuf_len;
  int state;
  int width;
  int k;
  int s;
  int nbio_test;
  int i;
  int in_init;
  int ret;
  int vpmtouched;
  int verify;
  int reconnect;
  int sdebug;
  int prexit;
  int mbuf_len;
  int full_log;
  int crlf;
  int key_format;
  int cert_format;
  int cbuf_off;
  int cbuf_len;
  int build_chain;
  int noCAfile;
  int noCApath;
  struct fd_set writefds;
  struct fd_set readfds;
  struct timeval * timeoutp;
  struct timeval timeout;
  const char * protohost;
  char * p;
  char * crl_file;
  char * sess_in;
  char * ReqCAfile;
  char * vfyCAfile;
  char * vfyCApath;
  char * pass;
  char * passarg;
  char * port;
  char * host;
  char * chCAfile;
  char * chCApath;
  char * chain_file;
  char * key_file;
  char * cert_file;
  char * connectstr;
  char * proxystr;
  char * mbuf;
  char * sbuf;
  char * cbuf;
  const char * CAfile;
  const char * CApath;
  int dane_ee_no_name;
  char * dane_tlsa_domain;
  struct SSL_CONF_CTX * cctx;
  struct SSL * con;
  int D.4055;
  char * iftmp.25;

  <bb 2> :
  con = 0B;
  cctx = 0B;
  dane_tlsa_domain = 0B;
  dane_ee_no_name = 0;
  CApath = 0B;
  CAfile = 0B;
  cbuf = 0B;
  sbuf = 0B;
  mbuf = 0B;
  proxystr = 0B;
  connectstr = 0B;
  cert_file = 0B;
  key_file = 0B;
  chain_file = 0B;
  chCApath = 0B;
  chCAfile = 0B;
  host = 0B;
  _1 = OPENSSL_strdup ("4433");
  _2 = (long int) _1;
  port = (char *) _2;
  passarg = 0B;
  pass = 0B;
  vfyCApath = 0B;
  vfyCAfile = 0B;
  ReqCAfile = 0B;
  sess_in = 0B;
  crl_file = 0B;
  protohost = 0B;
  noCApath = 0;
  noCAfile = 0;
  build_chain = 0;
  cert_format = 32773;
  key_format = 32773;
  crlf = 0;
  full_log = 1;
  mbuf_len = 0;
  prexit = 0;
  sdebug = 0;
  reconnect = 0;
  verify = 0;
  vpmtouched = 0;
  ret = 1;
  in_init = 1;
  nbio_test = 0;
  s = -1;
  state = 0;
  cmdletters = 1;
  starttls_proto = 0;
  crl_format = 32773;
  crl_download = 0;
  at_eof = 0;
  read_buf_len = 0;
  fallback_scsv = 0;
  enable_timeouts = 0;
  socket_mtu = 0;
  servername = 0B;
  noservername = 0;
  alpn_in = 0B;
  ssl_config = 0B;
  serverinfo_count = 0;
  start = 0;
  next_proto_neg_in = 0B;
  srppass = 0B;
  srp_lateuser = 0;
  ctlog_file = 0B;
  ct_validation = 0;
  min_version = 0;
  max_version = 0;
  prot_opt = 0;
  no_prot_opt = 0;
  async = 0;
  max_send_fragment = 0;
  split_send_fragment = 0;
  max_pipelines = 0;
  connect_type = 2;
  count4or6 = 0;
  maxfraglen = 0;
  c_nbio = 0;
  c_msg = 0;
  c_ign_eof = 0;
  c_brief = 0;
  c_tlsextdebug = 0;
  c_status_req = 0;
  keylog_file = 0B;
  early_data_file = 0B;
  isdtls = 0;
  psksessf = 0B;
  _3 = *argv;
  _4 = opt_progname (_3);
  prog = _4;
  c_quiet = 0;
  c_debug = 0;
  c_showcerts = 0;
  c_nbio = 0;
  goto <bb 21>; [INV]

  <bb 3> :
  if (connect_type == 1)
    goto <bb 4>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 4> :
  _5 = IS_INET_FLAG (o);
  if (_5 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  prog.0_6 = prog;
  bio_err.1_7 = bio_err;
  BIO_printf (bio_err.1_7, "%s: Intermixed protocol flags (unix and internet domains)\n", prog.0_6);
  // predicted unlikely by goto predictor.
  goto <bb 60>; [INV]

  <bb 6> :
  if (connect_type == 0)
    goto <bb 7>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 7> :
  _8 = IS_UNIX_FLAG (o);
  if (_8 != 0)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  prog.2_9 = prog;
  bio_err.3_10 = bio_err;
  BIO_printf (bio_err.3_10, "%s: Intermixed protocol flags (internet and unix domains)\n", prog.2_9);
  // predicted unlikely by goto predictor.
  goto <bb 60>; [INV]

  <bb 9> :
  _11 = IS_PROT_FLAG (o);
  if (_11 != 0)
    goto <bb 10>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 10> :
  prot_opt = prot_opt + 1;
  if (prot_opt > 1)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  bio_err.4_12 = bio_err;
  BIO_printf (bio_err.4_12, "Cannot supply multiple protocol flags\n");
  // predicted unlikely by goto predictor.
  goto <bb 60>; [INV]

  <bb 12> :
  o.5_13 = (unsigned int) o;
  _14 = o.5_13 + 4294964295;
  if (_14 <= 4)
    goto <bb 13>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 13> :
  no_prot_opt = no_prot_opt + 1;

  <bb 14> :
  _15 = prot_opt == 1;
  _16 = no_prot_opt != 0;
  _17 = _15 & _16;
  if (_17 != 0)
    goto <bb 15>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 15> :
  bio_err.6_18 = bio_err;
  BIO_printf (bio_err.6_18, "Cannot supply both a protocol flag and \'-no_<prot>\'\n");
  // predicted unlikely by goto predictor.
  goto <bb 60>; [INV]

  <bb 16> :
  switch (o) <default: <L23> [INV], case -1 ... 0: opthelp [INV], case 4: <L20> [INV], case 79: <L21> [INV], case 80: <L22> [INV]>

  <bb 17> :
opthelp:
  prog.7_19 = prog;
  bio_err.8_20 = bio_err;
  BIO_printf (bio_err.8_20, "%s: Use -help for summary.\n", prog.7_19);
  // predicted unlikely by goto predictor.
  goto <bb 60>; [INV]

  <bb 18> :
<L20>:
  connect_type = 0;
  _21 = opt_arg ();
  _22 = (long int) _21;
  _23 = (const char *) _22;
  freeandcopy (&host, _23);
  goto <bb 21>; [INV]

  <bb 19> :
<L21>:
  _24 = opt_arg ();
  _25 = (long int) _24;
  servername = (char *) _25;
  goto <bb 21>; [INV]

  <bb 20> :
<L22>:
  noservername = 1;

  <bb 21> :
<L23>:
  o = opt_next ();
  if (o != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 22>; [INV]

  <bb 22> :
  if (count4or6 > 1)
    goto <bb 23>; [INV]
  else
    goto <bb 24>; [INV]

  <bb 23> :
  prog.9_26 = prog;
  bio_err.10_27 = bio_err;
  BIO_printf (bio_err.10_27, "%s: Can\'t use both -4 and -6\n", prog.9_26);
  // predicted unlikely by goto predictor.
  goto <bb 17>; [INV]

  <bb 24> :
  if (noservername != 0)
    goto <bb 25>; [INV]
  else
    goto <bb 29>; [INV]

  <bb 25> :
  if (servername != 0B)
    goto <bb 26>; [INV]
  else
    goto <bb 27>; [INV]

  <bb 26> :
  prog.11_28 = prog;
  bio_err.12_29 = bio_err;
  BIO_printf (bio_err.12_29, "%s: Can\'t use -servername and -noservername together\n", prog.11_28);
  // predicted unlikely by goto predictor.
  goto <bb 17>; [INV]

  <bb 27> :
  if (dane_tlsa_domain != 0B)
    goto <bb 28>; [INV]
  else
    goto <bb 29>; [INV]

  <bb 28> :
  prog.13_30 = prog;
  bio_err.14_31 = bio_err;
  BIO_printf (bio_err.14_31, "%s: Can\'t use -dane_tlsa_domain and -noservername together\n", prog.13_30);
  // predicted unlikely by goto predictor.
  goto <bb 17>; [INV]

  <bb 29> :
  argc = opt_num_rest ();
  if (argc == 1)
    goto <bb 30>; [INV]
  else
    goto <bb 33>; [INV]

  <bb 30> :
  if (connectstr != 0B)
    goto <bb 31>; [INV]
  else
    goto <bb 32>; [INV]

  <bb 31> :
  prog.15_32 = prog;
  bio_err.16_33 = bio_err;
  BIO_printf (bio_err.16_33, "%s: must not provide both -connect option and target parameter\n", prog.15_32);
  // predicted unlikely by goto predictor.
  goto <bb 17>; [INV]

  <bb 32> :
  connect_type = 0;
  goto <bb 35>; [INV]

  <bb 33> :
  if (argc != 0)
    goto <bb 34>; [INV]
  else
    goto <bb 35>; [INV]

  <bb 34> :
  // predicted unlikely by goto predictor.
  goto <bb 17>; [INV]

  <bb 35> :
  if (sess_in != 0B)
    goto <bb 36>; [INV]
  else
    goto <bb 48>; [INV]

  <bb 36> :
  _34 = BIO_new_file (sess_in, "r");
  _35 = (long int) _34;
  stmp = (struct BIO *) _35;
  if (stmp == 0B)
    goto <bb 37>; [INV]
  else
    goto <bb 38>; [INV]

  <bb 37> :
  bio_err.17_36 = bio_err;
  BIO_printf (bio_err.17_36, "Can\'t open session file %s\n", sess_in);
  bio_err.18_37 = bio_err;
  ERR_print_errors (bio_err.18_37);
  // predicted unlikely by goto predictor.
  goto <bb 60>; [INV]

  <bb 38> :
  _38 = PEM_read_bio_SSL_SESSION (stmp, 0B, 0, 0B);
  _39 = (long int) _38;
  sess = (struct SSL_SESSION *) _39;
  BIO_free (stmp);
  if (sess == 0B)
    goto <bb 39>; [INV]
  else
    goto <bb 40>; [INV]

  <bb 39> :
  bio_err.19_40 = bio_err;
  BIO_printf (bio_err.19_40, "Can\'t open session file %s\n", sess_in);
  bio_err.20_41 = bio_err;
  ERR_print_errors (bio_err.20_41);
  // predicted unlikely by goto predictor.
  goto <bb 60>; [INV]

  <bb 40> :
  _42 = SSL_set_session (con, sess);
  if (_42 == 0)
    goto <bb 41>; [INV]
  else
    goto <bb 42>; [INV]

  <bb 41> :
  bio_err.21_43 = bio_err;
  BIO_printf (bio_err.21_43, "Can\'t set session\n");
  bio_err.22_44 = bio_err;
  ERR_print_errors (bio_err.22_44);
  // predicted unlikely by goto predictor.
  goto <bb 60>; [INV]

  <bb 42> :
  _45 = noservername == 0;
  _46 = servername == 0B;
  _47 = _45 & _46;
  if (_47 != 0)
    goto <bb 43>; [INV]
  else
    goto <bb 47>; [INV]

  <bb 43> :
  _48 = SSL_SESSION_get0_hostname (sess);
  _49 = (long int) _48;
  sni = (const char *) _49;
  if (sni != 0B)
    goto <bb 44>; [INV]
  else
    goto <bb 46>; [INV]

  <bb 44> :
  _50 = OPENSSL_strdup (sni);
  _51 = (long int) _50;
  servername = (char *) _51;
  if (servername == 0B)
    goto <bb 45>; [INV]
  else
    goto <bb 47>; [INV]

  <bb 45> :
  bio_err.23_52 = bio_err;
  BIO_printf (bio_err.23_52, "Can\'t set server name\n");
  bio_err.24_53 = bio_err;
  ERR_print_errors (bio_err.24_53);
  // predicted unlikely by goto predictor.
  goto <bb 60>; [INV]

  <bb 46> :
  noservername = 1;

  <bb 47> :
  SSL_SESSION_free (sess);

  <bb 48> :
  if (noservername == 0)
    goto <bb 49>; [INV]
  else
    goto <bb 57>; [INV]

  <bb 49> :
  _54 = servername != 0B;
  _55 = dane_tlsa_domain == 0B;
  _56 = _54 | _55;
  if (_56 != 0)
    goto <bb 50>; [INV]
  else
    goto <bb 57>; [INV]

  <bb 50> :
  if (servername == 0B)
    goto <bb 51>; [INV]
  else
    goto <bb 55>; [INV]

  <bb 51> :
  host.26_57 = host;
  if (host.26_57 != 0B)
    goto <bb 52>; [INV]
  else
    goto <bb 53>; [INV]

  <bb 52> :
  iftmp.25 = host;
  goto <bb 54>; [INV]

  <bb 53> :
  iftmp.25 = "localhost";

  <bb 54> :
  servername = iftmp.25;

  <bb 55> :
  _58 = SSL_set_tlsext_host_name (con, servername);
  if (_58 == 0)
    goto <bb 56>; [INV]
  else
    goto <bb 57>; [INV]

  <bb 56> :
  bio_err.27_59 = bio_err;
  BIO_printf (bio_err.27_59, "Unable to set TLS servername extension.\n");
  bio_err.28_60 = bio_err;
  ERR_print_errors (bio_err.28_60);
  // predicted unlikely by goto predictor.
  goto <bb 60>; [INV]

  <bb 57> :
re_start:
  ret = 0;
  if (in_init != 0)
    goto <bb 58>; [INV]
  else
    goto <bb 59>; [INV]

  <bb 58> :
  bio_c_out.29_61 = bio_c_out;
  print_stuff (bio_c_out.29_61, con, full_log);

  <bb 59> :
  do_ssl_shutdown (con);

  <bb 60> :
end:
  if (con != 0B)
    goto <bb 61>; [INV]
  else
    goto <bb 63>; [INV]

  <bb 61> :
  if (prexit != 0)
    goto <bb 62>; [INV]
  else
    goto <bb 63>; [INV]

  <bb 62> :
  bio_c_out.30_62 = bio_c_out;
  print_stuff (bio_c_out.30_62, con, 1);

  <bb 63> :
  host.31_63 = host;
  free (host.31_63);
  D.4055 = ret;
  host = {CLOBBER};
  timeout = {CLOBBER};
  readfds = {CLOBBER};
  writefds = {CLOBBER};
  serverinfo_types = {CLOBBER};
  return D.4055;

}



;; Function freeandcopy (freeandcopy, funcdef_no=22, decl_uid=3804, cgraph_uid=23, symbol_order=34)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4
;; 2 succs { 3 4 }
;; 3 succs { 4 }
;; 4 succs { 1 }
void freeandcopy (char * * dest, const char * source)
{
  <bb 2> :
  _1 = *dest;
  free (_1);
  *dest = 0B;
  if (source != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  _2 = OPENSSL_strdup (source);
  _3 = (long int) _2;
  _4 = (char *) _3;
  *dest = _4;

  <bb 4> :
  return;

}


