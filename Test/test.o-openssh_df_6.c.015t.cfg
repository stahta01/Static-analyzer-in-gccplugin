
;; Function clear_pass (clear_pass, funcdef_no=22, decl_uid=4091, cgraph_uid=23, symbol_order=24)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4
;; 2 succs { 3 4 }
;; 3 succs { 4 }
;; 4 succs { 1 }
void clear_pass ()
{
  <bb 2> :
  pass.0_1 = pass;
  if (pass.0_1 != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  pass.1_2 = pass;
  _3 = strlen (pass.1_2);
  pass.2_4 = pass;
  memset (pass.2_4, 0, _3);
  pass.3_5 = pass;
  free (pass.3_5);
  pass = 0B;

  <bb 4> :
  return;

}



;; Function ssh_askpass (ssh_askpass, funcdef_no=23, decl_uid=4097, cgraph_uid=24, symbol_order=25)

Merging blocks 22 and 23
;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22
;;
;; Loop 1
;;  header 16, latch 15
;;  depth 1, outer 0
;;  nodes: 16 15
;; 2 succs { 3 4 }
;; 3 succs { 4 }
;; 4 succs { 5 6 }
;; 5 succs { }
;; 6 succs { 7 8 }
;; 7 succs { }
;; 8 succs { 9 10 }
;; 9 succs { }
;; 10 succs { 11 14 }
;; 11 succs { 12 13 }
;; 12 succs { }
;; 13 succs { }
;; 14 succs { 16 }
;; 15 succs { 17 16 }
;; 16 succs { 15 17 }
;; 17 succs { 18 19 }
;; 18 succs { 22 }
;; 19 succs { 20 21 }
;; 20 succs { 21 }
;; 21 succs { 22 }
;; 22 succs { 1 }
char * ssh_askpass (char * askpass, char * msg)
{
  char buf[1024];
  int status;
  int p[2];
  char * pass;
  char * nl;
  size_t len;
  pid_t pid;
  char * D.4218;

  <bb 2> :
  stdout.4_1 = stdout;
  _2 = fflush (stdout.4_1);
  if (_2 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  _3 = __errno_location ();
  _4 = *_3;
  _5 = strerror (_4);
  error ("ssh_askpass: fflush: %s", _5);

  <bb 4> :
  if (askpass == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  printf ("internal error: askpass undefined%s", "");
  exit (1);

  <bb 6> :
  _6 = pipe (&p);
  if (_6 < 0)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  _7 = __errno_location ();
  _8 = *_7;
  _9 = strerror (_8);
  printf ("ssh_askpass: pipe: %s", _9);
  exit (1);

  <bb 8> :
  pid = fork ();
  if (pid < 0)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  _10 = __errno_location ();
  _11 = *_10;
  _12 = strerror (_11);
  printf ("ssh_askpass: fork: %s", _12);
  exit (1);

  <bb 10> :
  if (pid == 0)
    goto <bb 11>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 11> :
  _13 = p[0];
  close (_13);
  _14 = p[1];
  _15 = dup2 (_14, 1);
  if (_15 < 0)
    goto <bb 12>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 12> :
  _16 = __errno_location ();
  _17 = *_16;
  _18 = strerror (_17);
  printf ("ssh_askpass: dup2: %s", _18);
  exit (1);

  <bb 13> :
  execlp (askpass, askpass, msg, 0B);
  printf ("ssh_askpass: exec(%s)", askpass);
  exit (1);

  <bb 14> :
  _19 = p[1];
  close (_19);
  _20 = p[0];
  _21 = read (_20, &buf, 1024);
  len = (size_t) _21;
  _22 = p[0];
  close (_22);
  goto <bb 16>; [INV]

  <bb 15> :
  _23 = __errno_location ();
  _24 = *_23;
  if (_24 != 4)
    goto <bb 17>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 16> :
  _25 = waitpid (pid, &status, 0);
  if (_25 < 0)
    goto <bb 15>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 17> :
  if (len <= 1)
    goto <bb 18>; [INV]
  else
    goto <bb 19>; [INV]

  <bb 18> :
  D.4218 = strdup ("");
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 22>; [INV]

  <bb 19> :
  nl = strchr (&buf, 10);
  if (nl != 0B)
    goto <bb 20>; [INV]
  else
    goto <bb 21>; [INV]

  <bb 20> :
  *nl = 0;

  <bb 21> :
  pass = strdup (&buf);
  memset (&buf, 0, 1024);
  D.4218 = pass;

  <bb 22> :
  p = {CLOBBER};
  status = {CLOBBER};
  buf = {CLOBBER};
  return D.4218;

}



;; Function add_file (add_file, funcdef_no=24, decl_uid=4135, cgraph_uid=25, symbol_order=26)

;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30
;;
;; Loop 1
;;  header 18, latch 24
;;  depth 1, outer 0
;;  nodes: 18 24 23 21 19 20
;; 2 succs { 3 4 }
;; 3 succs { }
;; 4 succs { 5 9 }
;; 5 succs { 6 9 }
;; 6 succs { 7 8 }
;; 7 succs { 9 }
;; 8 succs { 9 }
;; 9 succs { 10 11 }
;; 10 succs { 11 }
;; 11 succs { 12 14 }
;; 12 succs { 13 14 }
;; 13 succs { 14 }
;; 14 succs { 15 25 }
;; 15 succs { 16 17 }
;; 16 succs { 29 }
;; 17 succs { 18 }
;; 18 succs { 19 20 }
;; 19 succs { 21 }
;; 20 succs { 21 }
;; 21 succs { 22 23 }
;; 22 succs { 29 }
;; 23 succs { 25 24 }
;; 24 succs { 18 }
;; 25 succs { 26 27 }
;; 26 succs { 28 }
;; 27 succs { 28 }
;; 28 succs { 30 }
;; 29 succs { 30 }
;; 30 succs { 1 }
void add_file (struct AuthenticationConnection * ac, const char * filename)
{
  const unsigned char D.4252;
  int interactive;
  char msg[1024];
  char buf[1024];
  char * askpass;
  char * comment;
  struct Key * private;
  struct stat st;

  <bb 2> :
  comment = 0B;
  askpass = 0B;
  interactive = isatty (0);
  _1 = stat (filename, &st);
  if (_1 < 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  perror (filename);
  exit (1);

  <bb 4> :
  if (interactive == 0)
    goto <bb 5>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 5> :
  _2 = getenv ("DISPLAY");
  if (_2 != 0B)
    goto <bb 6>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 6> :
  _3 = getenv ("SSH_ASKPASS");
  if (_3 != 0B)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  askpass = getenv ("SSH_ASKPASS");
  goto <bb 9>; [INV]

  <bb 8> :
  askpass = "/usr/X11R6/bin/ssh-askpass";

  <bb 9> :
  _4 = key_load_private (filename, "", &comment);
  _5 = (long int) _4;
  private = (struct Key *) _5;
  comment.5_6 = comment;
  if (comment.5_6 == 0B)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  _7 = strdup (filename);
  comment = _7;

  <bb 11> :
  if (private == 0B)
    goto <bb 12>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 12> :
  pass.6_8 = pass;
  if (pass.6_8 != 0B)
    goto <bb 13>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 13> :
  pass.7_9 = pass;
  _10 = key_load_private (filename, pass.7_9, 0B);
  _11 = (long int) _10;
  private = (struct Key *) _11;

  <bb 14> :
  if (private == 0B)
    goto <bb 15>; [INV]
  else
    goto <bb 25>; [INV]

  <bb 15> :
  clear_pass ();
  printf ("Need passphrase for %.200s\n", filename);
  _12 = interactive == 0;
  _13 = askpass == 0B;
  _14 = _12 & _13;
  if (_14 != 0)
    goto <bb 16>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 16> :
  comment.8_15 = comment;
  free (comment.8_15);
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 29>; [INV]

  <bb 17> :
  comment.9_16 = comment;
  snprintf (&msg, 1024, "Enter passphrase for %.200s", comment.9_16);

  <bb 18> :
  if (interactive != 0)
    goto <bb 19>; [INV]
  else
    goto <bb 20>; [INV]

  <bb 19> :
  snprintf (&buf, 1024, "%s: ", &msg);
  _17 = read_passphrase (&buf, 1);
  _18 = (long int) _17;
  _19 = (char *) _18;
  pass = _19;
  goto <bb 21>; [INV]

  <bb 20> :
  _20 = ssh_askpass (askpass, &msg);
  pass = _20;

  <bb 21> :
  pass.10_21 = pass;
  D.4252 = MEM[(const unsigned char * {ref-all})pass.10_21];
  _22 = (int) D.4252;
  if (_22 == 0)
    goto <bb 22>; [INV]
  else
    goto <bb 23>; [INV]

  <bb 22> :
  pass.11_23 = pass;
  free (pass.11_23);
  comment.12_24 = comment;
  free (comment.12_24);
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 29>; [INV]

  <bb 23> :
  pass.13_25 = pass;
  _26 = key_load_private (filename, pass.13_25, &comment);
  _27 = (long int) _26;
  private = (struct Key *) _27;
  if (private != 0B)
    goto <bb 25>; [INV]
  else
    goto <bb 24>; [INV]

  <bb 24> :
  clear_pass ();
  strlcpy (&msg, "Bad passphrase, try again", 1024);
  goto <bb 18>; [INV]

  <bb 25> :
  comment.14_28 = comment;
  _29 = ssh_add_identity (ac, private, comment.14_28);
  if (_29 != 0)
    goto <bb 26>; [INV]
  else
    goto <bb 27>; [INV]

  <bb 26> :
  comment.15_30 = comment;
  stderr.16_31 = stderr;
  fprintf (stderr.16_31, "Identity added: %s (%s)\n", filename, comment.15_30);
  goto <bb 28>; [INV]

  <bb 27> :
  stderr.17_32 = stderr;
  fprintf (stderr.17_32, "Could not add identity: %s\n", filename);

  <bb 28> :
  comment.18_33 = comment;
  free (comment.18_33);
  key_free (private);
  st = {CLOBBER};
  comment = {CLOBBER};
  buf = {CLOBBER};
  msg = {CLOBBER};
  goto <bb 30>; [INV]

  <bb 29> :
  st = {CLOBBER};
  comment = {CLOBBER};
  buf = {CLOBBER};
  msg = {CLOBBER};

  <bb 30> :
  return;

}



;; Function main (main, funcdef_no=25, decl_uid=4163, cgraph_uid=26, symbol_order=27)

Removing basic block 25
Merging blocks 23 and 24
Merging blocks 23 and 26
;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23
;;
;; Loop 1
;;  header 16, latch 15
;;  depth 1, outer 0
;;  nodes: 16 15 7 9 11 13 14 12 10 8 6 5
;; 2 succs { 3 4 }
;; 3 succs { }
;; 4 succs { 16 }
;; 5 succs { 7 6 }
;; 6 succs { 7 8 }
;; 7 succs { 15 }
;; 8 succs { 9 10 }
;; 9 succs { 15 }
;; 10 succs { 11 12 }
;; 11 succs { 15 }
;; 12 succs { 13 14 }
;; 13 succs { 15 }
;; 14 succs { 15 }
;; 15 succs { 16 }
;; 16 succs { 5 17 }
;; 17 succs { 18 23 }
;; 18 succs { 19 20 }
;; 19 succs { }
;; 20 succs { 21 22 }
;; 21 succs { 23 }
;; 22 succs { 23 }
;; 23 succs { 1 }
int main (int argc, char * * argv)
{
  int deleting;
  int i;
  int no_files;
  char buf[1024];
  struct passwd * pw;
  struct AuthenticationConnection * ac;
  int D.4274;

  <bb 2> :
  ac = 0B;
  no_files = 1;
  deleting = 0;
  _1 = *argv;
  _2 = get_progname (_1);
  _3 = (long int) _2;
  _4 = (char *) _3;
  __progname = _4;
  init_rng ();
  SSLeay_add_all_algorithms ();
  _5 = ssh_get_authentication_connection ();
  _6 = (long int) _5;
  ac = (struct AuthenticationConnection *) _6;
  if (ac == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  stderr.19_7 = stderr;
  __builtin_fwrite ("Could not open a connection to your authentication agent.\n", 1, 58, stderr.19_7);
  exit (1);

  <bb 4> :
  i = 1;
  goto <bb 16>; [INV]

  <bb 5> :
  _8 = (long unsigned int) i;
  _9 = _8 * 8;
  _10 = argv + _9;
  _11 = *_10;
  _12 = strcmp (_11, "-l");
  if (_12 == 0)
    goto <bb 7>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 6> :
  _13 = (long unsigned int) i;
  _14 = _13 * 8;
  _15 = argv + _14;
  _16 = *_15;
  _17 = strcmp (_16, "-L");
  if (_17 == 0)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  _18 = (long unsigned int) i;
  _19 = _18 * 8;
  _20 = argv + _19;
  _21 = *_20;
  _22 = _21 + 1;
  _23 = *_22;
  _24 = _23 == 108;
  _25 = (int) _24;
  list_identities (ac, _25);
  no_files = 0;
  // predicted unlikely by continue predictor.
  goto <bb 15>; [INV]

  <bb 8> :
  _26 = (long unsigned int) i;
  _27 = _26 * 8;
  _28 = argv + _27;
  _29 = *_28;
  _30 = strcmp (_29, "-d");
  if (_30 == 0)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  deleting = 1;
  // predicted unlikely by continue predictor.
  goto <bb 15>; [INV]

  <bb 10> :
  _31 = (long unsigned int) i;
  _32 = _31 * 8;
  _33 = argv + _32;
  _34 = *_33;
  _35 = strcmp (_34, "-D");
  if (_35 == 0)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  delete_all (ac);
  no_files = 0;
  // predicted unlikely by continue predictor.
  goto <bb 15>; [INV]

  <bb 12> :
  no_files = 0;
  if (deleting != 0)
    goto <bb 13>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 13> :
  _36 = (long unsigned int) i;
  _37 = _36 * 8;
  _38 = argv + _37;
  _39 = *_38;
  delete_file (ac, _39);
  goto <bb 15>; [INV]

  <bb 14> :
  _40 = (long unsigned int) i;
  _41 = _40 * 8;
  _42 = argv + _41;
  _43 = *_42;
  add_file (ac, _43);

  <bb 15> :
  i = i + 1;

  <bb 16> :
  if (i < argc)
    goto <bb 5>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 17> :
  if (no_files != 0)
    goto <bb 18>; [INV]
  else
    goto <bb 23>; [INV]

  <bb 18> :
  _44 = getuid ();
  _45 = getpwuid (_44);
  _46 = (long int) _45;
  pw = (struct passwd *) _46;
  if (pw == 0B)
    goto <bb 19>; [INV]
  else
    goto <bb 20>; [INV]

  <bb 19> :
  _47 = getuid ();
  _48 = (unsigned int) _47;
  stderr.20_49 = stderr;
  fprintf (stderr.20_49, "No user found with uid %u\n", _48);
  ssh_close_authentication_connection (ac);
  exit (1);

  <bb 20> :
  if (deleting != 0)
    goto <bb 21>; [INV]
  else
    goto <bb 22>; [INV]

  <bb 21> :
  delete_file (ac, &buf);
  goto <bb 23>; [INV]

  <bb 22> :
  add_file (ac, &buf);

  <bb 23> :
  clear_pass ();
  ssh_close_authentication_connection (ac);
  D.4274 = 0;
  buf = {CLOBBER};
  return D.4274;

}


