
;; Function test_ptr (test_ptr, funcdef_no=22, decl_uid=3597, cgraph_uid=23, symbol_order=22)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5
;; 2 succs { 3 4 }
;; 3 succs { 5 }
;; 4 succs { 5 }
;; 5 succs { 1 }
int test_ptr (const char * file, int line, const char * s, const void * p)
{
  int D.3776;

  <bb 2> :
  if (p != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  D.3776 = 1;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 5>; [INV]

  <bb 4> :
  test_fail_message (0B, file, line, "ptr", s, "NULL", "!=", "%p", p);
  D.3776 = 0;

  <bb 5> :
  return D.3776;

}



;; Function test_true (test_true, funcdef_no=23, decl_uid=3605, cgraph_uid=24, symbol_order=23)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5
;; 2 succs { 3 4 }
;; 3 succs { 5 }
;; 4 succs { 5 }
;; 5 succs { 1 }
int test_true (const char * file, int line, const char * s, int b)
{
  int D.3780;

  <bb 2> :
  if (b != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  D.3780 = 1;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 5>; [INV]

  <bb 4> :
  test_fail_message (0B, file, line, "bool", s, "true", "==", "false");
  D.3780 = 0;

  <bb 5> :
  return D.3780;

}



;; Function ASN1_STRING_set (ASN1_STRING_set, funcdef_no=24, decl_uid=3611, cgraph_uid=25, symbol_order=24)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13
;; 2 succs { 3 6 }
;; 3 succs { 4 5 }
;; 4 succs { 13 }
;; 5 succs { 6 }
;; 6 succs { 8 7 }
;; 7 succs { 8 10 }
;; 8 succs { 9 10 }
;; 9 succs { 13 }
;; 10 succs { 11 12 }
;; 11 succs { 12 }
;; 12 succs { 13 }
;; 13 succs { 1 }
int ASN1_STRING_set (struct ASN1_STRING * str, const void * _data, int len)
{
  const char * data;
  unsigned char * c;
  int D.3786;

  <bb 2> :
  data = _data;
  if (len < 0)
    goto <bb 3>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 3> :
  if (data == 0B)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  D.3786 = 0;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 13>; [INV]

  <bb 5> :
  _1 = strlen (data);
  len = (int) _1;

  <bb 6> :
  _2 = str->length;
  if (len >= _2)
    goto <bb 8>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  _3 = str->data;
  if (_3 == 0B)
    goto <bb 8>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 8> :
  c = str->data;
  _4 = len + 1;
  _5 = OPENSSL_realloc (c, _4);
  _6 = (long int) _5;
  _7 = (unsigned char *) _6;
  str->data = _7;
  _8 = str->data;
  if (_8 == 0B)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  str->data = c;
  D.3786 = 0;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 13>; [INV]

  <bb 10> :
  str->length = len;
  if (data != 0B)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  _9 = (long unsigned int) len;
  _10 = str->data;
  memcpy (_10, data, _9);
  _11 = str->data;
  _12 = (sizetype) len;
  _13 = _11 + _12;
  *_13 = 0;

  <bb 12> :
  D.3786 = 1;

  <bb 13> :
  return D.3786;

}



;; Function ASN1_INTEGER_set_uint64 (ASN1_INTEGER_set_uint64, funcdef_no=26, decl_uid=3630, cgraph_uid=27, symbol_order=26)

Merging blocks 2 and 3
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
int ASN1_INTEGER_set_uint64 (struct ASN1_INTEGER * a, uint64_t r)
{
  int D.3795;

  <bb 2> :
  D.3795 = asn1_string_set_uint64 (a, r, 2);
  return D.3795;

}



;; Function asn1_string_set_uint64 (asn1_string_set_uint64, funcdef_no=25, decl_uid=3622, cgraph_uid=26, symbol_order=25)

Merging blocks 2 and 3
Merging blocks 2 and 4
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
int asn1_string_set_uint64 (struct ASN1_STRING * a, uint64_t r, int itype)
{
  size_t off;
  unsigned char tbuf[8];
  int D.3797;

  <bb 2> :
  a->type = itype;
  _1 = asn1_put_uint64 (&tbuf, r);
  off = (size_t) _1;
  _2 = (unsigned int) off;
  _3 = 8 - _2;
  _4 = (int) _3;
  _5 = &tbuf + off;
  D.3797 = ASN1_STRING_set (a, _5, _4);
  tbuf = {CLOBBER};
  return D.3797;

}



;; Function ASN1_BIT_STRING_set (ASN1_BIT_STRING_set, funcdef_no=27, decl_uid=3635, cgraph_uid=28, symbol_order=27)

Merging blocks 2 and 3
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
int ASN1_BIT_STRING_set (struct ASN1_BIT_STRING * x, unsigned char * d, int len)
{
  int D.3800;

  <bb 2> :
  D.3800 = ASN1_STRING_set (x, d, len);
  return D.3800;

}



;; Function asn1_time_from_tm (asn1_time_from_tm, funcdef_no=28, decl_uid=3640, cgraph_uid=29, symbol_order=28)

Removing basic block 6
Removing basic block 10
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
;; 2 succs { 3 6 }
;; 3 succs { 4 5 }
;; 4 succs { 11 }
;; 5 succs { 11 }
;; 6 succs { 7 9 }
;; 7 succs { 8 11 }
;; 8 succs { 22 }
;; 9 succs { 10 11 }
;; 10 succs { 22 }
;; 11 succs { 12 13 }
;; 12 succs { 14 }
;; 13 succs { 14 }
;; 14 succs { 15 16 }
;; 15 succs { 25 }
;; 16 succs { 17 18 }
;; 17 succs { 22 }
;; 18 succs { 19 20 }
;; 19 succs { 21 }
;; 20 succs { 21 }
;; 21 succs { 25 }
;; 22 succs { 23 24 }
;; 23 succs { 24 }
;; 24 succs { 25 }
;; 25 succs { 1 }
struct ASN1_TIME * asn1_time_from_tm (struct ASN1_TIME * s, struct tm * ts, int type)
{
  const size_t len;
  struct ASN1_TIME * tmps;
  char * p;
  struct ASN1_TIME * D.3820;

  <bb 2> :
  tmps = 0B;
  len = 20;
  if (type == -1)
    goto <bb 3>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 3> :
  _1 = ts->tm_year;
  _2 = is_utc (_1);
  if (_2 != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  type = 23;
  goto <bb 11>; [INV]

  <bb 5> :
  type = 24;
  goto <bb 11>; [INV]

  <bb 6> :
  if (type == 23)
    goto <bb 7>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 7> :
  _3 = ts->tm_year;
  _4 = is_utc (_3);
  if (_4 == 0)
    goto <bb 8>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 8> :
  // predicted unlikely by goto predictor.
  goto <bb 22>; [INV]

  <bb 9> :
  if (type != 24)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  // predicted unlikely by goto predictor.
  goto <bb 22>; [INV]

  <bb 11> :
  if (s == 0B)
    goto <bb 12>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 12> :
  _5 = ASN1_STRING_new ();
  _6 = (long int) _5;
  tmps = (struct ASN1_TIME *) _6;
  goto <bb 14>; [INV]

  <bb 13> :
  tmps = s;

  <bb 14> :
  if (tmps == 0B)
    goto <bb 15>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 15> :
  D.3820 = 0B;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 25>; [INV]

  <bb 16> :
  _7 = ASN1_STRING_set (tmps, 0B, 20);
  if (_7 == 0)
    goto <bb 17>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 17> :
  // predicted unlikely by goto predictor.
  goto <bb 22>; [INV]

  <bb 18> :
  tmps->type = type;
  p = tmps->data;
  if (type == 24)
    goto <bb 19>; [INV]
  else
    goto <bb 20>; [INV]

  <bb 19> :
  _8 = ts->tm_sec;
  _9 = ts->tm_min;
  _10 = ts->tm_hour;
  _11 = ts->tm_mday;
  _12 = ts->tm_mon;
  _13 = _12 + 1;
  _14 = ts->tm_year;
  _15 = _14 + 1900;
  _16 = BIO_snprintf (p, 20, "%04d%02d%02d%02d%02d%02dZ", _15, _13, _11, _10, _9, _8);
  tmps->length = _16;
  goto <bb 21>; [INV]

  <bb 20> :
  _17 = ts->tm_sec;
  _18 = ts->tm_min;
  _19 = ts->tm_hour;
  _20 = ts->tm_mday;
  _21 = ts->tm_mon;
  _22 = _21 + 1;
  _23 = ts->tm_year;
  _24 = _23 % 100;
  _25 = BIO_snprintf (p, 20, "%02d%02d%02d%02d%02d%02dZ", _24, _22, _20, _19, _18, _17);
  tmps->length = _25;

  <bb 21> :
  D.3820 = tmps;
  goto <bb 25>; [INV]

  <bb 22> :
err:
  if (tmps != s)
    goto <bb 23>; [INV]
  else
    goto <bb 24>; [INV]

  <bb 23> :
  ASN1_STRING_free (tmps);

  <bb 24> :
  D.3820 = 0B;

  <bb 25> :
  return D.3820;

}



;; Function ASN1_TIME_adj (ASN1_TIME_adj, funcdef_no=29, decl_uid=3660, cgraph_uid=30, symbol_order=29)

Merging blocks 8 and 9
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8
;; 2 succs { 3 4 }
;; 3 succs { 8 }
;; 4 succs { 5 7 }
;; 5 succs { 6 7 }
;; 6 succs { 8 }
;; 7 succs { 8 }
;; 8 succs { 1 }
struct ASN1_TIME * ASN1_TIME_adj (struct ASN1_TIME * s, time_t t, int offset_day, long int offset_sec)
{
  struct tm data;
  struct tm * ts;
  struct ASN1_TIME * D.3831;

  <bb 2> :
  _1 = OPENSSL_gmtime (&t, &data);
  _2 = (long int) _1;
  ts = (struct tm *) _2;
  if (ts == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  D.3831 = 0B;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 8>; [INV]

  <bb 4> :
  _3 = offset_day != 0;
  _4 = offset_sec != 0;
  _5 = _3 | _4;
  if (_5 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 5> :
  _6 = OPENSSL_gmtime_adj (ts, offset_day, offset_sec);
  if (_6 == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  D.3831 = 0B;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 8>; [INV]

  <bb 7> :
  D.3831 = asn1_time_from_tm (s, ts, -1);

  <bb 8> :
  data = {CLOBBER};
  return D.3831;

}



;; Function ASN1_TIME_set (ASN1_TIME_set, funcdef_no=30, decl_uid=3670, cgraph_uid=31, symbol_order=30)

Merging blocks 2 and 3
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
struct ASN1_TIME * ASN1_TIME_set (struct ASN1_TIME * s, time_t t)
{
  struct ASN1_TIME * D.3838;

  <bb 2> :
  D.3838 = ASN1_TIME_adj (s, t, 0, 0);
  return D.3838;

}



;; Function X509_NAME_add_entry_by_NID (X509_NAME_add_entry_by_NID, funcdef_no=31, decl_uid=3679, cgraph_uid=32, symbol_order=31)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5
;; 2 succs { 3 4 }
;; 3 succs { 5 }
;; 4 succs { 5 }
;; 5 succs { 1 }
int X509_NAME_add_entry_by_NID (void * name, int nid, int type, const unsigned char * bytes, int len, int loc, int set)
{
  int ret;
  void * ne;
  int D.3842;

  <bb 2> :
  _1 = X509_NAME_ENTRY_create_by_NID (0B, nid, type, bytes, len);
  _2 = (long int) _1;
  ne = (void *) _2;
  if (ne == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  D.3842 = 0;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 5>; [INV]

  <bb 4> :
  ret = X509_NAME_add_entry (name, ne, loc, set);
  X509_NAME_ENTRY_free (ne);
  D.3842 = ret;

  <bb 5> :
  return D.3842;

}



;; Function OCSP_basic_add1_status (OCSP_basic_add1_status, funcdef_no=32, decl_uid=3696, cgraph_uid=33, symbol_order=32)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11
;; 2 succs { 3 5 }
;; 3 succs { 4 5 }
;; 4 succs { 10 }
;; 5 succs { 6 7 }
;; 6 succs { 10 }
;; 7 succs { 8 9 }
;; 8 succs { 10 }
;; 9 succs { 11 }
;; 10 succs { 11 }
;; 11 succs { 1 }
struct OCSP_SINGLERESP * OCSP_basic_add1_status (struct OCSP_BASICRESP * rsp, struct OCSP_CERTID * cid, int status, int reason, struct ASN1_TIME * revtime, struct ASN1_TIME * thisupd, struct ASN1_TIME * nextupd)
{
  struct OCSP_REVOKEDINFO * ri;
  struct OCSP_CERTSTATUS * cs;
  struct OCSP_SINGLERESP * single;
  struct OCSP_SINGLERESP * D.3852;

  <bb 2> :
  single = 0B;
  _1 = rsp->tbsResponseData.responses;
  if (_1 == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 3> :
  _2 = sk_OCSP_SINGLERESP_new_null ();
  _3 = (long int) _2;
  _4 = (struct OCSP_SINGLERESP *) _3;
  rsp->tbsResponseData.responses = _4;
  _5 = rsp->tbsResponseData.responses;
  if (_5 == 0B)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  // predicted unlikely by goto predictor.
  goto <bb 10>; [INV]

  <bb 5> :
  _6 = OCSP_CERTID_dup (cid);
  _7 = (long int) _6;
  _8 = (struct OCSP_CERTID *) _7;
  single->certId = _8;
  _9 = single->certId;
  if (_9 == 0B)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  // predicted unlikely by goto predictor.
  goto <bb 10>; [INV]

  <bb 7> :
  _10 = rsp->tbsResponseData.responses;
  _11 = sk_OCSP_SINGLERESP_push (_10, single);
  if (_11 == 0)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  // predicted unlikely by goto predictor.
  goto <bb 10>; [INV]

  <bb 9> :
  D.3852 = single;
  goto <bb 11>; [INV]

  <bb 10> :
err:
  OCSP_SINGLERESP_free (single);
  D.3852 = 0B;

  <bb 11> :
  return D.3852;

}



;; Function main (main, funcdef_no=34, decl_uid=3747, cgraph_uid=35, symbol_order=34)

Removing basic block 14
Merging blocks 13 and 15
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13
;; 2 succs { 5 3 }
;; 3 succs { 5 4 }
;; 4 succs { 5 6 }
;; 5 succs { 13 }
;; 6 succs { 8 7 }
;; 7 succs { 8 9 }
;; 8 succs { 13 }
;; 9 succs { 11 10 }
;; 10 succs { 11 12 }
;; 11 succs { 13 }
;; 12 succs { 13 }
;; 13 succs { 1 }
int main ()
{
  struct EVP_PKEY * key;
  struct X509 * tmp;
  struct X509 * signer;
  struct OCSP_BASICRESP * bs;
  int D.3858;

  <bb 2> :
  signer = 0B;
  key = 0B;
  bs = make_dummy_resp ();
  _1 = test_ptr ("./benchmarks/openssl/leak_1/openssl_leak_1.c", 329, "bs", bs);
  if (_1 == 0)
    goto <bb 5>; [INV]
  else
    goto <bb 3>; [INV]

  <bb 3> :
  _2 = get_cert_and_key (&signer, &key);
  _3 = _2 != 0;
  _4 = (int) _3;
  _5 = test_true ("./benchmarks/openssl/leak_1/openssl_leak_1.c", 330, "get_cert_and_key(&signer, &key)", _4);
  if (_5 == 0)
    goto <bb 5>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 4> :
  _6 = EVP_sha1 ();
  key.0_7 = key;
  signer.1_8 = signer;
  _9 = OCSP_basic_sign (bs, signer.1_8, key.0_7, _6, 0B, 1);
  _10 = _9 != 0;
  _11 = (int) _10;
  _12 = test_true ("./benchmarks/openssl/leak_1/openssl_leak_1.c", 331, "OCSP_basic_sign(bs, signer, key, EVP_sha1(), NULL, OCSP_NOCERTS)", _11);
  if (_12 == 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  D.3858 = 0;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 13>; [INV]

  <bb 6> :
  OCSP_BASICRESP_free (bs);
  bs = make_dummy_resp ();
  tmp = 0B;
  _13 = test_ptr ("./benchmarks/openssl/leak_1/openssl_leak_1.c", 339, "bs", bs);
  if (_13 == 0)
    goto <bb 8>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  _14 = EVP_sha1 ();
  key.2_15 = key;
  signer.3_16 = signer;
  _17 = OCSP_basic_sign (bs, signer.3_16, key.2_15, _14, 0B, 0);
  _18 = _17 != 0;
  _19 = (int) _18;
  _20 = test_true ("./benchmarks/openssl/leak_1/openssl_leak_1.c", 340, "OCSP_basic_sign(bs, signer, key, EVP_sha1(), NULL, 0)", _19);
  if (_20 == 0)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  D.3858 = 0;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 13>; [INV]

  <bb 9> :
  _21 = OCSP_resp_get0_signer (bs, &tmp, 0B);
  _22 = _21 != 0;
  _23 = (int) _22;
  _24 = test_true ("./benchmarks/openssl/leak_1/openssl_leak_1.c", 343, "OCSP_resp_get0_signer(bs, &tmp, NULL)", _23);
  if (_24 == 0)
    goto <bb 11>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 10> :
  signer.4_25 = signer;
  tmp.5_26 = tmp;
  _27 = X509_cmp (tmp.5_26, signer.4_25);
  _28 = TEST_int_eq (_27, 0);
  if (_28 == 0)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  D.3858 = 0;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 13>; [INV]

  <bb 12> :
  OCSP_BASICRESP_free (bs);
  signer.6_29 = signer;
  X509_free (signer.6_29);
  key.7_30 = key;
  EVP_PKEY_free (key.7_30);
  D.3858 = 1;

  <bb 13> :
  signer = {CLOBBER};
  tmp = {CLOBBER};
  key = {CLOBBER};
  return D.3858;

}



;; Function make_dummy_resp (make_dummy_resp, funcdef_no=33, decl_uid=3711, cgraph_uid=34, symbol_order=33)

Merging blocks 12 and 13
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12
;; 2 succs { 4 3 }
;; 3 succs { 4 5 }
;; 4 succs { 12 }
;; 5 succs { 10 6 }
;; 6 succs { 10 7 }
;; 7 succs { 10 8 }
;; 8 succs { 10 9 }
;; 9 succs { 10 11 }
;; 10 succs { 12 }
;; 11 succs { 12 }
;; 12 succs { 1 }
struct OCSP_BASICRESP * make_dummy_resp ()
{
  struct ASN1_INTEGER * serial;
  struct ASN1_BIT_STRING * key;
  void * name;
  struct ASN1_TIME * nextupd;
  struct ASN1_TIME * thisupd;
  struct OCSP_CERTID * cid;
  struct OCSP_BASICRESP * bs;
  unsigned char keybytes[128];
  const unsigned char namestr[20];
  struct OCSP_BASICRESP * D.3870;

  <bb 2> :
  namestr = "openssl.example.com";
  keybytes = "\x07";
  _1 = OCSP_BASICRESP_new ();
  _2 = (long int) _1;
  bs = (struct OCSP_BASICRESP *) _2;
  _3 = time (0B);
  _4 = (long int) _3;
  thisupd = ASN1_TIME_set (0B, _4);
  _5 = time (0B);
  _6 = _5 + 200;
  _7 = (long int) _6;
  nextupd = ASN1_TIME_set (0B, _7);
  _8 = X509_NAME_new ();
  _9 = (long int) _8;
  name = (void *) _9;
  _10 = ASN1_BIT_STRING_new ();
  _11 = (long int) _10;
  key = (struct ASN1_BIT_STRING *) _11;
  _12 = ASN1_INTEGER_new ();
  _13 = (long int) _12;
  serial = (struct ASN1_INTEGER *) _13;
  _14 = X509_NAME_add_entry_by_NID (name, 13, 4097, &namestr, -1, -1, 1);
  if (_14 == 0)
    goto <bb 4>; [INV]
  else
    goto <bb 3>; [INV]

  <bb 3> :
  _15 = ASN1_BIT_STRING_set (key, &keybytes, 1);
  if (_15 == 0)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  D.3870 = 0B;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 12>; [INV]

  <bb 5> :
  _16 = EVP_sha256 ();
  _17 = OCSP_cert_id_new (_16, name, key, serial);
  _18 = (long int) _17;
  cid = (struct OCSP_CERTID *) _18;
  _19 = test_ptr ("./benchmarks/openssl/leak_1/openssl_leak_1.c", 302, "bs", bs);
  if (_19 == 0)
    goto <bb 10>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 6> :
  _20 = test_ptr ("./benchmarks/openssl/leak_1/openssl_leak_1.c", 303, "thisupd", thisupd);
  if (_20 == 0)
    goto <bb 10>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  _21 = test_ptr ("./benchmarks/openssl/leak_1/openssl_leak_1.c", 304, "nextupd", nextupd);
  if (_21 == 0)
    goto <bb 10>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 8> :
  _22 = test_ptr ("./benchmarks/openssl/leak_1/openssl_leak_1.c", 305, "cid", cid);
  if (_22 == 0)
    goto <bb 10>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 9> :
  _23 = OCSP_basic_add1_status (bs, cid, 2, 0, 0B, thisupd, nextupd);
  _24 = _23 != 0B;
  _25 = (int) _24;
  _26 = test_true ("./benchmarks/openssl/leak_1/openssl_leak_1.c", 306, "OCSP_basic_add1_status(bs, cid, V_OCSP_CERTSTATUS_UNKNOWN, 0, NULL, thisupd, nextupd)", _25);
  if (_26 == 0)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  D.3870 = 0B;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 12>; [INV]

  <bb 11> :
  ASN1_TIME_free (thisupd);
  ASN1_TIME_free (nextupd);
  ASN1_BIT_STRING_free (key);
  ASN1_INTEGER_free (serial);
  OCSP_CERTID_free (cid);
  X509_NAME_free (name);
  D.3870 = bs;

  <bb 12> :
  namestr = {CLOBBER};
  keybytes = {CLOBBER};
  return D.3870;

}


