/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

#line 216 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h"
typedef unsigned long size_t;
#line 181 "../git.h"
struct lock_file {

};
#line 184 "../git.h"
struct split_index {

};
#line 185 "../git.h"
struct cache_time {

};
#line 186 "../git.h"
struct hashmap {

};
#line 187 "../git.h"
struct hashmap_entry {

};
#line 188 "../git.h"
struct untracked_cache {

};
#line 189 "../git.h"
struct stat_data {

};
#line 191
enum attr_match_mode {
    MATCH_SET = 0,
    MATCH_UNSET = 1,
    MATCH_VALUE = 2,
    MATCH_UNSPECIFIED = 3
} ;
#line 191 "../git.h"
struct attr_match {
   char *value ;
   enum attr_match_mode match_mode ;
};
#line 191
struct attr_check;
#line 191 "../git.h"
struct pathspec_item {
   char *match ;
   char *original ;
   unsigned int magic ;
   int len ;
   int prefix ;
   int nowildcard_len ;
   int flags ;
   int attr_match_nr ;
   struct attr_match *attr_match ;
   struct attr_check *attr_check ;
};
#line 191 "../git.h"
struct pathspec {
   int nr ;
   unsigned int has_wildcard : 1 ;
   unsigned int recursive : 1 ;
   unsigned int magic ;
   int max_depth ;
   struct pathspec_item *items ;
};
#line 218 "../git.h"
typedef unsigned long long uintmax_t;
#line 219 "../git.h"
typedef uintmax_t timestamp_t;
#line 222 "../git.h"
struct string_list_item {
   char *string ;
   void *util ;
};
#line 227 "../git.h"
struct string_list {
   struct string_list_item *items ;
   unsigned int nr ;
   unsigned int alloc ;
   unsigned int strdup_strings : 1 ;
   int (*cmp)(char const   * , char const   * ) ;
};
#line 247
struct cache_tree;
#line 247 "../git.h"
struct cache_tree_sub {
   struct cache_tree *cache_tree ;
   int count ;
   int namelen ;
   int used ;
   char name[] ;
};
#line 255 "../git.h"
struct object_id {
   unsigned char hash[20] ;
};
#line 259 "../git.h"
struct cache_tree {
   int entry_count ;
   struct object_id oid ;
   int subtree_nr ;
   int subtree_alloc ;
   struct cache_tree_sub **down ;
};
#line 267 "../git.h"
struct object {
   unsigned int parsed : 1 ;
   unsigned int type : 3 ;
   unsigned int flags : 27 ;
   struct object_id oid ;
};
#line 274 "../git.h"
struct tree {
   struct object object ;
   void *buffer ;
   unsigned long size ;
};
#line 280 "../git.h"
struct cache_entry {
   struct hashmap_entry ent ;
   struct stat_data ce_stat_data ;
   unsigned int ce_mode ;
   unsigned int ce_flags ;
   unsigned int ce_namelen ;
   unsigned int index ;
   struct object_id oid ;
   char name[] ;
};
#line 291 "../git.h"
struct index_state {
   struct cache_entry **cache ;
   unsigned int version ;
   unsigned int cache_nr ;
   unsigned int cache_alloc ;
   unsigned int cache_changed ;
   struct string_list *resolve_undo ;
   struct cache_tree *cache_tree ;
   struct split_index *split_index ;
   struct cache_time timestamp ;
   unsigned int name_hash_initialized : 1 ;
   unsigned int initialized : 1 ;
   struct hashmap name_hash ;
   struct hashmap dir_hash ;
   unsigned char sha1[20] ;
   struct untracked_cache *untracked ;
};
#line 307
struct commit;
#line 307 "../git.h"
struct commit_list {
   struct commit *item ;
   struct commit_list *next ;
};
#line 312 "../git.h"
struct commit {
   struct object object ;
   void *util ;
   unsigned int index ;
   timestamp_t date ;
   struct commit_list *parents ;
   struct tree *tree ;
};
#line 50 "git_leak_1.c"
enum __anonenum_commit_style_26 {
    COMMIT_AS_IS = 1,
    COMMIT_NORMAL = 2,
    COMMIT_PARTIAL = 3
} ;
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 161 "../git.h"
extern int ( /* missing proto */  st_mult)() ;
#line 169
extern int ( /* missing proto */  memmove)() ;
#line 166 "../git.h"
__inline static void move_array(void *dst , void const   *src , size_t n , size_t size ) 
{ 
  int tmp ;

  {
#line 168
  if (n) {
#line 169
    tmp = st_mult(size, n);
#line 169
    memmove(dst, src, tmp);
  }
#line 170
  return;
}
}
#line 174
extern int ( /* missing proto */  strdup)() ;
#line 385 "../git.h"
struct index_state the_index  ;
#line 50 "git_leak_1.c"
static enum __anonenum_commit_style_26 commit_style  ;
#line 76 "git_leak_1.c"
int core_preload_index  =    1;
#line 78 "git_leak_1.c"
static int patch_interactive  ;
#line 79 "git_leak_1.c"
static struct lock_file index_lock  ;
#line 83 "git_leak_1.c"
static int all  ;
#line 83 "git_leak_1.c"
static int also  ;
#line 83 "git_leak_1.c"
static int interactive  ;
#line 83 "git_leak_1.c"
static int only  ;
#line 94
extern int ( /* missing proto */  memset)() ;
#line 92 "git_leak_1.c"
void string_list_init(struct string_list *list , int strdup_strings ) 
{ 


  {
#line 94
  memset(list, 0, sizeof(*list));
#line 95
  list->strdup_strings = (unsigned int )strdup_strings;
#line 96
  return;
}
}
#line 102
extern int ( /* missing proto */  get_entry_index)() ;
#line 107
extern int ( /* missing proto */  alloc_nr)() ;
#line 107
extern int ( /* missing proto */  xrealloc)() ;
#line 99 "git_leak_1.c"
static int add_entry(int insert_at , struct string_list *list , char const   *string ) 
{ 
  int exact_match ;
  int index ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 101
  exact_match = 0;
#line 102
  if (insert_at != -1) {
#line 102
    tmp___0 = insert_at;
  } else {
#line 102
    tmp = get_entry_index(list, string, & exact_match);
#line 102
    tmp___0 = tmp;
  }
#line 102
  index = tmp___0;
#line 104
  if (exact_match) {
#line 105
    return (-1 - index);
  }
#line 107
  while (1) {
#line 107
    if (list->nr + 1U > list->alloc) {
#line 107
      tmp___2 = alloc_nr(list->alloc);
#line 107
      if ((unsigned int )tmp___2 < list->nr + 1U) {
#line 107
        list->alloc = list->nr + 1U;
      } else {
#line 107
        tmp___1 = alloc_nr(list->alloc);
#line 107
        list->alloc = (unsigned int )tmp___1;
      }
#line 107
      tmp___3 = st_mult(sizeof(*(list->items)), list->alloc);
#line 107
      tmp___4 = xrealloc(list->items, tmp___3);
#line 107
      list->items = (struct string_list_item *)tmp___4;
    }
#line 107
    break;
  }
#line 108
  if ((unsigned int )index < list->nr) {
#line 109
    move_array((void *)((list->items + index) + 1), (void const   *)(list->items + index),
               (size_t )(list->nr - (unsigned int )index), sizeof(*((list->items + index) + 1)) + (sizeof(char [1]) - 1UL));
  }
#line 111
  if (list->strdup_strings) {
#line 111
    tmp___5 = strdup(string);
#line 111
    (list->items + index)->string = (char *)tmp___5;
  } else {
#line 111
    (list->items + index)->string = (char *)string;
  }
#line 113
  (list->items + index)->util = (void *)0;
#line 114
  (list->nr) ++;
#line 116
  return (index);
}
}
#line 119 "git_leak_1.c"
struct string_list_item *string_list_insert(struct string_list *list , char const   *string ) 
{ 
  int index ;
  int tmp ;

  {
#line 121
  tmp = add_entry(-1, list, string);
#line 121
  index = tmp;
#line 123
  if (index < 0) {
#line 124
    index = -1 - index;
  }
#line 126
  return (list->items + index);
}
}
#line 159
extern int ( /* missing proto */  strlen)() ;
#line 184
extern int ( /* missing proto */  _)() ;
#line 182
extern int ( /* missing proto */  has_symlink_leading_path)() ;
#line 198
extern int ( /* missing proto */  init_pathspec_item)() ;
#line 134 "git_leak_1.c"
void parse_pathspec(struct pathspec *pathspec , unsigned int magic_mask , unsigned int flags ,
                    char const   *prefix , char const   **argv ) 
{ 
  struct pathspec_item *item ;
  char const   *entry ;
  char const   *tmp ;
  int i ;
  int n ;
  int prefixlen ;
  int warn_empty_string ;
  int nr_exclude ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int plen ;
  int tmp___11 ;

  {
#line 139
  if (argv) {
#line 139
    tmp = *argv;
  } else {
#line 139
    tmp = (char const   *)((void *)0);
  }
#line 139
  entry = tmp;
#line 140
  nr_exclude = 0;
#line 142
  memset(pathspec, 0, sizeof(*pathspec));
#line 144
  if (flags & (unsigned int )(1 << 2)) {
#line 145
    pathspec->magic |= (unsigned int )(1 << 1);
  }
#line 148
  if (! entry) {
#line 148
    if (! prefix) {
#line 149
      return;
    }
  }
#line 152
  if (! entry) {
#line 153
    if (flags & (unsigned int )(1 << 1)) {
#line 154
      return;
    }
#line 156
    tmp___0 = calloc((size_t )1, sizeof(*item));
#line 156
    item = (struct pathspec_item *)tmp___0;
#line 156
    pathspec->items = item;
#line 157
    tmp___1 = strdup(prefix);
#line 157
    item->match = (char *)tmp___1;
#line 158
    tmp___2 = strdup(prefix);
#line 158
    item->original = (char *)tmp___2;
#line 159
    tmp___3 = strlen(prefix);
#line 159
    item->len = tmp___3;
#line 159
    item->nowildcard_len = tmp___3;
#line 160
    item->prefix = item->len;
#line 161
    pathspec->nr = 1;
#line 162
    return;
  }
#line 165
  n = 0;
#line 166
  warn_empty_string = 1;
#line 168
  pathspec->nr = n;
#line 169
  tmp___4 = st_mult(sizeof(*(pathspec->items)), n + 1);
#line 169
  tmp___5 = malloc((size_t )tmp___4);
#line 169
  pathspec->items = (struct pathspec_item *)tmp___5;
#line 170
  item = pathspec->items;
#line 171
  if (prefix) {
#line 171
    tmp___6 = strlen(prefix);
#line 171
    prefixlen = tmp___6;
  } else {
#line 171
    prefixlen = 0;
  }
#line 173
  i = 0;
#line 173
  while (i < n) {
#line 174
    entry = *(argv + i);
#line 176
    tmp___7 = malloc((size_t )10);
#line 176
    (item + i)->match = (char *)tmp___7;
#line 177
    tmp___8 = malloc((size_t )100);
#line 177
    (item + i)->original = (char *)tmp___8;
#line 179
    if ((item + i)->magic & (unsigned int )(1 << 5)) {
#line 180
      nr_exclude ++;
    }
#line 182
    if (flags & (unsigned int )(1 << 3)) {
#line 182
      tmp___10 = has_symlink_leading_path((item + i)->match, (item + i)->len);
#line 182
      if (tmp___10) {
#line 184
        tmp___9 = _("pathspec \'%s\' is beyond a symbolic link");
#line 184
        printf((char const   * __restrict  )tmp___9, entry);
#line 184
        exit(1);
      }
    }
#line 187
    if ((item + i)->nowildcard_len < (item + i)->len) {
#line 188
      pathspec->has_wildcard = 1U;
    }
#line 189
    pathspec->magic |= (item + i)->magic;
#line 173
    i ++;
  }
#line 196
  if (nr_exclude == n) {
#line 197
    if (! (flags & 1U)) {
#line 197
      tmp___11 = 0;
    } else {
#line 197
      tmp___11 = prefixlen;
    }
#line 197
    plen = tmp___11;
#line 198
    init_pathspec_item(item + n, 0, prefix, plen, "");
#line 199
    (pathspec->nr) ++;
  }
#line 202
  return;
}
}
#line 220
extern int ( /* missing proto */  common_prefix)() ;
#line 221
extern int ( /* missing proto */  overlay_tree_on_index)() ;
#line 231
extern int ( /* missing proto */  ce_skip_worktree)() ;
#line 235
extern int ( /* missing proto */  report_path_error)() ;
#line 210 "git_leak_1.c"
static int list_paths(struct string_list *list , char const   *with_tree , char const   *prefix ,
                      struct pathspec  const  *pattern ) 
{ 
  int i ;
  int ret ;
  char *m ;
  char *max_prefix ;
  int tmp ;
  char const   *tmp___0 ;
  struct cache_entry  const  *ce ;
  struct string_list_item *item ;
  int tmp___1 ;

  {
#line 216
  if (! pattern->nr) {
#line 217
    return (0);
  }
#line 219
  if (with_tree) {
#line 220
    tmp = common_prefix(pattern);
#line 220
    max_prefix = (char *)tmp;
#line 221
    if (max_prefix) {
#line 221
      tmp___0 = (char const   *)max_prefix;
    } else {
#line 221
      tmp___0 = prefix;
    }
#line 221
    overlay_tree_on_index(& the_index, with_tree, tmp___0);
#line 223
    free((void *)max_prefix);
  }
#line 226
  i = 0;
#line 226
  while ((unsigned int )i < the_index.cache_nr) {
#line 227
    ce = (struct cache_entry  const  *)*(the_index.cache + i);
#line 230
    item = string_list_insert(list, (char const   *)(ce->name));
#line 231
    tmp___1 = ce_skip_worktree(ce);
#line 231
    if (tmp___1) {
#line 232
      item->util = (void *)item;
    }
#line 226
    i ++;
  }
#line 235
  ret = report_path_error(m, pattern, prefix);
#line 236
  free((void *)m);
#line 237
  return (ret);
}
}
#line 255
extern int ( /* missing proto */  read_index_preload)() ;
#line 261
extern int ( /* missing proto */  interactive_add)() ;
#line 264
extern int ( /* missing proto */  read_index_from)() ;
#line 264
extern int ( /* missing proto */  get_lock_file_path)() ;
#line 282
extern int ( /* missing proto */  add_files_to_cache)() ;
#line 300
extern int ( /* missing proto */  rollback_lock_file)() ;
#line 303
extern int ( /* missing proto */  get_index_file)() ;
#line 331
extern int ( /* missing proto */  discard_index)() ;
#line 241 "git_leak_1.c"
static char const   *prepare_index(int argc , char const   **argv , char const   *prefix ,
                                   struct commit  const  *current_head , int is_status ) 
{ 
  struct string_list partial ;
  struct pathspec pathspec ;
  int refresh_flags ;
  char const   *ret ;
  int tmp ;
  int tmp___0 ;
  char *old_index_env ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char const   *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char const   *tmp___9 ;
  int tmp___10 ;

  {
#line 246
  refresh_flags = 4;
#line 249
  if (is_status) {
#line 250
    refresh_flags |= 2;
  }
#line 251
  parse_pathspec(& pathspec, 0U, (unsigned int )(1 << 1), prefix, argv);
#line 255
  tmp___0 = read_index_preload(& the_index, & pathspec);
#line 255
  if (tmp___0 < 0) {
#line 256
    tmp = _("index file corrupt%s");
#line 256
    printf((char const   * __restrict  )tmp, "");
#line 256
    exit(1);
  }
#line 258
  if (interactive) {
#line 259
    old_index_env = (char *)((void *)0);
#line 261
    tmp___2 = interactive_add(argc, argv, prefix, patch_interactive);
#line 261
    if (tmp___2 != 0) {
#line 262
      tmp___1 = _("interactive add failed%s");
#line 262
      printf((char const   * __restrict  )tmp___1, "");
#line 262
      exit(1);
    }
#line 264
    tmp___3 = get_lock_file_path(& index_lock);
#line 264
    read_index_from(& the_index, tmp___3);
#line 265
    commit_style = (enum __anonenum_commit_style_26 )2;
#line 266
    tmp___4 = get_lock_file_path(& index_lock);
#line 266
    return ((char const   *)tmp___4);
  }
#line 281
  if (all) {
#line 281
    goto _L;
  } else
#line 281
  if (also) {
#line 281
    if (pathspec.nr) {
      _L: /* CIL Label */ 
#line 282
      if (also) {
#line 282
        tmp___5 = prefix;
      } else {
#line 282
        tmp___5 = (char const   *)((void *)0);
      }
#line 282
      add_files_to_cache(tmp___5, & pathspec, 0);
#line 283
      commit_style = (enum __anonenum_commit_style_26 )2;
#line 284
      tmp___6 = get_lock_file_path(& index_lock);
#line 284
      return ((char const   *)tmp___6);
    }
  }
#line 296
  if (! only) {
#line 296
    if (! pathspec.nr) {
#line 297
      if (the_index.cache_changed) {
#line 298
        tmp___7 = _("unable to write new_index file%s");
#line 298
        printf((char const   * __restrict  )tmp___7, "");
#line 298
        exit(1);
      } else {
#line 300
        rollback_lock_file(& index_lock);
      }
#line 302
      commit_style = (enum __anonenum_commit_style_26 )1;
#line 303
      tmp___8 = get_index_file();
#line 303
      return ((char const   *)tmp___8);
    }
  }
#line 325
  commit_style = (enum __anonenum_commit_style_26 )3;
#line 327
  string_list_init(& partial, 1);
#line 328
  if (! current_head) {
#line 328
    tmp___9 = (char const   *)((void *)0);
  } else {
#line 328
    tmp___9 = "HEAD";
  }
#line 328
  tmp___10 = list_paths(& partial, tmp___9, prefix, (struct pathspec  const  *)(& pathspec));
#line 328
  if (tmp___10) {
#line 329
    exit(1);
  }
#line 331
  discard_index(& the_index);
#line 332
  return (ret);
}
}
#line 335 "git_leak_1.c"
int main(int argc , char **argv ) 
{ 
  struct commit *current_head ;
  int is_status ;

  {
#line 339
  prepare_index(argc, (char const   **)argv, "prefix", (struct commit  const  *)current_head,
                is_status);
#line 340
  return (0);
}
}
