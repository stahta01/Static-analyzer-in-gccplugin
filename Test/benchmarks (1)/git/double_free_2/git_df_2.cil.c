/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

#line 216 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 144 "/usr/include/libio.h"
struct _IO_FILE;
#line 150 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 156 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 241 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 241 "../git.h"
struct strbuf {
   size_t alloc ;
   size_t len ;
   char *buf ;
};
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 170
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 531
extern int fgetc(FILE *__stream ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 187 "/usr/include/stdlib.h"
 __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1), __leaf__)) strtoul)(char const   * __restrict  str ,
                                                                                                 char ** __restrict  endptr ,
                                                                                                 int base ) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 161 "../git.h"
extern int ( /* missing proto */  memcpy)() ;
#line 161
extern int ( /* missing proto */  st_mult)() ;
#line 410 "../git.h"
void *xrealloc(void *ptr , size_t size ) 
{ 
  void *ret ;

  {
#line 414
  ret = realloc(ptr, size);
#line 415
  if (! ret) {
#line 415
    if (! size) {
#line 416
      ret = realloc(ptr, (size_t )1);
    }
  }
#line 417
  if (! ret) {
#line 418
    ret = realloc(ptr, size);
#line 419
    if (! ret) {
#line 419
      if (! size) {
#line 420
        ret = realloc(ptr, (size_t )1);
      }
    }
#line 421
    if (! ret) {
#line 422
      printf((char const   * __restrict  )"Out of memory, realloc failed%s", "");
#line 422
      exit(1);
    }
  }
#line 424
  return (ret);
}
}
#line 16 "git_df_2.c"
extern int ( /* missing proto */  memset)() ;
#line 13 "git_df_2.c"
void strbuf_release(struct strbuf *sb ) 
{ 


  {
#line 15
  free((void *)sb->buf);
#line 16
  memset(sb, 0, sizeof(*sb));
#line 17
  return;
}
}
#line 23
extern int ( /* missing proto */  alloc_nr)() ;
#line 19 "git_df_2.c"
void strbuf_grow(struct strbuf *sb , size_t extra ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;

  {
#line 21
  if ((sb->len + extra) + 1UL <= sb->len) {
#line 22
    printf((char const   * __restrict  )"you want to use way too much memory %s",
           "");
#line 22
    exit(1);
  }
#line 23
  while (1) {
#line 23
    if ((sb->len + extra) + 1UL > sb->alloc) {
#line 23
      tmp___0 = alloc_nr(sb->alloc);
#line 23
      if ((size_t )tmp___0 < (sb->len + extra) + 1UL) {
#line 23
        sb->alloc = (sb->len + extra) + 1UL;
      } else {
#line 23
        tmp = alloc_nr(sb->alloc);
#line 23
        sb->alloc = (size_t )tmp;
      }
#line 23
      tmp___1 = st_mult(sizeof(*(sb->buf)), sb->alloc);
#line 23
      tmp___2 = xrealloc((void *)sb->buf, (size_t )tmp___1);
#line 23
      sb->buf = (char *)tmp___2;
    }
#line 23
    break;
  }
#line 24
  return;
}
}
#line 29
extern int ( /* missing proto */  strbuf_setlen)() ;
#line 26 "git_df_2.c"
void strbuf_reset(struct strbuf *sb ) 
{ 


  {
#line 28
  if (sb->len) {
#line 29
    strbuf_setlen(sb, 0);
  }
#line 30
  return;
}
}
#line 32 "git_df_2.c"
void strbuf_add(struct strbuf *sb , void const   *data , size_t len ) 
{ 


  {
#line 34
  strbuf_grow(sb, len);
#line 35
  memcpy(sb->buf + sb->len, data, len);
#line 36
  strbuf_setlen(sb, sb->len + len);
#line 37
  return;
}
}
#line 38 "git_df_2.c"
int strbuf_getline(struct strbuf *sb , FILE *fp , int term ) 
{ 
  int ch ;
  int tmp ;
  size_t tmp___0 ;

  {
#line 42
  strbuf_grow(sb, (size_t )0);
#line 43
  tmp = feof(fp);
#line 43
  if (tmp) {
#line 44
    return (-1);
  }
#line 46
  strbuf_reset(sb);
#line 47
  while (1) {
#line 47
    ch = fgetc(fp);
#line 47
    if (! (ch != -1)) {
#line 47
      break;
    }
#line 48
    if (ch == term) {
#line 49
      break;
    }
#line 50
    strbuf_grow(sb, (size_t )1);
#line 51
    tmp___0 = sb->len;
#line 51
    (sb->len) ++;
#line 51
    *(sb->buf + tmp___0) = (char )ch;
  }
#line 53
  if (ch == -1) {
#line 53
    if (sb->len == 0UL) {
#line 54
      return (-1);
    }
  }
#line 56
  *(sb->buf + sb->len) = (char )'\000';
#line 57
  return (0);
}
}
#line 60
 __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1), __leaf__)) strtoul)(char const   * __restrict  str ,
                                                                                                 char ** __restrict  endptr ,
                                                                                                 int base ) ;
#line 60 "git_df_2.c"
unsigned long ( __attribute__((__nonnull__(1), __leaf__)) strtoul)(char const   * __restrict  str ,
                                                                   char ** __restrict  endptr ,
                                                                   int base ) 
{ 


  {
#line 62
  *endptr = (char *)(str + base);
#line 63
  return ((unsigned long )base);
}
}
#line 87
extern int ( /* missing proto */  strcspn)() ;
#line 128
extern int ( /* missing proto */  strbuf_addch)() ;
#line 78 "git_df_2.c"
int unquote_c_style(struct strbuf *sb , char const   *quoted , char const   **endp ) 
{ 
  size_t oldlen ;
  size_t len ;
  int ch ;
  int ac ;
  char const   *tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;

  {
#line 80
  oldlen = sb->len;
#line 83
  tmp = quoted;
#line 83
  quoted ++;
#line 83
  if ((int const   )*tmp != 34) {
#line 84
    return (-1);
  }
#line 86
  while (1) {
#line 87
    tmp___0 = strcspn(quoted, "\"\\");
#line 87
    len = (size_t )tmp___0;
#line 88
    strbuf_add(sb, (void const   *)quoted, len);
#line 89
    quoted += len;
#line 91
    tmp___1 = quoted;
#line 91
    quoted ++;
#line 91
    switch ((int const   )*tmp___1) {
    case 34: 
#line 93
    if (endp) {
#line 94
      *endp = quoted + 1;
    }
#line 95
    return (0);
    case 92: 
#line 97
    break;
    default: 
#line 99
    goto error;
    }
#line 102
    tmp___2 = quoted;
#line 102
    quoted ++;
#line 102
    ch = (int )*tmp___2;
#line 102
    switch (ch) {
    case 97: 
#line 103
    ch = '\a';
#line 103
    break;
    case 98: 
#line 104
    ch = '\b';
#line 104
    break;
    case 102: 
#line 105
    ch = '\f';
#line 105
    break;
    case 110: 
#line 106
    ch = '\n';
#line 106
    break;
    case 114: 
#line 107
    ch = '\r';
#line 107
    break;
    case 116: 
#line 108
    ch = '\t';
#line 108
    break;
    case 118: 
#line 109
    ch = '\v';
#line 109
    break;
    case 34: 
    case 92: 
#line 112
    break;
    case 51: 
    case 50: 
    case 49: 
    case 48: 
#line 116
    ac = (ch - 48) << 6;
#line 117
    tmp___3 = quoted;
#line 117
    quoted ++;
#line 117
    ch = (int )*tmp___3;
#line 117
    if (ch < 48) {
#line 118
      goto error;
    } else
#line 117
    if (55 < ch) {
#line 118
      goto error;
    }
#line 119
    ac |= (ch - 48) << 3;
#line 120
    tmp___4 = quoted;
#line 120
    quoted ++;
#line 120
    ch = (int )*tmp___4;
#line 120
    if (ch < 48) {
#line 121
      goto error;
    } else
#line 120
    if (55 < ch) {
#line 121
      goto error;
    }
#line 122
    ac |= ch - 48;
#line 123
    ch = ac;
#line 124
    break;
    default: 
#line 126
    goto error;
    }
#line 128
    strbuf_addch(sb, ch);
  }
  error: 
#line 132
  strbuf_setlen(sb, oldlen);
#line 133
  return (-1);
}
}
#line 141
extern int ( /* missing proto */  strbuf_init)() ;
#line 174
extern int ( /* missing proto */  strchr)() ;
#line 188
extern int ( /* missing proto */  get_sha1_hex)() ;
#line 200
extern int ( /* missing proto */  verify_path)() ;
#line 207
extern int ( /* missing proto */  remove_file_from_cache)() ;
#line 217
extern int ( /* missing proto */  add_cacheinfo)() ;
#line 136 "git_df_2.c"
static void read_index_info(int line_termination ) 
{ 
  struct strbuf buf ;
  struct strbuf uq ;
  char *ptr ;
  char *tab ;
  char *path_name ;
  unsigned char sha1[20] ;
  unsigned int mode ;
  unsigned long ul ;
  int stage ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 141
  strbuf_init(& buf, 0);
#line 142
  strbuf_init(& uq, 0);
#line 143
  while (1) {
#line 143
    tmp___8 = strbuf_getline(& buf, stdin, line_termination);
#line 143
    if (! (tmp___8 != -1)) {
#line 143
      break;
    }
#line 167
    tmp = __errno_location();
#line 167
    *tmp = 0;
#line 168
    ul = strtoul((char const   * __restrict  )buf.buf, (char ** __restrict  )(& ptr),
                 8);
#line 169
    if ((unsigned long )ptr == (unsigned long )buf.buf) {
#line 171
      goto bad_line;
    } else
#line 169
    if ((int )*ptr != 32) {
#line 171
      goto bad_line;
    } else {
#line 169
      tmp___0 = __errno_location();
#line 169
      if (*tmp___0) {
#line 171
        goto bad_line;
      } else
#line 169
      if ((unsigned long )((unsigned int )ul) != ul) {
#line 171
        goto bad_line;
      }
    }
#line 172
    mode = (unsigned int )ul;
#line 174
    tmp___1 = strchr(ptr, '\t');
#line 174
    tab = (char *)tmp___1;
#line 175
    if (! tab) {
#line 176
      goto bad_line;
    } else
#line 175
    if (tab - ptr < 41L) {
#line 176
      goto bad_line;
    }
#line 178
    if ((int )*(tab + -2) == 32) {
#line 178
      if (48 <= (int )*(tab + -1)) {
#line 178
        if ((int )*(tab + -1) <= 51) {
#line 179
          stage = (int )*(tab + -1) - 48;
#line 180
          ptr = tab + 1;
#line 181
          tab -= 2;
        } else {
#line 184
          stage = 0;
#line 185
          ptr = tab + 1;
        }
      } else {
#line 184
        stage = 0;
#line 185
        ptr = tab + 1;
      }
    } else {
#line 184
      stage = 0;
#line 185
      ptr = tab + 1;
    }
#line 188
    tmp___2 = get_sha1_hex(tab - 40, sha1);
#line 188
    if (tmp___2) {
#line 189
      goto bad_line;
    } else
#line 188
    if ((int )*(tab + -41) != 32) {
#line 189
      goto bad_line;
    }
#line 191
    path_name = ptr;
#line 192
    if (line_termination) {
#line 192
      if ((int )*(path_name + 0) == 34) {
#line 193
        strbuf_reset(& uq);
#line 194
        tmp___3 = unquote_c_style(& uq, (char const   *)path_name, (char const   **)((void *)0));
#line 194
        if (tmp___3) {
#line 195
          printf((char const   * __restrict  )"git-update-index: bad quoting of path name%s",
                 "");
#line 195
          exit(1);
        }
#line 197
        path_name = uq.buf;
      }
    }
#line 200
    tmp___4 = verify_path(path_name);
#line 200
    if (! tmp___4) {
#line 201
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Ignoring path %s\n",
              path_name);
#line 202
      continue;
    }
#line 205
    if (! mode) {
#line 207
      tmp___5 = remove_file_from_cache(path_name);
#line 207
      if (tmp___5) {
#line 208
        printf((char const   * __restrict  )"git-update-index: unable to remove %s",
               ptr);
#line 208
        exit(1);
      }
    } else {
#line 216
      tmp___6 = (char)0;
#line 216
      *(ptr + -1) = tmp___6;
#line 216
      *(ptr + -42) = tmp___6;
#line 217
      tmp___7 = add_cacheinfo(mode, sha1, path_name, stage);
#line 217
      if (tmp___7) {
#line 218
        printf((char const   * __restrict  )"git-update-index: unable to update %s",
               path_name);
#line 218
        exit(1);
      }
    }
#line 221
    if ((unsigned long )path_name != (unsigned long )ptr) {
#line 222
      free((void *)path_name);
    }
#line 223
    continue;
    bad_line: 
#line 226
    printf((char const   * __restrict  )"malformed index info %s", buf.buf);
#line 226
    exit(1);
  }
#line 228
  strbuf_release(& buf);
#line 229
  strbuf_release(& uq);
#line 230
  return;
}
}
#line 232 "git_df_2.c"
int main(void) 
{ 
  int line ;

  {
#line 235
  read_index_info(line);
#line 236
  return (0);
}
}
