/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

#line 216 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h"
typedef unsigned long size_t;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 208 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 410 "../git.h"
void *xrealloc(void *ptr , size_t size ) 
{ 
  void *ret ;

  {
#line 414
  ret = realloc(ptr, size);
#line 415
  if (! ret) {
#line 415
    if (! size) {
#line 416
      ret = realloc(ptr, (size_t )1);
    }
  }
#line 417
  if (! ret) {
#line 418
    ret = realloc(ptr, size);
#line 419
    if (! ret) {
#line 419
      if (! size) {
#line 420
        ret = realloc(ptr, (size_t )1);
      }
    }
#line 421
    if (! ret) {
#line 422
      printf((char const   * __restrict  )"Out of memory, realloc failed%s", "");
#line 422
      exit(1);
    }
  }
#line 424
  return (ret);
}
}
#line 91 "git_uaf_5.c"
extern int is_git_directory(char const   *path ) ;
#line 109
char const   *read_gitfile_gently(char const   *path , int *return_error_code ) ;
#line 122 "git_uaf_5.c"
int is_directory(char const   *path ) 
{ 
  struct stat st ;
  int tmp ;
  int tmp___0 ;

  {
#line 125
  tmp = stat((char const   * __restrict  )path, (struct stat * __restrict  )(& st));
#line 125
  if (tmp) {
#line 125
    tmp___0 = 0;
  } else
#line 125
  if ((st.st_mode & 61440U) == 16384U) {
#line 125
    tmp___0 = 1;
  } else {
#line 125
    tmp___0 = 0;
  }
#line 125
  return (tmp___0);
}
}
#line 151
extern int ( /* missing proto */  real_path_internal)() ;
#line 149 "git_uaf_5.c"
char const   *real_path(char const   *path ) 
{ 
  int tmp ;

  {
#line 151
  tmp = real_path_internal(path, 1);
#line 151
  return ((char const   *)tmp);
}
}
#line 187
extern int ( /* missing proto */  open)() ;
#line 193
extern int ( /* missing proto */  read_in_full)() ;
#line 194
extern int ( /* missing proto */  close)() ;
#line 200
extern int ( /* missing proto */  starts_with)() ;
#line 217
extern int ( /* missing proto */  strncpy)() ;
#line 213
extern int ( /* missing proto */  is_absolute_path)() ;
#line 213
extern int ( /* missing proto */  strrchr)() ;
#line 227
extern int ( /* missing proto */  update_linked_gitdir)() ;
#line 257
extern int ( /* missing proto */  assert)() ;
#line 164 "git_uaf_5.c"
char const   *read_gitfile_gently(char const   *path , int *return_error_code ) 
{ 
  int max_file_size ;
  int error_code ;
  char *buf ;
  char *dir ;
  char const   *slash ;
  struct stat st ;
  int fd ;
  ssize_t len ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t pathlen ;
  size_t dirlen ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 166
  max_file_size = 1 << 20;
#line 167
  error_code = 0;
#line 168
  buf = (char *)((void *)0);
#line 169
  dir = (char *)((void *)0);
#line 175
  tmp = stat((char const   * __restrict  )path, (struct stat * __restrict  )(& st));
#line 175
  if (tmp) {
#line 176
    error_code = 1;
#line 177
    goto cleanup_return;
  }
#line 179
  if (! ((st.st_mode & 61440U) == 32768U)) {
#line 180
    error_code = 2;
#line 181
    goto cleanup_return;
  }
#line 183
  if (st.st_size > (__off_t )max_file_size) {
#line 184
    error_code = 8;
#line 185
    goto cleanup_return;
  }
#line 187
  fd = open(path, 0);
#line 188
  if (fd < 0) {
#line 189
    error_code = 3;
#line 190
    goto cleanup_return;
  }
#line 192
  tmp___0 = malloc((size_t )(st.st_size + 1L));
#line 192
  buf = (char *)tmp___0;
#line 193
  tmp___1 = read_in_full(fd, buf, st.st_size);
#line 193
  len = (ssize_t )tmp___1;
#line 194
  close(fd);
#line 195
  if (len != st.st_size) {
#line 196
    error_code = 4;
#line 197
    goto cleanup_return;
  }
#line 199
  *(buf + len) = (char )'\000';
#line 200
  tmp___2 = starts_with(buf, "gitdir: ");
#line 200
  if (! tmp___2) {
#line 201
    error_code = 5;
#line 202
    goto cleanup_return;
  }
#line 204
  while (1) {
#line 204
    if (! ((int )*(buf + (len - 1L)) == 10)) {
#line 204
      if (! ((int )*(buf + (len - 1L)) == 13)) {
#line 204
        break;
      }
    }
#line 205
    len --;
  }
#line 206
  if (len < 9L) {
#line 207
    error_code = 6;
#line 208
    goto cleanup_return;
  }
#line 210
  *(buf + len) = (char )'\000';
#line 211
  dir = buf + 8;
#line 213
  tmp___4 = is_absolute_path(dir);
#line 213
  if (! tmp___4) {
#line 213
    tmp___5 = strrchr(path, '/');
#line 213
    slash = (char const   *)tmp___5;
#line 213
    if (slash) {
#line 214
      pathlen = (size_t )((slash + 1) - path);
#line 215
      dirlen = (pathlen + (size_t )len) - 8UL;
#line 216
      tmp___3 = malloc(dirlen + 1UL);
#line 216
      dir = (char *)tmp___3;
#line 217
      strncpy(dir, path, pathlen);
#line 218
      strncpy(dir + pathlen, buf + 8, len - 8L);
#line 219
      *(dir + dirlen) = (char )'\000';
#line 220
      free((void *)buf);
#line 221
      buf = dir;
    }
  }
#line 223
  tmp___6 = is_git_directory((char const   *)dir);
#line 223
  if (! tmp___6) {
#line 224
    error_code = 7;
#line 225
    goto cleanup_return;
  }
#line 227
  update_linked_gitdir(path, dir);
#line 228
  path = real_path((char const   *)dir);
  cleanup_return: 
#line 231
  free((void *)buf);
#line 233
  if (return_error_code) {
#line 234
    *return_error_code = error_code;
  }
#line 236
  if (error_code) {
#line 237
    if (return_error_code) {
#line 238
      return ((char const   *)((void *)0));
    }
#line 240
    switch (error_code) {
    case 2: 
    case 1: 
#line 243
    return ((char const   *)((void *)0));
    case 3: 
#line 245
    printf((char const   * __restrict  )"Error opening \'%s\'", path);
#line 245
    exit(1);
    case 8: 
#line 247
    printf((char const   * __restrict  )"Too large to be a .git file: \'%s\'", path);
#line 247
    exit(1);
    case 4: 
#line 249
    printf((char const   * __restrict  )"Error reading %s", path);
#line 249
    exit(1);
    case 5: 
#line 251
    printf((char const   * __restrict  )"Invalid gitfile format: %s", path);
#line 251
    exit(1);
    case 6: 
#line 253
    printf((char const   * __restrict  )"No path in gitfile: %s", path);
#line 253
    exit(1);
    case 7: 
#line 255
    printf((char const   * __restrict  )"Not a git repository: %s", dir);
#line 255
    exit(1);
    default: 
#line 257
    assert(0);
    }
  }
#line 261
  return (path);
}
}
#line 264 "git_uaf_5.c"
int main(void) 
{ 
  int error_code ;

  {
#line 267
  read_gitfile_gently("path", & error_code);
#line 268
  return (0);
}
}
