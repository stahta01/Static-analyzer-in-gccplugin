/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

#line 216 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 144 "/usr/include/libio.h"
struct _IO_FILE;
#line 150 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 156 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 241 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 179 "../git.h"
struct rev_info {

};
#line 19 "git_df_4.c"
struct refspec {
   unsigned int force : 1 ;
   unsigned int pattern : 1 ;
   unsigned int matching : 1 ;
   char *src ;
   char *dst ;
};
#line 29
enum __anonenum_status_26 {
    REF_STATUS_NONE = 0,
    REF_STATUS_OK = 1,
    REF_STATUS_REJECT_NONFASTFORWARD = 2,
    REF_STATUS_REJECT_NODELETE = 3,
    REF_STATUS_UPTODATE = 4,
    REF_STATUS_REMOTE_REJECT = 5,
    REF_STATUS_EXPECTING_REPORT = 6
} ;
#line 29 "git_df_4.c"
struct ref {
   struct ref *next ;
   unsigned char old_sha1[20] ;
   unsigned char new_sha1[20] ;
   char *symref ;
   unsigned int force : 1 ;
   unsigned int merge : 1 ;
   unsigned int nonfastforward : 1 ;
   unsigned int deletion : 1 ;
   enum __anonenum_status_26 status ;
   char *remote_status ;
   struct ref *peer_ref ;
   char name[] ;
};
#line 202
struct remote_lock;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 468 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 161 "../git.h"
extern int ( /* missing proto */  memcpy)() ;
#line 56 "git_df_4.c"
static struct ref *remote_refs  ;
#line 56 "git_df_4.c"
static struct ref **remote_tail  ;
#line 58 "git_df_4.c"
static void free_ref(struct ref *ref ) 
{ 


  {
#line 60
  if (! ref) {
#line 61
    return;
  }
#line 62
  free_ref(ref->peer_ref);
#line 63
  free((void *)ref->remote_status);
#line 64
  free((void *)ref->symref);
#line 65
  free((void *)ref);
#line 66
  return;
}
}
#line 68 "git_df_4.c"
void free_refs(struct ref *ref ) 
{ 
  struct ref *next ;

  {
#line 71
  while (ref) {
#line 72
    next = ref->next;
#line 73
    free_ref(ref);
#line 74
    ref = next;
  }
#line 76
  return;
}
}
#line 81
extern int ( /* missing proto */  strcmp)() ;
#line 78 "git_df_4.c"
struct ref *find_ref_by_name(struct ref  const  *list , char const   *name ) 
{ 
  int tmp ;

  {
#line 80
  while (list) {
#line 81
    tmp = strcmp(list->name, name);
#line 81
    if (! tmp) {
#line 82
      return ((struct ref *)list);
    }
#line 80
    list = (struct ref  const  *)list->next;
  }
#line 83
  return ((struct ref *)((void *)0));
}
}
#line 89
extern int ( /* missing proto */  strlen)() ;
#line 86 "git_df_4.c"
static struct ref *alloc_ref_with_prefix(char const   *prefix , size_t prefixlen ,
                                         char const   *name ) 
{ 
  size_t len ;
  int tmp ;
  struct ref *ref ;
  void *tmp___0 ;

  {
#line 89
  tmp = strlen(name);
#line 89
  len = (size_t )tmp;
#line 90
  tmp___0 = calloc((size_t )1, ((sizeof(struct ref ) + prefixlen) + len) + 1UL);
#line 90
  ref = (struct ref *)tmp___0;
#line 91
  memcpy(ref->name, prefix, prefixlen);
#line 92
  memcpy(ref->name + prefixlen, name, len);
#line 93
  return (ref);
}
}
#line 96 "git_df_4.c"
struct ref *alloc_ref(char const   *name ) 
{ 
  struct ref *tmp ;

  {
#line 98
  tmp = alloc_ref_with_prefix("", (size_t )0, name);
#line 98
  return (tmp);
}
}
#line 130
extern int ( /* missing proto */  hashcpy)() ;
#line 134 "git_df_4.c"
static void tail_link_ref(struct ref *ref , struct ref ***tail ) 
{ 


  {
#line 136
  *(*tail) = ref;
#line 137
  while (ref->next) {
#line 138
    ref = ref->next;
  }
#line 139
  *tail = & ref->next;
#line 140
  return;
}
}
#line 142 "git_df_4.c"
static struct ref *make_linked_ref(char const   *name , struct ref ***tail ) 
{ 
  struct ref *ret ;
  struct ref *tmp ;

  {
#line 144
  tmp = alloc_ref(name);
#line 144
  ret = tmp;
#line 145
  tail_link_ref(ret, tail);
#line 146
  return (ret);
}
}
#line 160
int match_refs(struct ref *src , struct ref *dst , struct ref ***dst_tail , int nr_refspec ,
               char const   **refspec , int flags ) ;
#line 154 "git_df_4.c"
int match_refs(struct ref *src , struct ref *dst , struct ref ***dst_tail , int nr_refspec ,
               char const   **refspec , int flags ) 
{ 
  int send_all ;
  int send_mirror ;
  struct ref *dst_peer ;
  struct refspec  const  *pat ;
  char *dst_name ;

  {
#line 158
  send_all = flags & 1;
#line 159
  send_mirror = flags & 2;
#line 163
  while (src) {
#line 165
    pat = (struct refspec  const  *)((void *)0);
#line 166
    dst_name = src->name;
#line 167
    if (src->peer_ref) {
#line 168
      goto __Cont;
    }
#line 170
    dst_peer = find_ref_by_name((struct ref  const  *)dst, (char const   *)dst_name);
#line 171
    if (dst_peer) {
#line 172
      if (dst_peer->peer_ref) {
#line 174
        goto free_name;
      }
    } else {
#line 177
      if (pat->matching) {
#line 177
        if (! send_all) {
#line 177
          if (! send_mirror) {
#line 183
            goto free_name;
          }
        }
      }
#line 186
      dst_peer = make_linked_ref((char const   *)dst_name, dst_tail);
#line 187
      hashcpy(dst_peer->new_sha1, src->new_sha1);
    }
#line 189
    dst_peer->peer_ref = src;
#line 190
    dst_peer->force = (unsigned int )pat->force;
    free_name: 
#line 192
    free((void *)dst_name);
    __Cont: /* CIL Label */ 
#line 163
    src = src->next;
  }
#line 194
  return (0);
}
}
#line 215
extern int ( /* missing proto */  get_local_heads)() ;
#line 198 "git_df_4.c"
int main(int argc , char **argv ) 
{ 
  int nr_refspec ;
  char **refspec ;
  struct remote_lock *ref_lock ;
  struct remote_lock *info_ref_lock ;
  int delete_branch ;
  int force_delete ;
  int rc ;
  struct ref *local_refs ;
  char *rewritten_url ;
  int tmp ;
  int tmp___0 ;

  {
#line 200
  nr_refspec = 0;
#line 201
  refspec = (char **)((void *)0);
#line 202
  ref_lock = (struct remote_lock *)((void *)0);
#line 203
  info_ref_lock = (struct remote_lock *)((void *)0);
#line 205
  delete_branch = 0;
#line 206
  force_delete = 0;
#line 208
  rc = 0;
#line 212
  rewritten_url = (char *)((void *)0);
#line 214
  refspec = argv;
#line 215
  tmp = get_local_heads();
#line 215
  local_refs = (struct ref *)tmp;
#line 216
  remote_tail = & remote_refs;
#line 218
  tmp___0 = match_refs(local_refs, remote_refs, & remote_tail, nr_refspec, (char const   **)refspec,
                       1);
#line 218
  if (tmp___0) {
#line 220
    rc = -1;
#line 221
    goto cleanup;
  }
#line 224
  if (! remote_refs) {
#line 225
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"No refs in common and none specified; doing nothing.\n");
#line 226
    rc = 0;
#line 227
    goto cleanup;
  }
  cleanup: 
#line 231
  free_refs(local_refs);
#line 232
  free_refs(remote_refs);
#line 233
  return (0);
}
}
