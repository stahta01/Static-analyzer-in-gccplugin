/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

#line 216 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 144 "/usr/include/libio.h"
struct _IO_FILE;
#line 150 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 156 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 241 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 184 "../git.h"
struct split_index {

};
#line 185 "../git.h"
struct cache_time {

};
#line 186 "../git.h"
struct hashmap {

};
#line 187 "../git.h"
struct hashmap_entry {

};
#line 188 "../git.h"
struct untracked_cache {

};
#line 189 "../git.h"
struct stat_data {

};
#line 222 "../git.h"
struct string_list_item {
   char *string ;
   void *util ;
};
#line 227 "../git.h"
struct string_list {
   struct string_list_item *items ;
   unsigned int nr ;
   unsigned int alloc ;
   unsigned int strdup_strings : 1 ;
   int (*cmp)(char const   * , char const   * ) ;
};
#line 241 "../git.h"
struct strbuf {
   size_t alloc ;
   size_t len ;
   char *buf ;
};
#line 247
struct cache_tree;
#line 247 "../git.h"
struct cache_tree_sub {
   struct cache_tree *cache_tree ;
   int count ;
   int namelen ;
   int used ;
   char name[] ;
};
#line 255 "../git.h"
struct object_id {
   unsigned char hash[20] ;
};
#line 259 "../git.h"
struct cache_tree {
   int entry_count ;
   struct object_id oid ;
   int subtree_nr ;
   int subtree_alloc ;
   struct cache_tree_sub **down ;
};
#line 280 "../git.h"
struct cache_entry {
   struct hashmap_entry ent ;
   struct stat_data ce_stat_data ;
   unsigned int ce_mode ;
   unsigned int ce_flags ;
   unsigned int ce_namelen ;
   unsigned int index ;
   struct object_id oid ;
   char name[] ;
};
#line 291 "../git.h"
struct index_state {
   struct cache_entry **cache ;
   unsigned int version ;
   unsigned int cache_nr ;
   unsigned int cache_alloc ;
   unsigned int cache_changed ;
   struct string_list *resolve_undo ;
   struct cache_tree *cache_tree ;
   struct split_index *split_index ;
   struct cache_time timestamp ;
   unsigned int name_hash_initialized : 1 ;
   unsigned int initialized : 1 ;
   struct hashmap name_hash ;
   struct hashmap dir_hash ;
   unsigned char sha1[20] ;
   struct untracked_cache *untracked ;
};
#line 12 "git_uaf_1.c"
struct checkout {
   struct index_state *istate ;
   char const   *base_dir ;
   int base_dir_len ;
   unsigned int force : 1 ;
   unsigned int quiet : 1 ;
   unsigned int not_new : 1 ;
   unsigned int refresh_cache : 1 ;
};
#line 110
struct stat;
#line 148
struct hashmap_iter;
#line 149
struct pair_entry;
#line 200
struct working_tree_entry;
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 480 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 662
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) mkdtemp)(char *__template ) ;
#line 161 "../git.h"
extern int ( /* missing proto */  st_mult)() ;
#line 386 "../git.h"
char strbuf_slopbuf[1]  ;
#line 410 "../git.h"
void *xrealloc(void *ptr , size_t size ) 
{ 
  void *ret ;

  {
#line 414
  ret = realloc(ptr, size);
#line 415
  if (! ret) {
#line 415
    if (! size) {
#line 416
      ret = realloc(ptr, (size_t )1);
    }
  }
#line 417
  if (! ret) {
#line 418
    ret = realloc(ptr, size);
#line 419
    if (! ret) {
#line 419
      if (! size) {
#line 420
        ret = realloc(ptr, (size_t )1);
      }
    }
#line 421
    if (! ret) {
#line 422
      printf((char const   * __restrict  )"Out of memory, realloc failed%s", "");
#line 422
      exit(1);
    }
  }
#line 424
  return (ret);
}
}
#line 31 "git_uaf_1.c"
void strbuf_grow(struct strbuf *sb , size_t extra ) ;
#line 26 "git_uaf_1.c"
void strbuf_init(struct strbuf *sb , size_t hint ) 
{ 
  size_t tmp ;

  {
#line 28
  tmp = (size_t )0;
#line 28
  sb->len = tmp;
#line 28
  sb->alloc = tmp;
#line 29
  sb->buf = strbuf_slopbuf;
#line 30
  if (hint) {
#line 31
    strbuf_grow(sb, hint);
  }
#line 32
  return;
}
}
#line 34 "git_uaf_1.c"
void strbuf_release(struct strbuf *sb ) 
{ 


  {
#line 36
  if (sb->alloc) {
#line 37
    free((void *)sb->buf);
#line 38
    strbuf_init(sb, (size_t )0);
  }
#line 40
  return;
}
}
#line 42 "git_uaf_1.c"
__inline static void strbuf_setlen(struct strbuf *sb , size_t len ) 
{ 
  size_t tmp ;

  {
#line 44
  if (sb->alloc) {
#line 44
    tmp = sb->alloc - 1UL;
  } else {
#line 44
    tmp = (size_t )0;
  }
#line 44
  if (len > tmp) {
#line 45
    printf((char const   * __restrict  )"BUG: strbuf_setlen() beyond buffer%s", "");
#line 45
    exit(1);
  }
#line 46
  sb->len = len;
#line 47
  *(sb->buf + len) = (char )'\000';
#line 48
  return;
}
}
#line 50 "git_uaf_1.c"
char *strbuf_detach(struct strbuf *sb , size_t *sz ) 
{ 
  char *res ;

  {
#line 53
  strbuf_grow(sb, 0);
#line 54
  res = sb->buf;
#line 55
  if (sz) {
#line 56
    *sz = sb->len;
  }
#line 57
  strbuf_init(sb, (size_t )0);
#line 58
  return (res);
}
}
#line 61 "git_uaf_1.c"
void strbuf_attach(struct strbuf *sb , void *buf , size_t len , size_t alloc ) 
{ 


  {
#line 63
  strbuf_release(sb);
#line 64
  sb->buf = (char *)buf;
#line 65
  sb->len = len;
#line 66
  sb->alloc = alloc;
#line 67
  strbuf_grow(sb, 0);
#line 68
  *(sb->buf + sb->len) = (char )'\000';
#line 69
  return;
}
}
#line 74
extern int ( /* missing proto */  unsigned_add_overflows)() ;
#line 79
extern int ( /* missing proto */  alloc_nr)() ;
#line 71 "git_uaf_1.c"
void strbuf_grow(struct strbuf *sb , size_t extra ) 
{ 
  int new_buf ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;

  {
#line 73
  new_buf = ! sb->alloc;
#line 74
  tmp = unsigned_add_overflows(extra, 1);
#line 74
  if (tmp) {
#line 76
    printf((char const   * __restrict  )"you want to use way too much memory%s", "");
#line 76
    exit(1);
  } else {
#line 74
    tmp___0 = unsigned_add_overflows(sb->len, extra + 1UL);
#line 74
    if (tmp___0) {
#line 76
      printf((char const   * __restrict  )"you want to use way too much memory%s",
             "");
#line 76
      exit(1);
    }
  }
#line 77
  if (new_buf) {
#line 78
    sb->buf = (char *)((void *)0);
  }
#line 79
  while (1) {
#line 79
    if ((sb->len + extra) + 1UL > sb->alloc) {
#line 79
      tmp___2 = alloc_nr(sb->alloc);
#line 79
      if ((size_t )tmp___2 < (sb->len + extra) + 1UL) {
#line 79
        sb->alloc = (sb->len + extra) + 1UL;
      } else {
#line 79
        tmp___1 = alloc_nr(sb->alloc);
#line 79
        sb->alloc = (size_t )tmp___1;
      }
#line 79
      tmp___3 = st_mult(sizeof(*(sb->buf)), sb->alloc);
#line 79
      tmp___4 = xrealloc((void *)sb->buf, (size_t )tmp___3);
#line 79
      sb->buf = (char *)tmp___4;
    }
#line 79
    break;
  }
#line 80
  if (new_buf) {
#line 81
    *(sb->buf + 0) = (char )'\000';
  }
#line 82
  return;
}
}
#line 88
extern int ( /* missing proto */  strbuf_avail)() ;
#line 84 "git_uaf_1.c"
void strbuf_vaddf(struct strbuf *sb , char const   *fmt , char const   *ap ) 
{ 
  int len ;
  char const   *cp ;
  int tmp ;

  {
#line 87
  cp = ap;
#line 88
  tmp = strbuf_avail(sb);
#line 88
  if (! tmp) {
#line 89
    strbuf_grow(sb, (size_t )64);
  }
#line 90
  strbuf_setlen(sb, sb->len + (size_t )len);
#line 91
  return;
}
}
#line 93 "git_uaf_1.c"
void strbuf_addf(struct strbuf *sb , char const   *fmt , char const   *ap ) 
{ 


  {
#line 95
  strbuf_vaddf(sb, fmt, ap);
#line 96
  return;
}
}
#line 102
extern int ( /* missing proto */  strbuf_addch)() ;
#line 103
extern int ( /* missing proto */  strbuf_addstr)() ;
#line 98 "git_uaf_1.c"
static void add_path(struct strbuf *buf , size_t base_len , char const   *path ) 
{ 


  {
#line 100
  strbuf_setlen(buf, base_len);
#line 101
  if (buf->len) {
#line 101
    if ((int )*(buf->buf + (buf->len - 1UL)) != 47) {
#line 102
      strbuf_addch(buf, '/');
    }
  }
#line 103
  strbuf_addstr(buf, path);
#line 104
  return;
}
}
#line 109
int checkout_entry(struct cache_entry *ce , struct checkout  const  *state , char *topath ) ;
#line 109 "git_uaf_1.c"
static struct strbuf path  =    {(size_t )0, (size_t )0, strbuf_slopbuf};
#line 113
extern int ( /* missing proto */  write_entry)() ;
#line 115
extern int ( /* missing proto */  strbuf_reset)() ;
#line 116
extern int ( /* missing proto */  strbuf_add)() ;
#line 118
extern int ( /* missing proto */  create_directories)() ;
#line 106 "git_uaf_1.c"
int checkout_entry(struct cache_entry *ce , struct checkout  const  *state , char *topath ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 112
  if (topath) {
#line 113
    tmp = write_entry(ce, topath, state, 1);
#line 113
    return (tmp);
  }
#line 115
  strbuf_reset(& path);
#line 116
  strbuf_add(& path, state->base_dir, state->base_dir_len);
#line 118
  create_directories(path.buf, path.len, state);
#line 119
  tmp___0 = write_entry(ce, path.buf, state, 0);
#line 119
  return (tmp___0);
}
}
#line 127
extern int ( /* missing proto */  make_cache_entry)() ;
#line 121 "git_uaf_1.c"
static int checkout_path(unsigned int mode , struct object_id *oid , char const   *path___0 ,
                         struct checkout  const  *state ) 
{ 
  struct cache_entry *ce ;
  int ret ;
  int tmp ;

  {
#line 127
  tmp = make_cache_entry(mode, oid->hash, path___0, 0, 0);
#line 127
  ce = (struct cache_entry *)tmp;
#line 128
  ret = checkout_entry(ce, state, (char *)((void *)0));
#line 130
  free((void *)ce);
#line 131
  return (ret);
}
}
#line 156
extern int ( /* missing proto */  get_git_work_tree)() ;
#line 160
extern int ( /* missing proto */  xsnprintf)() ;
#line 162
extern int ( /* missing proto */  error)() ;
#line 166
extern int ( /* missing proto */  is_dir_sep)() ;
#line 168
extern int ( /* missing proto */  mkdir)() ;
#line 171
extern int ( /* missing proto */  memset)() ;
#line 219
extern int ( /* missing proto */  error_errno)() ;
#line 218
extern int ( /* missing proto */  symlink)() ;
#line 206
extern int ( /* missing proto */  is_null_oid)() ;
#line 202
extern int ( /* missing proto */  use_wt_file)() ;
#line 199
extern int ( /* missing proto */  S_ISLNK)() ;
#line 188
extern int ( /* missing proto */  strbuf_getline_nul)() ;
#line 135 "git_uaf_1.c"
static int run_dir_diff(char const   *extcmd , int symlinks , char const   *prefix ,
                        int argc , char const   **argv ) 
{ 
  char tmpdir[4096] ;
  struct strbuf info ;
  struct strbuf lpath ;
  struct strbuf rpath ;
  struct strbuf buf ;
  struct strbuf ldir ;
  struct strbuf rdir ;
  struct strbuf wtdir ;
  size_t ldir_len ;
  size_t rdir_len ;
  size_t wtdir_len ;
  char const   *workdir ;
  char const   *tmp ;
  int ret ;
  int i ;
  FILE *fp ;
  struct index_state wtindex ;
  struct checkout lstate ;
  struct checkout rstate ;
  char const   *helper_argv[4] ;
  int indices_loaded ;
  int tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int lmode ;
  int rmode ;
  struct object_id loid ;
  struct object_id roid ;
  char status ;
  char const   *src_path ;
  char const   *dst_path ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  struct cache_entry *ce2 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;

  {
#line 139
  info.alloc = (size_t )0;
#line 139
  info.len = (size_t )0;
#line 139
  info.buf = strbuf_slopbuf;
#line 139
  lpath.alloc = (size_t )0;
#line 139
  lpath.len = (size_t )0;
#line 139
  lpath.buf = strbuf_slopbuf;
#line 140
  rpath.alloc = (size_t )0;
#line 140
  rpath.len = (size_t )0;
#line 140
  rpath.buf = strbuf_slopbuf;
#line 140
  buf.alloc = (size_t )0;
#line 140
  buf.len = (size_t )0;
#line 140
  buf.buf = strbuf_slopbuf;
#line 141
  ldir.alloc = (size_t )0;
#line 141
  ldir.len = (size_t )0;
#line 141
  ldir.buf = strbuf_slopbuf;
#line 141
  rdir.alloc = (size_t )0;
#line 141
  rdir.len = (size_t )0;
#line 141
  rdir.buf = strbuf_slopbuf;
#line 142
  wtdir.alloc = (size_t )0;
#line 142
  wtdir.len = (size_t )0;
#line 142
  wtdir.buf = strbuf_slopbuf;
#line 145
  ret = 0;
#line 152
  helper_argv[0] = "difftool--helper";
#line 152
  helper_argv[1] = (char const   *)((void *)0);
#line 152
  helper_argv[2] = (char const   *)((void *)0);
#line 152
  helper_argv[3] = (char const   *)((void *)0);
#line 154
  indices_loaded = 0;
#line 156
  tmp___0 = get_git_work_tree();
#line 156
  workdir = (char const   *)tmp___0;
#line 159
  tmp___1 = getenv("TMPDIR");
#line 159
  tmp = (char const   *)tmp___1;
#line 160
  if (tmp) {
#line 160
    tmp___2 = tmp;
  } else {
#line 160
    tmp___2 = "/tmp";
  }
#line 160
  xsnprintf(tmpdir, sizeof(tmpdir), "%s/git-difftool.XXXXXX", tmp___2);
#line 161
  tmp___4 = mkdtemp(tmpdir);
#line 161
  if (! tmp___4) {
#line 162
    tmp___3 = error("could not create \'%s\'", tmpdir);
#line 162
    return (tmp___3);
  }
#line 163
  strbuf_addf(& ldir, "%s/left/", (char const   *)(tmpdir));
#line 164
  strbuf_addf(& rdir, "%s/right/", (char const   *)(tmpdir));
#line 165
  strbuf_addstr(& wtdir, workdir);
#line 166
  if (! wtdir.len) {
#line 167
    strbuf_addch(& wtdir, '/');
  } else {
#line 166
    tmp___5 = is_dir_sep((int )*(wtdir.buf + (wtdir.len - 1UL)));
#line 166
    if (! tmp___5) {
#line 167
      strbuf_addch(& wtdir, '/');
    }
  }
#line 168
  mkdir(ldir.buf, 448);
#line 169
  mkdir(rdir.buf, 448);
#line 171
  memset(& wtindex, 0, sizeof(wtindex));
#line 173
  memset(& lstate, 0, sizeof(lstate));
#line 174
  lstate.base_dir = (char const   *)ldir.buf;
#line 175
  lstate.base_dir_len = (int )ldir.len;
#line 176
  lstate.force = 1U;
#line 177
  memset(& rstate, 0, sizeof(rstate));
#line 178
  rstate.base_dir = (char const   *)rdir.buf;
#line 179
  rstate.base_dir_len = (int )rdir.len;
#line 180
  rstate.force = 1U;
#line 182
  ldir_len = ldir.len;
#line 183
  rdir_len = rdir.len;
#line 184
  wtdir_len = wtdir.len;
#line 187
  i = 0;
#line 188
  while (1) {
#line 188
    tmp___15 = strbuf_getline_nul(& info, fp);
#line 188
    if (tmp___15) {
#line 188
      break;
    }
#line 194
    if (lmode) {
#line 194
      if ((int )status != 67) {
#line 195
        tmp___7 = checkout_path((unsigned int )lmode, & loid, src_path, (struct checkout  const  *)(& lstate));
#line 195
        if (tmp___7) {
#line 196
          tmp___6 = error("could not write \'%s\'", src_path);
#line 196
          return (tmp___6);
        }
      }
    }
#line 199
    if (rmode) {
#line 199
      tmp___14 = S_ISLNK(rmode);
#line 199
      if (! tmp___14) {
#line 202
        tmp___13 = use_wt_file(workdir, dst_path, & roid);
#line 202
        if (tmp___13) {
#line 206
          tmp___12 = is_null_oid(& roid);
#line 206
          if (tmp___12) {
#line 225
            goto finish;
          } else {
#line 212
            tmp___10 = make_cache_entry(rmode, roid.hash, dst_path, 0, 0);
#line 212
            ce2 = (struct cache_entry *)tmp___10;
#line 216
            add_path(& rdir, rdir_len, dst_path);
#line 217
            if (symlinks) {
#line 218
              tmp___11 = symlink(wtdir.buf, rdir.buf);
#line 218
              if (tmp___11) {
#line 219
                ret = error_errno("could not symlink \'%s\' to \'%s\'", wtdir.buf,
                                  rdir.buf);
#line 220
                goto finish;
              }
            }
          }
        } else {
#line 203
          tmp___9 = checkout_path((unsigned int )rmode, & roid, dst_path, (struct checkout  const  *)(& rstate));
#line 203
          if (tmp___9) {
#line 204
            tmp___8 = error("could not write \'%s\'", dst_path);
#line 204
            return (tmp___8);
          }
        }
      }
    }
  }
  finish: 
#line 232
  strbuf_release(& ldir);
#line 233
  strbuf_release(& rdir);
#line 234
  strbuf_release(& wtdir);
#line 235
  strbuf_release(& buf);
#line 237
  return (ret);
}
}
#line 240 "git_uaf_1.c"
int main(int argc , char **argv ) 
{ 
  int symlinks ;

  {
#line 243
  run_dir_diff("extcmd", symlinks, "prefix", argc, (char const   **)argv);
#line 244
  return (0);
}
}
