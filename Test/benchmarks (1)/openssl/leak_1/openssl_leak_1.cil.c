/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

#line 216 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h"
typedef unsigned long size_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 76 "../stdio.h"
typedef unsigned long long uint64_t;
#line 284 "../openssl.h"
struct ASN1_VALUE_st;
#line 284 "../openssl.h"
typedef struct ASN1_VALUE_st ASN1_VALUE;
#line 286
struct asn1_string_st;
#line 286 "../openssl.h"
typedef struct asn1_string_st ASN1_INTEGER;
#line 287 "../openssl.h"
typedef struct asn1_string_st ASN1_ENUMERATED;
#line 288 "../openssl.h"
typedef struct asn1_string_st ASN1_BIT_STRING;
#line 289 "../openssl.h"
typedef struct asn1_string_st ASN1_OCTET_STRING;
#line 290 "../openssl.h"
typedef struct asn1_string_st ASN1_PRINTABLESTRING;
#line 291 "../openssl.h"
typedef struct asn1_string_st ASN1_T61STRING;
#line 292 "../openssl.h"
typedef struct asn1_string_st ASN1_IA5STRING;
#line 293 "../openssl.h"
typedef struct asn1_string_st ASN1_GENERALSTRING;
#line 294 "../openssl.h"
typedef struct asn1_string_st ASN1_UNIVERSALSTRING;
#line 295 "../openssl.h"
typedef struct asn1_string_st ASN1_BMPSTRING;
#line 296 "../openssl.h"
typedef struct asn1_string_st ASN1_UTCTIME;
#line 297 "../openssl.h"
typedef struct asn1_string_st ASN1_TIME;
#line 298 "../openssl.h"
typedef struct asn1_string_st ASN1_GENERALIZEDTIME;
#line 299 "../openssl.h"
typedef struct asn1_string_st ASN1_VISIBLESTRING;
#line 300 "../openssl.h"
typedef struct asn1_string_st ASN1_UTF8STRING;
#line 301 "../openssl.h"
typedef struct asn1_string_st ASN1_STRING;
#line 302 "../openssl.h"
typedef int ASN1_BOOLEAN;
#line 305
struct asn1_object_st;
#line 305 "../openssl.h"
typedef struct asn1_object_st ASN1_OBJECT;
#line 325
struct evp_pkey_st;
#line 325 "../openssl.h"
typedef struct evp_pkey_st EVP_PKEY;
#line 353
struct x509_st;
#line 353 "../openssl.h"
typedef struct x509_st X509;
#line 354
struct X509_algor_st;
#line 354 "../openssl.h"
typedef struct X509_algor_st X509_ALGOR;
#line 400
struct ocsp_responder_id_st;
#line 431 "../openssl.h"
struct asn1_string_st {
   int length ;
   int type ;
   unsigned char *data ;
   long flags ;
};
#line 472 "../openssl.h"
struct asn1_object_st {
   char const   *sn ;
   char const   *ln ;
   int nid ;
   int length ;
   unsigned char const   *data ;
   int flags ;
};
#line 480 "../openssl.h"
union __anonunion_value_25 {
   char *ptr ;
   ASN1_BOOLEAN boolean ;
   ASN1_STRING *asn1_string ;
   ASN1_OBJECT *object ;
   ASN1_INTEGER *integer ;
   ASN1_ENUMERATED *enumerated ;
   ASN1_BIT_STRING *bit_string ;
   ASN1_OCTET_STRING *octet_string ;
   ASN1_PRINTABLESTRING *printablestring ;
   ASN1_T61STRING *t61string ;
   ASN1_IA5STRING *ia5string ;
   ASN1_GENERALSTRING *generalstring ;
   ASN1_BMPSTRING *bmpstring ;
   ASN1_UNIVERSALSTRING *universalstring ;
   ASN1_UTCTIME *utctime ;
   ASN1_GENERALIZEDTIME *generalizedtime ;
   ASN1_VISIBLESTRING *visiblestring ;
   ASN1_UTF8STRING *utf8string ;
   ASN1_STRING *set ;
   ASN1_STRING *sequence ;
   ASN1_VALUE *asn1_value ;
};
#line 480 "../openssl.h"
struct asn1_type_st {
   int type ;
   union __anonunion_value_25 value ;
};
#line 480 "../openssl.h"
typedef struct asn1_type_st ASN1_TYPE;
#line 514 "../openssl.h"
struct X509_algor_st {
   ASN1_OBJECT *algorithm ;
   ASN1_TYPE *parameter ;
};
#line 12 "openssl_leak_1.c"
struct tm {
   unsigned int tm_sec ;
   unsigned int tm_min ;
   unsigned int tm_hour ;
   unsigned int tm_mday ;
   unsigned int tm_mon ;
   unsigned int tm_year ;
};
#line 60
struct ocsp_cert_id_st;
#line 60 "openssl_leak_1.c"
typedef struct ocsp_cert_id_st OCSP_CERTID;
#line 66
struct ocsp_revoked_info_st;
#line 66 "openssl_leak_1.c"
typedef struct ocsp_revoked_info_st OCSP_REVOKEDINFO;
#line 67
struct ocsp_cert_status_st;
#line 67 "openssl_leak_1.c"
typedef struct ocsp_cert_status_st OCSP_CERTSTATUS;
#line 68
struct ocsp_single_response_st;
#line 68 "openssl_leak_1.c"
typedef struct ocsp_single_response_st OCSP_SINGLERESP;
#line 69
struct ocsp_response_data_st;
#line 70
struct ocsp_basic_response_st;
#line 73 "openssl_leak_1.c"
typedef struct ocsp_response_data_st OCSP_RESPDATA___0;
#line 74 "openssl_leak_1.c"
typedef struct ocsp_basic_response_st OCSP_BASICRESP___0;
#line 75 "openssl_leak_1.c"
typedef struct ocsp_responder_id_st OCSP_RESPID___0;
#line 77 "openssl_leak_1.c"
union __anonunion_value_27 {
   void *byName ;
   ASN1_OCTET_STRING *byKey ;
};
#line 77 "openssl_leak_1.c"
struct ocsp_responder_id_st {
   int type ;
   union __anonunion_value_27 value ;
};
#line 85 "openssl_leak_1.c"
struct ocsp_response_data_st {
   ASN1_INTEGER *version ;
   OCSP_RESPID___0 responderId ;
   ASN1_GENERALIZEDTIME *producedAt ;
   OCSP_SINGLERESP *responses ;
};
#line 92 "openssl_leak_1.c"
struct ocsp_basic_response_st {
   OCSP_RESPDATA___0 tbsResponseData ;
   X509_ALGOR signatureAlgorithm ;
   ASN1_BIT_STRING *signature ;
};
#line 98 "openssl_leak_1.c"
struct ocsp_single_response_st {
   OCSP_CERTID *certId ;
   OCSP_CERTSTATUS *certStatus ;
   ASN1_GENERALIZEDTIME *thisUpdate ;
   ASN1_GENERALIZEDTIME *nextUpdate ;
};
#line 111
extern int ( /* missing proto */  test_fail_message)() ;
#line 107 "openssl_leak_1.c"
int test_ptr(char const   *file , int line , char const   *s , void const   *p ) 
{ 


  {
#line 109
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 110
    return (1);
  }
#line 111
  test_fail_message((void *)0, file, line, "ptr", s, "NULL", "!=", "%p", p);
#line 112
  return (0);
}
}
#line 114 "openssl_leak_1.c"
int test_true(char const   *file , int line , char const   *s , int b ) 
{ 


  {
#line 116
  if (b) {
#line 117
    return (1);
  }
#line 118
  test_fail_message((void *)0, file, line, "bool", s, "true", "==", "false");
#line 119
  return (0);
}
}
#line 133
extern int ( /* missing proto */  strlen)() ;
#line 137
extern int ( /* missing proto */  OPENSSL_realloc)() ;
#line 145
extern int ( /* missing proto */  memcpy)() ;
#line 124 "openssl_leak_1.c"
int ASN1_STRING_set(ASN1_STRING *str , void const   *_data , int len ) 
{ 
  unsigned char *c ;
  char const   *data ;
  int tmp ;

  {
#line 127
  data = (char const   *)_data;
#line 129
  if (len < 0) {
#line 130
    if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 131
      return (0);
    } else {
#line 133
      len = strlen(data);
    }
  }
#line 135
  if (str->length <= len) {
#line 135
    goto _L;
  } else
#line 135
  if ((unsigned long )str->data == (unsigned long )((void *)0)) {
    _L: /* CIL Label */ 
#line 136
    c = str->data;
#line 137
    tmp = OPENSSL_realloc(c, len + 1);
#line 137
    str->data = (unsigned char *)tmp;
#line 138
    if ((unsigned long )str->data == (unsigned long )((void *)0)) {
#line 139
      str->data = c;
#line 140
      return (0);
    }
  }
#line 143
  str->length = len;
#line 144
  if ((unsigned long )data != (unsigned long )((void *)0)) {
#line 145
    memcpy(str->data, data, len);
#line 147
    *(str->data + len) = (unsigned char )'\000';
  }
#line 149
  return (1);
}
}
#line 158
extern int ( /* missing proto */  asn1_put_uint64)() ;
#line 152 "openssl_leak_1.c"
static int asn1_string_set_uint64(ASN1_STRING *a , uint64_t r , int itype ) 
{ 
  unsigned char tbuf[sizeof(r)] ;
  size_t off ;
  int tmp ;
  int tmp___0 ;

  {
#line 157
  a->type = itype;
#line 158
  tmp = asn1_put_uint64(tbuf, r);
#line 158
  off = (size_t )tmp;
#line 159
  tmp___0 = ASN1_STRING_set(a, (void const   *)(tbuf + off), (int )(sizeof(tbuf) - off));
#line 159
  return (tmp___0);
}
}
#line 162 "openssl_leak_1.c"
int ASN1_INTEGER_set_uint64(ASN1_INTEGER *a , uint64_t r ) 
{ 
  int tmp ;

  {
#line 164
  tmp = asn1_string_set_uint64(a, r, 2);
#line 164
  return (tmp);
}
}
#line 167 "openssl_leak_1.c"
int ASN1_BIT_STRING_set(ASN1_BIT_STRING *x , unsigned char *d , int len ) 
{ 
  int tmp ;

  {
#line 169
  tmp = ASN1_STRING_set(x, (void const   *)d, len);
#line 169
  return (tmp);
}
}
#line 179
extern int ( /* missing proto */  is_utc)() ;
#line 191
extern int ( /* missing proto */  ASN1_STRING_new)() ;
#line 204
extern int ( /* missing proto */  BIO_snprintf)() ;
#line 217
extern int ( /* missing proto */  ASN1_STRING_free)() ;
#line 172 "openssl_leak_1.c"
ASN1_TIME *asn1_time_from_tm(ASN1_TIME *s , struct tm *ts , int type ) 
{ 
  char *p ;
  ASN1_TIME *tmps ;
  size_t len ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 175
  tmps = (ASN1_TIME *)((void *)0);
#line 176
  len = (size_t )20;
#line 178
  if (type == -1) {
#line 179
    tmp = is_utc(ts->tm_year);
#line 179
    if (tmp) {
#line 180
      type = 23;
    } else {
#line 182
      type = 24;
    }
  } else
#line 183
  if (type == 23) {
#line 184
    tmp___0 = is_utc(ts->tm_year);
#line 184
    if (! tmp___0) {
#line 185
      goto err;
    }
  } else
#line 186
  if (type != 24) {
#line 187
    goto err;
  }
#line 190
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 191
    tmp___1 = ASN1_STRING_new();
#line 191
    tmps = (ASN1_TIME *)tmp___1;
  } else {
#line 193
    tmps = s;
  }
#line 194
  if ((unsigned long )tmps == (unsigned long )((void *)0)) {
#line 195
    return ((ASN1_TIME *)((void *)0));
  }
#line 197
  tmp___2 = ASN1_STRING_set(tmps, (void const   *)((void *)0), (int )len);
#line 197
  if (! tmp___2) {
#line 198
    goto err;
  }
#line 200
  tmps->type = type;
#line 201
  p = (char *)tmps->data;
#line 203
  if (type == 24) {
#line 204
    tmps->length = BIO_snprintf(p, len, "%04d%02d%02d%02d%02d%02dZ", ts->tm_year + 1900U,
                                ts->tm_mon + 1U, ts->tm_mday, ts->tm_hour, ts->tm_min,
                                ts->tm_sec);
  } else {
#line 209
    tmps->length = BIO_snprintf(p, len, "%02d%02d%02d%02d%02d%02dZ", ts->tm_year % 100U,
                                ts->tm_mon + 1U, ts->tm_mday, ts->tm_hour, ts->tm_min,
                                ts->tm_sec);
  }
#line 214
  return (tmps);
  err: 
#line 216
  if ((unsigned long )tmps != (unsigned long )s) {
#line 217
    ASN1_STRING_free(tmps);
  }
#line 218
  return ((ASN1_TIME *)((void *)0));
}
}
#line 227
extern int ( /* missing proto */  OPENSSL_gmtime)() ;
#line 232
extern int ( /* missing proto */  OPENSSL_gmtime_adj)() ;
#line 221 "openssl_leak_1.c"
ASN1_TIME *ASN1_TIME_adj(ASN1_TIME *s , time_t t , int offset_day , long offset_sec ) 
{ 
  struct tm *ts ;
  struct tm data ;
  int tmp ;
  int tmp___0 ;
  ASN1_TIME *tmp___1 ;

  {
#line 227
  tmp = OPENSSL_gmtime(& t, & data);
#line 227
  ts = (struct tm *)tmp;
#line 228
  if ((unsigned long )ts == (unsigned long )((void *)0)) {
#line 229
    return ((ASN1_TIME *)((void *)0));
  }
#line 231
  if (offset_day) {
#line 231
    goto _L;
  } else
#line 231
  if (offset_sec) {
    _L: /* CIL Label */ 
#line 232
    tmp___0 = OPENSSL_gmtime_adj(ts, offset_day, offset_sec);
#line 232
    if (! tmp___0) {
#line 233
      return ((ASN1_TIME *)((void *)0));
    }
  }
#line 235
  tmp___1 = asn1_time_from_tm(s, ts, -1);
#line 235
  return (tmp___1);
}
}
#line 238 "openssl_leak_1.c"
ASN1_TIME *ASN1_TIME_set(ASN1_TIME *s , time_t t ) 
{ 
  ASN1_TIME *tmp ;

  {
#line 240
  tmp = ASN1_TIME_adj(s, t, 0, 0L);
#line 240
  return (tmp);
}
}
#line 249
extern int ( /* missing proto */  X509_NAME_ENTRY_create_by_NID)() ;
#line 252
extern int ( /* missing proto */  X509_NAME_add_entry)() ;
#line 253
extern int ( /* missing proto */  X509_NAME_ENTRY_free)() ;
#line 243 "openssl_leak_1.c"
int X509_NAME_add_entry_by_NID(void *name , int nid , int type , unsigned char const   *bytes ,
                               int len , int loc , int set ) 
{ 
  void *ne ;
  int ret ;
  int tmp ;

  {
#line 249
  tmp = X509_NAME_ENTRY_create_by_NID((void *)0, nid, type, bytes, len);
#line 249
  ne = (void *)tmp;
#line 250
  if (! ne) {
#line 251
    return (0);
  }
#line 252
  ret = X509_NAME_add_entry(name, ne, loc, set);
#line 253
  X509_NAME_ENTRY_free(ne);
#line 254
  return (ret);
}
}
#line 268
extern int ( /* missing proto */  sk_OCSP_SINGLERESP_new_null)() ;
#line 273
extern int ( /* missing proto */  OCSP_CERTID_dup)() ;
#line 276
extern int ( /* missing proto */  sk_OCSP_SINGLERESP_push)() ;
#line 280
extern int ( /* missing proto */  OCSP_SINGLERESP_free)() ;
#line 257 "openssl_leak_1.c"
OCSP_SINGLERESP *OCSP_basic_add1_status(OCSP_BASICRESP___0 *rsp , OCSP_CERTID *cid ,
                                        int status , int reason , ASN1_TIME *revtime ,
                                        ASN1_TIME *thisupd , ASN1_TIME *nextupd ) 
{ 
  OCSP_SINGLERESP *single ;
  OCSP_SINGLERESP *tmp ;
  int tmp___0 ;
  OCSP_CERTID *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 264
  single = (OCSP_SINGLERESP *)((void *)0);
#line 268
  if ((unsigned long )rsp->tbsResponseData.responses == (unsigned long )((void *)0)) {
#line 268
    tmp___0 = sk_OCSP_SINGLERESP_new_null();
#line 268
    tmp = (OCSP_SINGLERESP *)tmp___0;
#line 268
    rsp->tbsResponseData.responses = tmp;
#line 268
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 271
      goto err;
    }
  }
#line 273
  tmp___2 = OCSP_CERTID_dup(cid);
#line 273
  tmp___1 = (OCSP_CERTID *)tmp___2;
#line 273
  single->certId = tmp___1;
#line 273
  if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
#line 274
    goto err;
  }
#line 276
  tmp___3 = sk_OCSP_SINGLERESP_push(rsp->tbsResponseData.responses, single);
#line 276
  if (! tmp___3) {
#line 277
    goto err;
  }
#line 278
  return (single);
  err: 
#line 280
  OCSP_SINGLERESP_free(single);
#line 281
  return ((OCSP_SINGLERESP *)((void *)0));
}
}
#line 288
extern int ( /* missing proto */  OCSP_BASICRESP_new)() ;
#line 290
extern int ( /* missing proto */  time)() ;
#line 292
extern int ( /* missing proto */  X509_NAME_new)() ;
#line 293
extern int ( /* missing proto */  ASN1_BIT_STRING_new)() ;
#line 294
extern int ( /* missing proto */  ASN1_INTEGER_new)() ;
#line 301
extern int ( /* missing proto */  OCSP_cert_id_new)() ;
#line 301
extern int ( /* missing proto */  EVP_sha256)() ;
#line 310
extern int ( /* missing proto */  ASN1_TIME_free)() ;
#line 312
extern int ( /* missing proto */  ASN1_BIT_STRING_free)() ;
#line 313
extern int ( /* missing proto */  ASN1_INTEGER_free)() ;
#line 314
extern int ( /* missing proto */  OCSP_CERTID_free)() ;
#line 315
extern int ( /* missing proto */  X509_NAME_free)() ;
#line 284 "openssl_leak_1.c"
static OCSP_BASICRESP___0 *make_dummy_resp(void) 
{ 
  unsigned char namestr[20] ;
  unsigned char keybytes[128] ;
  unsigned int tmp ;
  OCSP_BASICRESP___0 *bs ;
  int tmp___0 ;
  OCSP_CERTID *cid ;
  ASN1_TIME *thisupd ;
  int tmp___1 ;
  ASN1_TIME *tmp___2 ;
  ASN1_TIME *nextupd ;
  int tmp___3 ;
  ASN1_TIME *tmp___4 ;
  void *name ;
  int tmp___5 ;
  ASN1_BIT_STRING *key ;
  int tmp___6 ;
  ASN1_INTEGER *serial ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  OCSP_SINGLERESP *tmp___18 ;
  int tmp___19 ;

  {
#line 286
  namestr[0] = (unsigned char )'o';
#line 286
  namestr[1] = (unsigned char )'p';
#line 286
  namestr[2] = (unsigned char )'e';
#line 286
  namestr[3] = (unsigned char )'n';
#line 286
  namestr[4] = (unsigned char )'s';
#line 286
  namestr[5] = (unsigned char )'s';
#line 286
  namestr[6] = (unsigned char )'l';
#line 286
  namestr[7] = (unsigned char )'.';
#line 286
  namestr[8] = (unsigned char )'e';
#line 286
  namestr[9] = (unsigned char )'x';
#line 286
  namestr[10] = (unsigned char )'a';
#line 286
  namestr[11] = (unsigned char )'m';
#line 286
  namestr[12] = (unsigned char )'p';
#line 286
  namestr[13] = (unsigned char )'l';
#line 286
  namestr[14] = (unsigned char )'e';
#line 286
  namestr[15] = (unsigned char )'.';
#line 286
  namestr[16] = (unsigned char )'c';
#line 286
  namestr[17] = (unsigned char )'o';
#line 286
  namestr[18] = (unsigned char )'m';
#line 286
  namestr[19] = (unsigned char )'\000';
#line 287
  keybytes[0] = (unsigned char)7;
#line 287
  tmp = 1U;
#line 287
  while (! (tmp >= 128U)) {
#line 287
    keybytes[tmp] = (unsigned char)0;
#line 287
    tmp ++;
  }
#line 288
  tmp___0 = OCSP_BASICRESP_new();
#line 288
  bs = (OCSP_BASICRESP___0 *)tmp___0;
#line 290
  tmp___1 = time((void *)0);
#line 290
  tmp___2 = ASN1_TIME_set((ASN1_TIME *)((void *)0), (time_t )tmp___1);
#line 290
  thisupd = tmp___2;
#line 291
  tmp___3 = time((void *)0);
#line 291
  tmp___4 = ASN1_TIME_set((ASN1_TIME *)((void *)0), (time_t )(tmp___3 + 200));
#line 291
  nextupd = tmp___4;
#line 292
  tmp___5 = X509_NAME_new();
#line 292
  name = (void *)tmp___5;
#line 293
  tmp___6 = ASN1_BIT_STRING_new();
#line 293
  key = (ASN1_BIT_STRING *)tmp___6;
#line 294
  tmp___7 = ASN1_INTEGER_new();
#line 294
  serial = (ASN1_INTEGER *)tmp___7;
#line 296
  tmp___8 = X509_NAME_add_entry_by_NID(name, 13, 4097, (unsigned char const   *)(namestr),
                                       -1, -1, 1);
#line 296
  if (tmp___8) {
#line 296
    if (sizeof(keybytes)) {
#line 296
      tmp___10 = 1;
    } else {
#line 296
      tmp___9 = ASN1_INTEGER_set_uint64(serial, (uint64_t )1);
#line 296
      if (tmp___9) {
#line 296
        tmp___10 = 0;
      } else {
#line 296
        tmp___10 = 1;
      }
    }
#line 296
    tmp___11 = ASN1_BIT_STRING_set(key, keybytes, tmp___10);
#line 296
    if (! tmp___11) {
#line 300
      return ((OCSP_BASICRESP___0 *)((void *)0));
    }
  } else {
#line 300
    return ((OCSP_BASICRESP___0 *)((void *)0));
  }
#line 301
  tmp___12 = EVP_sha256();
#line 301
  tmp___13 = OCSP_cert_id_new(tmp___12, name, key, serial);
#line 301
  cid = (OCSP_CERTID *)tmp___13;
#line 302
  tmp___14 = test_ptr("openssl_leak_1.c", 302, "bs", (void const   *)bs);
#line 302
  if (tmp___14) {
#line 302
    tmp___15 = test_ptr("openssl_leak_1.c", 303, "thisupd", (void const   *)thisupd);
#line 302
    if (tmp___15) {
#line 302
      tmp___16 = test_ptr("openssl_leak_1.c", 304, "nextupd", (void const   *)nextupd);
#line 302
      if (tmp___16) {
#line 302
        tmp___17 = test_ptr("openssl_leak_1.c", 305, "cid", (void const   *)cid);
#line 302
        if (tmp___17) {
#line 302
          tmp___18 = OCSP_basic_add1_status(bs, cid, 2, 0, (ASN1_TIME *)((void *)0),
                                            thisupd, nextupd);
#line 302
          tmp___19 = test_true("openssl_leak_1.c", 308, "OCSP_basic_add1_status(bs, cid, V_OCSP_CERTSTATUS_UNKNOWN, 0, NULL, thisupd, nextupd)",
                               (unsigned long )tmp___18 != (unsigned long )((OCSP_SINGLERESP *)0));
#line 302
          if (! tmp___19) {
#line 309
            return ((OCSP_BASICRESP___0 *)((void *)0));
          }
        } else {
#line 309
          return ((OCSP_BASICRESP___0 *)((void *)0));
        }
      } else {
#line 309
        return ((OCSP_BASICRESP___0 *)((void *)0));
      }
    } else {
#line 309
      return ((OCSP_BASICRESP___0 *)((void *)0));
    }
  } else {
#line 309
    return ((OCSP_BASICRESP___0 *)((void *)0));
  }
#line 310
  ASN1_TIME_free(thisupd);
#line 311
  ASN1_TIME_free(nextupd);
#line 312
  ASN1_BIT_STRING_free(key);
#line 313
  ASN1_INTEGER_free(serial);
#line 314
  OCSP_CERTID_free(cid);
#line 315
  X509_NAME_free(name);
#line 316
  return (bs);
}
}
#line 329
extern int ( /* missing proto */  get_cert_and_key)() ;
#line 329
extern int ( /* missing proto */  OCSP_basic_sign)() ;
#line 329
extern int ( /* missing proto */  EVP_sha1)() ;
#line 334
extern int ( /* missing proto */  OCSP_BASICRESP_free)() ;
#line 343
extern int ( /* missing proto */  OCSP_resp_get0_signer)() ;
#line 343
extern int ( /* missing proto */  TEST_int_eq)() ;
#line 343
extern int ( /* missing proto */  X509_cmp)() ;
#line 347
extern int ( /* missing proto */  X509_free)() ;
#line 348
extern int ( /* missing proto */  EVP_PKEY_free)() ;
#line 319 "openssl_leak_1.c"
int main(void) 
{ 
  OCSP_BASICRESP___0 *bs ;
  X509 *signer ;
  X509 *tmp ;
  EVP_PKEY *key ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
#line 322
  signer = (X509 *)((void *)0);
#line 323
  key = (EVP_PKEY *)((void *)0);
#line 328
  bs = make_dummy_resp();
#line 329
  tmp___0 = test_ptr("openssl_leak_1.c", 329, "bs", (void const   *)bs);
#line 329
  if (tmp___0) {
#line 329
    tmp___1 = get_cert_and_key(& signer, & key);
#line 329
    tmp___2 = test_true("openssl_leak_1.c", 330, "get_cert_and_key(&signer, &key)",
                        tmp___1 != 0);
#line 329
    if (tmp___2) {
#line 329
      tmp___3 = EVP_sha1();
#line 329
      tmp___4 = OCSP_basic_sign(bs, signer, key, tmp___3, (void *)0, 1);
#line 329
      tmp___5 = test_true("openssl_leak_1.c", 332, "OCSP_basic_sign(bs, signer, key, EVP_sha1(), NULL, OCSP_NOCERTS)",
                          tmp___4 != 0);
#line 329
      if (! tmp___5) {
#line 333
        return (0);
      }
    } else {
#line 333
      return (0);
    }
  } else {
#line 333
    return (0);
  }
#line 334
  OCSP_BASICRESP_free(bs);
#line 337
  bs = make_dummy_resp();
#line 338
  tmp = (X509 *)((void *)0);
#line 339
  tmp___6 = test_ptr("openssl_leak_1.c", 339, "bs", (void const   *)bs);
#line 339
  if (tmp___6) {
#line 339
    tmp___7 = EVP_sha1();
#line 339
    tmp___8 = OCSP_basic_sign(bs, signer, key, tmp___7, (void *)0, 0);
#line 339
    tmp___9 = test_true("openssl_leak_1.c", 341, "OCSP_basic_sign(bs, signer, key, EVP_sha1(), NULL, 0)",
                        tmp___8 != 0);
#line 339
    if (! tmp___9) {
#line 342
      return (0);
    }
  } else {
#line 342
    return (0);
  }
#line 343
  tmp___10 = OCSP_resp_get0_signer(bs, & tmp, (void *)0);
#line 343
  tmp___11 = test_true("openssl_leak_1.c", 343, "OCSP_resp_get0_signer(bs, &tmp, NULL)",
                       tmp___10 != 0);
#line 343
  if (tmp___11) {
#line 343
    tmp___12 = X509_cmp(tmp, signer);
#line 343
    tmp___13 = TEST_int_eq(tmp___12, 0);
#line 343
    if (! tmp___13) {
#line 345
      return (0);
    }
  } else {
#line 345
    return (0);
  }
#line 346
  OCSP_BASICRESP_free(bs);
#line 347
  X509_free(signer);
#line 348
  EVP_PKEY_free(key);
#line 349
  return (1);
}
}
