/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

#line 216 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h"
typedef unsigned long size_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 317 "../openssl.h"
struct evp_pkey_st;
#line 317 "../openssl.h"
typedef struct evp_pkey_st EVP_PKEY;
#line 344
struct ssl_dane_st;
#line 344 "../openssl.h"
typedef struct ssl_dane_st SSL_DANE;
#line 345
struct x509_st;
#line 345 "../openssl.h"
typedef struct x509_st X509;
#line 347
struct X509_crl_st;
#line 347 "../openssl.h"
typedef struct X509_crl_st X509_CRL;
#line 352
struct x509_store_st;
#line 352 "../openssl.h"
typedef struct x509_store_st X509_STORE;
#line 353
struct x509_store_ctx_st;
#line 353 "../openssl.h"
typedef struct x509_store_ctx_st X509_STORE_CTX;
#line 358
struct X509_VERIFY_PARAM_st;
#line 358 "../openssl.h"
typedef struct X509_VERIFY_PARAM_st X509_VERIFY_PARAM;
#line 380
struct X509_POLICY_TREE_st;
#line 380 "../openssl.h"
typedef struct X509_POLICY_TREE_st X509_POLICY_TREE;
#line 388
struct crypto_ex_data_st;
#line 416 "../openssl.h"
typedef struct crypto_ex_data_st CRYPTO_EX_DATA___0;
#line 654 "../openssl.h"
struct crypto_ex_data_st {
   void *sk ;
};
#line 709 "../openssl.h"
struct x509_store_ctx_st {
   X509_STORE *ctx ;
   X509 *cert ;
   void *untrusted ;
   void *crls ;
   X509_VERIFY_PARAM *param ;
   void *other_ctx ;
   int (*verify)(X509_STORE_CTX *ctx ) ;
   int (*verify_cb)(int ok , X509_STORE_CTX *ctx ) ;
   int (*get_issuer)(X509 **issuer , X509_STORE_CTX *ctx , X509 *x ) ;
   int (*check_issued)(X509_STORE_CTX *ctx , X509 *x , X509 *issuer ) ;
   int (*check_revocation)(X509_STORE_CTX *ctx ) ;
   int (*get_crl)(X509_STORE_CTX *ctx , X509_CRL **crl , X509 *x ) ;
   int (*check_crl)(X509_STORE_CTX *ctx , X509_CRL *crl ) ;
   int (*cert_crl)(X509_STORE_CTX *ctx , X509_CRL *crl , X509 *x ) ;
   int (*check_policy)(X509_STORE_CTX *ctx ) ;
   void *(*lookup_certs)(X509_STORE_CTX *ctx , void *nm ) ;
   void *(*lookup_crls)(X509_STORE_CTX *ctx , void *nm ) ;
   int (*cleanup)(X509_STORE_CTX *ctx ) ;
   int valid ;
   int num_untrusted ;
   void *chain ;
   X509_POLICY_TREE *tree ;
   int explicit_policy ;
   int error_depth ;
   int error ;
   X509 *current_cert ;
   X509 *current_issuer ;
   X509_CRL *current_crl ;
   int current_crl_score ;
   unsigned int current_reasons ;
   X509_STORE_CTX *parent ;
   CRYPTO_EX_DATA___0 ex_data ;
   SSL_DANE *dane ;
   int bare_ta_signed ;
};
#line 167 "openssl_leak_5.c"
struct X509_VERIFY_PARAM_st {
   char *name ;
   time_t check_time ;
   unsigned long flags ;
   int purpose ;
   int trust ;
   int depth ;
   int auth_level ;
   void *policies ;
   void *hosts ;
   unsigned int hostflags ;
   char *peername ;
   char *email ;
   size_t emaillen ;
   unsigned char *ip ;
   size_t iplen ;
};
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 186 "openssl_leak_5.c"
static X509 *test_root  =    (X509 *)((void *)0);
#line 187 "openssl_leak_5.c"
static X509 *test_leaf  =    (X509 *)((void *)0);
#line 189
extern void X509_free(X509 *a ) ;
#line 196
extern int ( /* missing proto */  X509_VERIFY_PARAM_free)() ;
#line 199
extern int ( /* missing proto */  X509_policy_tree_free)() ;
#line 201
extern int ( /* missing proto */  sk_X509_pop_free)() ;
#line 191 "openssl_leak_5.c"
void X509_STORE_CTX_cleanup(X509_STORE_CTX *ctx ) 
{ 


  {
#line 193
  if ((unsigned long )ctx->param != (unsigned long )((void *)0)) {
#line 194
    printf((char const   * __restrict  )"%x\n", ctx->param);
#line 195
    if ((unsigned long )ctx->parent == (unsigned long )((void *)0)) {
#line 196
      X509_VERIFY_PARAM_free(ctx->param);
    }
#line 197
    ctx->param = (X509_VERIFY_PARAM *)((void *)0);
  }
#line 199
  X509_policy_tree_free(ctx->tree);
#line 200
  ctx->tree = (X509_POLICY_TREE *)((void *)0);
#line 201
  sk_X509_pop_free(ctx->chain, & X509_free);
#line 202
  ctx->chain = (void *)0;
#line 203
  return;
}
}
#line 212
extern int ( /* missing proto */  OPENSSL_free)() ;
#line 206 "openssl_leak_5.c"
void X509_STORE_CTX_free(X509_STORE_CTX *ctx ) 
{ 


  {
#line 208
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
#line 209
    return;
  }
#line 211
  X509_STORE_CTX_cleanup(ctx);
#line 212
  OPENSSL_free(ctx);
#line 213
  return;
}
}
#line 219
extern int ( /* missing proto */  test_fail_message)() ;
#line 215 "openssl_leak_5.c"
int test_ptr(char const   *file , int line , char const   *s , void const   *p ) 
{ 


  {
#line 217
  if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 218
    return (1);
  }
#line 219
  test_fail_message((void *)0, file, line, "ptr", s, "NULL", "!=", "%p", p);
#line 220
  return (0);
}
}
#line 222 "openssl_leak_5.c"
void X509_VERIFY_PARAM_set_depth(X509_VERIFY_PARAM *param , int depth ) 
{ 


  {
#line 224
  param->depth = depth;
#line 225
  return;
}
}
#line 227 "openssl_leak_5.c"
void X509_VERIFY_PARAM_set_time(X509_VERIFY_PARAM *param , time_t t ) 
{ 


  {
#line 229
  param->check_time = t;
#line 230
  param->flags |= 2UL;
#line 231
  return;
}
}
#line 233 "openssl_leak_5.c"
time_t X509_VERIFY_PARAM_get_time(X509_VERIFY_PARAM const   *param ) 
{ 


  {
#line 235
  return ((time_t )param->check_time);
}
}
#line 238 "openssl_leak_5.c"
int X509_VERIFY_PARAM_set_flags(X509_VERIFY_PARAM *param , unsigned long flags ) 
{ 


  {
#line 240
  param->flags |= flags;
#line 241
  if (flags & 1920UL) {
#line 242
    param->flags |= 128UL;
  }
#line 243
  return (1);
}
}
#line 246 "openssl_leak_5.c"
void X509_STORE_CTX_set0_param(X509_STORE_CTX *ctx , X509_VERIFY_PARAM *param ) 
{ 


  {
#line 248
  X509_VERIFY_PARAM_free(ctx->param);
#line 249
  ctx->param = param;
#line 250
  return;
}
}
#line 252 "openssl_leak_5.c"
static int const   minbits_table[5]  = {      (int const   )80,      (int const   )112,      (int const   )128,      (int const   )192, 
        (int const   )256};
#line 262
extern int ( /* missing proto */  X509_get0_pubkey)() ;
#line 272
extern int ( /* missing proto */  EVP_PKEY_security_bits)() ;
#line 260 "openssl_leak_5.c"
static int check_key_level(X509_STORE_CTX *ctx , X509 *cert ) 
{ 
  EVP_PKEY *pkey ;
  int tmp ;
  int level ;
  int tmp___0 ;

  {
#line 262
  tmp = X509_get0_pubkey(cert);
#line 262
  pkey = (EVP_PKEY *)tmp;
#line 263
  level = (ctx->param)->auth_level;
#line 266
  if ((unsigned long )pkey == (unsigned long )((void *)0)) {
#line 267
    return (0);
  }
#line 269
  if (level <= 0) {
#line 270
    return (1);
  }
#line 272
  tmp___0 = EVP_PKEY_security_bits(pkey);
#line 272
  return (tmp___0 >= (int )minbits_table[level - 1]);
}
}
#line 298
extern int ( /* missing proto */  sk_X509_new_null)() ;
#line 298
extern int ( /* missing proto */  sk_X509_push)() ;
#line 303
extern int ( /* missing proto */  X509_up_ref)() ;
#line 307
extern int ( /* missing proto */  verify_cb_cert)() ;
#line 312
extern int ( /* missing proto */  dane_verify)() ;
#line 314
extern int ( /* missing proto */  verify_chain)() ;
#line 311
extern int ( /* missing proto */  DANETLS_ENABLED)() ;
#line 275 "openssl_leak_5.c"
int X509_verify_cert(X509_STORE_CTX *ctx ) 
{ 
  SSL_DANE *dane ;
  int ret ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 277
  dane = ctx->dane;
#line 280
  if ((unsigned long )ctx->cert == (unsigned long )((void *)0)) {
#line 281
    ctx->error = 69;
#line 282
    return (-1);
  }
#line 285
  if ((unsigned long )ctx->chain != (unsigned long )((void *)0)) {
#line 290
    ctx->error = 69;
#line 291
    return (-1);
  }
#line 298
  tmp___0 = sk_X509_new_null();
#line 298
  tmp = (void *)tmp___0;
#line 298
  ctx->chain = tmp;
#line 298
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 300
    ctx->error = 17;
#line 301
    return (-1);
  } else {
#line 298
    tmp___1 = sk_X509_push(ctx->chain, ctx->cert);
#line 298
    if (! tmp___1) {
#line 300
      ctx->error = 17;
#line 301
      return (-1);
    }
  }
#line 303
  X509_up_ref(ctx->cert);
#line 304
  ctx->num_untrusted = 1;
#line 307
  tmp___2 = check_key_level(ctx, ctx->cert);
#line 307
  if (! tmp___2) {
#line 307
    tmp___3 = verify_cb_cert(ctx, ctx->cert, 0, 66);
#line 307
    if (! tmp___3) {
#line 309
      return (0);
    }
  }
#line 311
  tmp___4 = DANETLS_ENABLED(dane);
#line 311
  if (tmp___4) {
#line 312
    ret = dane_verify(ctx);
  } else {
#line 314
    ret = verify_chain(ctx);
  }
#line 321
  if (ret <= 0) {
#line 321
    if (ctx->error == 0) {
#line 322
      ctx->error = 1;
    }
  }
#line 323
  return (ret);
}
}
#line 334
extern int ( /* missing proto */  X509_STORE_CTX_new)() ;
#line 335
extern int ( /* missing proto */  X509_STORE_new)() ;
#line 336
extern int ( /* missing proto */  X509_VERIFY_PARAM_new)() ;
#line 348
extern int ( /* missing proto */  TEST_true)() ;
#line 348
extern int ( /* missing proto */  X509_STORE_CTX_init)() ;
#line 351
extern int ( /* missing proto */  X509_STORE_CTX_set0_trusted_stack)() ;
#line 352
extern int ( /* missing proto */  X509_STORE_CTX_set0_crls)() ;
#line 354
extern int ( /* missing proto */  test_long_eq)() ;
#line 361
extern int ( /* missing proto */  ERR_clear_error)() ;
#line 362
extern int ( /* missing proto */  X509_STORE_CTX_get_error)() ;
#line 367
extern int ( /* missing proto */  X509_STORE_free)() ;
#line 331 "openssl_leak_5.c"
static int verify(X509 *leaf , X509 *root , void *crls , unsigned long flags ) 
{ 
  X509_STORE_CTX *ctx ;
  int tmp ;
  X509_STORE *store ;
  int tmp___0 ;
  X509_VERIFY_PARAM *param ;
  int tmp___1 ;
  void *roots ;
  int tmp___2 ;
  int status ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  time_t tmp___7 ;
  int tmp___8 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 334
  tmp = X509_STORE_CTX_new();
#line 334
  ctx = (X509_STORE_CTX *)tmp;
#line 335
  tmp___0 = X509_STORE_new();
#line 335
  store = (X509_STORE *)tmp___0;
#line 336
  tmp___1 = X509_VERIFY_PARAM_new();
#line 336
  param = (X509_VERIFY_PARAM *)tmp___1;
#line 337
  tmp___2 = sk_X509_new_null();
#line 337
  roots = (void *)tmp___2;
#line 338
  status = 1;
#line 340
  if (! (& test_ptr)) {
#line 344
    goto err;
  } else
#line 340
  if (! (& test_ptr)) {
#line 344
    goto err;
  } else
#line 340
  if (! (& test_ptr)) {
#line 344
    goto err;
  } else
#line 340
  if (! (& test_ptr)) {
#line 344
    goto err;
  }
#line 347
  X509_up_ref(root);
#line 348
  tmp___3 = sk_X509_push(roots, root);
#line 348
  tmp___4 = TEST_true(tmp___3);
#line 348
  if (tmp___4) {
#line 348
    tmp___5 = X509_STORE_CTX_init(ctx, store, leaf, (void *)0);
#line 348
    tmp___6 = TEST_true(tmp___5);
#line 348
    if (! tmp___6) {
#line 350
      goto err;
    }
  } else {
#line 350
    goto err;
  }
#line 351
  X509_STORE_CTX_set0_trusted_stack(ctx, roots);
#line 352
  X509_STORE_CTX_set0_crls(ctx, crls);
#line 353
  X509_VERIFY_PARAM_set_time(param, (time_t )1474934400);
#line 354
  tmp___7 = X509_VERIFY_PARAM_get_time((X509_VERIFY_PARAM const   *)param);
#line 354
  tmp___8 = test_long_eq("openssl_leak_5.c", 354, "X509_VERIFY_PARAM_get_time(param)",
                         "PARAM_TIME", tmp___7, 1474934400);
#line 354
  if (! tmp___8) {
#line 355
    goto err;
  }
#line 356
  X509_VERIFY_PARAM_set_depth(param, 16);
#line 357
  if (flags) {
#line 358
    X509_VERIFY_PARAM_set_flags(param, flags);
  }
#line 359
  X509_STORE_CTX_set0_param(ctx, param);
#line 361
  ERR_clear_error();
#line 362
  tmp___11 = X509_verify_cert(ctx);
#line 362
  if (tmp___11 == 1) {
#line 362
    status = 0;
  } else {
#line 362
    tmp___10 = X509_STORE_CTX_get_error(ctx);
#line 362
    status = tmp___10;
  }
  err: 
#line 365
  sk_X509_pop_free(roots, & X509_free);
#line 366
  X509_STORE_CTX_free(ctx);
#line 367
  X509_STORE_free(store);
#line 368
  return (status);
}
}
#line 373
extern int ( /* missing proto */  TEST_int_eq)() ;
#line 371 "openssl_leak_5.c"
static int test_no_crl(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 373
  tmp = verify(test_leaf, test_root, (void *)0, 4UL);
#line 373
  tmp___0 = TEST_int_eq(tmp, 3);
#line 373
  return (tmp___0);
}
}
#line 378 "openssl_leak_5.c"
int main(void) 
{ 


  {
#line 380
  if (! (& test_ptr)) {
#line 382
    return (0);
  } else
#line 380
  if (! (& test_ptr)) {
#line 382
    return (0);
  }
#line 383
  test_no_crl();
#line 384
  X509_free(test_root);
#line 385
  X509_free(test_leaf);
#line 386
  return (0);
}
}
