/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

#line 216 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h"
typedef unsigned long size_t;
#line 323 "../openssl.h"
struct evp_md_st;
#line 323 "../openssl.h"
typedef struct evp_md_st EVP_MD;
#line 380
struct ssl_st;
#line 380 "../openssl.h"
typedef struct ssl_st SSL;
#line 381
struct ssl_ctx_st;
#line 381 "../openssl.h"
typedef struct ssl_ctx_st SSL_CTX;
#line 416
struct ssl_cipher_st;
#line 416 "../openssl.h"
typedef struct ssl_cipher_st SSL_CIPHER;
#line 417
struct ssl_session_st;
#line 417 "../openssl.h"
typedef struct ssl_session_st SSL_SESSION;
#line 21 "openssl_leak_8.c"
struct ssl_ctx_st {
   int (*psk_use_session_cb)(SSL *ssl , EVP_MD const   *md , unsigned char const   **id ,
                             size_t *idlen , SSL_SESSION **sess ) ;
};
#line 24 "openssl_leak_8.c"
struct ssl_session_st {
   SSL_CIPHER const   *cipher ;
};
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 11 "openssl_leak_8.c"
void SSL_SESSION_free(SSL_SESSION *ss ) 
{ 


  {
#line 13
  free((void *)ss);
#line 14
  return;
}
}
#line 27 "openssl_leak_8.c"
static SSL_SESSION *psksess  =    (SSL_SESSION *)((void *)0);
#line 28 "openssl_leak_8.c"
static char *psk_identity  =    (char *)"Client_identity";
#line 29 "openssl_leak_8.c"
static int psk_key  ;
#line 30 "openssl_leak_8.c"
unsigned char const   tls13_aes128gcmsha256_id[2]  = {      (unsigned char const   )19,      (unsigned char const   )1};
#line 31 "openssl_leak_8.c"
unsigned char const   tls13_aes256gcmsha384_id[2]  = {      (unsigned char const   )19,      (unsigned char const   )2};
#line 41
extern int ( /* missing proto */  SSL_SESSION_up_ref)() ;
#line 45
extern int ( /* missing proto */  strdup)() ;
#line 52
extern int ( /* missing proto */  SSL_CIPHER_find)() ;
#line 53
extern int ( /* missing proto */  EVP_MD_size)() ;
#line 53
extern int ( /* missing proto */  EVP_sha384)() ;
#line 51
extern int ( /* missing proto */  EVP_sha256)() ;
#line 65
extern int ( /* missing proto */  SSL_SESSION_set1_master_key)() ;
#line 65
extern int ( /* missing proto */  SSL_SESSION_set_cipher)() ;
#line 71
extern int ( /* missing proto */  SSL_SESSION_get0_cipher)() ;
#line 84
extern int ( /* missing proto */  strlen)() ;
#line 75
extern int ( /* missing proto */  SSL_CIPHER_get_handshake_digest)() ;
#line 33 "openssl_leak_8.c"
static int psk_use_session_cb(SSL *s , EVP_MD const   *md , unsigned char const   **id ,
                              size_t *idlen , SSL_SESSION **sess ) 
{ 
  SSL_SESSION *usesess ;
  SSL_CIPHER const   *cipher ;
  long key_len ;
  unsigned char *key ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 37
  usesess = (SSL_SESSION *)((void *)0);
#line 38
  cipher = (SSL_CIPHER const   *)((void *)0);
#line 40
  if ((unsigned long )psksess != (unsigned long )((void *)0)) {
#line 41
    SSL_SESSION_up_ref(psksess);
#line 42
    usesess = psksess;
  } else {
#line 45
    tmp = strdup(psk_key);
#line 45
    key = (unsigned char *)tmp;
#line 47
    if ((unsigned long )key == (unsigned long )((void *)0)) {
#line 48
      return (0);
    }
#line 51
    tmp___4 = EVP_sha256();
#line 51
    tmp___5 = EVP_MD_size(tmp___4);
#line 51
    if (key_len == (long )tmp___5) {
#line 52
      tmp___0 = SSL_CIPHER_find(s, tls13_aes128gcmsha256_id);
#line 52
      cipher = (SSL_CIPHER const   *)tmp___0;
    } else {
#line 53
      tmp___2 = EVP_sha384();
#line 53
      tmp___3 = EVP_MD_size(tmp___2);
#line 53
      if (key_len == (long )tmp___3) {
#line 54
        tmp___1 = SSL_CIPHER_find(s, tls13_aes256gcmsha384_id);
#line 54
        cipher = (SSL_CIPHER const   *)tmp___1;
      }
    }
#line 56
    if ((unsigned long )cipher == (unsigned long )((void *)0)) {
#line 58
      free((void *)key);
#line 59
      *id = (unsigned char const   *)((void *)0);
#line 60
      *idlen = (size_t )0;
#line 61
      *sess = (SSL_SESSION *)((void *)0);
#line 62
      return (0);
    }
#line 64
    tmp___6 = malloc(sizeof(*usesess));
#line 64
    usesess = (SSL_SESSION *)tmp___6;
#line 65
    if ((unsigned long )usesess == (unsigned long )((void *)0)) {
#line 68
      goto err;
    } else {
#line 65
      tmp___7 = SSL_SESSION_set1_master_key(usesess, key, key_len);
#line 65
      if (tmp___7) {
#line 65
        tmp___8 = SSL_SESSION_set_cipher(usesess, cipher);
#line 65
        if (! tmp___8) {
#line 68
          goto err;
        }
      } else {
#line 68
        goto err;
      }
    }
  }
#line 71
  tmp___9 = SSL_SESSION_get0_cipher(usesess);
#line 71
  cipher = (SSL_CIPHER const   *)tmp___9;
#line 72
  if ((unsigned long )cipher == (unsigned long )((void *)0)) {
#line 73
    goto err;
  }
#line 75
  if ((unsigned long )md != (unsigned long )((void *)0)) {
#line 75
    tmp___11 = SSL_CIPHER_get_handshake_digest(cipher);
#line 75
    if ((unsigned long )tmp___11 != (unsigned long )md) {
#line 77
      *id = (unsigned char const   *)((void *)0);
#line 78
      *idlen = (size_t )0;
#line 79
      *sess = (SSL_SESSION *)((void *)0);
#line 80
      SSL_SESSION_free(usesess);
    } else {
#line 82
      *sess = usesess;
#line 83
      *id = (unsigned char const   *)((unsigned char *)psk_identity);
#line 84
      tmp___10 = strlen(psk_identity);
#line 84
      *idlen = (size_t )tmp___10;
    }
  } else {
#line 82
    *sess = usesess;
#line 83
    *id = (unsigned char const   *)((unsigned char *)psk_identity);
#line 84
    tmp___10 = strlen(psk_identity);
#line 84
    *idlen = (size_t )tmp___10;
  }
#line 87
  return (1);
  err: 
#line 90
  SSL_SESSION_free(usesess);
#line 91
  return (0);
}
}
#line 94 "openssl_leak_8.c"
void SSL_CTX_set_psk_use_session_callback(SSL_CTX *ctx , int (*cb)(SSL *ssl , EVP_MD const   *md ,
                                                                   unsigned char const   **id ,
                                                                   size_t *idlen ,
                                                                   SSL_SESSION **sess ) ) 
{ 


  {
#line 97
  ctx->psk_use_session_cb = cb;
#line 98
  return;
}
}
#line 100 "openssl_leak_8.c"
int main(int argc , char **argv ) 
{ 
  char *psksessf ;
  SSL_CTX ctx ;
  SSL_SESSION *sess ;
  void *tmp ;

  {
#line 105
  if ((unsigned long )psksessf != (unsigned long )((void *)0)) {
#line 107
    tmp = malloc(sizeof(SSL_SESSION ));
#line 107
    psksess = (SSL_SESSION *)tmp;
#line 108
    if ((unsigned long )psksess == (unsigned long )((void *)0)) {
#line 109
      goto end;
    }
  }
#line 113
  if ((unsigned long )psksess != (unsigned long )((void *)0)) {
#line 114
    SSL_CTX_set_psk_use_session_callback(& ctx, & psk_use_session_cb);
  }
#line 115
  (*(ctx.psk_use_session_cb))((SSL *)((void *)0), (EVP_MD const   *)((void *)0), (unsigned char const   **)((void *)0),
                              (size_t *)((void *)0), & sess);
#line 116
  printf((char const   * __restrict  )"%d\n", sess);
  end: 
#line 119
  return (0);
}
}
