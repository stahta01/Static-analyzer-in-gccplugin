/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

#line 216 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h"
typedef unsigned long size_t;
#line 317 "../openssl.h"
struct evp_pkey_st;
#line 317 "../openssl.h"
typedef struct evp_pkey_st EVP_PKEY;
#line 396
struct ctlog_st;
#line 396 "../openssl.h"
typedef struct ctlog_st CTLOG;
#line 95 "openssl_leak_10.c"
extern int ( /* missing proto */  conv_ascii2bin)() ;
#line 89 "openssl_leak_10.c"
int EVP_DecodeBlock(unsigned char *t , unsigned char const   *f , int n ) 
{ 
  int i ;
  int ret ;
  int a ;
  int b ;
  int c ;
  int d ;
  unsigned long l ;
  int tmp ;
  int tmp___0 ;
  unsigned char const   *tmp___1 ;
  unsigned char const   *tmp___2 ;
  unsigned char const   *tmp___3 ;
  unsigned char const   *tmp___4 ;
  unsigned char *tmp___5 ;
  unsigned char *tmp___6 ;
  unsigned char *tmp___7 ;

  {
#line 91
  ret = 0;
#line 95
  while (1) {
#line 95
    tmp = conv_ascii2bin((int const   )*f);
#line 95
    if (tmp == 224) {
#line 95
      if (! (n > 0)) {
#line 95
        break;
      }
    } else {
#line 95
      break;
    }
#line 96
    f ++;
#line 97
    n --;
  }
#line 104
  while (1) {
#line 104
    if (n > 3) {
#line 104
      tmp___0 = conv_ascii2bin((int const   )*(f + (n - 1)));
#line 104
      if (! ((tmp___0 | 19) == 243)) {
#line 104
        break;
      }
    } else {
#line 104
      break;
    }
#line 105
    n --;
  }
#line 107
  if (n % 4 != 0) {
#line 108
    return (-1);
  }
#line 110
  i = 0;
#line 110
  while (i < n) {
#line 111
    tmp___1 = f;
#line 111
    f ++;
#line 111
    a = conv_ascii2bin((int const   )*tmp___1);
#line 112
    tmp___2 = f;
#line 112
    f ++;
#line 112
    b = conv_ascii2bin((int const   )*tmp___2);
#line 113
    tmp___3 = f;
#line 113
    f ++;
#line 113
    c = conv_ascii2bin((int const   )*tmp___3);
#line 114
    tmp___4 = f;
#line 114
    f ++;
#line 114
    d = conv_ascii2bin((int const   )*tmp___4);
#line 115
    if (a & 128) {
#line 116
      return (-1);
    } else
#line 115
    if (b & 128) {
#line 116
      return (-1);
    } else
#line 115
    if (c & 128) {
#line 116
      return (-1);
    } else
#line 115
    if (d & 128) {
#line 116
      return (-1);
    }
#line 117
    l = ((((unsigned long )a << 18L) | ((unsigned long )b << 12L)) | ((unsigned long )c << 6L)) | (unsigned long )d;
#line 120
    tmp___5 = t;
#line 120
    t ++;
#line 120
    *tmp___5 = (unsigned char )((int )((unsigned char )(l >> 16L)) & 255);
#line 121
    tmp___6 = t;
#line 121
    t ++;
#line 121
    *tmp___6 = (unsigned char )((int )((unsigned char )(l >> 8L)) & 255);
#line 122
    tmp___7 = t;
#line 122
    t ++;
#line 122
    *tmp___7 = (unsigned char )((int )((unsigned char )l) & 255);
#line 123
    ret += 3;
#line 110
    i += 4;
  }
#line 125
  return (ret);
}
}
#line 135
extern int ( /* missing proto */  strlen)() ;
#line 145
extern int ( /* missing proto */  OPENSSL_malloc)() ;
#line 147
extern int ( /* missing proto */  CTerr)() ;
#line 165
extern int ( /* missing proto */  OPENSSL_free)() ;
#line 133 "openssl_leak_10.c"
static int ct_base64_decode(char const   *in , unsigned char **out ) 
{ 
  size_t inlen ;
  int tmp ;
  int outlen ;
  unsigned char *outbuf ;
  int tmp___0 ;

  {
#line 135
  tmp = strlen(in);
#line 135
  inlen = (size_t )tmp;
#line 137
  outbuf = (unsigned char *)((void *)0);
#line 139
  if (inlen == 0UL) {
#line 140
    *out = (unsigned char *)((void *)0);
#line 141
    return (0);
  }
#line 144
  outlen = (int )((inlen / 4UL) * 3UL);
#line 145
  tmp___0 = OPENSSL_malloc(outlen);
#line 145
  outbuf = (unsigned char *)tmp___0;
#line 146
  if ((unsigned long )outbuf == (unsigned long )((void *)0)) {
#line 147
    CTerr(124, 65);
#line 148
    goto err;
  }
#line 151
  outlen = EVP_DecodeBlock(outbuf, (unsigned char const   *)((unsigned char *)in),
                           (int )inlen);
#line 152
  if (outlen < 0) {
#line 153
    CTerr(124, 108);
#line 154
    goto err;
  }
#line 158
  while (1) {
#line 158
    inlen --;
#line 158
    if (! ((int const   )*(in + inlen) == 61)) {
#line 158
      break;
    }
#line 159
    outlen --;
  }
#line 162
  *out = outbuf;
#line 163
  return (outlen);
  err: 
#line 165
  OPENSSL_free(outbuf);
#line 166
  return (-1);
}
}
#line 193
extern int ( /* missing proto */  d2i_PUBKEY)() ;
#line 200
extern int ( /* missing proto */  CTLOG_new)() ;
#line 202
extern int ( /* missing proto */  EVP_PKEY_free)() ;
#line 175 "openssl_leak_10.c"
int CTLOG_new_from_base64(CTLOG **ct_log , char const   *pkey_base64 , char const   *name ) 
{ 
  unsigned char *pkey_der ;
  int pkey_der_len ;
  int tmp ;
  unsigned char const   *p ;
  EVP_PKEY *pkey ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 177
  pkey_der = (unsigned char *)((void *)0);
#line 178
  tmp = ct_base64_decode(pkey_base64, & pkey_der);
#line 178
  pkey_der_len = tmp;
#line 180
  pkey = (EVP_PKEY *)((void *)0);
#line 182
  if ((unsigned long )ct_log == (unsigned long )((void *)0)) {
#line 183
    CTerr(118, 7);
#line 184
    return (0);
  }
#line 187
  if (pkey_der_len <= 0) {
#line 188
    CTerr(118, 110);
#line 189
    return (0);
  }
#line 192
  p = (unsigned char const   *)pkey_der;
#line 193
  tmp___0 = d2i_PUBKEY((void *)0, & p, pkey_der_len);
#line 193
  pkey = (EVP_PKEY *)tmp___0;
#line 194
  OPENSSL_free(pkey_der);
#line 195
  if ((unsigned long )pkey == (unsigned long )((void *)0)) {
#line 196
    CTerr(118, 110);
#line 197
    return (0);
  }
#line 200
  tmp___1 = CTLOG_new(pkey, name);
#line 200
  *ct_log = (CTLOG *)tmp___1;
#line 201
  if ((unsigned long )*ct_log == (unsigned long )((void *)0)) {
#line 202
    EVP_PKEY_free(pkey);
#line 203
    return (0);
  }
#line 206
  return (1);
}
}
#line 209 "openssl_leak_10.c"
int main(void) 
{ 
  CTLOG *ct_log ;

  {
#line 212
  CTLOG_new_from_base64(& ct_log, "pkey_base64", "name");
#line 213
  return (0);
}
}
