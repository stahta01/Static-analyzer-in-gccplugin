/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_14 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_14 fd_set;
#line 303 "../openssl.h"
struct bio_st;
#line 303 "../openssl.h"
typedef struct bio_st BIO;
#line 372
struct ssl_st;
#line 372 "../openssl.h"
typedef struct ssl_st SSL;
#line 409
struct ssl_session_st;
#line 409 "../openssl.h"
typedef struct ssl_session_st SSL_SESSION;
#line 411
struct ssl_conf_ctx_st;
#line 411 "../openssl.h"
typedef struct ssl_conf_ctx_st SSL_CONF_CTX;
#line 173 "openssl_leak_2.c"
enum OPTION_choice {
    OPT_ERR = -1,
    OPT_EOF = 0,
    OPT_HELP = 1,
    OPT_4 = 2,
    OPT_6 = 3,
    OPT_HOST = 4,
    OPT_PORT = 5,
    OPT_CONNECT = 6,
    OPT_UNIX = 7,
    OPT_XMPPHOST = 8,
    OPT_VERIFY = 9,
    OPT_NAMEOPT = 10,
    OPT_CERT = 11,
    OPT_CRL = 12,
    OPT_CRL_DOWNLOAD = 13,
    OPT_SESS_OUT = 14,
    OPT_SESS_IN = 15,
    OPT_CERTFORM = 16,
    OPT_CRLFORM = 17,
    OPT_VERIFY_RET_ERROR = 18,
    OPT_VERIFY_QUIET = 19,
    OPT_BRIEF = 20,
    OPT_PREXIT = 21,
    OPT_CRLF = 22,
    OPT_QUIET = 23,
    OPT_NBIO = 24,
    OPT_SSL_CLIENT_ENGINE = 25,
    OPT_IGN_EOF = 26,
    OPT_NO_IGN_EOF = 27,
    OPT_DEBUG = 28,
    OPT_TLSEXTDEBUG = 29,
    OPT_STATUS = 30,
    OPT_WDEBUG = 31,
    OPT_MSG = 32,
    OPT_MSGFILE = 33,
    OPT_ENGINE = 34,
    OPT_TRACE = 35,
    OPT_SECURITY_DEBUG = 36,
    OPT_SECURITY_DEBUG_VERBOSE = 37,
    OPT_SHOWCERTS = 38,
    OPT_NBIO_TEST = 39,
    OPT_STATE = 40,
    OPT_PSK_IDENTITY = 41,
    OPT_PSK = 42,
    OPT_PSK_SESS = 43,
    OPT_SRPUSER = 44,
    OPT_SRPPASS = 45,
    OPT_SRP_STRENGTH = 46,
    OPT_SRP_LATEUSER = 47,
    OPT_SRP_MOREGROUPS = 48,
    OPT_SSL3 = 49,
    OPT_SSL_CONFIG = 50,
    OPT_TLS1_3 = 51,
    OPT_TLS1_2 = 52,
    OPT_TLS1_1 = 53,
    OPT_TLS1 = 54,
    OPT_DTLS = 55,
    OPT_DTLS1 = 56,
    OPT_DTLS1_2 = 57,
    OPT_SCTP = 58,
    OPT_TIMEOUT = 59,
    OPT_MTU = 60,
    OPT_KEYFORM = 61,
    OPT_PASS = 62,
    OPT_CERT_CHAIN = 63,
    OPT_CAPATH = 64,
    OPT_NOCAPATH = 65,
    OPT_CHAINCAPATH = 66,
    OPT_VERIFYCAPATH = 67,
    OPT_KEY = 68,
    OPT_RECONNECT = 69,
    OPT_BUILD_CHAIN = 70,
    OPT_CAFILE = 71,
    OPT_NOCAFILE = 72,
    OPT_CHAINCAFILE = 73,
    OPT_VERIFYCAFILE = 74,
    OPT_NEXTPROTONEG = 75,
    OPT_ALPN = 76,
    OPT_SERVERINFO = 77,
    OPT_STARTTLS = 78,
    OPT_SERVERNAME = 79,
    OPT_NOSERVERNAME = 80,
    OPT_ASYNC = 81,
    OPT_USE_SRTP = 82,
    OPT_KEYMATEXPORT = 83,
    OPT_KEYMATEXPORTLEN = 84,
    OPT_PROTOHOST = 85,
    OPT_MAXFRAGLEN = 86,
    OPT_MAX_SEND_FRAG = 87,
    OPT_SPLIT_SEND_FRAG = 88,
    OPT_MAX_PIPELINES = 89,
    OPT_READ_BUF = 90,
    OPT_KEYLOG_FILE = 91,
    OPT_EARLY_DATA = 92,
    OPT_REQCAFILE = 93,
    OPT_V__FIRST = 2000,
    OPT_V_POLICY = 2001,
    OPT_V_PURPOSE = 2002,
    OPT_V_VERIFY_NAME = 2003,
    OPT_V_VERIFY_DEPTH = 2004,
    OPT_V_ATTIME = 2005,
    OPT_V_VERIFY_HOSTNAME = 2006,
    OPT_V_VERIFY_EMAIL = 2007,
    OPT_V_VERIFY_IP = 2008,
    OPT_V_IGNORE_CRITICAL = 2009,
    OPT_V_ISSUER_CHECKS = 2010,
    OPT_V_CRL_CHECK = 2011,
    OPT_V_CRL_CHECK_ALL = 2012,
    OPT_V_POLICY_CHECK = 2013,
    OPT_V_EXPLICIT_POLICY = 2014,
    OPT_V_INHIBIT_ANY = 2015,
    OPT_V_INHIBIT_MAP = 2016,
    OPT_V_X509_STRICT = 2017,
    OPT_V_EXTENDED_CRL = 2018,
    OPT_V_USE_DELTAS = 2019,
    OPT_V_POLICY_PRINT = 2020,
    OPT_V_CHECK_SS_SIG = 2021,
    OPT_V_TRUSTED_FIRST = 2022,
    OPT_V_SUITEB_128_ONLY = 2023,
    OPT_V_SUITEB_128 = 2024,
    OPT_V_SUITEB_192 = 2025,
    OPT_V_PARTIAL_CHAIN = 2026,
    OPT_V_NO_ALT_CHAINS = 2027,
    OPT_V_NO_CHECK_TIME = 2028,
    OPT_V_VERIFY_AUTH_LEVEL = 2029,
    OPT_V_ALLOW_PROXY_CERTS = 2030,
    OPT_V__LAST = 2031,
    OPT_X__FIRST = 1000,
    OPT_X_KEY = 1001,
    OPT_X_CERT = 1002,
    OPT_X_CHAIN = 1003,
    OPT_X_CHAIN_BUILD = 1004,
    OPT_X_CERTFORM = 1005,
    OPT_X_KEYFORM = 1006,
    OPT_X__LAST = 1007,
    OPT_S__FIRST = 3000,
    OPT_S_NOSSL3 = 3001,
    OPT_S_NOTLS1 = 3002,
    OPT_S_NOTLS1_1 = 3003,
    OPT_S_NOTLS1_2 = 3004,
    OPT_S_NOTLS1_3 = 3005,
    OPT_S_BUGS = 3006,
    OPT_S_NO_COMP = 3007,
    OPT_S_NOTICKET = 3008,
    OPT_S_SERVERPREF = 3009,
    OPT_S_LEGACYRENEG = 3010,
    OPT_S_LEGACYCONN = 3011,
    OPT_S_ONRESUMP = 3012,
    OPT_S_NOLEGACYCONN = 3013,
    OPT_S_ALLOW_NO_DHE_KEX = 3014,
    OPT_S_STRICT = 3015,
    OPT_S_SIGALGS = 3016,
    OPT_S_CLIENTSIGALGS = 3017,
    OPT_S_GROUPS = 3018,
    OPT_S_CURVES = 3019,
    OPT_S_NAMEDCURVE = 3020,
    OPT_S_CIPHER = 3021,
    OPT_S_RECORD_PADDING = 3022,
    OPT_S_DEBUGBROKE = 3023,
    OPT_S_COMP = 3024,
    OPT_S_NO_RENEGOTIATION = 3025,
    OPT_S__LAST = 3026,
    OPT_FALLBACKSCSV = 3027,
    OPT_NOCMDS = 3028,
    OPT_PROXY = 3029,
    OPT_DANE_TLSA_DOMAIN = 3030,
    OPT_CT = 3031,
    OPT_NOCT = 3032,
    OPT_CTLOG_FILE = 3033,
    OPT_DANE_TLSA_RRDATA = 3034,
    OPT_DANE_EE_NO_NAME = 3035,
    OPT_R__FIRST = 1500,
    OPT_R_RAND = 1501,
    OPT_R_WRITERAND = 1502,
    OPT_R__LAST = 1503
} ;
#line 173 "openssl_leak_2.c"
typedef enum OPTION_choice OPTION_CHOICE;
#line 320
enum __anonenum_connect_type_28 {
    use_inet = 0,
    use_unix = 1,
    use_unknown = 2
} ;
#line 323 "../apps.h"
extern char *opt_progname(char const   *argv0 ) ;
#line 326
extern int opt_next(void) ;
#line 230 "openssl_leak_2.c"
static char *prog  ;
#line 231 "openssl_leak_2.c"
static int c_debug  =    0;
#line 232 "openssl_leak_2.c"
static int c_showcerts  =    0;
#line 235 "openssl_leak_2.c"
static BIO *bio_c_out  =    (BIO *)((void *)0);
#line 236 "openssl_leak_2.c"
static int c_quiet  =    0;
#line 240 "openssl_leak_2.c"
BIO *bio_in  =    (BIO *)((void *)0);
#line 241 "openssl_leak_2.c"
BIO *bio_out  =    (BIO *)((void *)0);
#line 242 "openssl_leak_2.c"
BIO *bio_err  =    (BIO *)((void *)0);
#line 249
extern int ( /* missing proto */  OPENSSL_free)() ;
#line 252
extern int ( /* missing proto */  OPENSSL_strdup)() ;
#line 247 "openssl_leak_2.c"
static void freeandcopy(char **dest , char const   *source ) 
{ 
  int tmp ;

  {
#line 249
  OPENSSL_free(*dest);
#line 250
  *dest = (char *)((void *)0);
#line 251
  if ((unsigned long )source != (unsigned long )((void *)0)) {
#line 252
    tmp = OPENSSL_strdup(source);
#line 252
    *dest = (char *)tmp;
  }
#line 253
  return;
}
}
#line 344
extern int ( /* missing proto */  BIO_printf)() ;
#line 343
extern int ( /* missing proto */  IS_INET_FLAG)() ;
#line 349
extern int ( /* missing proto */  IS_UNIX_FLAG)() ;
#line 356
extern int ( /* missing proto */  IS_PROT_FLAG)() ;
#line 377
extern int ( /* missing proto */  opt_arg)() ;
#line 406
extern int ( /* missing proto */  opt_num_rest)() ;
#line 424
extern int ( /* missing proto */  BIO_new_file)() ;
#line 427
extern int ( /* missing proto */  ERR_print_errors)() ;
#line 430
extern int ( /* missing proto */  PEM_read_bio_SSL_SESSION)() ;
#line 431
extern int ( /* missing proto */  BIO_free)() ;
#line 437
extern int ( /* missing proto */  SSL_set_session)() ;
#line 444
extern int ( /* missing proto */  SSL_SESSION_get0_hostname)() ;
#line 461
extern int ( /* missing proto */  SSL_SESSION_free)() ;
#line 468
extern int ( /* missing proto */  SSL_set_tlsext_host_name)() ;
#line 478
extern int ( /* missing proto */  print_stuff)() ;
#line 479
extern int ( /* missing proto */  do_ssl_shutdown)() ;
#line 257 "openssl_leak_2.c"
int main(int argc , char **argv ) 
{ 
  SSL *con ;
  SSL_CONF_CTX *cctx ;
  char *dane_tlsa_domain ;
  int dane_ee_no_name ;
  char const   *CApath ;
  char const   *CAfile ;
  char *cbuf ;
  char *sbuf ;
  char *mbuf ;
  char *proxystr ;
  char *connectstr ;
  char *cert_file ;
  char *key_file ;
  char *chain_file ;
  char *chCApath ;
  char *chCAfile ;
  char *host ;
  char *port ;
  int tmp ;
  char *passarg ;
  char *pass ;
  char *vfyCApath ;
  char *vfyCAfile ;
  char *ReqCAfile ;
  char *sess_in ;
  char *crl_file ;
  char const   *protohost ;
  int noCApath ;
  int noCAfile ;
  int build_chain ;
  int cert_format ;
  int key_format ;
  int crlf ;
  int full_log ;
  int mbuf_len ;
  int prexit ;
  int sdebug ;
  int reconnect ;
  int verify ;
  int vpmtouched ;
  int ret ;
  int in_init ;
  int nbio_test ;
  int s ;
  int state ;
  int cmdletters ;
  int starttls_proto ;
  int crl_format ;
  int crl_download ;
  int at_eof ;
  int read_buf_len ;
  int fallback_scsv ;
  OPTION_CHOICE o ;
  int enable_timeouts ;
  long socket_mtu ;
  char *servername ;
  int noservername ;
  char const   *alpn_in ;
  char const   *ssl_config ;
  int serverinfo_count ;
  int start ;
  char const   *next_proto_neg_in ;
  char *srppass ;
  int srp_lateuser ;
  char *ctlog_file ;
  int ct_validation ;
  int min_version ;
  int max_version ;
  int prot_opt ;
  int no_prot_opt ;
  int async ;
  unsigned int max_send_fragment ;
  unsigned int split_send_fragment ;
  unsigned int max_pipelines ;
  enum __anonenum_connect_type_28 connect_type ;
  int count4or6 ;
  int maxfraglen ;
  int c_nbio ;
  int c_msg ;
  int c_ign_eof ;
  int c_brief ;
  int c_tlsextdebug ;
  int c_status_req ;
  char const   *keylog_file ;
  char const   *early_data_file ;
  int isdtls ;
  char *psksessf ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  SSL_SESSION *sess ;
  BIO *stmp ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char const   *sni ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;

  {
#line 259
  con = (SSL *)((void *)0);
#line 260
  cctx = (SSL_CONF_CTX *)((void *)0);
#line 261
  dane_tlsa_domain = (char *)((void *)0);
#line 262
  dane_ee_no_name = 0;
#line 263
  CApath = (char const   *)((void *)0);
#line 263
  CAfile = (char const   *)((void *)0);
#line 264
  cbuf = (char *)((void *)0);
#line 264
  sbuf = (char *)((void *)0);
#line 265
  mbuf = (char *)((void *)0);
#line 265
  proxystr = (char *)((void *)0);
#line 265
  connectstr = (char *)((void *)0);
#line 266
  cert_file = (char *)((void *)0);
#line 266
  key_file = (char *)((void *)0);
#line 266
  chain_file = (char *)((void *)0);
#line 267
  chCApath = (char *)((void *)0);
#line 267
  chCAfile = (char *)((void *)0);
#line 267
  host = (char *)((void *)0);
#line 268
  tmp = OPENSSL_strdup("4433");
#line 268
  port = (char *)tmp;
#line 269
  passarg = (char *)((void *)0);
#line 269
  pass = (char *)((void *)0);
#line 269
  vfyCApath = (char *)((void *)0);
#line 269
  vfyCAfile = (char *)((void *)0);
#line 270
  ReqCAfile = (char *)((void *)0);
#line 271
  sess_in = (char *)((void *)0);
#line 271
  crl_file = (char *)((void *)0);
#line 272
  protohost = (char const   *)((void *)0);
#line 275
  noCApath = 0;
#line 275
  noCAfile = 0;
#line 276
  build_chain = 0;
#line 276
  cert_format = 32773;
#line 277
  key_format = 32773;
#line 277
  crlf = 0;
#line 277
  full_log = 1;
#line 277
  mbuf_len = 0;
#line 278
  prexit = 0;
#line 279
  sdebug = 0;
#line 280
  reconnect = 0;
#line 280
  verify = 0;
#line 280
  vpmtouched = 0;
#line 281
  ret = 1;
#line 281
  in_init = 1;
#line 281
  nbio_test = 0;
#line 281
  s = -1;
#line 281
  state = 0;
#line 282
  cmdletters = 1;
#line 283
  starttls_proto = 0;
#line 283
  crl_format = 32773;
#line 283
  crl_download = 0;
#line 286
  at_eof = 0;
#line 288
  read_buf_len = 0;
#line 289
  fallback_scsv = 0;
#line 292
  enable_timeouts = 0;
#line 293
  socket_mtu = 0L;
#line 298
  servername = (char *)((void *)0);
#line 299
  noservername = 0;
#line 300
  alpn_in = (char const   *)((void *)0);
#line 301
  ssl_config = (char const   *)((void *)0);
#line 304
  serverinfo_count = 0;
#line 304
  start = 0;
#line 306
  next_proto_neg_in = (char const   *)((void *)0);
#line 309
  srppass = (char *)((void *)0);
#line 310
  srp_lateuser = 0;
#line 313
  ctlog_file = (char *)((void *)0);
#line 314
  ct_validation = 0;
#line 316
  min_version = 0;
#line 316
  max_version = 0;
#line 316
  prot_opt = 0;
#line 316
  no_prot_opt = 0;
#line 317
  async = 0;
#line 318
  max_send_fragment = 0U;
#line 319
  split_send_fragment = 0U;
#line 319
  max_pipelines = 0U;
#line 320
  connect_type = (enum __anonenum_connect_type_28 )2;
#line 321
  count4or6 = 0;
#line 322
  maxfraglen = 0;
#line 323
  c_nbio = 0;
#line 323
  c_msg = 0;
#line 323
  c_ign_eof = 0;
#line 323
  c_brief = 0;
#line 324
  c_tlsextdebug = 0;
#line 326
  c_status_req = 0;
#line 328
  keylog_file = (char const   *)((void *)0);
#line 328
  early_data_file = (char const   *)((void *)0);
#line 330
  isdtls = 0;
#line 332
  psksessf = (char *)((void *)0);
#line 334
  prog = opt_progname((char const   *)*(argv + 0));
#line 335
  c_quiet = 0;
#line 336
  c_debug = 0;
#line 337
  c_showcerts = 0;
#line 338
  c_nbio = 0;
#line 341
  while (1) {
#line 341
    tmp___5 = opt_next();
#line 341
    o = (OPTION_CHOICE )tmp___5;
#line 341
    if (! ((int )o != 0)) {
#line 341
      break;
    }
#line 343
    if ((unsigned int )connect_type == 1U) {
#line 343
      tmp___0 = IS_INET_FLAG((int )o);
#line 343
      if (tmp___0) {
#line 344
        BIO_printf(bio_err, "%s: Intermixed protocol flags (unix and internet domains)\n",
                   prog);
#line 347
        goto end;
      }
    }
#line 349
    if ((unsigned int )connect_type == 0U) {
#line 349
      tmp___1 = IS_UNIX_FLAG((int )o);
#line 349
      if (tmp___1) {
#line 350
        BIO_printf(bio_err, "%s: Intermixed protocol flags (internet and unix domains)\n",
                   prog);
#line 353
        goto end;
      }
    }
#line 356
    tmp___2 = IS_PROT_FLAG((int )o);
#line 356
    if (tmp___2) {
#line 356
      prot_opt ++;
#line 356
      if (prot_opt > 1) {
#line 357
        BIO_printf(bio_err, "Cannot supply multiple protocol flags\n");
#line 358
        goto end;
      }
    }
#line 360
    if ((int )o == 3001) {
#line 361
      no_prot_opt ++;
    } else
#line 360
    if ((int )o == 3002) {
#line 361
      no_prot_opt ++;
    } else
#line 360
    if ((int )o == 3003) {
#line 361
      no_prot_opt ++;
    } else
#line 360
    if ((int )o == 3004) {
#line 361
      no_prot_opt ++;
    } else
#line 360
    if ((int )o == 3005) {
#line 361
      no_prot_opt ++;
    }
#line 362
    if (prot_opt == 1) {
#line 362
      if (no_prot_opt) {
#line 363
        BIO_printf(bio_err, "Cannot supply both a protocol flag and \'-no_<prot>\'\n");
#line 365
        goto end;
      }
    }
#line 368
    switch ((int )o) {
    opthelp: 
    case -1: 
    case 0: 
#line 372
    BIO_printf(bio_err, "%s: Use -help for summary.\n", prog);
#line 373
    goto end;
    case 4: 
#line 376
    connect_type = (enum __anonenum_connect_type_28 )0;
#line 377
    tmp___3 = opt_arg();
#line 377
    freeandcopy(& host, (char const   *)tmp___3);
#line 378
    break;
    case 79: 
#line 381
    tmp___4 = opt_arg();
#line 381
    servername = (char *)tmp___4;
#line 382
    break;
    case 80: 
#line 384
    noservername = 1;
#line 385
    break;
    }
  }
#line 388
  if (count4or6 >= 2) {
#line 389
    BIO_printf(bio_err, "%s: Can\'t use both -4 and -6\n", prog);
#line 390
    goto opthelp;
  }
#line 392
  if (noservername) {
#line 393
    if ((unsigned long )servername != (unsigned long )((void *)0)) {
#line 394
      BIO_printf(bio_err, "%s: Can\'t use -servername and -noservername together\n",
                 prog);
#line 397
      goto opthelp;
    }
#line 399
    if ((unsigned long )dane_tlsa_domain != (unsigned long )((void *)0)) {
#line 400
      BIO_printf(bio_err, "%s: Can\'t use -dane_tlsa_domain and -noservername together\n",
                 prog);
#line 403
      goto opthelp;
    }
  }
#line 406
  argc = opt_num_rest();
#line 407
  if (argc == 1) {
#line 412
    if ((unsigned long )connectstr != (unsigned long )((void *)0)) {
#line 413
      BIO_printf(bio_err, "%s: must not provide both -connect option and target parameter\n",
                 prog);
#line 416
      goto opthelp;
    }
#line 418
    connect_type = (enum __anonenum_connect_type_28 )0;
  } else
#line 419
  if (argc != 0) {
#line 420
    goto opthelp;
  }
#line 422
  if ((unsigned long )sess_in != (unsigned long )((void *)0)) {
#line 424
    tmp___6 = BIO_new_file(sess_in, "r");
#line 424
    stmp = (BIO *)tmp___6;
#line 425
    if ((unsigned long )stmp == (unsigned long )((void *)0)) {
#line 426
      BIO_printf(bio_err, "Can\'t open session file %s\n", sess_in);
#line 427
      ERR_print_errors(bio_err);
#line 428
      goto end;
    }
#line 430
    tmp___7 = PEM_read_bio_SSL_SESSION(stmp, (void *)0, 0, (void *)0);
#line 430
    sess = (SSL_SESSION *)tmp___7;
#line 431
    BIO_free(stmp);
#line 432
    if ((unsigned long )sess == (unsigned long )((void *)0)) {
#line 433
      BIO_printf(bio_err, "Can\'t open session file %s\n", sess_in);
#line 434
      ERR_print_errors(bio_err);
#line 435
      goto end;
    }
#line 437
    tmp___8 = SSL_set_session(con, sess);
#line 437
    if (! tmp___8) {
#line 438
      BIO_printf(bio_err, "Can\'t set session\n");
#line 439
      ERR_print_errors(bio_err);
#line 440
      goto end;
    }
#line 443
    if (! noservername) {
#line 443
      if ((unsigned long )servername == (unsigned long )((void *)0)) {
#line 444
        tmp___9 = SSL_SESSION_get0_hostname(sess);
#line 444
        sni = (char const   *)tmp___9;
#line 446
        if ((unsigned long )sni != (unsigned long )((void *)0)) {
#line 447
          tmp___10 = OPENSSL_strdup(sni);
#line 447
          servername = (char *)tmp___10;
#line 448
          if ((unsigned long )servername == (unsigned long )((void *)0)) {
#line 449
            BIO_printf(bio_err, "Can\'t set server name\n");
#line 450
            ERR_print_errors(bio_err);
#line 451
            goto end;
          }
        } else {
#line 458
          noservername = 1;
        }
      }
    }
#line 461
    SSL_SESSION_free(sess);
  }
#line 465
  if (! noservername) {
#line 465
    if ((unsigned long )servername != (unsigned long )((void *)0)) {
#line 465
      goto _L;
    } else
#line 465
    if ((unsigned long )dane_tlsa_domain == (unsigned long )((void *)0)) {
      _L: /* CIL Label */ 
#line 466
      if ((unsigned long )servername == (unsigned long )((void *)0)) {
#line 467
        if ((unsigned long )host == (unsigned long )((void *)0)) {
#line 467
          servername = (char *)"localhost";
        } else {
#line 467
          servername = host;
        }
      }
#line 468
      tmp___11 = SSL_set_tlsext_host_name(con, servername);
#line 468
      if (! tmp___11) {
#line 469
        BIO_printf(bio_err, "Unable to set TLS servername extension.\n");
#line 470
        ERR_print_errors(bio_err);
#line 471
        goto end;
      }
    }
  }
#line 475
  ret = 0;
#line 477
  if (in_init) {
#line 478
    print_stuff(bio_c_out, con, full_log);
  }
#line 479
  do_ssl_shutdown(con);
  end: 
#line 481
  if ((unsigned long )con != (unsigned long )((void *)0)) {
#line 482
    if (prexit != 0) {
#line 483
      print_stuff(bio_c_out, con, 1);
    }
  }
#line 485
  OPENSSL_free(host);
#line 486
  return (ret);
}
}
