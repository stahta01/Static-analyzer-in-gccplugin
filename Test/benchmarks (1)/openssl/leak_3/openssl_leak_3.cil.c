/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

#line 216 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h"
typedef unsigned long size_t;
#line 274 "../openssl.h"
struct ASN1_TEMPLATE_st;
#line 274 "../openssl.h"
typedef struct ASN1_TEMPLATE_st ASN1_TEMPLATE;
#line 275
struct ASN1_TLC_st;
#line 275 "../openssl.h"
typedef struct ASN1_TLC_st ASN1_TLC;
#line 276
struct ASN1_VALUE_st;
#line 276 "../openssl.h"
typedef struct ASN1_VALUE_st ASN1_VALUE;
#line 278
struct asn1_string_st;
#line 278 "../openssl.h"
typedef struct asn1_string_st ASN1_INTEGER;
#line 279 "../openssl.h"
typedef struct asn1_string_st ASN1_ENUMERATED;
#line 280 "../openssl.h"
typedef struct asn1_string_st ASN1_BIT_STRING;
#line 281 "../openssl.h"
typedef struct asn1_string_st ASN1_OCTET_STRING;
#line 282 "../openssl.h"
typedef struct asn1_string_st ASN1_PRINTABLESTRING;
#line 283 "../openssl.h"
typedef struct asn1_string_st ASN1_T61STRING;
#line 284 "../openssl.h"
typedef struct asn1_string_st ASN1_IA5STRING;
#line 285 "../openssl.h"
typedef struct asn1_string_st ASN1_GENERALSTRING;
#line 286 "../openssl.h"
typedef struct asn1_string_st ASN1_UNIVERSALSTRING;
#line 287 "../openssl.h"
typedef struct asn1_string_st ASN1_BMPSTRING;
#line 288 "../openssl.h"
typedef struct asn1_string_st ASN1_UTCTIME;
#line 290 "../openssl.h"
typedef struct asn1_string_st ASN1_GENERALIZEDTIME;
#line 291 "../openssl.h"
typedef struct asn1_string_st ASN1_VISIBLESTRING;
#line 292 "../openssl.h"
typedef struct asn1_string_st ASN1_UTF8STRING;
#line 293 "../openssl.h"
typedef struct asn1_string_st ASN1_STRING;
#line 294 "../openssl.h"
typedef int ASN1_BOOLEAN;
#line 297
struct asn1_object_st;
#line 297 "../openssl.h"
typedef struct asn1_object_st ASN1_OBJECT;
#line 299
struct ASN1_ITEM_st;
#line 299 "../openssl.h"
typedef struct ASN1_ITEM_st ASN1_ITEM;
#line 300
struct asn1_pctx_st;
#line 300 "../openssl.h"
typedef struct asn1_pctx_st ASN1_PCTX;
#line 303
struct bio_st;
#line 303 "../openssl.h"
typedef struct bio_st BIO;
#line 419 "../openssl.h"
typedef ASN1_ITEM const   *ASN1_ITEM_EXP(void);
#line 423 "../openssl.h"
struct asn1_string_st {
   int length ;
   int type ;
   unsigned char *data ;
   long flags ;
};
#line 444 "../openssl.h"
struct ASN1_ITEM_st {
   char itype ;
   long utype ;
   ASN1_TEMPLATE const   *templates ;
   long tcount ;
   void const   *funcs ;
   long size ;
   char const   *sname ;
};
#line 456 "../openssl.h"
struct ASN1_TEMPLATE_st {
   unsigned long flags ;
   long tag ;
   unsigned long offset ;
   char const   *field_name ;
   ASN1_ITEM_EXP *item ;
};
#line 464 "../openssl.h"
struct asn1_object_st {
   char const   *sn ;
   char const   *ln ;
   int nid ;
   int length ;
   unsigned char const   *data ;
   int flags ;
};
#line 472 "../openssl.h"
union __anonunion_value_25 {
   char *ptr ;
   ASN1_BOOLEAN boolean ;
   ASN1_STRING *asn1_string ;
   ASN1_OBJECT *object ;
   ASN1_INTEGER *integer ;
   ASN1_ENUMERATED *enumerated ;
   ASN1_BIT_STRING *bit_string ;
   ASN1_OCTET_STRING *octet_string ;
   ASN1_PRINTABLESTRING *printablestring ;
   ASN1_T61STRING *t61string ;
   ASN1_IA5STRING *ia5string ;
   ASN1_GENERALSTRING *generalstring ;
   ASN1_BMPSTRING *bmpstring ;
   ASN1_UNIVERSALSTRING *universalstring ;
   ASN1_UTCTIME *utctime ;
   ASN1_GENERALIZEDTIME *generalizedtime ;
   ASN1_VISIBLESTRING *visiblestring ;
   ASN1_UTF8STRING *utf8string ;
   ASN1_STRING *set ;
   ASN1_STRING *sequence ;
   ASN1_VALUE *asn1_value ;
};
#line 472 "../openssl.h"
struct asn1_type_st {
   int type ;
   union __anonunion_value_25 value ;
};
#line 472 "../openssl.h"
typedef struct asn1_type_st ASN1_TYPE;
#line 524 "../openssl.h"
struct otherName_st {
   ASN1_OBJECT *type_id ;
   ASN1_TYPE *value ;
};
#line 524 "../openssl.h"
typedef struct otherName_st OTHERNAME;
#line 529 "../openssl.h"
struct EDIPartyName_st {
   ASN1_STRING *nameAssigner ;
   ASN1_STRING *partyName ;
};
#line 529 "../openssl.h"
typedef struct EDIPartyName_st EDIPARTYNAME;
#line 534 "../openssl.h"
union __anonunion_d_26 {
   char *ptr ;
   OTHERNAME *otherName ;
   ASN1_IA5STRING *rfc822Name ;
   ASN1_IA5STRING *dNSName ;
   ASN1_TYPE *x400Address ;
   void *directoryName ;
   EDIPARTYNAME *ediPartyName ;
   ASN1_IA5STRING *uniformResourceIdentifier ;
   ASN1_OCTET_STRING *iPAddress ;
   ASN1_OBJECT *registeredID ;
   ASN1_OCTET_STRING *ip ;
   void *dirn ;
   ASN1_IA5STRING *ia5 ;
   ASN1_OBJECT *rid ;
   ASN1_TYPE *other ;
};
#line 534 "../openssl.h"
struct GENERAL_NAME_st {
   int type ;
   union __anonunion_d_26 d ;
};
#line 534 "../openssl.h"
typedef struct GENERAL_NAME_st GENERAL_NAME;
#line 562 "../openssl.h"
struct ASN1_TLC_st {
   char valid ;
   int ret ;
   long plen ;
   int ptag ;
   int pclass ;
   int hdrlen ;
};
#line 572 "../openssl.h"
typedef int ASN1_ex_d2i(ASN1_VALUE **pval , unsigned char const   **in , long len ,
                        ASN1_ITEM const   *it , int tag , int aclass , char opt ,
                        ASN1_TLC *ctx );
#line 576 "../openssl.h"
typedef int ASN1_ex_i2d(ASN1_VALUE **pval , unsigned char **out , ASN1_ITEM const   *it ,
                        int tag , int aclass );
#line 578 "../openssl.h"
typedef int ASN1_ex_new_func(ASN1_VALUE **pval , ASN1_ITEM const   *it );
#line 579 "../openssl.h"
typedef void ASN1_ex_free_func(ASN1_VALUE **pval , ASN1_ITEM const   *it );
#line 581 "../openssl.h"
typedef int ASN1_ex_print_func(BIO *out , ASN1_VALUE **pval , int indent , char const   *fname ,
                               ASN1_PCTX const   *pctx );
#line 585 "../openssl.h"
typedef int ASN1_primitive_i2c(ASN1_VALUE **pval , unsigned char *cont , int *putype ,
                               ASN1_ITEM const   *it );
#line 587 "../openssl.h"
typedef int ASN1_primitive_c2i(ASN1_VALUE **pval , unsigned char const   *cont , int len ,
                               int utype , char *free_cont , ASN1_ITEM const   *it );
#line 590 "../openssl.h"
typedef int ASN1_primitive_print(BIO *out , ASN1_VALUE **pval , ASN1_ITEM const   *it ,
                                 int indent , ASN1_PCTX const   *pctx );
#line 594 "../openssl.h"
struct ASN1_EXTERN_FUNCS_st {
   void *app_data ;
   ASN1_ex_new_func *asn1_ex_new ;
   ASN1_ex_free_func *asn1_ex_free ;
   ASN1_ex_free_func *asn1_ex_clear ;
   ASN1_ex_d2i *asn1_ex_d2i ;
   ASN1_ex_i2d *asn1_ex_i2d ;
   ASN1_ex_print_func *asn1_ex_print ;
};
#line 594 "../openssl.h"
typedef struct ASN1_EXTERN_FUNCS_st ASN1_EXTERN_FUNCS;
#line 604 "../openssl.h"
struct ASN1_PRIMITIVE_FUNCS_st {
   void *app_data ;
   unsigned long flags ;
   ASN1_ex_new_func *prim_new ;
   ASN1_ex_free_func *prim_free ;
   ASN1_ex_free_func *prim_clear ;
   ASN1_primitive_c2i *prim_c2i ;
   ASN1_primitive_i2c *prim_i2c ;
   ASN1_primitive_print *prim_print ;
};
#line 604 "../openssl.h"
typedef struct ASN1_PRIMITIVE_FUNCS_st ASN1_PRIMITIVE_FUNCS;
#line 615 "../openssl.h"
typedef int ASN1_aux_cb(int operation , ASN1_VALUE **in , ASN1_ITEM const   *it ,
                        void *exarg );
#line 618 "../openssl.h"
struct ASN1_AUX_st {
   void *app_data ;
   int flags ;
   int ref_offset ;
   int ref_lock ;
   ASN1_aux_cb *asn1_cb ;
   int enc_offset ;
};
#line 618 "../openssl.h"
typedef struct ASN1_AUX_st ASN1_AUX;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 185 "openssl_leak_3.c"
extern int ( /* missing proto */  ASN1_STRING_type_new)() ;
#line 157 "openssl_leak_3.c"
static int asn1_primitive_new(ASN1_VALUE **pval , ASN1_ITEM const   *it , int embed ) 
{ 
  ASN1_STRING *str ;
  int utype ;
  ASN1_PRIMITIVE_FUNCS const   *pf ;
  int tmp ;
  int tmp___0 ;

  {
#line 164
  if (! it) {
#line 165
    return (0);
  }
#line 167
  if (it->funcs) {
#line 168
    pf = (ASN1_PRIMITIVE_FUNCS const   *)it->funcs;
#line 169
    if (embed) {
#line 170
      if (pf->prim_clear) {
#line 171
        (*(pf->prim_clear))(pval, it);
#line 172
        return (1);
      }
    } else
#line 174
    if (pf->prim_new) {
#line 175
      tmp = (*(pf->prim_new))(pval, it);
#line 175
      return (tmp);
    }
  }
#line 179
  if ((int const   )it->itype == 5) {
#line 180
    utype = -1;
  } else {
#line 182
    utype = (int )it->utype;
  }
#line 183
  switch (utype) {
  default: 
#line 185
  tmp___0 = ASN1_STRING_type_new(utype);
#line 185
  str = (ASN1_STRING *)tmp___0;
#line 186
  *pval = (ASN1_VALUE *)str;
#line 187
  if ((int const   )it->itype == 5) {
#line 187
    if (str) {
#line 188
      str->flags |= 64L;
    }
  }
#line 189
  break;
  }
#line 191
  if (*pval) {
#line 192
    return (1);
  }
#line 193
  return (0);
}
}
#line 199
int ASN1_item_ex_new(ASN1_VALUE **pval , ASN1_ITEM const   *it ) ;
#line 196 "openssl_leak_3.c"
ASN1_VALUE *ASN1_item_new(ASN1_ITEM const   *it ) 
{ 
  ASN1_VALUE *ret ;
  int tmp ;

  {
#line 198
  ret = (ASN1_VALUE *)((void *)0);
#line 199
  tmp = ASN1_item_ex_new(& ret, it);
#line 199
  if (tmp > 0) {
#line 200
    return (ret);
  }
#line 201
  return ((ASN1_VALUE *)((void *)0));
}
}
#line 208
int asn1_item_embed_new(ASN1_VALUE **pval , ASN1_ITEM const   *it , int embed ) ;
#line 206 "openssl_leak_3.c"
int ASN1_item_ex_new(ASN1_VALUE **pval , ASN1_ITEM const   *it ) 
{ 
  int tmp ;

  {
#line 208
  tmp = asn1_item_embed_new(pval, it, 0);
#line 208
  return (tmp);
}
}
#line 228
static int asn1_template_new(ASN1_VALUE **pval , ASN1_TEMPLATE const   *tt ) ;
#line 245
extern int ( /* missing proto */  memset)() ;
#line 247
extern int ( /* missing proto */  OPENSSL_zalloc)() ;
#line 252
extern int ( /* missing proto */  asn1_get_field_ptr)() ;
#line 264
extern int ( /* missing proto */  ASN1_item_ex_free)() ;
#line 211 "openssl_leak_3.c"
int asn1_item_embed_new(ASN1_VALUE **pval , ASN1_ITEM const   *it , int embed ) 
{ 
  ASN1_TEMPLATE const   *tt ;
  ASN1_AUX const   *aux ;
  ASN1_aux_cb *asn1_cb ;
  ASN1_VALUE **pseqval ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 213
  tt = (ASN1_TEMPLATE const   *)((void *)0);
#line 215
  aux = (ASN1_AUX const   *)it->funcs;
#line 219
  if (aux) {
#line 219
    if (aux->asn1_cb) {
#line 220
      asn1_cb = (ASN1_aux_cb *)aux->asn1_cb;
    } else {
#line 222
      asn1_cb = (ASN1_aux_cb *)0;
    }
  } else {
#line 222
    asn1_cb = (ASN1_aux_cb *)0;
  }
#line 224
  switch ((int const   )it->itype) {
  case 0: 
#line 227
  if (it->templates) {
#line 228
    tmp = asn1_template_new(pval, it->templates);
#line 228
    if (! tmp) {
#line 229
      goto memerr;
    }
  } else {
#line 230
    tmp___0 = asn1_primitive_new(pval, it, embed);
#line 230
    if (! tmp___0) {
#line 231
      goto memerr;
    }
  }
#line 232
  break;
  case 1: 
  case 6: 
#line 236
  if (asn1_cb) {
#line 237
    i = (*asn1_cb)(0, pval, it, (void *)0);
#line 238
    if (! i) {
#line 239
      goto auxerr;
    }
#line 240
    if (i == 2) {
#line 241
      return (1);
    }
  }
#line 244
  if (embed) {
#line 245
    memset(*pval, 0, it->size);
  } else {
#line 247
    tmp___1 = OPENSSL_zalloc(it->size);
#line 247
    *pval = (ASN1_VALUE *)tmp___1;
#line 248
    if ((unsigned long )*pval == (unsigned long )((void *)0)) {
#line 249
      goto memerr;
    }
  }
#line 251
  i = 0;
#line 251
  tt = (ASN1_TEMPLATE const   *)it->templates;
#line 251
  while ((long const   )i < it->tcount) {
#line 252
    tmp___2 = asn1_get_field_ptr(pval, tt);
#line 252
    pseqval = (ASN1_VALUE **)tmp___2;
#line 253
    tmp___3 = asn1_template_new(pseqval, tt);
#line 253
    if (! tmp___3) {
#line 254
      goto memerr2;
    }
#line 251
    tt ++;
#line 251
    i ++;
  }
#line 256
  if (asn1_cb) {
#line 256
    tmp___4 = (*asn1_cb)(1, pval, it, (void *)0);
#line 256
    if (! tmp___4) {
#line 257
      goto auxerr2;
    }
  }
#line 258
  break;
  }
#line 260
  return (1);
  memerr2: 
#line 263
  if (! embed) {
#line 264
    ASN1_item_ex_free(pval, it);
  }
  memerr: 
#line 266
  return (0);
  auxerr2: 
#line 269
  if (! embed) {
#line 270
    ASN1_item_ex_free(pval, it);
  }
  auxerr: 
#line 272
  return (0);
}
}
#line 292
static void asn1_template_clear(ASN1_VALUE **pval , ASN1_TEMPLATE const   *tt ) ;
#line 294
static void asn1_primitive_clear(ASN1_VALUE **pval , ASN1_ITEM const   *it ) ;
#line 276 "openssl_leak_3.c"
static void asn1_item_clear(ASN1_VALUE **pval , ASN1_ITEM const   *it ) 
{ 
  ASN1_EXTERN_FUNCS const   *ef ;

  {
#line 280
  switch ((int const   )it->itype) {
  case 4: 
#line 283
  ef = (ASN1_EXTERN_FUNCS const   *)it->funcs;
#line 284
  if (ef) {
#line 284
    if (ef->asn1_ex_clear) {
#line 285
      (*(ef->asn1_ex_clear))(pval, it);
    } else {
#line 287
      *pval = (ASN1_VALUE *)((void *)0);
    }
  } else {
#line 287
    *pval = (ASN1_VALUE *)((void *)0);
  }
#line 288
  break;
  case 0: 
#line 291
  if (it->templates) {
#line 292
    asn1_template_clear(pval, it->templates);
  } else {
#line 294
    asn1_primitive_clear(pval, it);
  }
#line 295
  break;
  case 5: 
#line 298
  asn1_primitive_clear(pval, it);
#line 299
  break;
  case 6: 
  case 1: 
  case 2: 
#line 304
  *pval = (ASN1_VALUE *)((void *)0);
#line 305
  break;
  }
#line 307
  return;
}
}
#line 311
extern int ( /* missing proto */  ASN1_ITEM_ptr)() ;
#line 330
extern int ( /* missing proto */  OPENSSL_mem_debug_push)() ;
#line 336
extern int ( /* missing proto */  sk_ASN1_VALUE_new_null)() ;
#line 349
extern int ( /* missing proto */  OPENSSL_mem_debug_pop)() ;
#line 309 "openssl_leak_3.c"
static int asn1_template_new(ASN1_VALUE **pval , ASN1_TEMPLATE const   *tt ) 
{ 
  ASN1_ITEM const   *it ;
  int tmp ;
  int embed ;
  ASN1_VALUE *tval ;
  int ret ;
  char const   *tmp___0 ;
  void *skval ;
  int tmp___1 ;

  {
#line 311
  tmp = ASN1_ITEM_ptr(tt->item);
#line 311
  it = (ASN1_ITEM const   *)tmp;
#line 312
  embed = (int )(tt->flags & (unsigned long const   )(1 << 12));
#line 315
  if (embed) {
#line 316
    tval = (ASN1_VALUE *)pval;
#line 317
    pval = & tval;
  }
#line 319
  if (tt->flags & 1UL) {
#line 320
    asn1_template_clear(pval, tt);
#line 321
    return (1);
  }
#line 325
  if (tt->flags & (unsigned long const   )(3 << 8)) {
#line 326
    *pval = (ASN1_VALUE *)((void *)0);
#line 327
    return (1);
  }
#line 330
  if (tt->field_name) {
#line 330
    tmp___0 = tt->field_name;
  } else {
#line 330
    tmp___0 = (char const   * const  )"asn1_template_new";
  }
#line 330
  OPENSSL_mem_debug_push(tmp___0);
#line 334
  if (tt->flags & (unsigned long const   )(3 << 1)) {
#line 336
    tmp___1 = sk_ASN1_VALUE_new_null();
#line 336
    skval = (void *)tmp___1;
#line 337
    if (! skval) {
#line 338
      ret = 0;
#line 339
      goto done;
    }
#line 341
    *pval = (ASN1_VALUE *)skval;
#line 342
    ret = 1;
#line 343
    goto done;
  }
#line 346
  ret = asn1_item_embed_new(pval, it, embed);
  done: 
#line 349
  OPENSSL_mem_debug_pop();
#line 351
  return (ret);
}
}
#line 354 "openssl_leak_3.c"
static void asn1_template_clear(ASN1_VALUE **pval , ASN1_TEMPLATE const   *tt ) 
{ 
  int tmp ;

  {
#line 357
  if (tt->flags & (unsigned long const   )((3 << 8) | (3 << 1))) {
#line 358
    *pval = (ASN1_VALUE *)((void *)0);
  } else {
#line 360
    tmp = ASN1_ITEM_ptr(tt->item);
#line 360
    asn1_item_clear(pval, (ASN1_ITEM const   *)tmp);
  }
#line 361
  return;
}
}
#line 363 "openssl_leak_3.c"
static void asn1_primitive_clear(ASN1_VALUE **pval , ASN1_ITEM const   *it ) 
{ 
  int utype ;
  ASN1_PRIMITIVE_FUNCS const   *pf ;

  {
#line 366
  if (it) {
#line 366
    if (it->funcs) {
#line 367
      pf = (ASN1_PRIMITIVE_FUNCS const   *)it->funcs;
#line 368
      if (pf->prim_clear) {
#line 369
        (*(pf->prim_clear))(pval, it);
      } else {
#line 371
        *pval = (ASN1_VALUE *)((void *)0);
      }
#line 372
      return;
    }
  }
#line 374
  if (! it) {
#line 375
    utype = -1;
  } else
#line 374
  if ((int const   )it->itype == 5) {
#line 375
    utype = -1;
  } else {
#line 377
    utype = (int )it->utype;
  }
#line 378
  if (utype == 1) {
#line 379
    *((ASN1_BOOLEAN *)pval) = (ASN1_BOOLEAN )it->size;
  } else {
#line 381
    *pval = (ASN1_VALUE *)((void *)0);
  }
#line 382
  return;
}
}
#line 384 "openssl_leak_3.c"
struct ASN1_ITEM_st  const  OTHERNAME_it  =    {(char)0, 0L, (ASN1_TEMPLATE const   *)((void *)0), 0L, (void const   *)((void *)0),
    0L, "OTHERNAME"};
#line 385 "openssl_leak_3.c"
OTHERNAME *OTHERNAME_new(void) 
{ 
  ASN1_VALUE *tmp ;

  {
#line 385
  tmp = ASN1_item_new(& OTHERNAME_it);
#line 385
  return ((OTHERNAME *)tmp);
}
}
#line 385
extern int ( /* missing proto */  ASN1_item_free)() ;
#line 385 "openssl_leak_3.c"
void OTHERNAME_free(OTHERNAME *a ) 
{ 


  {
#line 385
  ASN1_item_free((ASN1_VALUE *)a, & OTHERNAME_it);
#line 385
  return;
}
}
#line 387 "openssl_leak_3.c"
void GENERAL_NAME_set0_value(GENERAL_NAME *a , int type , void *value ) 
{ 


  {
#line 389
  switch (type) {
  case 5: 
  case 3: 
#line 392
  a->d.other = (ASN1_TYPE *)value;
#line 393
  break;
  case 0: 
#line 396
  a->d.otherName = (OTHERNAME *)value;
#line 397
  break;
  case 6: 
  case 2: 
  case 1: 
#line 402
  a->d.ia5 = (ASN1_IA5STRING *)value;
#line 403
  break;
  case 4: 
#line 406
  a->d.dirn = value;
#line 407
  break;
  case 7: 
#line 410
  a->d.ip = (ASN1_OCTET_STRING *)value;
#line 411
  break;
  case 8: 
#line 414
  a->d.rid = (ASN1_OBJECT *)value;
#line 415
  break;
  }
#line 417
  a->type = type;
#line 418
  return;
}
}
#line 421 "openssl_leak_3.c"
int GENERAL_NAME_set0_othername(GENERAL_NAME *gen , ASN1_OBJECT *oid , ASN1_TYPE *value ) 
{ 
  OTHERNAME *oth ;

  {
#line 425
  oth = OTHERNAME_new();
#line 426
  if ((unsigned long )oth == (unsigned long )((void *)0)) {
#line 427
    return (0);
  }
#line 428
  oth->type_id = oid;
#line 429
  oth->value = value;
#line 430
  GENERAL_NAME_set0_value(gen, 0, (void *)oth);
#line 431
  return (1);
}
}
#line 434 "openssl_leak_3.c"
int main(void) 
{ 
  ASN1_TYPE *value ;
  void *tmp ;

  {
#line 436
  tmp = malloc(sizeof(ASN1_TYPE ));
#line 436
  value = (ASN1_TYPE *)tmp;
#line 437
  GENERAL_NAME_set0_othername((GENERAL_NAME *)((void *)0), (ASN1_OBJECT *)((void *)0),
                              value);
#line 438
  free((void *)value);
#line 439
  return (0);
}
}
