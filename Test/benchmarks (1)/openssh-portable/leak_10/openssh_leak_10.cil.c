/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

#line 216 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 144 "/usr/include/libio.h"
struct _IO_FILE;
#line 150 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 156 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 241 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 203 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned long u_int64_t;
#line 196 "../stdio.h"
typedef unsigned int u_int___0;
#line 197 "../stdio.h"
typedef unsigned long u_long___0;
#line 200 "../stdio.h"
typedef int int32_t___0;
#line 207 "../stdio.h"
typedef unsigned char u_char___0;
#line 245 "../stdio.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   int pw_uid ;
   int pw_gid ;
   int pw_change ;
   char *pw_class ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
   int pw_expire ;
};
#line 364 "../openssh.h"
typedef u_int___0 BN_ULONG;
#line 365 "../openssh.h"
struct __anonstruct_Buffer_25 {
   u_char___0 *buf ;
   u_int___0 alloc ;
   u_int___0 offset ;
   u_int___0 end ;
};
#line 365 "../openssh.h"
typedef struct __anonstruct_Buffer_25 Buffer;
#line 372 "../openssh.h"
struct bignum_st {
   BN_ULONG *d ;
   int top ;
   int dmax ;
   int neg ;
   int flags ;
};
#line 390 "../openssh.h"
typedef struct bignum_st BIGNUM;
#line 391 "../openssh.h"
struct rsa_st {
   int pad ;
   int32_t___0 version ;
   void const   *meth ;
   void *engine ;
   BIGNUM *n ;
   BIGNUM *e ;
   BIGNUM *d ;
   BIGNUM *p ;
   BIGNUM *q ;
   BIGNUM *dmp1 ;
   BIGNUM *dmq1 ;
   BIGNUM *iqmp ;
   void *pss ;
   int ex_data ;
   int references ;
   int flags ;
   void *_method_mod_n ;
   void *_method_mod_p ;
   void *_method_mod_q ;
   char *bignum_data ;
   void *blinding ;
   void *mt_blinding ;
   void *lock ;
};
#line 391 "../openssh.h"
typedef struct rsa_st RSA;
#line 434 "../openssh.h"
struct dsa_st {
   int pad ;
   int32_t___0 version ;
   BIGNUM *p ;
   BIGNUM *q ;
   BIGNUM *g ;
   BIGNUM *pub_key ;
   BIGNUM *priv_key ;
   int flags ;
};
#line 434 "../openssh.h"
typedef struct dsa_st DSA;
#line 1298
struct Key;
#line 1298 "../openssh.h"
typedef struct Key Key;
#line 1310 "../openssh.h"
struct KeyCert {
   Buffer certblob ;
   u_int___0 type ;
   u_int64_t serial ;
   char *key_id ;
   u_int___0 nprincipals ;
   char **principals ;
   u_int64_t valid_after ;
   u_int64_t valid_before ;
   Buffer critical ;
   Buffer extensions ;
   Key *signature_key ;
};
#line 1323 "../openssh.h"
struct Key {
   int type ;
   int flags ;
   RSA *rsa ;
   DSA *dsa ;
   int ecdsa_nid ;
   void *ecdsa ;
   struct KeyCert *cert ;
   u_char___0 *ed25519_sk ;
   u_char___0 *ed25519_pk ;
};
#line 16 "openssh_leak_10.c"
typedef unsigned int uid_t___0;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 374 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rand)(void) ;
#line 376
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) srand)(unsigned int __seed ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 14 "openssh_leak_10.c"
int quiet  =    0;
#line 20
extern int ( /* missing proto */  strlen)() ;
#line 21
extern int ( /* missing proto */  strnlen)() ;
#line 24
extern int ( /* missing proto */  memcpy)() ;
#line 18 "openssh_leak_10.c"
size_t strlcat(char * __restrict  dst , char const   * __restrict  src , size_t maxlen ) 
{ 
  size_t srclen ;
  int tmp ;
  size_t dstlen ;
  int tmp___0 ;

  {
#line 20
  tmp = strlen(src);
#line 20
  srclen = (size_t )tmp;
#line 21
  tmp___0 = strnlen(dst, maxlen);
#line 21
  dstlen = (size_t )tmp___0;
#line 22
  if (dstlen == maxlen) {
#line 22
    return (maxlen + srclen);
  }
#line 23
  if (srclen < maxlen - dstlen) {
#line 24
    memcpy(dst + dstlen, src, srclen + 1UL);
  } else {
#line 26
    memcpy(dst + dstlen, src, maxlen - 1UL);
#line 27
    *(dst + ((dstlen + maxlen) - 1UL)) = (char )'\000';
  }
#line 29
  return (dstlen + srclen);
}
}
#line 45
extern int ( /* missing proto */  strdup)() ;
#line 48
extern int ( /* missing proto */  strchr)() ;
#line 36 "openssh_leak_10.c"
char *tilde_expand_filename(char const   *filename , uid_t___0 uid ) 
{ 
  char const   *path ;
  char user[128] ;
  char ret[64] ;
  u_int___0 slash ;
  int tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;

  {
#line 44
  if ((int const   )*filename != 126) {
#line 45
    tmp = strdup(filename);
#line 45
    return ((char *)tmp);
  }
#line 46
  filename ++;
#line 48
  tmp___0 = strchr(filename, '/');
#line 48
  path = (char const   *)tmp___0;
#line 49
  if ((unsigned long )path != (unsigned long )((void *)0)) {
#line 49
    if ((unsigned long )path > (unsigned long )filename) {
#line 50
      slash = (u_int___0 )(path - filename);
#line 51
      if ((unsigned long )slash > sizeof(user) - 1UL) {
#line 52
        printf((char const   * __restrict  )"tilde_expand_filename: ~username too long%s\n",
               "");
#line 52
        exit(1);
      }
#line 53
      memcpy(user, filename, slash);
#line 54
      user[slash] = (char )'\000';
    }
  }
#line 58
  if ((unsigned long )path != (unsigned long )((void *)0)) {
#line 59
    filename = path + 1;
  }
#line 60
  tmp___1 = strlcat((char * __restrict  )(ret), (char const   * __restrict  )filename,
                    sizeof(ret));
#line 60
  if (tmp___1 >= sizeof(ret)) {
#line 61
    printf((char const   * __restrict  )"tilde_expand_filename: Path too long%s\n",
           "");
#line 61
    exit(1);
  }
#line 63
  tmp___2 = strdup(ret);
#line 63
  return ((char *)tmp___2);
}
}
#line 66 "openssh_leak_10.c"
int read_keyfile_line(FILE *f , char const   *filename , char *buf , size_t bufsz ,
                      u_long___0 *lineno ) 
{ 
  int tmp___0 ;
  int tmp___1 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 70
  while (1) {
#line 70
    tmp___4 = rand();
#line 70
    if (tmp___4 % 2 == 1) {
#line 70
      tmp___3 = 1;
    } else {
#line 70
      tmp___3 = 0;
    }
#line 70
    if (! tmp___3) {
#line 70
      break;
    }
#line 71
    (*lineno) ++;
#line 72
    printf((char const   * __restrict  )"%s: %s line %lu exceeds size limit\n", "read_keyfile_line",
           filename, *lineno);
#line 74
    tmp___1 = rand();
#line 74
    if (tmp___1 % 2 == 1) {
#line 74
      tmp___0 = 1;
    } else {
#line 74
      tmp___0 = 0;
    }
#line 74
    if (tmp___0) {
#line 75
      return (0);
    }
  }
#line 77
  return (-1);
}
}
#line 92
extern int ( /* missing proto */  strcmp)() ;
#line 81 "openssh_leak_10.c"
static void update_krl_from_file(struct passwd *pw , char const   *file ) 
{ 
  Key *key ;
  u_long___0 lnum ;
  char *path ;
  char line[16384] ;
  FILE *krl_spec ;
  int tmp ;
  int tmp___0 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 84
  key = (Key *)((void *)0);
#line 85
  lnum = (u_long___0 )0;
#line 91
  path = tilde_expand_filename(file, (uid_t___0 )pw->pw_uid);
#line 92
  tmp___0 = strcmp(path, "-");
#line 92
  if (tmp___0 == 0) {
#line 93
    krl_spec = stdin;
#line 94
    free((void *)path);
#line 95
    tmp = strdup("(standard input)");
#line 95
    path = (char *)tmp;
  } else {
#line 96
    krl_spec = fopen((char const   * __restrict  )path, (char const   * __restrict  )"r");
#line 96
    if ((unsigned long )krl_spec == (unsigned long )((void *)0)) {
#line 97
      printf((char const   * __restrict  )"fopen %s: \n", path);
#line 97
      exit(1);
    }
  }
#line 99
  if (! quiet) {
#line 100
    printf((char const   * __restrict  )"Revoking from %s\n", path);
  }
#line 101
  while (1) {
#line 101
    tmp___4 = read_keyfile_line(krl_spec, (char const   *)path, line, sizeof(line),
                                & lnum);
#line 101
    if (! (tmp___4 == 0)) {
#line 101
      break;
    }
#line 103
    tmp___3 = rand();
#line 103
    if (tmp___3 % 2 == 1) {
#line 103
      tmp___2 = 1;
    } else {
#line 103
      tmp___2 = 0;
    }
#line 103
    if (tmp___2) {
#line 104
      printf((char const   * __restrict  )"%s: invalid\n", path);
#line 104
      exit(1);
    }
  }
#line 106
  tmp___5 = strcmp(path, "-");
#line 106
  if (tmp___5 != 0) {
#line 107
    fclose(krl_spec);
  }
#line 109
  return;
}
}
#line 115
extern int ( /* missing proto */  time)() ;
#line 111 "openssh_leak_10.c"
int main(int argc , char **argv ) 
{ 
  struct passwd pw ;
  int i ;
  int tmp ;

  {
#line 115
  tmp = time((void *)0);
#line 115
  srand((unsigned int )tmp);
#line 116
  i = 0;
#line 116
  while (i < argc) {
#line 117
    update_krl_from_file(& pw, (char const   *)*(argv + i));
#line 116
    i ++;
  }
#line 118
  return (0);
}
}
