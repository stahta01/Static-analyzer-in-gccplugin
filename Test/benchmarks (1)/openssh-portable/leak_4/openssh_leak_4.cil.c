/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

#line 216 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 144 "/usr/include/libio.h"
struct _IO_FILE;
#line 150 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 156 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 241 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 483 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 13 "openssh_leak_4.c"
char *host  ;
#line 14 "openssh_leak_4.c"
char *config_file_name  ;
#line 15 "openssh_leak_4.c"
int log_stderr_fd  ;
#line 19 "openssh_leak_4.c"
static void usage(void) 
{ 


  {
#line 22
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"usage: ssh [-1246AaCfGgKkMNnqsTtVvXxYy] [-b bind_address] [-c cipher_spec]\n           [-D [bind_address:]port] [-E log_file] [-e escape_char]\n           [-F configfile] [-I pkcs11] [-i identity_file]\n           [-L address] [-l login_name] [-m mac_spec]\n           [-O ctl_cmd] [-o option] [-p port]\n           [-Q cipher | cipher-auth | mac | kex | key]\n           [-R address] [-S ctl_path] [-W host:port]\n           [-w local_tun[:remote_tun]] [user@]hostname [command]\n");
#line 32
  exit(255);
}
}
#line 42
extern int ( /* missing proto */  strerror)() ;
#line 41
extern int ( /* missing proto */  open)() ;
#line 36 "openssh_leak_4.c"
void log_redirect_stderr_to(char const   *logfile ) 
{ 
  int fd ;
  int *tmp ;
  int tmp___0 ;

  {
#line 41
  fd = open(logfile, 4353, 384);
#line 41
  if (fd == -1) {
#line 42
    tmp = __errno_location();
#line 42
    tmp___0 = strerror(*tmp);
#line 42
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Couldn\'t open logfile %s: %s\n",
            logfile, tmp___0);
#line 44
    exit(1);
  }
#line 46
  log_stderr_fd = fd;
#line 47
  return;
}
}
#line 53
extern int optind ;
#line 54
extern char *optarg ;
#line 65
extern int ( /* missing proto */  strdup)() ;
#line 58
extern int ( /* missing proto */  getopt)() ;
#line 78
extern int ( /* missing proto */  strrchr)() ;
#line 49 "openssh_leak_4.c"
int main(int ac , char **av ) 
{ 
  int opt ;
  char *logfile ;
  char *p ;
  char *cp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 56
  logfile = (char *)((void *)0);
  again: 
#line 58
  while (1) {
#line 58
    opt = getopt(ac, av, "1246ab:c:e:fgi:kl:m:no:p:qstvxACD:E:F:GI:KL:MNO:PQ:R:S:TVw:W:XYy");
#line 58
    if (! (opt != -1)) {
#line 58
      break;
    }
#line 60
    switch (opt) {
    case 52: 
#line 62
    config_file_name = optarg;
#line 63
    break;
    case 69: 
#line 65
    tmp = strdup(optarg);
#line 65
    logfile = (char *)tmp;
#line 66
    break;
    default: 
#line 68
    break;
    }
  }
#line 72
  ac -= optind;
#line 73
  av += optind;
#line 75
  if (ac > 0) {
#line 75
    if (! host) {
#line 76
      tmp___4 = strrchr(*av, '@');
#line 76
      if (tmp___4) {
#line 77
        tmp___0 = strdup(*av);
#line 77
        p = (char *)tmp___0;
#line 78
        tmp___1 = strrchr(p, '@');
#line 78
        cp = (char *)tmp___1;
#line 79
        if ((unsigned long )cp == (unsigned long )((void *)0)) {
#line 80
          usage();
        } else
#line 79
        if ((unsigned long )cp == (unsigned long )p) {
#line 80
          usage();
        }
#line 81
        *cp = (char )'\000';
#line 82
        cp ++;
#line 82
        tmp___2 = strdup(cp);
#line 82
        host = (char *)tmp___2;
      } else {
#line 84
        tmp___3 = strdup(*av);
#line 84
        host = (char *)tmp___3;
      }
#line 85
      if (ac > 1) {
#line 86
        optind = 1;
#line 87
        goto again;
      }
#line 89
      ac --;
#line 89
      av ++;
    }
  }
#line 95
  if ((unsigned long )logfile != (unsigned long )((void *)0)) {
#line 96
    log_redirect_stderr_to((char const   *)logfile);
#line 97
    free((void *)logfile);
  }
#line 100
  return (0);
}
}
