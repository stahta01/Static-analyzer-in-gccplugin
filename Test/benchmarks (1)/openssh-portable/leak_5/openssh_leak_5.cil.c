/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

#line 216 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 144 "/usr/include/libio.h"
struct _IO_FILE;
#line 150 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 156 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 241 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 203 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned long u_int64_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 196 "../stdio.h"
typedef unsigned int u_int___0;
#line 203 "../stdio.h"
typedef unsigned int u_int32_t___0;
#line 207 "../stdio.h"
typedef unsigned char u_char___0;
#line 792 "../openssh.h"
enum __anonenum_LogLevel_27 {
    SYSLOG_LEVEL_QUIET = 0,
    SYSLOG_LEVEL_FATAL = 1,
    SYSLOG_LEVEL_ERROR = 2,
    SYSLOG_LEVEL_INFO = 3,
    SYSLOG_LEVEL_VERBOSE = 4,
    SYSLOG_LEVEL_DEBUG1 = 5,
    SYSLOG_LEVEL_DEBUG2 = 6,
    SYSLOG_LEVEL_DEBUG3 = 7,
    SYSLOG_LEVEL_NOT_SET = -1
} ;
#line 792 "../openssh.h"
typedef enum __anonenum_LogLevel_27 LogLevel;
#line 121 "openssh_leak_5.c"
struct bwlimit {
   size_t buflen ;
   u_int64_t rate ;
   u_int64_t thresh ;
   u_int64_t lamt ;
   struct timeval bwstart ;
   struct timeval bwend ;
};
#line 127 "openssh_leak_5.c"
struct sftp_conn {
   int fd_in ;
   int fd_out ;
   u_int___0 transfer_buflen ;
   u_int___0 num_requests ;
   u_int___0 version ;
   u_int___0 msg_id ;
   u_int___0 exts ;
   u_int64_t limit_kbps ;
   struct bwlimit bwlimit_in ;
   struct bwlimit bwlimit_out ;
};
#line 156
struct Attrib;
#line 156 "openssh_leak_5.c"
typedef struct Attrib Attrib;
#line 159 "openssh_leak_5.c"
struct Attrib {
   u_int32_t___0 flags ;
   u_int64_t size ;
   u_int32_t___0 uid ;
   u_int32_t___0 gid ;
   u_int32_t___0 perm ;
   u_int32_t___0 atime ;
   u_int32_t___0 mtime ;
};
#line 170 "openssh_leak_5.c"
typedef void EditLine;
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 468 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 179 "openssh_leak_5.c"
int batchmode  =    0;
#line 180 "openssh_leak_5.c"
FILE *infile  ;
#line 182 "openssh_leak_5.c"
int quiet  =    0;
#line 184 "openssh_leak_5.c"
struct sftp_conn *do_init(int fd_in , int fd_out , u_int___0 transfer_buflen , u_int___0 num_requests ,
                          u_int64_t limit_kbps ) 
{ 
  u_char___0 type ;
  struct sftp_conn *ret ;
  void *tmp ;

  {
#line 192
  tmp = calloc((size_t )1, sizeof(*ret));
#line 192
  ret = (struct sftp_conn *)tmp;
#line 193
  ret->msg_id = (u_int___0 )1;
#line 194
  ret->fd_in = fd_in;
#line 195
  ret->fd_out = fd_out;
#line 196
  ret->transfer_buflen = transfer_buflen;
#line 197
  ret->num_requests = num_requests;
#line 198
  ret->exts = (u_int___0 )0;
#line 199
  ret->limit_kbps = (u_int64_t )0;
#line 201
  if ((int )type != 2) {
#line 202
    printf((char const   * __restrict  )"Invalid packet back from SSH2_FXP_INIT (type %u)\n",
           (int )type);
#line 205
    return ((struct sftp_conn *)((void *)0));
  }
#line 208
  printf((char const   * __restrict  )"Remote version: %u", ret->version);
#line 211
  if (ret->version == 0U) {
#line 212
    if (ret->transfer_buflen < 20480U) {
#line 212
      ret->transfer_buflen = ret->transfer_buflen;
    } else {
#line 212
      ret->transfer_buflen = (u_int___0 )20480;
    }
  }
#line 214
  ret->limit_kbps = limit_kbps;
#line 216
  return (ret);
}
}
#line 235
extern int ( /* missing proto */  strdup)() ;
#line 219 "openssh_leak_5.c"
char *do_realpath(struct sftp_conn *conn , char const   *path ) 
{ 
  u_int___0 expected_id ;
  u_int___0 id ;
  u_char___0 type ;
  u_int___0 tmp ;
  int tmp___0 ;

  {
#line 228
  tmp = conn->msg_id;
#line 228
  (conn->msg_id) ++;
#line 228
  id = tmp;
#line 228
  expected_id = id;
#line 230
  if ((int )type == 101) {
#line 232
    return ((char *)((void *)0));
  }
#line 235
  tmp___0 = strdup(path);
#line 235
  return ((char *)tmp___0);
}
}
#line 277
extern int ( /* missing proto */  error)() ;
#line 240 "openssh_leak_5.c"
static int parse_dispatch_command(struct sftp_conn *conn , char const   *cmd , char **pwd ,
                                  int err_abort ) 
{ 
  char *path1 ;
  char *path2 ;
  char *tmp ;
  int ignore_errors ;
  int aflag ;
  int fflag ;
  int hflag ;
  int iflag ;
  int lflag ;
  int pflag ;
  int rflag ;
  int sflag ;
  int cmdnum ;
  unsigned long n_arg ;
  Attrib *aa ;
  int err ;

  {
#line 245
  ignore_errors = 0;
#line 245
  aflag = 0;
#line 245
  fflag = 0;
#line 245
  hflag = 0;
#line 245
  iflag = 0;
#line 247
  lflag = 0;
#line 247
  pflag = 0;
#line 247
  rflag = 0;
#line 247
  sflag = 0;
#line 249
  n_arg = 0UL;
#line 252
  err = 0;
#line 254
  path2 = (char *)((void *)0);
#line 254
  path1 = path2;
#line 255
  if (ignore_errors != 0) {
#line 256
    err_abort = 0;
  }
#line 259
  switch (cmdnum) {
  case 0: 
#line 262
  break;
  case -1: 
#line 265
  err = -1;
#line 266
  break;
  case 19: 
#line 268
  aflag = 1;
  case 1: 
#line 271
  tmp = do_realpath(conn, (char const   *)path1);
#line 271
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 272
    err = 1;
#line 273
    break;
  }
#line 276
  if (! (aa->flags & 4U)) {
#line 277
    error("Can\'t change directory: Can\'t check target");
#line 278
    free((void *)tmp);
#line 279
    err = 1;
#line 280
    break;
  }
#line 282
  free((void *)*pwd);
#line 283
  *pwd = tmp;
#line 284
  break;
  default: 
#line 286
  printf((char const   * __restrict  )"%d is not implemented", cmdnum);
  }
#line 290
  if (err_abort) {
#line 290
    if (err != 0) {
#line 291
      return (-1);
    } else {
#line 290
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 292
  if (cmdnum == 18) {
#line 293
    return (1);
  }
#line 295
  return (0);
}
}
#line 299 "openssh_leak_5.c"
int interactive_loop(struct sftp_conn *conn , char *file1 , char *file2 ) 
{ 
  char *remote_path ;
  char *dir ;
  char cmd[2048] ;
  int err ;
  EditLine *el ;
  int tmp ;
  int tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
#line 303
  dir = (char *)((void *)0);
#line 306
  el = (void *)0;
#line 308
  remote_path = do_realpath(conn, ".");
#line 309
  if ((unsigned long )remote_path == (unsigned long )((void *)0)) {
#line 310
    printf((char const   * __restrict  )"Need cwd%s", "");
#line 310
    exit(1);
  }
#line 312
  if ((unsigned long )file1 != (unsigned long )((void *)0)) {
#line 313
    tmp = strdup(file1);
#line 313
    dir = (char *)tmp;
#line 315
    if ((unsigned long )file2 == (unsigned long )((void *)0)) {
#line 316
      if (! quiet) {
#line 317
        printf((char const   * __restrict  )"Changing to: %s\n", dir);
      }
#line 318
      snprintf((char * __restrict  )(cmd), sizeof(cmd), (char const   * __restrict  )"cd \"%s\"",
               dir);
#line 319
      tmp___0 = parse_dispatch_command(conn, (char const   *)(cmd), & remote_path,
                                       1);
#line 319
      if (tmp___0 != 0) {
#line 321
        free((void *)dir);
#line 322
        free((void *)remote_path);
#line 323
        free((void *)conn);
#line 324
        return (-1);
      }
    } else {
#line 328
      if ((unsigned long )file2 == (unsigned long )((void *)0)) {
#line 328
        tmp___1 = "";
      } else {
#line 328
        tmp___1 = (char const   *)file2;
      }
#line 328
      if ((unsigned long )file2 == (unsigned long )((void *)0)) {
#line 328
        tmp___2 = "";
      } else {
#line 328
        tmp___2 = " ";
      }
#line 328
      snprintf((char * __restrict  )(cmd), sizeof(cmd), (char const   * __restrict  )"get %s%s%s",
               dir, tmp___2, tmp___1);
#line 332
      err = parse_dispatch_command(conn, (char const   *)(cmd), & remote_path, 1);
#line 334
      free((void *)dir);
#line 335
      free((void *)remote_path);
#line 336
      free((void *)conn);
#line 337
      return (err);
    }
#line 339
    free((void *)dir);
  }
#line 342
  err = 0;
#line 343
  while (1) {
#line 346
    if ((unsigned long )el == (unsigned long )((void *)0)) {
#line 347
      tmp___3 = fgets((char * __restrict  )(cmd), (int )sizeof(cmd), (FILE * __restrict  )infile);
#line 347
      if ((unsigned long )tmp___3 == (unsigned long )((void *)0)) {
#line 348
        break;
      }
    }
#line 352
    err = parse_dispatch_command(conn, (char const   *)(cmd), & remote_path, batchmode);
#line 354
    if (err != 0) {
#line 355
      break;
    }
  }
#line 357
  free((void *)remote_path);
#line 358
  free((void *)conn);
#line 361
  if (err >= 0) {
#line 361
    tmp___4 = 0;
  } else {
#line 361
    tmp___4 = -1;
  }
#line 361
  return (tmp___4);
}
}
#line 370 "openssh_leak_5.c"
int main(int argc , char **argv ) 
{ 
  int in ;
  int out ;
  int err ;
  char *host ;
  char *file2 ;
  int debug_level ;
  int sshver ;
  char *file1 ;
  char *sftp_server ;
  char *ssh_program ;
  char *sftp_direct ;
  LogLevel ll ;
  struct sftp_conn *conn ;
  size_t copy_buffer_len ;
  size_t num_requests ;
  long long limit_kbps ;

  {
#line 374
  host = (char *)((void *)0);
#line 374
  file2 = (char *)((void *)0);
#line 375
  debug_level = 0;
#line 375
  sshver = 2;
#line 376
  file1 = (char *)((void *)0);
#line 376
  sftp_server = (char *)((void *)0);
#line 377
  ssh_program = (char *)"/usr/bin/ssh";
#line 377
  sftp_direct = (char *)((void *)0);
#line 379
  ll = (LogLevel )3;
#line 383
  copy_buffer_len = (size_t )32768;
#line 384
  num_requests = (size_t )64;
#line 385
  limit_kbps = 0LL;
#line 387
  conn = do_init(in, out, (u_int___0 )copy_buffer_len, (u_int___0 )num_requests, (u_int64_t )limit_kbps);
#line 388
  if ((unsigned long )conn == (unsigned long )((void *)0)) {
#line 389
    printf((char const   * __restrict  )"Couldn\'t initialise connection to server\n");
#line 390
    return (1);
  }
#line 393
  err = interactive_loop(conn, file1, file2);
#line 394
  return (0);
}
}
