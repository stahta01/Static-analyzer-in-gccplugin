/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

#line 216 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h"
typedef unsigned long size_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 67 "../stdio.h"
typedef unsigned short u_short___0;
#line 68 "../stdio.h"
typedef unsigned int u_int___0;
#line 79 "../stdio.h"
typedef unsigned char u_char___0;
#line 85 "../stdio.h"
typedef int pid_t___0;
#line 39 "../tmux.h"
typedef char bitstr_t;
#line 41 "../tmux.h"
struct event {

};
#line 42 "../tmux.h"
struct termios {

};
#line 48
struct key_binding;
#line 48
struct key_binding;
#line 49
struct key_bindings;
#line 49
struct key_bindings;
#line 50
struct args;
#line 50
struct args;
#line 51
struct client;
#line 51
struct client;
#line 52
struct cmd_find_state;
#line 52
struct cmd_find_state;
#line 53
struct cmdq_item;
#line 53
struct cmdq_item;
#line 54
struct cmdq_list;
#line 54
struct cmdq_list;
#line 55
struct environ;
#line 55
struct environ;
#line 56
struct format_job_tree;
#line 56
struct format_job_tree;
#line 57
struct input_ctx;
#line 57
struct input_ctx;
#line 59
struct mouse_event;
#line 59
struct mouse_event;
#line 60
struct options;
#line 60
struct options;
#line 61
struct options_entry;
#line 61
struct options_entry;
#line 62
struct session;
#line 62
struct session;
#line 63
struct tmuxpeer;
#line 63
struct tmuxpeer;
#line 140 "../tmux.h"
typedef unsigned long long key_code;
#line 473 "../tmux.h"
struct options_tree {
   struct options_entry *rbh_root ;
};
#line 473 "../tmux.h"
struct options {
   struct options_tree tree ;
   struct options *parent ;
};
#line 479 "../tmux.h"
struct __anonstruct_name_entry_26 {
   struct paste_buffer *rbe_left ;
   struct paste_buffer *rbe_right ;
   struct paste_buffer *rbe_parent ;
   int rbe_color ;
};
#line 479 "../tmux.h"
struct __anonstruct_time_entry_27 {
   struct paste_buffer *rbe_left ;
   struct paste_buffer *rbe_right ;
   struct paste_buffer *rbe_parent ;
   int rbe_color ;
};
#line 479 "../tmux.h"
struct paste_buffer {
   char *data ;
   size_t size ;
   char *name ;
   int automatic ;
   u_int___0 order ;
   struct __anonstruct_name_entry_26 name_entry ;
   struct __anonstruct_time_entry_27 time_entry ;
};
#line 490 "../tmux.h"
struct paste_stack {
   struct paste_buffer **list ;
   u_int___0 num ;
   size_t space ;
};
#line 543 "../tmux.h"
struct utf8_data {
   u_char___0 data[9] ;
   u_char___0 have ;
   u_char___0 size ;
   u_char___0 width ;
};
#line 585 "../tmux.h"
struct grid_cell {
   u_char___0 flags ;
   u_short___0 attr ;
   int fg ;
   int bg ;
   struct utf8_data data ;
};
#line 592 "../tmux.h"
struct __anonstruct_data_29 {
   u_char___0 attr ;
   u_char___0 fg ;
   u_char___0 bg ;
   u_char___0 data ;
};
#line 592 "../tmux.h"
union __anonunion____missing_field_name_28 {
   u_int___0 offset ;
   struct __anonstruct_data_29 data ;
};
#line 592 "../tmux.h"
struct grid_cell_entry {
   u_char___0 flags ;
   union __anonunion____missing_field_name_28 __annonCompField1 ;
};
#line 606 "../tmux.h"
struct grid_line {
   u_int___0 cellused ;
   u_int___0 cellsize ;
   struct grid_cell_entry *celldata ;
   u_int___0 extdsize ;
   struct grid_cell *extddata ;
   int flags ;
};
#line 618 "../tmux.h"
struct grid {
   int flags ;
   u_int___0 sx ;
   u_int___0 sy ;
   u_int___0 hscrolled ;
   u_int___0 hsize ;
   u_int___0 hlimit ;
   struct grid_line *linedata ;
};
#line 633
struct cmd_list;
#line 646
struct bufferevent;
#line 671
enum __anonenum_lineflag_33 {
    LINE_SEL_NONE = 0,
    LINE_SEL_LEFT_RIGHT = 1,
    LINE_SEL_RIGHT_LEFT = 2
} ;
#line 671 "../tmux.h"
struct screen_sel {
   int flag ;
   int hidden ;
   int rectflag ;
   enum __anonenum_lineflag_33 lineflag ;
   int modekeys ;
   u_int___0 sx ;
   u_int___0 sy ;
   u_int___0 ex ;
   u_int___0 ey ;
   struct grid_cell cell ;
};
#line 693
struct screen_titles;
#line 693
struct screen_titles;
#line 694 "../tmux.h"
struct screen {
   char *title ;
   struct screen_titles *titles ;
   struct grid *grid ;
   u_int___0 cx ;
   u_int___0 cy ;
   u_int___0 cstyle ;
   char *ccolour ;
   u_int___0 rupper ;
   u_int___0 rlower ;
   u_int___0 hsize ;
   int mode ;
   bitstr_t *tabs ;
   struct screen_sel sel ;
};
#line 721
struct window_pane;
#line 746 "../tmux.h"
struct window_mode {
   char const   *name ;
   struct screen *(*init)(struct window_pane * , struct cmd_find_state * , struct args * ) ;
   void (*free)(struct window_pane * ) ;
   void (*resize)(struct window_pane * , u_int___0  , u_int___0  ) ;
   void (*key)(struct window_pane * , struct client * , struct session * , key_code  ,
               struct mouse_event * ) ;
   char const   *(*key_table)(struct window_pane * ) ;
   void (*command)(struct window_pane * , struct client * , struct session * , struct args * ,
                   struct mouse_event * ) ;
};
#line 766
struct winlink;
#line 788
struct window;
#line 788
struct layout_cell;
#line 788 "../tmux.h"
struct __anonstruct_entry_34 {
   struct window_pane *tqe_next ;
   struct window_pane **tqe_prev ;
};
#line 788 "../tmux.h"
struct __anonstruct_tree_entry_35 {
   struct window_pane *rbe_left ;
   struct window_pane *rbe_right ;
   struct window_pane *rbe_parent ;
   int rbe_color ;
};
#line 788 "../tmux.h"
struct window_pane {
   u_int___0 id ;
   u_int___0 active_point ;
   struct window *window ;
   struct layout_cell *layout_cell ;
   struct layout_cell *saved_layout_cell ;
   u_int___0 sx ;
   u_int___0 sy ;
   u_int___0 osx ;
   u_int___0 osy ;
   u_int___0 xoff ;
   u_int___0 yoff ;
   int flags ;
   int argc ;
   char **argv ;
   char *shell ;
   char const   *cwd ;
   pid_t___0 pid ;
   char tty[10] ;
   int status ;
   int fd ;
   struct bufferevent *event ;
   struct event resize_timer ;
   struct input_ctx *ictx ;
   struct grid_cell colgc ;
   int *palette ;
   int pipe_fd ;
   struct bufferevent *pipe_event ;
   size_t pipe_off ;
   struct screen *screen ;
   struct screen base ;
   struct screen status_screen ;
   size_t status_size ;
   u_int___0 saved_cx ;
   u_int___0 saved_cy ;
   struct grid *saved_grid ;
   struct grid_cell saved_cell ;
   struct window_mode  const  *mode ;
   void *modedata ;
   struct event modetimer ;
   time_t modelast ;
   u_int___0 modeprefix ;
   char *searchstr ;
   struct __anonstruct_entry_34 entry ;
   struct __anonstruct_tree_entry_35 tree_entry ;
};
#line 865 "../tmux.h"
struct window_panes {
   struct window_pane *tqh_first ;
   struct window_pane **tqh_last ;
};
#line 922 "../tmux.h"
struct __anonstruct_entry_36 {
   struct winlink *rbe_left ;
   struct winlink *rbe_right ;
   struct winlink *rbe_parent ;
   int rbe_color ;
};
#line 922 "../tmux.h"
struct __anonstruct_wentry_37 {
   struct winlink *tqe_next ;
   struct winlink **tqe_prev ;
};
#line 922 "../tmux.h"
struct __anonstruct_sentry_38 {
   struct winlink *tqe_next ;
   struct winlink **tqe_prev ;
};
#line 922 "../tmux.h"
struct winlink {
   int idx ;
   struct session *session ;
   struct window *window ;
   size_t status_width ;
   struct grid_cell status_cell ;
   char *status_text ;
   int flags ;
   struct __anonstruct_entry_36 entry ;
   struct __anonstruct_wentry_37 wentry ;
   struct __anonstruct_sentry_38 sentry ;
};
#line 941 "../tmux.h"
struct winlinks {
   struct winlink *rbh_root ;
};
#line 942 "../tmux.h"
struct winlink_stack {
   struct winlink *tqh_first ;
   struct winlink **tqh_last ;
};
#line 945
enum layout_type {
    LAYOUT_LEFTRIGHT = 0,
    LAYOUT_TOPBOTTOM = 1,
    LAYOUT_WINDOWPANE = 2
} ;
#line 952 "../tmux.h"
struct layout_cells {
   struct layout_cell *tqh_first ;
   struct layout_cell **tqh_last ;
};
#line 955 "../tmux.h"
struct __anonstruct_entry_39 {
   struct layout_cell *tqe_next ;
   struct layout_cell **tqe_prev ;
};
#line 955 "../tmux.h"
struct layout_cell {
   enum layout_type type ;
   struct layout_cell *parent ;
   u_int___0 sx ;
   u_int___0 sy ;
   u_int___0 xoff ;
   u_int___0 yoff ;
   struct window_pane *wp ;
   struct layout_cells cells ;
   struct __anonstruct_entry_39 entry ;
};
#line 1055 "../tmux.h"
struct mouse_event {
   int valid ;
   key_code key ;
   int statusat ;
   u_int___0 x ;
   u_int___0 y ;
   u_int___0 b ;
   u_int___0 lx ;
   u_int___0 ly ;
   u_int___0 lb ;
   int s ;
   int w ;
   int wp ;
   u_int___0 sgr_type ;
   u_int___0 sgr_b ;
};
#line 1078 "../tmux.h"
struct tty_key {
   char ch ;
   key_code key ;
   struct tty_key *left ;
   struct tty_key *right ;
   struct tty_key *next ;
};
#line 1088
struct tty_code;
#line 1088
struct tty_code;
#line 1090 "../tmux.h"
struct __anonstruct_entry_41 {

};
#line 1090 "../tmux.h"
struct tty_term {
   char *name ;
   u_int___0 references ;
   char acs[11][2] ;
   struct tty_code *codes ;
   int flags ;
   struct __anonstruct_entry_41 entry ;
};
#line 1106
struct evbuffer;
#line 1106
enum __anonenum_term_type_42 {
    TTY_VT100 = 0,
    TTY_VT101 = 1,
    TTY_VT102 = 2,
    TTY_VT220 = 3,
    TTY_VT320 = 4,
    TTY_VT420 = 5,
    TTY_UNKNOWN = 6
} ;
#line 1106 "../tmux.h"
struct tty {
   struct client *client ;
   u_int___0 sx ;
   u_int___0 sy ;
   u_int___0 cx ;
   u_int___0 cy ;
   u_int___0 cstyle ;
   char *ccolour ;
   int mode ;
   u_int___0 rlower ;
   u_int___0 rupper ;
   u_int___0 rleft ;
   u_int___0 rright ;
   int fd ;
   struct event event_in ;
   struct evbuffer *in ;
   struct event event_out ;
   struct evbuffer *out ;
   struct event timer ;
   size_t discarded ;
   struct termios tio ;
   struct grid_cell cell ;
   int last_wp ;
   struct grid_cell last_cell ;
   int flags ;
   struct tty_term *term ;
   char *term_name ;
   int term_flags ;
   enum __anonenum_term_type_42 term_type ;
   struct mouse_event mouse ;
   int mouse_drag_flag ;
   void (*mouse_drag_update)(struct client * , struct mouse_event * ) ;
   void (*mouse_drag_release)(struct client * , struct mouse_event * ) ;
   struct event key_timer ;
   struct tty_key *key_tree ;
};
#line 1206 "../tmux.h"
struct __anonstruct_entry_43 {
   struct message_entry *tqe_next ;
   struct message_entry **tqe_prev ;
};
#line 1206 "../tmux.h"
struct message_entry {
   char *msg ;
   u_int___0 msg_num ;
   time_t msg_time ;
   struct __anonstruct_entry_43 entry ;
};
#line 1215 "../tmux.h"
struct __anonstruct_entry_44 {
   struct args_entry *rbe_left ;
   struct args_entry *rbe_right ;
   struct args_entry *rbe_parent ;
   int rbe_color ;
};
#line 1215 "../tmux.h"
struct args_entry {
   u_char___0 flag ;
   char *value ;
   struct __anonstruct_entry_44 entry ;
};
#line 1221 "../tmux.h"
struct args_tree {
   struct args_entry *rbh_root ;
};
#line 1222 "../tmux.h"
struct args {
   struct args_tree tree ;
   int argc ;
   char **argv ;
};
#line 1234 "../tmux.h"
struct cmd_find_state {
   int flags ;
   struct cmd_find_state *current ;
   struct session *s ;
   struct winlink *wl ;
   struct window *w ;
   struct window_pane *wp ;
   int idx ;
};
#line 1256
struct cmd_entry;
#line 1256 "../tmux.h"
struct __anonstruct_qentry_45 {
   struct cmd *tqe_next ;
   struct cmd **tqe_prev ;
};
#line 1256 "../tmux.h"
struct cmd {
   struct cmd_entry  const  *entry ;
   struct args *args ;
   char *file ;
   u_int___0 line ;
   int flags ;
   void *data ;
   struct __anonstruct_qentry_45 qentry ;
};
#line 1269 "../tmux.h"
struct __anonstruct_list_46 {
   struct cmd *tqh_first ;
   struct cmd **tqh_last ;
};
#line 1269 "../tmux.h"
struct cmd_list {
   int references ;
   struct __anonstruct_list_46 list ;
};
#line 1305
struct cmdq_item;
#line 1306 "../tmux.h"
struct cmdq_list {
   struct cmdq_item *tqh_first ;
   struct cmdq_item **tqh_last ;
};
#line 1316
struct cmd_entry;
#line 1322
struct key_table;
#line 1322 "../tmux.h"
struct __anonstruct_message_log_47 {
   struct message_entry *tqh_first ;
   struct message_entry **tqh_last ;
};
#line 1322
enum __anonenum_prompt_mode_48 {
    PROMPT_ENTRY = 0,
    PROMPT_COMMAND = 1
} ;
#line 1322
struct cmd_q;
#line 1322 "../tmux.h"
struct __anonstruct_entry_49 {
   struct client *tqe_next ;
   struct client **tqe_prev ;
};
#line 1322 "../tmux.h"
struct client {
   char const   *name ;
   struct tmuxpeer *peer ;
   struct cmdq_list queue ;
   pid_t___0 pid ;
   int fd ;
   struct event event ;
   int retval ;
   struct timeval creation_time ;
   struct timeval activity_time ;
   struct environ *environ ;
   struct format_job_tree *jobs ;
   char *title ;
   char const   *cwd ;
   char *term ;
   char *ttyname ;
   struct tty tty ;
   size_t written ;
   size_t discarded ;
   size_t redraw ;
   void (*stdin_callback)(struct client * , int  , void * ) ;
   void *stdin_callback_data ;
   struct evbuffer *stdin_data ;
   int stdin_closed ;
   struct evbuffer *stdout_data ;
   struct evbuffer *stderr_data ;
   struct event repeat_timer ;
   struct event click_timer ;
   u_int___0 click_button ;
   struct event status_timer ;
   struct screen status ;
   struct screen *old_status ;
   int flags ;
   struct key_table *keytable ;
   struct event identify_timer ;
   void (*identify_callback)(struct client * , struct window_pane * ) ;
   void *identify_callback_data ;
   char *message_string ;
   struct event message_timer ;
   u_int___0 message_next ;
   struct __anonstruct_message_log_47 message_log ;
   char *prompt_string ;
   struct utf8_data *prompt_buffer ;
   size_t prompt_index ;
   int (*prompt_inputcb)(struct client * , void * , char const   * , int  ) ;
   void (*prompt_freecb)(void * ) ;
   void *prompt_data ;
   u_int___0 prompt_hindex ;
   enum __anonenum_prompt_mode_48 prompt_mode ;
   int prompt_flags ;
   struct session *session ;
   struct session *last_session ;
   int wlmouse ;
   int references ;
   struct cmd_q *cmdq ;
   struct __anonstruct_entry_49 entry ;
};
#line 1434 "../tmux.h"
struct __anonstruct_entry_50 {
   struct key_binding *rbe_left ;
   struct key_binding *rbe_right ;
   struct key_binding *rbe_parent ;
   int rbe_color ;
};
#line 1434 "../tmux.h"
struct key_binding {
   key_code key ;
   struct cmd_list *cmdlist ;
   int flags ;
   struct __anonstruct_entry_50 entry ;
};
#line 1443 "../tmux.h"
struct key_bindings {
   struct key_binding *rbh_root ;
};
#line 1445 "../tmux.h"
struct __anonstruct_entry_51 {
   struct key_table *rbe_left ;
   struct key_table *rbe_right ;
   struct key_table *rbe_parent ;
   int rbe_color ;
};
#line 1445 "../tmux.h"
struct key_table {
   char const   *name ;
   struct key_bindings key_bindings ;
   u_int___0 references ;
   struct __anonstruct_entry_51 entry ;
};
#line 1507
struct paste_buffer;
#line 17 "tmux_uaf_4.c"
struct window {
   char *name ;
   struct event name_timer ;
   struct window_pane *active ;
   struct window_panes panes ;
   int lastlayout ;
   struct layout_cell *layout_root ;
   u_int___0 sx ;
   u_int___0 sy ;
   int flags ;
   struct options options ;
   u_int___0 references ;
};
#line 41 "tmux_uaf_4.c"
struct windows {
   struct window **list ;
   u_int___0 num ;
   size_t space ;
};
#line 43 "tmux_uaf_4.c"
struct __anonstruct_sessions_52 {
   struct session *tqh_first ;
   struct session **tqh_last ;
};
#line 43 "tmux_uaf_4.c"
struct __anonstruct_entry_53 {
   struct session_group *tqe_next ;
   struct session_group **tqe_prev ;
};
#line 43 "tmux_uaf_4.c"
struct session_group {
   struct __anonstruct_sessions_52 sessions ;
   struct __anonstruct_entry_53 entry ;
};
#line 48 "tmux_uaf_4.c"
struct session_groups {
   struct session_group *tqh_first ;
   struct session_group **tqh_last ;
};
#line 50 "tmux_uaf_4.c"
struct __anonstruct_gentry_54 {
   struct session *tqe_next ;
   struct session **tqe_prev ;
};
#line 50 "tmux_uaf_4.c"
struct session {
   char *name ;
   u_int___0 sx ;
   u_int___0 sy ;
   struct winlink *curw ;
   struct winlink_stack lastw ;
   struct winlinks windows ;
   struct paste_stack buffers ;
   int flags ;
   struct termios *tio ;
   int references ;
   struct __anonstruct_gentry_54 gentry ;
};
#line 72 "tmux_uaf_4.c"
struct sessions {
   struct session **list ;
   u_int___0 num ;
   size_t space ;
};
#line 371
struct session_alert;
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 42 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 140
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 171
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 75 "tmux_uaf_4.c"
struct session_groups session_groups  ;
#line 76 "tmux_uaf_4.c"
struct sessions sessions  ;
#line 77 "tmux_uaf_4.c"
struct windows windows  ;
#line 80 "tmux_uaf_4.c"
int winlink_cmp(struct winlink *wl1 , struct winlink *wl2 ) 
{ 


  {
#line 83
  return (wl1->idx - wl2->idx);
}
}
#line 86 "tmux_uaf_4.c"
void winlinks_RB_INSERT_COLOR(struct winlinks *head , struct winlink *elm ) 
{ 
  struct winlink *parent ;
  struct winlink *gparent ;
  struct winlink *tmp ;
  struct winlink *tmp___0 ;
  struct winlink *tmp___1 ;
  struct winlink *tmp___2 ;
  struct winlink *tmp___3 ;
  struct winlink *tmp___4 ;
  struct winlink *tmp___5 ;
  struct winlink *tmp___6 ;
  struct winlink *tmp___7 ;

  {
#line 86
  while (1) {
#line 86
    parent = elm->entry.rbe_parent;
#line 86
    if ((unsigned long )parent != (unsigned long )((void *)0)) {
#line 86
      if (! (parent->entry.rbe_color == 1)) {
#line 86
        break;
      }
    } else {
#line 86
      break;
    }
#line 86
    gparent = parent->entry.rbe_parent;
#line 86
    if ((unsigned long )parent == (unsigned long )gparent->entry.rbe_left) {
#line 86
      tmp = gparent->entry.rbe_right;
#line 86
      if (tmp) {
#line 86
        if (tmp->entry.rbe_color == 1) {
#line 86
          tmp->entry.rbe_color = 0;
#line 86
          while (1) {
#line 86
            parent->entry.rbe_color = 0;
#line 86
            gparent->entry.rbe_color = 1;
#line 86
            break;
          }
#line 86
          elm = gparent;
#line 86
          continue;
        }
      }
#line 86
      if ((unsigned long )parent->entry.rbe_right == (unsigned long )elm) {
#line 86
        while (1) {
#line 86
          tmp = parent->entry.rbe_right;
#line 86
          tmp___0 = tmp->entry.rbe_left;
#line 86
          parent->entry.rbe_right = tmp___0;
#line 86
          if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 86
            (tmp->entry.rbe_left)->entry.rbe_parent = parent;
          }
#line 86
          while (1) {
#line 86
            break;
          }
#line 86
          tmp___1 = parent->entry.rbe_parent;
#line 86
          tmp->entry.rbe_parent = tmp___1;
#line 86
          if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
#line 86
            if ((unsigned long )parent == (unsigned long )(parent->entry.rbe_parent)->entry.rbe_left) {
#line 86
              (parent->entry.rbe_parent)->entry.rbe_left = tmp;
            } else {
#line 86
              (parent->entry.rbe_parent)->entry.rbe_right = tmp;
            }
          } else {
#line 86
            head->rbh_root = tmp;
          }
#line 86
          tmp->entry.rbe_left = parent;
#line 86
          parent->entry.rbe_parent = tmp;
#line 86
          while (1) {
#line 86
            break;
          }
#line 86
          if (tmp->entry.rbe_parent) {
#line 86
            while (1) {
#line 86
              break;
            }
          }
#line 86
          break;
        }
#line 86
        tmp = parent;
#line 86
        parent = elm;
#line 86
        elm = tmp;
      }
#line 86
      while (1) {
#line 86
        parent->entry.rbe_color = 0;
#line 86
        gparent->entry.rbe_color = 1;
#line 86
        break;
      }
#line 86
      while (1) {
#line 86
        tmp = gparent->entry.rbe_left;
#line 86
        tmp___2 = tmp->entry.rbe_right;
#line 86
        gparent->entry.rbe_left = tmp___2;
#line 86
        if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
#line 86
          (tmp->entry.rbe_right)->entry.rbe_parent = gparent;
        }
#line 86
        while (1) {
#line 86
          break;
        }
#line 86
        tmp___3 = gparent->entry.rbe_parent;
#line 86
        tmp->entry.rbe_parent = tmp___3;
#line 86
        if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
#line 86
          if ((unsigned long )gparent == (unsigned long )(gparent->entry.rbe_parent)->entry.rbe_left) {
#line 86
            (gparent->entry.rbe_parent)->entry.rbe_left = tmp;
          } else {
#line 86
            (gparent->entry.rbe_parent)->entry.rbe_right = tmp;
          }
        } else {
#line 86
          head->rbh_root = tmp;
        }
#line 86
        tmp->entry.rbe_right = gparent;
#line 86
        gparent->entry.rbe_parent = tmp;
#line 86
        while (1) {
#line 86
          break;
        }
#line 86
        if (tmp->entry.rbe_parent) {
#line 86
          while (1) {
#line 86
            break;
          }
        }
#line 86
        break;
      }
    } else {
#line 86
      tmp = gparent->entry.rbe_left;
#line 86
      if (tmp) {
#line 86
        if (tmp->entry.rbe_color == 1) {
#line 86
          tmp->entry.rbe_color = 0;
#line 86
          while (1) {
#line 86
            parent->entry.rbe_color = 0;
#line 86
            gparent->entry.rbe_color = 1;
#line 86
            break;
          }
#line 86
          elm = gparent;
#line 86
          continue;
        }
      }
#line 86
      if ((unsigned long )parent->entry.rbe_left == (unsigned long )elm) {
#line 86
        while (1) {
#line 86
          tmp = parent->entry.rbe_left;
#line 86
          tmp___4 = tmp->entry.rbe_right;
#line 86
          parent->entry.rbe_left = tmp___4;
#line 86
          if ((unsigned long )tmp___4 != (unsigned long )((void *)0)) {
#line 86
            (tmp->entry.rbe_right)->entry.rbe_parent = parent;
          }
#line 86
          while (1) {
#line 86
            break;
          }
#line 86
          tmp___5 = parent->entry.rbe_parent;
#line 86
          tmp->entry.rbe_parent = tmp___5;
#line 86
          if ((unsigned long )tmp___5 != (unsigned long )((void *)0)) {
#line 86
            if ((unsigned long )parent == (unsigned long )(parent->entry.rbe_parent)->entry.rbe_left) {
#line 86
              (parent->entry.rbe_parent)->entry.rbe_left = tmp;
            } else {
#line 86
              (parent->entry.rbe_parent)->entry.rbe_right = tmp;
            }
          } else {
#line 86
            head->rbh_root = tmp;
          }
#line 86
          tmp->entry.rbe_right = parent;
#line 86
          parent->entry.rbe_parent = tmp;
#line 86
          while (1) {
#line 86
            break;
          }
#line 86
          if (tmp->entry.rbe_parent) {
#line 86
            while (1) {
#line 86
              break;
            }
          }
#line 86
          break;
        }
#line 86
        tmp = parent;
#line 86
        parent = elm;
#line 86
        elm = tmp;
      }
#line 86
      while (1) {
#line 86
        parent->entry.rbe_color = 0;
#line 86
        gparent->entry.rbe_color = 1;
#line 86
        break;
      }
#line 86
      while (1) {
#line 86
        tmp = gparent->entry.rbe_right;
#line 86
        tmp___6 = tmp->entry.rbe_left;
#line 86
        gparent->entry.rbe_right = tmp___6;
#line 86
        if ((unsigned long )tmp___6 != (unsigned long )((void *)0)) {
#line 86
          (tmp->entry.rbe_left)->entry.rbe_parent = gparent;
        }
#line 86
        while (1) {
#line 86
          break;
        }
#line 86
        tmp___7 = gparent->entry.rbe_parent;
#line 86
        tmp->entry.rbe_parent = tmp___7;
#line 86
        if ((unsigned long )tmp___7 != (unsigned long )((void *)0)) {
#line 86
          if ((unsigned long )gparent == (unsigned long )(gparent->entry.rbe_parent)->entry.rbe_left) {
#line 86
            (gparent->entry.rbe_parent)->entry.rbe_left = tmp;
          } else {
#line 86
            (gparent->entry.rbe_parent)->entry.rbe_right = tmp;
          }
        } else {
#line 86
          head->rbh_root = tmp;
        }
#line 86
        tmp->entry.rbe_left = gparent;
#line 86
        gparent->entry.rbe_parent = tmp;
#line 86
        while (1) {
#line 86
          break;
        }
#line 86
        if (tmp->entry.rbe_parent) {
#line 86
          while (1) {
#line 86
            break;
          }
        }
#line 86
        break;
      }
    }
  }
#line 86
  (head->rbh_root)->entry.rbe_color = 0;
#line 86
  return;
}
}
#line 86 "tmux_uaf_4.c"
void winlinks_RB_REMOVE_COLOR(struct winlinks *head , struct winlink *parent , struct winlink *elm ) 
{ 
  struct winlink *tmp ;
  struct winlink *tmp___0 ;
  struct winlink *tmp___1 ;
  struct winlink *oleft ;
  struct winlink *tmp___2 ;
  struct winlink *tmp___3 ;
  struct winlink *tmp___4 ;
  struct winlink *tmp___5 ;
  struct winlink *tmp___6 ;
  struct winlink *tmp___7 ;
  struct winlink *oright ;
  struct winlink *tmp___8 ;
  struct winlink *tmp___9 ;
  struct winlink *tmp___10 ;
  struct winlink *tmp___11 ;

  {
#line 86
  while (1) {
#line 86
    if ((unsigned long )elm == (unsigned long )((void *)0)) {
#line 86
      goto _L___5;
    } else
#line 86
    if (elm->entry.rbe_color == 0) {
      _L___5: /* CIL Label */ 
#line 86
      if (! ((unsigned long )elm != (unsigned long )head->rbh_root)) {
#line 86
        break;
      }
    } else {
#line 86
      break;
    }
#line 86
    if ((unsigned long )parent->entry.rbe_left == (unsigned long )elm) {
#line 86
      tmp = parent->entry.rbe_right;
#line 86
      if (tmp->entry.rbe_color == 1) {
#line 86
        while (1) {
#line 86
          tmp->entry.rbe_color = 0;
#line 86
          parent->entry.rbe_color = 1;
#line 86
          break;
        }
#line 86
        while (1) {
#line 86
          tmp = parent->entry.rbe_right;
#line 86
          tmp___0 = tmp->entry.rbe_left;
#line 86
          parent->entry.rbe_right = tmp___0;
#line 86
          if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 86
            (tmp->entry.rbe_left)->entry.rbe_parent = parent;
          }
#line 86
          while (1) {
#line 86
            break;
          }
#line 86
          tmp___1 = parent->entry.rbe_parent;
#line 86
          tmp->entry.rbe_parent = tmp___1;
#line 86
          if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
#line 86
            if ((unsigned long )parent == (unsigned long )(parent->entry.rbe_parent)->entry.rbe_left) {
#line 86
              (parent->entry.rbe_parent)->entry.rbe_left = tmp;
            } else {
#line 86
              (parent->entry.rbe_parent)->entry.rbe_right = tmp;
            }
          } else {
#line 86
            head->rbh_root = tmp;
          }
#line 86
          tmp->entry.rbe_left = parent;
#line 86
          parent->entry.rbe_parent = tmp;
#line 86
          while (1) {
#line 86
            break;
          }
#line 86
          if (tmp->entry.rbe_parent) {
#line 86
            while (1) {
#line 86
              break;
            }
          }
#line 86
          break;
        }
#line 86
        tmp = parent->entry.rbe_right;
      }
#line 86
      if ((unsigned long )tmp->entry.rbe_left == (unsigned long )((void *)0)) {
#line 86
        goto _L___1;
      } else
#line 86
      if ((tmp->entry.rbe_left)->entry.rbe_color == 0) {
        _L___1: /* CIL Label */ 
#line 86
        if ((unsigned long )tmp->entry.rbe_right == (unsigned long )((void *)0)) {
#line 86
          tmp->entry.rbe_color = 1;
#line 86
          elm = parent;
#line 86
          parent = elm->entry.rbe_parent;
        } else
#line 86
        if ((tmp->entry.rbe_right)->entry.rbe_color == 0) {
#line 86
          tmp->entry.rbe_color = 1;
#line 86
          elm = parent;
#line 86
          parent = elm->entry.rbe_parent;
        } else {
#line 86
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 86
        if ((unsigned long )tmp->entry.rbe_right == (unsigned long )((void *)0)) {
#line 86
          goto _L;
        } else
#line 86
        if ((tmp->entry.rbe_right)->entry.rbe_color == 0) {
          _L: /* CIL Label */ 
#line 86
          oleft = tmp->entry.rbe_left;
#line 86
          if ((unsigned long )oleft != (unsigned long )((void *)0)) {
#line 86
            oleft->entry.rbe_color = 0;
          }
#line 86
          tmp->entry.rbe_color = 1;
#line 86
          while (1) {
#line 86
            oleft = tmp->entry.rbe_left;
#line 86
            tmp___2 = oleft->entry.rbe_right;
#line 86
            tmp->entry.rbe_left = tmp___2;
#line 86
            if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
#line 86
              (oleft->entry.rbe_right)->entry.rbe_parent = tmp;
            }
#line 86
            while (1) {
#line 86
              break;
            }
#line 86
            tmp___3 = tmp->entry.rbe_parent;
#line 86
            oleft->entry.rbe_parent = tmp___3;
#line 86
            if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
#line 86
              if ((unsigned long )tmp == (unsigned long )(tmp->entry.rbe_parent)->entry.rbe_left) {
#line 86
                (tmp->entry.rbe_parent)->entry.rbe_left = oleft;
              } else {
#line 86
                (tmp->entry.rbe_parent)->entry.rbe_right = oleft;
              }
            } else {
#line 86
              head->rbh_root = oleft;
            }
#line 86
            oleft->entry.rbe_right = tmp;
#line 86
            tmp->entry.rbe_parent = oleft;
#line 86
            while (1) {
#line 86
              break;
            }
#line 86
            if (oleft->entry.rbe_parent) {
#line 86
              while (1) {
#line 86
                break;
              }
            }
#line 86
            break;
          }
#line 86
          tmp = parent->entry.rbe_right;
        }
#line 86
        tmp->entry.rbe_color = parent->entry.rbe_color;
#line 86
        parent->entry.rbe_color = 0;
#line 86
        if (tmp->entry.rbe_right) {
#line 86
          (tmp->entry.rbe_right)->entry.rbe_color = 0;
        }
#line 86
        while (1) {
#line 86
          tmp = parent->entry.rbe_right;
#line 86
          tmp___4 = tmp->entry.rbe_left;
#line 86
          parent->entry.rbe_right = tmp___4;
#line 86
          if ((unsigned long )tmp___4 != (unsigned long )((void *)0)) {
#line 86
            (tmp->entry.rbe_left)->entry.rbe_parent = parent;
          }
#line 86
          while (1) {
#line 86
            break;
          }
#line 86
          tmp___5 = parent->entry.rbe_parent;
#line 86
          tmp->entry.rbe_parent = tmp___5;
#line 86
          if ((unsigned long )tmp___5 != (unsigned long )((void *)0)) {
#line 86
            if ((unsigned long )parent == (unsigned long )(parent->entry.rbe_parent)->entry.rbe_left) {
#line 86
              (parent->entry.rbe_parent)->entry.rbe_left = tmp;
            } else {
#line 86
              (parent->entry.rbe_parent)->entry.rbe_right = tmp;
            }
          } else {
#line 86
            head->rbh_root = tmp;
          }
#line 86
          tmp->entry.rbe_left = parent;
#line 86
          parent->entry.rbe_parent = tmp;
#line 86
          while (1) {
#line 86
            break;
          }
#line 86
          if (tmp->entry.rbe_parent) {
#line 86
            while (1) {
#line 86
              break;
            }
          }
#line 86
          break;
        }
#line 86
        elm = head->rbh_root;
#line 86
        break;
      }
    } else {
#line 86
      tmp = parent->entry.rbe_left;
#line 86
      if (tmp->entry.rbe_color == 1) {
#line 86
        while (1) {
#line 86
          tmp->entry.rbe_color = 0;
#line 86
          parent->entry.rbe_color = 1;
#line 86
          break;
        }
#line 86
        while (1) {
#line 86
          tmp = parent->entry.rbe_left;
#line 86
          tmp___6 = tmp->entry.rbe_right;
#line 86
          parent->entry.rbe_left = tmp___6;
#line 86
          if ((unsigned long )tmp___6 != (unsigned long )((void *)0)) {
#line 86
            (tmp->entry.rbe_right)->entry.rbe_parent = parent;
          }
#line 86
          while (1) {
#line 86
            break;
          }
#line 86
          tmp___7 = parent->entry.rbe_parent;
#line 86
          tmp->entry.rbe_parent = tmp___7;
#line 86
          if ((unsigned long )tmp___7 != (unsigned long )((void *)0)) {
#line 86
            if ((unsigned long )parent == (unsigned long )(parent->entry.rbe_parent)->entry.rbe_left) {
#line 86
              (parent->entry.rbe_parent)->entry.rbe_left = tmp;
            } else {
#line 86
              (parent->entry.rbe_parent)->entry.rbe_right = tmp;
            }
          } else {
#line 86
            head->rbh_root = tmp;
          }
#line 86
          tmp->entry.rbe_right = parent;
#line 86
          parent->entry.rbe_parent = tmp;
#line 86
          while (1) {
#line 86
            break;
          }
#line 86
          if (tmp->entry.rbe_parent) {
#line 86
            while (1) {
#line 86
              break;
            }
          }
#line 86
          break;
        }
#line 86
        tmp = parent->entry.rbe_left;
      }
#line 86
      if ((unsigned long )tmp->entry.rbe_left == (unsigned long )((void *)0)) {
#line 86
        goto _L___4;
      } else
#line 86
      if ((tmp->entry.rbe_left)->entry.rbe_color == 0) {
        _L___4: /* CIL Label */ 
#line 86
        if ((unsigned long )tmp->entry.rbe_right == (unsigned long )((void *)0)) {
#line 86
          tmp->entry.rbe_color = 1;
#line 86
          elm = parent;
#line 86
          parent = elm->entry.rbe_parent;
        } else
#line 86
        if ((tmp->entry.rbe_right)->entry.rbe_color == 0) {
#line 86
          tmp->entry.rbe_color = 1;
#line 86
          elm = parent;
#line 86
          parent = elm->entry.rbe_parent;
        } else {
#line 86
          goto _L___3;
        }
      } else {
        _L___3: /* CIL Label */ 
#line 86
        if ((unsigned long )tmp->entry.rbe_left == (unsigned long )((void *)0)) {
#line 86
          goto _L___2;
        } else
#line 86
        if ((tmp->entry.rbe_left)->entry.rbe_color == 0) {
          _L___2: /* CIL Label */ 
#line 86
          oright = tmp->entry.rbe_right;
#line 86
          if ((unsigned long )oright != (unsigned long )((void *)0)) {
#line 86
            oright->entry.rbe_color = 0;
          }
#line 86
          tmp->entry.rbe_color = 1;
#line 86
          while (1) {
#line 86
            oright = tmp->entry.rbe_right;
#line 86
            tmp___8 = oright->entry.rbe_left;
#line 86
            tmp->entry.rbe_right = tmp___8;
#line 86
            if ((unsigned long )tmp___8 != (unsigned long )((void *)0)) {
#line 86
              (oright->entry.rbe_left)->entry.rbe_parent = tmp;
            }
#line 86
            while (1) {
#line 86
              break;
            }
#line 86
            tmp___9 = tmp->entry.rbe_parent;
#line 86
            oright->entry.rbe_parent = tmp___9;
#line 86
            if ((unsigned long )tmp___9 != (unsigned long )((void *)0)) {
#line 86
              if ((unsigned long )tmp == (unsigned long )(tmp->entry.rbe_parent)->entry.rbe_left) {
#line 86
                (tmp->entry.rbe_parent)->entry.rbe_left = oright;
              } else {
#line 86
                (tmp->entry.rbe_parent)->entry.rbe_right = oright;
              }
            } else {
#line 86
              head->rbh_root = oright;
            }
#line 86
            oright->entry.rbe_left = tmp;
#line 86
            tmp->entry.rbe_parent = oright;
#line 86
            while (1) {
#line 86
              break;
            }
#line 86
            if (oright->entry.rbe_parent) {
#line 86
              while (1) {
#line 86
                break;
              }
            }
#line 86
            break;
          }
#line 86
          tmp = parent->entry.rbe_left;
        }
#line 86
        tmp->entry.rbe_color = parent->entry.rbe_color;
#line 86
        parent->entry.rbe_color = 0;
#line 86
        if (tmp->entry.rbe_left) {
#line 86
          (tmp->entry.rbe_left)->entry.rbe_color = 0;
        }
#line 86
        while (1) {
#line 86
          tmp = parent->entry.rbe_left;
#line 86
          tmp___10 = tmp->entry.rbe_right;
#line 86
          parent->entry.rbe_left = tmp___10;
#line 86
          if ((unsigned long )tmp___10 != (unsigned long )((void *)0)) {
#line 86
            (tmp->entry.rbe_right)->entry.rbe_parent = parent;
          }
#line 86
          while (1) {
#line 86
            break;
          }
#line 86
          tmp___11 = parent->entry.rbe_parent;
#line 86
          tmp->entry.rbe_parent = tmp___11;
#line 86
          if ((unsigned long )tmp___11 != (unsigned long )((void *)0)) {
#line 86
            if ((unsigned long )parent == (unsigned long )(parent->entry.rbe_parent)->entry.rbe_left) {
#line 86
              (parent->entry.rbe_parent)->entry.rbe_left = tmp;
            } else {
#line 86
              (parent->entry.rbe_parent)->entry.rbe_right = tmp;
            }
          } else {
#line 86
            head->rbh_root = tmp;
          }
#line 86
          tmp->entry.rbe_right = parent;
#line 86
          parent->entry.rbe_parent = tmp;
#line 86
          while (1) {
#line 86
            break;
          }
#line 86
          if (tmp->entry.rbe_parent) {
#line 86
            while (1) {
#line 86
              break;
            }
          }
#line 86
          break;
        }
#line 86
        elm = head->rbh_root;
#line 86
        break;
      }
    }
  }
#line 86
  if (elm) {
#line 86
    elm->entry.rbe_color = 0;
  }
#line 86
  return;
}
}
#line 86 "tmux_uaf_4.c"
struct winlink *winlinks_RB_INSERT(struct winlinks *head , struct winlink *elm ) 
{ 
  struct winlink *tmp ;
  struct winlink *parent ;
  int comp ;
  struct winlink *tmp___0 ;

  {
#line 86
  parent = (struct winlink *)((void *)0);
#line 86
  comp = 0;
#line 86
  tmp = head->rbh_root;
#line 86
  while (tmp) {
#line 86
    parent = tmp;
#line 86
    comp = winlink_cmp(elm, parent);
#line 86
    if (comp < 0) {
#line 86
      tmp = tmp->entry.rbe_left;
    } else
#line 86
    if (comp > 0) {
#line 86
      tmp = tmp->entry.rbe_right;
    } else {
#line 86
      return (tmp);
    }
  }
#line 86
  while (1) {
#line 86
    elm->entry.rbe_parent = parent;
#line 86
    tmp___0 = (struct winlink *)((void *)0);
#line 86
    elm->entry.rbe_right = tmp___0;
#line 86
    elm->entry.rbe_left = tmp___0;
#line 86
    elm->entry.rbe_color = 1;
#line 86
    break;
  }
#line 86
  if ((unsigned long )parent != (unsigned long )((void *)0)) {
#line 86
    if (comp < 0) {
#line 86
      parent->entry.rbe_left = elm;
    } else {
#line 86
      parent->entry.rbe_right = elm;
    }
#line 86
    while (1) {
#line 86
      break;
    }
  } else {
#line 86
    head->rbh_root = elm;
  }
#line 86
  winlinks_RB_INSERT_COLOR(head, elm);
#line 86
  return ((struct winlink *)((void *)0));
}
}
#line 86 "tmux_uaf_4.c"
struct winlink *winlinks_RB_REMOVE(struct winlinks *head , struct winlink *elm ) 
{ 
  struct winlink *child ;
  struct winlink *parent ;
  struct winlink *old ;
  int color ;
  struct winlink *left ;

  {
#line 86
  old = elm;
#line 86
  if ((unsigned long )elm->entry.rbe_left == (unsigned long )((void *)0)) {
#line 86
    child = elm->entry.rbe_right;
  } else
#line 86
  if ((unsigned long )elm->entry.rbe_right == (unsigned long )((void *)0)) {
#line 86
    child = elm->entry.rbe_left;
  } else {
#line 86
    elm = elm->entry.rbe_right;
#line 86
    while (1) {
#line 86
      left = elm->entry.rbe_left;
#line 86
      if (! ((unsigned long )left != (unsigned long )((void *)0))) {
#line 86
        break;
      }
#line 86
      elm = left;
    }
#line 86
    child = elm->entry.rbe_right;
#line 86
    parent = elm->entry.rbe_parent;
#line 86
    color = elm->entry.rbe_color;
#line 86
    if (child) {
#line 86
      child->entry.rbe_parent = parent;
    }
#line 86
    if (parent) {
#line 86
      if ((unsigned long )parent->entry.rbe_left == (unsigned long )elm) {
#line 86
        parent->entry.rbe_left = child;
      } else {
#line 86
        parent->entry.rbe_right = child;
      }
#line 86
      while (1) {
#line 86
        break;
      }
    } else {
#line 86
      head->rbh_root = child;
    }
#line 86
    if ((unsigned long )elm->entry.rbe_parent == (unsigned long )old) {
#line 86
      parent = elm;
    }
#line 86
    elm->entry = old->entry;
#line 86
    if (old->entry.rbe_parent) {
#line 86
      if ((unsigned long )(old->entry.rbe_parent)->entry.rbe_left == (unsigned long )old) {
#line 86
        (old->entry.rbe_parent)->entry.rbe_left = elm;
      } else {
#line 86
        (old->entry.rbe_parent)->entry.rbe_right = elm;
      }
#line 86
      while (1) {
#line 86
        break;
      }
    } else {
#line 86
      head->rbh_root = elm;
    }
#line 86
    (old->entry.rbe_left)->entry.rbe_parent = elm;
#line 86
    if (old->entry.rbe_right) {
#line 86
      (old->entry.rbe_right)->entry.rbe_parent = elm;
    }
#line 86
    if (parent) {
#line 86
      left = parent;
#line 86
      while (1) {
#line 86
        while (1) {
#line 86
          break;
        }
#line 86
        left = left->entry.rbe_parent;
#line 86
        if (! ((unsigned long )left != (unsigned long )((void *)0))) {
#line 86
          break;
        }
      }
    }
#line 86
    goto color;
  }
#line 86
  parent = elm->entry.rbe_parent;
#line 86
  color = elm->entry.rbe_color;
#line 86
  if (child) {
#line 86
    child->entry.rbe_parent = parent;
  }
#line 86
  if (parent) {
#line 86
    if ((unsigned long )parent->entry.rbe_left == (unsigned long )elm) {
#line 86
      parent->entry.rbe_left = child;
    } else {
#line 86
      parent->entry.rbe_right = child;
    }
#line 86
    while (1) {
#line 86
      break;
    }
  } else {
#line 86
    head->rbh_root = child;
  }
  color: 
#line 86
  if (color == 0) {
#line 86
    winlinks_RB_REMOVE_COLOR(head, parent, child);
  }
#line 86
  return (old);
}
}
#line 86 "tmux_uaf_4.c"
struct winlink *winlinks_RB_FIND(struct winlinks *head , struct winlink *elm ) 
{ 
  struct winlink *tmp ;
  int comp ;

  {
#line 86
  tmp = head->rbh_root;
#line 86
  while (tmp) {
#line 86
    comp = winlink_cmp(elm, tmp);
#line 86
    if (comp < 0) {
#line 86
      tmp = tmp->entry.rbe_left;
    } else
#line 86
    if (comp > 0) {
#line 86
      tmp = tmp->entry.rbe_right;
    } else {
#line 86
      return (tmp);
    }
  }
#line 86
  return ((struct winlink *)((void *)0));
}
}
#line 86 "tmux_uaf_4.c"
struct winlink *winlinks_RB_NFIND(struct winlinks *head , struct winlink *elm ) 
{ 
  struct winlink *tmp ;
  struct winlink *res ;
  int comp ;

  {
#line 86
  tmp = head->rbh_root;
#line 86
  res = (struct winlink *)((void *)0);
#line 86
  while (tmp) {
#line 86
    comp = winlink_cmp(elm, tmp);
#line 86
    if (comp < 0) {
#line 86
      res = tmp;
#line 86
      tmp = tmp->entry.rbe_left;
    } else
#line 86
    if (comp > 0) {
#line 86
      tmp = tmp->entry.rbe_right;
    } else {
#line 86
      return (tmp);
    }
  }
#line 86
  return (res);
}
}
#line 86 "tmux_uaf_4.c"
struct winlink *winlinks_RB_NEXT(struct winlink *elm ) 
{ 


  {
#line 86
  if (elm->entry.rbe_right) {
#line 86
    elm = elm->entry.rbe_right;
#line 86
    while (elm->entry.rbe_left) {
#line 86
      elm = elm->entry.rbe_left;
    }
  } else
#line 86
  if (elm->entry.rbe_parent) {
#line 86
    if ((unsigned long )elm == (unsigned long )(elm->entry.rbe_parent)->entry.rbe_left) {
#line 86
      elm = elm->entry.rbe_parent;
    } else {
#line 86
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 86
    while (1) {
#line 86
      if (elm->entry.rbe_parent) {
#line 86
        if (! ((unsigned long )elm == (unsigned long )(elm->entry.rbe_parent)->entry.rbe_right)) {
#line 86
          break;
        }
      } else {
#line 86
        break;
      }
#line 86
      elm = elm->entry.rbe_parent;
    }
#line 86
    elm = elm->entry.rbe_parent;
  }
#line 86
  return (elm);
}
}
#line 86 "tmux_uaf_4.c"
struct winlink *winlinks_RB_PREV(struct winlink *elm ) 
{ 


  {
#line 86
  if (elm->entry.rbe_left) {
#line 86
    elm = elm->entry.rbe_left;
#line 86
    while (elm->entry.rbe_right) {
#line 86
      elm = elm->entry.rbe_right;
    }
  } else
#line 86
  if (elm->entry.rbe_parent) {
#line 86
    if ((unsigned long )elm == (unsigned long )(elm->entry.rbe_parent)->entry.rbe_right) {
#line 86
      elm = elm->entry.rbe_parent;
    } else {
#line 86
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 86
    while (1) {
#line 86
      if (elm->entry.rbe_parent) {
#line 86
        if (! ((unsigned long )elm == (unsigned long )(elm->entry.rbe_parent)->entry.rbe_left)) {
#line 86
          break;
        }
      } else {
#line 86
        break;
      }
#line 86
      elm = elm->entry.rbe_parent;
    }
#line 86
    elm = elm->entry.rbe_parent;
  }
#line 86
  return (elm);
}
}
#line 86 "tmux_uaf_4.c"
struct winlink *winlinks_RB_MINMAX(struct winlinks *head , int val ) 
{ 
  struct winlink *tmp ;
  struct winlink *parent ;

  {
#line 86
  tmp = head->rbh_root;
#line 86
  parent = (struct winlink *)((void *)0);
#line 86
  while (tmp) {
#line 86
    parent = tmp;
#line 86
    if (val < 0) {
#line 86
      tmp = tmp->entry.rbe_left;
    } else {
#line 86
      tmp = tmp->entry.rbe_right;
    }
  }
#line 86
  return (parent);
}
}
#line 89 "tmux_uaf_4.c"
void *xrealloc(void *oldptr , size_t nmemb , size_t size ) 
{ 
  size_t newsize ;
  void *newptr ;

  {
#line 92
  newsize = nmemb * size;
#line 95
  if (newsize == 0UL) {
#line 96
    printf((char const   * __restrict  )"zero size%s", "");
#line 96
    exit(1);
  }
#line 97
  if ((size_t )(1 << 30) / nmemb < size) {
#line 98
    printf((char const   * __restrict  )"nmemb * size > SIZE_MAX%s", "");
#line 98
    exit(1);
  }
#line 99
  newptr = realloc(oldptr, newsize);
#line 99
  if ((unsigned long )newptr == (unsigned long )((void *)0)) {
#line 100
    printf((char const   * __restrict  )"xrealloc failed%s", "");
#line 100
    exit(1);
  }
#line 102
  return (newptr);
}
}
#line 105 "tmux_uaf_4.c"
struct winlink *winlink_find_by_index(struct winlinks *wwl , int idx ) 
{ 
  struct winlink wl ;
  struct winlink *tmp ;

  {
#line 110
  if (idx < 0) {
#line 111
    printf((char const   * __restrict  )"bad index%s", "");
#line 111
    exit(1);
  }
#line 113
  wl.idx = idx;
#line 114
  tmp = winlinks_RB_FIND(wwl, & wl);
#line 114
  return (tmp);
}
}
#line 117 "tmux_uaf_4.c"
u_int___0 winlink_count(struct winlinks *wwl ) 
{ 
  struct winlink *wl ;
  u_int___0 n ;

  {
#line 122
  n = (u_int___0 )0;
#line 123
  wl = winlinks_RB_MINMAX(wwl, -1);
#line 123
  while ((unsigned long )wl != (unsigned long )((void *)0)) {
#line 124
    n ++;
#line 123
    wl = winlinks_RB_NEXT(wl);
  }
#line 126
  return (n);
}
}
#line 129 "tmux_uaf_4.c"
int winlink_next_index(struct winlinks *wwl , int idx ) 
{ 
  int i ;
  struct winlink *tmp ;

  {
#line 134
  i = idx;
#line 135
  while (1) {
#line 136
    tmp = winlink_find_by_index(wwl, i);
#line 136
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 137
      return (i);
    }
#line 138
    if (i == 10000) {
#line 139
      i = 0;
    } else {
#line 141
      i ++;
    }
#line 135
    if (! (i != idx)) {
#line 135
      break;
    }
  }
#line 143
  return (-1);
}
}
#line 147 "tmux_uaf_4.c"
struct winlink *winlink_find_by_window(struct winlinks *wwl , struct window *w ) 
{ 
  struct winlink *wl ;

  {
#line 152
  wl = winlinks_RB_MINMAX(wwl, -1);
#line 152
  while ((unsigned long )wl != (unsigned long )((void *)0)) {
#line 153
    if ((unsigned long )wl->window == (unsigned long )w) {
#line 154
      return (wl);
    }
#line 152
    wl = winlinks_RB_NEXT(wl);
  }
#line 157
  return ((struct winlink *)((void *)0));
}
}
#line 160 "tmux_uaf_4.c"
struct winlink *cmd_find_pane(int arg , struct session **sp ) 
{ 
  struct session *s ;
  struct winlink *tmp ;

  {
#line 166
  if ((unsigned long )((void *)(& sessions)) == (unsigned long )((void *)0)) {
#line 167
    printf((char const   * __restrict  )"can\'t establish current session\n");
#line 168
    return ((struct winlink *)((void *)0));
  } else
#line 166
  if (sessions.num == 0U) {
#line 167
    printf((char const   * __restrict  )"can\'t establish current session\n");
#line 168
    return ((struct winlink *)((void *)0));
  }
#line 170
  s = *(sessions.list + 1);
#line 171
  if ((unsigned long )sp != (unsigned long )((void *)0)) {
#line 172
    *sp = s;
  }
#line 173
  if (arg) {
#line 174
    return (s->curw);
  }
#line 175
  tmp = winlinks_RB_NEXT(s->curw);
#line 175
  return (tmp);
}
}
#line 179 "tmux_uaf_4.c"
int session_has(struct session *s , struct window *w ) 
{ 
  struct winlink *wl ;

  {
#line 184
  wl = winlinks_RB_MINMAX(& s->windows, -1);
#line 184
  while ((unsigned long )wl != (unsigned long )((void *)0)) {
#line 185
    if ((unsigned long )wl->window == (unsigned long )w) {
#line 186
      return (1);
    }
#line 184
    wl = winlinks_RB_NEXT(wl);
  }
#line 188
  return (0);
}
}
#line 192 "tmux_uaf_4.c"
struct session_group *session_group_find(struct session *target ) 
{ 
  struct session_group *sg ;
  struct session *s ;

  {
#line 198
  sg = session_groups.tqh_first;
#line 198
  while (sg) {
#line 199
    s = sg->sessions.tqh_first;
#line 199
    while (s) {
#line 200
      if ((unsigned long )s == (unsigned long )target) {
#line 201
        return (sg);
      }
#line 199
      s = s->gentry.tqe_next;
    }
#line 198
    sg = sg->entry.tqe_next;
  }
#line 204
  return ((struct session_group *)((void *)0));
}
}
#line 211 "tmux_uaf_4.c"
void session_group_add(struct session *target , struct session *s ) 
{ 
  struct session_group *sg ;
  void *tmp ;

  {
#line 216
  sg = session_group_find(target);
#line 216
  if ((unsigned long )sg == (unsigned long )((void *)0)) {
#line 217
    tmp = malloc(sizeof(*sg));
#line 217
    sg = (struct session_group *)tmp;
#line 218
    while (1) {
#line 218
      sg->entry.tqe_next = (struct session_group *)((void *)0);
#line 218
      sg->entry.tqe_prev = session_groups.tqh_last;
#line 218
      *(session_groups.tqh_last) = sg;
#line 218
      session_groups.tqh_last = & sg->entry.tqe_next;
#line 218
      break;
    }
#line 219
    while (1) {
#line 219
      sg->sessions.tqh_first = (struct session *)((void *)0);
#line 219
      sg->sessions.tqh_last = & sg->sessions.tqh_first;
#line 219
      break;
    }
#line 220
    while (1) {
#line 220
      target->gentry.tqe_next = (struct session *)((void *)0);
#line 220
      target->gentry.tqe_prev = sg->sessions.tqh_last;
#line 220
      *(sg->sessions.tqh_last) = target;
#line 220
      sg->sessions.tqh_last = & target->gentry.tqe_next;
#line 220
      break;
    }
  }
#line 222
  while (1) {
#line 222
    s->gentry.tqe_next = (struct session *)((void *)0);
#line 222
    s->gentry.tqe_prev = sg->sessions.tqh_last;
#line 222
    *(sg->sessions.tqh_last) = s;
#line 222
    sg->sessions.tqh_last = & s->gentry.tqe_next;
#line 222
    break;
  }
#line 223
  return;
}
}
#line 225 "tmux_uaf_4.c"
struct winlink *winlink_add(struct winlinks *wwl , struct window *w , int idx ) 
{ 
  struct winlink *wl ;
  struct winlink *tmp ;
  void *tmp___0 ;

  {
#line 230
  if (idx < 0) {
#line 231
    idx = winlink_next_index(wwl, - idx - 1);
#line 231
    if (idx == -1) {
#line 232
      return ((struct winlink *)((void *)0));
    }
  } else {
#line 233
    tmp = winlink_find_by_index(wwl, idx);
#line 233
    if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 234
      return ((struct winlink *)((void *)0));
    }
  }
#line 236
  tmp___0 = calloc((size_t )1, sizeof(*wl));
#line 236
  wl = (struct winlink *)tmp___0;
#line 237
  wl->idx = idx;
#line 238
  wl->window = w;
#line 239
  winlinks_RB_INSERT(wwl, wl);
#line 241
  (w->references) ++;
#line 243
  return (wl);
}
}
#line 246 "tmux_uaf_4.c"
int window_index(struct window *s , u_int___0 *i ) 
{ 


  {
#line 249
  *i = (u_int___0 )0;
#line 249
  while (*i < windows.num) {
#line 250
    if ((unsigned long )s == (unsigned long )*(windows.list + *i)) {
#line 251
      return (0);
    }
#line 249
    (*i) ++;
  }
#line 253
  return (-1);
}
}
#line 257 "tmux_uaf_4.c"
void session_group_remove(struct session *s ) 
{ 
  struct session_group *sg ;

  {
#line 262
  sg = session_group_find(s);
#line 262
  if ((unsigned long )sg == (unsigned long )((void *)0)) {
#line 263
    return;
  }
#line 264
  while (1) {
#line 264
    if ((unsigned long )s->gentry.tqe_next != (unsigned long )((void *)0)) {
#line 264
      (s->gentry.tqe_next)->gentry.tqe_prev = s->gentry.tqe_prev;
    } else {
#line 264
      sg->sessions.tqh_last = s->gentry.tqe_prev;
    }
#line 264
    *(s->gentry.tqe_prev) = s->gentry.tqe_next;
#line 264
    break;
  }
#line 265
  if ((unsigned long )(sg->sessions.tqh_first)->gentry.tqe_next == (unsigned long )((void *)0)) {
#line 266
    while (1) {
#line 266
      if ((unsigned long )(sg->sessions.tqh_first)->gentry.tqe_next != (unsigned long )((void *)0)) {
#line 266
        ((sg->sessions.tqh_first)->gentry.tqe_next)->gentry.tqe_prev = (sg->sessions.tqh_first)->gentry.tqe_prev;
      } else {
#line 266
        sg->sessions.tqh_last = (sg->sessions.tqh_first)->gentry.tqe_prev;
      }
#line 266
      *((sg->sessions.tqh_first)->gentry.tqe_prev) = (sg->sessions.tqh_first)->gentry.tqe_next;
#line 266
      break;
    }
  }
#line 267
  if ((unsigned long )sg->sessions.tqh_first == (unsigned long )((void *)0)) {
#line 268
    while (1) {
#line 268
      if ((unsigned long )sg->entry.tqe_next != (unsigned long )((void *)0)) {
#line 268
        (sg->entry.tqe_next)->entry.tqe_prev = sg->entry.tqe_prev;
      } else {
#line 268
        session_groups.tqh_last = sg->entry.tqe_prev;
      }
#line 268
      *(sg->entry.tqe_prev) = sg->entry.tqe_next;
#line 268
      break;
    }
#line 269
    free((void *)sg);
  }
#line 271
  return;
}
}
#line 274 "tmux_uaf_4.c"
struct session *session_find(char const   *name ) 
{ 
  struct session *s ;
  u_int___0 i ;
  int tmp ;

  {
#line 280
  i = (u_int___0 )0;
#line 280
  while (i < sessions.num) {
#line 281
    s = *(sessions.list + i);
#line 282
    if ((unsigned long )s != (unsigned long )((void *)0)) {
#line 282
      tmp = strcmp((char const   *)s->name, name);
#line 282
      if (tmp == 0) {
#line 283
        return (s);
      }
    }
#line 280
    i ++;
  }
#line 286
  return ((struct session *)((void *)0));
}
}
#line 291 "tmux_uaf_4.c"
int session_index(struct session *s , u_int___0 *i ) 
{ 


  {
#line 294
  *i = (u_int___0 )0;
#line 294
  while (*i < sessions.num) {
#line 295
    if ((unsigned long )s == (unsigned long )*(sessions.list + *i)) {
#line 296
      return (0);
    }
#line 294
    (*i) ++;
  }
#line 298
  return (-1);
}
}
#line 301 "tmux_uaf_4.c"
void winlink_stack_remove(struct winlink_stack *stack , struct winlink *wl ) 
{ 
  struct winlink *wl2 ;

  {
#line 306
  if ((unsigned long )wl == (unsigned long )((void *)0)) {
#line 307
    return;
  }
#line 309
  wl2 = stack->tqh_first;
#line 309
  while (wl2) {
#line 310
    if ((unsigned long )wl2 == (unsigned long )wl) {
#line 311
      while (1) {
#line 311
        if ((unsigned long )wl->sentry.tqe_next != (unsigned long )((void *)0)) {
#line 311
          (wl->sentry.tqe_next)->sentry.tqe_prev = wl->sentry.tqe_prev;
        } else {
#line 311
          stack->tqh_last = wl->sentry.tqe_prev;
        }
#line 311
        *(wl->sentry.tqe_prev) = wl->sentry.tqe_next;
#line 311
        break;
      }
#line 312
      return;
    }
#line 309
    wl2 = wl2->sentry.tqe_next;
  }
#line 315
  return;
}
}
#line 317 "tmux_uaf_4.c"
void winlink_stack_push(struct winlink_stack *stack , struct winlink *wl ) 
{ 
  struct winlink *tmp ;

  {
#line 320
  if ((unsigned long )wl == (unsigned long )((void *)0)) {
#line 321
    return;
  }
#line 323
  winlink_stack_remove(stack, wl);
#line 324
  while (1) {
#line 324
    tmp = stack->tqh_first;
#line 324
    wl->sentry.tqe_next = tmp;
#line 324
    if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 324
      (stack->tqh_first)->sentry.tqe_prev = & wl->sentry.tqe_next;
    } else {
#line 324
      stack->tqh_last = & wl->sentry.tqe_next;
    }
#line 324
    stack->tqh_first = wl;
#line 324
    wl->sentry.tqe_prev = & stack->tqh_first;
#line 324
    break;
  }
#line 325
  return;
}
}
#line 327 "tmux_uaf_4.c"
void window_destroy(struct window *w ) 
{ 
  u_int___0 i ;
  int tmp ;

  {
#line 332
  tmp = window_index(w, & i);
#line 332
  if (tmp != 0) {
#line 333
    printf((char const   * __restrict  )"index not found%s\n", "");
#line 333
    exit(1);
  }
#line 334
  while (1) {
#line 334
    *(windows.list + i) = (struct window *)((void *)0);
#line 334
    break;
  }
#line 335
  while (1) {
#line 335
    if ((unsigned long )((void *)(& windows)) == (unsigned long )((void *)0)) {
#line 335
      break;
    } else
#line 335
    if (windows.num == 0U) {
#line 335
      break;
    } else
#line 335
    if (! ((unsigned long )*(windows.list + (windows.num - 1U)) == (unsigned long )((void *)0))) {
#line 335
      break;
    }
#line 336
    while (1) {
#line 336
      if (windows.num > 1U) {
#line 336
        (windows.num) --;
      } else {
#line 336
        while (1) {
#line 336
          free((void *)windows.list);
#line 336
          while (1) {
#line 336
            windows.num = (u_int___0 )0;
#line 336
            windows.list = (struct window **)((void *)0);
#line 336
            windows.space = (size_t )0;
#line 336
            break;
          }
#line 336
          break;
        }
      }
#line 336
      break;
    }
  }
#line 338
  if ((unsigned long )w->name != (unsigned long )((void *)0)) {
#line 339
    free((void *)w->name);
  }
#line 340
  free((void *)w);
#line 341
  return;
}
}
#line 343 "tmux_uaf_4.c"
void winlink_remove(struct winlinks *wwl , struct winlink *wl ) 
{ 
  struct window *w ;

  {
#line 346
  w = wl->window;
#line 348
  winlinks_RB_REMOVE(wwl, wl);
#line 349
  if ((unsigned long )wl->status_text != (unsigned long )((void *)0)) {
#line 350
    free((void *)wl->status_text);
  }
#line 351
  free((void *)wl);
#line 353
  if (w->references == 0U) {
#line 354
    printf((char const   * __restrict  )"bad reference count%s\n", "");
#line 354
    exit(1);
  }
#line 355
  (w->references) --;
#line 356
  if (w->references == 0U) {
#line 357
    window_destroy(w);
  }
#line 358
  return;
}
}
#line 365 "tmux_uaf_4.c"
void session_group_synchronize1(struct session *target , struct session *s ) 
{ 
  struct winlinks old_windows ;
  struct winlinks *ww ;
  struct winlink_stack old_lastw ;
  struct winlink *wl ;
  struct winlink *wl2 ;

  {
#line 374
  ww = & target->windows;
#line 375
  if ((unsigned long )ww->rbh_root == (unsigned long )((void *)0)) {
#line 376
    return;
  }
#line 379
  memcpy((void * __restrict  )(& old_windows), (void const   * __restrict  )(& s->windows),
         sizeof(old_windows));
#line 380
  while (1) {
#line 380
    s->windows.rbh_root = (struct winlink *)((void *)0);
#line 380
    break;
  }
#line 383
  wl = winlinks_RB_MINMAX(ww, -1);
#line 383
  while ((unsigned long )wl != (unsigned long )((void *)0)) {
#line 384
    winlink_add(& s->windows, wl->window, wl->idx);
#line 383
    wl = winlinks_RB_NEXT(wl);
  }
#line 387
  memcpy((void * __restrict  )(& old_lastw), (void const   * __restrict  )(& s->lastw),
         sizeof(old_lastw));
#line 388
  while (1) {
#line 388
    s->lastw.tqh_first = (struct winlink *)((void *)0);
#line 388
    s->lastw.tqh_last = & s->lastw.tqh_first;
#line 388
    break;
  }
#line 389
  wl = old_lastw.tqh_first;
#line 389
  while (wl) {
#line 390
    wl2 = winlink_find_by_index(& s->windows, wl->idx);
#line 391
    if ((unsigned long )wl2 != (unsigned long )((void *)0)) {
#line 392
      while (1) {
#line 392
        wl2->sentry.tqe_next = (struct winlink *)((void *)0);
#line 392
        wl2->sentry.tqe_prev = s->lastw.tqh_last;
#line 392
        *(s->lastw.tqh_last) = wl2;
#line 392
        s->lastw.tqh_last = & wl2->sentry.tqe_next;
#line 392
        break;
      }
    }
#line 389
    wl = wl->sentry.tqe_next;
  }
#line 394
  s->curw = s->lastw.tqh_first;
#line 397
  while (! ((unsigned long )old_windows.rbh_root == (unsigned long )((void *)0))) {
#line 398
    wl = old_windows.rbh_root;
#line 399
    winlink_remove(& old_windows, wl);
  }
#line 401
  return;
}
}
#line 404 "tmux_uaf_4.c"
void session_group_synchronize_to(struct session *s ) 
{ 
  struct session_group *sg ;
  struct session *target ;

  {
#line 410
  sg = session_group_find(s);
#line 410
  if ((unsigned long )sg == (unsigned long )((void *)0)) {
#line 411
    return;
  }
#line 413
  target = (struct session *)((void *)0);
#line 414
  target = sg->sessions.tqh_first;
#line 414
  while (target) {
#line 415
    if ((unsigned long )target != (unsigned long )s) {
#line 416
      break;
    }
#line 414
    target = target->gentry.tqe_next;
  }
#line 418
  session_group_synchronize1(target, s);
#line 419
  return;
}
}
#line 422 "tmux_uaf_4.c"
void session_group_synchronize_from(struct session *target ) 
{ 
  struct session_group *sg ;
  struct session *s ;

  {
#line 428
  sg = session_group_find(target);
#line 428
  if ((unsigned long )sg == (unsigned long )((void *)0)) {
#line 429
    return;
  }
#line 431
  s = sg->sessions.tqh_first;
#line 431
  while (s) {
#line 432
    if ((unsigned long )s != (unsigned long )target) {
#line 433
      session_group_synchronize1(target, s);
    }
#line 431
    s = s->gentry.tqe_next;
  }
#line 435
  return;
}
}
#line 438 "tmux_uaf_4.c"
void session_destroy(struct session *s ) 
{ 
  u_int___0 i ;
  int tmp ;

  {
#line 443
  printf((char const   * __restrict  )"session %s destroyed\n", s->name);
#line 445
  tmp = session_index(s, & i);
#line 445
  if (tmp != 0) {
#line 446
    printf((char const   * __restrict  )"session not found%s\n", "");
#line 446
    exit(1);
  }
#line 447
  while (1) {
#line 447
    *(sessions.list + i) = (struct session *)((void *)0);
#line 447
    break;
  }
#line 448
  while (1) {
#line 448
    if ((unsigned long )((void *)(& sessions)) == (unsigned long )((void *)0)) {
#line 448
      break;
    } else
#line 448
    if (sessions.num == 0U) {
#line 448
      break;
    } else
#line 448
    if (! ((unsigned long )*(sessions.list + (sessions.num - 1U)) == (unsigned long )((void *)0))) {
#line 448
      break;
    }
#line 449
    while (1) {
#line 449
      if (sessions.num > 1U) {
#line 449
        (sessions.num) --;
      } else {
#line 449
        while (1) {
#line 449
          free((void *)sessions.list);
#line 449
          while (1) {
#line 449
            sessions.num = (u_int___0 )0;
#line 449
            sessions.list = (struct session **)((void *)0);
#line 449
            sessions.space = (size_t )0;
#line 449
            break;
          }
#line 449
          break;
        }
      }
#line 449
      break;
    }
  }
#line 451
  session_group_remove(s);
#line 453
  while (! ((unsigned long )s->lastw.tqh_first == (unsigned long )((void *)0))) {
#line 454
    winlink_stack_remove(& s->lastw, s->lastw.tqh_first);
  }
#line 455
  while (! ((unsigned long )s->windows.rbh_root == (unsigned long )((void *)0))) {
#line 456
    winlink_remove(& s->windows, s->windows.rbh_root);
  }
#line 458
  free((void *)s->name);
#line 459
  free((void *)s);
#line 460
  return;
}
}
#line 463 "tmux_uaf_4.c"
int session_detach(struct session *s , struct winlink *wl ) 
{ 


  {
#line 466
  winlink_stack_remove(& s->lastw, wl);
#line 467
  winlink_remove(& s->windows, wl);
#line 468
  session_group_synchronize_from(s);
#line 469
  if ((unsigned long )s->windows.rbh_root == (unsigned long )((void *)0)) {
#line 470
    session_destroy(s);
#line 471
    return (1);
  }
#line 473
  return (0);
}
}
#line 476 "tmux_uaf_4.c"
void server_destroy_session_group(struct session *s ) 
{ 
  struct session_group *sg ;

  {
#line 481
  sg = session_group_find(s);
#line 481
  if ((unsigned long )sg == (unsigned long )((void *)0)) {
#line 482
    return;
  } else {
#line 484
    while (1) {
#line 484
      if ((unsigned long )sg->entry.tqe_next != (unsigned long )((void *)0)) {
#line 484
        (sg->entry.tqe_next)->entry.tqe_prev = sg->entry.tqe_prev;
      } else {
#line 484
        session_groups.tqh_last = sg->entry.tqe_prev;
      }
#line 484
      *(sg->entry.tqe_prev) = sg->entry.tqe_next;
#line 484
      break;
    }
#line 485
    free((void *)sg);
  }
#line 487
  return;
}
}
#line 489 "tmux_uaf_4.c"
void server_kill_window(struct window *w ) 
{ 
  struct session *s ;
  struct winlink *wl ;
  u_int___0 i ;
  int tmp ;
  int tmp___0 ;

  {
#line 496
  i = (u_int___0 )0;
#line 496
  while (i < sessions.num) {
#line 497
    s = *(sessions.list + i);
#line 498
    if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 499
      goto __Cont;
    } else {
#line 498
      tmp = session_has(s, w);
#line 498
      if (! tmp) {
#line 499
        goto __Cont;
      }
    }
#line 500
    while (1) {
#line 500
      wl = winlink_find_by_window(& s->windows, w);
#line 500
      if (! ((unsigned long )wl != (unsigned long )((void *)0))) {
#line 500
        break;
      }
#line 501
      tmp___0 = session_detach(s, wl);
#line 501
      if (tmp___0) {
#line 502
        server_destroy_session_group(s);
#line 503
        break;
      }
    }
    __Cont: /* CIL Label */ 
#line 496
    i ++;
  }
#line 507
  return;
}
}
#line 510 "tmux_uaf_4.c"
int session_select(struct session *s , int idx ) 
{ 
  struct winlink *wl ;

  {
#line 515
  wl = winlink_find_by_index(& s->windows, idx);
#line 516
  if ((unsigned long )wl == (unsigned long )((void *)0)) {
#line 517
    return (-1);
  }
#line 518
  if ((unsigned long )wl == (unsigned long )s->curw) {
#line 519
    return (1);
  }
#line 520
  winlink_stack_remove(& s->lastw, wl);
#line 521
  winlink_stack_push(& s->lastw, s->curw);
#line 522
  s->curw = wl;
#line 523
  return (0);
}
}
#line 526 "tmux_uaf_4.c"
int join_pane_exec(void) 
{ 
  struct session *dst_s ;
  struct winlink *src_wl ;
  struct winlink *dst_wl ;
  struct window *src_w ;
  struct window *dst_w ;

  {
#line 532
  dst_wl = cmd_find_pane(0, & dst_s);
#line 532
  if ((unsigned long )dst_wl == (unsigned long )((void *)0)) {
#line 533
    return (-1);
  }
#line 534
  dst_w = dst_wl->window;
#line 536
  src_wl = cmd_find_pane(1, (struct session **)((void *)0));
#line 536
  if ((unsigned long )src_wl == (unsigned long )((void *)0)) {
#line 537
    return (-1);
  }
#line 538
  src_w = src_wl->window;
#line 540
  if ((unsigned long )src_w == (unsigned long )dst_w) {
#line 541
    printf((char const   * __restrict  )"can\'t join a pane to its own window\n");
#line 542
    return (-1);
  }
#line 544
  server_kill_window(src_w);
#line 546
  session_select(dst_s, dst_wl->idx);
#line 548
  return (0);
}
}
#line 551 "tmux_uaf_4.c"
struct window *window_create1(u_int___0 sx , u_int___0 sy ) 
{ 
  struct window *w ;
  u_int___0 i ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 557
  tmp = malloc(sizeof(*w));
#line 557
  w = (struct window *)tmp;
#line 558
  w->name = (char *)((void *)0);
#line 559
  w->flags = 0;
#line 561
  w->active = (struct window_pane *)((void *)0);
#line 563
  w->lastlayout = -1;
#line 564
  w->layout_root = (struct layout_cell *)((void *)0);
#line 566
  w->sx = sx;
#line 567
  w->sy = sy;
#line 569
  i = (u_int___0 )0;
#line 569
  while (i < windows.num) {
#line 570
    if ((unsigned long )*(windows.list + i) == (unsigned long )((void *)0)) {
#line 571
      while (1) {
#line 571
        *(windows.list + i) = w;
#line 571
        break;
      }
#line 572
      break;
    }
#line 569
    i ++;
  }
#line 575
  if (i == windows.num) {
#line 576
    while (1) {
#line 576
      while (1) {
#line 576
        if ((u_int___0 )((1 << 30) - 1) < windows.num) {
#line 576
          printf((char const   * __restrict  )"number too big%s", "");
#line 576
          exit(1);
        }
#line 576
        if ((unsigned long )((u_int___0 )(1 << 30) / (windows.num + 1U)) < sizeof(*(windows.list))) {
#line 576
          printf((char const   * __restrict  )"size too big%s", "");
#line 576
          exit(1);
        }
#line 576
        if (windows.space == 0UL) {
#line 576
          windows.space = 10UL * sizeof(*(windows.list));
#line 576
          tmp___0 = xrealloc((void *)windows.list, (size_t )1, windows.space);
#line 576
          windows.list = (struct window **)tmp___0;
        }
#line 576
        while (windows.space <= (unsigned long )(windows.num + 1U) * sizeof(*(windows.list))) {
#line 576
          tmp___1 = xrealloc((void *)windows.list, (size_t )2, windows.space);
#line 576
          windows.list = (struct window **)tmp___1;
#line 576
          windows.space *= 2UL;
        }
#line 576
        break;
      }
#line 576
      *(windows.list + windows.num) = w;
#line 576
      (windows.num) ++;
#line 576
      break;
    }
  }
#line 577
  w->references = (u_int___0 )0;
#line 579
  return (w);
}
}
#line 583 "tmux_uaf_4.c"
struct winlink *session_attach(struct session *s , struct window *w , int idx , char **cause ) 
{ 
  struct winlink *wl ;

  {
#line 588
  wl = winlink_add(& s->windows, w, idx);
#line 588
  if ((unsigned long )wl == (unsigned long )((void *)0)) {
#line 589
    printf((char const   * __restrict  )"index in use: %d\n", idx);
  }
#line 590
  session_group_synchronize_from(s);
#line 591
  return (wl);
}
}
#line 595 "tmux_uaf_4.c"
struct winlink *session_new(struct session *s , char const   *name , char const   *cmd ,
                            char const   *cwd , int idx , char **cause ) 
{ 
  struct window *w ;
  struct winlink *tmp ;

  {
#line 604
  w = window_create1(s->sx, s->sy);
#line 605
  if ((unsigned long )w == (unsigned long )((void *)0)) {
#line 606
    return ((struct winlink *)((void *)0));
  }
#line 609
  tmp = session_attach(s, w, idx, cause);
#line 609
  return (tmp);
}
}
#line 613 "tmux_uaf_4.c"
struct session *session_create(char const   *name , char const   *cmd , char const   *cwd ,
                               struct environ *env , struct termios *tio , int idx ,
                               u_int___0 sx , u_int___0 sy , char **cause ) 
{ 
  struct session *s ;
  u_int___0 i ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  struct winlink *tmp___2 ;

  {
#line 621
  tmp = malloc(sizeof(*s));
#line 621
  s = (struct session *)tmp;
#line 622
  s->references = 0;
#line 623
  s->flags = 0;
#line 625
  s->curw = (struct winlink *)((void *)0);
#line 626
  while (1) {
#line 626
    s->lastw.tqh_first = (struct winlink *)((void *)0);
#line 626
    s->lastw.tqh_last = & s->lastw.tqh_first;
#line 626
    break;
  }
#line 627
  while (1) {
#line 627
    s->windows.rbh_root = (struct winlink *)((void *)0);
#line 627
    break;
  }
#line 629
  s->tio = (struct termios *)((void *)0);
#line 630
  s->sx = sx;
#line 631
  s->sy = sy;
#line 633
  i = (u_int___0 )0;
#line 633
  while (i < sessions.num) {
#line 634
    if ((unsigned long )*(sessions.list + i) == (unsigned long )((void *)0)) {
#line 635
      while (1) {
#line 635
        *(sessions.list + i) = s;
#line 635
        break;
      }
#line 636
      break;
    }
#line 633
    i ++;
  }
#line 639
  if (i == sessions.num) {
#line 640
    while (1) {
#line 640
      while (1) {
#line 640
        if ((u_int___0 )((1 << 30) - 1) < sessions.num) {
#line 640
          printf((char const   * __restrict  )"number too big%s", "");
#line 640
          exit(1);
        }
#line 640
        if ((unsigned long )((u_int___0 )(1 << 30) / (sessions.num + 1U)) < sizeof(*(sessions.list))) {
#line 640
          printf((char const   * __restrict  )"size too big%s", "");
#line 640
          exit(1);
        }
#line 640
        if (sessions.space == 0UL) {
#line 640
          sessions.space = 10UL * sizeof(*(sessions.list));
#line 640
          tmp___0 = xrealloc((void *)sessions.list, (size_t )1, sessions.space);
#line 640
          sessions.list = (struct session **)tmp___0;
        }
#line 640
        while (sessions.space <= (unsigned long )(sessions.num + 1U) * sizeof(*(sessions.list))) {
#line 640
          tmp___1 = xrealloc((void *)sessions.list, (size_t )2, sessions.space);
#line 640
          sessions.list = (struct session **)tmp___1;
#line 640
          sessions.space *= 2UL;
        }
#line 640
        break;
      }
#line 640
      *(sessions.list + sessions.num) = s;
#line 640
      (sessions.num) ++;
#line 640
      break;
    }
  }
#line 641
  if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 642
    printf((char const   * __restrict  )"no name%s\n", "");
#line 642
    exit(1);
  }
#line 643
  s->name = strdup(name);
#line 645
  if ((unsigned long )cmd != (unsigned long )((void *)0)) {
#line 646
    tmp___2 = session_new(s, (char const   *)((void *)0), cmd, cwd, idx, cause);
#line 646
    if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
#line 647
      session_destroy(s);
#line 648
      return ((struct session *)((void *)0));
    }
#line 650
    session_select(s, (s->windows.rbh_root)->idx);
  }
#line 652
  printf((char const   * __restrict  )"session %s created\n", s->name);
#line 654
  return (s);
}
}
#line 657 "tmux_uaf_4.c"
int main(int argc , char **argv ) 
{ 
  struct session *s ;
  struct session *groupwith ;
  struct window *w ;
  char *target ;
  char *cmd ;
  char *name ;
  char *cause ;
  int idx ;
  int sx ;
  int sy ;
  int i ;
  int tmp ;
  int tmp___0 ;

  {
#line 663
  idx = 0;
#line 665
  while (1) {
#line 665
    windows.num = (u_int___0 )0;
#line 665
    windows.list = (struct window **)((void *)0);
#line 665
    windows.space = (size_t )0;
#line 665
    break;
  }
#line 666
  while (1) {
#line 666
    sessions.num = (u_int___0 )0;
#line 666
    sessions.list = (struct session **)((void *)0);
#line 666
    sessions.space = (size_t )0;
#line 666
    break;
  }
#line 667
  while (1) {
#line 667
    session_groups.tqh_first = (struct session_group *)((void *)0);
#line 667
    session_groups.tqh_last = & session_groups.tqh_first;
#line 667
    break;
  }
#line 669
  i = 0;
#line 669
  while (i < argc) {
#line 671
    if ((int )*(*(argv + i) + 0) == 116) {
#line 671
      if (i > 0) {
#line 672
        target = strdup((char const   *)*(argv + (i - 1)));
      } else {
#line 674
        target = (char *)((void *)0);
      }
    } else {
#line 674
      target = (char *)((void *)0);
    }
#line 676
    groupwith = session_find((char const   *)target);
#line 678
    if ((unsigned long )target == (unsigned long )((void *)0)) {
#line 679
      cmd = strdup("cmd");
    } else {
#line 681
      cmd = (char *)((void *)0);
    }
#line 683
    free((void *)target);
#line 685
    name = strdup((char const   *)*(argv + i));
#line 686
    tmp = idx;
#line 686
    idx ++;
#line 686
    s = session_create((char const   *)name, (char const   *)cmd, "cwd", (struct environ *)((void *)0),
                       (struct termios *)((void *)0), tmp, (u_int___0 )sx, (u_int___0 )sy,
                       & cause);
#line 687
    w = window_create1((u_int___0 )sx, (u_int___0 )sy);
#line 688
    tmp___0 = idx;
#line 688
    idx ++;
#line 688
    session_attach(s, w, tmp___0, & cause);
#line 689
    free((void *)cmd);
#line 690
    if ((unsigned long )groupwith != (unsigned long )((void *)0)) {
#line 691
      session_group_add(groupwith, s);
#line 692
      session_group_synchronize_to(s);
#line 693
      session_select(s, (s->windows.rbh_root)->idx);
    }
#line 669
    i ++;
  }
#line 697
  join_pane_exec();
#line 698
  while (1) {
#line 698
    if ((unsigned long )((void *)(& sessions)) == (unsigned long )((void *)0)) {
#line 698
      break;
    } else
#line 698
    if (sessions.num == 0U) {
#line 698
      break;
    }
#line 699
    session_destroy(*(sessions.list + 0));
  }
#line 701
  return (0);
}
}
