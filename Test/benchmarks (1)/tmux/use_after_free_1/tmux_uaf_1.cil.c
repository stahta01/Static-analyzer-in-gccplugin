/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

#line 216 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h"
typedef unsigned long size_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 192 "../stdio.h"
typedef unsigned short u_short___0;
#line 193 "../stdio.h"
typedef unsigned int u_int___0;
#line 204 "../stdio.h"
typedef unsigned char u_char___0;
#line 210 "../stdio.h"
typedef int pid_t___0;
#line 39 "../tmux.h"
typedef char bitstr_t;
#line 41 "../tmux.h"
struct event {

};
#line 42 "../tmux.h"
struct termios {

};
#line 48
struct args;
#line 48
struct args;
#line 49
struct client;
#line 49
struct client;
#line 51
struct cmdq_item;
#line 51
struct cmdq_item;
#line 52
struct cmdq_list;
#line 52
struct cmdq_list;
#line 53
struct environ;
#line 53
struct environ;
#line 54
struct format_job_tree;
#line 54
struct format_job_tree;
#line 55
struct input_ctx;
#line 55
struct input_ctx;
#line 57
struct mouse_event;
#line 57
struct mouse_event;
#line 58
struct options;
#line 58
struct options;
#line 59
struct options_entry;
#line 59
struct options_entry;
#line 60
struct session;
#line 60
struct session;
#line 61
struct tmuxpeer;
#line 61
struct tmuxpeer;
#line 138 "../tmux.h"
typedef unsigned long long key_code;
#line 470 "../tmux.h"
struct options_tree {
   struct options_entry *rbh_root ;
};
#line 470 "../tmux.h"
struct options {
   struct options_tree tree ;
   struct options *parent ;
};
#line 540 "../tmux.h"
struct utf8_data {
   u_char___0 data[9] ;
   u_char___0 have ;
   u_char___0 size ;
   u_char___0 width ;
};
#line 582 "../tmux.h"
struct grid_cell {
   u_char___0 flags ;
   u_short___0 attr ;
   int fg ;
   int bg ;
   struct utf8_data data ;
};
#line 589 "../tmux.h"
struct __anonstruct_data_29 {
   u_char___0 attr ;
   u_char___0 fg ;
   u_char___0 bg ;
   u_char___0 data ;
};
#line 589 "../tmux.h"
union __anonunion____missing_field_name_28 {
   u_int___0 offset ;
   struct __anonstruct_data_29 data ;
};
#line 589 "../tmux.h"
struct grid_cell_entry {
   u_char___0 flags ;
   union __anonunion____missing_field_name_28 __annonCompField1 ;
};
#line 603 "../tmux.h"
struct grid_line {
   u_int___0 cellused ;
   u_int___0 cellsize ;
   struct grid_cell_entry *celldata ;
   u_int___0 extdsize ;
   struct grid_cell *extddata ;
   int flags ;
};
#line 615 "../tmux.h"
struct grid {
   int flags ;
   u_int___0 sx ;
   u_int___0 sy ;
   u_int___0 hscrolled ;
   u_int___0 hsize ;
   u_int___0 hlimit ;
   struct grid_line *linedata ;
};
#line 630
struct cmd_list;
#line 643
struct bufferevent;
#line 668
enum __anonenum_lineflag_33 {
    LINE_SEL_NONE = 0,
    LINE_SEL_LEFT_RIGHT = 1,
    LINE_SEL_RIGHT_LEFT = 2
} ;
#line 668 "../tmux.h"
struct screen_sel {
   int flag ;
   int hidden ;
   int rectflag ;
   enum __anonenum_lineflag_33 lineflag ;
   int modekeys ;
   u_int___0 sx ;
   u_int___0 sy ;
   u_int___0 ex ;
   u_int___0 ey ;
   struct grid_cell cell ;
};
#line 690
struct screen_titles;
#line 690
struct screen_titles;
#line 691 "../tmux.h"
struct screen {
   char *title ;
   struct screen_titles *titles ;
   struct grid *grid ;
   u_int___0 cx ;
   u_int___0 cy ;
   u_int___0 cstyle ;
   char *ccolour ;
   u_int___0 rupper ;
   u_int___0 rlower ;
   u_int___0 hsize ;
   int mode ;
   bitstr_t *tabs ;
   struct screen_sel sel ;
};
#line 716
struct screen_write_collect_item;
#line 716
struct screen_write_collect_item;
#line 717
struct screen_write_collect_line;
#line 717
struct screen_write_collect_line;
#line 718
struct window_pane;
#line 718 "../tmux.h"
struct screen_write_ctx {
   struct window_pane *wp ;
   struct screen *s ;
   struct screen_write_collect_item *item ;
   struct screen_write_collect_line *list ;
   u_int___0 scrolled ;
   u_int___0 bg ;
   u_int___0 cells ;
   u_int___0 written ;
   u_int___0 skipped ;
};
#line 763
struct winlink;
#line 785
struct window;
#line 785
struct layout_cell;
#line 785
struct window_mode;
#line 785 "../tmux.h"
struct __anonstruct_entry_34 {
   struct window_pane *tqe_next ;
   struct window_pane **tqe_prev ;
};
#line 785 "../tmux.h"
struct __anonstruct_tree_entry_35 {
   struct window_pane *rbe_left ;
   struct window_pane *rbe_right ;
   struct window_pane *rbe_parent ;
   int rbe_color ;
};
#line 785 "../tmux.h"
struct window_pane {
   u_int___0 id ;
   u_int___0 active_point ;
   struct window *window ;
   struct layout_cell *layout_cell ;
   struct layout_cell *saved_layout_cell ;
   u_int___0 sx ;
   u_int___0 sy ;
   u_int___0 osx ;
   u_int___0 osy ;
   u_int___0 xoff ;
   u_int___0 yoff ;
   int flags ;
   int argc ;
   char **argv ;
   char *shell ;
   char const   *cwd ;
   pid_t___0 pid ;
   char tty[10] ;
   int status ;
   int fd ;
   struct bufferevent *event ;
   struct event resize_timer ;
   struct input_ctx *ictx ;
   struct grid_cell colgc ;
   int *palette ;
   int pipe_fd ;
   struct bufferevent *pipe_event ;
   size_t pipe_off ;
   struct screen *screen ;
   struct screen base ;
   struct screen status_screen ;
   size_t status_size ;
   u_int___0 saved_cx ;
   u_int___0 saved_cy ;
   struct grid *saved_grid ;
   struct grid_cell saved_cell ;
   struct window_mode  const  *mode ;
   void *modedata ;
   struct event modetimer ;
   time_t modelast ;
   u_int___0 modeprefix ;
   char *searchstr ;
   struct __anonstruct_entry_34 entry ;
   struct __anonstruct_tree_entry_35 tree_entry ;
};
#line 862 "../tmux.h"
struct window_panes {
   struct window_pane *tqh_first ;
   struct window_pane **tqh_last ;
};
#line 919 "../tmux.h"
struct __anonstruct_entry_36 {
   struct winlink *rbe_left ;
   struct winlink *rbe_right ;
   struct winlink *rbe_parent ;
   int rbe_color ;
};
#line 919 "../tmux.h"
struct __anonstruct_wentry_37 {
   struct winlink *tqe_next ;
   struct winlink **tqe_prev ;
};
#line 919 "../tmux.h"
struct __anonstruct_sentry_38 {
   struct winlink *tqe_next ;
   struct winlink **tqe_prev ;
};
#line 919 "../tmux.h"
struct winlink {
   int idx ;
   struct session *session ;
   struct window *window ;
   size_t status_width ;
   struct grid_cell status_cell ;
   char *status_text ;
   int flags ;
   struct __anonstruct_entry_36 entry ;
   struct __anonstruct_wentry_37 wentry ;
   struct __anonstruct_sentry_38 sentry ;
};
#line 938 "../tmux.h"
struct winlinks {
   struct winlink *rbh_root ;
};
#line 939 "../tmux.h"
struct winlink_stack {
   struct winlink *tqh_first ;
   struct winlink **tqh_last ;
};
#line 942
enum layout_type {
    LAYOUT_LEFTRIGHT = 0,
    LAYOUT_TOPBOTTOM = 1,
    LAYOUT_WINDOWPANE = 2
} ;
#line 949 "../tmux.h"
struct layout_cells {
   struct layout_cell *tqh_first ;
   struct layout_cell **tqh_last ;
};
#line 952 "../tmux.h"
struct __anonstruct_entry_39 {
   struct layout_cell *tqe_next ;
   struct layout_cell **tqe_prev ;
};
#line 952 "../tmux.h"
struct layout_cell {
   enum layout_type type ;
   struct layout_cell *parent ;
   u_int___0 sx ;
   u_int___0 sy ;
   u_int___0 xoff ;
   u_int___0 yoff ;
   struct window_pane *wp ;
   struct layout_cells cells ;
   struct __anonstruct_entry_39 entry ;
};
#line 987
struct hooks;
#line 987 "../tmux.h"
struct __anonstruct_gentry_43 {
   struct session *tqe_next ;
   struct session **tqe_prev ;
};
#line 987 "../tmux.h"
struct __anonstruct_entry_44 {
   struct session *rbe_left ;
   struct session *rbe_right ;
   struct session *rbe_parent ;
   int rbe_color ;
};
#line 987 "../tmux.h"
struct session {
   u_int___0 id ;
   char *name ;
   char const   *cwd ;
   struct timeval creation_time ;
   struct timeval last_attached_time ;
   struct timeval activity_time ;
   struct timeval last_activity_time ;
   struct event lock_timer ;
   u_int___0 sx ;
   u_int___0 sy ;
   struct winlink *curw ;
   struct winlink_stack lastw ;
   struct winlinks windows ;
   int statusat ;
   struct hooks *hooks ;
   struct options *options ;
   int flags ;
   u_int___0 attached ;
   struct termios *tio ;
   struct environ *environ ;
   int references ;
   struct __anonstruct_gentry_43 gentry ;
   struct __anonstruct_entry_44 entry ;
};
#line 1050 "../tmux.h"
struct mouse_event {
   int valid ;
   key_code key ;
   int statusat ;
   u_int___0 x ;
   u_int___0 y ;
   u_int___0 b ;
   u_int___0 lx ;
   u_int___0 ly ;
   u_int___0 lb ;
   int s ;
   int w ;
   int wp ;
   u_int___0 sgr_type ;
   u_int___0 sgr_b ;
};
#line 1073 "../tmux.h"
struct tty_key {
   char ch ;
   key_code key ;
   struct tty_key *left ;
   struct tty_key *right ;
   struct tty_key *next ;
};
#line 1083
struct tty_code;
#line 1083
struct tty_code;
#line 1084 "../tmux.h"
struct __anonstruct_entry_45 {

};
#line 1084 "../tmux.h"
struct tty_term {
   char *name ;
   u_int___0 references ;
   char acs[11][2] ;
   struct tty_code *codes ;
   int flags ;
   struct __anonstruct_entry_45 entry ;
};
#line 1100
struct evbuffer;
#line 1100
enum __anonenum_term_type_46 {
    TTY_VT100 = 0,
    TTY_VT101 = 1,
    TTY_VT102 = 2,
    TTY_VT220 = 3,
    TTY_VT320 = 4,
    TTY_VT420 = 5,
    TTY_UNKNOWN = 6
} ;
#line 1100 "../tmux.h"
struct tty {
   struct client *client ;
   u_int___0 sx ;
   u_int___0 sy ;
   u_int___0 cx ;
   u_int___0 cy ;
   u_int___0 cstyle ;
   char *ccolour ;
   int mode ;
   u_int___0 rlower ;
   u_int___0 rupper ;
   u_int___0 rleft ;
   u_int___0 rright ;
   int fd ;
   struct event event_in ;
   struct evbuffer *in ;
   struct event event_out ;
   struct evbuffer *out ;
   struct event timer ;
   size_t discarded ;
   struct termios tio ;
   struct grid_cell cell ;
   int last_wp ;
   struct grid_cell last_cell ;
   int flags ;
   struct tty_term *term ;
   char *term_name ;
   int term_flags ;
   enum __anonenum_term_type_46 term_type ;
   struct mouse_event mouse ;
   int mouse_drag_flag ;
   void (*mouse_drag_update)(struct client * , struct mouse_event * ) ;
   void (*mouse_drag_release)(struct client * , struct mouse_event * ) ;
   struct event key_timer ;
   struct tty_key *key_tree ;
};
#line 1199 "../tmux.h"
struct __anonstruct_entry_47 {
   struct message_entry *tqe_next ;
   struct message_entry **tqe_prev ;
};
#line 1199 "../tmux.h"
struct message_entry {
   char *msg ;
   u_int___0 msg_num ;
   time_t msg_time ;
   struct __anonstruct_entry_47 entry ;
};
#line 1208 "../tmux.h"
struct __anonstruct_entry_48 {
   struct args_entry *rbe_left ;
   struct args_entry *rbe_right ;
   struct args_entry *rbe_parent ;
   int rbe_color ;
};
#line 1208 "../tmux.h"
struct args_entry {
   u_char___0 flag ;
   char *value ;
   struct __anonstruct_entry_48 entry ;
};
#line 1214 "../tmux.h"
struct args_tree {
   struct args_entry *rbh_root ;
};
#line 1215 "../tmux.h"
struct args {
   struct args_tree tree ;
   int argc ;
   char **argv ;
};
#line 1248
struct cmd_entry;
#line 1248 "../tmux.h"
struct __anonstruct_qentry_49 {
   struct cmd *tqe_next ;
   struct cmd **tqe_prev ;
};
#line 1248 "../tmux.h"
struct cmd {
   struct cmd_entry  const  *entry ;
   struct args *args ;
   char *file ;
   u_int___0 line ;
   int flags ;
   void *data ;
   struct __anonstruct_qentry_49 qentry ;
};
#line 1261 "../tmux.h"
struct __anonstruct_list_50 {
   struct cmd *tqh_first ;
   struct cmd **tqh_last ;
};
#line 1261 "../tmux.h"
struct cmd_list {
   int references ;
   struct __anonstruct_list_50 list ;
};
#line 1296
struct cmdq_item;
#line 1297 "../tmux.h"
struct cmdq_list {
   struct cmdq_item *tqh_first ;
   struct cmdq_item **tqh_last ;
};
#line 1307
struct cmd_entry;
#line 1313
struct key_table;
#line 1313 "../tmux.h"
struct __anonstruct_message_log_51 {
   struct message_entry *tqh_first ;
   struct message_entry **tqh_last ;
};
#line 1313
enum __anonenum_prompt_mode_52 {
    PROMPT_ENTRY = 0,
    PROMPT_COMMAND = 1
} ;
#line 1313
struct cmd_q;
#line 1313 "../tmux.h"
struct __anonstruct_entry_53 {
   struct client *tqe_next ;
   struct client **tqe_prev ;
};
#line 1313 "../tmux.h"
struct client {
   char const   *name ;
   struct tmuxpeer *peer ;
   struct cmdq_list queue ;
   pid_t___0 pid ;
   int fd ;
   struct event event ;
   int retval ;
   struct timeval creation_time ;
   struct timeval activity_time ;
   struct environ *environ ;
   struct format_job_tree *jobs ;
   char *title ;
   char const   *cwd ;
   char *term ;
   char *ttyname ;
   struct tty tty ;
   size_t written ;
   size_t discarded ;
   size_t redraw ;
   void (*stdin_callback)(struct client * , int  , void * ) ;
   void *stdin_callback_data ;
   struct evbuffer *stdin_data ;
   int stdin_closed ;
   struct evbuffer *stdout_data ;
   struct evbuffer *stderr_data ;
   struct event repeat_timer ;
   struct event click_timer ;
   u_int___0 click_button ;
   struct event status_timer ;
   struct screen status ;
   struct screen *old_status ;
   int flags ;
   struct key_table *keytable ;
   struct event identify_timer ;
   void (*identify_callback)(struct client * , struct window_pane * ) ;
   void *identify_callback_data ;
   char *message_string ;
   struct event message_timer ;
   u_int___0 message_next ;
   struct __anonstruct_message_log_51 message_log ;
   char *prompt_string ;
   struct utf8_data *prompt_buffer ;
   size_t prompt_index ;
   int (*prompt_inputcb)(struct client * , void * , char const   * , int  ) ;
   void (*prompt_freecb)(void * ) ;
   void *prompt_data ;
   u_int___0 prompt_hindex ;
   enum __anonenum_prompt_mode_52 prompt_mode ;
   int prompt_flags ;
   struct session *session ;
   struct session *last_session ;
   int wlmouse ;
   int references ;
   struct cmd_q *cmdq ;
   struct __anonstruct_entry_53 entry ;
};
#line 1424 "../tmux.h"
struct __anonstruct_entry_54 {
   struct key_binding *rbe_left ;
   struct key_binding *rbe_right ;
   struct key_binding *rbe_parent ;
   int rbe_color ;
};
#line 1424 "../tmux.h"
struct key_binding {
   key_code key ;
   struct cmd_list *cmdlist ;
   int flags ;
   struct __anonstruct_entry_54 entry ;
};
#line 1433 "../tmux.h"
struct key_bindings {
   struct key_binding *rbh_root ;
};
#line 1435 "../tmux.h"
struct __anonstruct_entry_55 {
   struct key_table *rbe_left ;
   struct key_table *rbe_right ;
   struct key_table *rbe_parent ;
   int rbe_color ;
};
#line 1435 "../tmux.h"
struct key_table {
   char const   *name ;
   struct key_bindings key_bindings ;
   u_int___0 references ;
   struct __anonstruct_entry_55 entry ;
};
#line 15 "tmux_uaf_1.c"
struct window {
   char *name ;
   struct event name_timer ;
   struct window_pane *active ;
   struct window_panes panes ;
   int lastlayout ;
   struct layout_cell *layout_root ;
   u_int___0 sx ;
   u_int___0 sy ;
   int flags ;
   struct options options ;
   u_int___0 references ;
};
#line 39 "tmux_uaf_1.c"
struct windows {
   struct window **list ;
   u_int___0 num ;
   size_t space ;
};
#line 51 "tmux_uaf_1.c"
struct window_mode {
   struct screen *(*init)(struct window_pane * ) ;
   void (*free)(struct window_pane * ) ;
   void (*resize)(struct window_pane * , u_int___0  , u_int___0  ) ;
   void (*key)(struct window_pane * , struct client * , int  ) ;
   void (*mouse)(struct window_pane * , struct client * , struct mouse_event * ) ;
   void (*timer)(struct window_pane * ) ;
};
#line 67
struct mode_key_tree;
#line 67 "tmux_uaf_1.c"
struct mode_key_data {
   struct mode_key_tree *tree ;
   int mode ;
};
#line 84
enum window_copy_input_type {
    WINDOW_COPY_OFF = 0,
    WINDOW_COPY_NUMERICPREFIX = 1,
    WINDOW_COPY_SEARCHUP = 2,
    WINDOW_COPY_SEARCHDOWN = 3,
    WINDOW_COPY_GOTOLINE = 4
} ;
#line 92 "tmux_uaf_1.c"
struct window_copy_mode_data {
   struct screen screen ;
   struct mode_key_data mdata ;
   u_int___0 oy ;
   u_int___0 selx ;
   u_int___0 sely ;
   u_int___0 rectflag ;
   u_int___0 cx ;
   u_int___0 cy ;
   u_int___0 lastcx ;
   u_int___0 lastsx ;
   enum window_copy_input_type inputtype ;
   char const   *inputprompt ;
   char *inputstr ;
   u_int___0 numprefix ;
   enum window_copy_input_type searchtype ;
   char *searchstr ;
};
#line 121
enum mode_key_cmd {
    MODEKEY_NONE = 0,
    MODEKEY_OTHER = 1,
    MODEKEYEDIT_BACKSPACE = 2,
    MODEKEYEDIT_CANCEL = 3,
    MODEKEYEDIT_COMPLETE = 4,
    MODEKEYEDIT_CURSORLEFT = 5,
    MODEKEYEDIT_CURSORRIGHT = 6,
    MODEKEYEDIT_DELETE = 7,
    MODEKEYEDIT_DELETELINE = 8,
    MODEKEYEDIT_DELETETOENDOFLINE = 9,
    MODEKEYEDIT_ENDOFLINE = 10,
    MODEKEYEDIT_ENTER = 11,
    MODEKEYEDIT_HISTORYDOWN = 12,
    MODEKEYEDIT_HISTORYUP = 13,
    MODEKEYEDIT_PASTE = 14,
    MODEKEYEDIT_STARTOFLINE = 15,
    MODEKEYEDIT_SWITCHMODE = 16,
    MODEKEYEDIT_SWITCHMODEAPPEND = 17,
    MODEKEYEDIT_TRANSPOSECHARS = 18,
    MODEKEYCHOICE_CANCEL = 19,
    MODEKEYCHOICE_CHOOSE = 20,
    MODEKEYCHOICE_DOWN = 21,
    MODEKEYCHOICE_PAGEDOWN = 22,
    MODEKEYCHOICE_PAGEUP = 23,
    MODEKEYCHOICE_SCROLLDOWN = 24,
    MODEKEYCHOICE_SCROLLUP = 25,
    MODEKEYCHOICE_UP = 26,
    MODEKEYCOPY_BACKTOINDENTATION = 27,
    MODEKEYCOPY_BOTTOMLINE = 28,
    MODEKEYCOPY_CANCEL = 29,
    MODEKEYCOPY_CLEARSELECTION = 30,
    MODEKEYCOPY_COPYSELECTION = 31,
    MODEKEYCOPY_DOWN = 32,
    MODEKEYCOPY_ENDOFLINE = 33,
    MODEKEYCOPY_GOTOLINE = 34,
    MODEKEYCOPY_HALFPAGEDOWN = 35,
    MODEKEYCOPY_HALFPAGEUP = 36,
    MODEKEYCOPY_HISTORYBOTTOM = 37,
    MODEKEYCOPY_HISTORYTOP = 38,
    MODEKEYCOPY_LEFT = 39,
    MODEKEYCOPY_MIDDLELINE = 40,
    MODEKEYCOPY_NEXTPAGE = 41,
    MODEKEYCOPY_NEXTSPACE = 42,
    MODEKEYCOPY_NEXTSPACEEND = 43,
    MODEKEYCOPY_NEXTWORD = 44,
    MODEKEYCOPY_NEXTWORDEND = 45,
    MODEKEYCOPY_PREVIOUSPAGE = 46,
    MODEKEYCOPY_PREVIOUSSPACE = 47,
    MODEKEYCOPY_PREVIOUSWORD = 48,
    MODEKEYCOPY_RECTANGLETOGGLE = 49,
    MODEKEYCOPY_RIGHT = 50,
    MODEKEYCOPY_SCROLLDOWN = 51,
    MODEKEYCOPY_SCROLLUP = 52,
    MODEKEYCOPY_SEARCHAGAIN = 53,
    MODEKEYCOPY_SEARCHDOWN = 54,
    MODEKEYCOPY_SEARCHREVERSE = 55,
    MODEKEYCOPY_SEARCHUP = 56,
    MODEKEYCOPY_STARTNUMBERPREFIX = 57,
    MODEKEYCOPY_STARTOFLINE = 58,
    MODEKEYCOPY_STARTSELECTION = 59,
    MODEKEYCOPY_TOPLINE = 60,
    MODEKEYCOPY_UP = 61
} ;
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 431
extern int scanf(char const   * __restrict  __format  , ...)  __asm__("__isoc99_scanf")  ;
#line 538
extern int getchar(void) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 42 "tmux_uaf_1.c"
struct screen *window_copy_init(struct window_pane *wp ) ;
#line 43
void window_copy_free(struct window_pane *wp ) ;
#line 45
void window_copy_key(struct window_pane *wp , struct client *c , int key ) ;
#line 61
struct window *window_create1(u_int___0 sx , u_int___0 sy ) ;
#line 62
struct window *window_create(char const   *name , char const   *cmd , char const   *shell ,
                             char const   *cwd , u_int___0 sx , u_int___0 sy , u_int___0 hlimit ,
                             char **cause ) ;
#line 64
struct window_pane *window_pane_create(struct window *w , u_int___0 sx , u_int___0 sy ,
                                       u_int___0 hlimit ) ;
#line 75 "tmux_uaf_1.c"
struct window_mode  const  window_copy_mode  =    {& window_copy_init, & window_copy_free, (void (*)(struct window_pane * , u_int___0  ,
                                                      u_int___0  ))((void *)0), & window_copy_key,
    (void (*)(struct window_pane * , struct client * , struct mouse_event * ))((void *)0),
    (void (*)(struct window_pane * ))((void *)0)};
#line 192 "tmux_uaf_1.c"
struct windows windows  ;
#line 193 "tmux_uaf_1.c"
void mode_key_init(struct mode_key_data *mdata , struct mode_key_tree *mtree ) 
{ 


  {
#line 196
  mdata->tree = mtree;
#line 197
  mdata->mode = 0;
#line 198
  return;
}
}
#line 202 "tmux_uaf_1.c"
int window_pane_set_mode(struct window_pane *wp , struct window_mode  const  *mode ) 
{ 
  struct screen *s ;

  {
#line 207
  if ((unsigned long )wp->mode != (unsigned long )((void *)0)) {
#line 208
    return (1);
  }
#line 209
  wp->mode = mode;
#line 211
  s = (*((wp->mode)->init))(wp);
#line 211
  if ((unsigned long )s != (unsigned long )((void *)0)) {
#line 212
    wp->screen = s;
  }
#line 213
  wp->flags |= 1;
#line 214
  return (0);
}
}
#line 218 "tmux_uaf_1.c"
void *xrealloc(void *oldptr , size_t nmemb , size_t size ) 
{ 
  size_t newsize ;
  void *newptr ;

  {
#line 221
  newsize = nmemb * size;
#line 224
  if (newsize == 0UL) {
#line 225
    printf((char const   * __restrict  )"zero size%s", "");
#line 225
    exit(1);
  }
#line 226
  if ((size_t )(1 << 30) / nmemb < size) {
#line 227
    printf((char const   * __restrict  )"nmemb * size > SIZE_MAX%s", "");
#line 227
    exit(1);
  }
#line 228
  newptr = realloc(oldptr, newsize);
#line 228
  if ((unsigned long )newptr == (unsigned long )((void *)0)) {
#line 229
    printf((char const   * __restrict  )"xrealloc failed%s", "");
#line 229
    exit(1);
  }
#line 231
  return (newptr);
}
}
#line 234 "tmux_uaf_1.c"
void window_pane_reset_mode(struct window_pane *wp ) 
{ 


  {
#line 237
  if ((unsigned long )wp->mode == (unsigned long )((void *)0)) {
#line 238
    return;
  }
#line 240
  (*((wp->mode)->free))(wp);
#line 241
  wp->mode = (struct window_mode  const  *)((void *)0);
#line 243
  wp->screen = & wp->base;
#line 244
  wp->flags |= 1;
#line 245
  return;
}
}
#line 268
extern int ( /* missing proto */  strdup)() ;
#line 247 "tmux_uaf_1.c"
struct screen *window_copy_init(struct window_pane *wp ) 
{ 
  struct window_copy_mode_data *data ;
  struct screen *s ;
  void *tmp ;
  int tmp___0 ;

  {
#line 256
  tmp = malloc(sizeof(*data));
#line 256
  data = (struct window_copy_mode_data *)tmp;
#line 256
  wp->modedata = (void *)data;
#line 257
  data->oy = (u_int___0 )0;
#line 258
  data->cx = wp->base.cx;
#line 259
  data->cy = wp->base.cy;
#line 261
  data->lastcx = (u_int___0 )0;
#line 262
  data->lastsx = (u_int___0 )0;
#line 264
  data->rectflag = (u_int___0 )0;
#line 266
  data->inputtype = (enum window_copy_input_type )0;
#line 267
  data->inputprompt = (char const   *)((void *)0);
#line 268
  tmp___0 = strdup("");
#line 268
  data->inputstr = (char *)tmp___0;
#line 269
  data->numprefix = (u_int___0 )0;
#line 271
  data->searchtype = (enum window_copy_input_type )0;
#line 272
  data->searchstr = (char *)((void *)0);
#line 274
  wp->flags |= 2;
#line 276
  s = & data->screen;
#line 279
  s->cx = data->cx;
#line 280
  s->cy = data->cy;
#line 282
  return (s);
}
}
#line 285 "tmux_uaf_1.c"
void window_copy_free(struct window_pane *wp ) 
{ 
  struct window_copy_mode_data *data ;

  {
#line 288
  data = (struct window_copy_mode_data *)wp->modedata;
#line 290
  wp->flags &= -3;
#line 292
  if ((unsigned long )data->searchstr != (unsigned long )((void *)0)) {
#line 293
    free((void *)data->searchstr);
  }
#line 294
  free((void *)data->inputstr);
#line 297
  free((void *)data);
#line 298
  return;
}
}
#line 299 "tmux_uaf_1.c"
void window_copy_key(struct window_pane *wp , struct client *c , int key ) 
{ 
  struct window_copy_mode_data *data ;
  struct screen *s ;
  u_int___0 np ;
  enum mode_key_cmd cmd ;
  int tmp ;

  {
#line 303
  data = (struct window_copy_mode_data *)wp->modedata;
#line 304
  s = & data->screen;
#line 309
  np = data->numprefix;
#line 310
  if (np == 0U) {
#line 311
    np = (u_int___0 )1;
  }
#line 313
  if ((unsigned int )data->inputtype == 1U) {
#line 314
    data->inputtype = (enum window_copy_input_type )0;
  } else
#line 315
  if ((unsigned int )data->inputtype != 0U) {
#line 316
    tmp = getchar();
#line 316
    if (tmp) {
#line 317
      goto input_off;
    }
#line 318
    return;
  }
#line 321
  switch ((unsigned int )cmd) {
  case 29U: 
#line 323
  while (np != 0U) {
#line 324
    window_pane_reset_mode(wp);
#line 323
    np --;
  }
#line 325
  break;
  case 34U: 
#line 327
  *(data->inputstr) = (char )'\000';
#line 328
  goto input_on;
  default: 
#line 330
  break;
  }
#line 333
  data->numprefix = (u_int___0 )0;
#line 334
  return;
  input_on: 
#line 337
  data->inputtype = (enum window_copy_input_type )4;
#line 338
  data->inputprompt = "Goto Line";
#line 340
  return;
  input_off: 
#line 344
  data->inputtype = (enum window_copy_input_type )0;
#line 345
  data->inputprompt = (char const   *)((void *)0);
#line 347
  return;
}
}
#line 349 "tmux_uaf_1.c"
void window_pane_destroy(struct window_pane *wp ) 
{ 


  {
#line 352
  window_pane_reset_mode(wp);
#line 354
  if ((unsigned long )wp->cwd != (unsigned long )((void *)0)) {
#line 355
    free((void *)wp->cwd);
  }
#line 356
  if ((unsigned long )wp->shell != (unsigned long )((void *)0)) {
#line 357
    free((void *)wp->shell);
  }
#line 358
  free((void *)wp);
#line 359
  return;
}
}
#line 362 "tmux_uaf_1.c"
void window_destroy_panes(struct window *w ) 
{ 
  struct window_pane *wp ;

  {
#line 367
  while (! ((unsigned long )w->panes.tqh_first == (unsigned long )((void *)0))) {
#line 368
    wp = w->panes.tqh_first;
#line 369
    while (1) {
#line 369
      if ((unsigned long )wp->entry.tqe_next != (unsigned long )((void *)0)) {
#line 369
        (wp->entry.tqe_next)->entry.tqe_prev = wp->entry.tqe_prev;
      } else {
#line 369
        w->panes.tqh_last = wp->entry.tqe_prev;
      }
#line 369
      *(wp->entry.tqe_prev) = wp->entry.tqe_next;
#line 369
      break;
    }
#line 370
    window_pane_destroy(wp);
  }
#line 372
  return;
}
}
#line 373 "tmux_uaf_1.c"
int window_index(struct window *s , u_int___0 *i ) 
{ 


  {
#line 376
  *i = (u_int___0 )0;
#line 376
  while (*i < windows.num) {
#line 377
    if ((unsigned long )s == (unsigned long )*(windows.list + *i)) {
#line 378
      return (0);
    }
#line 376
    (*i) ++;
  }
#line 380
  return (-1);
}
}
#line 383 "tmux_uaf_1.c"
void window_destroy(struct window *w ) 
{ 
  u_int___0 i ;
  int tmp ;

  {
#line 388
  tmp = window_index(w, & i);
#line 388
  if (tmp != 0) {
#line 389
    printf((char const   * __restrict  )"index not found%s", "");
#line 389
    exit(1);
  }
#line 390
  while (1) {
#line 390
    *(windows.list + i) = (struct window *)((void *)0);
#line 390
    break;
  }
#line 391
  while (1) {
#line 391
    if ((unsigned long )((void *)(& windows)) == (unsigned long )((void *)0)) {
#line 391
      break;
    } else
#line 391
    if (windows.num == 0U) {
#line 391
      break;
    } else
#line 391
    if (! ((unsigned long )*(windows.list + (windows.num - 1U)) == (unsigned long )((void *)0))) {
#line 391
      break;
    }
#line 392
    while (1) {
#line 392
      if (windows.num > 1U) {
#line 392
        (windows.num) --;
      } else {
#line 392
        while (1) {
#line 392
          free((void *)windows.list);
#line 392
          while (1) {
#line 392
            windows.num = (u_int___0 )0;
#line 392
            windows.list = (struct window **)((void *)0);
#line 392
            windows.space = (size_t )0;
#line 392
            break;
          }
#line 392
          break;
        }
      }
#line 392
      break;
    }
  }
#line 394
  window_destroy_panes(w);
#line 396
  if ((unsigned long )w->name != (unsigned long )((void *)0)) {
#line 397
    free((void *)w->name);
  }
#line 398
  free((void *)w);
#line 399
  return;
}
}
#line 402 "tmux_uaf_1.c"
struct window *window_create1(u_int___0 sx , u_int___0 sy ) 
{ 
  struct window *w ;
  u_int___0 i ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 408
  tmp = malloc(sizeof(*w));
#line 408
  w = (struct window *)tmp;
#line 409
  w->name = (char *)((void *)0);
#line 410
  w->flags = 0;
#line 412
  while (1) {
#line 412
    w->panes.tqh_first = (struct window_pane *)((void *)0);
#line 412
    w->panes.tqh_last = & w->panes.tqh_first;
#line 412
    break;
  }
#line 413
  w->active = (struct window_pane *)((void *)0);
#line 415
  w->lastlayout = -1;
#line 416
  w->layout_root = (struct layout_cell *)((void *)0);
#line 418
  w->sx = sx;
#line 419
  w->sy = sy;
#line 421
  i = (u_int___0 )0;
#line 421
  while (i < windows.num) {
#line 422
    if ((unsigned long )*(windows.list + i) == (unsigned long )((void *)0)) {
#line 423
      while (1) {
#line 423
        *(windows.list + i) = w;
#line 423
        break;
      }
#line 424
      break;
    }
#line 421
    i ++;
  }
#line 427
  if (i == windows.num) {
#line 428
    while (1) {
#line 428
      while (1) {
#line 428
        if ((u_int___0 )((1 << 30) - 1) < windows.num) {
#line 428
          printf((char const   * __restrict  )"number too big%s", "");
#line 428
          exit(1);
        }
#line 428
        if ((unsigned long )((u_int___0 )(1 << 30) / (windows.num + 1U)) < sizeof(*(windows.list))) {
#line 428
          printf((char const   * __restrict  )"size too big%s", "");
#line 428
          exit(1);
        }
#line 428
        if (windows.space == 0UL) {
#line 428
          windows.space = 10UL * sizeof(*(windows.list));
#line 428
          tmp___0 = xrealloc((void *)windows.list, (size_t )1, windows.space);
#line 428
          windows.list = (struct window **)tmp___0;
        }
#line 428
        while (windows.space <= (unsigned long )(windows.num + 1U) * sizeof(*(windows.list))) {
#line 428
          tmp___1 = xrealloc((void *)windows.list, (size_t )2, windows.space);
#line 428
          windows.list = (struct window **)tmp___1;
#line 428
          windows.space *= 2UL;
        }
#line 428
        break;
      }
#line 428
      *(windows.list + windows.num) = w;
#line 428
      (windows.num) ++;
#line 428
      break;
    }
  }
#line 429
  w->references = (u_int___0 )0;
#line 431
  return (w);
}
}
#line 434 "tmux_uaf_1.c"
struct window_pane *window_add_pane(struct window *w , u_int___0 hlimit ) 
{ 
  struct window_pane *wp ;
  struct window_pane *tmp ;
  struct window_pane *tmp___0 ;

  {
#line 439
  wp = window_pane_create(w, w->sx, w->sy, hlimit);
#line 440
  if ((unsigned long )w->panes.tqh_first == (unsigned long )((void *)0)) {
#line 441
    while (1) {
#line 441
      tmp = w->panes.tqh_first;
#line 441
      wp->entry.tqe_next = tmp;
#line 441
      if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 441
        (w->panes.tqh_first)->entry.tqe_prev = & wp->entry.tqe_next;
      } else {
#line 441
        w->panes.tqh_last = & wp->entry.tqe_next;
      }
#line 441
      w->panes.tqh_first = wp;
#line 441
      wp->entry.tqe_prev = & w->panes.tqh_first;
#line 441
      break;
    }
  } else {
#line 443
    while (1) {
#line 443
      tmp___0 = (w->active)->entry.tqe_next;
#line 443
      wp->entry.tqe_next = tmp___0;
#line 443
      if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 443
        (wp->entry.tqe_next)->entry.tqe_prev = & wp->entry.tqe_next;
      } else {
#line 443
        w->panes.tqh_last = & wp->entry.tqe_next;
      }
#line 443
      (w->active)->entry.tqe_next = wp;
#line 443
      wp->entry.tqe_prev = & (w->active)->entry.tqe_next;
#line 443
      break;
    }
  }
#line 444
  return (wp);
}
}
#line 447 "tmux_uaf_1.c"
struct window *window_create(char const   *name , char const   *cmd , char const   *shell ,
                             char const   *cwd , u_int___0 sx , u_int___0 sy , u_int___0 hlimit ,
                             char **cause ) 
{ 
  struct window *w ;
  struct window_pane *wp ;
  int tmp ;

  {
#line 454
  w = window_create1(sx, sy);
#line 455
  wp = window_add_pane(w, hlimit);
#line 457
  w->active = w->panes.tqh_first;
#line 458
  tmp = strdup(name);
#line 458
  w->name = (char *)tmp;
#line 459
  return (w);
}
}
#line 463 "tmux_uaf_1.c"
struct window_pane *window_pane_create(struct window *w , u_int___0 sx , u_int___0 sy ,
                                       u_int___0 hlimit ) 
{ 
  struct window_pane *wp ;
  void *tmp ;

  {
#line 468
  tmp = calloc((size_t )1, sizeof(*wp));
#line 468
  wp = (struct window_pane *)tmp;
#line 469
  wp->window = w;
#line 471
  wp->shell = (char *)((void *)0);
#line 472
  wp->cwd = (char const   *)((void *)0);
#line 474
  wp->fd = -1;
#line 475
  wp->event = (struct bufferevent *)((void *)0);
#line 477
  wp->mode = (struct window_mode  const  *)((void *)0);
#line 479
  wp->layout_cell = (struct layout_cell *)((void *)0);
#line 481
  wp->xoff = (u_int___0 )0;
#line 482
  wp->yoff = (u_int___0 )0;
#line 484
  wp->sx = sx;
#line 485
  wp->sy = sy;
#line 487
  wp->pipe_fd = -1;
#line 488
  wp->pipe_off = (size_t )0;
#line 489
  wp->pipe_event = (struct bufferevent *)((void *)0);
#line 491
  wp->saved_grid = (struct grid *)((void *)0);
#line 493
  return (wp);
}
}
#line 497 "tmux_uaf_1.c"
int main(void) 
{ 
  struct window *w ;
  struct window_pane *wp ;
  struct client c ;
  int key ;
  u_int___0 sx ;
  u_int___0 sy ;
  u_int___0 hlimit ;
  int tmp ;

  {
#line 506
  w = window_create("name", "cmd", "shell", "cwd", sx, sy, hlimit, (char **)((void *)0));
#line 507
  wp = w->active;
#line 509
  window_pane_set_mode(wp, & window_copy_mode);
#line 511
  while (1) {
#line 511
    tmp = getchar();
#line 511
    if (! tmp) {
#line 511
      break;
    }
#line 513
    scanf((char const   * __restrict  )"%d", & key);
#line 514
    (*((wp->mode)->key))(wp, & c, key);
  }
#line 516
  (*((wp->mode)->free))(wp);
#line 517
  window_destroy(w);
#line 518
  return (0);
}
}
