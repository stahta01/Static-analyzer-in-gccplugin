/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

#line 216 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h"
typedef unsigned long size_t;
#line 192 "../stdio.h"
typedef unsigned short u_short___0;
#line 193 "../stdio.h"
typedef unsigned int u_int___0;
#line 204 "../stdio.h"
typedef unsigned char u_char___0;
#line 39 "../tmux.h"
typedef char bitstr_t;
#line 42 "../tmux.h"
struct termios {

};
#line 533 "../tmux.h"
struct utf8_data {
   u_char___0 data[9] ;
   u_char___0 have ;
   u_char___0 size ;
   u_char___0 width ;
};
#line 575 "../tmux.h"
struct grid_cell {
   u_char___0 flags ;
   u_short___0 attr ;
   int fg ;
   int bg ;
   struct utf8_data data ;
};
#line 582 "../tmux.h"
struct __anonstruct_data_27 {
   u_char___0 attr ;
   u_char___0 fg ;
   u_char___0 bg ;
   u_char___0 data ;
};
#line 582 "../tmux.h"
union __anonunion____missing_field_name_26 {
   u_int___0 offset ;
   struct __anonstruct_data_27 data ;
};
#line 582 "../tmux.h"
struct grid_cell_entry {
   u_char___0 flags ;
   union __anonunion____missing_field_name_26 __annonCompField1 ;
};
#line 596 "../tmux.h"
struct grid_line {
   u_int___0 cellused ;
   u_int___0 cellsize ;
   struct grid_cell_entry *celldata ;
   u_int___0 extdsize ;
   struct grid_cell *extddata ;
   int flags ;
};
#line 608 "../tmux.h"
struct grid {
   int flags ;
   u_int___0 sx ;
   u_int___0 sy ;
   u_int___0 hscrolled ;
   u_int___0 hsize ;
   u_int___0 hlimit ;
   struct grid_line *linedata ;
};
#line 661
enum __anonenum_lineflag_31 {
    LINE_SEL_NONE = 0,
    LINE_SEL_LEFT_RIGHT = 1,
    LINE_SEL_RIGHT_LEFT = 2
} ;
#line 661 "../tmux.h"
struct screen_sel {
   int flag ;
   int hidden ;
   int rectflag ;
   enum __anonenum_lineflag_31 lineflag ;
   int modekeys ;
   u_int___0 sx ;
   u_int___0 sy ;
   u_int___0 ex ;
   u_int___0 ey ;
   struct grid_cell cell ;
};
#line 683
struct screen_titles;
#line 683
struct screen_titles;
#line 684 "../tmux.h"
struct screen {
   char *title ;
   struct screen_titles *titles ;
   struct grid *grid ;
   u_int___0 cx ;
   u_int___0 cy ;
   u_int___0 cstyle ;
   char *ccolour ;
   u_int___0 rupper ;
   u_int___0 rlower ;
   u_int___0 hsize ;
   int mode ;
   bitstr_t *tabs ;
   struct screen_sel sel ;
};
#line 778
struct window;
#line 24 "tmux_uaf_2.c"
struct buffer {
   u_char___0 *base ;
   size_t space ;
   size_t size ;
   size_t off ;
};
#line 33 "tmux_uaf_2.c"
struct window {
   char name[32] ;
   int fd ;
   struct buffer *in ;
   struct buffer *out ;
   u_int___0 references ;
   struct screen screen ;
};
#line 44 "tmux_uaf_2.c"
struct windows {
   struct window **list ;
   u_int___0 num ;
   size_t space ;
};
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 47 "tmux_uaf_2.c"
struct windows windows  ;
#line 49
void window_destroy(struct window *w ) ;
#line 52 "tmux_uaf_2.c"
void *xrealloc(void *oldptr , size_t nmemb , size_t size ) 
{ 
  size_t newsize ;
  void *newptr ;

  {
#line 55
  newsize = nmemb * size;
#line 58
  if (newsize == 0UL) {
#line 59
    printf((char const   * __restrict  )"zero size%s", "");
#line 59
    exit(1);
  }
#line 60
  if ((size_t )(1 << 30) / nmemb < size) {
#line 61
    printf((char const   * __restrict  )"nmemb * size > SIZE_MAX%s", "");
#line 61
    exit(1);
  }
#line 62
  newptr = realloc(oldptr, newsize);
#line 62
  if ((unsigned long )newptr == (unsigned long )((void *)0)) {
#line 63
    printf((char const   * __restrict  )"xrealloc failed%s", "");
#line 63
    exit(1);
  }
#line 65
  return (newptr);
}
}
#line 69 "tmux_uaf_2.c"
struct buffer *buffer_create(size_t size ) 
{ 
  struct buffer *b ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 74
  if (size == 0UL) {
#line 75
    printf((char const   * __restrict  )"zero size%s", "");
#line 75
    exit(1);
  }
#line 77
  tmp = calloc((size_t )1, sizeof(*b));
#line 77
  b = (struct buffer *)tmp;
#line 79
  tmp___0 = malloc(size);
#line 79
  b->base = (u_char___0 *)tmp___0;
#line 80
  b->space = size;
#line 82
  return (b);
}
}
#line 86 "tmux_uaf_2.c"
void buffer_destroy(struct buffer *b ) 
{ 


  {
#line 89
  free((void *)b->base);
#line 90
  free((void *)b);
#line 91
  return;
}
}
#line 94 "tmux_uaf_2.c"
int window_index(struct windows *ww , struct window *w , u_int___0 *i ) 
{ 


  {
#line 97
  *i = (u_int___0 )0;
#line 97
  while (*i < ww->num) {
#line 98
    if ((unsigned long )w == (unsigned long )*(ww->list + *i)) {
#line 99
      return (0);
    }
#line 97
    (*i) ++;
  }
#line 101
  return (-1);
}
}
#line 112
extern int ( /* missing proto */  memmove)() ;
#line 105 "tmux_uaf_2.c"
void window_remove(struct windows *ww , struct window *w ) 
{ 
  u_int___0 i ;
  int tmp ;

  {
#line 110
  tmp = window_index(ww, w, & i);
#line 110
  if (tmp != 0) {
#line 111
    printf((char const   * __restrict  )"window not found%s", "");
#line 111
    exit(1);
  }
#line 112
  while (1) {
#line 112
    if (i < ww->num - 1U) {
#line 112
      memmove(ww->list + i, (ww->list + i) + 1, sizeof(*(ww->list)) * (unsigned long )((ww->num - i) - 1U));
    }
#line 112
    (ww->num) --;
#line 112
    if (ww->num == 0U) {
#line 112
      while (1) {
#line 112
        free((void *)ww->list);
#line 112
        while (1) {
#line 112
          ww->num = (u_int___0 )0;
#line 112
          ww->list = (struct window **)((void *)0);
#line 112
          ww->space = (size_t )0;
#line 112
          break;
        }
#line 112
        break;
      }
    }
#line 112
    break;
  }
#line 114
  (w->references) --;
#line 115
  if (w->references == 0U) {
#line 116
    window_destroy(w);
#line 117
    window_remove(& windows, w);
  }
#line 119
  return;
}
}
#line 125
extern int ( /* missing proto */  close)() ;
#line 122 "tmux_uaf_2.c"
void window_destroy(struct window *w ) 
{ 


  {
#line 125
  close(w->fd);
#line 127
  buffer_destroy(w->in);
#line 128
  buffer_destroy(w->out);
#line 129
  free((void *)w);
#line 130
  return;
}
}
#line 133 "tmux_uaf_2.c"
void window_add(struct windows *ww , struct window *w ) 
{ 
  u_int___0 i ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 138
  tmp___1 = window_index(ww, (struct window *)((void *)0), & i);
#line 138
  if (tmp___1 != 0) {
#line 139
    while (1) {
#line 139
      while (1) {
#line 139
        if ((u_int___0 )((1 << 30) - 1) < ww->num) {
#line 139
          printf((char const   * __restrict  )"number too big%s", "");
#line 139
          exit(1);
        }
#line 139
        if ((unsigned long )((u_int___0 )(1 << 30) / (ww->num + 1U)) < sizeof(*(ww->list))) {
#line 139
          printf((char const   * __restrict  )"size too big%s", "");
#line 139
          exit(1);
        }
#line 139
        if (ww->space == 0UL) {
#line 139
          ww->space = 10UL * sizeof(*(ww->list));
#line 139
          tmp = xrealloc((void *)ww->list, (size_t )1, ww->space);
#line 139
          ww->list = (struct window **)tmp;
        }
#line 139
        while (ww->space <= (unsigned long )(ww->num + 1U) * sizeof(*(ww->list))) {
#line 139
          tmp___0 = xrealloc((void *)ww->list, (size_t )2, ww->space);
#line 139
          ww->list = (struct window **)tmp___0;
#line 139
          ww->space *= 2UL;
        }
#line 139
        break;
      }
#line 139
      *(ww->list + ww->num) = w;
#line 139
      (ww->num) ++;
#line 139
      break;
    }
  } else {
#line 141
    while (1) {
#line 141
      *(ww->list + i) = w;
#line 141
      break;
    }
  }
#line 143
  (w->references) ++;
#line 144
  return;
}
}
#line 161
extern int ( /* missing proto */  strdup)() ;
#line 166
extern int ( /* missing proto */  strchr)() ;
#line 174
extern int ( /* missing proto */  strcpy)() ;
#line 148 "tmux_uaf_2.c"
struct window *window_create(char const   *cmd , u_int___0 sx , u_int___0 sy ) 
{ 
  struct window *w ;
  int fd ;
  char *ptr ;
  char *name ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 156
  tmp = malloc(sizeof(*w));
#line 156
  w = (struct window *)tmp;
#line 157
  w->fd = fd;
#line 158
  w->in = buffer_create((size_t )8192);
#line 159
  w->out = buffer_create((size_t )8192);
#line 161
  tmp___0 = strdup(cmd);
#line 161
  name = (char *)tmp___0;
#line 162
  tmp___2 = strchr(name, ' ');
#line 162
  ptr = (char *)tmp___2;
#line 162
  if ((unsigned long )ptr != (unsigned long )((void *)0)) {
#line 163
    if ((unsigned long )ptr != (unsigned long )name) {
#line 163
      if ((int )*(ptr + -1) != 92) {
#line 164
        *ptr = (char )'\000';
      } else {
#line 163
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 166
      while (1) {
#line 166
        tmp___1 = strchr(ptr + 1, ' ');
#line 166
        ptr = (char *)tmp___1;
#line 166
        if (! ((unsigned long )ptr != (unsigned long )((void *)0))) {
#line 166
          break;
        }
#line 167
        if ((int )*(ptr + -1) != 92) {
#line 168
          *ptr = (char )'\000';
#line 169
          break;
        }
      }
    }
  }
#line 174
  strcpy(w->name, name);
#line 175
  free((void *)name);
#line 177
  window_add(& windows, w);
#line 178
  w->references = (u_int___0 )0;
#line 180
  return (w);
}
}
#line 183 "tmux_uaf_2.c"
int main(void) 
{ 
  struct window *w ;
  u_int___0 sx ;
  u_int___0 sy ;

  {
#line 188
  w = window_create("cmd", sx, sy);
#line 189
  window_add(& windows, w);
#line 191
  window_remove(& windows, w);
#line 192
  return (0);
}
}
