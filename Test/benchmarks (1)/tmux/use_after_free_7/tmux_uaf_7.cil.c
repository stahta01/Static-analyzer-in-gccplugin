/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

#line 216 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h"
typedef unsigned long size_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 67 "../stdio.h"
typedef unsigned short u_short___0;
#line 68 "../stdio.h"
typedef unsigned int u_int___0;
#line 79 "../stdio.h"
typedef unsigned char u_char___0;
#line 39 "../tmux.h"
typedef char bitstr_t;
#line 41 "../tmux.h"
struct event {

};
#line 42 "../tmux.h"
struct termios {

};
#line 55
struct environ;
#line 55
struct environ;
#line 60
struct options;
#line 60
struct options;
#line 61
struct options_entry;
#line 61
struct options_entry;
#line 62
struct session;
#line 62
struct session;
#line 473 "../tmux.h"
struct options_tree {
   struct options_entry *rbh_root ;
};
#line 473 "../tmux.h"
struct options {
   struct options_tree tree ;
   struct options *parent ;
};
#line 543 "../tmux.h"
struct utf8_data {
   u_char___0 data[9] ;
   u_char___0 have ;
   u_char___0 size ;
   u_char___0 width ;
};
#line 585 "../tmux.h"
struct grid_cell {
   u_char___0 flags ;
   u_short___0 attr ;
   int fg ;
   int bg ;
   struct utf8_data data ;
};
#line 592 "../tmux.h"
struct __anonstruct_data_29 {
   u_char___0 attr ;
   u_char___0 fg ;
   u_char___0 bg ;
   u_char___0 data ;
};
#line 592 "../tmux.h"
union __anonunion____missing_field_name_28 {
   u_int___0 offset ;
   struct __anonstruct_data_29 data ;
};
#line 592 "../tmux.h"
struct grid_cell_entry {
   u_char___0 flags ;
   union __anonunion____missing_field_name_28 __annonCompField1 ;
};
#line 606 "../tmux.h"
struct grid_line {
   u_int___0 cellused ;
   u_int___0 cellsize ;
   struct grid_cell_entry *celldata ;
   u_int___0 extdsize ;
   struct grid_cell *extddata ;
   int flags ;
};
#line 618 "../tmux.h"
struct grid {
   int flags ;
   u_int___0 sx ;
   u_int___0 sy ;
   u_int___0 hscrolled ;
   u_int___0 hsize ;
   u_int___0 hlimit ;
   struct grid_line *linedata ;
};
#line 671
enum __anonenum_lineflag_33 {
    LINE_SEL_NONE = 0,
    LINE_SEL_LEFT_RIGHT = 1,
    LINE_SEL_RIGHT_LEFT = 2
} ;
#line 671 "../tmux.h"
struct screen_sel {
   int flag ;
   int hidden ;
   int rectflag ;
   enum __anonenum_lineflag_33 lineflag ;
   int modekeys ;
   u_int___0 sx ;
   u_int___0 sy ;
   u_int___0 ex ;
   u_int___0 ey ;
   struct grid_cell cell ;
};
#line 693
struct screen_titles;
#line 693
struct screen_titles;
#line 694 "../tmux.h"
struct screen {
   char *title ;
   struct screen_titles *titles ;
   struct grid *grid ;
   u_int___0 cx ;
   u_int___0 cy ;
   u_int___0 cstyle ;
   char *ccolour ;
   u_int___0 rupper ;
   u_int___0 rlower ;
   u_int___0 hsize ;
   int mode ;
   bitstr_t *tabs ;
   struct screen_sel sel ;
};
#line 766
struct winlink;
#line 788
struct window;
#line 788
struct window_mode;
#line 922 "../tmux.h"
struct __anonstruct_entry_36 {
   struct winlink *rbe_left ;
   struct winlink *rbe_right ;
   struct winlink *rbe_parent ;
   int rbe_color ;
};
#line 922 "../tmux.h"
struct __anonstruct_wentry_37 {
   struct winlink *tqe_next ;
   struct winlink **tqe_prev ;
};
#line 922 "../tmux.h"
struct __anonstruct_sentry_38 {
   struct winlink *tqe_next ;
   struct winlink **tqe_prev ;
};
#line 922 "../tmux.h"
struct winlink {
   int idx ;
   struct session *session ;
   struct window *window ;
   size_t status_width ;
   struct grid_cell status_cell ;
   char *status_text ;
   int flags ;
   struct __anonstruct_entry_36 entry ;
   struct __anonstruct_wentry_37 wentry ;
   struct __anonstruct_sentry_38 sentry ;
};
#line 941 "../tmux.h"
struct winlinks {
   struct winlink *rbh_root ;
};
#line 942 "../tmux.h"
struct winlink_stack {
   struct winlink *tqh_first ;
   struct winlink **tqh_last ;
};
#line 992
struct hooks;
#line 992 "../tmux.h"
struct __anonstruct_gentry_43 {
   struct session *tqe_next ;
   struct session **tqe_prev ;
};
#line 992 "../tmux.h"
struct __anonstruct_entry_44 {
   struct session *rbe_left ;
   struct session *rbe_right ;
   struct session *rbe_parent ;
   int rbe_color ;
};
#line 992 "../tmux.h"
struct session {
   u_int___0 id ;
   char *name ;
   char const   *cwd ;
   struct timeval creation_time ;
   struct timeval last_attached_time ;
   struct timeval activity_time ;
   struct timeval last_activity_time ;
   struct event lock_timer ;
   u_int___0 sx ;
   u_int___0 sy ;
   struct winlink *curw ;
   struct winlink_stack lastw ;
   struct winlinks windows ;
   int statusat ;
   struct hooks *hooks ;
   struct options *options ;
   int flags ;
   u_int___0 attached ;
   struct termios *tio ;
   struct environ *environ ;
   int references ;
   struct __anonstruct_gentry_43 gentry ;
   struct __anonstruct_entry_44 entry ;
};
#line 13 "tmux_uaf_7.c"
typedef unsigned int uint8_t;
#line 15 "tmux_uaf_7.c"
struct buffer {
   u_char___0 *base ;
   size_t space ;
   size_t size ;
   size_t off ;
};
#line 27 "tmux_uaf_7.c"
struct window_mode {
   void (*init)(struct window * ) ;
   void (*resize)(struct window * , u_int___0  , u_int___0  ) ;
   void (*draw)(struct window * , struct buffer * , u_int___0  , u_int___0  ) ;
   void (*key)(struct window * , int  ) ;
};
#line 35 "tmux_uaf_7.c"
struct window {
   char *name ;
   int fd ;
   struct buffer *in ;
   struct buffer *out ;
   int flags ;
   struct screen screen ;
   struct window_mode  const  *mode ;
   void *modedata ;
   u_int___0 references ;
};
#line 52 "tmux_uaf_7.c"
struct windows {
   struct window **list ;
   u_int___0 num ;
   size_t space ;
};
#line 66 "tmux_uaf_7.c"
struct window_scroll_mode_data {
   u_int___0 off ;
   u_int___0 size ;
};
#line 71 "tmux_uaf_7.c"
struct session___0 {
   char *name ;
   u_int___0 sx ;
   u_int___0 sy ;
   struct winlink *curw ;
   struct winlinks windows ;
};
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 431
extern int scanf(char const   * __restrict  __format  , ...)  __asm__("__isoc99_scanf")  ;
#line 374 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rand)(void) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 54 "tmux_uaf_7.c"
void window_scroll_init(struct window *w ) ;
#line 57
void window_scroll_key(struct window *w , int key ) ;
#line 59 "tmux_uaf_7.c"
struct window_mode  const  window_scroll_mode  =    {& window_scroll_init, (void (*)(struct window * , u_int___0  , u_int___0  ))((void *)0),
    (void (*)(struct window * , struct buffer * , u_int___0  , u_int___0  ))((void *)0),
    & window_scroll_key};
#line 84 "tmux_uaf_7.c"
struct windows windows  ;
#line 86 "tmux_uaf_7.c"
int winlink_cmp(struct winlink *wl1 , struct winlink *wl2 ) 
{ 


  {
#line 89
  return (wl1->idx - wl2->idx);
}
}
#line 92 "tmux_uaf_7.c"
void winlinks_RB_INSERT_COLOR(struct winlinks *head , struct winlink *elm ) 
{ 
  struct winlink *parent ;
  struct winlink *gparent ;
  struct winlink *tmp ;
  struct winlink *tmp___0 ;
  struct winlink *tmp___1 ;
  struct winlink *tmp___2 ;
  struct winlink *tmp___3 ;
  struct winlink *tmp___4 ;
  struct winlink *tmp___5 ;
  struct winlink *tmp___6 ;
  struct winlink *tmp___7 ;

  {
#line 92
  while (1) {
#line 92
    parent = elm->entry.rbe_parent;
#line 92
    if ((unsigned long )parent != (unsigned long )((void *)0)) {
#line 92
      if (! (parent->entry.rbe_color == 1)) {
#line 92
        break;
      }
    } else {
#line 92
      break;
    }
#line 92
    gparent = parent->entry.rbe_parent;
#line 92
    if ((unsigned long )parent == (unsigned long )gparent->entry.rbe_left) {
#line 92
      tmp = gparent->entry.rbe_right;
#line 92
      if (tmp) {
#line 92
        if (tmp->entry.rbe_color == 1) {
#line 92
          tmp->entry.rbe_color = 0;
#line 92
          while (1) {
#line 92
            parent->entry.rbe_color = 0;
#line 92
            gparent->entry.rbe_color = 1;
#line 92
            break;
          }
#line 92
          elm = gparent;
#line 92
          continue;
        }
      }
#line 92
      if ((unsigned long )parent->entry.rbe_right == (unsigned long )elm) {
#line 92
        while (1) {
#line 92
          tmp = parent->entry.rbe_right;
#line 92
          tmp___0 = tmp->entry.rbe_left;
#line 92
          parent->entry.rbe_right = tmp___0;
#line 92
          if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 92
            (tmp->entry.rbe_left)->entry.rbe_parent = parent;
          }
#line 92
          while (1) {
#line 92
            break;
          }
#line 92
          tmp___1 = parent->entry.rbe_parent;
#line 92
          tmp->entry.rbe_parent = tmp___1;
#line 92
          if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
#line 92
            if ((unsigned long )parent == (unsigned long )(parent->entry.rbe_parent)->entry.rbe_left) {
#line 92
              (parent->entry.rbe_parent)->entry.rbe_left = tmp;
            } else {
#line 92
              (parent->entry.rbe_parent)->entry.rbe_right = tmp;
            }
          } else {
#line 92
            head->rbh_root = tmp;
          }
#line 92
          tmp->entry.rbe_left = parent;
#line 92
          parent->entry.rbe_parent = tmp;
#line 92
          while (1) {
#line 92
            break;
          }
#line 92
          if (tmp->entry.rbe_parent) {
#line 92
            while (1) {
#line 92
              break;
            }
          }
#line 92
          break;
        }
#line 92
        tmp = parent;
#line 92
        parent = elm;
#line 92
        elm = tmp;
      }
#line 92
      while (1) {
#line 92
        parent->entry.rbe_color = 0;
#line 92
        gparent->entry.rbe_color = 1;
#line 92
        break;
      }
#line 92
      while (1) {
#line 92
        tmp = gparent->entry.rbe_left;
#line 92
        tmp___2 = tmp->entry.rbe_right;
#line 92
        gparent->entry.rbe_left = tmp___2;
#line 92
        if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
#line 92
          (tmp->entry.rbe_right)->entry.rbe_parent = gparent;
        }
#line 92
        while (1) {
#line 92
          break;
        }
#line 92
        tmp___3 = gparent->entry.rbe_parent;
#line 92
        tmp->entry.rbe_parent = tmp___3;
#line 92
        if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
#line 92
          if ((unsigned long )gparent == (unsigned long )(gparent->entry.rbe_parent)->entry.rbe_left) {
#line 92
            (gparent->entry.rbe_parent)->entry.rbe_left = tmp;
          } else {
#line 92
            (gparent->entry.rbe_parent)->entry.rbe_right = tmp;
          }
        } else {
#line 92
          head->rbh_root = tmp;
        }
#line 92
        tmp->entry.rbe_right = gparent;
#line 92
        gparent->entry.rbe_parent = tmp;
#line 92
        while (1) {
#line 92
          break;
        }
#line 92
        if (tmp->entry.rbe_parent) {
#line 92
          while (1) {
#line 92
            break;
          }
        }
#line 92
        break;
      }
    } else {
#line 92
      tmp = gparent->entry.rbe_left;
#line 92
      if (tmp) {
#line 92
        if (tmp->entry.rbe_color == 1) {
#line 92
          tmp->entry.rbe_color = 0;
#line 92
          while (1) {
#line 92
            parent->entry.rbe_color = 0;
#line 92
            gparent->entry.rbe_color = 1;
#line 92
            break;
          }
#line 92
          elm = gparent;
#line 92
          continue;
        }
      }
#line 92
      if ((unsigned long )parent->entry.rbe_left == (unsigned long )elm) {
#line 92
        while (1) {
#line 92
          tmp = parent->entry.rbe_left;
#line 92
          tmp___4 = tmp->entry.rbe_right;
#line 92
          parent->entry.rbe_left = tmp___4;
#line 92
          if ((unsigned long )tmp___4 != (unsigned long )((void *)0)) {
#line 92
            (tmp->entry.rbe_right)->entry.rbe_parent = parent;
          }
#line 92
          while (1) {
#line 92
            break;
          }
#line 92
          tmp___5 = parent->entry.rbe_parent;
#line 92
          tmp->entry.rbe_parent = tmp___5;
#line 92
          if ((unsigned long )tmp___5 != (unsigned long )((void *)0)) {
#line 92
            if ((unsigned long )parent == (unsigned long )(parent->entry.rbe_parent)->entry.rbe_left) {
#line 92
              (parent->entry.rbe_parent)->entry.rbe_left = tmp;
            } else {
#line 92
              (parent->entry.rbe_parent)->entry.rbe_right = tmp;
            }
          } else {
#line 92
            head->rbh_root = tmp;
          }
#line 92
          tmp->entry.rbe_right = parent;
#line 92
          parent->entry.rbe_parent = tmp;
#line 92
          while (1) {
#line 92
            break;
          }
#line 92
          if (tmp->entry.rbe_parent) {
#line 92
            while (1) {
#line 92
              break;
            }
          }
#line 92
          break;
        }
#line 92
        tmp = parent;
#line 92
        parent = elm;
#line 92
        elm = tmp;
      }
#line 92
      while (1) {
#line 92
        parent->entry.rbe_color = 0;
#line 92
        gparent->entry.rbe_color = 1;
#line 92
        break;
      }
#line 92
      while (1) {
#line 92
        tmp = gparent->entry.rbe_right;
#line 92
        tmp___6 = tmp->entry.rbe_left;
#line 92
        gparent->entry.rbe_right = tmp___6;
#line 92
        if ((unsigned long )tmp___6 != (unsigned long )((void *)0)) {
#line 92
          (tmp->entry.rbe_left)->entry.rbe_parent = gparent;
        }
#line 92
        while (1) {
#line 92
          break;
        }
#line 92
        tmp___7 = gparent->entry.rbe_parent;
#line 92
        tmp->entry.rbe_parent = tmp___7;
#line 92
        if ((unsigned long )tmp___7 != (unsigned long )((void *)0)) {
#line 92
          if ((unsigned long )gparent == (unsigned long )(gparent->entry.rbe_parent)->entry.rbe_left) {
#line 92
            (gparent->entry.rbe_parent)->entry.rbe_left = tmp;
          } else {
#line 92
            (gparent->entry.rbe_parent)->entry.rbe_right = tmp;
          }
        } else {
#line 92
          head->rbh_root = tmp;
        }
#line 92
        tmp->entry.rbe_left = gparent;
#line 92
        gparent->entry.rbe_parent = tmp;
#line 92
        while (1) {
#line 92
          break;
        }
#line 92
        if (tmp->entry.rbe_parent) {
#line 92
          while (1) {
#line 92
            break;
          }
        }
#line 92
        break;
      }
    }
  }
#line 92
  (head->rbh_root)->entry.rbe_color = 0;
#line 92
  return;
}
}
#line 92 "tmux_uaf_7.c"
void winlinks_RB_REMOVE_COLOR(struct winlinks *head , struct winlink *parent , struct winlink *elm ) 
{ 
  struct winlink *tmp ;
  struct winlink *tmp___0 ;
  struct winlink *tmp___1 ;
  struct winlink *oleft ;
  struct winlink *tmp___2 ;
  struct winlink *tmp___3 ;
  struct winlink *tmp___4 ;
  struct winlink *tmp___5 ;
  struct winlink *tmp___6 ;
  struct winlink *tmp___7 ;
  struct winlink *oright ;
  struct winlink *tmp___8 ;
  struct winlink *tmp___9 ;
  struct winlink *tmp___10 ;
  struct winlink *tmp___11 ;

  {
#line 92
  while (1) {
#line 92
    if ((unsigned long )elm == (unsigned long )((void *)0)) {
#line 92
      goto _L___5;
    } else
#line 92
    if (elm->entry.rbe_color == 0) {
      _L___5: /* CIL Label */ 
#line 92
      if (! ((unsigned long )elm != (unsigned long )head->rbh_root)) {
#line 92
        break;
      }
    } else {
#line 92
      break;
    }
#line 92
    if ((unsigned long )parent->entry.rbe_left == (unsigned long )elm) {
#line 92
      tmp = parent->entry.rbe_right;
#line 92
      if (tmp->entry.rbe_color == 1) {
#line 92
        while (1) {
#line 92
          tmp->entry.rbe_color = 0;
#line 92
          parent->entry.rbe_color = 1;
#line 92
          break;
        }
#line 92
        while (1) {
#line 92
          tmp = parent->entry.rbe_right;
#line 92
          tmp___0 = tmp->entry.rbe_left;
#line 92
          parent->entry.rbe_right = tmp___0;
#line 92
          if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 92
            (tmp->entry.rbe_left)->entry.rbe_parent = parent;
          }
#line 92
          while (1) {
#line 92
            break;
          }
#line 92
          tmp___1 = parent->entry.rbe_parent;
#line 92
          tmp->entry.rbe_parent = tmp___1;
#line 92
          if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
#line 92
            if ((unsigned long )parent == (unsigned long )(parent->entry.rbe_parent)->entry.rbe_left) {
#line 92
              (parent->entry.rbe_parent)->entry.rbe_left = tmp;
            } else {
#line 92
              (parent->entry.rbe_parent)->entry.rbe_right = tmp;
            }
          } else {
#line 92
            head->rbh_root = tmp;
          }
#line 92
          tmp->entry.rbe_left = parent;
#line 92
          parent->entry.rbe_parent = tmp;
#line 92
          while (1) {
#line 92
            break;
          }
#line 92
          if (tmp->entry.rbe_parent) {
#line 92
            while (1) {
#line 92
              break;
            }
          }
#line 92
          break;
        }
#line 92
        tmp = parent->entry.rbe_right;
      }
#line 92
      if ((unsigned long )tmp->entry.rbe_left == (unsigned long )((void *)0)) {
#line 92
        goto _L___1;
      } else
#line 92
      if ((tmp->entry.rbe_left)->entry.rbe_color == 0) {
        _L___1: /* CIL Label */ 
#line 92
        if ((unsigned long )tmp->entry.rbe_right == (unsigned long )((void *)0)) {
#line 92
          tmp->entry.rbe_color = 1;
#line 92
          elm = parent;
#line 92
          parent = elm->entry.rbe_parent;
        } else
#line 92
        if ((tmp->entry.rbe_right)->entry.rbe_color == 0) {
#line 92
          tmp->entry.rbe_color = 1;
#line 92
          elm = parent;
#line 92
          parent = elm->entry.rbe_parent;
        } else {
#line 92
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 92
        if ((unsigned long )tmp->entry.rbe_right == (unsigned long )((void *)0)) {
#line 92
          goto _L;
        } else
#line 92
        if ((tmp->entry.rbe_right)->entry.rbe_color == 0) {
          _L: /* CIL Label */ 
#line 92
          oleft = tmp->entry.rbe_left;
#line 92
          if ((unsigned long )oleft != (unsigned long )((void *)0)) {
#line 92
            oleft->entry.rbe_color = 0;
          }
#line 92
          tmp->entry.rbe_color = 1;
#line 92
          while (1) {
#line 92
            oleft = tmp->entry.rbe_left;
#line 92
            tmp___2 = oleft->entry.rbe_right;
#line 92
            tmp->entry.rbe_left = tmp___2;
#line 92
            if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
#line 92
              (oleft->entry.rbe_right)->entry.rbe_parent = tmp;
            }
#line 92
            while (1) {
#line 92
              break;
            }
#line 92
            tmp___3 = tmp->entry.rbe_parent;
#line 92
            oleft->entry.rbe_parent = tmp___3;
#line 92
            if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
#line 92
              if ((unsigned long )tmp == (unsigned long )(tmp->entry.rbe_parent)->entry.rbe_left) {
#line 92
                (tmp->entry.rbe_parent)->entry.rbe_left = oleft;
              } else {
#line 92
                (tmp->entry.rbe_parent)->entry.rbe_right = oleft;
              }
            } else {
#line 92
              head->rbh_root = oleft;
            }
#line 92
            oleft->entry.rbe_right = tmp;
#line 92
            tmp->entry.rbe_parent = oleft;
#line 92
            while (1) {
#line 92
              break;
            }
#line 92
            if (oleft->entry.rbe_parent) {
#line 92
              while (1) {
#line 92
                break;
              }
            }
#line 92
            break;
          }
#line 92
          tmp = parent->entry.rbe_right;
        }
#line 92
        tmp->entry.rbe_color = parent->entry.rbe_color;
#line 92
        parent->entry.rbe_color = 0;
#line 92
        if (tmp->entry.rbe_right) {
#line 92
          (tmp->entry.rbe_right)->entry.rbe_color = 0;
        }
#line 92
        while (1) {
#line 92
          tmp = parent->entry.rbe_right;
#line 92
          tmp___4 = tmp->entry.rbe_left;
#line 92
          parent->entry.rbe_right = tmp___4;
#line 92
          if ((unsigned long )tmp___4 != (unsigned long )((void *)0)) {
#line 92
            (tmp->entry.rbe_left)->entry.rbe_parent = parent;
          }
#line 92
          while (1) {
#line 92
            break;
          }
#line 92
          tmp___5 = parent->entry.rbe_parent;
#line 92
          tmp->entry.rbe_parent = tmp___5;
#line 92
          if ((unsigned long )tmp___5 != (unsigned long )((void *)0)) {
#line 92
            if ((unsigned long )parent == (unsigned long )(parent->entry.rbe_parent)->entry.rbe_left) {
#line 92
              (parent->entry.rbe_parent)->entry.rbe_left = tmp;
            } else {
#line 92
              (parent->entry.rbe_parent)->entry.rbe_right = tmp;
            }
          } else {
#line 92
            head->rbh_root = tmp;
          }
#line 92
          tmp->entry.rbe_left = parent;
#line 92
          parent->entry.rbe_parent = tmp;
#line 92
          while (1) {
#line 92
            break;
          }
#line 92
          if (tmp->entry.rbe_parent) {
#line 92
            while (1) {
#line 92
              break;
            }
          }
#line 92
          break;
        }
#line 92
        elm = head->rbh_root;
#line 92
        break;
      }
    } else {
#line 92
      tmp = parent->entry.rbe_left;
#line 92
      if (tmp->entry.rbe_color == 1) {
#line 92
        while (1) {
#line 92
          tmp->entry.rbe_color = 0;
#line 92
          parent->entry.rbe_color = 1;
#line 92
          break;
        }
#line 92
        while (1) {
#line 92
          tmp = parent->entry.rbe_left;
#line 92
          tmp___6 = tmp->entry.rbe_right;
#line 92
          parent->entry.rbe_left = tmp___6;
#line 92
          if ((unsigned long )tmp___6 != (unsigned long )((void *)0)) {
#line 92
            (tmp->entry.rbe_right)->entry.rbe_parent = parent;
          }
#line 92
          while (1) {
#line 92
            break;
          }
#line 92
          tmp___7 = parent->entry.rbe_parent;
#line 92
          tmp->entry.rbe_parent = tmp___7;
#line 92
          if ((unsigned long )tmp___7 != (unsigned long )((void *)0)) {
#line 92
            if ((unsigned long )parent == (unsigned long )(parent->entry.rbe_parent)->entry.rbe_left) {
#line 92
              (parent->entry.rbe_parent)->entry.rbe_left = tmp;
            } else {
#line 92
              (parent->entry.rbe_parent)->entry.rbe_right = tmp;
            }
          } else {
#line 92
            head->rbh_root = tmp;
          }
#line 92
          tmp->entry.rbe_right = parent;
#line 92
          parent->entry.rbe_parent = tmp;
#line 92
          while (1) {
#line 92
            break;
          }
#line 92
          if (tmp->entry.rbe_parent) {
#line 92
            while (1) {
#line 92
              break;
            }
          }
#line 92
          break;
        }
#line 92
        tmp = parent->entry.rbe_left;
      }
#line 92
      if ((unsigned long )tmp->entry.rbe_left == (unsigned long )((void *)0)) {
#line 92
        goto _L___4;
      } else
#line 92
      if ((tmp->entry.rbe_left)->entry.rbe_color == 0) {
        _L___4: /* CIL Label */ 
#line 92
        if ((unsigned long )tmp->entry.rbe_right == (unsigned long )((void *)0)) {
#line 92
          tmp->entry.rbe_color = 1;
#line 92
          elm = parent;
#line 92
          parent = elm->entry.rbe_parent;
        } else
#line 92
        if ((tmp->entry.rbe_right)->entry.rbe_color == 0) {
#line 92
          tmp->entry.rbe_color = 1;
#line 92
          elm = parent;
#line 92
          parent = elm->entry.rbe_parent;
        } else {
#line 92
          goto _L___3;
        }
      } else {
        _L___3: /* CIL Label */ 
#line 92
        if ((unsigned long )tmp->entry.rbe_left == (unsigned long )((void *)0)) {
#line 92
          goto _L___2;
        } else
#line 92
        if ((tmp->entry.rbe_left)->entry.rbe_color == 0) {
          _L___2: /* CIL Label */ 
#line 92
          oright = tmp->entry.rbe_right;
#line 92
          if ((unsigned long )oright != (unsigned long )((void *)0)) {
#line 92
            oright->entry.rbe_color = 0;
          }
#line 92
          tmp->entry.rbe_color = 1;
#line 92
          while (1) {
#line 92
            oright = tmp->entry.rbe_right;
#line 92
            tmp___8 = oright->entry.rbe_left;
#line 92
            tmp->entry.rbe_right = tmp___8;
#line 92
            if ((unsigned long )tmp___8 != (unsigned long )((void *)0)) {
#line 92
              (oright->entry.rbe_left)->entry.rbe_parent = tmp;
            }
#line 92
            while (1) {
#line 92
              break;
            }
#line 92
            tmp___9 = tmp->entry.rbe_parent;
#line 92
            oright->entry.rbe_parent = tmp___9;
#line 92
            if ((unsigned long )tmp___9 != (unsigned long )((void *)0)) {
#line 92
              if ((unsigned long )tmp == (unsigned long )(tmp->entry.rbe_parent)->entry.rbe_left) {
#line 92
                (tmp->entry.rbe_parent)->entry.rbe_left = oright;
              } else {
#line 92
                (tmp->entry.rbe_parent)->entry.rbe_right = oright;
              }
            } else {
#line 92
              head->rbh_root = oright;
            }
#line 92
            oright->entry.rbe_left = tmp;
#line 92
            tmp->entry.rbe_parent = oright;
#line 92
            while (1) {
#line 92
              break;
            }
#line 92
            if (oright->entry.rbe_parent) {
#line 92
              while (1) {
#line 92
                break;
              }
            }
#line 92
            break;
          }
#line 92
          tmp = parent->entry.rbe_left;
        }
#line 92
        tmp->entry.rbe_color = parent->entry.rbe_color;
#line 92
        parent->entry.rbe_color = 0;
#line 92
        if (tmp->entry.rbe_left) {
#line 92
          (tmp->entry.rbe_left)->entry.rbe_color = 0;
        }
#line 92
        while (1) {
#line 92
          tmp = parent->entry.rbe_left;
#line 92
          tmp___10 = tmp->entry.rbe_right;
#line 92
          parent->entry.rbe_left = tmp___10;
#line 92
          if ((unsigned long )tmp___10 != (unsigned long )((void *)0)) {
#line 92
            (tmp->entry.rbe_right)->entry.rbe_parent = parent;
          }
#line 92
          while (1) {
#line 92
            break;
          }
#line 92
          tmp___11 = parent->entry.rbe_parent;
#line 92
          tmp->entry.rbe_parent = tmp___11;
#line 92
          if ((unsigned long )tmp___11 != (unsigned long )((void *)0)) {
#line 92
            if ((unsigned long )parent == (unsigned long )(parent->entry.rbe_parent)->entry.rbe_left) {
#line 92
              (parent->entry.rbe_parent)->entry.rbe_left = tmp;
            } else {
#line 92
              (parent->entry.rbe_parent)->entry.rbe_right = tmp;
            }
          } else {
#line 92
            head->rbh_root = tmp;
          }
#line 92
          tmp->entry.rbe_right = parent;
#line 92
          parent->entry.rbe_parent = tmp;
#line 92
          while (1) {
#line 92
            break;
          }
#line 92
          if (tmp->entry.rbe_parent) {
#line 92
            while (1) {
#line 92
              break;
            }
          }
#line 92
          break;
        }
#line 92
        elm = head->rbh_root;
#line 92
        break;
      }
    }
  }
#line 92
  if (elm) {
#line 92
    elm->entry.rbe_color = 0;
  }
#line 92
  return;
}
}
#line 92 "tmux_uaf_7.c"
struct winlink *winlinks_RB_INSERT(struct winlinks *head , struct winlink *elm ) 
{ 
  struct winlink *tmp ;
  struct winlink *parent ;
  int comp ;
  struct winlink *tmp___0 ;

  {
#line 92
  parent = (struct winlink *)((void *)0);
#line 92
  comp = 0;
#line 92
  tmp = head->rbh_root;
#line 92
  while (tmp) {
#line 92
    parent = tmp;
#line 92
    comp = winlink_cmp(elm, parent);
#line 92
    if (comp < 0) {
#line 92
      tmp = tmp->entry.rbe_left;
    } else
#line 92
    if (comp > 0) {
#line 92
      tmp = tmp->entry.rbe_right;
    } else {
#line 92
      return (tmp);
    }
  }
#line 92
  while (1) {
#line 92
    elm->entry.rbe_parent = parent;
#line 92
    tmp___0 = (struct winlink *)((void *)0);
#line 92
    elm->entry.rbe_right = tmp___0;
#line 92
    elm->entry.rbe_left = tmp___0;
#line 92
    elm->entry.rbe_color = 1;
#line 92
    break;
  }
#line 92
  if ((unsigned long )parent != (unsigned long )((void *)0)) {
#line 92
    if (comp < 0) {
#line 92
      parent->entry.rbe_left = elm;
    } else {
#line 92
      parent->entry.rbe_right = elm;
    }
#line 92
    while (1) {
#line 92
      break;
    }
  } else {
#line 92
    head->rbh_root = elm;
  }
#line 92
  winlinks_RB_INSERT_COLOR(head, elm);
#line 92
  return ((struct winlink *)((void *)0));
}
}
#line 92 "tmux_uaf_7.c"
struct winlink *winlinks_RB_REMOVE(struct winlinks *head , struct winlink *elm ) 
{ 
  struct winlink *child ;
  struct winlink *parent ;
  struct winlink *old ;
  int color ;
  struct winlink *left ;

  {
#line 92
  old = elm;
#line 92
  if ((unsigned long )elm->entry.rbe_left == (unsigned long )((void *)0)) {
#line 92
    child = elm->entry.rbe_right;
  } else
#line 92
  if ((unsigned long )elm->entry.rbe_right == (unsigned long )((void *)0)) {
#line 92
    child = elm->entry.rbe_left;
  } else {
#line 92
    elm = elm->entry.rbe_right;
#line 92
    while (1) {
#line 92
      left = elm->entry.rbe_left;
#line 92
      if (! ((unsigned long )left != (unsigned long )((void *)0))) {
#line 92
        break;
      }
#line 92
      elm = left;
    }
#line 92
    child = elm->entry.rbe_right;
#line 92
    parent = elm->entry.rbe_parent;
#line 92
    color = elm->entry.rbe_color;
#line 92
    if (child) {
#line 92
      child->entry.rbe_parent = parent;
    }
#line 92
    if (parent) {
#line 92
      if ((unsigned long )parent->entry.rbe_left == (unsigned long )elm) {
#line 92
        parent->entry.rbe_left = child;
      } else {
#line 92
        parent->entry.rbe_right = child;
      }
#line 92
      while (1) {
#line 92
        break;
      }
    } else {
#line 92
      head->rbh_root = child;
    }
#line 92
    if ((unsigned long )elm->entry.rbe_parent == (unsigned long )old) {
#line 92
      parent = elm;
    }
#line 92
    elm->entry = old->entry;
#line 92
    if (old->entry.rbe_parent) {
#line 92
      if ((unsigned long )(old->entry.rbe_parent)->entry.rbe_left == (unsigned long )old) {
#line 92
        (old->entry.rbe_parent)->entry.rbe_left = elm;
      } else {
#line 92
        (old->entry.rbe_parent)->entry.rbe_right = elm;
      }
#line 92
      while (1) {
#line 92
        break;
      }
    } else {
#line 92
      head->rbh_root = elm;
    }
#line 92
    (old->entry.rbe_left)->entry.rbe_parent = elm;
#line 92
    if (old->entry.rbe_right) {
#line 92
      (old->entry.rbe_right)->entry.rbe_parent = elm;
    }
#line 92
    if (parent) {
#line 92
      left = parent;
#line 92
      while (1) {
#line 92
        while (1) {
#line 92
          break;
        }
#line 92
        left = left->entry.rbe_parent;
#line 92
        if (! ((unsigned long )left != (unsigned long )((void *)0))) {
#line 92
          break;
        }
      }
    }
#line 92
    goto color;
  }
#line 92
  parent = elm->entry.rbe_parent;
#line 92
  color = elm->entry.rbe_color;
#line 92
  if (child) {
#line 92
    child->entry.rbe_parent = parent;
  }
#line 92
  if (parent) {
#line 92
    if ((unsigned long )parent->entry.rbe_left == (unsigned long )elm) {
#line 92
      parent->entry.rbe_left = child;
    } else {
#line 92
      parent->entry.rbe_right = child;
    }
#line 92
    while (1) {
#line 92
      break;
    }
  } else {
#line 92
    head->rbh_root = child;
  }
  color: 
#line 92
  if (color == 0) {
#line 92
    winlinks_RB_REMOVE_COLOR(head, parent, child);
  }
#line 92
  return (old);
}
}
#line 92 "tmux_uaf_7.c"
struct winlink *winlinks_RB_FIND(struct winlinks *head , struct winlink *elm ) 
{ 
  struct winlink *tmp ;
  int comp ;

  {
#line 92
  tmp = head->rbh_root;
#line 92
  while (tmp) {
#line 92
    comp = winlink_cmp(elm, tmp);
#line 92
    if (comp < 0) {
#line 92
      tmp = tmp->entry.rbe_left;
    } else
#line 92
    if (comp > 0) {
#line 92
      tmp = tmp->entry.rbe_right;
    } else {
#line 92
      return (tmp);
    }
  }
#line 92
  return ((struct winlink *)((void *)0));
}
}
#line 92 "tmux_uaf_7.c"
struct winlink *winlinks_RB_NFIND(struct winlinks *head , struct winlink *elm ) 
{ 
  struct winlink *tmp ;
  struct winlink *res ;
  int comp ;

  {
#line 92
  tmp = head->rbh_root;
#line 92
  res = (struct winlink *)((void *)0);
#line 92
  while (tmp) {
#line 92
    comp = winlink_cmp(elm, tmp);
#line 92
    if (comp < 0) {
#line 92
      res = tmp;
#line 92
      tmp = tmp->entry.rbe_left;
    } else
#line 92
    if (comp > 0) {
#line 92
      tmp = tmp->entry.rbe_right;
    } else {
#line 92
      return (tmp);
    }
  }
#line 92
  return (res);
}
}
#line 92 "tmux_uaf_7.c"
struct winlink *winlinks_RB_NEXT(struct winlink *elm ) 
{ 


  {
#line 92
  if (elm->entry.rbe_right) {
#line 92
    elm = elm->entry.rbe_right;
#line 92
    while (elm->entry.rbe_left) {
#line 92
      elm = elm->entry.rbe_left;
    }
  } else
#line 92
  if (elm->entry.rbe_parent) {
#line 92
    if ((unsigned long )elm == (unsigned long )(elm->entry.rbe_parent)->entry.rbe_left) {
#line 92
      elm = elm->entry.rbe_parent;
    } else {
#line 92
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 92
    while (1) {
#line 92
      if (elm->entry.rbe_parent) {
#line 92
        if (! ((unsigned long )elm == (unsigned long )(elm->entry.rbe_parent)->entry.rbe_right)) {
#line 92
          break;
        }
      } else {
#line 92
        break;
      }
#line 92
      elm = elm->entry.rbe_parent;
    }
#line 92
    elm = elm->entry.rbe_parent;
  }
#line 92
  return (elm);
}
}
#line 92 "tmux_uaf_7.c"
struct winlink *winlinks_RB_PREV(struct winlink *elm ) 
{ 


  {
#line 92
  if (elm->entry.rbe_left) {
#line 92
    elm = elm->entry.rbe_left;
#line 92
    while (elm->entry.rbe_right) {
#line 92
      elm = elm->entry.rbe_right;
    }
  } else
#line 92
  if (elm->entry.rbe_parent) {
#line 92
    if ((unsigned long )elm == (unsigned long )(elm->entry.rbe_parent)->entry.rbe_right) {
#line 92
      elm = elm->entry.rbe_parent;
    } else {
#line 92
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 92
    while (1) {
#line 92
      if (elm->entry.rbe_parent) {
#line 92
        if (! ((unsigned long )elm == (unsigned long )(elm->entry.rbe_parent)->entry.rbe_left)) {
#line 92
          break;
        }
      } else {
#line 92
        break;
      }
#line 92
      elm = elm->entry.rbe_parent;
    }
#line 92
    elm = elm->entry.rbe_parent;
  }
#line 92
  return (elm);
}
}
#line 92 "tmux_uaf_7.c"
struct winlink *winlinks_RB_MINMAX(struct winlinks *head , int val ) 
{ 
  struct winlink *tmp ;
  struct winlink *parent ;

  {
#line 92
  tmp = head->rbh_root;
#line 92
  parent = (struct winlink *)((void *)0);
#line 92
  while (tmp) {
#line 92
    parent = tmp;
#line 92
    if (val < 0) {
#line 92
      tmp = tmp->entry.rbe_left;
    } else {
#line 92
      tmp = tmp->entry.rbe_right;
    }
  }
#line 92
  return (parent);
}
}
#line 94 "tmux_uaf_7.c"
void window_scroll_init(struct window *w ) 
{ 
  struct window_scroll_mode_data *data ;
  void *tmp ;

  {
#line 99
  tmp = malloc(sizeof(*data));
#line 99
  data = (struct window_scroll_mode_data *)tmp;
#line 99
  w->modedata = (void *)data;
#line 100
  data->off = (u_int___0 )0;
#line 101
  data->size = w->screen.hsize;
#line 102
  return;
}
}
#line 104 "tmux_uaf_7.c"
void window_scroll_key(struct window *w , int key ) 
{ 
  struct window_scroll_mode_data *data ;
  u_int___0 off ;
  u_int___0 sy ;

  {
#line 107
  data = (struct window_scroll_mode_data *)w->modedata;
#line 108
  sy = (w->screen.grid)->sy;
#line 110
  off = data->off;
#line 111
  switch (key) {
  case 113: 
  case 81: 
#line 114
  w->mode = (struct window_mode  const  *)((void *)0);
#line 115
  free(w->modedata);
#line 117
  break;
  case 268435545: 
  case 75: 
  case 107: 
#line 121
  if (data->off < data->size) {
#line 122
    (data->off) ++;
  }
#line 123
  break;
  case 268435546: 
  case 74: 
  case 106: 
#line 127
  if (data->off > 0U) {
#line 128
    (data->off) --;
  }
#line 129
  break;
  case 268435543: 
  case 21: 
#line 132
  if (data->off + sy > data->size) {
#line 133
    data->off = data->size;
  } else {
#line 135
    data->off += sy;
  }
#line 136
  break;
  case 268435542: 
  case 6: 
#line 139
  if (data->off < sy) {
#line 140
    data->off = (u_int___0 )0;
  } else {
#line 142
    data->off -= sy;
  }
#line 143
  break;
  }
#line 145
  if (off != data->off) {
#line 146
    return;
  }
#line 147
  return;
}
}
#line 150 "tmux_uaf_7.c"
void input_store8(struct buffer *b , uint8_t n ) 
{ 


  {
#line 153
  *(((b->base + b->off) + b->size) + 0) = (u_char___0 )n;
#line 154
  (b->size) ++;
#line 155
  return;
}
}
#line 158 "tmux_uaf_7.c"
void input_key(struct buffer *b , int key ) 
{ 


  {
#line 163
  if ((unsigned long long )key != 281470681743360ULL) {
#line 163
    if (key >= 0) {
#line 164
      input_store8(b, (uint8_t )key);
#line 165
      return;
    }
  }
#line 167
  return;
}
}
#line 168 "tmux_uaf_7.c"
void window_key(struct window *w , int key ) 
{ 


  {
#line 171
  if ((unsigned long )w->mode != (unsigned long )((void *)0)) {
#line 172
    (*((w->mode)->key))(w, key);
  } else {
#line 174
    input_key(w->out, key);
  }
#line 175
  return;
}
}
#line 177 "tmux_uaf_7.c"
struct window *window_create(char const   *name , char const   *cmd , char const   **env ,
                             u_int___0 sx , u_int___0 sy ) 
{ 
  struct window *w ;
  void *tmp ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 183
  tmp = malloc(sizeof(*w));
#line 183
  w = (struct window *)tmp;
#line 184
  w->mode = (struct window_mode  const  *)((void *)0);
#line 186
  tmp___2 = rand();
#line 186
  if (tmp___2 % 2 == 1) {
#line 186
    tmp___1 = 1;
  } else {
#line 186
    tmp___1 = 0;
  }
#line 186
  if (tmp___1) {
#line 188
    w->mode = & window_scroll_mode;
#line 189
    (*((w->mode)->init))(w);
  }
#line 193
  return (w);
}
}
#line 196 "tmux_uaf_7.c"
void window_destroy(struct window *w ) 
{ 


  {
#line 199
  free((void *)w);
#line 200
  return;
}
}
#line 202 "tmux_uaf_7.c"
struct winlink *winlink_add(struct winlinks *wwl , struct window *w , int idx ) 
{ 
  struct winlink *wl ;
  void *tmp ;

  {
#line 207
  tmp = calloc((size_t )1, sizeof(*wl));
#line 207
  wl = (struct winlink *)tmp;
#line 208
  wl->idx = idx;
#line 209
  wl->window = w;
#line 210
  winlinks_RB_INSERT(wwl, wl);
#line 212
  (w->references) ++;
#line 214
  return (wl);
}
}
#line 217 "tmux_uaf_7.c"
void winlink_remove(struct winlinks *wwl , struct winlink *wl ) 
{ 
  struct window *w ;

  {
#line 220
  w = wl->window;
#line 222
  winlinks_RB_REMOVE(wwl, wl);
#line 223
  free((void *)wl);
#line 225
  if (w->references == 0U) {
#line 226
    printf((char const   * __restrict  )"bad reference count%s\n", "");
#line 226
    exit(1);
  }
#line 227
  (w->references) --;
#line 228
  if (w->references == 0U) {
#line 229
    window_destroy(w);
  }
#line 230
  return;
}
}
#line 233 "tmux_uaf_7.c"
void session_destroy(struct session___0 *s ) 
{ 


  {
#line 238
  printf((char const   * __restrict  )"session %s destroyed\n", s->name);
#line 240
  while (! ((unsigned long )s->windows.rbh_root == (unsigned long )((void *)0))) {
#line 241
    winlink_remove(& s->windows, s->windows.rbh_root);
  }
#line 243
  free((void *)s->name);
#line 244
  free((void *)s);
#line 245
  return;
}
}
#line 247 "tmux_uaf_7.c"
struct winlink *session_attach(struct session___0 *s , struct window *w , int idx ,
                               char **cause ) 
{ 
  struct winlink *wl ;

  {
#line 252
  wl = winlink_add(& s->windows, w, idx);
#line 252
  if ((unsigned long )wl == (unsigned long )((void *)0)) {
#line 253
    printf((char const   * __restrict  )"index in use: %d\n", idx);
  }
#line 254
  return (wl);
}
}
#line 258 "tmux_uaf_7.c"
struct winlink *session_new(struct session___0 *s , char const   *name , char const   *cmd ,
                            char const   *cwd , int idx , char **cause ) 
{ 
  struct window *w ;
  struct winlink *tmp ;

  {
#line 267
  w = window_create(name, cmd, (char const   **)((void *)0), s->sx, s->sy);
#line 268
  if ((unsigned long )w == (unsigned long )((void *)0)) {
#line 269
    return ((struct winlink *)((void *)0));
  }
#line 272
  tmp = session_attach(s, w, idx, cause);
#line 272
  return (tmp);
}
}
#line 294
extern int ( /* missing proto */  strdup)() ;
#line 275 "tmux_uaf_7.c"
struct session___0 *session_create(char const   *name , char const   *cmd , char const   *cwd ,
                                   struct environ *env , struct termios *tio , int idx ,
                                   u_int___0 sx , u_int___0 sy , char **cause ) 
{ 
  struct session___0 *s ;
  struct winlink *wl ;
  void *tmp ;
  int tmp___0 ;

  {
#line 284
  tmp = malloc(sizeof(*s));
#line 284
  s = (struct session___0 *)tmp;
#line 286
  s->curw = (struct winlink *)((void *)0);
#line 287
  while (1) {
#line 287
    s->windows.rbh_root = (struct winlink *)((void *)0);
#line 287
    break;
  }
#line 289
  s->sx = sx;
#line 290
  s->sy = sy;
#line 292
  if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 293
    printf((char const   * __restrict  )"no name%s\n", "");
#line 293
    exit(1);
  }
#line 294
  tmp___0 = strdup(name);
#line 294
  s->name = (char *)tmp___0;
#line 296
  if ((unsigned long )cmd != (unsigned long )((void *)0)) {
#line 297
    wl = session_new(s, (char const   *)((void *)0), cmd, cwd, idx, cause);
#line 297
    if ((unsigned long )wl == (unsigned long )((void *)0)) {
#line 298
      session_destroy(s);
#line 299
      return ((struct session___0 *)((void *)0));
    }
#line 301
    s->curw = wl;
  }
#line 303
  return (s);
}
}
#line 306 "tmux_uaf_7.c"
int main(int argc , char **argv ) 
{ 
  struct session___0 *s ;
  struct window *w ;
  int key ;
  uint8_t sx ;
  uint8_t sy ;
  char *cause ;
  char env ;
  int tmp ;

  {
#line 314
  if (argc == 1) {
#line 315
    return (1);
  }
#line 317
  s = session_create("name", (char const   *)*(argv + 0), "cwd", (struct environ *)((void *)0),
                     (struct termios *)((void *)0), 0, sx, sy, & cause);
#line 318
  w = window_create((char const   *)*(argv + 1), "cwd", (char const   **)(& env),
                    sx, sy);
#line 319
  s->curw = session_attach(s, w, 0, & cause);
#line 321
  while (! ((unsigned long )s->curw == (unsigned long )((void *)0))) {
#line 324
    w = (s->curw)->window;
#line 326
    while (1) {
#line 326
      tmp = scanf((char const   * __restrict  )"%d", & key);
#line 326
      if (! (tmp != -1)) {
#line 326
        break;
      }
#line 327
      window_key(w, key);
    }
#line 329
    winlink_remove(& s->windows, s->curw);
  }
#line 331
  session_destroy(s);
#line 332
  return (0);
}
}
