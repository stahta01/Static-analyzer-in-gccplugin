/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

#line 216 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h"
typedef unsigned long size_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 192 "../stdio.h"
typedef unsigned short u_short___0;
#line 193 "../stdio.h"
typedef unsigned int u_int___0;
#line 204 "../stdio.h"
typedef unsigned char u_char___0;
#line 210 "../stdio.h"
typedef int pid_t___0;
#line 38 "../tmux.h"
typedef char bitstr_t;
#line 40 "../tmux.h"
struct event {

};
#line 41 "../tmux.h"
struct termios {

};
#line 47
struct args;
#line 47
struct args;
#line 48
struct client;
#line 48
struct client;
#line 49
struct cmd_find_state;
#line 49
struct cmd_find_state;
#line 50
struct cmdq_item;
#line 50
struct cmdq_item;
#line 51
struct cmdq_list;
#line 51
struct cmdq_list;
#line 52
struct environ;
#line 52
struct environ;
#line 53
struct format_job_tree;
#line 53
struct format_job_tree;
#line 54
struct input_ctx;
#line 54
struct input_ctx;
#line 56
struct mouse_event;
#line 56
struct mouse_event;
#line 57
struct options;
#line 57
struct options;
#line 59
struct session;
#line 59
struct session;
#line 60
struct tmuxpeer;
#line 60
struct tmuxpeer;
#line 137 "../tmux.h"
typedef unsigned long long key_code;
#line 519 "../tmux.h"
struct utf8_data {
   u_char___0 data[9] ;
   u_char___0 have ;
   u_char___0 size ;
   u_char___0 width ;
};
#line 561 "../tmux.h"
struct grid_cell {
   u_char___0 flags ;
   u_short___0 attr ;
   int fg ;
   int bg ;
   struct utf8_data data ;
};
#line 568 "../tmux.h"
struct __anonstruct_data_27 {
   u_char___0 attr ;
   u_char___0 fg ;
   u_char___0 bg ;
   u_char___0 data ;
};
#line 568 "../tmux.h"
union __anonunion____missing_field_name_26 {
   u_int___0 offset ;
   struct __anonstruct_data_27 data ;
};
#line 568 "../tmux.h"
struct grid_cell_entry {
   u_char___0 flags ;
   union __anonunion____missing_field_name_26 __annonCompField1 ;
};
#line 582 "../tmux.h"
struct grid_line {
   u_int___0 cellused ;
   u_int___0 cellsize ;
   struct grid_cell_entry *celldata ;
   u_int___0 extdsize ;
   struct grid_cell *extddata ;
   int flags ;
};
#line 594 "../tmux.h"
struct grid {
   int flags ;
   u_int___0 sx ;
   u_int___0 sy ;
   u_int___0 hscrolled ;
   u_int___0 hsize ;
   u_int___0 hlimit ;
   struct grid_line *linedata ;
};
#line 609
struct cmd_list;
#line 622
struct bufferevent;
#line 647
enum __anonenum_lineflag_31 {
    LINE_SEL_NONE = 0,
    LINE_SEL_LEFT_RIGHT = 1,
    LINE_SEL_RIGHT_LEFT = 2
} ;
#line 647 "../tmux.h"
struct screen_sel {
   int flag ;
   int hidden ;
   int rectflag ;
   enum __anonenum_lineflag_31 lineflag ;
   int modekeys ;
   u_int___0 sx ;
   u_int___0 sy ;
   u_int___0 ex ;
   u_int___0 ey ;
   struct grid_cell cell ;
};
#line 670
struct screen_titles;
#line 670
struct screen_titles;
#line 671 "../tmux.h"
struct screen {
   char *title ;
   struct screen_titles *titles ;
   struct grid *grid ;
   u_int___0 cx ;
   u_int___0 cy ;
   u_int___0 cstyle ;
   char *ccolour ;
   u_int___0 rupper ;
   u_int___0 rlower ;
   int mode ;
   bitstr_t *tabs ;
   struct screen_sel sel ;
};
#line 696
struct window_pane;
#line 720 "../tmux.h"
struct window_mode {
   char const   *name ;
   struct screen *(*init)(struct window_pane * , struct cmd_find_state * , struct args * ) ;
   void (*free)(struct window_pane * ) ;
   void (*resize)(struct window_pane * , u_int___0  , u_int___0  ) ;
   void (*key)(struct window_pane * , struct client * , struct session * , key_code  ,
               struct mouse_event * ) ;
   char const   *(*key_table)(struct window_pane * ) ;
   void (*command)(struct window_pane * , struct client * , struct session * , struct args * ,
                   struct mouse_event * ) ;
};
#line 738
struct winlink;
#line 760
struct window;
#line 760
struct layout_cell;
#line 760 "../tmux.h"
struct __anonstruct_entry_32 {
   struct window_pane *tqe_next ;
   struct window_pane **tqe_prev ;
};
#line 760 "../tmux.h"
struct __anonstruct_tree_entry_33 {
   struct window_pane *rbe_left ;
   struct window_pane *rbe_right ;
   struct window_pane *rbe_parent ;
   int rbe_color ;
};
#line 760 "../tmux.h"
struct window_pane {
   u_int___0 id ;
   u_int___0 active_point ;
   struct window *window ;
   struct layout_cell *layout_cell ;
   struct layout_cell *saved_layout_cell ;
   u_int___0 sx ;
   u_int___0 sy ;
   u_int___0 osx ;
   u_int___0 osy ;
   u_int___0 xoff ;
   u_int___0 yoff ;
   int flags ;
   int argc ;
   char **argv ;
   char *shell ;
   char const   *cwd ;
   pid_t___0 pid ;
   char tty[10] ;
   int status ;
   int fd ;
   struct bufferevent *event ;
   struct event resize_timer ;
   struct input_ctx *ictx ;
   struct grid_cell colgc ;
   int *palette ;
   int pipe_fd ;
   struct bufferevent *pipe_event ;
   size_t pipe_off ;
   struct screen *screen ;
   struct screen base ;
   struct screen status_screen ;
   size_t status_size ;
   u_int___0 saved_cx ;
   u_int___0 saved_cy ;
   struct grid *saved_grid ;
   struct grid_cell saved_cell ;
   struct window_mode  const  *mode ;
   void *modedata ;
   struct event modetimer ;
   time_t modelast ;
   u_int___0 modeprefix ;
   char *searchstr ;
   struct __anonstruct_entry_32 entry ;
   struct __anonstruct_tree_entry_33 tree_entry ;
};
#line 837 "../tmux.h"
struct window_panes {
   struct window_pane *tqh_first ;
   struct window_pane **tqh_last ;
};
#line 841 "../tmux.h"
struct __anonstruct_alerts_entry_34 {
   struct window *tqe_next ;
   struct window **tqe_prev ;
};
#line 841 "../tmux.h"
struct __anonstruct_winlinks_35 {
   struct winlink *tqh_first ;
   struct winlink **tqh_last ;
};
#line 841 "../tmux.h"
struct __anonstruct_entry_36 {
   struct window *rbe_left ;
   struct window *rbe_right ;
   struct window *rbe_parent ;
   int rbe_color ;
};
#line 841 "../tmux.h"
struct window {
   u_int___0 id ;
   char *name ;
   struct event name_event ;
   struct timeval name_time ;
   struct event alerts_timer ;
   struct timeval activity_time ;
   struct window_pane *active ;
   struct window_pane *last ;
   struct window_panes panes ;
   int lastlayout ;
   struct layout_cell *layout_root ;
   struct layout_cell *saved_layout_root ;
   char *old_layout ;
   u_int___0 sx ;
   u_int___0 sy ;
   int flags ;
   int alerts_queued ;
   struct __anonstruct_alerts_entry_34 alerts_entry ;
   struct options *options ;
   struct grid_cell style ;
   struct grid_cell active_style ;
   u_int___0 references ;
   struct __anonstruct_winlinks_35 winlinks ;
   struct __anonstruct_entry_36 entry ;
};
#line 891 "../tmux.h"
struct __anonstruct_entry_37 {
   struct winlink *rbe_left ;
   struct winlink *rbe_right ;
   struct winlink *rbe_parent ;
   int rbe_color ;
};
#line 891 "../tmux.h"
struct __anonstruct_wentry_38 {
   struct winlink *tqe_next ;
   struct winlink **tqe_prev ;
};
#line 891 "../tmux.h"
struct __anonstruct_sentry_39 {
   struct winlink *tqe_next ;
   struct winlink **tqe_prev ;
};
#line 891 "../tmux.h"
struct winlink {
   int idx ;
   struct session *session ;
   struct window *window ;
   size_t status_width ;
   struct grid_cell status_cell ;
   char *status_text ;
   int flags ;
   struct __anonstruct_entry_37 entry ;
   struct __anonstruct_wentry_38 wentry ;
   struct __anonstruct_sentry_39 sentry ;
};
#line 910 "../tmux.h"
struct winlinks {
   struct winlink *rbh_root ;
};
#line 911 "../tmux.h"
struct winlink_stack {
   struct winlink *tqh_first ;
   struct winlink **tqh_last ;
};
#line 914
enum layout_type {
    LAYOUT_LEFTRIGHT = 0,
    LAYOUT_TOPBOTTOM = 1,
    LAYOUT_WINDOWPANE = 2
} ;
#line 921 "../tmux.h"
struct layout_cells {
   struct layout_cell *tqh_first ;
   struct layout_cell **tqh_last ;
};
#line 924 "../tmux.h"
struct __anonstruct_entry_40 {
   struct layout_cell *tqe_next ;
   struct layout_cell **tqe_prev ;
};
#line 924 "../tmux.h"
struct layout_cell {
   enum layout_type type ;
   struct layout_cell *parent ;
   u_int___0 sx ;
   u_int___0 sy ;
   u_int___0 xoff ;
   u_int___0 yoff ;
   struct window_pane *wp ;
   struct layout_cells cells ;
   struct __anonstruct_entry_40 entry ;
};
#line 958
struct hooks;
#line 958 "../tmux.h"
struct __anonstruct_gentry_44 {
   struct session *tqe_next ;
   struct session **tqe_prev ;
};
#line 958 "../tmux.h"
struct __anonstruct_entry_45 {
   struct session *rbe_left ;
   struct session *rbe_right ;
   struct session *rbe_parent ;
   int rbe_color ;
};
#line 958 "../tmux.h"
struct session {
   u_int___0 id ;
   char *name ;
   char const   *cwd ;
   struct timeval creation_time ;
   struct timeval last_attached_time ;
   struct timeval activity_time ;
   struct timeval last_activity_time ;
   struct event lock_timer ;
   u_int___0 sx ;
   u_int___0 sy ;
   struct winlink *curw ;
   struct winlink_stack lastw ;
   struct winlinks windows ;
   int statusat ;
   struct hooks *hooks ;
   struct options *options ;
   int flags ;
   u_int___0 attached ;
   struct termios *tio ;
   struct environ *environ ;
   int references ;
   struct __anonstruct_gentry_44 gentry ;
   struct __anonstruct_entry_45 entry ;
};
#line 1020 "../tmux.h"
struct mouse_event {
   int valid ;
   key_code key ;
   int statusat ;
   u_int___0 x ;
   u_int___0 y ;
   u_int___0 b ;
   u_int___0 lx ;
   u_int___0 ly ;
   u_int___0 lb ;
   int s ;
   int w ;
   int wp ;
   u_int___0 sgr_type ;
   u_int___0 sgr_b ;
};
#line 1043 "../tmux.h"
struct tty_key {
   char ch ;
   key_code key ;
   struct tty_key *left ;
   struct tty_key *right ;
   struct tty_key *next ;
};
#line 1053
struct tty_code;
#line 1053
struct tty_code;
#line 1054 "../tmux.h"
struct __anonstruct_entry_46 {

};
#line 1054 "../tmux.h"
struct tty_term {
   char *name ;
   u_int___0 references ;
   char acs[11][2] ;
   struct tty_code *codes ;
   int flags ;
   struct __anonstruct_entry_46 entry ;
};
#line 1070
struct evbuffer;
#line 1070
enum __anonenum_term_type_47 {
    TTY_VT100 = 0,
    TTY_VT101 = 1,
    TTY_VT102 = 2,
    TTY_VT220 = 3,
    TTY_VT320 = 4,
    TTY_VT420 = 5,
    TTY_UNKNOWN = 6
} ;
#line 1070 "../tmux.h"
struct tty {
   struct client *client ;
   u_int___0 sx ;
   u_int___0 sy ;
   u_int___0 cx ;
   u_int___0 cy ;
   u_int___0 cstyle ;
   char *ccolour ;
   int mode ;
   u_int___0 rlower ;
   u_int___0 rupper ;
   u_int___0 rleft ;
   u_int___0 rright ;
   int fd ;
   struct event event_in ;
   struct evbuffer *in ;
   struct event event_out ;
   struct evbuffer *out ;
   struct event timer ;
   size_t discarded ;
   struct termios tio ;
   struct grid_cell cell ;
   int last_wp ;
   struct grid_cell last_cell ;
   int flags ;
   struct tty_term *term ;
   char *term_name ;
   int term_flags ;
   enum __anonenum_term_type_47 term_type ;
   struct mouse_event mouse ;
   int mouse_drag_flag ;
   void (*mouse_drag_update)(struct client * , struct mouse_event * ) ;
   void (*mouse_drag_release)(struct client * , struct mouse_event * ) ;
   struct event key_timer ;
   struct tty_key *key_tree ;
};
#line 1169 "../tmux.h"
struct __anonstruct_entry_48 {
   struct message_entry *tqe_next ;
   struct message_entry **tqe_prev ;
};
#line 1169 "../tmux.h"
struct message_entry {
   char *msg ;
   u_int___0 msg_num ;
   time_t msg_time ;
   struct __anonstruct_entry_48 entry ;
};
#line 1177
struct args_entry;
#line 1177
struct args_entry;
#line 1178 "../tmux.h"
struct args_tree {
   struct args_entry *rbh_root ;
};
#line 1179 "../tmux.h"
struct args {
   struct args_tree tree ;
   int argc ;
   char **argv ;
};
#line 1191 "../tmux.h"
struct cmd_find_state {
   int flags ;
   struct cmd_find_state *current ;
   struct session *s ;
   struct winlink *wl ;
   struct window *w ;
   struct window_pane *wp ;
   int idx ;
};
#line 1212
struct cmd_entry;
#line 1212 "../tmux.h"
struct __anonstruct_qentry_49 {
   struct cmd *tqe_next ;
   struct cmd **tqe_prev ;
};
#line 1212 "../tmux.h"
struct cmd {
   struct cmd_entry  const  *entry ;
   struct args *args ;
   char *file ;
   u_int___0 line ;
   int flags ;
   struct __anonstruct_qentry_49 qentry ;
};
#line 1225 "../tmux.h"
struct __anonstruct_list_50 {
   struct cmd *tqh_first ;
   struct cmd **tqh_last ;
};
#line 1225 "../tmux.h"
struct cmd_list {
   int references ;
   struct __anonstruct_list_50 list ;
};
#line 1231
enum cmd_retval {
    CMD_RETURN_ERROR = -1,
    CMD_RETURN_NORMAL = 0,
    CMD_RETURN_WAIT = 1,
    CMD_RETURN_STOP = 2
} ;
#line 1260
struct cmdq_item;
#line 1261 "../tmux.h"
struct cmdq_list {
   struct cmdq_item *tqh_first ;
   struct cmdq_item **tqh_last ;
};
#line 1271
struct cmd_entry;
#line 1276
struct key_table;
#line 1276 "../tmux.h"
struct __anonstruct_message_log_51 {
   struct message_entry *tqh_first ;
   struct message_entry **tqh_last ;
};
#line 1276
enum __anonenum_prompt_mode_52 {
    PROMPT_ENTRY = 0,
    PROMPT_COMMAND = 1
} ;
#line 1276 "../tmux.h"
struct __anonstruct_entry_53 {
   struct client *tqe_next ;
   struct client **tqe_prev ;
};
#line 1276 "../tmux.h"
struct client {
   char const   *name ;
   struct tmuxpeer *peer ;
   struct cmdq_list queue ;
   pid_t___0 pid ;
   int fd ;
   struct event event ;
   int retval ;
   struct timeval creation_time ;
   struct timeval activity_time ;
   struct environ *environ ;
   struct format_job_tree *jobs ;
   char *title ;
   char const   *cwd ;
   char *term ;
   char *ttyname ;
   struct tty tty ;
   size_t written ;
   size_t discarded ;
   size_t redraw ;
   void (*stdin_callback)(struct client * , int  , void * ) ;
   void *stdin_callback_data ;
   struct evbuffer *stdin_data ;
   int stdin_closed ;
   struct evbuffer *stdout_data ;
   struct evbuffer *stderr_data ;
   struct event repeat_timer ;
   struct event click_timer ;
   u_int___0 click_button ;
   struct event status_timer ;
   struct screen status ;
   struct screen *old_status ;
   int flags ;
   struct key_table *keytable ;
   struct event identify_timer ;
   void (*identify_callback)(struct client * , struct window_pane * ) ;
   void *identify_callback_data ;
   char *message_string ;
   struct event message_timer ;
   u_int___0 message_next ;
   struct __anonstruct_message_log_51 message_log ;
   char *prompt_string ;
   struct utf8_data *prompt_buffer ;
   size_t prompt_index ;
   int (*prompt_inputcb)(struct client * , void * , char const   * , int  ) ;
   void (*prompt_freecb)(void * ) ;
   void *prompt_data ;
   u_int___0 prompt_hindex ;
   enum __anonenum_prompt_mode_52 prompt_mode ;
   int prompt_flags ;
   struct session *session ;
   struct session *last_session ;
   int wlmouse ;
   int references ;
   struct __anonstruct_entry_53 entry ;
};
#line 1384 "../tmux.h"
struct __anonstruct_entry_54 {
   struct key_binding *rbe_left ;
   struct key_binding *rbe_right ;
   struct key_binding *rbe_parent ;
   int rbe_color ;
};
#line 1384 "../tmux.h"
struct key_binding {
   key_code key ;
   struct cmd_list *cmdlist ;
   int flags ;
   struct __anonstruct_entry_54 entry ;
};
#line 1393 "../tmux.h"
struct key_bindings {
   struct key_binding *rbh_root ;
};
#line 1395 "../tmux.h"
struct __anonstruct_entry_55 {
   struct key_table *rbe_left ;
   struct key_table *rbe_right ;
   struct key_table *rbe_parent ;
   int rbe_color ;
};
#line 1395 "../tmux.h"
struct key_table {
   char const   *name ;
   struct key_bindings key_bindings ;
   u_int___0 references ;
   struct __anonstruct_entry_55 entry ;
};
#line 1489
struct paste_buffer;
#line 1489
struct paste_buffer;
#line 20 "tmux_leak_6.c"
struct __anonstruct_qentry_56 {
   struct cmd_q_item *tqe_next ;
   struct cmd_q_item **tqe_prev ;
};
#line 20 "tmux_leak_6.c"
struct cmd_q_item {
   struct cmd_list *cmdlist ;
   struct mouse_event mouse ;
   struct __anonstruct_qentry_56 qentry ;
};
#line 27 "tmux_leak_6.c"
struct cmd_q_items {
   struct cmd_q_item *tqh_first ;
   struct cmd_q_item **tqh_last ;
};
#line 31 "tmux_leak_6.c"
struct __anonstruct_waitentry_57 {
   struct cmd_q *tqe_next ;
   struct cmd_q **tqe_prev ;
};
#line 31 "tmux_leak_6.c"
struct cmd_q {
   int references ;
   int flags ;
   struct client *client ;
   int client_exit ;
   struct cmd_q_items queue ;
   struct cmd_q_item *item ;
   struct cmd *cmd ;
   time_t time ;
   u_int___0 number ;
   void (*emptyfn)(struct cmd_q * ) ;
   void *data ;
   struct __anonstruct_waitentry_57 waitentry ;
};
#line 54 "tmux_leak_6.c"
struct cmd_entry {
   char const   *name ;
   char const   *alias ;
   char const   *args_template ;
   int args_lower ;
   int args_upper ;
   char const   *usage ;
   int flags ;
   enum cmd_retval (*exec)(struct cmd * , struct cmd_q * ) ;
};
#line 91 "tmux_leak_6.c"
struct __anonstruct_name_entry_58 {
   struct paste_buffer *rbe_left ;
   struct paste_buffer *rbe_right ;
   struct paste_buffer *rbe_parent ;
   int rbe_color ;
};
#line 91 "tmux_leak_6.c"
struct paste_buffer {
   char *data ;
   size_t size ;
   char *name ;
   int automatic ;
   u_int___0 order ;
   struct __anonstruct_name_entry_58 name_entry ;
};
#line 105 "tmux_leak_6.c"
struct paste_name_tree {
   struct paste_buffer *rbh_root ;
};
#line 112 "tmux_leak_6.c"
struct __anonstruct_entry_59 {
   struct args_entry *rbe_left ;
   struct args_entry *rbe_right ;
   struct args_entry *rbe_parent ;
   int rbe_color ;
};
#line 112 "tmux_leak_6.c"
struct args_entry {
   u_char___0 flag ;
   char *value ;
   struct __anonstruct_entry_59 entry ;
};
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 1496 "../tmux.h"
struct paste_buffer *paste_get_name(char const   *name ) ;
#line 1497
void paste_free(struct paste_buffer *pb ) ;
#line 1498
void paste_add(char *data , size_t size ) ;
#line 1500
int paste_set(char *data , size_t size , char const   *name , char **cause ) ;
#line 1714
int args_has(struct args *args , u_char___0 ch ) ;
#line 102 "tmux_leak_6.c"
u_int___0 paste_next_index  ;
#line 103 "tmux_leak_6.c"
u_int___0 paste_next_order  ;
#line 104 "tmux_leak_6.c"
u_int___0 paste_num_automatic  ;
#line 105 "tmux_leak_6.c"
struct paste_name_tree paste_by_name  ;
#line 107
int paste_cmp_names(struct paste_buffer  const  *a , struct paste_buffer  const  *b ) ;
#line 108
void paste_name_tree_RB_INSERT_COLOR(struct paste_name_tree *head , struct paste_buffer *elm ) ;
#line 108
void paste_name_tree_RB_REMOVE_COLOR(struct paste_name_tree *head , struct paste_buffer *parent ,
                                     struct paste_buffer *elm ) ;
#line 108
struct paste_buffer *paste_name_tree_RB_INSERT(struct paste_name_tree *head , struct paste_buffer *elm ) ;
#line 108
struct paste_buffer *paste_name_tree_RB_REMOVE(struct paste_name_tree *head , struct paste_buffer *elm ) ;
#line 108
struct paste_buffer *paste_name_tree_RB_FIND(struct paste_name_tree *head , struct paste_buffer *elm ) ;
#line 108
struct paste_buffer *paste_name_tree_RB_NFIND(struct paste_name_tree *head , struct paste_buffer *elm ) ;
#line 108
struct paste_buffer *paste_name_tree_RB_NEXT(struct paste_buffer *elm ) ;
#line 108
struct paste_buffer *paste_name_tree_RB_PREV(struct paste_buffer *elm ) ;
#line 108
struct paste_buffer *paste_name_tree_RB_MINMAX(struct paste_name_tree *head , int val ) ;
#line 109 "tmux_leak_6.c"
void paste_name_tree_RB_INSERT_COLOR(struct paste_name_tree *head , struct paste_buffer *elm ) 
{ 
  struct paste_buffer *parent ;
  struct paste_buffer *gparent ;
  struct paste_buffer *tmp ;
  struct paste_buffer *tmp___0 ;
  struct paste_buffer *tmp___1 ;
  struct paste_buffer *tmp___2 ;
  struct paste_buffer *tmp___3 ;
  struct paste_buffer *tmp___4 ;
  struct paste_buffer *tmp___5 ;
  struct paste_buffer *tmp___6 ;
  struct paste_buffer *tmp___7 ;

  {
#line 109
  while (1) {
#line 109
    parent = elm->name_entry.rbe_parent;
#line 109
    if ((unsigned long )parent != (unsigned long )((void *)0)) {
#line 109
      if (! (parent->name_entry.rbe_color == 1)) {
#line 109
        break;
      }
    } else {
#line 109
      break;
    }
#line 109
    gparent = parent->name_entry.rbe_parent;
#line 109
    if ((unsigned long )parent == (unsigned long )gparent->name_entry.rbe_left) {
#line 109
      tmp = gparent->name_entry.rbe_right;
#line 109
      if (tmp) {
#line 109
        if (tmp->name_entry.rbe_color == 1) {
#line 109
          tmp->name_entry.rbe_color = 0;
#line 109
          while (1) {
#line 109
            parent->name_entry.rbe_color = 0;
#line 109
            gparent->name_entry.rbe_color = 1;
#line 109
            break;
          }
#line 109
          elm = gparent;
#line 109
          continue;
        }
      }
#line 109
      if ((unsigned long )parent->name_entry.rbe_right == (unsigned long )elm) {
#line 109
        while (1) {
#line 109
          tmp = parent->name_entry.rbe_right;
#line 109
          tmp___0 = tmp->name_entry.rbe_left;
#line 109
          parent->name_entry.rbe_right = tmp___0;
#line 109
          if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 109
            (tmp->name_entry.rbe_left)->name_entry.rbe_parent = parent;
          }
#line 109
          while (1) {
#line 109
            break;
          }
#line 109
          tmp___1 = parent->name_entry.rbe_parent;
#line 109
          tmp->name_entry.rbe_parent = tmp___1;
#line 109
          if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
#line 109
            if ((unsigned long )parent == (unsigned long )(parent->name_entry.rbe_parent)->name_entry.rbe_left) {
#line 109
              (parent->name_entry.rbe_parent)->name_entry.rbe_left = tmp;
            } else {
#line 109
              (parent->name_entry.rbe_parent)->name_entry.rbe_right = tmp;
            }
          } else {
#line 109
            head->rbh_root = tmp;
          }
#line 109
          tmp->name_entry.rbe_left = parent;
#line 109
          parent->name_entry.rbe_parent = tmp;
#line 109
          while (1) {
#line 109
            break;
          }
#line 109
          if (tmp->name_entry.rbe_parent) {
#line 109
            while (1) {
#line 109
              break;
            }
          }
#line 109
          break;
        }
#line 109
        tmp = parent;
#line 109
        parent = elm;
#line 109
        elm = tmp;
      }
#line 109
      while (1) {
#line 109
        parent->name_entry.rbe_color = 0;
#line 109
        gparent->name_entry.rbe_color = 1;
#line 109
        break;
      }
#line 109
      while (1) {
#line 109
        tmp = gparent->name_entry.rbe_left;
#line 109
        tmp___2 = tmp->name_entry.rbe_right;
#line 109
        gparent->name_entry.rbe_left = tmp___2;
#line 109
        if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
#line 109
          (tmp->name_entry.rbe_right)->name_entry.rbe_parent = gparent;
        }
#line 109
        while (1) {
#line 109
          break;
        }
#line 109
        tmp___3 = gparent->name_entry.rbe_parent;
#line 109
        tmp->name_entry.rbe_parent = tmp___3;
#line 109
        if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
#line 109
          if ((unsigned long )gparent == (unsigned long )(gparent->name_entry.rbe_parent)->name_entry.rbe_left) {
#line 109
            (gparent->name_entry.rbe_parent)->name_entry.rbe_left = tmp;
          } else {
#line 109
            (gparent->name_entry.rbe_parent)->name_entry.rbe_right = tmp;
          }
        } else {
#line 109
          head->rbh_root = tmp;
        }
#line 109
        tmp->name_entry.rbe_right = gparent;
#line 109
        gparent->name_entry.rbe_parent = tmp;
#line 109
        while (1) {
#line 109
          break;
        }
#line 109
        if (tmp->name_entry.rbe_parent) {
#line 109
          while (1) {
#line 109
            break;
          }
        }
#line 109
        break;
      }
    } else {
#line 109
      tmp = gparent->name_entry.rbe_left;
#line 109
      if (tmp) {
#line 109
        if (tmp->name_entry.rbe_color == 1) {
#line 109
          tmp->name_entry.rbe_color = 0;
#line 109
          while (1) {
#line 109
            parent->name_entry.rbe_color = 0;
#line 109
            gparent->name_entry.rbe_color = 1;
#line 109
            break;
          }
#line 109
          elm = gparent;
#line 109
          continue;
        }
      }
#line 109
      if ((unsigned long )parent->name_entry.rbe_left == (unsigned long )elm) {
#line 109
        while (1) {
#line 109
          tmp = parent->name_entry.rbe_left;
#line 109
          tmp___4 = tmp->name_entry.rbe_right;
#line 109
          parent->name_entry.rbe_left = tmp___4;
#line 109
          if ((unsigned long )tmp___4 != (unsigned long )((void *)0)) {
#line 109
            (tmp->name_entry.rbe_right)->name_entry.rbe_parent = parent;
          }
#line 109
          while (1) {
#line 109
            break;
          }
#line 109
          tmp___5 = parent->name_entry.rbe_parent;
#line 109
          tmp->name_entry.rbe_parent = tmp___5;
#line 109
          if ((unsigned long )tmp___5 != (unsigned long )((void *)0)) {
#line 109
            if ((unsigned long )parent == (unsigned long )(parent->name_entry.rbe_parent)->name_entry.rbe_left) {
#line 109
              (parent->name_entry.rbe_parent)->name_entry.rbe_left = tmp;
            } else {
#line 109
              (parent->name_entry.rbe_parent)->name_entry.rbe_right = tmp;
            }
          } else {
#line 109
            head->rbh_root = tmp;
          }
#line 109
          tmp->name_entry.rbe_right = parent;
#line 109
          parent->name_entry.rbe_parent = tmp;
#line 109
          while (1) {
#line 109
            break;
          }
#line 109
          if (tmp->name_entry.rbe_parent) {
#line 109
            while (1) {
#line 109
              break;
            }
          }
#line 109
          break;
        }
#line 109
        tmp = parent;
#line 109
        parent = elm;
#line 109
        elm = tmp;
      }
#line 109
      while (1) {
#line 109
        parent->name_entry.rbe_color = 0;
#line 109
        gparent->name_entry.rbe_color = 1;
#line 109
        break;
      }
#line 109
      while (1) {
#line 109
        tmp = gparent->name_entry.rbe_right;
#line 109
        tmp___6 = tmp->name_entry.rbe_left;
#line 109
        gparent->name_entry.rbe_right = tmp___6;
#line 109
        if ((unsigned long )tmp___6 != (unsigned long )((void *)0)) {
#line 109
          (tmp->name_entry.rbe_left)->name_entry.rbe_parent = gparent;
        }
#line 109
        while (1) {
#line 109
          break;
        }
#line 109
        tmp___7 = gparent->name_entry.rbe_parent;
#line 109
        tmp->name_entry.rbe_parent = tmp___7;
#line 109
        if ((unsigned long )tmp___7 != (unsigned long )((void *)0)) {
#line 109
          if ((unsigned long )gparent == (unsigned long )(gparent->name_entry.rbe_parent)->name_entry.rbe_left) {
#line 109
            (gparent->name_entry.rbe_parent)->name_entry.rbe_left = tmp;
          } else {
#line 109
            (gparent->name_entry.rbe_parent)->name_entry.rbe_right = tmp;
          }
        } else {
#line 109
          head->rbh_root = tmp;
        }
#line 109
        tmp->name_entry.rbe_left = gparent;
#line 109
        gparent->name_entry.rbe_parent = tmp;
#line 109
        while (1) {
#line 109
          break;
        }
#line 109
        if (tmp->name_entry.rbe_parent) {
#line 109
          while (1) {
#line 109
            break;
          }
        }
#line 109
        break;
      }
    }
  }
#line 109
  (head->rbh_root)->name_entry.rbe_color = 0;
#line 109
  return;
}
}
#line 109 "tmux_leak_6.c"
void paste_name_tree_RB_REMOVE_COLOR(struct paste_name_tree *head , struct paste_buffer *parent ,
                                     struct paste_buffer *elm ) 
{ 
  struct paste_buffer *tmp ;
  struct paste_buffer *tmp___0 ;
  struct paste_buffer *tmp___1 ;
  struct paste_buffer *oleft ;
  struct paste_buffer *tmp___2 ;
  struct paste_buffer *tmp___3 ;
  struct paste_buffer *tmp___4 ;
  struct paste_buffer *tmp___5 ;
  struct paste_buffer *tmp___6 ;
  struct paste_buffer *tmp___7 ;
  struct paste_buffer *oright ;
  struct paste_buffer *tmp___8 ;
  struct paste_buffer *tmp___9 ;
  struct paste_buffer *tmp___10 ;
  struct paste_buffer *tmp___11 ;

  {
#line 109
  while (1) {
#line 109
    if ((unsigned long )elm == (unsigned long )((void *)0)) {
#line 109
      goto _L___5;
    } else
#line 109
    if (elm->name_entry.rbe_color == 0) {
      _L___5: /* CIL Label */ 
#line 109
      if (! ((unsigned long )elm != (unsigned long )head->rbh_root)) {
#line 109
        break;
      }
    } else {
#line 109
      break;
    }
#line 109
    if ((unsigned long )parent->name_entry.rbe_left == (unsigned long )elm) {
#line 109
      tmp = parent->name_entry.rbe_right;
#line 109
      if (tmp->name_entry.rbe_color == 1) {
#line 109
        while (1) {
#line 109
          tmp->name_entry.rbe_color = 0;
#line 109
          parent->name_entry.rbe_color = 1;
#line 109
          break;
        }
#line 109
        while (1) {
#line 109
          tmp = parent->name_entry.rbe_right;
#line 109
          tmp___0 = tmp->name_entry.rbe_left;
#line 109
          parent->name_entry.rbe_right = tmp___0;
#line 109
          if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 109
            (tmp->name_entry.rbe_left)->name_entry.rbe_parent = parent;
          }
#line 109
          while (1) {
#line 109
            break;
          }
#line 109
          tmp___1 = parent->name_entry.rbe_parent;
#line 109
          tmp->name_entry.rbe_parent = tmp___1;
#line 109
          if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
#line 109
            if ((unsigned long )parent == (unsigned long )(parent->name_entry.rbe_parent)->name_entry.rbe_left) {
#line 109
              (parent->name_entry.rbe_parent)->name_entry.rbe_left = tmp;
            } else {
#line 109
              (parent->name_entry.rbe_parent)->name_entry.rbe_right = tmp;
            }
          } else {
#line 109
            head->rbh_root = tmp;
          }
#line 109
          tmp->name_entry.rbe_left = parent;
#line 109
          parent->name_entry.rbe_parent = tmp;
#line 109
          while (1) {
#line 109
            break;
          }
#line 109
          if (tmp->name_entry.rbe_parent) {
#line 109
            while (1) {
#line 109
              break;
            }
          }
#line 109
          break;
        }
#line 109
        tmp = parent->name_entry.rbe_right;
      }
#line 109
      if ((unsigned long )tmp->name_entry.rbe_left == (unsigned long )((void *)0)) {
#line 109
        goto _L___1;
      } else
#line 109
      if ((tmp->name_entry.rbe_left)->name_entry.rbe_color == 0) {
        _L___1: /* CIL Label */ 
#line 109
        if ((unsigned long )tmp->name_entry.rbe_right == (unsigned long )((void *)0)) {
#line 109
          tmp->name_entry.rbe_color = 1;
#line 109
          elm = parent;
#line 109
          parent = elm->name_entry.rbe_parent;
        } else
#line 109
        if ((tmp->name_entry.rbe_right)->name_entry.rbe_color == 0) {
#line 109
          tmp->name_entry.rbe_color = 1;
#line 109
          elm = parent;
#line 109
          parent = elm->name_entry.rbe_parent;
        } else {
#line 109
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 109
        if ((unsigned long )tmp->name_entry.rbe_right == (unsigned long )((void *)0)) {
#line 109
          goto _L;
        } else
#line 109
        if ((tmp->name_entry.rbe_right)->name_entry.rbe_color == 0) {
          _L: /* CIL Label */ 
#line 109
          oleft = tmp->name_entry.rbe_left;
#line 109
          if ((unsigned long )oleft != (unsigned long )((void *)0)) {
#line 109
            oleft->name_entry.rbe_color = 0;
          }
#line 109
          tmp->name_entry.rbe_color = 1;
#line 109
          while (1) {
#line 109
            oleft = tmp->name_entry.rbe_left;
#line 109
            tmp___2 = oleft->name_entry.rbe_right;
#line 109
            tmp->name_entry.rbe_left = tmp___2;
#line 109
            if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
#line 109
              (oleft->name_entry.rbe_right)->name_entry.rbe_parent = tmp;
            }
#line 109
            while (1) {
#line 109
              break;
            }
#line 109
            tmp___3 = tmp->name_entry.rbe_parent;
#line 109
            oleft->name_entry.rbe_parent = tmp___3;
#line 109
            if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
#line 109
              if ((unsigned long )tmp == (unsigned long )(tmp->name_entry.rbe_parent)->name_entry.rbe_left) {
#line 109
                (tmp->name_entry.rbe_parent)->name_entry.rbe_left = oleft;
              } else {
#line 109
                (tmp->name_entry.rbe_parent)->name_entry.rbe_right = oleft;
              }
            } else {
#line 109
              head->rbh_root = oleft;
            }
#line 109
            oleft->name_entry.rbe_right = tmp;
#line 109
            tmp->name_entry.rbe_parent = oleft;
#line 109
            while (1) {
#line 109
              break;
            }
#line 109
            if (oleft->name_entry.rbe_parent) {
#line 109
              while (1) {
#line 109
                break;
              }
            }
#line 109
            break;
          }
#line 109
          tmp = parent->name_entry.rbe_right;
        }
#line 109
        tmp->name_entry.rbe_color = parent->name_entry.rbe_color;
#line 109
        parent->name_entry.rbe_color = 0;
#line 109
        if (tmp->name_entry.rbe_right) {
#line 109
          (tmp->name_entry.rbe_right)->name_entry.rbe_color = 0;
        }
#line 109
        while (1) {
#line 109
          tmp = parent->name_entry.rbe_right;
#line 109
          tmp___4 = tmp->name_entry.rbe_left;
#line 109
          parent->name_entry.rbe_right = tmp___4;
#line 109
          if ((unsigned long )tmp___4 != (unsigned long )((void *)0)) {
#line 109
            (tmp->name_entry.rbe_left)->name_entry.rbe_parent = parent;
          }
#line 109
          while (1) {
#line 109
            break;
          }
#line 109
          tmp___5 = parent->name_entry.rbe_parent;
#line 109
          tmp->name_entry.rbe_parent = tmp___5;
#line 109
          if ((unsigned long )tmp___5 != (unsigned long )((void *)0)) {
#line 109
            if ((unsigned long )parent == (unsigned long )(parent->name_entry.rbe_parent)->name_entry.rbe_left) {
#line 109
              (parent->name_entry.rbe_parent)->name_entry.rbe_left = tmp;
            } else {
#line 109
              (parent->name_entry.rbe_parent)->name_entry.rbe_right = tmp;
            }
          } else {
#line 109
            head->rbh_root = tmp;
          }
#line 109
          tmp->name_entry.rbe_left = parent;
#line 109
          parent->name_entry.rbe_parent = tmp;
#line 109
          while (1) {
#line 109
            break;
          }
#line 109
          if (tmp->name_entry.rbe_parent) {
#line 109
            while (1) {
#line 109
              break;
            }
          }
#line 109
          break;
        }
#line 109
        elm = head->rbh_root;
#line 109
        break;
      }
    } else {
#line 109
      tmp = parent->name_entry.rbe_left;
#line 109
      if (tmp->name_entry.rbe_color == 1) {
#line 109
        while (1) {
#line 109
          tmp->name_entry.rbe_color = 0;
#line 109
          parent->name_entry.rbe_color = 1;
#line 109
          break;
        }
#line 109
        while (1) {
#line 109
          tmp = parent->name_entry.rbe_left;
#line 109
          tmp___6 = tmp->name_entry.rbe_right;
#line 109
          parent->name_entry.rbe_left = tmp___6;
#line 109
          if ((unsigned long )tmp___6 != (unsigned long )((void *)0)) {
#line 109
            (tmp->name_entry.rbe_right)->name_entry.rbe_parent = parent;
          }
#line 109
          while (1) {
#line 109
            break;
          }
#line 109
          tmp___7 = parent->name_entry.rbe_parent;
#line 109
          tmp->name_entry.rbe_parent = tmp___7;
#line 109
          if ((unsigned long )tmp___7 != (unsigned long )((void *)0)) {
#line 109
            if ((unsigned long )parent == (unsigned long )(parent->name_entry.rbe_parent)->name_entry.rbe_left) {
#line 109
              (parent->name_entry.rbe_parent)->name_entry.rbe_left = tmp;
            } else {
#line 109
              (parent->name_entry.rbe_parent)->name_entry.rbe_right = tmp;
            }
          } else {
#line 109
            head->rbh_root = tmp;
          }
#line 109
          tmp->name_entry.rbe_right = parent;
#line 109
          parent->name_entry.rbe_parent = tmp;
#line 109
          while (1) {
#line 109
            break;
          }
#line 109
          if (tmp->name_entry.rbe_parent) {
#line 109
            while (1) {
#line 109
              break;
            }
          }
#line 109
          break;
        }
#line 109
        tmp = parent->name_entry.rbe_left;
      }
#line 109
      if ((unsigned long )tmp->name_entry.rbe_left == (unsigned long )((void *)0)) {
#line 109
        goto _L___4;
      } else
#line 109
      if ((tmp->name_entry.rbe_left)->name_entry.rbe_color == 0) {
        _L___4: /* CIL Label */ 
#line 109
        if ((unsigned long )tmp->name_entry.rbe_right == (unsigned long )((void *)0)) {
#line 109
          tmp->name_entry.rbe_color = 1;
#line 109
          elm = parent;
#line 109
          parent = elm->name_entry.rbe_parent;
        } else
#line 109
        if ((tmp->name_entry.rbe_right)->name_entry.rbe_color == 0) {
#line 109
          tmp->name_entry.rbe_color = 1;
#line 109
          elm = parent;
#line 109
          parent = elm->name_entry.rbe_parent;
        } else {
#line 109
          goto _L___3;
        }
      } else {
        _L___3: /* CIL Label */ 
#line 109
        if ((unsigned long )tmp->name_entry.rbe_left == (unsigned long )((void *)0)) {
#line 109
          goto _L___2;
        } else
#line 109
        if ((tmp->name_entry.rbe_left)->name_entry.rbe_color == 0) {
          _L___2: /* CIL Label */ 
#line 109
          oright = tmp->name_entry.rbe_right;
#line 109
          if ((unsigned long )oright != (unsigned long )((void *)0)) {
#line 109
            oright->name_entry.rbe_color = 0;
          }
#line 109
          tmp->name_entry.rbe_color = 1;
#line 109
          while (1) {
#line 109
            oright = tmp->name_entry.rbe_right;
#line 109
            tmp___8 = oright->name_entry.rbe_left;
#line 109
            tmp->name_entry.rbe_right = tmp___8;
#line 109
            if ((unsigned long )tmp___8 != (unsigned long )((void *)0)) {
#line 109
              (oright->name_entry.rbe_left)->name_entry.rbe_parent = tmp;
            }
#line 109
            while (1) {
#line 109
              break;
            }
#line 109
            tmp___9 = tmp->name_entry.rbe_parent;
#line 109
            oright->name_entry.rbe_parent = tmp___9;
#line 109
            if ((unsigned long )tmp___9 != (unsigned long )((void *)0)) {
#line 109
              if ((unsigned long )tmp == (unsigned long )(tmp->name_entry.rbe_parent)->name_entry.rbe_left) {
#line 109
                (tmp->name_entry.rbe_parent)->name_entry.rbe_left = oright;
              } else {
#line 109
                (tmp->name_entry.rbe_parent)->name_entry.rbe_right = oright;
              }
            } else {
#line 109
              head->rbh_root = oright;
            }
#line 109
            oright->name_entry.rbe_left = tmp;
#line 109
            tmp->name_entry.rbe_parent = oright;
#line 109
            while (1) {
#line 109
              break;
            }
#line 109
            if (oright->name_entry.rbe_parent) {
#line 109
              while (1) {
#line 109
                break;
              }
            }
#line 109
            break;
          }
#line 109
          tmp = parent->name_entry.rbe_left;
        }
#line 109
        tmp->name_entry.rbe_color = parent->name_entry.rbe_color;
#line 109
        parent->name_entry.rbe_color = 0;
#line 109
        if (tmp->name_entry.rbe_left) {
#line 109
          (tmp->name_entry.rbe_left)->name_entry.rbe_color = 0;
        }
#line 109
        while (1) {
#line 109
          tmp = parent->name_entry.rbe_left;
#line 109
          tmp___10 = tmp->name_entry.rbe_right;
#line 109
          parent->name_entry.rbe_left = tmp___10;
#line 109
          if ((unsigned long )tmp___10 != (unsigned long )((void *)0)) {
#line 109
            (tmp->name_entry.rbe_right)->name_entry.rbe_parent = parent;
          }
#line 109
          while (1) {
#line 109
            break;
          }
#line 109
          tmp___11 = parent->name_entry.rbe_parent;
#line 109
          tmp->name_entry.rbe_parent = tmp___11;
#line 109
          if ((unsigned long )tmp___11 != (unsigned long )((void *)0)) {
#line 109
            if ((unsigned long )parent == (unsigned long )(parent->name_entry.rbe_parent)->name_entry.rbe_left) {
#line 109
              (parent->name_entry.rbe_parent)->name_entry.rbe_left = tmp;
            } else {
#line 109
              (parent->name_entry.rbe_parent)->name_entry.rbe_right = tmp;
            }
          } else {
#line 109
            head->rbh_root = tmp;
          }
#line 109
          tmp->name_entry.rbe_right = parent;
#line 109
          parent->name_entry.rbe_parent = tmp;
#line 109
          while (1) {
#line 109
            break;
          }
#line 109
          if (tmp->name_entry.rbe_parent) {
#line 109
            while (1) {
#line 109
              break;
            }
          }
#line 109
          break;
        }
#line 109
        elm = head->rbh_root;
#line 109
        break;
      }
    }
  }
#line 109
  if (elm) {
#line 109
    elm->name_entry.rbe_color = 0;
  }
#line 109
  return;
}
}
#line 109 "tmux_leak_6.c"
struct paste_buffer *paste_name_tree_RB_INSERT(struct paste_name_tree *head , struct paste_buffer *elm ) 
{ 
  struct paste_buffer *tmp ;
  struct paste_buffer *parent ;
  int comp ;
  struct paste_buffer *tmp___0 ;

  {
#line 109
  parent = (struct paste_buffer *)((void *)0);
#line 109
  comp = 0;
#line 109
  tmp = head->rbh_root;
#line 109
  while (tmp) {
#line 109
    parent = tmp;
#line 109
    comp = paste_cmp_names((struct paste_buffer  const  *)elm, (struct paste_buffer  const  *)parent);
#line 109
    if (comp < 0) {
#line 109
      tmp = tmp->name_entry.rbe_left;
    } else
#line 109
    if (comp > 0) {
#line 109
      tmp = tmp->name_entry.rbe_right;
    } else {
#line 109
      return (tmp);
    }
  }
#line 109
  while (1) {
#line 109
    elm->name_entry.rbe_parent = parent;
#line 109
    tmp___0 = (struct paste_buffer *)((void *)0);
#line 109
    elm->name_entry.rbe_right = tmp___0;
#line 109
    elm->name_entry.rbe_left = tmp___0;
#line 109
    elm->name_entry.rbe_color = 1;
#line 109
    break;
  }
#line 109
  if ((unsigned long )parent != (unsigned long )((void *)0)) {
#line 109
    if (comp < 0) {
#line 109
      parent->name_entry.rbe_left = elm;
    } else {
#line 109
      parent->name_entry.rbe_right = elm;
    }
#line 109
    while (1) {
#line 109
      break;
    }
  } else {
#line 109
    head->rbh_root = elm;
  }
#line 109
  paste_name_tree_RB_INSERT_COLOR(head, elm);
#line 109
  return ((struct paste_buffer *)((void *)0));
}
}
#line 109 "tmux_leak_6.c"
struct paste_buffer *paste_name_tree_RB_REMOVE(struct paste_name_tree *head , struct paste_buffer *elm ) 
{ 
  struct paste_buffer *child ;
  struct paste_buffer *parent ;
  struct paste_buffer *old ;
  int color ;
  struct paste_buffer *left ;

  {
#line 109
  old = elm;
#line 109
  if ((unsigned long )elm->name_entry.rbe_left == (unsigned long )((void *)0)) {
#line 109
    child = elm->name_entry.rbe_right;
  } else
#line 109
  if ((unsigned long )elm->name_entry.rbe_right == (unsigned long )((void *)0)) {
#line 109
    child = elm->name_entry.rbe_left;
  } else {
#line 109
    elm = elm->name_entry.rbe_right;
#line 109
    while (1) {
#line 109
      left = elm->name_entry.rbe_left;
#line 109
      if (! ((unsigned long )left != (unsigned long )((void *)0))) {
#line 109
        break;
      }
#line 109
      elm = left;
    }
#line 109
    child = elm->name_entry.rbe_right;
#line 109
    parent = elm->name_entry.rbe_parent;
#line 109
    color = elm->name_entry.rbe_color;
#line 109
    if (child) {
#line 109
      child->name_entry.rbe_parent = parent;
    }
#line 109
    if (parent) {
#line 109
      if ((unsigned long )parent->name_entry.rbe_left == (unsigned long )elm) {
#line 109
        parent->name_entry.rbe_left = child;
      } else {
#line 109
        parent->name_entry.rbe_right = child;
      }
#line 109
      while (1) {
#line 109
        break;
      }
    } else {
#line 109
      head->rbh_root = child;
    }
#line 109
    if ((unsigned long )elm->name_entry.rbe_parent == (unsigned long )old) {
#line 109
      parent = elm;
    }
#line 109
    elm->name_entry = old->name_entry;
#line 109
    if (old->name_entry.rbe_parent) {
#line 109
      if ((unsigned long )(old->name_entry.rbe_parent)->name_entry.rbe_left == (unsigned long )old) {
#line 109
        (old->name_entry.rbe_parent)->name_entry.rbe_left = elm;
      } else {
#line 109
        (old->name_entry.rbe_parent)->name_entry.rbe_right = elm;
      }
#line 109
      while (1) {
#line 109
        break;
      }
    } else {
#line 109
      head->rbh_root = elm;
    }
#line 109
    (old->name_entry.rbe_left)->name_entry.rbe_parent = elm;
#line 109
    if (old->name_entry.rbe_right) {
#line 109
      (old->name_entry.rbe_right)->name_entry.rbe_parent = elm;
    }
#line 109
    if (parent) {
#line 109
      left = parent;
#line 109
      while (1) {
#line 109
        while (1) {
#line 109
          break;
        }
#line 109
        left = left->name_entry.rbe_parent;
#line 109
        if (! ((unsigned long )left != (unsigned long )((void *)0))) {
#line 109
          break;
        }
      }
    }
#line 109
    goto color;
  }
#line 109
  parent = elm->name_entry.rbe_parent;
#line 109
  color = elm->name_entry.rbe_color;
#line 109
  if (child) {
#line 109
    child->name_entry.rbe_parent = parent;
  }
#line 109
  if (parent) {
#line 109
    if ((unsigned long )parent->name_entry.rbe_left == (unsigned long )elm) {
#line 109
      parent->name_entry.rbe_left = child;
    } else {
#line 109
      parent->name_entry.rbe_right = child;
    }
#line 109
    while (1) {
#line 109
      break;
    }
  } else {
#line 109
    head->rbh_root = child;
  }
  color: 
#line 109
  if (color == 0) {
#line 109
    paste_name_tree_RB_REMOVE_COLOR(head, parent, child);
  }
#line 109
  return (old);
}
}
#line 109 "tmux_leak_6.c"
struct paste_buffer *paste_name_tree_RB_FIND(struct paste_name_tree *head , struct paste_buffer *elm ) 
{ 
  struct paste_buffer *tmp ;
  int comp ;

  {
#line 109
  tmp = head->rbh_root;
#line 109
  while (tmp) {
#line 109
    comp = paste_cmp_names((struct paste_buffer  const  *)elm, (struct paste_buffer  const  *)tmp);
#line 109
    if (comp < 0) {
#line 109
      tmp = tmp->name_entry.rbe_left;
    } else
#line 109
    if (comp > 0) {
#line 109
      tmp = tmp->name_entry.rbe_right;
    } else {
#line 109
      return (tmp);
    }
  }
#line 109
  return ((struct paste_buffer *)((void *)0));
}
}
#line 109 "tmux_leak_6.c"
struct paste_buffer *paste_name_tree_RB_NFIND(struct paste_name_tree *head , struct paste_buffer *elm ) 
{ 
  struct paste_buffer *tmp ;
  struct paste_buffer *res ;
  int comp ;

  {
#line 109
  tmp = head->rbh_root;
#line 109
  res = (struct paste_buffer *)((void *)0);
#line 109
  while (tmp) {
#line 109
    comp = paste_cmp_names((struct paste_buffer  const  *)elm, (struct paste_buffer  const  *)tmp);
#line 109
    if (comp < 0) {
#line 109
      res = tmp;
#line 109
      tmp = tmp->name_entry.rbe_left;
    } else
#line 109
    if (comp > 0) {
#line 109
      tmp = tmp->name_entry.rbe_right;
    } else {
#line 109
      return (tmp);
    }
  }
#line 109
  return (res);
}
}
#line 109 "tmux_leak_6.c"
struct paste_buffer *paste_name_tree_RB_NEXT(struct paste_buffer *elm ) 
{ 


  {
#line 109
  if (elm->name_entry.rbe_right) {
#line 109
    elm = elm->name_entry.rbe_right;
#line 109
    while (elm->name_entry.rbe_left) {
#line 109
      elm = elm->name_entry.rbe_left;
    }
  } else
#line 109
  if (elm->name_entry.rbe_parent) {
#line 109
    if ((unsigned long )elm == (unsigned long )(elm->name_entry.rbe_parent)->name_entry.rbe_left) {
#line 109
      elm = elm->name_entry.rbe_parent;
    } else {
#line 109
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 109
    while (1) {
#line 109
      if (elm->name_entry.rbe_parent) {
#line 109
        if (! ((unsigned long )elm == (unsigned long )(elm->name_entry.rbe_parent)->name_entry.rbe_right)) {
#line 109
          break;
        }
      } else {
#line 109
        break;
      }
#line 109
      elm = elm->name_entry.rbe_parent;
    }
#line 109
    elm = elm->name_entry.rbe_parent;
  }
#line 109
  return (elm);
}
}
#line 109 "tmux_leak_6.c"
struct paste_buffer *paste_name_tree_RB_PREV(struct paste_buffer *elm ) 
{ 


  {
#line 109
  if (elm->name_entry.rbe_left) {
#line 109
    elm = elm->name_entry.rbe_left;
#line 109
    while (elm->name_entry.rbe_right) {
#line 109
      elm = elm->name_entry.rbe_right;
    }
  } else
#line 109
  if (elm->name_entry.rbe_parent) {
#line 109
    if ((unsigned long )elm == (unsigned long )(elm->name_entry.rbe_parent)->name_entry.rbe_right) {
#line 109
      elm = elm->name_entry.rbe_parent;
    } else {
#line 109
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 109
    while (1) {
#line 109
      if (elm->name_entry.rbe_parent) {
#line 109
        if (! ((unsigned long )elm == (unsigned long )(elm->name_entry.rbe_parent)->name_entry.rbe_left)) {
#line 109
          break;
        }
      } else {
#line 109
        break;
      }
#line 109
      elm = elm->name_entry.rbe_parent;
    }
#line 109
    elm = elm->name_entry.rbe_parent;
  }
#line 109
  return (elm);
}
}
#line 109 "tmux_leak_6.c"
struct paste_buffer *paste_name_tree_RB_MINMAX(struct paste_name_tree *head , int val ) 
{ 
  struct paste_buffer *tmp ;
  struct paste_buffer *parent ;

  {
#line 109
  tmp = head->rbh_root;
#line 109
  parent = (struct paste_buffer *)((void *)0);
#line 109
  while (tmp) {
#line 109
    parent = tmp;
#line 109
    if (val < 0) {
#line 109
      tmp = tmp->name_entry.rbe_left;
    } else {
#line 109
      tmp = tmp->name_entry.rbe_right;
    }
  }
#line 109
  return (parent);
}
}
#line 119 "tmux_leak_6.c"
int args_cmp(struct args_entry *a1 , struct args_entry *a2 ) 
{ 


  {
#line 122
  return ((int )a1->flag - (int )a2->flag);
}
}
#line 125 "tmux_leak_6.c"
void args_tree_RB_INSERT_COLOR(struct args_tree *head , struct args_entry *elm ) 
{ 
  struct args_entry *parent ;
  struct args_entry *gparent ;
  struct args_entry *tmp ;
  struct args_entry *tmp___0 ;
  struct args_entry *tmp___1 ;
  struct args_entry *tmp___2 ;
  struct args_entry *tmp___3 ;
  struct args_entry *tmp___4 ;
  struct args_entry *tmp___5 ;
  struct args_entry *tmp___6 ;
  struct args_entry *tmp___7 ;

  {
#line 125
  while (1) {
#line 125
    parent = elm->entry.rbe_parent;
#line 125
    if ((unsigned long )parent != (unsigned long )((void *)0)) {
#line 125
      if (! (parent->entry.rbe_color == 1)) {
#line 125
        break;
      }
    } else {
#line 125
      break;
    }
#line 125
    gparent = parent->entry.rbe_parent;
#line 125
    if ((unsigned long )parent == (unsigned long )gparent->entry.rbe_left) {
#line 125
      tmp = gparent->entry.rbe_right;
#line 125
      if (tmp) {
#line 125
        if (tmp->entry.rbe_color == 1) {
#line 125
          tmp->entry.rbe_color = 0;
#line 125
          while (1) {
#line 125
            parent->entry.rbe_color = 0;
#line 125
            gparent->entry.rbe_color = 1;
#line 125
            break;
          }
#line 125
          elm = gparent;
#line 125
          continue;
        }
      }
#line 125
      if ((unsigned long )parent->entry.rbe_right == (unsigned long )elm) {
#line 125
        while (1) {
#line 125
          tmp = parent->entry.rbe_right;
#line 125
          tmp___0 = tmp->entry.rbe_left;
#line 125
          parent->entry.rbe_right = tmp___0;
#line 125
          if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 125
            (tmp->entry.rbe_left)->entry.rbe_parent = parent;
          }
#line 125
          while (1) {
#line 125
            break;
          }
#line 125
          tmp___1 = parent->entry.rbe_parent;
#line 125
          tmp->entry.rbe_parent = tmp___1;
#line 125
          if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
#line 125
            if ((unsigned long )parent == (unsigned long )(parent->entry.rbe_parent)->entry.rbe_left) {
#line 125
              (parent->entry.rbe_parent)->entry.rbe_left = tmp;
            } else {
#line 125
              (parent->entry.rbe_parent)->entry.rbe_right = tmp;
            }
          } else {
#line 125
            head->rbh_root = tmp;
          }
#line 125
          tmp->entry.rbe_left = parent;
#line 125
          parent->entry.rbe_parent = tmp;
#line 125
          while (1) {
#line 125
            break;
          }
#line 125
          if (tmp->entry.rbe_parent) {
#line 125
            while (1) {
#line 125
              break;
            }
          }
#line 125
          break;
        }
#line 125
        tmp = parent;
#line 125
        parent = elm;
#line 125
        elm = tmp;
      }
#line 125
      while (1) {
#line 125
        parent->entry.rbe_color = 0;
#line 125
        gparent->entry.rbe_color = 1;
#line 125
        break;
      }
#line 125
      while (1) {
#line 125
        tmp = gparent->entry.rbe_left;
#line 125
        tmp___2 = tmp->entry.rbe_right;
#line 125
        gparent->entry.rbe_left = tmp___2;
#line 125
        if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
#line 125
          (tmp->entry.rbe_right)->entry.rbe_parent = gparent;
        }
#line 125
        while (1) {
#line 125
          break;
        }
#line 125
        tmp___3 = gparent->entry.rbe_parent;
#line 125
        tmp->entry.rbe_parent = tmp___3;
#line 125
        if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
#line 125
          if ((unsigned long )gparent == (unsigned long )(gparent->entry.rbe_parent)->entry.rbe_left) {
#line 125
            (gparent->entry.rbe_parent)->entry.rbe_left = tmp;
          } else {
#line 125
            (gparent->entry.rbe_parent)->entry.rbe_right = tmp;
          }
        } else {
#line 125
          head->rbh_root = tmp;
        }
#line 125
        tmp->entry.rbe_right = gparent;
#line 125
        gparent->entry.rbe_parent = tmp;
#line 125
        while (1) {
#line 125
          break;
        }
#line 125
        if (tmp->entry.rbe_parent) {
#line 125
          while (1) {
#line 125
            break;
          }
        }
#line 125
        break;
      }
    } else {
#line 125
      tmp = gparent->entry.rbe_left;
#line 125
      if (tmp) {
#line 125
        if (tmp->entry.rbe_color == 1) {
#line 125
          tmp->entry.rbe_color = 0;
#line 125
          while (1) {
#line 125
            parent->entry.rbe_color = 0;
#line 125
            gparent->entry.rbe_color = 1;
#line 125
            break;
          }
#line 125
          elm = gparent;
#line 125
          continue;
        }
      }
#line 125
      if ((unsigned long )parent->entry.rbe_left == (unsigned long )elm) {
#line 125
        while (1) {
#line 125
          tmp = parent->entry.rbe_left;
#line 125
          tmp___4 = tmp->entry.rbe_right;
#line 125
          parent->entry.rbe_left = tmp___4;
#line 125
          if ((unsigned long )tmp___4 != (unsigned long )((void *)0)) {
#line 125
            (tmp->entry.rbe_right)->entry.rbe_parent = parent;
          }
#line 125
          while (1) {
#line 125
            break;
          }
#line 125
          tmp___5 = parent->entry.rbe_parent;
#line 125
          tmp->entry.rbe_parent = tmp___5;
#line 125
          if ((unsigned long )tmp___5 != (unsigned long )((void *)0)) {
#line 125
            if ((unsigned long )parent == (unsigned long )(parent->entry.rbe_parent)->entry.rbe_left) {
#line 125
              (parent->entry.rbe_parent)->entry.rbe_left = tmp;
            } else {
#line 125
              (parent->entry.rbe_parent)->entry.rbe_right = tmp;
            }
          } else {
#line 125
            head->rbh_root = tmp;
          }
#line 125
          tmp->entry.rbe_right = parent;
#line 125
          parent->entry.rbe_parent = tmp;
#line 125
          while (1) {
#line 125
            break;
          }
#line 125
          if (tmp->entry.rbe_parent) {
#line 125
            while (1) {
#line 125
              break;
            }
          }
#line 125
          break;
        }
#line 125
        tmp = parent;
#line 125
        parent = elm;
#line 125
        elm = tmp;
      }
#line 125
      while (1) {
#line 125
        parent->entry.rbe_color = 0;
#line 125
        gparent->entry.rbe_color = 1;
#line 125
        break;
      }
#line 125
      while (1) {
#line 125
        tmp = gparent->entry.rbe_right;
#line 125
        tmp___6 = tmp->entry.rbe_left;
#line 125
        gparent->entry.rbe_right = tmp___6;
#line 125
        if ((unsigned long )tmp___6 != (unsigned long )((void *)0)) {
#line 125
          (tmp->entry.rbe_left)->entry.rbe_parent = gparent;
        }
#line 125
        while (1) {
#line 125
          break;
        }
#line 125
        tmp___7 = gparent->entry.rbe_parent;
#line 125
        tmp->entry.rbe_parent = tmp___7;
#line 125
        if ((unsigned long )tmp___7 != (unsigned long )((void *)0)) {
#line 125
          if ((unsigned long )gparent == (unsigned long )(gparent->entry.rbe_parent)->entry.rbe_left) {
#line 125
            (gparent->entry.rbe_parent)->entry.rbe_left = tmp;
          } else {
#line 125
            (gparent->entry.rbe_parent)->entry.rbe_right = tmp;
          }
        } else {
#line 125
          head->rbh_root = tmp;
        }
#line 125
        tmp->entry.rbe_left = gparent;
#line 125
        gparent->entry.rbe_parent = tmp;
#line 125
        while (1) {
#line 125
          break;
        }
#line 125
        if (tmp->entry.rbe_parent) {
#line 125
          while (1) {
#line 125
            break;
          }
        }
#line 125
        break;
      }
    }
  }
#line 125
  (head->rbh_root)->entry.rbe_color = 0;
#line 125
  return;
}
}
#line 125 "tmux_leak_6.c"
void args_tree_RB_REMOVE_COLOR(struct args_tree *head , struct args_entry *parent ,
                               struct args_entry *elm ) 
{ 
  struct args_entry *tmp ;
  struct args_entry *tmp___0 ;
  struct args_entry *tmp___1 ;
  struct args_entry *oleft ;
  struct args_entry *tmp___2 ;
  struct args_entry *tmp___3 ;
  struct args_entry *tmp___4 ;
  struct args_entry *tmp___5 ;
  struct args_entry *tmp___6 ;
  struct args_entry *tmp___7 ;
  struct args_entry *oright ;
  struct args_entry *tmp___8 ;
  struct args_entry *tmp___9 ;
  struct args_entry *tmp___10 ;
  struct args_entry *tmp___11 ;

  {
#line 125
  while (1) {
#line 125
    if ((unsigned long )elm == (unsigned long )((void *)0)) {
#line 125
      goto _L___5;
    } else
#line 125
    if (elm->entry.rbe_color == 0) {
      _L___5: /* CIL Label */ 
#line 125
      if (! ((unsigned long )elm != (unsigned long )head->rbh_root)) {
#line 125
        break;
      }
    } else {
#line 125
      break;
    }
#line 125
    if ((unsigned long )parent->entry.rbe_left == (unsigned long )elm) {
#line 125
      tmp = parent->entry.rbe_right;
#line 125
      if (tmp->entry.rbe_color == 1) {
#line 125
        while (1) {
#line 125
          tmp->entry.rbe_color = 0;
#line 125
          parent->entry.rbe_color = 1;
#line 125
          break;
        }
#line 125
        while (1) {
#line 125
          tmp = parent->entry.rbe_right;
#line 125
          tmp___0 = tmp->entry.rbe_left;
#line 125
          parent->entry.rbe_right = tmp___0;
#line 125
          if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 125
            (tmp->entry.rbe_left)->entry.rbe_parent = parent;
          }
#line 125
          while (1) {
#line 125
            break;
          }
#line 125
          tmp___1 = parent->entry.rbe_parent;
#line 125
          tmp->entry.rbe_parent = tmp___1;
#line 125
          if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
#line 125
            if ((unsigned long )parent == (unsigned long )(parent->entry.rbe_parent)->entry.rbe_left) {
#line 125
              (parent->entry.rbe_parent)->entry.rbe_left = tmp;
            } else {
#line 125
              (parent->entry.rbe_parent)->entry.rbe_right = tmp;
            }
          } else {
#line 125
            head->rbh_root = tmp;
          }
#line 125
          tmp->entry.rbe_left = parent;
#line 125
          parent->entry.rbe_parent = tmp;
#line 125
          while (1) {
#line 125
            break;
          }
#line 125
          if (tmp->entry.rbe_parent) {
#line 125
            while (1) {
#line 125
              break;
            }
          }
#line 125
          break;
        }
#line 125
        tmp = parent->entry.rbe_right;
      }
#line 125
      if ((unsigned long )tmp->entry.rbe_left == (unsigned long )((void *)0)) {
#line 125
        goto _L___1;
      } else
#line 125
      if ((tmp->entry.rbe_left)->entry.rbe_color == 0) {
        _L___1: /* CIL Label */ 
#line 125
        if ((unsigned long )tmp->entry.rbe_right == (unsigned long )((void *)0)) {
#line 125
          tmp->entry.rbe_color = 1;
#line 125
          elm = parent;
#line 125
          parent = elm->entry.rbe_parent;
        } else
#line 125
        if ((tmp->entry.rbe_right)->entry.rbe_color == 0) {
#line 125
          tmp->entry.rbe_color = 1;
#line 125
          elm = parent;
#line 125
          parent = elm->entry.rbe_parent;
        } else {
#line 125
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 125
        if ((unsigned long )tmp->entry.rbe_right == (unsigned long )((void *)0)) {
#line 125
          goto _L;
        } else
#line 125
        if ((tmp->entry.rbe_right)->entry.rbe_color == 0) {
          _L: /* CIL Label */ 
#line 125
          oleft = tmp->entry.rbe_left;
#line 125
          if ((unsigned long )oleft != (unsigned long )((void *)0)) {
#line 125
            oleft->entry.rbe_color = 0;
          }
#line 125
          tmp->entry.rbe_color = 1;
#line 125
          while (1) {
#line 125
            oleft = tmp->entry.rbe_left;
#line 125
            tmp___2 = oleft->entry.rbe_right;
#line 125
            tmp->entry.rbe_left = tmp___2;
#line 125
            if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
#line 125
              (oleft->entry.rbe_right)->entry.rbe_parent = tmp;
            }
#line 125
            while (1) {
#line 125
              break;
            }
#line 125
            tmp___3 = tmp->entry.rbe_parent;
#line 125
            oleft->entry.rbe_parent = tmp___3;
#line 125
            if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
#line 125
              if ((unsigned long )tmp == (unsigned long )(tmp->entry.rbe_parent)->entry.rbe_left) {
#line 125
                (tmp->entry.rbe_parent)->entry.rbe_left = oleft;
              } else {
#line 125
                (tmp->entry.rbe_parent)->entry.rbe_right = oleft;
              }
            } else {
#line 125
              head->rbh_root = oleft;
            }
#line 125
            oleft->entry.rbe_right = tmp;
#line 125
            tmp->entry.rbe_parent = oleft;
#line 125
            while (1) {
#line 125
              break;
            }
#line 125
            if (oleft->entry.rbe_parent) {
#line 125
              while (1) {
#line 125
                break;
              }
            }
#line 125
            break;
          }
#line 125
          tmp = parent->entry.rbe_right;
        }
#line 125
        tmp->entry.rbe_color = parent->entry.rbe_color;
#line 125
        parent->entry.rbe_color = 0;
#line 125
        if (tmp->entry.rbe_right) {
#line 125
          (tmp->entry.rbe_right)->entry.rbe_color = 0;
        }
#line 125
        while (1) {
#line 125
          tmp = parent->entry.rbe_right;
#line 125
          tmp___4 = tmp->entry.rbe_left;
#line 125
          parent->entry.rbe_right = tmp___4;
#line 125
          if ((unsigned long )tmp___4 != (unsigned long )((void *)0)) {
#line 125
            (tmp->entry.rbe_left)->entry.rbe_parent = parent;
          }
#line 125
          while (1) {
#line 125
            break;
          }
#line 125
          tmp___5 = parent->entry.rbe_parent;
#line 125
          tmp->entry.rbe_parent = tmp___5;
#line 125
          if ((unsigned long )tmp___5 != (unsigned long )((void *)0)) {
#line 125
            if ((unsigned long )parent == (unsigned long )(parent->entry.rbe_parent)->entry.rbe_left) {
#line 125
              (parent->entry.rbe_parent)->entry.rbe_left = tmp;
            } else {
#line 125
              (parent->entry.rbe_parent)->entry.rbe_right = tmp;
            }
          } else {
#line 125
            head->rbh_root = tmp;
          }
#line 125
          tmp->entry.rbe_left = parent;
#line 125
          parent->entry.rbe_parent = tmp;
#line 125
          while (1) {
#line 125
            break;
          }
#line 125
          if (tmp->entry.rbe_parent) {
#line 125
            while (1) {
#line 125
              break;
            }
          }
#line 125
          break;
        }
#line 125
        elm = head->rbh_root;
#line 125
        break;
      }
    } else {
#line 125
      tmp = parent->entry.rbe_left;
#line 125
      if (tmp->entry.rbe_color == 1) {
#line 125
        while (1) {
#line 125
          tmp->entry.rbe_color = 0;
#line 125
          parent->entry.rbe_color = 1;
#line 125
          break;
        }
#line 125
        while (1) {
#line 125
          tmp = parent->entry.rbe_left;
#line 125
          tmp___6 = tmp->entry.rbe_right;
#line 125
          parent->entry.rbe_left = tmp___6;
#line 125
          if ((unsigned long )tmp___6 != (unsigned long )((void *)0)) {
#line 125
            (tmp->entry.rbe_right)->entry.rbe_parent = parent;
          }
#line 125
          while (1) {
#line 125
            break;
          }
#line 125
          tmp___7 = parent->entry.rbe_parent;
#line 125
          tmp->entry.rbe_parent = tmp___7;
#line 125
          if ((unsigned long )tmp___7 != (unsigned long )((void *)0)) {
#line 125
            if ((unsigned long )parent == (unsigned long )(parent->entry.rbe_parent)->entry.rbe_left) {
#line 125
              (parent->entry.rbe_parent)->entry.rbe_left = tmp;
            } else {
#line 125
              (parent->entry.rbe_parent)->entry.rbe_right = tmp;
            }
          } else {
#line 125
            head->rbh_root = tmp;
          }
#line 125
          tmp->entry.rbe_right = parent;
#line 125
          parent->entry.rbe_parent = tmp;
#line 125
          while (1) {
#line 125
            break;
          }
#line 125
          if (tmp->entry.rbe_parent) {
#line 125
            while (1) {
#line 125
              break;
            }
          }
#line 125
          break;
        }
#line 125
        tmp = parent->entry.rbe_left;
      }
#line 125
      if ((unsigned long )tmp->entry.rbe_left == (unsigned long )((void *)0)) {
#line 125
        goto _L___4;
      } else
#line 125
      if ((tmp->entry.rbe_left)->entry.rbe_color == 0) {
        _L___4: /* CIL Label */ 
#line 125
        if ((unsigned long )tmp->entry.rbe_right == (unsigned long )((void *)0)) {
#line 125
          tmp->entry.rbe_color = 1;
#line 125
          elm = parent;
#line 125
          parent = elm->entry.rbe_parent;
        } else
#line 125
        if ((tmp->entry.rbe_right)->entry.rbe_color == 0) {
#line 125
          tmp->entry.rbe_color = 1;
#line 125
          elm = parent;
#line 125
          parent = elm->entry.rbe_parent;
        } else {
#line 125
          goto _L___3;
        }
      } else {
        _L___3: /* CIL Label */ 
#line 125
        if ((unsigned long )tmp->entry.rbe_left == (unsigned long )((void *)0)) {
#line 125
          goto _L___2;
        } else
#line 125
        if ((tmp->entry.rbe_left)->entry.rbe_color == 0) {
          _L___2: /* CIL Label */ 
#line 125
          oright = tmp->entry.rbe_right;
#line 125
          if ((unsigned long )oright != (unsigned long )((void *)0)) {
#line 125
            oright->entry.rbe_color = 0;
          }
#line 125
          tmp->entry.rbe_color = 1;
#line 125
          while (1) {
#line 125
            oright = tmp->entry.rbe_right;
#line 125
            tmp___8 = oright->entry.rbe_left;
#line 125
            tmp->entry.rbe_right = tmp___8;
#line 125
            if ((unsigned long )tmp___8 != (unsigned long )((void *)0)) {
#line 125
              (oright->entry.rbe_left)->entry.rbe_parent = tmp;
            }
#line 125
            while (1) {
#line 125
              break;
            }
#line 125
            tmp___9 = tmp->entry.rbe_parent;
#line 125
            oright->entry.rbe_parent = tmp___9;
#line 125
            if ((unsigned long )tmp___9 != (unsigned long )((void *)0)) {
#line 125
              if ((unsigned long )tmp == (unsigned long )(tmp->entry.rbe_parent)->entry.rbe_left) {
#line 125
                (tmp->entry.rbe_parent)->entry.rbe_left = oright;
              } else {
#line 125
                (tmp->entry.rbe_parent)->entry.rbe_right = oright;
              }
            } else {
#line 125
              head->rbh_root = oright;
            }
#line 125
            oright->entry.rbe_left = tmp;
#line 125
            tmp->entry.rbe_parent = oright;
#line 125
            while (1) {
#line 125
              break;
            }
#line 125
            if (oright->entry.rbe_parent) {
#line 125
              while (1) {
#line 125
                break;
              }
            }
#line 125
            break;
          }
#line 125
          tmp = parent->entry.rbe_left;
        }
#line 125
        tmp->entry.rbe_color = parent->entry.rbe_color;
#line 125
        parent->entry.rbe_color = 0;
#line 125
        if (tmp->entry.rbe_left) {
#line 125
          (tmp->entry.rbe_left)->entry.rbe_color = 0;
        }
#line 125
        while (1) {
#line 125
          tmp = parent->entry.rbe_left;
#line 125
          tmp___10 = tmp->entry.rbe_right;
#line 125
          parent->entry.rbe_left = tmp___10;
#line 125
          if ((unsigned long )tmp___10 != (unsigned long )((void *)0)) {
#line 125
            (tmp->entry.rbe_right)->entry.rbe_parent = parent;
          }
#line 125
          while (1) {
#line 125
            break;
          }
#line 125
          tmp___11 = parent->entry.rbe_parent;
#line 125
          tmp->entry.rbe_parent = tmp___11;
#line 125
          if ((unsigned long )tmp___11 != (unsigned long )((void *)0)) {
#line 125
            if ((unsigned long )parent == (unsigned long )(parent->entry.rbe_parent)->entry.rbe_left) {
#line 125
              (parent->entry.rbe_parent)->entry.rbe_left = tmp;
            } else {
#line 125
              (parent->entry.rbe_parent)->entry.rbe_right = tmp;
            }
          } else {
#line 125
            head->rbh_root = tmp;
          }
#line 125
          tmp->entry.rbe_right = parent;
#line 125
          parent->entry.rbe_parent = tmp;
#line 125
          while (1) {
#line 125
            break;
          }
#line 125
          if (tmp->entry.rbe_parent) {
#line 125
            while (1) {
#line 125
              break;
            }
          }
#line 125
          break;
        }
#line 125
        elm = head->rbh_root;
#line 125
        break;
      }
    }
  }
#line 125
  if (elm) {
#line 125
    elm->entry.rbe_color = 0;
  }
#line 125
  return;
}
}
#line 125 "tmux_leak_6.c"
struct args_entry *args_tree_RB_INSERT(struct args_tree *head , struct args_entry *elm ) 
{ 
  struct args_entry *tmp ;
  struct args_entry *parent ;
  int comp ;
  struct args_entry *tmp___0 ;

  {
#line 125
  parent = (struct args_entry *)((void *)0);
#line 125
  comp = 0;
#line 125
  tmp = head->rbh_root;
#line 125
  while (tmp) {
#line 125
    parent = tmp;
#line 125
    comp = args_cmp(elm, parent);
#line 125
    if (comp < 0) {
#line 125
      tmp = tmp->entry.rbe_left;
    } else
#line 125
    if (comp > 0) {
#line 125
      tmp = tmp->entry.rbe_right;
    } else {
#line 125
      return (tmp);
    }
  }
#line 125
  while (1) {
#line 125
    elm->entry.rbe_parent = parent;
#line 125
    tmp___0 = (struct args_entry *)((void *)0);
#line 125
    elm->entry.rbe_right = tmp___0;
#line 125
    elm->entry.rbe_left = tmp___0;
#line 125
    elm->entry.rbe_color = 1;
#line 125
    break;
  }
#line 125
  if ((unsigned long )parent != (unsigned long )((void *)0)) {
#line 125
    if (comp < 0) {
#line 125
      parent->entry.rbe_left = elm;
    } else {
#line 125
      parent->entry.rbe_right = elm;
    }
#line 125
    while (1) {
#line 125
      break;
    }
  } else {
#line 125
    head->rbh_root = elm;
  }
#line 125
  args_tree_RB_INSERT_COLOR(head, elm);
#line 125
  return ((struct args_entry *)((void *)0));
}
}
#line 125 "tmux_leak_6.c"
struct args_entry *args_tree_RB_REMOVE(struct args_tree *head , struct args_entry *elm ) 
{ 
  struct args_entry *child ;
  struct args_entry *parent ;
  struct args_entry *old ;
  int color ;
  struct args_entry *left ;

  {
#line 125
  old = elm;
#line 125
  if ((unsigned long )elm->entry.rbe_left == (unsigned long )((void *)0)) {
#line 125
    child = elm->entry.rbe_right;
  } else
#line 125
  if ((unsigned long )elm->entry.rbe_right == (unsigned long )((void *)0)) {
#line 125
    child = elm->entry.rbe_left;
  } else {
#line 125
    elm = elm->entry.rbe_right;
#line 125
    while (1) {
#line 125
      left = elm->entry.rbe_left;
#line 125
      if (! ((unsigned long )left != (unsigned long )((void *)0))) {
#line 125
        break;
      }
#line 125
      elm = left;
    }
#line 125
    child = elm->entry.rbe_right;
#line 125
    parent = elm->entry.rbe_parent;
#line 125
    color = elm->entry.rbe_color;
#line 125
    if (child) {
#line 125
      child->entry.rbe_parent = parent;
    }
#line 125
    if (parent) {
#line 125
      if ((unsigned long )parent->entry.rbe_left == (unsigned long )elm) {
#line 125
        parent->entry.rbe_left = child;
      } else {
#line 125
        parent->entry.rbe_right = child;
      }
#line 125
      while (1) {
#line 125
        break;
      }
    } else {
#line 125
      head->rbh_root = child;
    }
#line 125
    if ((unsigned long )elm->entry.rbe_parent == (unsigned long )old) {
#line 125
      parent = elm;
    }
#line 125
    elm->entry = old->entry;
#line 125
    if (old->entry.rbe_parent) {
#line 125
      if ((unsigned long )(old->entry.rbe_parent)->entry.rbe_left == (unsigned long )old) {
#line 125
        (old->entry.rbe_parent)->entry.rbe_left = elm;
      } else {
#line 125
        (old->entry.rbe_parent)->entry.rbe_right = elm;
      }
#line 125
      while (1) {
#line 125
        break;
      }
    } else {
#line 125
      head->rbh_root = elm;
    }
#line 125
    (old->entry.rbe_left)->entry.rbe_parent = elm;
#line 125
    if (old->entry.rbe_right) {
#line 125
      (old->entry.rbe_right)->entry.rbe_parent = elm;
    }
#line 125
    if (parent) {
#line 125
      left = parent;
#line 125
      while (1) {
#line 125
        while (1) {
#line 125
          break;
        }
#line 125
        left = left->entry.rbe_parent;
#line 125
        if (! ((unsigned long )left != (unsigned long )((void *)0))) {
#line 125
          break;
        }
      }
    }
#line 125
    goto color;
  }
#line 125
  parent = elm->entry.rbe_parent;
#line 125
  color = elm->entry.rbe_color;
#line 125
  if (child) {
#line 125
    child->entry.rbe_parent = parent;
  }
#line 125
  if (parent) {
#line 125
    if ((unsigned long )parent->entry.rbe_left == (unsigned long )elm) {
#line 125
      parent->entry.rbe_left = child;
    } else {
#line 125
      parent->entry.rbe_right = child;
    }
#line 125
    while (1) {
#line 125
      break;
    }
  } else {
#line 125
    head->rbh_root = child;
  }
  color: 
#line 125
  if (color == 0) {
#line 125
    args_tree_RB_REMOVE_COLOR(head, parent, child);
  }
#line 125
  return (old);
}
}
#line 125 "tmux_leak_6.c"
struct args_entry *args_tree_RB_FIND(struct args_tree *head , struct args_entry *elm ) 
{ 
  struct args_entry *tmp ;
  int comp ;

  {
#line 125
  tmp = head->rbh_root;
#line 125
  while (tmp) {
#line 125
    comp = args_cmp(elm, tmp);
#line 125
    if (comp < 0) {
#line 125
      tmp = tmp->entry.rbe_left;
    } else
#line 125
    if (comp > 0) {
#line 125
      tmp = tmp->entry.rbe_right;
    } else {
#line 125
      return (tmp);
    }
  }
#line 125
  return ((struct args_entry *)((void *)0));
}
}
#line 125 "tmux_leak_6.c"
struct args_entry *args_tree_RB_NFIND(struct args_tree *head , struct args_entry *elm ) 
{ 
  struct args_entry *tmp ;
  struct args_entry *res ;
  int comp ;

  {
#line 125
  tmp = head->rbh_root;
#line 125
  res = (struct args_entry *)((void *)0);
#line 125
  while (tmp) {
#line 125
    comp = args_cmp(elm, tmp);
#line 125
    if (comp < 0) {
#line 125
      res = tmp;
#line 125
      tmp = tmp->entry.rbe_left;
    } else
#line 125
    if (comp > 0) {
#line 125
      tmp = tmp->entry.rbe_right;
    } else {
#line 125
      return (tmp);
    }
  }
#line 125
  return (res);
}
}
#line 125 "tmux_leak_6.c"
struct args_entry *args_tree_RB_NEXT(struct args_entry *elm ) 
{ 


  {
#line 125
  if (elm->entry.rbe_right) {
#line 125
    elm = elm->entry.rbe_right;
#line 125
    while (elm->entry.rbe_left) {
#line 125
      elm = elm->entry.rbe_left;
    }
  } else
#line 125
  if (elm->entry.rbe_parent) {
#line 125
    if ((unsigned long )elm == (unsigned long )(elm->entry.rbe_parent)->entry.rbe_left) {
#line 125
      elm = elm->entry.rbe_parent;
    } else {
#line 125
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 125
    while (1) {
#line 125
      if (elm->entry.rbe_parent) {
#line 125
        if (! ((unsigned long )elm == (unsigned long )(elm->entry.rbe_parent)->entry.rbe_right)) {
#line 125
          break;
        }
      } else {
#line 125
        break;
      }
#line 125
      elm = elm->entry.rbe_parent;
    }
#line 125
    elm = elm->entry.rbe_parent;
  }
#line 125
  return (elm);
}
}
#line 125 "tmux_leak_6.c"
struct args_entry *args_tree_RB_PREV(struct args_entry *elm ) 
{ 


  {
#line 125
  if (elm->entry.rbe_left) {
#line 125
    elm = elm->entry.rbe_left;
#line 125
    while (elm->entry.rbe_right) {
#line 125
      elm = elm->entry.rbe_right;
    }
  } else
#line 125
  if (elm->entry.rbe_parent) {
#line 125
    if ((unsigned long )elm == (unsigned long )(elm->entry.rbe_parent)->entry.rbe_right) {
#line 125
      elm = elm->entry.rbe_parent;
    } else {
#line 125
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 125
    while (1) {
#line 125
      if (elm->entry.rbe_parent) {
#line 125
        if (! ((unsigned long )elm == (unsigned long )(elm->entry.rbe_parent)->entry.rbe_left)) {
#line 125
          break;
        }
      } else {
#line 125
        break;
      }
#line 125
      elm = elm->entry.rbe_parent;
    }
#line 125
    elm = elm->entry.rbe_parent;
  }
#line 125
  return (elm);
}
}
#line 125 "tmux_leak_6.c"
struct args_entry *args_tree_RB_MINMAX(struct args_tree *head , int val ) 
{ 
  struct args_entry *tmp ;
  struct args_entry *parent ;

  {
#line 125
  tmp = head->rbh_root;
#line 125
  parent = (struct args_entry *)((void *)0);
#line 125
  while (tmp) {
#line 125
    parent = tmp;
#line 125
    if (val < 0) {
#line 125
      tmp = tmp->entry.rbe_left;
    } else {
#line 125
      tmp = tmp->entry.rbe_right;
    }
  }
#line 125
  return (parent);
}
}
#line 127 "tmux_leak_6.c"
void *xrealloc(void *oldptr , size_t newsize ) 
{ 
  void *newptr ;

  {
#line 132
  if (newsize == 0UL) {
#line 133
    printf((char const   * __restrict  )"zero size%s", "");
#line 133
    exit(1);
  }
#line 134
  newptr = realloc(oldptr, newsize);
#line 134
  if ((unsigned long )newptr == (unsigned long )((void *)0)) {
#line 135
    printf((char const   * __restrict  )"xrealloc failed%s", "");
#line 135
    exit(1);
  }
#line 136
  return (newptr);
}
}
#line 142
extern int ( /* missing proto */  strcmp)() ;
#line 139 "tmux_leak_6.c"
int paste_cmp_names(struct paste_buffer  const  *a , struct paste_buffer  const  *b ) 
{ 
  int tmp ;

  {
#line 142
  tmp = strcmp(a->name, b->name);
#line 142
  return (tmp);
}
}
#line 146 "tmux_leak_6.c"
void paste_free(struct paste_buffer *pb ) 
{ 


  {
#line 149
  paste_name_tree_RB_REMOVE(& paste_by_name, pb);
#line 150
  if (pb->automatic) {
#line 151
    paste_num_automatic --;
  }
#line 153
  free((void *)pb->data);
#line 154
  free((void *)pb->name);
#line 155
  free((void *)pb);
#line 156
  return;
}
}
#line 159 "tmux_leak_6.c"
struct paste_buffer *paste_get_name(char const   *name ) 
{ 
  struct paste_buffer pbfind ;
  struct paste_buffer *tmp ;

  {
#line 164
  if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 165
    return ((struct paste_buffer *)((void *)0));
  } else
#line 164
  if ((int const   )*name == 0) {
#line 165
    return ((struct paste_buffer *)((void *)0));
  }
#line 167
  pbfind.name = (char *)name;
#line 168
  tmp = paste_name_tree_RB_FIND(& paste_by_name, & pbfind);
#line 168
  return (tmp);
}
}
#line 175 "tmux_leak_6.c"
void paste_add(char *data , size_t size ) 
{ 
  struct paste_buffer *pb ;
  void *tmp ;
  void *tmp___0 ;
  struct paste_buffer *tmp___1 ;
  u_int___0 tmp___2 ;

  {
#line 181
  if (size == 0UL) {
#line 182
    return;
  }
#line 184
  tmp = malloc(sizeof(*pb));
#line 184
  pb = (struct paste_buffer *)tmp;
#line 186
  pb->name = (char *)((void *)0);
#line 187
  while (1) {
#line 188
    free((void *)pb->name);
#line 189
    tmp___0 = malloc((size_t )10);
#line 189
    pb->name = (char *)tmp___0;
#line 190
    paste_next_index ++;
#line 187
    tmp___1 = paste_get_name((char const   *)pb->name);
#line 187
    if (! ((unsigned long )tmp___1 != (unsigned long )((void *)0))) {
#line 187
      break;
    }
  }
#line 193
  pb->data = data;
#line 194
  pb->size = size;
#line 196
  pb->automatic = 1;
#line 197
  paste_num_automatic ++;
#line 199
  tmp___2 = paste_next_order;
#line 199
  paste_next_order ++;
#line 199
  pb->order = tmp___2;
#line 200
  paste_name_tree_RB_INSERT(& paste_by_name, pb);
#line 201
  return;
}
}
#line 226
extern int ( /* missing proto */  strdup)() ;
#line 207 "tmux_leak_6.c"
int paste_set(char *data , size_t size , char const   *name , char **cause ) 
{ 
  struct paste_buffer *pb ;
  struct paste_buffer *old ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  u_int___0 tmp___2 ;

  {
#line 212
  if ((unsigned long )cause != (unsigned long )((void *)0)) {
#line 213
    *cause = (char *)((void *)0);
  }
#line 215
  if (size == 0UL) {
#line 216
    free((void *)data);
#line 217
    return (0);
  }
#line 219
  if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 220
    paste_add(data, size);
#line 221
    return (0);
  }
#line 224
  if ((int const   )*name == 0) {
#line 225
    if ((unsigned long )cause != (unsigned long )((void *)0)) {
#line 226
      tmp = strdup("empty buffer name");
#line 226
      *cause = (char *)tmp;
    }
#line 227
    return (-1);
  }
#line 230
  tmp___0 = malloc(sizeof(*pb));
#line 230
  pb = (struct paste_buffer *)tmp___0;
#line 232
  tmp___1 = strdup(name);
#line 232
  pb->name = (char *)tmp___1;
#line 234
  pb->data = data;
#line 235
  pb->size = size;
#line 237
  pb->automatic = 0;
#line 238
  tmp___2 = paste_next_order;
#line 238
  paste_next_order ++;
#line 238
  pb->order = tmp___2;
#line 240
  old = paste_get_name(name);
#line 240
  if ((unsigned long )old != (unsigned long )((void *)0)) {
#line 241
    paste_free(old);
  }
#line 243
  paste_name_tree_RB_INSERT(& paste_by_name, pb);
#line 245
  return (0);
}
}
#line 249 "tmux_leak_6.c"
struct args_entry *args_find(struct args *args , u_char___0 ch ) 
{ 
  struct args_entry entry ;
  struct args_entry *tmp ;

  {
#line 254
  entry.flag = ch;
#line 255
  tmp = args_tree_RB_FIND(& args->tree, & entry);
#line 255
  return (tmp);
}
}
#line 259 "tmux_leak_6.c"
int args_has(struct args *args , u_char___0 ch ) 
{ 
  int tmp___0 ;
  struct args_entry *tmp___1 ;

  {
#line 262
  tmp___1 = args_find(args, ch);
#line 262
  if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
#line 262
    tmp___0 = 0;
  } else {
#line 262
    tmp___0 = 1;
  }
#line 262
  return (tmp___0);
}
}
#line 269
extern int ( /* missing proto */  memcpy)() ;
#line 265 "tmux_leak_6.c"
char *cmd_capture_pane_append(char *buf , size_t *len , char *line , size_t linelen ) 
{ 
  void *tmp ;

  {
#line 268
  tmp = xrealloc((void *)buf, (*len + linelen) + 1UL);
#line 268
  buf = (char *)tmp;
#line 269
  memcpy(buf + *len, line, linelen);
#line 270
  *len += linelen;
#line 271
  return (buf);
}
}
#line 289
extern int ( /* missing proto */  strlen)() ;
#line 274 "tmux_leak_6.c"
char *cmd_capture_pane_pending(struct args *args , struct window_pane *wp , size_t *len ) 
{ 
  int *pending ;
  char *buf ;
  char *line ;
  char tmp[5] ;
  size_t linelen ;
  u_int___0 i ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 283
  if ((unsigned long )pending == (unsigned long )((void *)0)) {
#line 284
    tmp___0 = strdup("");
#line 284
    return ((char *)tmp___0);
  }
#line 286
  tmp___1 = strdup("");
#line 286
  buf = (char *)tmp___1;
#line 287
  tmp___3 = args_has(args, (u_char___0 )'C');
#line 287
  if (tmp___3) {
#line 288
    i = (u_int___0 )0;
#line 288
    while ((size_t )i < linelen) {
#line 289
      tmp___2 = strlen(tmp);
#line 289
      buf = cmd_capture_pane_append(buf, len, tmp, (size_t )tmp___2);
#line 288
      i ++;
    }
  } else {
#line 293
    buf = cmd_capture_pane_append(buf, len, line, linelen);
  }
#line 294
  return (buf);
}
}
#line 297 "tmux_leak_6.c"
char *cmd_capture_pane_history(struct args *args , struct cmd_q *cmdq , struct window_pane *wp ,
                               size_t *len ) 
{ 
  struct grid *gd ;
  u_int___0 i ;
  u_int___0 top ;
  u_int___0 bottom ;
  char *buf ;
  char *line ;
  size_t linelen ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;

  {
#line 307
  tmp___2 = args_has(args, (u_char___0 )'a');
#line 307
  if (tmp___2) {
#line 308
    if ((unsigned long )gd == (unsigned long )((void *)0)) {
#line 309
      tmp___0 = args_has(args, (u_char___0 )'q');
#line 309
      if (! tmp___0) {
#line 310
        return ((char *)((void *)0));
      }
#line 312
      tmp___1 = strdup("");
#line 312
      return ((char *)tmp___1);
    }
  }
#line 316
  buf = (char *)((void *)0);
#line 317
  i = top;
#line 317
  while (i <= bottom) {
#line 318
    buf = cmd_capture_pane_append(buf, len, line, linelen);
#line 319
    tmp___3 = *len;
#line 319
    (*len) ++;
#line 319
    *(buf + tmp___3) = (char )'\n';
#line 321
    free((void *)line);
#line 317
    i ++;
  }
#line 323
  return (buf);
}
}
#line 325 "tmux_leak_6.c"
enum cmd_retval cmd_capture_pane_exec(struct cmd *self , struct cmd_q *cmdq ) 
{ 
  struct args *args ;
  struct client *c ;
  struct window_pane *wp ;
  char *buf ;
  char *cause ;
  char const   *bufname ;
  size_t len ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 328
  args = self->args;
#line 335
  len = (size_t )0;
#line 336
  tmp = args_has(args, (u_char___0 )'P');
#line 336
  if (tmp) {
#line 337
    buf = cmd_capture_pane_pending(args, wp, & len);
  } else {
#line 339
    buf = cmd_capture_pane_history(args, cmdq, wp, & len);
  }
#line 340
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 341
    return ((enum cmd_retval )-1);
  }
#line 343
  tmp___1 = args_has(args, (u_char___0 )'p');
#line 343
  if (tmp___1) {
#line 344
    c = cmdq->client;
#line 345
    if ((unsigned long )c == (unsigned long )((void *)0)) {
#line 348
      return ((enum cmd_retval )-1);
    } else
#line 345
    if ((unsigned long )c->session != (unsigned long )((void *)0)) {
#line 345
      if (! (c->flags & 8192)) {
#line 348
        return ((enum cmd_retval )-1);
      }
    }
#line 350
    bufname = (char const   *)((void *)0);
#line 351
    tmp___0 = paste_set(buf, len, bufname, & cause);
#line 351
    if (tmp___0 != 0) {
#line 352
      free((void *)buf);
#line 353
      free((void *)cause);
#line 354
      return ((enum cmd_retval )-1);
    }
  }
#line 359
  return ((enum cmd_retval )0);
}
}
#line 362 "tmux_leak_6.c"
int main(void) 
{ 
  struct cmd self ;
  struct cmd_q cmdq ;
  struct paste_buffer *p ;

  {
#line 366
  cmd_capture_pane_exec(& self, & cmdq);
#line 369
  p = paste_name_tree_RB_MINMAX(& paste_by_name, -1);
#line 369
  while ((unsigned long )p != (unsigned long )((void *)0)) {
#line 370
    paste_free(p);
#line 369
    p = paste_name_tree_RB_NEXT(p);
  }
#line 371
  return (0);
}
}
