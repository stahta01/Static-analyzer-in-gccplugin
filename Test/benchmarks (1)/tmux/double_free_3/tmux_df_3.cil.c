/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

#line 216 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h"
typedef unsigned long size_t;
#line 68 "../stdio.h"
typedef unsigned int u_int___0;
#line 79 "../stdio.h"
typedef unsigned char u_char___0;
#line 117 "../stdio.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   int pw_uid ;
   int pw_gid ;
   int pw_change ;
   char *pw_class ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
   int pw_expire ;
};
#line 50 "../tmux.h"
struct args;
#line 50
struct args;
#line 633
struct cmd_list;
#line 1215 "../tmux.h"
struct __anonstruct_entry_51 {
   struct args_entry *rbe_left ;
   struct args_entry *rbe_right ;
   struct args_entry *rbe_parent ;
   int rbe_color ;
};
#line 1215 "../tmux.h"
struct args_entry {
   u_char___0 flag ;
   char *value ;
   struct __anonstruct_entry_51 entry ;
};
#line 1221 "../tmux.h"
struct args_tree {
   struct args_entry *rbh_root ;
};
#line 1222 "../tmux.h"
struct args {
   struct args_tree tree ;
   int argc ;
   char **argv ;
};
#line 1256
struct cmd_entry;
#line 1256 "../tmux.h"
struct __anonstruct_qentry_52 {
   struct cmd *tqe_next ;
   struct cmd **tqe_prev ;
};
#line 1256 "../tmux.h"
struct cmd {
   struct cmd_entry  const  *entry ;
   struct args *args ;
   char *file ;
   u_int___0 line ;
   int flags ;
   void *data ;
   struct __anonstruct_qentry_52 qentry ;
};
#line 1269 "../tmux.h"
struct __anonstruct_list_53 {
   struct cmd *tqh_first ;
   struct cmd **tqh_last ;
};
#line 1269 "../tmux.h"
struct cmd_list {
   int references ;
   struct __anonstruct_list_53 list ;
};
#line 1316
struct cmd_entry;
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 480 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 18 "tmux_df_3.c"
int cmd_string_getc(char const   *s , size_t *p ) ;
#line 19
void cmd_string_ungetc(char const   *s , size_t *p ) ;
#line 20
char *cmd_string_string(char const   *s , size_t *p , char endch , int esc ) ;
#line 21
char *cmd_string_variable(char const   *s , size_t *p ) ;
#line 22
char *cmd_string_expand_tilde(char const   *s , size_t *p ) ;
#line 24 "tmux_df_3.c"
void *xrealloc(void *oldptr , size_t nmemb , size_t size ) 
{ 
  size_t newsize ;
  void *newptr ;

  {
#line 27
  newsize = nmemb * size;
#line 30
  if (newsize == 0UL) {
#line 31
    printf((char const   * __restrict  )"zero size%s", "");
#line 31
    exit(1);
  }
#line 32
  if ((size_t )(1 << 30) / nmemb < size) {
#line 33
    printf((char const   * __restrict  )"nmemb * size > SIZE_MAX%s", "");
#line 33
    exit(1);
  }
#line 34
  newptr = realloc(oldptr, newsize);
#line 34
  if ((unsigned long )newptr == (unsigned long )((void *)0)) {
#line 35
    printf((char const   * __restrict  )"xrealloc failed%s", "");
#line 35
    exit(1);
  }
#line 37
  return (newptr);
}
}
#line 40 "tmux_df_3.c"
int cmd_string_getc(char const   *s , size_t *p ) 
{ 
  size_t tmp ;

  {
#line 43
  if ((int const   )*(s + *p) == 0) {
#line 44
    return (-1);
  }
#line 45
  tmp = *p;
#line 45
  (*p) ++;
#line 45
  return ((int )*(s + tmp));
}
}
#line 48 "tmux_df_3.c"
void cmd_string_ungetc(char const   *s , size_t *p ) 
{ 


  {
#line 51
  (*p) --;
#line 52
  return;
}
}
#line 93
extern int ( /* missing proto */  strlen)() ;
#line 94
extern int ( /* missing proto */  strcpy)() ;
#line 54 "tmux_df_3.c"
char *cmd_string_string(char const   *s , size_t *p , char endch , int esc ) 
{ 
  int ch ;
  char *buf ;
  char *t ;
  size_t len ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;

  {
#line 61
  buf = (char *)((void *)0);
#line 62
  len = (size_t )0;
#line 64
  while (1) {
#line 64
    ch = cmd_string_getc(s, p);
#line 64
    if (! (ch != (int )endch)) {
#line 64
      break;
    }
#line 65
    switch (ch) {
    case -1: 
#line 67
    goto error;
    case 92: 
#line 69
    if (! esc) {
#line 70
      break;
    }
#line 71
    ch = cmd_string_getc(s, p);
#line 71
    switch (ch) {
    case -1: 
#line 73
    goto error;
    case 101: 
#line 75
    ch = '\033';
#line 76
    break;
    case 114: 
#line 78
    ch = '\r';
#line 79
    break;
    case 110: 
#line 81
    ch = '\n';
#line 82
    break;
    case 116: 
#line 84
    ch = '\t';
#line 85
    break;
    }
#line 87
    break;
    case 36: 
#line 89
    if (! esc) {
#line 90
      break;
    }
#line 91
    t = cmd_string_variable(s, p);
#line 91
    if ((unsigned long )t == (unsigned long )((void *)0)) {
#line 92
      goto error;
    }
#line 93
    tmp = strlen(t);
#line 93
    tmp___0 = xrealloc((void *)buf, (size_t )1, (len + (size_t )tmp) + 1UL);
#line 93
    buf = (char *)tmp___0;
#line 94
    strcpy(buf + len, t);
#line 95
    tmp___1 = strlen(t);
#line 95
    len += (size_t )tmp___1;
#line 96
    free((void *)t);
#line 97
    continue;
    }
#line 100
    if (len >= (size_t )((1 << 30) - 2)) {
#line 101
      goto error;
    }
#line 102
    tmp___2 = xrealloc((void *)buf, (size_t )1, len + 1UL);
#line 102
    buf = (char *)tmp___2;
#line 103
    tmp___3 = len;
#line 103
    len ++;
#line 103
    *(buf + tmp___3) = (char )ch;
  }
#line 106
  tmp___4 = xrealloc((void *)buf, (size_t )1, len + 1UL);
#line 106
  buf = (char *)tmp___4;
#line 107
  *(buf + len) = (char )'\000';
#line 108
  return (buf);
  error: 
#line 111
  if ((unsigned long )buf != (unsigned long )((void *)0)) {
#line 112
    free((void *)buf);
  }
#line 113
  return ((char *)((void *)0));
}
}
#line 145
extern int ( /* missing proto */  strdup)() ;
#line 116 "tmux_df_3.c"
char *cmd_string_variable(char const   *s , size_t *p ) 
{ 
  int ch ;
  int fch ;
  char *buf ;
  char *t ;
  size_t len ;
  int tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 129
  buf = (char *)((void *)0);
#line 130
  len = (size_t )0;
#line 132
  fch = -1;
#line 133
  ch = cmd_string_getc(s, p);
#line 133
  switch (ch) {
  case -1: 
#line 135
  goto error;
  case 123: 
#line 137
  fch = '{';
#line 139
  ch = cmd_string_getc(s, p);
#line 140
  if (! (ch == 95)) {
#line 140
    if (ch >= 97) {
#line 140
      if (! (ch <= 122)) {
#line 140
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 140
    if (ch >= 65) {
#line 140
      if (! (ch <= 90)) {
#line 141
        goto error;
      }
    } else {
#line 141
      goto error;
    }
  }
  default: 
#line 144
  if (! (ch == 95)) {
#line 144
    if (ch >= 97) {
#line 144
      if (! (ch <= 122)) {
#line 144
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 144
    if (ch >= 65) {
#line 144
      if (! (ch <= 90)) {
#line 145
        tmp = strdup("$");
#line 145
        t = (char *)tmp;
#line 146
        return (t);
      }
    } else {
#line 145
      tmp = strdup("$");
#line 145
      t = (char *)tmp;
#line 146
      return (t);
    }
  }
#line 149
  tmp___0 = xrealloc((void *)buf, (size_t )1, len + 1UL);
#line 149
  buf = (char *)tmp___0;
#line 150
  tmp___1 = len;
#line 150
  len ++;
#line 150
  *(buf + tmp___1) = (char )ch;
#line 152
  while (1) {
#line 153
    ch = cmd_string_getc(s, p);
#line 154
    if (ch == -1) {
#line 155
      break;
    } else
#line 154
    if (ch == 95) {
#line 154
      goto _L___1;
    } else
#line 154
    if (ch >= 97) {
#line 154
      if (ch <= 122) {
#line 154
        goto _L___1;
      } else {
#line 154
        goto _L___3;
      }
    } else
    _L___3: /* CIL Label */ 
#line 154
    if (ch >= 65) {
#line 154
      if (ch <= 90) {
#line 154
        goto _L___1;
      } else {
#line 154
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 154
    if (ch >= 48) {
#line 154
      if (ch <= 57) {
        _L___1: /* CIL Label */ 
#line 157
        if (len >= (size_t )((1 << 30) - 3)) {
#line 158
          goto error;
        }
#line 159
        tmp___2 = xrealloc((void *)buf, (size_t )1, len + 1UL);
#line 159
        buf = (char *)tmp___2;
#line 160
        tmp___3 = len;
#line 160
        len ++;
#line 160
        *(buf + tmp___3) = (char )ch;
      } else {
#line 155
        break;
      }
    } else {
#line 155
      break;
    }
  }
  }
#line 165
  if (fch == 123) {
#line 165
    if (ch != 125) {
#line 166
      goto error;
    }
  }
#line 167
  if (ch != -1) {
#line 167
    if (fch != 123) {
#line 168
      cmd_string_ungetc(s, p);
    }
  }
#line 170
  tmp___4 = xrealloc((void *)buf, (size_t )1, len + 1UL);
#line 170
  buf = (char *)tmp___4;
#line 171
  *(buf + len) = (char )'\000';
#line 173
  t = getenv((char const   *)buf);
#line 173
  if ((unsigned long )t == (unsigned long )((void *)0)) {
#line 174
    free((void *)buf);
#line 175
    tmp___5 = strdup("");
#line 175
    return ((char *)tmp___5);
  }
#line 177
  free((void *)buf);
#line 178
  tmp___6 = strdup(t);
#line 178
  return ((char *)tmp___6);
  error: 
#line 181
  if ((unsigned long )buf != (unsigned long )((void *)0)) {
#line 182
    free((void *)buf);
  }
#line 183
  return ((char *)((void *)0));
}
}
#line 195
extern int ( /* missing proto */  getpwuid)() ;
#line 195
extern int ( /* missing proto */  getuid)() ;
#line 202
extern int ( /* missing proto */  getpwnam)() ;
#line 186 "tmux_df_3.c"
char *cmd_string_expand_tilde(char const   *s , size_t *p ) 
{ 
  struct passwd *pw ;
  char *home ;
  char *path ;
  char *username ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 192
  home = (char *)((void *)0);
#line 193
  tmp___2 = cmd_string_getc(s, p);
#line 193
  if (tmp___2 == 47) {
#line 194
    home = getenv("HOME");
#line 194
    if ((unsigned long )home == (unsigned long )((void *)0)) {
#line 195
      tmp = getuid();
#line 195
      tmp___0 = getpwuid(tmp);
#line 195
      pw = (struct passwd *)tmp___0;
#line 195
      if ((unsigned long )pw != (unsigned long )((void *)0)) {
#line 196
        home = pw->pw_dir;
      }
    }
  } else {
#line 199
    cmd_string_ungetc(s, p);
#line 200
    username = cmd_string_string(s, p, (char )'/', 0);
#line 200
    if ((unsigned long )username == (unsigned long )((void *)0)) {
#line 201
      return ((char *)((void *)0));
    }
#line 202
    tmp___1 = getpwnam(username);
#line 202
    pw = (struct passwd *)tmp___1;
#line 202
    if ((unsigned long )pw != (unsigned long )((void *)0)) {
#line 203
      home = pw->pw_dir;
    }
#line 204
    if ((unsigned long )username != (unsigned long )((void *)0)) {
#line 205
      free((void *)username);
    }
  }
#line 207
  if ((unsigned long )home == (unsigned long )((void *)0)) {
#line 208
    return ((char *)((void *)0));
  }
#line 210
  tmp___3 = strdup(home);
#line 210
  path = (char *)tmp___3;
#line 211
  return (path);
}
}
#line 268
extern int ( /* missing proto */  strchr)() ;
#line 269
extern int ( /* missing proto */  strcspn)() ;
#line 273
extern int ( /* missing proto */  memmove)() ;
#line 217 "tmux_df_3.c"
int cmd_string_parse(char const   *s , struct cmd_list **cmdlist , char **cause ) 
{ 
  size_t p ;
  int ch ;
  int i ;
  int argc ;
  int rval ;
  int have_arg ;
  char **argv ;
  char *buf ;
  char const   *whitespace ;
  char const   *equals ;
  size_t len ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  size_t tmp___5 ;

  {
#line 226
  argv = (char **)((void *)0);
#line 227
  argc = 0;
#line 229
  buf = (char *)((void *)0);
#line 230
  len = (size_t )0;
#line 232
  have_arg = 0;
#line 234
  *cause = (char *)((void *)0);
#line 236
  *cmdlist = (struct cmd_list *)((void *)0);
#line 237
  rval = -1;
#line 239
  p = (size_t )0;
#line 240
  while (1) {
#line 241
    ch = cmd_string_getc(s, & p);
#line 242
    switch (ch) {
    case 35: 
#line 245
    while (1) {
#line 245
      ch = cmd_string_getc(s, & p);
#line 245
      if (! (ch != -1)) {
#line 245
        break;
      }
    }
    case 9: 
    case 32: 
    case -1: 
#line 251
    if (have_arg) {
#line 252
      tmp = xrealloc((void *)buf, (size_t )1, len + 1UL);
#line 252
      buf = (char *)tmp;
#line 253
      *(buf + len) = (char )'\000';
#line 255
      tmp___0 = xrealloc((void *)argv, (size_t )(argc + 1), sizeof(*argv));
#line 255
      argv = (char **)tmp___0;
#line 256
      tmp___1 = argc;
#line 256
      argc ++;
#line 256
      *(argv + tmp___1) = buf;
#line 258
      buf = (char *)((void *)0);
#line 259
      len = (size_t )0;
#line 261
      have_arg = 0;
    }
#line 264
    if (ch != -1) {
#line 265
      break;
    }
#line 267
    while (argc != 0) {
#line 268
      tmp___2 = strchr(*(argv + 0), '=');
#line 268
      equals = (char const   *)tmp___2;
#line 269
      tmp___3 = strcspn(*(argv + 0), " \t");
#line 269
      whitespace = (char const   *)(*(argv + 0) + tmp___3);
#line 270
      if ((unsigned long )equals == (unsigned long )((void *)0)) {
#line 271
        break;
      } else
#line 270
      if ((unsigned long )equals > (unsigned long )whitespace) {
#line 271
        break;
      }
#line 272
      argc --;
#line 273
      memmove(argv, argv + 1, (unsigned long )argc * sizeof(*argv));
    }
#line 275
    if (argc == 0) {
#line 276
      goto error;
    }
#line 278
    while (1) {
#line 279
      free((void *)*(argv + (argc - 1)));
#line 278
      argc --;
#line 278
      if (! (argc > 0)) {
#line 278
        break;
      }
    }
#line 282
    rval = 0;
#line 283
    goto error;
    default: 
#line 286
    if (len >= (size_t )((1 << 30) - 2)) {
#line 287
      goto error;
    }
#line 289
    tmp___4 = xrealloc((void *)buf, (size_t )1, len + 1UL);
#line 289
    buf = (char *)tmp___4;
#line 290
    tmp___5 = len;
#line 290
    len ++;
#line 290
    *(buf + tmp___5) = (char )ch;
#line 292
    have_arg = 1;
#line 293
    break;
    }
  }
  error: 
#line 300
  if ((unsigned long )buf != (unsigned long )((void *)0)) {
#line 301
    free((void *)buf);
  }
#line 303
  if ((unsigned long )argv != (unsigned long )((void *)0)) {
#line 304
    i = 0;
#line 304
    while (i < argc) {
#line 305
      free((void *)*(argv + argc));
#line 304
      i ++;
    }
#line 306
    free((void *)argv);
  }
#line 309
  return (rval);
}
}
#line 312 "tmux_df_3.c"
int main(int argc , char **argv ) 
{ 
  char *cause ;
  struct cmd_list *cmdlist ;

  {
#line 317
  if (argc > 1) {
#line 318
    cmd_string_parse((char const   *)*(argv + 1), & cmdlist, & cause);
  }
#line 320
  return (0);
}
}
