/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

#line 216 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h"
typedef unsigned long size_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 192 "../stdio.h"
typedef unsigned short u_short___0;
#line 193 "../stdio.h"
typedef unsigned int u_int___0;
#line 204 "../stdio.h"
typedef unsigned char u_char___0;
#line 210 "../stdio.h"
typedef int pid_t___0;
#line 39 "../tmux.h"
typedef char bitstr_t;
#line 41 "../tmux.h"
struct event {

};
#line 42 "../tmux.h"
struct termios {

};
#line 50
struct args;
#line 50
struct args;
#line 51
struct client;
#line 51
struct client;
#line 52
struct cmd_find_state;
#line 52
struct cmd_find_state;
#line 55
struct environ;
#line 55
struct environ;
#line 57
struct input_ctx;
#line 57
struct input_ctx;
#line 59
struct mouse_event;
#line 59
struct mouse_event;
#line 60
struct options;
#line 60
struct options;
#line 61
struct options_entry;
#line 61
struct options_entry;
#line 62
struct session;
#line 62
struct session;
#line 140 "../tmux.h"
typedef unsigned long long key_code;
#line 473 "../tmux.h"
struct options_tree {
   struct options_entry *rbh_root ;
};
#line 473 "../tmux.h"
struct options {
   struct options_tree tree ;
   struct options *parent ;
};
#line 543 "../tmux.h"
struct utf8_data {
   u_char___0 data[9] ;
   u_char___0 have ;
   u_char___0 size ;
   u_char___0 width ;
};
#line 585 "../tmux.h"
struct grid_cell {
   u_char___0 flags ;
   u_short___0 attr ;
   int fg ;
   int bg ;
   struct utf8_data data ;
};
#line 592 "../tmux.h"
struct __anonstruct_data_29 {
   u_char___0 attr ;
   u_char___0 fg ;
   u_char___0 bg ;
   u_char___0 data ;
};
#line 592 "../tmux.h"
union __anonunion____missing_field_name_28 {
   u_int___0 offset ;
   struct __anonstruct_data_29 data ;
};
#line 592 "../tmux.h"
struct grid_cell_entry {
   u_char___0 flags ;
   union __anonunion____missing_field_name_28 __annonCompField1 ;
};
#line 606 "../tmux.h"
struct grid_line {
   u_int___0 cellused ;
   u_int___0 cellsize ;
   struct grid_cell_entry *celldata ;
   u_int___0 extdsize ;
   struct grid_cell *extddata ;
   int flags ;
};
#line 618 "../tmux.h"
struct grid {
   int flags ;
   u_int___0 sx ;
   u_int___0 sy ;
   u_int___0 hscrolled ;
   u_int___0 hsize ;
   u_int___0 hlimit ;
   struct grid_line *linedata ;
};
#line 646
struct bufferevent;
#line 671
enum __anonenum_lineflag_33 {
    LINE_SEL_NONE = 0,
    LINE_SEL_LEFT_RIGHT = 1,
    LINE_SEL_RIGHT_LEFT = 2
} ;
#line 671 "../tmux.h"
struct screen_sel {
   int flag ;
   int hidden ;
   int rectflag ;
   enum __anonenum_lineflag_33 lineflag ;
   int modekeys ;
   u_int___0 sx ;
   u_int___0 sy ;
   u_int___0 ex ;
   u_int___0 ey ;
   struct grid_cell cell ;
};
#line 693
struct screen_titles;
#line 693
struct screen_titles;
#line 694 "../tmux.h"
struct screen {
   char *title ;
   struct screen_titles *titles ;
   struct grid *grid ;
   u_int___0 cx ;
   u_int___0 cy ;
   u_int___0 cstyle ;
   char *ccolour ;
   u_int___0 rupper ;
   u_int___0 rlower ;
   u_int___0 hsize ;
   int mode ;
   bitstr_t *tabs ;
   struct screen_sel sel ;
};
#line 721
struct window_pane;
#line 746 "../tmux.h"
struct window_mode {
   char const   *name ;
   struct screen *(*init)(struct window_pane * , struct cmd_find_state * , struct args * ) ;
   void (*free)(struct window_pane * ) ;
   void (*resize)(struct window_pane * , u_int___0  , u_int___0  ) ;
   void (*key)(struct window_pane * , struct client * , struct session * , key_code  ,
               struct mouse_event * ) ;
   char const   *(*key_table)(struct window_pane * ) ;
   void (*command)(struct window_pane * , struct client * , struct session * , struct args * ,
                   struct mouse_event * ) ;
};
#line 766
struct winlink;
#line 788
struct window;
#line 788
struct layout_cell;
#line 788 "../tmux.h"
struct __anonstruct_entry_34 {
   struct window_pane *tqe_next ;
   struct window_pane **tqe_prev ;
};
#line 788 "../tmux.h"
struct __anonstruct_tree_entry_35 {
   struct window_pane *rbe_left ;
   struct window_pane *rbe_right ;
   struct window_pane *rbe_parent ;
   int rbe_color ;
};
#line 788 "../tmux.h"
struct window_pane {
   u_int___0 id ;
   u_int___0 active_point ;
   struct window *window ;
   struct layout_cell *layout_cell ;
   struct layout_cell *saved_layout_cell ;
   u_int___0 sx ;
   u_int___0 sy ;
   u_int___0 osx ;
   u_int___0 osy ;
   u_int___0 xoff ;
   u_int___0 yoff ;
   int flags ;
   int argc ;
   char **argv ;
   char *shell ;
   char const   *cwd ;
   pid_t___0 pid ;
   char tty[10] ;
   int status ;
   int fd ;
   struct bufferevent *event ;
   struct event resize_timer ;
   struct input_ctx *ictx ;
   struct grid_cell colgc ;
   int *palette ;
   int pipe_fd ;
   struct bufferevent *pipe_event ;
   size_t pipe_off ;
   struct screen *screen ;
   struct screen base ;
   struct screen status_screen ;
   size_t status_size ;
   u_int___0 saved_cx ;
   u_int___0 saved_cy ;
   struct grid *saved_grid ;
   struct grid_cell saved_cell ;
   struct window_mode  const  *mode ;
   void *modedata ;
   struct event modetimer ;
   time_t modelast ;
   u_int___0 modeprefix ;
   char *searchstr ;
   struct __anonstruct_entry_34 entry ;
   struct __anonstruct_tree_entry_35 tree_entry ;
};
#line 865 "../tmux.h"
struct window_panes {
   struct window_pane *tqh_first ;
   struct window_pane **tqh_last ;
};
#line 870 "../tmux.h"
struct __anonstruct_alerts_entry_36 {
   struct window *tqe_next ;
   struct window **tqe_prev ;
};
#line 870 "../tmux.h"
struct __anonstruct_winlinks_37 {
   struct winlink *tqh_first ;
   struct winlink **tqh_last ;
};
#line 870 "../tmux.h"
struct __anonstruct_entry_38 {
   struct window *rbe_left ;
   struct window *rbe_right ;
   struct window *rbe_parent ;
   int rbe_color ;
};
#line 870 "../tmux.h"
struct window {
   u_int___0 id ;
   char *name ;
   struct event name_event ;
   struct timeval name_time ;
   struct event alerts_timer ;
   struct timeval activity_time ;
   struct window_pane *active ;
   struct window_pane *last ;
   struct window_panes panes ;
   int lastlayout ;
   struct layout_cell *layout_root ;
   struct layout_cell *saved_layout_root ;
   char *old_layout ;
   u_int___0 sx ;
   u_int___0 sy ;
   int flags ;
   int alerts_queued ;
   struct __anonstruct_alerts_entry_36 alerts_entry ;
   struct options *options ;
   struct grid_cell style ;
   struct grid_cell active_style ;
   u_int___0 references ;
   struct __anonstruct_winlinks_37 winlinks ;
   struct __anonstruct_entry_38 entry ;
};
#line 922 "../tmux.h"
struct __anonstruct_entry_39 {
   struct winlink *rbe_left ;
   struct winlink *rbe_right ;
   struct winlink *rbe_parent ;
   int rbe_color ;
};
#line 922 "../tmux.h"
struct __anonstruct_wentry_40 {
   struct winlink *tqe_next ;
   struct winlink **tqe_prev ;
};
#line 922 "../tmux.h"
struct __anonstruct_sentry_41 {
   struct winlink *tqe_next ;
   struct winlink **tqe_prev ;
};
#line 922 "../tmux.h"
struct winlink {
   int idx ;
   struct session *session ;
   struct window *window ;
   size_t status_width ;
   struct grid_cell status_cell ;
   char *status_text ;
   int flags ;
   struct __anonstruct_entry_39 entry ;
   struct __anonstruct_wentry_40 wentry ;
   struct __anonstruct_sentry_41 sentry ;
};
#line 941 "../tmux.h"
struct winlinks {
   struct winlink *rbh_root ;
};
#line 942 "../tmux.h"
struct winlink_stack {
   struct winlink *tqh_first ;
   struct winlink **tqh_last ;
};
#line 945
enum layout_type {
    LAYOUT_LEFTRIGHT = 0,
    LAYOUT_TOPBOTTOM = 1,
    LAYOUT_WINDOWPANE = 2
} ;
#line 952 "../tmux.h"
struct layout_cells {
   struct layout_cell *tqh_first ;
   struct layout_cell **tqh_last ;
};
#line 955 "../tmux.h"
struct __anonstruct_entry_42 {
   struct layout_cell *tqe_next ;
   struct layout_cell **tqe_prev ;
};
#line 955 "../tmux.h"
struct layout_cell {
   enum layout_type type ;
   struct layout_cell *parent ;
   u_int___0 sx ;
   u_int___0 sy ;
   u_int___0 xoff ;
   u_int___0 yoff ;
   struct window_pane *wp ;
   struct layout_cells cells ;
   struct __anonstruct_entry_42 entry ;
};
#line 992
struct hooks;
#line 992 "../tmux.h"
struct __anonstruct_gentry_46 {
   struct session *tqe_next ;
   struct session **tqe_prev ;
};
#line 992 "../tmux.h"
struct __anonstruct_entry_47 {
   struct session *rbe_left ;
   struct session *rbe_right ;
   struct session *rbe_parent ;
   int rbe_color ;
};
#line 992 "../tmux.h"
struct session {
   u_int___0 id ;
   char *name ;
   char const   *cwd ;
   struct timeval creation_time ;
   struct timeval last_attached_time ;
   struct timeval activity_time ;
   struct timeval last_activity_time ;
   struct event lock_timer ;
   u_int___0 sx ;
   u_int___0 sy ;
   struct winlink *curw ;
   struct winlink_stack lastw ;
   struct winlinks windows ;
   int statusat ;
   struct hooks *hooks ;
   struct options *options ;
   int flags ;
   u_int___0 attached ;
   struct termios *tio ;
   struct environ *environ ;
   int references ;
   struct __anonstruct_gentry_46 gentry ;
   struct __anonstruct_entry_47 entry ;
};
#line 1055 "../tmux.h"
struct mouse_event {
   int valid ;
   key_code key ;
   int statusat ;
   u_int___0 x ;
   u_int___0 y ;
   u_int___0 b ;
   u_int___0 lx ;
   u_int___0 ly ;
   u_int___0 lb ;
   int s ;
   int w ;
   int wp ;
   u_int___0 sgr_type ;
   u_int___0 sgr_b ;
};
#line 1078 "../tmux.h"
struct tty_key {
   char ch ;
   key_code key ;
   struct tty_key *left ;
   struct tty_key *right ;
   struct tty_key *next ;
};
#line 1088
struct tty_code;
#line 1088
struct tty_code;
#line 1215 "../tmux.h"
struct __anonstruct_entry_49 {
   struct args_entry *rbe_left ;
   struct args_entry *rbe_right ;
   struct args_entry *rbe_parent ;
   int rbe_color ;
};
#line 1215 "../tmux.h"
struct args_entry {
   u_char___0 flag ;
   char *value ;
   struct __anonstruct_entry_49 entry ;
};
#line 1221 "../tmux.h"
struct args_tree {
   struct args_entry *rbh_root ;
};
#line 1222 "../tmux.h"
struct args {
   struct args_tree tree ;
   int argc ;
   char **argv ;
};
#line 1234 "../tmux.h"
struct cmd_find_state {
   int flags ;
   struct cmd_find_state *current ;
   struct session *s ;
   struct winlink *wl ;
   struct window *w ;
   struct window_pane *wp ;
   int idx ;
};
#line 16 "tmux_uaf_5.c"
struct pollfd {
   int fd ;
   int events ;
};
#line 21 "tmux_uaf_5.c"
struct imsgbuf {
   int fd ;
   pid_t___0 pid ;
};
#line 27
enum tty_code_type {
    TTYCODE_NONE = 0,
    TTYCODE_STRING = 1,
    TTYCODE_NUMBER = 2,
    TTYCODE_FLAG = 3
} ;
#line 35 "tmux_uaf_5.c"
union __anonunion_value_54 {
   char *string ;
   int number ;
   int flag ;
};
#line 35 "tmux_uaf_5.c"
struct tty_code {
   enum tty_code_type type ;
   union __anonunion_value_54 value ;
};
#line 45 "tmux_uaf_5.c"
struct tty_term {
   char *name ;
   u_int___0 references ;
   struct tty_code codes[300] ;
   int flags ;
};
#line 58
struct buffer;
#line 58 "tmux_uaf_5.c"
struct tty_keys {
   struct tty_key *rbh_root ;
};
#line 58 "tmux_uaf_5.c"
struct tty {
   char *path ;
   u_int___0 sx ;
   u_int___0 sy ;
   u_int___0 cx ;
   u_int___0 cy ;
   int mode ;
   u_int___0 rlower ;
   u_int___0 rupper ;
   char *termname ;
   struct tty_term *term ;
   int fd ;
   struct buffer *in ;
   struct buffer *out ;
   int log_fd ;
   struct termios tio ;
   struct grid_cell cell ;
   u_char___0 acs[11] ;
   int flags ;
   int term_flags ;
   struct timeval key_timer ;
   size_t ksize ;
   struct tty_keys ktree ;
};
#line 104 "tmux_uaf_5.c"
struct __anonstruct_prompt_hdata_55 {
   char **list ;
   u_int___0 num ;
   size_t space ;
};
#line 104 "tmux_uaf_5.c"
struct client {
   struct imsgbuf ibuf ;
   struct timeval tv ;
   char *title ;
   char *cwd ;
   struct tty tty ;
   struct timeval repeat_timer ;
   struct timeval status_timer ;
   struct screen status ;
   int flags ;
   struct timeval identify_timer ;
   char *message_string ;
   struct timeval message_timer ;
   char *prompt_string ;
   char *prompt_buffer ;
   size_t prompt_index ;
   int (*prompt_callbackfn)(void * , char const   * ) ;
   void (*prompt_freefn)(void * ) ;
   void *prompt_data ;
   int prompt_flags ;
   u_int___0 prompt_hindex ;
   struct __anonstruct_prompt_hdata_55 prompt_hdata ;
   struct session *session ;
   int references ;
};
#line 151 "tmux_uaf_5.c"
struct clients {
   struct client **list ;
   u_int___0 num ;
   size_t space ;
};
#line 167 "tmux_uaf_5.c"
struct buffer {
   u_char___0 *base ;
   size_t space ;
   size_t size ;
   size_t off ;
};
#line 176 "tmux_uaf_5.c"
struct __anonstruct_entry_56 {
   struct poll_item *rbe_left ;
   struct poll_item *rbe_right ;
   struct poll_item *rbe_parent ;
   int rbe_color ;
};
#line 176 "tmux_uaf_5.c"
struct poll_item {
   int fd ;
   int events ;
   void (*fn)(int  , int  , void * ) ;
   void *data ;
   struct __anonstruct_entry_56 entry ;
};
#line 185 "tmux_uaf_5.c"
struct poll_items {
   struct poll_item *rbh_root ;
};
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 374 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rand)(void) ;
#line 376
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) srand)(unsigned int __seed ) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 155 "tmux_uaf_5.c"
struct clients clients  ;
#line 156 "tmux_uaf_5.c"
struct clients dead_clients  ;
#line 158 "tmux_uaf_5.c"
int srv_fd  ;
#line 185 "tmux_uaf_5.c"
struct poll_items poll_items  ;
#line 187
int server_poll_cmp(struct poll_item *pitem1 , struct poll_item *pitem2 ) ;
#line 188
struct poll_item *server_poll_lookup(int fd ) ;
#line 189
void server_poll_add(int fd , int events , void (*fn)(int  , int  , void * ) , void *data ) ;
#line 190
struct pollfd *server_poll_flatten(int *nfds ) ;
#line 191
void server_poll_dispatch(struct pollfd *pfds , int nfds ) ;
#line 192
void server_poll_reset(void) ;
#line 194
void poll_items_RB_INSERT_COLOR(struct poll_items *head , struct poll_item *elm ) ;
#line 194
void poll_items_RB_REMOVE_COLOR(struct poll_items *head , struct poll_item *parent ,
                                struct poll_item *elm ) ;
#line 194
struct poll_item *poll_items_RB_INSERT(struct poll_items *head , struct poll_item *elm ) ;
#line 194
struct poll_item *poll_items_RB_REMOVE(struct poll_items *head , struct poll_item *elm ) ;
#line 194
struct poll_item *poll_items_RB_FIND(struct poll_items *head , struct poll_item *elm ) ;
#line 194
struct poll_item *poll_items_RB_NFIND(struct poll_items *head , struct poll_item *elm ) ;
#line 194
struct poll_item *poll_items_RB_NEXT(struct poll_item *elm ) ;
#line 194
struct poll_item *poll_items_RB_PREV(struct poll_item *elm ) ;
#line 194
struct poll_item *poll_items_RB_MINMAX(struct poll_items *head , int val ) ;
#line 195 "tmux_uaf_5.c"
void poll_items_RB_INSERT_COLOR(struct poll_items *head , struct poll_item *elm ) 
{ 
  struct poll_item *parent ;
  struct poll_item *gparent ;
  struct poll_item *tmp ;
  struct poll_item *tmp___0 ;
  struct poll_item *tmp___1 ;
  struct poll_item *tmp___2 ;
  struct poll_item *tmp___3 ;
  struct poll_item *tmp___4 ;
  struct poll_item *tmp___5 ;
  struct poll_item *tmp___6 ;
  struct poll_item *tmp___7 ;

  {
#line 195
  while (1) {
#line 195
    parent = elm->entry.rbe_parent;
#line 195
    if ((unsigned long )parent != (unsigned long )((void *)0)) {
#line 195
      if (! (parent->entry.rbe_color == 1)) {
#line 195
        break;
      }
    } else {
#line 195
      break;
    }
#line 195
    gparent = parent->entry.rbe_parent;
#line 195
    if ((unsigned long )parent == (unsigned long )gparent->entry.rbe_left) {
#line 195
      tmp = gparent->entry.rbe_right;
#line 195
      if (tmp) {
#line 195
        if (tmp->entry.rbe_color == 1) {
#line 195
          tmp->entry.rbe_color = 0;
#line 195
          while (1) {
#line 195
            parent->entry.rbe_color = 0;
#line 195
            gparent->entry.rbe_color = 1;
#line 195
            break;
          }
#line 195
          elm = gparent;
#line 195
          continue;
        }
      }
#line 195
      if ((unsigned long )parent->entry.rbe_right == (unsigned long )elm) {
#line 195
        while (1) {
#line 195
          tmp = parent->entry.rbe_right;
#line 195
          tmp___0 = tmp->entry.rbe_left;
#line 195
          parent->entry.rbe_right = tmp___0;
#line 195
          if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 195
            (tmp->entry.rbe_left)->entry.rbe_parent = parent;
          }
#line 195
          while (1) {
#line 195
            break;
          }
#line 195
          tmp___1 = parent->entry.rbe_parent;
#line 195
          tmp->entry.rbe_parent = tmp___1;
#line 195
          if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
#line 195
            if ((unsigned long )parent == (unsigned long )(parent->entry.rbe_parent)->entry.rbe_left) {
#line 195
              (parent->entry.rbe_parent)->entry.rbe_left = tmp;
            } else {
#line 195
              (parent->entry.rbe_parent)->entry.rbe_right = tmp;
            }
          } else {
#line 195
            head->rbh_root = tmp;
          }
#line 195
          tmp->entry.rbe_left = parent;
#line 195
          parent->entry.rbe_parent = tmp;
#line 195
          while (1) {
#line 195
            break;
          }
#line 195
          if (tmp->entry.rbe_parent) {
#line 195
            while (1) {
#line 195
              break;
            }
          }
#line 195
          break;
        }
#line 195
        tmp = parent;
#line 195
        parent = elm;
#line 195
        elm = tmp;
      }
#line 195
      while (1) {
#line 195
        parent->entry.rbe_color = 0;
#line 195
        gparent->entry.rbe_color = 1;
#line 195
        break;
      }
#line 195
      while (1) {
#line 195
        tmp = gparent->entry.rbe_left;
#line 195
        tmp___2 = tmp->entry.rbe_right;
#line 195
        gparent->entry.rbe_left = tmp___2;
#line 195
        if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
#line 195
          (tmp->entry.rbe_right)->entry.rbe_parent = gparent;
        }
#line 195
        while (1) {
#line 195
          break;
        }
#line 195
        tmp___3 = gparent->entry.rbe_parent;
#line 195
        tmp->entry.rbe_parent = tmp___3;
#line 195
        if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
#line 195
          if ((unsigned long )gparent == (unsigned long )(gparent->entry.rbe_parent)->entry.rbe_left) {
#line 195
            (gparent->entry.rbe_parent)->entry.rbe_left = tmp;
          } else {
#line 195
            (gparent->entry.rbe_parent)->entry.rbe_right = tmp;
          }
        } else {
#line 195
          head->rbh_root = tmp;
        }
#line 195
        tmp->entry.rbe_right = gparent;
#line 195
        gparent->entry.rbe_parent = tmp;
#line 195
        while (1) {
#line 195
          break;
        }
#line 195
        if (tmp->entry.rbe_parent) {
#line 195
          while (1) {
#line 195
            break;
          }
        }
#line 195
        break;
      }
    } else {
#line 195
      tmp = gparent->entry.rbe_left;
#line 195
      if (tmp) {
#line 195
        if (tmp->entry.rbe_color == 1) {
#line 195
          tmp->entry.rbe_color = 0;
#line 195
          while (1) {
#line 195
            parent->entry.rbe_color = 0;
#line 195
            gparent->entry.rbe_color = 1;
#line 195
            break;
          }
#line 195
          elm = gparent;
#line 195
          continue;
        }
      }
#line 195
      if ((unsigned long )parent->entry.rbe_left == (unsigned long )elm) {
#line 195
        while (1) {
#line 195
          tmp = parent->entry.rbe_left;
#line 195
          tmp___4 = tmp->entry.rbe_right;
#line 195
          parent->entry.rbe_left = tmp___4;
#line 195
          if ((unsigned long )tmp___4 != (unsigned long )((void *)0)) {
#line 195
            (tmp->entry.rbe_right)->entry.rbe_parent = parent;
          }
#line 195
          while (1) {
#line 195
            break;
          }
#line 195
          tmp___5 = parent->entry.rbe_parent;
#line 195
          tmp->entry.rbe_parent = tmp___5;
#line 195
          if ((unsigned long )tmp___5 != (unsigned long )((void *)0)) {
#line 195
            if ((unsigned long )parent == (unsigned long )(parent->entry.rbe_parent)->entry.rbe_left) {
#line 195
              (parent->entry.rbe_parent)->entry.rbe_left = tmp;
            } else {
#line 195
              (parent->entry.rbe_parent)->entry.rbe_right = tmp;
            }
          } else {
#line 195
            head->rbh_root = tmp;
          }
#line 195
          tmp->entry.rbe_right = parent;
#line 195
          parent->entry.rbe_parent = tmp;
#line 195
          while (1) {
#line 195
            break;
          }
#line 195
          if (tmp->entry.rbe_parent) {
#line 195
            while (1) {
#line 195
              break;
            }
          }
#line 195
          break;
        }
#line 195
        tmp = parent;
#line 195
        parent = elm;
#line 195
        elm = tmp;
      }
#line 195
      while (1) {
#line 195
        parent->entry.rbe_color = 0;
#line 195
        gparent->entry.rbe_color = 1;
#line 195
        break;
      }
#line 195
      while (1) {
#line 195
        tmp = gparent->entry.rbe_right;
#line 195
        tmp___6 = tmp->entry.rbe_left;
#line 195
        gparent->entry.rbe_right = tmp___6;
#line 195
        if ((unsigned long )tmp___6 != (unsigned long )((void *)0)) {
#line 195
          (tmp->entry.rbe_left)->entry.rbe_parent = gparent;
        }
#line 195
        while (1) {
#line 195
          break;
        }
#line 195
        tmp___7 = gparent->entry.rbe_parent;
#line 195
        tmp->entry.rbe_parent = tmp___7;
#line 195
        if ((unsigned long )tmp___7 != (unsigned long )((void *)0)) {
#line 195
          if ((unsigned long )gparent == (unsigned long )(gparent->entry.rbe_parent)->entry.rbe_left) {
#line 195
            (gparent->entry.rbe_parent)->entry.rbe_left = tmp;
          } else {
#line 195
            (gparent->entry.rbe_parent)->entry.rbe_right = tmp;
          }
        } else {
#line 195
          head->rbh_root = tmp;
        }
#line 195
        tmp->entry.rbe_left = gparent;
#line 195
        gparent->entry.rbe_parent = tmp;
#line 195
        while (1) {
#line 195
          break;
        }
#line 195
        if (tmp->entry.rbe_parent) {
#line 195
          while (1) {
#line 195
            break;
          }
        }
#line 195
        break;
      }
    }
  }
#line 195
  (head->rbh_root)->entry.rbe_color = 0;
#line 195
  return;
}
}
#line 195 "tmux_uaf_5.c"
void poll_items_RB_REMOVE_COLOR(struct poll_items *head , struct poll_item *parent ,
                                struct poll_item *elm ) 
{ 
  struct poll_item *tmp ;
  struct poll_item *tmp___0 ;
  struct poll_item *tmp___1 ;
  struct poll_item *oleft ;
  struct poll_item *tmp___2 ;
  struct poll_item *tmp___3 ;
  struct poll_item *tmp___4 ;
  struct poll_item *tmp___5 ;
  struct poll_item *tmp___6 ;
  struct poll_item *tmp___7 ;
  struct poll_item *oright ;
  struct poll_item *tmp___8 ;
  struct poll_item *tmp___9 ;
  struct poll_item *tmp___10 ;
  struct poll_item *tmp___11 ;

  {
#line 195
  while (1) {
#line 195
    if ((unsigned long )elm == (unsigned long )((void *)0)) {
#line 195
      goto _L___5;
    } else
#line 195
    if (elm->entry.rbe_color == 0) {
      _L___5: /* CIL Label */ 
#line 195
      if (! ((unsigned long )elm != (unsigned long )head->rbh_root)) {
#line 195
        break;
      }
    } else {
#line 195
      break;
    }
#line 195
    if ((unsigned long )parent->entry.rbe_left == (unsigned long )elm) {
#line 195
      tmp = parent->entry.rbe_right;
#line 195
      if (tmp->entry.rbe_color == 1) {
#line 195
        while (1) {
#line 195
          tmp->entry.rbe_color = 0;
#line 195
          parent->entry.rbe_color = 1;
#line 195
          break;
        }
#line 195
        while (1) {
#line 195
          tmp = parent->entry.rbe_right;
#line 195
          tmp___0 = tmp->entry.rbe_left;
#line 195
          parent->entry.rbe_right = tmp___0;
#line 195
          if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 195
            (tmp->entry.rbe_left)->entry.rbe_parent = parent;
          }
#line 195
          while (1) {
#line 195
            break;
          }
#line 195
          tmp___1 = parent->entry.rbe_parent;
#line 195
          tmp->entry.rbe_parent = tmp___1;
#line 195
          if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
#line 195
            if ((unsigned long )parent == (unsigned long )(parent->entry.rbe_parent)->entry.rbe_left) {
#line 195
              (parent->entry.rbe_parent)->entry.rbe_left = tmp;
            } else {
#line 195
              (parent->entry.rbe_parent)->entry.rbe_right = tmp;
            }
          } else {
#line 195
            head->rbh_root = tmp;
          }
#line 195
          tmp->entry.rbe_left = parent;
#line 195
          parent->entry.rbe_parent = tmp;
#line 195
          while (1) {
#line 195
            break;
          }
#line 195
          if (tmp->entry.rbe_parent) {
#line 195
            while (1) {
#line 195
              break;
            }
          }
#line 195
          break;
        }
#line 195
        tmp = parent->entry.rbe_right;
      }
#line 195
      if ((unsigned long )tmp->entry.rbe_left == (unsigned long )((void *)0)) {
#line 195
        goto _L___1;
      } else
#line 195
      if ((tmp->entry.rbe_left)->entry.rbe_color == 0) {
        _L___1: /* CIL Label */ 
#line 195
        if ((unsigned long )tmp->entry.rbe_right == (unsigned long )((void *)0)) {
#line 195
          tmp->entry.rbe_color = 1;
#line 195
          elm = parent;
#line 195
          parent = elm->entry.rbe_parent;
        } else
#line 195
        if ((tmp->entry.rbe_right)->entry.rbe_color == 0) {
#line 195
          tmp->entry.rbe_color = 1;
#line 195
          elm = parent;
#line 195
          parent = elm->entry.rbe_parent;
        } else {
#line 195
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 195
        if ((unsigned long )tmp->entry.rbe_right == (unsigned long )((void *)0)) {
#line 195
          goto _L;
        } else
#line 195
        if ((tmp->entry.rbe_right)->entry.rbe_color == 0) {
          _L: /* CIL Label */ 
#line 195
          oleft = tmp->entry.rbe_left;
#line 195
          if ((unsigned long )oleft != (unsigned long )((void *)0)) {
#line 195
            oleft->entry.rbe_color = 0;
          }
#line 195
          tmp->entry.rbe_color = 1;
#line 195
          while (1) {
#line 195
            oleft = tmp->entry.rbe_left;
#line 195
            tmp___2 = oleft->entry.rbe_right;
#line 195
            tmp->entry.rbe_left = tmp___2;
#line 195
            if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
#line 195
              (oleft->entry.rbe_right)->entry.rbe_parent = tmp;
            }
#line 195
            while (1) {
#line 195
              break;
            }
#line 195
            tmp___3 = tmp->entry.rbe_parent;
#line 195
            oleft->entry.rbe_parent = tmp___3;
#line 195
            if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
#line 195
              if ((unsigned long )tmp == (unsigned long )(tmp->entry.rbe_parent)->entry.rbe_left) {
#line 195
                (tmp->entry.rbe_parent)->entry.rbe_left = oleft;
              } else {
#line 195
                (tmp->entry.rbe_parent)->entry.rbe_right = oleft;
              }
            } else {
#line 195
              head->rbh_root = oleft;
            }
#line 195
            oleft->entry.rbe_right = tmp;
#line 195
            tmp->entry.rbe_parent = oleft;
#line 195
            while (1) {
#line 195
              break;
            }
#line 195
            if (oleft->entry.rbe_parent) {
#line 195
              while (1) {
#line 195
                break;
              }
            }
#line 195
            break;
          }
#line 195
          tmp = parent->entry.rbe_right;
        }
#line 195
        tmp->entry.rbe_color = parent->entry.rbe_color;
#line 195
        parent->entry.rbe_color = 0;
#line 195
        if (tmp->entry.rbe_right) {
#line 195
          (tmp->entry.rbe_right)->entry.rbe_color = 0;
        }
#line 195
        while (1) {
#line 195
          tmp = parent->entry.rbe_right;
#line 195
          tmp___4 = tmp->entry.rbe_left;
#line 195
          parent->entry.rbe_right = tmp___4;
#line 195
          if ((unsigned long )tmp___4 != (unsigned long )((void *)0)) {
#line 195
            (tmp->entry.rbe_left)->entry.rbe_parent = parent;
          }
#line 195
          while (1) {
#line 195
            break;
          }
#line 195
          tmp___5 = parent->entry.rbe_parent;
#line 195
          tmp->entry.rbe_parent = tmp___5;
#line 195
          if ((unsigned long )tmp___5 != (unsigned long )((void *)0)) {
#line 195
            if ((unsigned long )parent == (unsigned long )(parent->entry.rbe_parent)->entry.rbe_left) {
#line 195
              (parent->entry.rbe_parent)->entry.rbe_left = tmp;
            } else {
#line 195
              (parent->entry.rbe_parent)->entry.rbe_right = tmp;
            }
          } else {
#line 195
            head->rbh_root = tmp;
          }
#line 195
          tmp->entry.rbe_left = parent;
#line 195
          parent->entry.rbe_parent = tmp;
#line 195
          while (1) {
#line 195
            break;
          }
#line 195
          if (tmp->entry.rbe_parent) {
#line 195
            while (1) {
#line 195
              break;
            }
          }
#line 195
          break;
        }
#line 195
        elm = head->rbh_root;
#line 195
        break;
      }
    } else {
#line 195
      tmp = parent->entry.rbe_left;
#line 195
      if (tmp->entry.rbe_color == 1) {
#line 195
        while (1) {
#line 195
          tmp->entry.rbe_color = 0;
#line 195
          parent->entry.rbe_color = 1;
#line 195
          break;
        }
#line 195
        while (1) {
#line 195
          tmp = parent->entry.rbe_left;
#line 195
          tmp___6 = tmp->entry.rbe_right;
#line 195
          parent->entry.rbe_left = tmp___6;
#line 195
          if ((unsigned long )tmp___6 != (unsigned long )((void *)0)) {
#line 195
            (tmp->entry.rbe_right)->entry.rbe_parent = parent;
          }
#line 195
          while (1) {
#line 195
            break;
          }
#line 195
          tmp___7 = parent->entry.rbe_parent;
#line 195
          tmp->entry.rbe_parent = tmp___7;
#line 195
          if ((unsigned long )tmp___7 != (unsigned long )((void *)0)) {
#line 195
            if ((unsigned long )parent == (unsigned long )(parent->entry.rbe_parent)->entry.rbe_left) {
#line 195
              (parent->entry.rbe_parent)->entry.rbe_left = tmp;
            } else {
#line 195
              (parent->entry.rbe_parent)->entry.rbe_right = tmp;
            }
          } else {
#line 195
            head->rbh_root = tmp;
          }
#line 195
          tmp->entry.rbe_right = parent;
#line 195
          parent->entry.rbe_parent = tmp;
#line 195
          while (1) {
#line 195
            break;
          }
#line 195
          if (tmp->entry.rbe_parent) {
#line 195
            while (1) {
#line 195
              break;
            }
          }
#line 195
          break;
        }
#line 195
        tmp = parent->entry.rbe_left;
      }
#line 195
      if ((unsigned long )tmp->entry.rbe_left == (unsigned long )((void *)0)) {
#line 195
        goto _L___4;
      } else
#line 195
      if ((tmp->entry.rbe_left)->entry.rbe_color == 0) {
        _L___4: /* CIL Label */ 
#line 195
        if ((unsigned long )tmp->entry.rbe_right == (unsigned long )((void *)0)) {
#line 195
          tmp->entry.rbe_color = 1;
#line 195
          elm = parent;
#line 195
          parent = elm->entry.rbe_parent;
        } else
#line 195
        if ((tmp->entry.rbe_right)->entry.rbe_color == 0) {
#line 195
          tmp->entry.rbe_color = 1;
#line 195
          elm = parent;
#line 195
          parent = elm->entry.rbe_parent;
        } else {
#line 195
          goto _L___3;
        }
      } else {
        _L___3: /* CIL Label */ 
#line 195
        if ((unsigned long )tmp->entry.rbe_left == (unsigned long )((void *)0)) {
#line 195
          goto _L___2;
        } else
#line 195
        if ((tmp->entry.rbe_left)->entry.rbe_color == 0) {
          _L___2: /* CIL Label */ 
#line 195
          oright = tmp->entry.rbe_right;
#line 195
          if ((unsigned long )oright != (unsigned long )((void *)0)) {
#line 195
            oright->entry.rbe_color = 0;
          }
#line 195
          tmp->entry.rbe_color = 1;
#line 195
          while (1) {
#line 195
            oright = tmp->entry.rbe_right;
#line 195
            tmp___8 = oright->entry.rbe_left;
#line 195
            tmp->entry.rbe_right = tmp___8;
#line 195
            if ((unsigned long )tmp___8 != (unsigned long )((void *)0)) {
#line 195
              (oright->entry.rbe_left)->entry.rbe_parent = tmp;
            }
#line 195
            while (1) {
#line 195
              break;
            }
#line 195
            tmp___9 = tmp->entry.rbe_parent;
#line 195
            oright->entry.rbe_parent = tmp___9;
#line 195
            if ((unsigned long )tmp___9 != (unsigned long )((void *)0)) {
#line 195
              if ((unsigned long )tmp == (unsigned long )(tmp->entry.rbe_parent)->entry.rbe_left) {
#line 195
                (tmp->entry.rbe_parent)->entry.rbe_left = oright;
              } else {
#line 195
                (tmp->entry.rbe_parent)->entry.rbe_right = oright;
              }
            } else {
#line 195
              head->rbh_root = oright;
            }
#line 195
            oright->entry.rbe_left = tmp;
#line 195
            tmp->entry.rbe_parent = oright;
#line 195
            while (1) {
#line 195
              break;
            }
#line 195
            if (oright->entry.rbe_parent) {
#line 195
              while (1) {
#line 195
                break;
              }
            }
#line 195
            break;
          }
#line 195
          tmp = parent->entry.rbe_left;
        }
#line 195
        tmp->entry.rbe_color = parent->entry.rbe_color;
#line 195
        parent->entry.rbe_color = 0;
#line 195
        if (tmp->entry.rbe_left) {
#line 195
          (tmp->entry.rbe_left)->entry.rbe_color = 0;
        }
#line 195
        while (1) {
#line 195
          tmp = parent->entry.rbe_left;
#line 195
          tmp___10 = tmp->entry.rbe_right;
#line 195
          parent->entry.rbe_left = tmp___10;
#line 195
          if ((unsigned long )tmp___10 != (unsigned long )((void *)0)) {
#line 195
            (tmp->entry.rbe_right)->entry.rbe_parent = parent;
          }
#line 195
          while (1) {
#line 195
            break;
          }
#line 195
          tmp___11 = parent->entry.rbe_parent;
#line 195
          tmp->entry.rbe_parent = tmp___11;
#line 195
          if ((unsigned long )tmp___11 != (unsigned long )((void *)0)) {
#line 195
            if ((unsigned long )parent == (unsigned long )(parent->entry.rbe_parent)->entry.rbe_left) {
#line 195
              (parent->entry.rbe_parent)->entry.rbe_left = tmp;
            } else {
#line 195
              (parent->entry.rbe_parent)->entry.rbe_right = tmp;
            }
          } else {
#line 195
            head->rbh_root = tmp;
          }
#line 195
          tmp->entry.rbe_right = parent;
#line 195
          parent->entry.rbe_parent = tmp;
#line 195
          while (1) {
#line 195
            break;
          }
#line 195
          if (tmp->entry.rbe_parent) {
#line 195
            while (1) {
#line 195
              break;
            }
          }
#line 195
          break;
        }
#line 195
        elm = head->rbh_root;
#line 195
        break;
      }
    }
  }
#line 195
  if (elm) {
#line 195
    elm->entry.rbe_color = 0;
  }
#line 195
  return;
}
}
#line 195 "tmux_uaf_5.c"
struct poll_item *poll_items_RB_INSERT(struct poll_items *head , struct poll_item *elm ) 
{ 
  struct poll_item *tmp ;
  struct poll_item *parent ;
  int comp ;
  struct poll_item *tmp___0 ;

  {
#line 195
  parent = (struct poll_item *)((void *)0);
#line 195
  comp = 0;
#line 195
  tmp = head->rbh_root;
#line 195
  while (tmp) {
#line 195
    parent = tmp;
#line 195
    comp = server_poll_cmp(elm, parent);
#line 195
    if (comp < 0) {
#line 195
      tmp = tmp->entry.rbe_left;
    } else
#line 195
    if (comp > 0) {
#line 195
      tmp = tmp->entry.rbe_right;
    } else {
#line 195
      return (tmp);
    }
  }
#line 195
  while (1) {
#line 195
    elm->entry.rbe_parent = parent;
#line 195
    tmp___0 = (struct poll_item *)((void *)0);
#line 195
    elm->entry.rbe_right = tmp___0;
#line 195
    elm->entry.rbe_left = tmp___0;
#line 195
    elm->entry.rbe_color = 1;
#line 195
    break;
  }
#line 195
  if ((unsigned long )parent != (unsigned long )((void *)0)) {
#line 195
    if (comp < 0) {
#line 195
      parent->entry.rbe_left = elm;
    } else {
#line 195
      parent->entry.rbe_right = elm;
    }
#line 195
    while (1) {
#line 195
      break;
    }
  } else {
#line 195
    head->rbh_root = elm;
  }
#line 195
  poll_items_RB_INSERT_COLOR(head, elm);
#line 195
  return ((struct poll_item *)((void *)0));
}
}
#line 195 "tmux_uaf_5.c"
struct poll_item *poll_items_RB_REMOVE(struct poll_items *head , struct poll_item *elm ) 
{ 
  struct poll_item *child ;
  struct poll_item *parent ;
  struct poll_item *old ;
  int color ;
  struct poll_item *left ;

  {
#line 195
  old = elm;
#line 195
  if ((unsigned long )elm->entry.rbe_left == (unsigned long )((void *)0)) {
#line 195
    child = elm->entry.rbe_right;
  } else
#line 195
  if ((unsigned long )elm->entry.rbe_right == (unsigned long )((void *)0)) {
#line 195
    child = elm->entry.rbe_left;
  } else {
#line 195
    elm = elm->entry.rbe_right;
#line 195
    while (1) {
#line 195
      left = elm->entry.rbe_left;
#line 195
      if (! ((unsigned long )left != (unsigned long )((void *)0))) {
#line 195
        break;
      }
#line 195
      elm = left;
    }
#line 195
    child = elm->entry.rbe_right;
#line 195
    parent = elm->entry.rbe_parent;
#line 195
    color = elm->entry.rbe_color;
#line 195
    if (child) {
#line 195
      child->entry.rbe_parent = parent;
    }
#line 195
    if (parent) {
#line 195
      if ((unsigned long )parent->entry.rbe_left == (unsigned long )elm) {
#line 195
        parent->entry.rbe_left = child;
      } else {
#line 195
        parent->entry.rbe_right = child;
      }
#line 195
      while (1) {
#line 195
        break;
      }
    } else {
#line 195
      head->rbh_root = child;
    }
#line 195
    if ((unsigned long )elm->entry.rbe_parent == (unsigned long )old) {
#line 195
      parent = elm;
    }
#line 195
    elm->entry = old->entry;
#line 195
    if (old->entry.rbe_parent) {
#line 195
      if ((unsigned long )(old->entry.rbe_parent)->entry.rbe_left == (unsigned long )old) {
#line 195
        (old->entry.rbe_parent)->entry.rbe_left = elm;
      } else {
#line 195
        (old->entry.rbe_parent)->entry.rbe_right = elm;
      }
#line 195
      while (1) {
#line 195
        break;
      }
    } else {
#line 195
      head->rbh_root = elm;
    }
#line 195
    (old->entry.rbe_left)->entry.rbe_parent = elm;
#line 195
    if (old->entry.rbe_right) {
#line 195
      (old->entry.rbe_right)->entry.rbe_parent = elm;
    }
#line 195
    if (parent) {
#line 195
      left = parent;
#line 195
      while (1) {
#line 195
        while (1) {
#line 195
          break;
        }
#line 195
        left = left->entry.rbe_parent;
#line 195
        if (! ((unsigned long )left != (unsigned long )((void *)0))) {
#line 195
          break;
        }
      }
    }
#line 195
    goto color;
  }
#line 195
  parent = elm->entry.rbe_parent;
#line 195
  color = elm->entry.rbe_color;
#line 195
  if (child) {
#line 195
    child->entry.rbe_parent = parent;
  }
#line 195
  if (parent) {
#line 195
    if ((unsigned long )parent->entry.rbe_left == (unsigned long )elm) {
#line 195
      parent->entry.rbe_left = child;
    } else {
#line 195
      parent->entry.rbe_right = child;
    }
#line 195
    while (1) {
#line 195
      break;
    }
  } else {
#line 195
    head->rbh_root = child;
  }
  color: 
#line 195
  if (color == 0) {
#line 195
    poll_items_RB_REMOVE_COLOR(head, parent, child);
  }
#line 195
  return (old);
}
}
#line 195 "tmux_uaf_5.c"
struct poll_item *poll_items_RB_FIND(struct poll_items *head , struct poll_item *elm ) 
{ 
  struct poll_item *tmp ;
  int comp ;

  {
#line 195
  tmp = head->rbh_root;
#line 195
  while (tmp) {
#line 195
    comp = server_poll_cmp(elm, tmp);
#line 195
    if (comp < 0) {
#line 195
      tmp = tmp->entry.rbe_left;
    } else
#line 195
    if (comp > 0) {
#line 195
      tmp = tmp->entry.rbe_right;
    } else {
#line 195
      return (tmp);
    }
  }
#line 195
  return ((struct poll_item *)((void *)0));
}
}
#line 195 "tmux_uaf_5.c"
struct poll_item *poll_items_RB_NFIND(struct poll_items *head , struct poll_item *elm ) 
{ 
  struct poll_item *tmp ;
  struct poll_item *res ;
  int comp ;

  {
#line 195
  tmp = head->rbh_root;
#line 195
  res = (struct poll_item *)((void *)0);
#line 195
  while (tmp) {
#line 195
    comp = server_poll_cmp(elm, tmp);
#line 195
    if (comp < 0) {
#line 195
      res = tmp;
#line 195
      tmp = tmp->entry.rbe_left;
    } else
#line 195
    if (comp > 0) {
#line 195
      tmp = tmp->entry.rbe_right;
    } else {
#line 195
      return (tmp);
    }
  }
#line 195
  return (res);
}
}
#line 195 "tmux_uaf_5.c"
struct poll_item *poll_items_RB_NEXT(struct poll_item *elm ) 
{ 


  {
#line 195
  if (elm->entry.rbe_right) {
#line 195
    elm = elm->entry.rbe_right;
#line 195
    while (elm->entry.rbe_left) {
#line 195
      elm = elm->entry.rbe_left;
    }
  } else
#line 195
  if (elm->entry.rbe_parent) {
#line 195
    if ((unsigned long )elm == (unsigned long )(elm->entry.rbe_parent)->entry.rbe_left) {
#line 195
      elm = elm->entry.rbe_parent;
    } else {
#line 195
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 195
    while (1) {
#line 195
      if (elm->entry.rbe_parent) {
#line 195
        if (! ((unsigned long )elm == (unsigned long )(elm->entry.rbe_parent)->entry.rbe_right)) {
#line 195
          break;
        }
      } else {
#line 195
        break;
      }
#line 195
      elm = elm->entry.rbe_parent;
    }
#line 195
    elm = elm->entry.rbe_parent;
  }
#line 195
  return (elm);
}
}
#line 195 "tmux_uaf_5.c"
struct poll_item *poll_items_RB_PREV(struct poll_item *elm ) 
{ 


  {
#line 195
  if (elm->entry.rbe_left) {
#line 195
    elm = elm->entry.rbe_left;
#line 195
    while (elm->entry.rbe_right) {
#line 195
      elm = elm->entry.rbe_right;
    }
  } else
#line 195
  if (elm->entry.rbe_parent) {
#line 195
    if ((unsigned long )elm == (unsigned long )(elm->entry.rbe_parent)->entry.rbe_right) {
#line 195
      elm = elm->entry.rbe_parent;
    } else {
#line 195
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 195
    while (1) {
#line 195
      if (elm->entry.rbe_parent) {
#line 195
        if (! ((unsigned long )elm == (unsigned long )(elm->entry.rbe_parent)->entry.rbe_left)) {
#line 195
          break;
        }
      } else {
#line 195
        break;
      }
#line 195
      elm = elm->entry.rbe_parent;
    }
#line 195
    elm = elm->entry.rbe_parent;
  }
#line 195
  return (elm);
}
}
#line 195 "tmux_uaf_5.c"
struct poll_item *poll_items_RB_MINMAX(struct poll_items *head , int val ) 
{ 
  struct poll_item *tmp ;
  struct poll_item *parent ;

  {
#line 195
  tmp = head->rbh_root;
#line 195
  parent = (struct poll_item *)((void *)0);
#line 195
  while (tmp) {
#line 195
    parent = tmp;
#line 195
    if (val < 0) {
#line 195
      tmp = tmp->entry.rbe_left;
    } else {
#line 195
      tmp = tmp->entry.rbe_right;
    }
  }
#line 195
  return (parent);
}
}
#line 198 "tmux_uaf_5.c"
void *xrealloc(void *oldptr , size_t nmemb , size_t size ) 
{ 
  size_t newsize ;
  void *newptr ;

  {
#line 201
  newsize = nmemb * size;
#line 204
  if (newsize == 0UL) {
#line 205
    printf((char const   * __restrict  )"zero size%s\n", "");
#line 205
    exit(1);
  }
#line 206
  if ((size_t )(1 << 30) / nmemb < size) {
#line 207
    printf((char const   * __restrict  )"nmemb * size > SIZE_MAX%s\n", "");
#line 207
    exit(1);
  }
#line 208
  newptr = realloc(oldptr, newsize);
#line 208
  if ((unsigned long )newptr == (unsigned long )((void *)0)) {
#line 209
    printf((char const   * __restrict  )"xrealloc failed%s\n", "");
#line 209
    exit(1);
  }
#line 211
  return (newptr);
}
}
#line 215 "tmux_uaf_5.c"
struct buffer *buffer_create(size_t size ) 
{ 
  struct buffer *b ;
  void *tmp ;

  {
#line 220
  if (size == 0UL) {
#line 221
    printf((char const   * __restrict  )"zero size%s\n", "");
#line 221
    exit(1);
  }
#line 223
  tmp = malloc(sizeof(*b));
#line 223
  b = (struct buffer *)tmp;
#line 225
  b->space = size;
#line 227
  return (b);
}
}
#line 231 "tmux_uaf_5.c"
void buffer_destroy(struct buffer *b ) 
{ 


  {
#line 234
  free((void *)b);
#line 235
  return;
}
}
#line 238 "tmux_uaf_5.c"
void buffer_add(struct buffer *b , size_t size ) 
{ 


  {
#line 241
  if (size == 0UL) {
#line 242
    printf((char const   * __restrict  )"zero size%s\n", "");
#line 242
    exit(1);
  }
#line 243
  if (size > b->space - b->size) {
#line 244
    printf((char const   * __restrict  )"overflow%s\n", "");
#line 244
    exit(1);
  }
#line 246
  b->size += size;
#line 247
  return;
}
}
#line 250 "tmux_uaf_5.c"
void buffer_ensure(struct buffer *b , size_t size ) 
{ 


  {
#line 253
  if (size == 0UL) {
#line 254
    printf((char const   * __restrict  )"zero size%s\n", "");
#line 254
    exit(1);
  }
#line 256
  if ((size_t )(1 << 30) - b->size < size) {
#line 257
    printf((char const   * __restrict  )"size too big%s\n", "");
#line 257
    exit(1);
  }
#line 258
  return;
}
}
#line 262 "tmux_uaf_5.c"
void buffer_write(struct buffer *b , void const   *data , size_t size ) 
{ 


  {
#line 265
  buffer_ensure(b, size);
#line 266
  buffer_add(b, size);
#line 267
  return;
}
}
#line 271 "tmux_uaf_5.c"
int buffer_poll(int fd , int events , struct buffer *in , struct buffer *out ) 
{ 
  ssize_t n ;
  int tmp ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 274
  tmp = rand();
#line 274
  n = (ssize_t )(tmp % 2 + 1);
#line 276
  if ((unsigned long )in != (unsigned long )((void *)0)) {
#line 277
    buffer_ensure(in, (size_t )8192);
#line 278
    buffer_add(in, (size_t )n);
  }
#line 281
  tmp___2 = rand();
#line 281
  if (tmp___2 % 2 == 1) {
#line 281
    tmp___1 = 1;
  } else {
#line 281
    tmp___1 = 0;
  }
#line 281
  if (tmp___1) {
#line 282
    return (-1);
  }
#line 284
  return (0);
}
}
#line 286 "tmux_uaf_5.c"
int server_poll_cmp(struct poll_item *pitem1 , struct poll_item *pitem2 ) 
{ 


  {
#line 289
  return (pitem1->fd - pitem2->fd);
}
}
#line 292 "tmux_uaf_5.c"
void tty_close(struct tty *tty ) 
{ 


  {
#line 295
  if (tty->flags & 32) {
#line 296
    buffer_destroy(tty->in);
#line 297
    buffer_destroy(tty->out);
#line 298
    tty->flags &= -33;
  }
#line 300
  return;
}
}
#line 303 "tmux_uaf_5.c"
void tty_free(struct tty *tty ) 
{ 


  {
#line 306
  tty_close(tty);
#line 307
  return;
}
}
#line 311 "tmux_uaf_5.c"
int server_should_shutdown(void) 
{ 
  u_int___0 i ;

  {
#line 316
  i = (u_int___0 )0;
#line 316
  while (i < clients.num) {
#line 317
    if ((unsigned long )*(clients.list + i) != (unsigned long )((void *)0)) {
#line 318
      return (0);
    }
#line 316
    i ++;
  }
#line 320
  return (1);
}
}
#line 324 "tmux_uaf_5.c"
void server_clean_dead(void) 
{ 
  struct client *c ;
  u_int___0 i ;

  {
#line 330
  i = (u_int___0 )0;
#line 330
  while (i < dead_clients.num) {
#line 331
    c = *(dead_clients.list + i);
#line 332
    if ((unsigned long )c == (unsigned long )((void *)0)) {
#line 333
      goto __Cont;
    } else
#line 332
    if (c->references != 0) {
#line 333
      goto __Cont;
    }
#line 334
    while (1) {
#line 334
      *(dead_clients.list + i) = (struct client *)((void *)0);
#line 334
      break;
    }
#line 335
    free((void *)c);
    __Cont: /* CIL Label */ 
#line 330
    i ++;
  }
#line 337
  return;
}
}
#line 340 "tmux_uaf_5.c"
void server_client_create(int fd ) 
{ 
  struct client *c ;
  u_int___0 i ;
  void *tmp ;
  int tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;

  {
#line 346
  tmp = malloc(sizeof(*c));
#line 346
  c = (struct client *)tmp;
#line 347
  c->references = 0;
#line 349
  c->ibuf.fd = fd;
#line 350
  tmp___5 = rand();
#line 350
  if (tmp___5 % 2 == 1) {
#line 350
    tmp___4 = 1;
  } else {
#line 350
    tmp___4 = 0;
  }
#line 350
  if (tmp___4) {
#line 350
    c->tty.fd = 0;
  } else {
#line 350
    c->tty.fd = -1;
  }
#line 351
  c->title = (char *)((void *)0);
#line 353
  c->session = (struct session *)((void *)0);
#line 354
  c->tty.sx = (u_int___0 )80;
#line 355
  c->tty.sy = (u_int___0 )24;
#line 356
  c->tty.in = buffer_create((size_t )8192);
#line 357
  c->tty.out = buffer_create((size_t )8192);
#line 358
  c->tty.flags = 32;
#line 359
  c->flags |= 1;
#line 361
  c->message_string = (char *)((void *)0);
#line 363
  c->prompt_string = (char *)((void *)0);
#line 364
  c->prompt_buffer = (char *)((void *)0);
#line 365
  c->prompt_index = (size_t )0;
#line 367
  printf((char const   * __restrict  )"new client %d\n", fd);
#line 368
  i = (u_int___0 )0;
#line 368
  while (i < clients.num) {
#line 369
    if ((unsigned long )*(clients.list + i) == (unsigned long )((void *)0)) {
#line 370
      while (1) {
#line 370
        *(clients.list + i) = c;
#line 370
        break;
      }
#line 371
      return;
    }
#line 368
    i ++;
  }
#line 374
  while (1) {
#line 374
    while (1) {
#line 374
      if ((u_int___0 )((1 << 30) - 1) < clients.num) {
#line 374
        printf((char const   * __restrict  )"number too big%s", "");
#line 374
        exit(1);
      }
#line 374
      if ((unsigned long )((u_int___0 )(1 << 30) / (clients.num + 1U)) < sizeof(*(clients.list))) {
#line 374
        printf((char const   * __restrict  )"size too big%s", "");
#line 374
        exit(1);
      }
#line 374
      if (clients.space == 0UL) {
#line 374
        clients.space = 10UL * sizeof(*(clients.list));
#line 374
        tmp___6 = xrealloc((void *)clients.list, (size_t )1, clients.space);
#line 374
        clients.list = (struct client **)tmp___6;
      }
#line 374
      while (clients.space <= (unsigned long )(clients.num + 1U) * sizeof(*(clients.list))) {
#line 374
        tmp___7 = xrealloc((void *)clients.list, (size_t )2, clients.space);
#line 374
        clients.list = (struct client **)tmp___7;
#line 374
        clients.space *= 2UL;
      }
#line 374
      break;
    }
#line 374
    *(clients.list + clients.num) = c;
#line 374
    (clients.num) ++;
#line 374
    break;
  }
#line 375
  return;
}
}
#line 379 "tmux_uaf_5.c"
void server_client_lost(struct client *c ) 
{ 
  u_int___0 i ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 384
  i = (u_int___0 )0;
#line 384
  while (i < clients.num) {
#line 385
    if ((unsigned long )*(clients.list + i) == (unsigned long )c) {
#line 386
      while (1) {
#line 386
        *(clients.list + i) = (struct client *)((void *)0);
#line 386
        break;
      }
    }
#line 384
    i ++;
  }
#line 393
  if (c->flags & 1) {
#line 394
    tty_free(& c->tty);
  }
#line 396
  i = (u_int___0 )0;
#line 396
  while (i < dead_clients.num) {
#line 397
    if ((unsigned long )*(dead_clients.list + i) == (unsigned long )((void *)0)) {
#line 398
      while (1) {
#line 398
        *(dead_clients.list + i) = c;
#line 398
        break;
      }
#line 399
      break;
    }
#line 396
    i ++;
  }
#line 402
  if (i == dead_clients.num) {
#line 403
    while (1) {
#line 403
      while (1) {
#line 403
        if ((u_int___0 )((1 << 30) - 1) < dead_clients.num) {
#line 403
          printf((char const   * __restrict  )"number too big%s", "");
#line 403
          exit(1);
        }
#line 403
        if ((unsigned long )((u_int___0 )(1 << 30) / (dead_clients.num + 1U)) < sizeof(*(dead_clients.list))) {
#line 403
          printf((char const   * __restrict  )"size too big%s", "");
#line 403
          exit(1);
        }
#line 403
        if (dead_clients.space == 0UL) {
#line 403
          dead_clients.space = 10UL * sizeof(*(dead_clients.list));
#line 403
          tmp = xrealloc((void *)dead_clients.list, (size_t )1, dead_clients.space);
#line 403
          dead_clients.list = (struct client **)tmp;
        }
#line 403
        while (dead_clients.space <= (unsigned long )(dead_clients.num + 1U) * sizeof(*(dead_clients.list))) {
#line 403
          tmp___0 = xrealloc((void *)dead_clients.list, (size_t )2, dead_clients.space);
#line 403
          dead_clients.list = (struct client **)tmp___0;
#line 403
          dead_clients.space *= 2UL;
        }
#line 403
        break;
      }
#line 403
      *(dead_clients.list + dead_clients.num) = c;
#line 403
      (dead_clients.num) ++;
#line 403
      break;
    }
  }
#line 404
  c->flags |= 512;
#line 405
  return;
}
}
#line 406 "tmux_uaf_5.c"
void server_poll_reset(void) 
{ 
  struct poll_item *pitem ;

  {
#line 411
  while (! ((unsigned long )poll_items.rbh_root == (unsigned long )((void *)0))) {
#line 412
    pitem = poll_items.rbh_root;
#line 413
    poll_items_RB_REMOVE(& poll_items, pitem);
#line 414
    free((void *)pitem);
  }
#line 416
  return;
}
}
#line 418 "tmux_uaf_5.c"
struct poll_item *server_poll_lookup(int fd ) 
{ 
  struct poll_item pitem ;
  struct poll_item *tmp ;

  {
#line 423
  pitem.fd = fd;
#line 424
  tmp = poll_items_RB_FIND(& poll_items, & pitem);
#line 424
  return (tmp);
}
}
#line 427 "tmux_uaf_5.c"
struct pollfd *server_poll_flatten(int *nfds ) 
{ 
  struct poll_item *pitem ;
  struct pollfd *pfds ;
  void *tmp ;

  {
#line 433
  pfds = (struct pollfd *)((void *)0);
#line 434
  *nfds = 0;
#line 435
  pitem = poll_items_RB_MINMAX(& poll_items, -1);
#line 435
  while ((unsigned long )pitem != (unsigned long )((void *)0)) {
#line 436
    tmp = xrealloc((void *)pfds, (size_t )(*nfds + 1), sizeof(*pfds));
#line 436
    pfds = (struct pollfd *)tmp;
#line 437
    (pfds + *nfds)->fd = pitem->fd;
#line 438
    (pfds + *nfds)->events = pitem->events;
#line 439
    (*nfds) ++;
#line 435
    pitem = poll_items_RB_NEXT(pitem);
  }
#line 441
  return (pfds);
}
}
#line 445 "tmux_uaf_5.c"
void server_callback(int fd , int events , void *data ) 
{ 


  {
#line 448
  srv_fd ++;
#line 448
  server_client_create(srv_fd);
#line 449
  return;
}
}
#line 451 "tmux_uaf_5.c"
void server_poll_dispatch(struct pollfd *pfds , int nfds ) 
{ 
  struct poll_item *pitem ;
  struct pollfd *pfd ;

  {
#line 457
  while (nfds > 0) {
#line 458
    nfds --;
#line 458
    pfd = pfds + nfds;
#line 459
    pitem = server_poll_lookup(pfd->fd);
#line 460
    (*(pitem->fn))(pitem->fd, pfd->events, pitem->data);
  }
#line 462
  free((void *)pfds);
#line 463
  return;
}
}
#line 465 "tmux_uaf_5.c"
void server_poll_add(int fd , int events , void (*fn)(int  , int  , void * ) , void *data ) 
{ 
  struct poll_item *pitem ;
  void *tmp ;

  {
#line 470
  tmp = malloc(sizeof(*pitem));
#line 470
  pitem = (struct poll_item *)tmp;
#line 471
  pitem->fd = fd;
#line 472
  pitem->events = events;
#line 474
  pitem->fn = fn;
#line 475
  pitem->data = data;
#line 477
  poll_items_RB_INSERT(& poll_items, pitem);
#line 478
  return;
}
}
#line 481 "tmux_uaf_5.c"
void server_client_callback(int fd , int events , void *data ) 
{ 
  struct client *c ;
  int tmp ;

  {
#line 484
  c = (struct client *)data;
#line 490
  if (c->flags & 128) {
#line 491
    goto client_lost;
  }
#line 494
  if (c->flags & 64) {
#line 495
    return;
  }
#line 497
  printf((char const   * __restrict  )"client : %d is used\n", c->ibuf.fd);
#line 498
  tmp = buffer_poll(fd, events, c->tty.in, c->tty.out);
#line 498
  if (tmp != 0) {
#line 499
    goto client_lost;
  }
#line 501
  return;
  client_lost: 
#line 504
  printf((char const   * __restrict  )"client : %d is lost\n", c->ibuf.fd);
#line 505
  server_client_lost(c);
#line 506
  return;
}
}
#line 509 "tmux_uaf_5.c"
void server_fill_clients(void) 
{ 
  struct client *c ;
  u_int___0 i ;
  int events ;

  {
#line 516
  i = (u_int___0 )0;
#line 516
  while (i < clients.num) {
#line 517
    c = *(clients.list + i);
#line 519
    if ((unsigned long )c != (unsigned long )((void *)0)) {
#line 520
      events = 0;
#line 521
      if (! (c->flags & 128)) {
#line 522
        events |= 1;
      }
#line 523
      if (c->ibuf.fd < 0) {
#line 524
        events |= 2;
      }
#line 525
      server_poll_add(c->ibuf.fd, events, & server_client_callback, (void *)c);
    }
#line 529
    if ((unsigned long )c != (unsigned long )((void *)0)) {
#line 529
      if (! (c->flags & 64)) {
#line 529
        if (c->tty.fd != -1) {
#line 531
          events = 1;
#line 532
          if ((c->tty.out)->size > 0UL) {
#line 533
            events |= 2;
          }
#line 534
          server_poll_add(c->tty.fd, events, & server_client_callback, (void *)c);
        }
      }
    }
#line 516
    i ++;
  }
#line 538
  return;
}
}
#line 545
extern int ( /* missing proto */  strlen)() ;
#line 541 "tmux_uaf_5.c"
void server_client_handle_data(struct client *c ) 
{ 
  char const   *s ;
  int tmp ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 544
  s = "handling data";
#line 545
  tmp = strlen(s);
#line 545
  buffer_write(c->tty.out, (void const   *)s, (size_t )tmp);
#line 546
  tmp___2 = rand();
#line 546
  if (tmp___2 % 2 == 1) {
#line 546
    tmp___1 = 1;
  } else {
#line 546
    tmp___1 = 0;
  }
#line 546
  if (tmp___1) {
#line 547
    c->flags |= 128;
  }
#line 548
  return;
}
}
#line 551 "tmux_uaf_5.c"
void server_client_loop(void) 
{ 
  struct client *c ;
  u_int___0 i ;

  {
#line 557
  i = (u_int___0 )0;
#line 557
  while (i < clients.num) {
#line 558
    c = *(clients.list + i);
#line 559
    if ((unsigned long )c == (unsigned long )((void *)0)) {
#line 560
      goto __Cont;
    }
#line 561
    server_client_handle_data(c);
    __Cont: /* CIL Label */ 
#line 557
    i ++;
  }
#line 563
  return;
}
}
#line 574
extern int ( /* missing proto */  time)() ;
#line 566 "tmux_uaf_5.c"
int main(int argc , char **argv ) 
{ 
  struct pollfd *pfds ;
  int srv_fd___0 ;
  int nfds ;
  u_int___0 i ;
  int tmp ;
  int tmp___0 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 574
  tmp = time((void *)0);
#line 574
  srand((unsigned int )tmp);
#line 575
  srv_fd___0 = 0;
#line 577
  while (1) {
#line 577
    clients.num = (u_int___0 )0;
#line 577
    clients.list = (struct client **)((void *)0);
#line 577
    clients.space = (size_t )0;
#line 577
    break;
  }
#line 578
  while (1) {
#line 578
    dead_clients.num = (u_int___0 )0;
#line 578
    dead_clients.list = (struct client **)((void *)0);
#line 578
    dead_clients.space = (size_t )0;
#line 578
    break;
  }
#line 580
  server_client_create(srv_fd___0);
#line 582
  pfds = (struct pollfd *)((void *)0);
#line 583
  while (1) {
#line 584
    tmp___0 = server_should_shutdown();
#line 584
    if (tmp___0) {
#line 585
      break;
    }
#line 587
    srv_fd___0 ++;
#line 590
    server_poll_reset();
#line 591
    server_poll_add(srv_fd___0, 1, & server_callback, (void *)0);
#line 593
    server_fill_clients();
#line 596
    pfds = server_poll_flatten(& nfds);
#line 598
    server_poll_dispatch(pfds, nfds);
#line 600
    server_client_loop();
#line 603
    server_clean_dead();
#line 605
    tmp___3 = rand();
#line 605
    if (tmp___3 % 2 == 1) {
#line 605
      tmp___2 = 1;
    } else {
#line 605
      tmp___2 = 0;
    }
#line 605
    if (tmp___2) {
#line 605
      break;
    }
  }
#line 607
  server_poll_reset();
#line 609
  i = (u_int___0 )0;
#line 609
  while (i < clients.num) {
#line 610
    if ((unsigned long )*(clients.list + i) != (unsigned long )((void *)0)) {
#line 611
      server_client_lost(*(clients.list + i));
    }
#line 609
    i ++;
  }
#line 613
  while (1) {
#line 613
    free((void *)clients.list);
#line 613
    while (1) {
#line 613
      clients.num = (u_int___0 )0;
#line 613
      clients.list = (struct client **)((void *)0);
#line 613
      clients.space = (size_t )0;
#line 613
      break;
    }
#line 613
    break;
  }
#line 615
  server_clean_dead();
#line 616
  return (0);
}
}
