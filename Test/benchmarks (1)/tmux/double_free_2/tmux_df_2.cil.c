/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

#line 216 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h"
typedef unsigned long size_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 192 "../stdio.h"
typedef unsigned short u_short___0;
#line 193 "../stdio.h"
typedef unsigned int u_int___0;
#line 204 "../stdio.h"
typedef unsigned char u_char___0;
#line 210 "../stdio.h"
typedef int pid_t___0;
#line 39 "../tmux.h"
typedef char bitstr_t;
#line 41 "../tmux.h"
struct event {

};
#line 42 "../tmux.h"
struct termios {

};
#line 48
struct args;
#line 48
struct args;
#line 49
struct client;
#line 49
struct client;
#line 50
struct cmd_find_state;
#line 50
struct cmd_find_state;
#line 51
struct cmdq_item;
#line 51
struct cmdq_item;
#line 52
struct cmdq_list;
#line 52
struct cmdq_list;
#line 53
struct environ;
#line 53
struct environ;
#line 54
struct format_job_tree;
#line 54
struct format_job_tree;
#line 55
struct input_ctx;
#line 55
struct input_ctx;
#line 57
struct mouse_event;
#line 57
struct mouse_event;
#line 58
struct options;
#line 58
struct options;
#line 59
struct options_entry;
#line 59
struct options_entry;
#line 60
struct session;
#line 60
struct session;
#line 61
struct tmuxpeer;
#line 61
struct tmuxpeer;
#line 138 "../tmux.h"
typedef unsigned long long key_code;
#line 470 "../tmux.h"
struct options_tree {
   struct options_entry *rbh_root ;
};
#line 470 "../tmux.h"
struct options {
   struct options_tree tree ;
   struct options *parent ;
};
#line 533 "../tmux.h"
struct utf8_data {
   u_char___0 data[9] ;
   u_char___0 have ;
   u_char___0 size ;
   u_char___0 width ;
};
#line 575 "../tmux.h"
struct grid_cell {
   u_char___0 flags ;
   u_short___0 attr ;
   int fg ;
   int bg ;
   struct utf8_data data ;
};
#line 582 "../tmux.h"
struct __anonstruct_data_27 {
   u_char___0 attr ;
   u_char___0 fg ;
   u_char___0 bg ;
   u_char___0 data ;
};
#line 582 "../tmux.h"
union __anonunion____missing_field_name_26 {
   u_int___0 offset ;
   struct __anonstruct_data_27 data ;
};
#line 582 "../tmux.h"
struct grid_cell_entry {
   u_char___0 flags ;
   union __anonunion____missing_field_name_26 __annonCompField1 ;
};
#line 596 "../tmux.h"
struct grid_line {
   u_int___0 cellused ;
   u_int___0 cellsize ;
   struct grid_cell_entry *celldata ;
   u_int___0 extdsize ;
   struct grid_cell *extddata ;
   int flags ;
};
#line 608 "../tmux.h"
struct grid {
   int flags ;
   u_int___0 sx ;
   u_int___0 sy ;
   u_int___0 hscrolled ;
   u_int___0 hsize ;
   u_int___0 hlimit ;
   struct grid_line *linedata ;
};
#line 623
struct cmd_list;
#line 636
struct bufferevent;
#line 661
enum __anonenum_lineflag_31 {
    LINE_SEL_NONE = 0,
    LINE_SEL_LEFT_RIGHT = 1,
    LINE_SEL_RIGHT_LEFT = 2
} ;
#line 661 "../tmux.h"
struct screen_sel {
   int flag ;
   int hidden ;
   int rectflag ;
   enum __anonenum_lineflag_31 lineflag ;
   int modekeys ;
   u_int___0 sx ;
   u_int___0 sy ;
   u_int___0 ex ;
   u_int___0 ey ;
   struct grid_cell cell ;
};
#line 684
struct screen_titles;
#line 684
struct screen_titles;
#line 685 "../tmux.h"
struct screen {
   char *title ;
   struct screen_titles *titles ;
   struct grid *grid ;
   u_int___0 cx ;
   u_int___0 cy ;
   u_int___0 cstyle ;
   char *ccolour ;
   u_int___0 rupper ;
   u_int___0 rlower ;
   int mode ;
   bitstr_t *tabs ;
   struct screen_sel sel ;
};
#line 710
struct window_pane;
#line 734 "../tmux.h"
struct window_mode {
   char const   *name ;
   struct screen *(*init)(struct window_pane * , struct cmd_find_state * , struct args * ) ;
   void (*free)(struct window_pane * ) ;
   void (*resize)(struct window_pane * , u_int___0  , u_int___0  ) ;
   void (*key)(struct window_pane * , struct client * , struct session * , key_code  ,
               struct mouse_event * ) ;
   char const   *(*key_table)(struct window_pane * ) ;
   void (*command)(struct window_pane * , struct client * , struct session * , struct args * ,
                   struct mouse_event * ) ;
};
#line 752
struct winlink;
#line 774
struct window;
#line 774
struct layout_cell;
#line 774 "../tmux.h"
struct __anonstruct_entry_32 {
   struct window_pane *tqe_next ;
   struct window_pane **tqe_prev ;
};
#line 774 "../tmux.h"
struct __anonstruct_tree_entry_33 {
   struct window_pane *rbe_left ;
   struct window_pane *rbe_right ;
   struct window_pane *rbe_parent ;
   int rbe_color ;
};
#line 774 "../tmux.h"
struct window_pane {
   u_int___0 id ;
   u_int___0 active_point ;
   struct window *window ;
   struct layout_cell *layout_cell ;
   struct layout_cell *saved_layout_cell ;
   u_int___0 sx ;
   u_int___0 sy ;
   u_int___0 osx ;
   u_int___0 osy ;
   u_int___0 xoff ;
   u_int___0 yoff ;
   int flags ;
   int argc ;
   char **argv ;
   char *shell ;
   char const   *cwd ;
   pid_t___0 pid ;
   char tty[10] ;
   int status ;
   int fd ;
   struct bufferevent *event ;
   struct event resize_timer ;
   struct input_ctx *ictx ;
   struct grid_cell colgc ;
   int *palette ;
   int pipe_fd ;
   struct bufferevent *pipe_event ;
   size_t pipe_off ;
   struct screen *screen ;
   struct screen base ;
   struct screen status_screen ;
   size_t status_size ;
   u_int___0 saved_cx ;
   u_int___0 saved_cy ;
   struct grid *saved_grid ;
   struct grid_cell saved_cell ;
   struct window_mode  const  *mode ;
   void *modedata ;
   struct event modetimer ;
   time_t modelast ;
   u_int___0 modeprefix ;
   char *searchstr ;
   struct __anonstruct_entry_32 entry ;
   struct __anonstruct_tree_entry_33 tree_entry ;
};
#line 851 "../tmux.h"
struct window_panes {
   struct window_pane *tqh_first ;
   struct window_pane **tqh_last ;
};
#line 852 "../tmux.h"
struct window_pane_tree {
   struct window_pane *rbh_root ;
};
#line 856 "../tmux.h"
struct __anonstruct_alerts_entry_34 {
   struct window *tqe_next ;
   struct window **tqe_prev ;
};
#line 856 "../tmux.h"
struct __anonstruct_winlinks_35 {
   struct winlink *tqh_first ;
   struct winlink **tqh_last ;
};
#line 856 "../tmux.h"
struct __anonstruct_entry_36 {
   struct window *rbe_left ;
   struct window *rbe_right ;
   struct window *rbe_parent ;
   int rbe_color ;
};
#line 856 "../tmux.h"
struct window {
   u_int___0 id ;
   char *name ;
   struct event name_event ;
   struct timeval name_time ;
   struct event alerts_timer ;
   struct timeval activity_time ;
   struct window_pane *active ;
   struct window_pane *last ;
   struct window_panes panes ;
   int lastlayout ;
   struct layout_cell *layout_root ;
   struct layout_cell *saved_layout_root ;
   char *old_layout ;
   u_int___0 sx ;
   u_int___0 sy ;
   int flags ;
   int alerts_queued ;
   struct __anonstruct_alerts_entry_34 alerts_entry ;
   struct options *options ;
   struct grid_cell style ;
   struct grid_cell active_style ;
   u_int___0 references ;
   struct __anonstruct_winlinks_35 winlinks ;
   struct __anonstruct_entry_36 entry ;
};
#line 903 "../tmux.h"
struct windows {
   struct window *rbh_root ;
};
#line 908 "../tmux.h"
struct __anonstruct_entry_37 {
   struct winlink *rbe_left ;
   struct winlink *rbe_right ;
   struct winlink *rbe_parent ;
   int rbe_color ;
};
#line 908 "../tmux.h"
struct __anonstruct_wentry_38 {
   struct winlink *tqe_next ;
   struct winlink **tqe_prev ;
};
#line 908 "../tmux.h"
struct __anonstruct_sentry_39 {
   struct winlink *tqe_next ;
   struct winlink **tqe_prev ;
};
#line 908 "../tmux.h"
struct winlink {
   int idx ;
   struct session *session ;
   struct window *window ;
   size_t status_width ;
   struct grid_cell status_cell ;
   char *status_text ;
   int flags ;
   struct __anonstruct_entry_37 entry ;
   struct __anonstruct_wentry_38 wentry ;
   struct __anonstruct_sentry_39 sentry ;
};
#line 927 "../tmux.h"
struct winlinks {
   struct winlink *rbh_root ;
};
#line 928 "../tmux.h"
struct winlink_stack {
   struct winlink *tqh_first ;
   struct winlink **tqh_last ;
};
#line 931
enum layout_type {
    LAYOUT_LEFTRIGHT = 0,
    LAYOUT_TOPBOTTOM = 1,
    LAYOUT_WINDOWPANE = 2
} ;
#line 938 "../tmux.h"
struct layout_cells {
   struct layout_cell *tqh_first ;
   struct layout_cell **tqh_last ;
};
#line 941 "../tmux.h"
struct __anonstruct_entry_40 {
   struct layout_cell *tqe_next ;
   struct layout_cell **tqe_prev ;
};
#line 941 "../tmux.h"
struct layout_cell {
   enum layout_type type ;
   struct layout_cell *parent ;
   u_int___0 sx ;
   u_int___0 sy ;
   u_int___0 xoff ;
   u_int___0 yoff ;
   struct window_pane *wp ;
   struct layout_cells cells ;
   struct __anonstruct_entry_40 entry ;
};
#line 976
struct hooks;
#line 976 "../tmux.h"
struct __anonstruct_gentry_44 {
   struct session *tqe_next ;
   struct session **tqe_prev ;
};
#line 976 "../tmux.h"
struct __anonstruct_entry_45 {
   struct session *rbe_left ;
   struct session *rbe_right ;
   struct session *rbe_parent ;
   int rbe_color ;
};
#line 976 "../tmux.h"
struct session {
   u_int___0 id ;
   char *name ;
   char const   *cwd ;
   struct timeval creation_time ;
   struct timeval last_attached_time ;
   struct timeval activity_time ;
   struct timeval last_activity_time ;
   struct event lock_timer ;
   u_int___0 sx ;
   u_int___0 sy ;
   struct winlink *curw ;
   struct winlink_stack lastw ;
   struct winlinks windows ;
   int statusat ;
   struct hooks *hooks ;
   struct options *options ;
   int flags ;
   u_int___0 attached ;
   struct termios *tio ;
   struct environ *environ ;
   int references ;
   struct __anonstruct_gentry_44 gentry ;
   struct __anonstruct_entry_45 entry ;
};
#line 1039 "../tmux.h"
struct mouse_event {
   int valid ;
   key_code key ;
   int statusat ;
   u_int___0 x ;
   u_int___0 y ;
   u_int___0 b ;
   u_int___0 lx ;
   u_int___0 ly ;
   u_int___0 lb ;
   int s ;
   int w ;
   int wp ;
   u_int___0 sgr_type ;
   u_int___0 sgr_b ;
};
#line 1062 "../tmux.h"
struct tty_key {
   char ch ;
   key_code key ;
   struct tty_key *left ;
   struct tty_key *right ;
   struct tty_key *next ;
};
#line 1072
struct tty_code;
#line 1072
struct tty_code;
#line 1073 "../tmux.h"
struct __anonstruct_entry_46 {

};
#line 1073 "../tmux.h"
struct tty_term {
   char *name ;
   u_int___0 references ;
   char acs[11][2] ;
   struct tty_code *codes ;
   int flags ;
   struct __anonstruct_entry_46 entry ;
};
#line 1089
struct evbuffer;
#line 1089
enum __anonenum_term_type_47 {
    TTY_VT100 = 0,
    TTY_VT101 = 1,
    TTY_VT102 = 2,
    TTY_VT220 = 3,
    TTY_VT320 = 4,
    TTY_VT420 = 5,
    TTY_UNKNOWN = 6
} ;
#line 1089 "../tmux.h"
struct tty {
   struct client *client ;
   u_int___0 sx ;
   u_int___0 sy ;
   u_int___0 cx ;
   u_int___0 cy ;
   u_int___0 cstyle ;
   char *ccolour ;
   int mode ;
   u_int___0 rlower ;
   u_int___0 rupper ;
   u_int___0 rleft ;
   u_int___0 rright ;
   int fd ;
   struct event event_in ;
   struct evbuffer *in ;
   struct event event_out ;
   struct evbuffer *out ;
   struct event timer ;
   size_t discarded ;
   struct termios tio ;
   struct grid_cell cell ;
   int last_wp ;
   struct grid_cell last_cell ;
   int flags ;
   struct tty_term *term ;
   char *term_name ;
   int term_flags ;
   enum __anonenum_term_type_47 term_type ;
   struct mouse_event mouse ;
   int mouse_drag_flag ;
   void (*mouse_drag_update)(struct client * , struct mouse_event * ) ;
   void (*mouse_drag_release)(struct client * , struct mouse_event * ) ;
   struct event key_timer ;
   struct tty_key *key_tree ;
};
#line 1188 "../tmux.h"
struct __anonstruct_entry_48 {
   struct message_entry *tqe_next ;
   struct message_entry **tqe_prev ;
};
#line 1188 "../tmux.h"
struct message_entry {
   char *msg ;
   u_int___0 msg_num ;
   time_t msg_time ;
   struct __anonstruct_entry_48 entry ;
};
#line 1197 "../tmux.h"
struct __anonstruct_entry_49 {
   struct args_entry *rbe_left ;
   struct args_entry *rbe_right ;
   struct args_entry *rbe_parent ;
   int rbe_color ;
};
#line 1197 "../tmux.h"
struct args_entry {
   u_char___0 flag ;
   char *value ;
   struct __anonstruct_entry_49 entry ;
};
#line 1203 "../tmux.h"
struct args_tree {
   struct args_entry *rbh_root ;
};
#line 1204 "../tmux.h"
struct args {
   struct args_tree tree ;
   int argc ;
   char **argv ;
};
#line 1216 "../tmux.h"
struct cmd_find_state {
   int flags ;
   struct cmd_find_state *current ;
   struct session *s ;
   struct winlink *wl ;
   struct window *w ;
   struct window_pane *wp ;
   int idx ;
};
#line 1237
struct cmd_entry;
#line 1237 "../tmux.h"
struct __anonstruct_qentry_50 {
   struct cmd *tqe_next ;
   struct cmd **tqe_prev ;
};
#line 1237 "../tmux.h"
struct cmd {
   struct cmd_entry  const  *entry ;
   struct args *args ;
   char *file ;
   u_int___0 line ;
   int flags ;
   void *data ;
   struct __anonstruct_qentry_50 qentry ;
};
#line 1250 "../tmux.h"
struct __anonstruct_list_51 {
   struct cmd *tqh_first ;
   struct cmd **tqh_last ;
};
#line 1250 "../tmux.h"
struct cmd_list {
   int references ;
   struct __anonstruct_list_51 list ;
};
#line 1285
struct cmdq_item;
#line 1286 "../tmux.h"
struct cmdq_list {
   struct cmdq_item *tqh_first ;
   struct cmdq_item **tqh_last ;
};
#line 1296
struct cmd_entry;
#line 1302
struct key_table;
#line 1302 "../tmux.h"
struct __anonstruct_message_log_52 {
   struct message_entry *tqh_first ;
   struct message_entry **tqh_last ;
};
#line 1302
enum __anonenum_prompt_mode_53 {
    PROMPT_ENTRY = 0,
    PROMPT_COMMAND = 1
} ;
#line 1302
struct cmd_q;
#line 1302 "../tmux.h"
struct __anonstruct_entry_54 {
   struct client *tqe_next ;
   struct client **tqe_prev ;
};
#line 1302 "../tmux.h"
struct client {
   char const   *name ;
   struct tmuxpeer *peer ;
   struct cmdq_list queue ;
   pid_t___0 pid ;
   int fd ;
   struct event event ;
   int retval ;
   struct timeval creation_time ;
   struct timeval activity_time ;
   struct environ *environ ;
   struct format_job_tree *jobs ;
   char *title ;
   char const   *cwd ;
   char *term ;
   char *ttyname ;
   struct tty tty ;
   size_t written ;
   size_t discarded ;
   size_t redraw ;
   void (*stdin_callback)(struct client * , int  , void * ) ;
   void *stdin_callback_data ;
   struct evbuffer *stdin_data ;
   int stdin_closed ;
   struct evbuffer *stdout_data ;
   struct evbuffer *stderr_data ;
   struct event repeat_timer ;
   struct event click_timer ;
   u_int___0 click_button ;
   struct event status_timer ;
   struct screen status ;
   struct screen *old_status ;
   int flags ;
   struct key_table *keytable ;
   struct event identify_timer ;
   void (*identify_callback)(struct client * , struct window_pane * ) ;
   void *identify_callback_data ;
   char *message_string ;
   struct event message_timer ;
   u_int___0 message_next ;
   struct __anonstruct_message_log_52 message_log ;
   char *prompt_string ;
   struct utf8_data *prompt_buffer ;
   size_t prompt_index ;
   int (*prompt_inputcb)(struct client * , void * , char const   * , int  ) ;
   void (*prompt_freecb)(void * ) ;
   void *prompt_data ;
   u_int___0 prompt_hindex ;
   enum __anonenum_prompt_mode_53 prompt_mode ;
   int prompt_flags ;
   struct session *session ;
   struct session *last_session ;
   int wlmouse ;
   int references ;
   struct cmd_q *cmdq ;
   struct __anonstruct_entry_54 entry ;
};
#line 1413 "../tmux.h"
struct __anonstruct_entry_55 {
   struct key_binding *rbe_left ;
   struct key_binding *rbe_right ;
   struct key_binding *rbe_parent ;
   int rbe_color ;
};
#line 1413 "../tmux.h"
struct key_binding {
   key_code key ;
   struct cmd_list *cmdlist ;
   int flags ;
   struct __anonstruct_entry_55 entry ;
};
#line 1422 "../tmux.h"
struct key_bindings {
   struct key_binding *rbh_root ;
};
#line 1424 "../tmux.h"
struct __anonstruct_entry_56 {
   struct key_table *rbe_left ;
   struct key_table *rbe_right ;
   struct key_table *rbe_parent ;
   int rbe_color ;
};
#line 1424 "../tmux.h"
struct key_table {
   char const   *name ;
   struct key_bindings key_bindings ;
   u_int___0 references ;
   struct __anonstruct_entry_56 entry ;
};
#line 12 "tmux_df_2.c"
enum notify_type {
    NOTIFY_WINDOW_LAYOUT_CHANGED = 0,
    NOTIFY_WINDOW_UNLINKED = 1,
    NOTIFY_WINDOW_LINKED = 2,
    NOTIFY_WINDOW_RENAMED = 3,
    NOTIFY_ATTACHED_SESSION_CHANGED = 4,
    NOTIFY_SESSION_RENAMED = 5,
    NOTIFY_SESSION_CREATED = 6,
    NOTIFY_SESSION_CLOSED = 7
} ;
#line 23 "tmux_df_2.c"
struct __anonstruct_entry_57 {
   struct notify_entry *tqe_next ;
   struct notify_entry **tqe_prev ;
};
#line 23 "tmux_df_2.c"
struct notify_entry {
   enum notify_type type ;
   struct client *client ;
   struct session *session ;
   struct window *window ;
   struct __anonstruct_entry_57 entry ;
};
#line 32 "tmux_df_2.c"
struct __anonstruct_notify_queue_58 {
   struct notify_entry *tqh_first ;
   struct notify_entry **tqh_last ;
};
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 32 "tmux_df_2.c"
struct __anonstruct_notify_queue_58 notify_queue  =    {(struct notify_entry *)((void *)0), & notify_queue.tqh_first};
#line 33 "tmux_df_2.c"
int notify_enabled  =    1;
#line 36
void notify_drain(void) ;
#line 37
void notify_add(enum notify_type type , struct client *c , struct session *s , struct window *w ) ;
#line 40 "tmux_df_2.c"
struct windows windows  ;
#line 43 "tmux_df_2.c"
struct window_pane_tree all_window_panes  ;
#line 44 "tmux_df_2.c"
u_int___0 next_window_pane_id  ;
#line 45 "tmux_df_2.c"
u_int___0 next_window_id  ;
#line 46 "tmux_df_2.c"
u_int___0 next_active_point  ;
#line 48 "tmux_df_2.c"
int window_cmp(struct window *w1 , struct window *w2 ) 
{ 


  {
#line 51
  return ((int )(w1->id - w2->id));
}
}
#line 54 "tmux_df_2.c"
int winlink_cmp(struct winlink *wl1 , struct winlink *wl2 ) 
{ 


  {
#line 57
  return (wl1->idx - wl2->idx);
}
}
#line 60 "tmux_df_2.c"
int window_pane_cmp(struct window_pane *wp1 , struct window_pane *wp2 ) 
{ 


  {
#line 63
  return ((int )(wp1->id - wp2->id));
}
}
#line 66 "tmux_df_2.c"
void windows_RB_INSERT_COLOR(struct windows *head , struct window *elm ) 
{ 
  struct window *parent ;
  struct window *gparent ;
  struct window *tmp ;
  struct window *tmp___0 ;
  struct window *tmp___1 ;
  struct window *tmp___2 ;
  struct window *tmp___3 ;
  struct window *tmp___4 ;
  struct window *tmp___5 ;
  struct window *tmp___6 ;
  struct window *tmp___7 ;

  {
#line 66
  while (1) {
#line 66
    parent = elm->entry.rbe_parent;
#line 66
    if ((unsigned long )parent != (unsigned long )((void *)0)) {
#line 66
      if (! (parent->entry.rbe_color == 1)) {
#line 66
        break;
      }
    } else {
#line 66
      break;
    }
#line 66
    gparent = parent->entry.rbe_parent;
#line 66
    if ((unsigned long )parent == (unsigned long )gparent->entry.rbe_left) {
#line 66
      tmp = gparent->entry.rbe_right;
#line 66
      if (tmp) {
#line 66
        if (tmp->entry.rbe_color == 1) {
#line 66
          tmp->entry.rbe_color = 0;
#line 66
          while (1) {
#line 66
            parent->entry.rbe_color = 0;
#line 66
            gparent->entry.rbe_color = 1;
#line 66
            break;
          }
#line 66
          elm = gparent;
#line 66
          continue;
        }
      }
#line 66
      if ((unsigned long )parent->entry.rbe_right == (unsigned long )elm) {
#line 66
        while (1) {
#line 66
          tmp = parent->entry.rbe_right;
#line 66
          tmp___0 = tmp->entry.rbe_left;
#line 66
          parent->entry.rbe_right = tmp___0;
#line 66
          if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 66
            (tmp->entry.rbe_left)->entry.rbe_parent = parent;
          }
#line 66
          while (1) {
#line 66
            break;
          }
#line 66
          tmp___1 = parent->entry.rbe_parent;
#line 66
          tmp->entry.rbe_parent = tmp___1;
#line 66
          if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
#line 66
            if ((unsigned long )parent == (unsigned long )(parent->entry.rbe_parent)->entry.rbe_left) {
#line 66
              (parent->entry.rbe_parent)->entry.rbe_left = tmp;
            } else {
#line 66
              (parent->entry.rbe_parent)->entry.rbe_right = tmp;
            }
          } else {
#line 66
            head->rbh_root = tmp;
          }
#line 66
          tmp->entry.rbe_left = parent;
#line 66
          parent->entry.rbe_parent = tmp;
#line 66
          while (1) {
#line 66
            break;
          }
#line 66
          if (tmp->entry.rbe_parent) {
#line 66
            while (1) {
#line 66
              break;
            }
          }
#line 66
          break;
        }
#line 66
        tmp = parent;
#line 66
        parent = elm;
#line 66
        elm = tmp;
      }
#line 66
      while (1) {
#line 66
        parent->entry.rbe_color = 0;
#line 66
        gparent->entry.rbe_color = 1;
#line 66
        break;
      }
#line 66
      while (1) {
#line 66
        tmp = gparent->entry.rbe_left;
#line 66
        tmp___2 = tmp->entry.rbe_right;
#line 66
        gparent->entry.rbe_left = tmp___2;
#line 66
        if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
#line 66
          (tmp->entry.rbe_right)->entry.rbe_parent = gparent;
        }
#line 66
        while (1) {
#line 66
          break;
        }
#line 66
        tmp___3 = gparent->entry.rbe_parent;
#line 66
        tmp->entry.rbe_parent = tmp___3;
#line 66
        if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
#line 66
          if ((unsigned long )gparent == (unsigned long )(gparent->entry.rbe_parent)->entry.rbe_left) {
#line 66
            (gparent->entry.rbe_parent)->entry.rbe_left = tmp;
          } else {
#line 66
            (gparent->entry.rbe_parent)->entry.rbe_right = tmp;
          }
        } else {
#line 66
          head->rbh_root = tmp;
        }
#line 66
        tmp->entry.rbe_right = gparent;
#line 66
        gparent->entry.rbe_parent = tmp;
#line 66
        while (1) {
#line 66
          break;
        }
#line 66
        if (tmp->entry.rbe_parent) {
#line 66
          while (1) {
#line 66
            break;
          }
        }
#line 66
        break;
      }
    } else {
#line 66
      tmp = gparent->entry.rbe_left;
#line 66
      if (tmp) {
#line 66
        if (tmp->entry.rbe_color == 1) {
#line 66
          tmp->entry.rbe_color = 0;
#line 66
          while (1) {
#line 66
            parent->entry.rbe_color = 0;
#line 66
            gparent->entry.rbe_color = 1;
#line 66
            break;
          }
#line 66
          elm = gparent;
#line 66
          continue;
        }
      }
#line 66
      if ((unsigned long )parent->entry.rbe_left == (unsigned long )elm) {
#line 66
        while (1) {
#line 66
          tmp = parent->entry.rbe_left;
#line 66
          tmp___4 = tmp->entry.rbe_right;
#line 66
          parent->entry.rbe_left = tmp___4;
#line 66
          if ((unsigned long )tmp___4 != (unsigned long )((void *)0)) {
#line 66
            (tmp->entry.rbe_right)->entry.rbe_parent = parent;
          }
#line 66
          while (1) {
#line 66
            break;
          }
#line 66
          tmp___5 = parent->entry.rbe_parent;
#line 66
          tmp->entry.rbe_parent = tmp___5;
#line 66
          if ((unsigned long )tmp___5 != (unsigned long )((void *)0)) {
#line 66
            if ((unsigned long )parent == (unsigned long )(parent->entry.rbe_parent)->entry.rbe_left) {
#line 66
              (parent->entry.rbe_parent)->entry.rbe_left = tmp;
            } else {
#line 66
              (parent->entry.rbe_parent)->entry.rbe_right = tmp;
            }
          } else {
#line 66
            head->rbh_root = tmp;
          }
#line 66
          tmp->entry.rbe_right = parent;
#line 66
          parent->entry.rbe_parent = tmp;
#line 66
          while (1) {
#line 66
            break;
          }
#line 66
          if (tmp->entry.rbe_parent) {
#line 66
            while (1) {
#line 66
              break;
            }
          }
#line 66
          break;
        }
#line 66
        tmp = parent;
#line 66
        parent = elm;
#line 66
        elm = tmp;
      }
#line 66
      while (1) {
#line 66
        parent->entry.rbe_color = 0;
#line 66
        gparent->entry.rbe_color = 1;
#line 66
        break;
      }
#line 66
      while (1) {
#line 66
        tmp = gparent->entry.rbe_right;
#line 66
        tmp___6 = tmp->entry.rbe_left;
#line 66
        gparent->entry.rbe_right = tmp___6;
#line 66
        if ((unsigned long )tmp___6 != (unsigned long )((void *)0)) {
#line 66
          (tmp->entry.rbe_left)->entry.rbe_parent = gparent;
        }
#line 66
        while (1) {
#line 66
          break;
        }
#line 66
        tmp___7 = gparent->entry.rbe_parent;
#line 66
        tmp->entry.rbe_parent = tmp___7;
#line 66
        if ((unsigned long )tmp___7 != (unsigned long )((void *)0)) {
#line 66
          if ((unsigned long )gparent == (unsigned long )(gparent->entry.rbe_parent)->entry.rbe_left) {
#line 66
            (gparent->entry.rbe_parent)->entry.rbe_left = tmp;
          } else {
#line 66
            (gparent->entry.rbe_parent)->entry.rbe_right = tmp;
          }
        } else {
#line 66
          head->rbh_root = tmp;
        }
#line 66
        tmp->entry.rbe_left = gparent;
#line 66
        gparent->entry.rbe_parent = tmp;
#line 66
        while (1) {
#line 66
          break;
        }
#line 66
        if (tmp->entry.rbe_parent) {
#line 66
          while (1) {
#line 66
            break;
          }
        }
#line 66
        break;
      }
    }
  }
#line 66
  (head->rbh_root)->entry.rbe_color = 0;
#line 66
  return;
}
}
#line 66 "tmux_df_2.c"
void windows_RB_REMOVE_COLOR(struct windows *head , struct window *parent , struct window *elm ) 
{ 
  struct window *tmp ;
  struct window *tmp___0 ;
  struct window *tmp___1 ;
  struct window *oleft ;
  struct window *tmp___2 ;
  struct window *tmp___3 ;
  struct window *tmp___4 ;
  struct window *tmp___5 ;
  struct window *tmp___6 ;
  struct window *tmp___7 ;
  struct window *oright ;
  struct window *tmp___8 ;
  struct window *tmp___9 ;
  struct window *tmp___10 ;
  struct window *tmp___11 ;

  {
#line 66
  while (1) {
#line 66
    if ((unsigned long )elm == (unsigned long )((void *)0)) {
#line 66
      goto _L___5;
    } else
#line 66
    if (elm->entry.rbe_color == 0) {
      _L___5: /* CIL Label */ 
#line 66
      if (! ((unsigned long )elm != (unsigned long )head->rbh_root)) {
#line 66
        break;
      }
    } else {
#line 66
      break;
    }
#line 66
    if ((unsigned long )parent->entry.rbe_left == (unsigned long )elm) {
#line 66
      tmp = parent->entry.rbe_right;
#line 66
      if (tmp->entry.rbe_color == 1) {
#line 66
        while (1) {
#line 66
          tmp->entry.rbe_color = 0;
#line 66
          parent->entry.rbe_color = 1;
#line 66
          break;
        }
#line 66
        while (1) {
#line 66
          tmp = parent->entry.rbe_right;
#line 66
          tmp___0 = tmp->entry.rbe_left;
#line 66
          parent->entry.rbe_right = tmp___0;
#line 66
          if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 66
            (tmp->entry.rbe_left)->entry.rbe_parent = parent;
          }
#line 66
          while (1) {
#line 66
            break;
          }
#line 66
          tmp___1 = parent->entry.rbe_parent;
#line 66
          tmp->entry.rbe_parent = tmp___1;
#line 66
          if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
#line 66
            if ((unsigned long )parent == (unsigned long )(parent->entry.rbe_parent)->entry.rbe_left) {
#line 66
              (parent->entry.rbe_parent)->entry.rbe_left = tmp;
            } else {
#line 66
              (parent->entry.rbe_parent)->entry.rbe_right = tmp;
            }
          } else {
#line 66
            head->rbh_root = tmp;
          }
#line 66
          tmp->entry.rbe_left = parent;
#line 66
          parent->entry.rbe_parent = tmp;
#line 66
          while (1) {
#line 66
            break;
          }
#line 66
          if (tmp->entry.rbe_parent) {
#line 66
            while (1) {
#line 66
              break;
            }
          }
#line 66
          break;
        }
#line 66
        tmp = parent->entry.rbe_right;
      }
#line 66
      if ((unsigned long )tmp->entry.rbe_left == (unsigned long )((void *)0)) {
#line 66
        goto _L___1;
      } else
#line 66
      if ((tmp->entry.rbe_left)->entry.rbe_color == 0) {
        _L___1: /* CIL Label */ 
#line 66
        if ((unsigned long )tmp->entry.rbe_right == (unsigned long )((void *)0)) {
#line 66
          tmp->entry.rbe_color = 1;
#line 66
          elm = parent;
#line 66
          parent = elm->entry.rbe_parent;
        } else
#line 66
        if ((tmp->entry.rbe_right)->entry.rbe_color == 0) {
#line 66
          tmp->entry.rbe_color = 1;
#line 66
          elm = parent;
#line 66
          parent = elm->entry.rbe_parent;
        } else {
#line 66
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 66
        if ((unsigned long )tmp->entry.rbe_right == (unsigned long )((void *)0)) {
#line 66
          goto _L;
        } else
#line 66
        if ((tmp->entry.rbe_right)->entry.rbe_color == 0) {
          _L: /* CIL Label */ 
#line 66
          oleft = tmp->entry.rbe_left;
#line 66
          if ((unsigned long )oleft != (unsigned long )((void *)0)) {
#line 66
            oleft->entry.rbe_color = 0;
          }
#line 66
          tmp->entry.rbe_color = 1;
#line 66
          while (1) {
#line 66
            oleft = tmp->entry.rbe_left;
#line 66
            tmp___2 = oleft->entry.rbe_right;
#line 66
            tmp->entry.rbe_left = tmp___2;
#line 66
            if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
#line 66
              (oleft->entry.rbe_right)->entry.rbe_parent = tmp;
            }
#line 66
            while (1) {
#line 66
              break;
            }
#line 66
            tmp___3 = tmp->entry.rbe_parent;
#line 66
            oleft->entry.rbe_parent = tmp___3;
#line 66
            if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
#line 66
              if ((unsigned long )tmp == (unsigned long )(tmp->entry.rbe_parent)->entry.rbe_left) {
#line 66
                (tmp->entry.rbe_parent)->entry.rbe_left = oleft;
              } else {
#line 66
                (tmp->entry.rbe_parent)->entry.rbe_right = oleft;
              }
            } else {
#line 66
              head->rbh_root = oleft;
            }
#line 66
            oleft->entry.rbe_right = tmp;
#line 66
            tmp->entry.rbe_parent = oleft;
#line 66
            while (1) {
#line 66
              break;
            }
#line 66
            if (oleft->entry.rbe_parent) {
#line 66
              while (1) {
#line 66
                break;
              }
            }
#line 66
            break;
          }
#line 66
          tmp = parent->entry.rbe_right;
        }
#line 66
        tmp->entry.rbe_color = parent->entry.rbe_color;
#line 66
        parent->entry.rbe_color = 0;
#line 66
        if (tmp->entry.rbe_right) {
#line 66
          (tmp->entry.rbe_right)->entry.rbe_color = 0;
        }
#line 66
        while (1) {
#line 66
          tmp = parent->entry.rbe_right;
#line 66
          tmp___4 = tmp->entry.rbe_left;
#line 66
          parent->entry.rbe_right = tmp___4;
#line 66
          if ((unsigned long )tmp___4 != (unsigned long )((void *)0)) {
#line 66
            (tmp->entry.rbe_left)->entry.rbe_parent = parent;
          }
#line 66
          while (1) {
#line 66
            break;
          }
#line 66
          tmp___5 = parent->entry.rbe_parent;
#line 66
          tmp->entry.rbe_parent = tmp___5;
#line 66
          if ((unsigned long )tmp___5 != (unsigned long )((void *)0)) {
#line 66
            if ((unsigned long )parent == (unsigned long )(parent->entry.rbe_parent)->entry.rbe_left) {
#line 66
              (parent->entry.rbe_parent)->entry.rbe_left = tmp;
            } else {
#line 66
              (parent->entry.rbe_parent)->entry.rbe_right = tmp;
            }
          } else {
#line 66
            head->rbh_root = tmp;
          }
#line 66
          tmp->entry.rbe_left = parent;
#line 66
          parent->entry.rbe_parent = tmp;
#line 66
          while (1) {
#line 66
            break;
          }
#line 66
          if (tmp->entry.rbe_parent) {
#line 66
            while (1) {
#line 66
              break;
            }
          }
#line 66
          break;
        }
#line 66
        elm = head->rbh_root;
#line 66
        break;
      }
    } else {
#line 66
      tmp = parent->entry.rbe_left;
#line 66
      if (tmp->entry.rbe_color == 1) {
#line 66
        while (1) {
#line 66
          tmp->entry.rbe_color = 0;
#line 66
          parent->entry.rbe_color = 1;
#line 66
          break;
        }
#line 66
        while (1) {
#line 66
          tmp = parent->entry.rbe_left;
#line 66
          tmp___6 = tmp->entry.rbe_right;
#line 66
          parent->entry.rbe_left = tmp___6;
#line 66
          if ((unsigned long )tmp___6 != (unsigned long )((void *)0)) {
#line 66
            (tmp->entry.rbe_right)->entry.rbe_parent = parent;
          }
#line 66
          while (1) {
#line 66
            break;
          }
#line 66
          tmp___7 = parent->entry.rbe_parent;
#line 66
          tmp->entry.rbe_parent = tmp___7;
#line 66
          if ((unsigned long )tmp___7 != (unsigned long )((void *)0)) {
#line 66
            if ((unsigned long )parent == (unsigned long )(parent->entry.rbe_parent)->entry.rbe_left) {
#line 66
              (parent->entry.rbe_parent)->entry.rbe_left = tmp;
            } else {
#line 66
              (parent->entry.rbe_parent)->entry.rbe_right = tmp;
            }
          } else {
#line 66
            head->rbh_root = tmp;
          }
#line 66
          tmp->entry.rbe_right = parent;
#line 66
          parent->entry.rbe_parent = tmp;
#line 66
          while (1) {
#line 66
            break;
          }
#line 66
          if (tmp->entry.rbe_parent) {
#line 66
            while (1) {
#line 66
              break;
            }
          }
#line 66
          break;
        }
#line 66
        tmp = parent->entry.rbe_left;
      }
#line 66
      if ((unsigned long )tmp->entry.rbe_left == (unsigned long )((void *)0)) {
#line 66
        goto _L___4;
      } else
#line 66
      if ((tmp->entry.rbe_left)->entry.rbe_color == 0) {
        _L___4: /* CIL Label */ 
#line 66
        if ((unsigned long )tmp->entry.rbe_right == (unsigned long )((void *)0)) {
#line 66
          tmp->entry.rbe_color = 1;
#line 66
          elm = parent;
#line 66
          parent = elm->entry.rbe_parent;
        } else
#line 66
        if ((tmp->entry.rbe_right)->entry.rbe_color == 0) {
#line 66
          tmp->entry.rbe_color = 1;
#line 66
          elm = parent;
#line 66
          parent = elm->entry.rbe_parent;
        } else {
#line 66
          goto _L___3;
        }
      } else {
        _L___3: /* CIL Label */ 
#line 66
        if ((unsigned long )tmp->entry.rbe_left == (unsigned long )((void *)0)) {
#line 66
          goto _L___2;
        } else
#line 66
        if ((tmp->entry.rbe_left)->entry.rbe_color == 0) {
          _L___2: /* CIL Label */ 
#line 66
          oright = tmp->entry.rbe_right;
#line 66
          if ((unsigned long )oright != (unsigned long )((void *)0)) {
#line 66
            oright->entry.rbe_color = 0;
          }
#line 66
          tmp->entry.rbe_color = 1;
#line 66
          while (1) {
#line 66
            oright = tmp->entry.rbe_right;
#line 66
            tmp___8 = oright->entry.rbe_left;
#line 66
            tmp->entry.rbe_right = tmp___8;
#line 66
            if ((unsigned long )tmp___8 != (unsigned long )((void *)0)) {
#line 66
              (oright->entry.rbe_left)->entry.rbe_parent = tmp;
            }
#line 66
            while (1) {
#line 66
              break;
            }
#line 66
            tmp___9 = tmp->entry.rbe_parent;
#line 66
            oright->entry.rbe_parent = tmp___9;
#line 66
            if ((unsigned long )tmp___9 != (unsigned long )((void *)0)) {
#line 66
              if ((unsigned long )tmp == (unsigned long )(tmp->entry.rbe_parent)->entry.rbe_left) {
#line 66
                (tmp->entry.rbe_parent)->entry.rbe_left = oright;
              } else {
#line 66
                (tmp->entry.rbe_parent)->entry.rbe_right = oright;
              }
            } else {
#line 66
              head->rbh_root = oright;
            }
#line 66
            oright->entry.rbe_left = tmp;
#line 66
            tmp->entry.rbe_parent = oright;
#line 66
            while (1) {
#line 66
              break;
            }
#line 66
            if (oright->entry.rbe_parent) {
#line 66
              while (1) {
#line 66
                break;
              }
            }
#line 66
            break;
          }
#line 66
          tmp = parent->entry.rbe_left;
        }
#line 66
        tmp->entry.rbe_color = parent->entry.rbe_color;
#line 66
        parent->entry.rbe_color = 0;
#line 66
        if (tmp->entry.rbe_left) {
#line 66
          (tmp->entry.rbe_left)->entry.rbe_color = 0;
        }
#line 66
        while (1) {
#line 66
          tmp = parent->entry.rbe_left;
#line 66
          tmp___10 = tmp->entry.rbe_right;
#line 66
          parent->entry.rbe_left = tmp___10;
#line 66
          if ((unsigned long )tmp___10 != (unsigned long )((void *)0)) {
#line 66
            (tmp->entry.rbe_right)->entry.rbe_parent = parent;
          }
#line 66
          while (1) {
#line 66
            break;
          }
#line 66
          tmp___11 = parent->entry.rbe_parent;
#line 66
          tmp->entry.rbe_parent = tmp___11;
#line 66
          if ((unsigned long )tmp___11 != (unsigned long )((void *)0)) {
#line 66
            if ((unsigned long )parent == (unsigned long )(parent->entry.rbe_parent)->entry.rbe_left) {
#line 66
              (parent->entry.rbe_parent)->entry.rbe_left = tmp;
            } else {
#line 66
              (parent->entry.rbe_parent)->entry.rbe_right = tmp;
            }
          } else {
#line 66
            head->rbh_root = tmp;
          }
#line 66
          tmp->entry.rbe_right = parent;
#line 66
          parent->entry.rbe_parent = tmp;
#line 66
          while (1) {
#line 66
            break;
          }
#line 66
          if (tmp->entry.rbe_parent) {
#line 66
            while (1) {
#line 66
              break;
            }
          }
#line 66
          break;
        }
#line 66
        elm = head->rbh_root;
#line 66
        break;
      }
    }
  }
#line 66
  if (elm) {
#line 66
    elm->entry.rbe_color = 0;
  }
#line 66
  return;
}
}
#line 66 "tmux_df_2.c"
struct window *windows_RB_INSERT(struct windows *head , struct window *elm ) 
{ 
  struct window *tmp ;
  struct window *parent ;
  int comp ;
  struct window *tmp___0 ;

  {
#line 66
  parent = (struct window *)((void *)0);
#line 66
  comp = 0;
#line 66
  tmp = head->rbh_root;
#line 66
  while (tmp) {
#line 66
    parent = tmp;
#line 66
    comp = window_cmp(elm, parent);
#line 66
    if (comp < 0) {
#line 66
      tmp = tmp->entry.rbe_left;
    } else
#line 66
    if (comp > 0) {
#line 66
      tmp = tmp->entry.rbe_right;
    } else {
#line 66
      return (tmp);
    }
  }
#line 66
  while (1) {
#line 66
    elm->entry.rbe_parent = parent;
#line 66
    tmp___0 = (struct window *)((void *)0);
#line 66
    elm->entry.rbe_right = tmp___0;
#line 66
    elm->entry.rbe_left = tmp___0;
#line 66
    elm->entry.rbe_color = 1;
#line 66
    break;
  }
#line 66
  if ((unsigned long )parent != (unsigned long )((void *)0)) {
#line 66
    if (comp < 0) {
#line 66
      parent->entry.rbe_left = elm;
    } else {
#line 66
      parent->entry.rbe_right = elm;
    }
#line 66
    while (1) {
#line 66
      break;
    }
  } else {
#line 66
    head->rbh_root = elm;
  }
#line 66
  windows_RB_INSERT_COLOR(head, elm);
#line 66
  return ((struct window *)((void *)0));
}
}
#line 66 "tmux_df_2.c"
struct window *windows_RB_REMOVE(struct windows *head , struct window *elm ) 
{ 
  struct window *child ;
  struct window *parent ;
  struct window *old ;
  int color ;
  struct window *left ;

  {
#line 66
  old = elm;
#line 66
  if ((unsigned long )elm->entry.rbe_left == (unsigned long )((void *)0)) {
#line 66
    child = elm->entry.rbe_right;
  } else
#line 66
  if ((unsigned long )elm->entry.rbe_right == (unsigned long )((void *)0)) {
#line 66
    child = elm->entry.rbe_left;
  } else {
#line 66
    elm = elm->entry.rbe_right;
#line 66
    while (1) {
#line 66
      left = elm->entry.rbe_left;
#line 66
      if (! ((unsigned long )left != (unsigned long )((void *)0))) {
#line 66
        break;
      }
#line 66
      elm = left;
    }
#line 66
    child = elm->entry.rbe_right;
#line 66
    parent = elm->entry.rbe_parent;
#line 66
    color = elm->entry.rbe_color;
#line 66
    if (child) {
#line 66
      child->entry.rbe_parent = parent;
    }
#line 66
    if (parent) {
#line 66
      if ((unsigned long )parent->entry.rbe_left == (unsigned long )elm) {
#line 66
        parent->entry.rbe_left = child;
      } else {
#line 66
        parent->entry.rbe_right = child;
      }
#line 66
      while (1) {
#line 66
        break;
      }
    } else {
#line 66
      head->rbh_root = child;
    }
#line 66
    if ((unsigned long )elm->entry.rbe_parent == (unsigned long )old) {
#line 66
      parent = elm;
    }
#line 66
    elm->entry = old->entry;
#line 66
    if (old->entry.rbe_parent) {
#line 66
      if ((unsigned long )(old->entry.rbe_parent)->entry.rbe_left == (unsigned long )old) {
#line 66
        (old->entry.rbe_parent)->entry.rbe_left = elm;
      } else {
#line 66
        (old->entry.rbe_parent)->entry.rbe_right = elm;
      }
#line 66
      while (1) {
#line 66
        break;
      }
    } else {
#line 66
      head->rbh_root = elm;
    }
#line 66
    (old->entry.rbe_left)->entry.rbe_parent = elm;
#line 66
    if (old->entry.rbe_right) {
#line 66
      (old->entry.rbe_right)->entry.rbe_parent = elm;
    }
#line 66
    if (parent) {
#line 66
      left = parent;
#line 66
      while (1) {
#line 66
        while (1) {
#line 66
          break;
        }
#line 66
        left = left->entry.rbe_parent;
#line 66
        if (! ((unsigned long )left != (unsigned long )((void *)0))) {
#line 66
          break;
        }
      }
    }
#line 66
    goto color;
  }
#line 66
  parent = elm->entry.rbe_parent;
#line 66
  color = elm->entry.rbe_color;
#line 66
  if (child) {
#line 66
    child->entry.rbe_parent = parent;
  }
#line 66
  if (parent) {
#line 66
    if ((unsigned long )parent->entry.rbe_left == (unsigned long )elm) {
#line 66
      parent->entry.rbe_left = child;
    } else {
#line 66
      parent->entry.rbe_right = child;
    }
#line 66
    while (1) {
#line 66
      break;
    }
  } else {
#line 66
    head->rbh_root = child;
  }
  color: 
#line 66
  if (color == 0) {
#line 66
    windows_RB_REMOVE_COLOR(head, parent, child);
  }
#line 66
  return (old);
}
}
#line 66 "tmux_df_2.c"
struct window *windows_RB_FIND(struct windows *head , struct window *elm ) 
{ 
  struct window *tmp ;
  int comp ;

  {
#line 66
  tmp = head->rbh_root;
#line 66
  while (tmp) {
#line 66
    comp = window_cmp(elm, tmp);
#line 66
    if (comp < 0) {
#line 66
      tmp = tmp->entry.rbe_left;
    } else
#line 66
    if (comp > 0) {
#line 66
      tmp = tmp->entry.rbe_right;
    } else {
#line 66
      return (tmp);
    }
  }
#line 66
  return ((struct window *)((void *)0));
}
}
#line 66 "tmux_df_2.c"
struct window *windows_RB_NFIND(struct windows *head , struct window *elm ) 
{ 
  struct window *tmp ;
  struct window *res ;
  int comp ;

  {
#line 66
  tmp = head->rbh_root;
#line 66
  res = (struct window *)((void *)0);
#line 66
  while (tmp) {
#line 66
    comp = window_cmp(elm, tmp);
#line 66
    if (comp < 0) {
#line 66
      res = tmp;
#line 66
      tmp = tmp->entry.rbe_left;
    } else
#line 66
    if (comp > 0) {
#line 66
      tmp = tmp->entry.rbe_right;
    } else {
#line 66
      return (tmp);
    }
  }
#line 66
  return (res);
}
}
#line 66 "tmux_df_2.c"
struct window *windows_RB_NEXT(struct window *elm ) 
{ 


  {
#line 66
  if (elm->entry.rbe_right) {
#line 66
    elm = elm->entry.rbe_right;
#line 66
    while (elm->entry.rbe_left) {
#line 66
      elm = elm->entry.rbe_left;
    }
  } else
#line 66
  if (elm->entry.rbe_parent) {
#line 66
    if ((unsigned long )elm == (unsigned long )(elm->entry.rbe_parent)->entry.rbe_left) {
#line 66
      elm = elm->entry.rbe_parent;
    } else {
#line 66
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 66
    while (1) {
#line 66
      if (elm->entry.rbe_parent) {
#line 66
        if (! ((unsigned long )elm == (unsigned long )(elm->entry.rbe_parent)->entry.rbe_right)) {
#line 66
          break;
        }
      } else {
#line 66
        break;
      }
#line 66
      elm = elm->entry.rbe_parent;
    }
#line 66
    elm = elm->entry.rbe_parent;
  }
#line 66
  return (elm);
}
}
#line 66 "tmux_df_2.c"
struct window *windows_RB_PREV(struct window *elm ) 
{ 


  {
#line 66
  if (elm->entry.rbe_left) {
#line 66
    elm = elm->entry.rbe_left;
#line 66
    while (elm->entry.rbe_right) {
#line 66
      elm = elm->entry.rbe_right;
    }
  } else
#line 66
  if (elm->entry.rbe_parent) {
#line 66
    if ((unsigned long )elm == (unsigned long )(elm->entry.rbe_parent)->entry.rbe_right) {
#line 66
      elm = elm->entry.rbe_parent;
    } else {
#line 66
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 66
    while (1) {
#line 66
      if (elm->entry.rbe_parent) {
#line 66
        if (! ((unsigned long )elm == (unsigned long )(elm->entry.rbe_parent)->entry.rbe_left)) {
#line 66
          break;
        }
      } else {
#line 66
        break;
      }
#line 66
      elm = elm->entry.rbe_parent;
    }
#line 66
    elm = elm->entry.rbe_parent;
  }
#line 66
  return (elm);
}
}
#line 66 "tmux_df_2.c"
struct window *windows_RB_MINMAX(struct windows *head , int val ) 
{ 
  struct window *tmp ;
  struct window *parent ;

  {
#line 66
  tmp = head->rbh_root;
#line 66
  parent = (struct window *)((void *)0);
#line 66
  while (tmp) {
#line 66
    parent = tmp;
#line 66
    if (val < 0) {
#line 66
      tmp = tmp->entry.rbe_left;
    } else {
#line 66
      tmp = tmp->entry.rbe_right;
    }
  }
#line 66
  return (parent);
}
}
#line 67 "tmux_df_2.c"
void winlinks_RB_INSERT_COLOR(struct winlinks *head , struct winlink *elm ) 
{ 
  struct winlink *parent ;
  struct winlink *gparent ;
  struct winlink *tmp ;
  struct winlink *tmp___0 ;
  struct winlink *tmp___1 ;
  struct winlink *tmp___2 ;
  struct winlink *tmp___3 ;
  struct winlink *tmp___4 ;
  struct winlink *tmp___5 ;
  struct winlink *tmp___6 ;
  struct winlink *tmp___7 ;

  {
#line 67
  while (1) {
#line 67
    parent = elm->entry.rbe_parent;
#line 67
    if ((unsigned long )parent != (unsigned long )((void *)0)) {
#line 67
      if (! (parent->entry.rbe_color == 1)) {
#line 67
        break;
      }
    } else {
#line 67
      break;
    }
#line 67
    gparent = parent->entry.rbe_parent;
#line 67
    if ((unsigned long )parent == (unsigned long )gparent->entry.rbe_left) {
#line 67
      tmp = gparent->entry.rbe_right;
#line 67
      if (tmp) {
#line 67
        if (tmp->entry.rbe_color == 1) {
#line 67
          tmp->entry.rbe_color = 0;
#line 67
          while (1) {
#line 67
            parent->entry.rbe_color = 0;
#line 67
            gparent->entry.rbe_color = 1;
#line 67
            break;
          }
#line 67
          elm = gparent;
#line 67
          continue;
        }
      }
#line 67
      if ((unsigned long )parent->entry.rbe_right == (unsigned long )elm) {
#line 67
        while (1) {
#line 67
          tmp = parent->entry.rbe_right;
#line 67
          tmp___0 = tmp->entry.rbe_left;
#line 67
          parent->entry.rbe_right = tmp___0;
#line 67
          if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 67
            (tmp->entry.rbe_left)->entry.rbe_parent = parent;
          }
#line 67
          while (1) {
#line 67
            break;
          }
#line 67
          tmp___1 = parent->entry.rbe_parent;
#line 67
          tmp->entry.rbe_parent = tmp___1;
#line 67
          if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
#line 67
            if ((unsigned long )parent == (unsigned long )(parent->entry.rbe_parent)->entry.rbe_left) {
#line 67
              (parent->entry.rbe_parent)->entry.rbe_left = tmp;
            } else {
#line 67
              (parent->entry.rbe_parent)->entry.rbe_right = tmp;
            }
          } else {
#line 67
            head->rbh_root = tmp;
          }
#line 67
          tmp->entry.rbe_left = parent;
#line 67
          parent->entry.rbe_parent = tmp;
#line 67
          while (1) {
#line 67
            break;
          }
#line 67
          if (tmp->entry.rbe_parent) {
#line 67
            while (1) {
#line 67
              break;
            }
          }
#line 67
          break;
        }
#line 67
        tmp = parent;
#line 67
        parent = elm;
#line 67
        elm = tmp;
      }
#line 67
      while (1) {
#line 67
        parent->entry.rbe_color = 0;
#line 67
        gparent->entry.rbe_color = 1;
#line 67
        break;
      }
#line 67
      while (1) {
#line 67
        tmp = gparent->entry.rbe_left;
#line 67
        tmp___2 = tmp->entry.rbe_right;
#line 67
        gparent->entry.rbe_left = tmp___2;
#line 67
        if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
#line 67
          (tmp->entry.rbe_right)->entry.rbe_parent = gparent;
        }
#line 67
        while (1) {
#line 67
          break;
        }
#line 67
        tmp___3 = gparent->entry.rbe_parent;
#line 67
        tmp->entry.rbe_parent = tmp___3;
#line 67
        if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
#line 67
          if ((unsigned long )gparent == (unsigned long )(gparent->entry.rbe_parent)->entry.rbe_left) {
#line 67
            (gparent->entry.rbe_parent)->entry.rbe_left = tmp;
          } else {
#line 67
            (gparent->entry.rbe_parent)->entry.rbe_right = tmp;
          }
        } else {
#line 67
          head->rbh_root = tmp;
        }
#line 67
        tmp->entry.rbe_right = gparent;
#line 67
        gparent->entry.rbe_parent = tmp;
#line 67
        while (1) {
#line 67
          break;
        }
#line 67
        if (tmp->entry.rbe_parent) {
#line 67
          while (1) {
#line 67
            break;
          }
        }
#line 67
        break;
      }
    } else {
#line 67
      tmp = gparent->entry.rbe_left;
#line 67
      if (tmp) {
#line 67
        if (tmp->entry.rbe_color == 1) {
#line 67
          tmp->entry.rbe_color = 0;
#line 67
          while (1) {
#line 67
            parent->entry.rbe_color = 0;
#line 67
            gparent->entry.rbe_color = 1;
#line 67
            break;
          }
#line 67
          elm = gparent;
#line 67
          continue;
        }
      }
#line 67
      if ((unsigned long )parent->entry.rbe_left == (unsigned long )elm) {
#line 67
        while (1) {
#line 67
          tmp = parent->entry.rbe_left;
#line 67
          tmp___4 = tmp->entry.rbe_right;
#line 67
          parent->entry.rbe_left = tmp___4;
#line 67
          if ((unsigned long )tmp___4 != (unsigned long )((void *)0)) {
#line 67
            (tmp->entry.rbe_right)->entry.rbe_parent = parent;
          }
#line 67
          while (1) {
#line 67
            break;
          }
#line 67
          tmp___5 = parent->entry.rbe_parent;
#line 67
          tmp->entry.rbe_parent = tmp___5;
#line 67
          if ((unsigned long )tmp___5 != (unsigned long )((void *)0)) {
#line 67
            if ((unsigned long )parent == (unsigned long )(parent->entry.rbe_parent)->entry.rbe_left) {
#line 67
              (parent->entry.rbe_parent)->entry.rbe_left = tmp;
            } else {
#line 67
              (parent->entry.rbe_parent)->entry.rbe_right = tmp;
            }
          } else {
#line 67
            head->rbh_root = tmp;
          }
#line 67
          tmp->entry.rbe_right = parent;
#line 67
          parent->entry.rbe_parent = tmp;
#line 67
          while (1) {
#line 67
            break;
          }
#line 67
          if (tmp->entry.rbe_parent) {
#line 67
            while (1) {
#line 67
              break;
            }
          }
#line 67
          break;
        }
#line 67
        tmp = parent;
#line 67
        parent = elm;
#line 67
        elm = tmp;
      }
#line 67
      while (1) {
#line 67
        parent->entry.rbe_color = 0;
#line 67
        gparent->entry.rbe_color = 1;
#line 67
        break;
      }
#line 67
      while (1) {
#line 67
        tmp = gparent->entry.rbe_right;
#line 67
        tmp___6 = tmp->entry.rbe_left;
#line 67
        gparent->entry.rbe_right = tmp___6;
#line 67
        if ((unsigned long )tmp___6 != (unsigned long )((void *)0)) {
#line 67
          (tmp->entry.rbe_left)->entry.rbe_parent = gparent;
        }
#line 67
        while (1) {
#line 67
          break;
        }
#line 67
        tmp___7 = gparent->entry.rbe_parent;
#line 67
        tmp->entry.rbe_parent = tmp___7;
#line 67
        if ((unsigned long )tmp___7 != (unsigned long )((void *)0)) {
#line 67
          if ((unsigned long )gparent == (unsigned long )(gparent->entry.rbe_parent)->entry.rbe_left) {
#line 67
            (gparent->entry.rbe_parent)->entry.rbe_left = tmp;
          } else {
#line 67
            (gparent->entry.rbe_parent)->entry.rbe_right = tmp;
          }
        } else {
#line 67
          head->rbh_root = tmp;
        }
#line 67
        tmp->entry.rbe_left = gparent;
#line 67
        gparent->entry.rbe_parent = tmp;
#line 67
        while (1) {
#line 67
          break;
        }
#line 67
        if (tmp->entry.rbe_parent) {
#line 67
          while (1) {
#line 67
            break;
          }
        }
#line 67
        break;
      }
    }
  }
#line 67
  (head->rbh_root)->entry.rbe_color = 0;
#line 67
  return;
}
}
#line 67 "tmux_df_2.c"
void winlinks_RB_REMOVE_COLOR(struct winlinks *head , struct winlink *parent , struct winlink *elm ) 
{ 
  struct winlink *tmp ;
  struct winlink *tmp___0 ;
  struct winlink *tmp___1 ;
  struct winlink *oleft ;
  struct winlink *tmp___2 ;
  struct winlink *tmp___3 ;
  struct winlink *tmp___4 ;
  struct winlink *tmp___5 ;
  struct winlink *tmp___6 ;
  struct winlink *tmp___7 ;
  struct winlink *oright ;
  struct winlink *tmp___8 ;
  struct winlink *tmp___9 ;
  struct winlink *tmp___10 ;
  struct winlink *tmp___11 ;

  {
#line 67
  while (1) {
#line 67
    if ((unsigned long )elm == (unsigned long )((void *)0)) {
#line 67
      goto _L___5;
    } else
#line 67
    if (elm->entry.rbe_color == 0) {
      _L___5: /* CIL Label */ 
#line 67
      if (! ((unsigned long )elm != (unsigned long )head->rbh_root)) {
#line 67
        break;
      }
    } else {
#line 67
      break;
    }
#line 67
    if ((unsigned long )parent->entry.rbe_left == (unsigned long )elm) {
#line 67
      tmp = parent->entry.rbe_right;
#line 67
      if (tmp->entry.rbe_color == 1) {
#line 67
        while (1) {
#line 67
          tmp->entry.rbe_color = 0;
#line 67
          parent->entry.rbe_color = 1;
#line 67
          break;
        }
#line 67
        while (1) {
#line 67
          tmp = parent->entry.rbe_right;
#line 67
          tmp___0 = tmp->entry.rbe_left;
#line 67
          parent->entry.rbe_right = tmp___0;
#line 67
          if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 67
            (tmp->entry.rbe_left)->entry.rbe_parent = parent;
          }
#line 67
          while (1) {
#line 67
            break;
          }
#line 67
          tmp___1 = parent->entry.rbe_parent;
#line 67
          tmp->entry.rbe_parent = tmp___1;
#line 67
          if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
#line 67
            if ((unsigned long )parent == (unsigned long )(parent->entry.rbe_parent)->entry.rbe_left) {
#line 67
              (parent->entry.rbe_parent)->entry.rbe_left = tmp;
            } else {
#line 67
              (parent->entry.rbe_parent)->entry.rbe_right = tmp;
            }
          } else {
#line 67
            head->rbh_root = tmp;
          }
#line 67
          tmp->entry.rbe_left = parent;
#line 67
          parent->entry.rbe_parent = tmp;
#line 67
          while (1) {
#line 67
            break;
          }
#line 67
          if (tmp->entry.rbe_parent) {
#line 67
            while (1) {
#line 67
              break;
            }
          }
#line 67
          break;
        }
#line 67
        tmp = parent->entry.rbe_right;
      }
#line 67
      if ((unsigned long )tmp->entry.rbe_left == (unsigned long )((void *)0)) {
#line 67
        goto _L___1;
      } else
#line 67
      if ((tmp->entry.rbe_left)->entry.rbe_color == 0) {
        _L___1: /* CIL Label */ 
#line 67
        if ((unsigned long )tmp->entry.rbe_right == (unsigned long )((void *)0)) {
#line 67
          tmp->entry.rbe_color = 1;
#line 67
          elm = parent;
#line 67
          parent = elm->entry.rbe_parent;
        } else
#line 67
        if ((tmp->entry.rbe_right)->entry.rbe_color == 0) {
#line 67
          tmp->entry.rbe_color = 1;
#line 67
          elm = parent;
#line 67
          parent = elm->entry.rbe_parent;
        } else {
#line 67
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 67
        if ((unsigned long )tmp->entry.rbe_right == (unsigned long )((void *)0)) {
#line 67
          goto _L;
        } else
#line 67
        if ((tmp->entry.rbe_right)->entry.rbe_color == 0) {
          _L: /* CIL Label */ 
#line 67
          oleft = tmp->entry.rbe_left;
#line 67
          if ((unsigned long )oleft != (unsigned long )((void *)0)) {
#line 67
            oleft->entry.rbe_color = 0;
          }
#line 67
          tmp->entry.rbe_color = 1;
#line 67
          while (1) {
#line 67
            oleft = tmp->entry.rbe_left;
#line 67
            tmp___2 = oleft->entry.rbe_right;
#line 67
            tmp->entry.rbe_left = tmp___2;
#line 67
            if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
#line 67
              (oleft->entry.rbe_right)->entry.rbe_parent = tmp;
            }
#line 67
            while (1) {
#line 67
              break;
            }
#line 67
            tmp___3 = tmp->entry.rbe_parent;
#line 67
            oleft->entry.rbe_parent = tmp___3;
#line 67
            if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
#line 67
              if ((unsigned long )tmp == (unsigned long )(tmp->entry.rbe_parent)->entry.rbe_left) {
#line 67
                (tmp->entry.rbe_parent)->entry.rbe_left = oleft;
              } else {
#line 67
                (tmp->entry.rbe_parent)->entry.rbe_right = oleft;
              }
            } else {
#line 67
              head->rbh_root = oleft;
            }
#line 67
            oleft->entry.rbe_right = tmp;
#line 67
            tmp->entry.rbe_parent = oleft;
#line 67
            while (1) {
#line 67
              break;
            }
#line 67
            if (oleft->entry.rbe_parent) {
#line 67
              while (1) {
#line 67
                break;
              }
            }
#line 67
            break;
          }
#line 67
          tmp = parent->entry.rbe_right;
        }
#line 67
        tmp->entry.rbe_color = parent->entry.rbe_color;
#line 67
        parent->entry.rbe_color = 0;
#line 67
        if (tmp->entry.rbe_right) {
#line 67
          (tmp->entry.rbe_right)->entry.rbe_color = 0;
        }
#line 67
        while (1) {
#line 67
          tmp = parent->entry.rbe_right;
#line 67
          tmp___4 = tmp->entry.rbe_left;
#line 67
          parent->entry.rbe_right = tmp___4;
#line 67
          if ((unsigned long )tmp___4 != (unsigned long )((void *)0)) {
#line 67
            (tmp->entry.rbe_left)->entry.rbe_parent = parent;
          }
#line 67
          while (1) {
#line 67
            break;
          }
#line 67
          tmp___5 = parent->entry.rbe_parent;
#line 67
          tmp->entry.rbe_parent = tmp___5;
#line 67
          if ((unsigned long )tmp___5 != (unsigned long )((void *)0)) {
#line 67
            if ((unsigned long )parent == (unsigned long )(parent->entry.rbe_parent)->entry.rbe_left) {
#line 67
              (parent->entry.rbe_parent)->entry.rbe_left = tmp;
            } else {
#line 67
              (parent->entry.rbe_parent)->entry.rbe_right = tmp;
            }
          } else {
#line 67
            head->rbh_root = tmp;
          }
#line 67
          tmp->entry.rbe_left = parent;
#line 67
          parent->entry.rbe_parent = tmp;
#line 67
          while (1) {
#line 67
            break;
          }
#line 67
          if (tmp->entry.rbe_parent) {
#line 67
            while (1) {
#line 67
              break;
            }
          }
#line 67
          break;
        }
#line 67
        elm = head->rbh_root;
#line 67
        break;
      }
    } else {
#line 67
      tmp = parent->entry.rbe_left;
#line 67
      if (tmp->entry.rbe_color == 1) {
#line 67
        while (1) {
#line 67
          tmp->entry.rbe_color = 0;
#line 67
          parent->entry.rbe_color = 1;
#line 67
          break;
        }
#line 67
        while (1) {
#line 67
          tmp = parent->entry.rbe_left;
#line 67
          tmp___6 = tmp->entry.rbe_right;
#line 67
          parent->entry.rbe_left = tmp___6;
#line 67
          if ((unsigned long )tmp___6 != (unsigned long )((void *)0)) {
#line 67
            (tmp->entry.rbe_right)->entry.rbe_parent = parent;
          }
#line 67
          while (1) {
#line 67
            break;
          }
#line 67
          tmp___7 = parent->entry.rbe_parent;
#line 67
          tmp->entry.rbe_parent = tmp___7;
#line 67
          if ((unsigned long )tmp___7 != (unsigned long )((void *)0)) {
#line 67
            if ((unsigned long )parent == (unsigned long )(parent->entry.rbe_parent)->entry.rbe_left) {
#line 67
              (parent->entry.rbe_parent)->entry.rbe_left = tmp;
            } else {
#line 67
              (parent->entry.rbe_parent)->entry.rbe_right = tmp;
            }
          } else {
#line 67
            head->rbh_root = tmp;
          }
#line 67
          tmp->entry.rbe_right = parent;
#line 67
          parent->entry.rbe_parent = tmp;
#line 67
          while (1) {
#line 67
            break;
          }
#line 67
          if (tmp->entry.rbe_parent) {
#line 67
            while (1) {
#line 67
              break;
            }
          }
#line 67
          break;
        }
#line 67
        tmp = parent->entry.rbe_left;
      }
#line 67
      if ((unsigned long )tmp->entry.rbe_left == (unsigned long )((void *)0)) {
#line 67
        goto _L___4;
      } else
#line 67
      if ((tmp->entry.rbe_left)->entry.rbe_color == 0) {
        _L___4: /* CIL Label */ 
#line 67
        if ((unsigned long )tmp->entry.rbe_right == (unsigned long )((void *)0)) {
#line 67
          tmp->entry.rbe_color = 1;
#line 67
          elm = parent;
#line 67
          parent = elm->entry.rbe_parent;
        } else
#line 67
        if ((tmp->entry.rbe_right)->entry.rbe_color == 0) {
#line 67
          tmp->entry.rbe_color = 1;
#line 67
          elm = parent;
#line 67
          parent = elm->entry.rbe_parent;
        } else {
#line 67
          goto _L___3;
        }
      } else {
        _L___3: /* CIL Label */ 
#line 67
        if ((unsigned long )tmp->entry.rbe_left == (unsigned long )((void *)0)) {
#line 67
          goto _L___2;
        } else
#line 67
        if ((tmp->entry.rbe_left)->entry.rbe_color == 0) {
          _L___2: /* CIL Label */ 
#line 67
          oright = tmp->entry.rbe_right;
#line 67
          if ((unsigned long )oright != (unsigned long )((void *)0)) {
#line 67
            oright->entry.rbe_color = 0;
          }
#line 67
          tmp->entry.rbe_color = 1;
#line 67
          while (1) {
#line 67
            oright = tmp->entry.rbe_right;
#line 67
            tmp___8 = oright->entry.rbe_left;
#line 67
            tmp->entry.rbe_right = tmp___8;
#line 67
            if ((unsigned long )tmp___8 != (unsigned long )((void *)0)) {
#line 67
              (oright->entry.rbe_left)->entry.rbe_parent = tmp;
            }
#line 67
            while (1) {
#line 67
              break;
            }
#line 67
            tmp___9 = tmp->entry.rbe_parent;
#line 67
            oright->entry.rbe_parent = tmp___9;
#line 67
            if ((unsigned long )tmp___9 != (unsigned long )((void *)0)) {
#line 67
              if ((unsigned long )tmp == (unsigned long )(tmp->entry.rbe_parent)->entry.rbe_left) {
#line 67
                (tmp->entry.rbe_parent)->entry.rbe_left = oright;
              } else {
#line 67
                (tmp->entry.rbe_parent)->entry.rbe_right = oright;
              }
            } else {
#line 67
              head->rbh_root = oright;
            }
#line 67
            oright->entry.rbe_left = tmp;
#line 67
            tmp->entry.rbe_parent = oright;
#line 67
            while (1) {
#line 67
              break;
            }
#line 67
            if (oright->entry.rbe_parent) {
#line 67
              while (1) {
#line 67
                break;
              }
            }
#line 67
            break;
          }
#line 67
          tmp = parent->entry.rbe_left;
        }
#line 67
        tmp->entry.rbe_color = parent->entry.rbe_color;
#line 67
        parent->entry.rbe_color = 0;
#line 67
        if (tmp->entry.rbe_left) {
#line 67
          (tmp->entry.rbe_left)->entry.rbe_color = 0;
        }
#line 67
        while (1) {
#line 67
          tmp = parent->entry.rbe_left;
#line 67
          tmp___10 = tmp->entry.rbe_right;
#line 67
          parent->entry.rbe_left = tmp___10;
#line 67
          if ((unsigned long )tmp___10 != (unsigned long )((void *)0)) {
#line 67
            (tmp->entry.rbe_right)->entry.rbe_parent = parent;
          }
#line 67
          while (1) {
#line 67
            break;
          }
#line 67
          tmp___11 = parent->entry.rbe_parent;
#line 67
          tmp->entry.rbe_parent = tmp___11;
#line 67
          if ((unsigned long )tmp___11 != (unsigned long )((void *)0)) {
#line 67
            if ((unsigned long )parent == (unsigned long )(parent->entry.rbe_parent)->entry.rbe_left) {
#line 67
              (parent->entry.rbe_parent)->entry.rbe_left = tmp;
            } else {
#line 67
              (parent->entry.rbe_parent)->entry.rbe_right = tmp;
            }
          } else {
#line 67
            head->rbh_root = tmp;
          }
#line 67
          tmp->entry.rbe_right = parent;
#line 67
          parent->entry.rbe_parent = tmp;
#line 67
          while (1) {
#line 67
            break;
          }
#line 67
          if (tmp->entry.rbe_parent) {
#line 67
            while (1) {
#line 67
              break;
            }
          }
#line 67
          break;
        }
#line 67
        elm = head->rbh_root;
#line 67
        break;
      }
    }
  }
#line 67
  if (elm) {
#line 67
    elm->entry.rbe_color = 0;
  }
#line 67
  return;
}
}
#line 67 "tmux_df_2.c"
struct winlink *winlinks_RB_INSERT(struct winlinks *head , struct winlink *elm ) 
{ 
  struct winlink *tmp ;
  struct winlink *parent ;
  int comp ;
  struct winlink *tmp___0 ;

  {
#line 67
  parent = (struct winlink *)((void *)0);
#line 67
  comp = 0;
#line 67
  tmp = head->rbh_root;
#line 67
  while (tmp) {
#line 67
    parent = tmp;
#line 67
    comp = winlink_cmp(elm, parent);
#line 67
    if (comp < 0) {
#line 67
      tmp = tmp->entry.rbe_left;
    } else
#line 67
    if (comp > 0) {
#line 67
      tmp = tmp->entry.rbe_right;
    } else {
#line 67
      return (tmp);
    }
  }
#line 67
  while (1) {
#line 67
    elm->entry.rbe_parent = parent;
#line 67
    tmp___0 = (struct winlink *)((void *)0);
#line 67
    elm->entry.rbe_right = tmp___0;
#line 67
    elm->entry.rbe_left = tmp___0;
#line 67
    elm->entry.rbe_color = 1;
#line 67
    break;
  }
#line 67
  if ((unsigned long )parent != (unsigned long )((void *)0)) {
#line 67
    if (comp < 0) {
#line 67
      parent->entry.rbe_left = elm;
    } else {
#line 67
      parent->entry.rbe_right = elm;
    }
#line 67
    while (1) {
#line 67
      break;
    }
  } else {
#line 67
    head->rbh_root = elm;
  }
#line 67
  winlinks_RB_INSERT_COLOR(head, elm);
#line 67
  return ((struct winlink *)((void *)0));
}
}
#line 67 "tmux_df_2.c"
struct winlink *winlinks_RB_REMOVE(struct winlinks *head , struct winlink *elm ) 
{ 
  struct winlink *child ;
  struct winlink *parent ;
  struct winlink *old ;
  int color ;
  struct winlink *left ;

  {
#line 67
  old = elm;
#line 67
  if ((unsigned long )elm->entry.rbe_left == (unsigned long )((void *)0)) {
#line 67
    child = elm->entry.rbe_right;
  } else
#line 67
  if ((unsigned long )elm->entry.rbe_right == (unsigned long )((void *)0)) {
#line 67
    child = elm->entry.rbe_left;
  } else {
#line 67
    elm = elm->entry.rbe_right;
#line 67
    while (1) {
#line 67
      left = elm->entry.rbe_left;
#line 67
      if (! ((unsigned long )left != (unsigned long )((void *)0))) {
#line 67
        break;
      }
#line 67
      elm = left;
    }
#line 67
    child = elm->entry.rbe_right;
#line 67
    parent = elm->entry.rbe_parent;
#line 67
    color = elm->entry.rbe_color;
#line 67
    if (child) {
#line 67
      child->entry.rbe_parent = parent;
    }
#line 67
    if (parent) {
#line 67
      if ((unsigned long )parent->entry.rbe_left == (unsigned long )elm) {
#line 67
        parent->entry.rbe_left = child;
      } else {
#line 67
        parent->entry.rbe_right = child;
      }
#line 67
      while (1) {
#line 67
        break;
      }
    } else {
#line 67
      head->rbh_root = child;
    }
#line 67
    if ((unsigned long )elm->entry.rbe_parent == (unsigned long )old) {
#line 67
      parent = elm;
    }
#line 67
    elm->entry = old->entry;
#line 67
    if (old->entry.rbe_parent) {
#line 67
      if ((unsigned long )(old->entry.rbe_parent)->entry.rbe_left == (unsigned long )old) {
#line 67
        (old->entry.rbe_parent)->entry.rbe_left = elm;
      } else {
#line 67
        (old->entry.rbe_parent)->entry.rbe_right = elm;
      }
#line 67
      while (1) {
#line 67
        break;
      }
    } else {
#line 67
      head->rbh_root = elm;
    }
#line 67
    (old->entry.rbe_left)->entry.rbe_parent = elm;
#line 67
    if (old->entry.rbe_right) {
#line 67
      (old->entry.rbe_right)->entry.rbe_parent = elm;
    }
#line 67
    if (parent) {
#line 67
      left = parent;
#line 67
      while (1) {
#line 67
        while (1) {
#line 67
          break;
        }
#line 67
        left = left->entry.rbe_parent;
#line 67
        if (! ((unsigned long )left != (unsigned long )((void *)0))) {
#line 67
          break;
        }
      }
    }
#line 67
    goto color;
  }
#line 67
  parent = elm->entry.rbe_parent;
#line 67
  color = elm->entry.rbe_color;
#line 67
  if (child) {
#line 67
    child->entry.rbe_parent = parent;
  }
#line 67
  if (parent) {
#line 67
    if ((unsigned long )parent->entry.rbe_left == (unsigned long )elm) {
#line 67
      parent->entry.rbe_left = child;
    } else {
#line 67
      parent->entry.rbe_right = child;
    }
#line 67
    while (1) {
#line 67
      break;
    }
  } else {
#line 67
    head->rbh_root = child;
  }
  color: 
#line 67
  if (color == 0) {
#line 67
    winlinks_RB_REMOVE_COLOR(head, parent, child);
  }
#line 67
  return (old);
}
}
#line 67 "tmux_df_2.c"
struct winlink *winlinks_RB_FIND(struct winlinks *head , struct winlink *elm ) 
{ 
  struct winlink *tmp ;
  int comp ;

  {
#line 67
  tmp = head->rbh_root;
#line 67
  while (tmp) {
#line 67
    comp = winlink_cmp(elm, tmp);
#line 67
    if (comp < 0) {
#line 67
      tmp = tmp->entry.rbe_left;
    } else
#line 67
    if (comp > 0) {
#line 67
      tmp = tmp->entry.rbe_right;
    } else {
#line 67
      return (tmp);
    }
  }
#line 67
  return ((struct winlink *)((void *)0));
}
}
#line 67 "tmux_df_2.c"
struct winlink *winlinks_RB_NFIND(struct winlinks *head , struct winlink *elm ) 
{ 
  struct winlink *tmp ;
  struct winlink *res ;
  int comp ;

  {
#line 67
  tmp = head->rbh_root;
#line 67
  res = (struct winlink *)((void *)0);
#line 67
  while (tmp) {
#line 67
    comp = winlink_cmp(elm, tmp);
#line 67
    if (comp < 0) {
#line 67
      res = tmp;
#line 67
      tmp = tmp->entry.rbe_left;
    } else
#line 67
    if (comp > 0) {
#line 67
      tmp = tmp->entry.rbe_right;
    } else {
#line 67
      return (tmp);
    }
  }
#line 67
  return (res);
}
}
#line 67 "tmux_df_2.c"
struct winlink *winlinks_RB_NEXT(struct winlink *elm ) 
{ 


  {
#line 67
  if (elm->entry.rbe_right) {
#line 67
    elm = elm->entry.rbe_right;
#line 67
    while (elm->entry.rbe_left) {
#line 67
      elm = elm->entry.rbe_left;
    }
  } else
#line 67
  if (elm->entry.rbe_parent) {
#line 67
    if ((unsigned long )elm == (unsigned long )(elm->entry.rbe_parent)->entry.rbe_left) {
#line 67
      elm = elm->entry.rbe_parent;
    } else {
#line 67
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 67
    while (1) {
#line 67
      if (elm->entry.rbe_parent) {
#line 67
        if (! ((unsigned long )elm == (unsigned long )(elm->entry.rbe_parent)->entry.rbe_right)) {
#line 67
          break;
        }
      } else {
#line 67
        break;
      }
#line 67
      elm = elm->entry.rbe_parent;
    }
#line 67
    elm = elm->entry.rbe_parent;
  }
#line 67
  return (elm);
}
}
#line 67 "tmux_df_2.c"
struct winlink *winlinks_RB_PREV(struct winlink *elm ) 
{ 


  {
#line 67
  if (elm->entry.rbe_left) {
#line 67
    elm = elm->entry.rbe_left;
#line 67
    while (elm->entry.rbe_right) {
#line 67
      elm = elm->entry.rbe_right;
    }
  } else
#line 67
  if (elm->entry.rbe_parent) {
#line 67
    if ((unsigned long )elm == (unsigned long )(elm->entry.rbe_parent)->entry.rbe_right) {
#line 67
      elm = elm->entry.rbe_parent;
    } else {
#line 67
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 67
    while (1) {
#line 67
      if (elm->entry.rbe_parent) {
#line 67
        if (! ((unsigned long )elm == (unsigned long )(elm->entry.rbe_parent)->entry.rbe_left)) {
#line 67
          break;
        }
      } else {
#line 67
        break;
      }
#line 67
      elm = elm->entry.rbe_parent;
    }
#line 67
    elm = elm->entry.rbe_parent;
  }
#line 67
  return (elm);
}
}
#line 67 "tmux_df_2.c"
struct winlink *winlinks_RB_MINMAX(struct winlinks *head , int val ) 
{ 
  struct winlink *tmp ;
  struct winlink *parent ;

  {
#line 67
  tmp = head->rbh_root;
#line 67
  parent = (struct winlink *)((void *)0);
#line 67
  while (tmp) {
#line 67
    parent = tmp;
#line 67
    if (val < 0) {
#line 67
      tmp = tmp->entry.rbe_left;
    } else {
#line 67
      tmp = tmp->entry.rbe_right;
    }
  }
#line 67
  return (parent);
}
}
#line 68 "tmux_df_2.c"
void window_pane_tree_RB_INSERT_COLOR(struct window_pane_tree *head , struct window_pane *elm ) 
{ 
  struct window_pane *parent ;
  struct window_pane *gparent ;
  struct window_pane *tmp ;
  struct window_pane *tmp___0 ;
  struct window_pane *tmp___1 ;
  struct window_pane *tmp___2 ;
  struct window_pane *tmp___3 ;
  struct window_pane *tmp___4 ;
  struct window_pane *tmp___5 ;
  struct window_pane *tmp___6 ;
  struct window_pane *tmp___7 ;

  {
#line 68
  while (1) {
#line 68
    parent = elm->tree_entry.rbe_parent;
#line 68
    if ((unsigned long )parent != (unsigned long )((void *)0)) {
#line 68
      if (! (parent->tree_entry.rbe_color == 1)) {
#line 68
        break;
      }
    } else {
#line 68
      break;
    }
#line 68
    gparent = parent->tree_entry.rbe_parent;
#line 68
    if ((unsigned long )parent == (unsigned long )gparent->tree_entry.rbe_left) {
#line 68
      tmp = gparent->tree_entry.rbe_right;
#line 68
      if (tmp) {
#line 68
        if (tmp->tree_entry.rbe_color == 1) {
#line 68
          tmp->tree_entry.rbe_color = 0;
#line 68
          while (1) {
#line 68
            parent->tree_entry.rbe_color = 0;
#line 68
            gparent->tree_entry.rbe_color = 1;
#line 68
            break;
          }
#line 68
          elm = gparent;
#line 68
          continue;
        }
      }
#line 68
      if ((unsigned long )parent->tree_entry.rbe_right == (unsigned long )elm) {
#line 68
        while (1) {
#line 68
          tmp = parent->tree_entry.rbe_right;
#line 68
          tmp___0 = tmp->tree_entry.rbe_left;
#line 68
          parent->tree_entry.rbe_right = tmp___0;
#line 68
          if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 68
            (tmp->tree_entry.rbe_left)->tree_entry.rbe_parent = parent;
          }
#line 68
          while (1) {
#line 68
            break;
          }
#line 68
          tmp___1 = parent->tree_entry.rbe_parent;
#line 68
          tmp->tree_entry.rbe_parent = tmp___1;
#line 68
          if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
#line 68
            if ((unsigned long )parent == (unsigned long )(parent->tree_entry.rbe_parent)->tree_entry.rbe_left) {
#line 68
              (parent->tree_entry.rbe_parent)->tree_entry.rbe_left = tmp;
            } else {
#line 68
              (parent->tree_entry.rbe_parent)->tree_entry.rbe_right = tmp;
            }
          } else {
#line 68
            head->rbh_root = tmp;
          }
#line 68
          tmp->tree_entry.rbe_left = parent;
#line 68
          parent->tree_entry.rbe_parent = tmp;
#line 68
          while (1) {
#line 68
            break;
          }
#line 68
          if (tmp->tree_entry.rbe_parent) {
#line 68
            while (1) {
#line 68
              break;
            }
          }
#line 68
          break;
        }
#line 68
        tmp = parent;
#line 68
        parent = elm;
#line 68
        elm = tmp;
      }
#line 68
      while (1) {
#line 68
        parent->tree_entry.rbe_color = 0;
#line 68
        gparent->tree_entry.rbe_color = 1;
#line 68
        break;
      }
#line 68
      while (1) {
#line 68
        tmp = gparent->tree_entry.rbe_left;
#line 68
        tmp___2 = tmp->tree_entry.rbe_right;
#line 68
        gparent->tree_entry.rbe_left = tmp___2;
#line 68
        if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
#line 68
          (tmp->tree_entry.rbe_right)->tree_entry.rbe_parent = gparent;
        }
#line 68
        while (1) {
#line 68
          break;
        }
#line 68
        tmp___3 = gparent->tree_entry.rbe_parent;
#line 68
        tmp->tree_entry.rbe_parent = tmp___3;
#line 68
        if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
#line 68
          if ((unsigned long )gparent == (unsigned long )(gparent->tree_entry.rbe_parent)->tree_entry.rbe_left) {
#line 68
            (gparent->tree_entry.rbe_parent)->tree_entry.rbe_left = tmp;
          } else {
#line 68
            (gparent->tree_entry.rbe_parent)->tree_entry.rbe_right = tmp;
          }
        } else {
#line 68
          head->rbh_root = tmp;
        }
#line 68
        tmp->tree_entry.rbe_right = gparent;
#line 68
        gparent->tree_entry.rbe_parent = tmp;
#line 68
        while (1) {
#line 68
          break;
        }
#line 68
        if (tmp->tree_entry.rbe_parent) {
#line 68
          while (1) {
#line 68
            break;
          }
        }
#line 68
        break;
      }
    } else {
#line 68
      tmp = gparent->tree_entry.rbe_left;
#line 68
      if (tmp) {
#line 68
        if (tmp->tree_entry.rbe_color == 1) {
#line 68
          tmp->tree_entry.rbe_color = 0;
#line 68
          while (1) {
#line 68
            parent->tree_entry.rbe_color = 0;
#line 68
            gparent->tree_entry.rbe_color = 1;
#line 68
            break;
          }
#line 68
          elm = gparent;
#line 68
          continue;
        }
      }
#line 68
      if ((unsigned long )parent->tree_entry.rbe_left == (unsigned long )elm) {
#line 68
        while (1) {
#line 68
          tmp = parent->tree_entry.rbe_left;
#line 68
          tmp___4 = tmp->tree_entry.rbe_right;
#line 68
          parent->tree_entry.rbe_left = tmp___4;
#line 68
          if ((unsigned long )tmp___4 != (unsigned long )((void *)0)) {
#line 68
            (tmp->tree_entry.rbe_right)->tree_entry.rbe_parent = parent;
          }
#line 68
          while (1) {
#line 68
            break;
          }
#line 68
          tmp___5 = parent->tree_entry.rbe_parent;
#line 68
          tmp->tree_entry.rbe_parent = tmp___5;
#line 68
          if ((unsigned long )tmp___5 != (unsigned long )((void *)0)) {
#line 68
            if ((unsigned long )parent == (unsigned long )(parent->tree_entry.rbe_parent)->tree_entry.rbe_left) {
#line 68
              (parent->tree_entry.rbe_parent)->tree_entry.rbe_left = tmp;
            } else {
#line 68
              (parent->tree_entry.rbe_parent)->tree_entry.rbe_right = tmp;
            }
          } else {
#line 68
            head->rbh_root = tmp;
          }
#line 68
          tmp->tree_entry.rbe_right = parent;
#line 68
          parent->tree_entry.rbe_parent = tmp;
#line 68
          while (1) {
#line 68
            break;
          }
#line 68
          if (tmp->tree_entry.rbe_parent) {
#line 68
            while (1) {
#line 68
              break;
            }
          }
#line 68
          break;
        }
#line 68
        tmp = parent;
#line 68
        parent = elm;
#line 68
        elm = tmp;
      }
#line 68
      while (1) {
#line 68
        parent->tree_entry.rbe_color = 0;
#line 68
        gparent->tree_entry.rbe_color = 1;
#line 68
        break;
      }
#line 68
      while (1) {
#line 68
        tmp = gparent->tree_entry.rbe_right;
#line 68
        tmp___6 = tmp->tree_entry.rbe_left;
#line 68
        gparent->tree_entry.rbe_right = tmp___6;
#line 68
        if ((unsigned long )tmp___6 != (unsigned long )((void *)0)) {
#line 68
          (tmp->tree_entry.rbe_left)->tree_entry.rbe_parent = gparent;
        }
#line 68
        while (1) {
#line 68
          break;
        }
#line 68
        tmp___7 = gparent->tree_entry.rbe_parent;
#line 68
        tmp->tree_entry.rbe_parent = tmp___7;
#line 68
        if ((unsigned long )tmp___7 != (unsigned long )((void *)0)) {
#line 68
          if ((unsigned long )gparent == (unsigned long )(gparent->tree_entry.rbe_parent)->tree_entry.rbe_left) {
#line 68
            (gparent->tree_entry.rbe_parent)->tree_entry.rbe_left = tmp;
          } else {
#line 68
            (gparent->tree_entry.rbe_parent)->tree_entry.rbe_right = tmp;
          }
        } else {
#line 68
          head->rbh_root = tmp;
        }
#line 68
        tmp->tree_entry.rbe_left = gparent;
#line 68
        gparent->tree_entry.rbe_parent = tmp;
#line 68
        while (1) {
#line 68
          break;
        }
#line 68
        if (tmp->tree_entry.rbe_parent) {
#line 68
          while (1) {
#line 68
            break;
          }
        }
#line 68
        break;
      }
    }
  }
#line 68
  (head->rbh_root)->tree_entry.rbe_color = 0;
#line 68
  return;
}
}
#line 68 "tmux_df_2.c"
void window_pane_tree_RB_REMOVE_COLOR(struct window_pane_tree *head , struct window_pane *parent ,
                                      struct window_pane *elm ) 
{ 
  struct window_pane *tmp ;
  struct window_pane *tmp___0 ;
  struct window_pane *tmp___1 ;
  struct window_pane *oleft ;
  struct window_pane *tmp___2 ;
  struct window_pane *tmp___3 ;
  struct window_pane *tmp___4 ;
  struct window_pane *tmp___5 ;
  struct window_pane *tmp___6 ;
  struct window_pane *tmp___7 ;
  struct window_pane *oright ;
  struct window_pane *tmp___8 ;
  struct window_pane *tmp___9 ;
  struct window_pane *tmp___10 ;
  struct window_pane *tmp___11 ;

  {
#line 68
  while (1) {
#line 68
    if ((unsigned long )elm == (unsigned long )((void *)0)) {
#line 68
      goto _L___5;
    } else
#line 68
    if (elm->tree_entry.rbe_color == 0) {
      _L___5: /* CIL Label */ 
#line 68
      if (! ((unsigned long )elm != (unsigned long )head->rbh_root)) {
#line 68
        break;
      }
    } else {
#line 68
      break;
    }
#line 68
    if ((unsigned long )parent->tree_entry.rbe_left == (unsigned long )elm) {
#line 68
      tmp = parent->tree_entry.rbe_right;
#line 68
      if (tmp->tree_entry.rbe_color == 1) {
#line 68
        while (1) {
#line 68
          tmp->tree_entry.rbe_color = 0;
#line 68
          parent->tree_entry.rbe_color = 1;
#line 68
          break;
        }
#line 68
        while (1) {
#line 68
          tmp = parent->tree_entry.rbe_right;
#line 68
          tmp___0 = tmp->tree_entry.rbe_left;
#line 68
          parent->tree_entry.rbe_right = tmp___0;
#line 68
          if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 68
            (tmp->tree_entry.rbe_left)->tree_entry.rbe_parent = parent;
          }
#line 68
          while (1) {
#line 68
            break;
          }
#line 68
          tmp___1 = parent->tree_entry.rbe_parent;
#line 68
          tmp->tree_entry.rbe_parent = tmp___1;
#line 68
          if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
#line 68
            if ((unsigned long )parent == (unsigned long )(parent->tree_entry.rbe_parent)->tree_entry.rbe_left) {
#line 68
              (parent->tree_entry.rbe_parent)->tree_entry.rbe_left = tmp;
            } else {
#line 68
              (parent->tree_entry.rbe_parent)->tree_entry.rbe_right = tmp;
            }
          } else {
#line 68
            head->rbh_root = tmp;
          }
#line 68
          tmp->tree_entry.rbe_left = parent;
#line 68
          parent->tree_entry.rbe_parent = tmp;
#line 68
          while (1) {
#line 68
            break;
          }
#line 68
          if (tmp->tree_entry.rbe_parent) {
#line 68
            while (1) {
#line 68
              break;
            }
          }
#line 68
          break;
        }
#line 68
        tmp = parent->tree_entry.rbe_right;
      }
#line 68
      if ((unsigned long )tmp->tree_entry.rbe_left == (unsigned long )((void *)0)) {
#line 68
        goto _L___1;
      } else
#line 68
      if ((tmp->tree_entry.rbe_left)->tree_entry.rbe_color == 0) {
        _L___1: /* CIL Label */ 
#line 68
        if ((unsigned long )tmp->tree_entry.rbe_right == (unsigned long )((void *)0)) {
#line 68
          tmp->tree_entry.rbe_color = 1;
#line 68
          elm = parent;
#line 68
          parent = elm->tree_entry.rbe_parent;
        } else
#line 68
        if ((tmp->tree_entry.rbe_right)->tree_entry.rbe_color == 0) {
#line 68
          tmp->tree_entry.rbe_color = 1;
#line 68
          elm = parent;
#line 68
          parent = elm->tree_entry.rbe_parent;
        } else {
#line 68
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 68
        if ((unsigned long )tmp->tree_entry.rbe_right == (unsigned long )((void *)0)) {
#line 68
          goto _L;
        } else
#line 68
        if ((tmp->tree_entry.rbe_right)->tree_entry.rbe_color == 0) {
          _L: /* CIL Label */ 
#line 68
          oleft = tmp->tree_entry.rbe_left;
#line 68
          if ((unsigned long )oleft != (unsigned long )((void *)0)) {
#line 68
            oleft->tree_entry.rbe_color = 0;
          }
#line 68
          tmp->tree_entry.rbe_color = 1;
#line 68
          while (1) {
#line 68
            oleft = tmp->tree_entry.rbe_left;
#line 68
            tmp___2 = oleft->tree_entry.rbe_right;
#line 68
            tmp->tree_entry.rbe_left = tmp___2;
#line 68
            if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
#line 68
              (oleft->tree_entry.rbe_right)->tree_entry.rbe_parent = tmp;
            }
#line 68
            while (1) {
#line 68
              break;
            }
#line 68
            tmp___3 = tmp->tree_entry.rbe_parent;
#line 68
            oleft->tree_entry.rbe_parent = tmp___3;
#line 68
            if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
#line 68
              if ((unsigned long )tmp == (unsigned long )(tmp->tree_entry.rbe_parent)->tree_entry.rbe_left) {
#line 68
                (tmp->tree_entry.rbe_parent)->tree_entry.rbe_left = oleft;
              } else {
#line 68
                (tmp->tree_entry.rbe_parent)->tree_entry.rbe_right = oleft;
              }
            } else {
#line 68
              head->rbh_root = oleft;
            }
#line 68
            oleft->tree_entry.rbe_right = tmp;
#line 68
            tmp->tree_entry.rbe_parent = oleft;
#line 68
            while (1) {
#line 68
              break;
            }
#line 68
            if (oleft->tree_entry.rbe_parent) {
#line 68
              while (1) {
#line 68
                break;
              }
            }
#line 68
            break;
          }
#line 68
          tmp = parent->tree_entry.rbe_right;
        }
#line 68
        tmp->tree_entry.rbe_color = parent->tree_entry.rbe_color;
#line 68
        parent->tree_entry.rbe_color = 0;
#line 68
        if (tmp->tree_entry.rbe_right) {
#line 68
          (tmp->tree_entry.rbe_right)->tree_entry.rbe_color = 0;
        }
#line 68
        while (1) {
#line 68
          tmp = parent->tree_entry.rbe_right;
#line 68
          tmp___4 = tmp->tree_entry.rbe_left;
#line 68
          parent->tree_entry.rbe_right = tmp___4;
#line 68
          if ((unsigned long )tmp___4 != (unsigned long )((void *)0)) {
#line 68
            (tmp->tree_entry.rbe_left)->tree_entry.rbe_parent = parent;
          }
#line 68
          while (1) {
#line 68
            break;
          }
#line 68
          tmp___5 = parent->tree_entry.rbe_parent;
#line 68
          tmp->tree_entry.rbe_parent = tmp___5;
#line 68
          if ((unsigned long )tmp___5 != (unsigned long )((void *)0)) {
#line 68
            if ((unsigned long )parent == (unsigned long )(parent->tree_entry.rbe_parent)->tree_entry.rbe_left) {
#line 68
              (parent->tree_entry.rbe_parent)->tree_entry.rbe_left = tmp;
            } else {
#line 68
              (parent->tree_entry.rbe_parent)->tree_entry.rbe_right = tmp;
            }
          } else {
#line 68
            head->rbh_root = tmp;
          }
#line 68
          tmp->tree_entry.rbe_left = parent;
#line 68
          parent->tree_entry.rbe_parent = tmp;
#line 68
          while (1) {
#line 68
            break;
          }
#line 68
          if (tmp->tree_entry.rbe_parent) {
#line 68
            while (1) {
#line 68
              break;
            }
          }
#line 68
          break;
        }
#line 68
        elm = head->rbh_root;
#line 68
        break;
      }
    } else {
#line 68
      tmp = parent->tree_entry.rbe_left;
#line 68
      if (tmp->tree_entry.rbe_color == 1) {
#line 68
        while (1) {
#line 68
          tmp->tree_entry.rbe_color = 0;
#line 68
          parent->tree_entry.rbe_color = 1;
#line 68
          break;
        }
#line 68
        while (1) {
#line 68
          tmp = parent->tree_entry.rbe_left;
#line 68
          tmp___6 = tmp->tree_entry.rbe_right;
#line 68
          parent->tree_entry.rbe_left = tmp___6;
#line 68
          if ((unsigned long )tmp___6 != (unsigned long )((void *)0)) {
#line 68
            (tmp->tree_entry.rbe_right)->tree_entry.rbe_parent = parent;
          }
#line 68
          while (1) {
#line 68
            break;
          }
#line 68
          tmp___7 = parent->tree_entry.rbe_parent;
#line 68
          tmp->tree_entry.rbe_parent = tmp___7;
#line 68
          if ((unsigned long )tmp___7 != (unsigned long )((void *)0)) {
#line 68
            if ((unsigned long )parent == (unsigned long )(parent->tree_entry.rbe_parent)->tree_entry.rbe_left) {
#line 68
              (parent->tree_entry.rbe_parent)->tree_entry.rbe_left = tmp;
            } else {
#line 68
              (parent->tree_entry.rbe_parent)->tree_entry.rbe_right = tmp;
            }
          } else {
#line 68
            head->rbh_root = tmp;
          }
#line 68
          tmp->tree_entry.rbe_right = parent;
#line 68
          parent->tree_entry.rbe_parent = tmp;
#line 68
          while (1) {
#line 68
            break;
          }
#line 68
          if (tmp->tree_entry.rbe_parent) {
#line 68
            while (1) {
#line 68
              break;
            }
          }
#line 68
          break;
        }
#line 68
        tmp = parent->tree_entry.rbe_left;
      }
#line 68
      if ((unsigned long )tmp->tree_entry.rbe_left == (unsigned long )((void *)0)) {
#line 68
        goto _L___4;
      } else
#line 68
      if ((tmp->tree_entry.rbe_left)->tree_entry.rbe_color == 0) {
        _L___4: /* CIL Label */ 
#line 68
        if ((unsigned long )tmp->tree_entry.rbe_right == (unsigned long )((void *)0)) {
#line 68
          tmp->tree_entry.rbe_color = 1;
#line 68
          elm = parent;
#line 68
          parent = elm->tree_entry.rbe_parent;
        } else
#line 68
        if ((tmp->tree_entry.rbe_right)->tree_entry.rbe_color == 0) {
#line 68
          tmp->tree_entry.rbe_color = 1;
#line 68
          elm = parent;
#line 68
          parent = elm->tree_entry.rbe_parent;
        } else {
#line 68
          goto _L___3;
        }
      } else {
        _L___3: /* CIL Label */ 
#line 68
        if ((unsigned long )tmp->tree_entry.rbe_left == (unsigned long )((void *)0)) {
#line 68
          goto _L___2;
        } else
#line 68
        if ((tmp->tree_entry.rbe_left)->tree_entry.rbe_color == 0) {
          _L___2: /* CIL Label */ 
#line 68
          oright = tmp->tree_entry.rbe_right;
#line 68
          if ((unsigned long )oright != (unsigned long )((void *)0)) {
#line 68
            oright->tree_entry.rbe_color = 0;
          }
#line 68
          tmp->tree_entry.rbe_color = 1;
#line 68
          while (1) {
#line 68
            oright = tmp->tree_entry.rbe_right;
#line 68
            tmp___8 = oright->tree_entry.rbe_left;
#line 68
            tmp->tree_entry.rbe_right = tmp___8;
#line 68
            if ((unsigned long )tmp___8 != (unsigned long )((void *)0)) {
#line 68
              (oright->tree_entry.rbe_left)->tree_entry.rbe_parent = tmp;
            }
#line 68
            while (1) {
#line 68
              break;
            }
#line 68
            tmp___9 = tmp->tree_entry.rbe_parent;
#line 68
            oright->tree_entry.rbe_parent = tmp___9;
#line 68
            if ((unsigned long )tmp___9 != (unsigned long )((void *)0)) {
#line 68
              if ((unsigned long )tmp == (unsigned long )(tmp->tree_entry.rbe_parent)->tree_entry.rbe_left) {
#line 68
                (tmp->tree_entry.rbe_parent)->tree_entry.rbe_left = oright;
              } else {
#line 68
                (tmp->tree_entry.rbe_parent)->tree_entry.rbe_right = oright;
              }
            } else {
#line 68
              head->rbh_root = oright;
            }
#line 68
            oright->tree_entry.rbe_left = tmp;
#line 68
            tmp->tree_entry.rbe_parent = oright;
#line 68
            while (1) {
#line 68
              break;
            }
#line 68
            if (oright->tree_entry.rbe_parent) {
#line 68
              while (1) {
#line 68
                break;
              }
            }
#line 68
            break;
          }
#line 68
          tmp = parent->tree_entry.rbe_left;
        }
#line 68
        tmp->tree_entry.rbe_color = parent->tree_entry.rbe_color;
#line 68
        parent->tree_entry.rbe_color = 0;
#line 68
        if (tmp->tree_entry.rbe_left) {
#line 68
          (tmp->tree_entry.rbe_left)->tree_entry.rbe_color = 0;
        }
#line 68
        while (1) {
#line 68
          tmp = parent->tree_entry.rbe_left;
#line 68
          tmp___10 = tmp->tree_entry.rbe_right;
#line 68
          parent->tree_entry.rbe_left = tmp___10;
#line 68
          if ((unsigned long )tmp___10 != (unsigned long )((void *)0)) {
#line 68
            (tmp->tree_entry.rbe_right)->tree_entry.rbe_parent = parent;
          }
#line 68
          while (1) {
#line 68
            break;
          }
#line 68
          tmp___11 = parent->tree_entry.rbe_parent;
#line 68
          tmp->tree_entry.rbe_parent = tmp___11;
#line 68
          if ((unsigned long )tmp___11 != (unsigned long )((void *)0)) {
#line 68
            if ((unsigned long )parent == (unsigned long )(parent->tree_entry.rbe_parent)->tree_entry.rbe_left) {
#line 68
              (parent->tree_entry.rbe_parent)->tree_entry.rbe_left = tmp;
            } else {
#line 68
              (parent->tree_entry.rbe_parent)->tree_entry.rbe_right = tmp;
            }
          } else {
#line 68
            head->rbh_root = tmp;
          }
#line 68
          tmp->tree_entry.rbe_right = parent;
#line 68
          parent->tree_entry.rbe_parent = tmp;
#line 68
          while (1) {
#line 68
            break;
          }
#line 68
          if (tmp->tree_entry.rbe_parent) {
#line 68
            while (1) {
#line 68
              break;
            }
          }
#line 68
          break;
        }
#line 68
        elm = head->rbh_root;
#line 68
        break;
      }
    }
  }
#line 68
  if (elm) {
#line 68
    elm->tree_entry.rbe_color = 0;
  }
#line 68
  return;
}
}
#line 68 "tmux_df_2.c"
struct window_pane *window_pane_tree_RB_INSERT(struct window_pane_tree *head , struct window_pane *elm ) 
{ 
  struct window_pane *tmp ;
  struct window_pane *parent ;
  int comp ;
  struct window_pane *tmp___0 ;

  {
#line 68
  parent = (struct window_pane *)((void *)0);
#line 68
  comp = 0;
#line 68
  tmp = head->rbh_root;
#line 68
  while (tmp) {
#line 68
    parent = tmp;
#line 68
    comp = window_pane_cmp(elm, parent);
#line 68
    if (comp < 0) {
#line 68
      tmp = tmp->tree_entry.rbe_left;
    } else
#line 68
    if (comp > 0) {
#line 68
      tmp = tmp->tree_entry.rbe_right;
    } else {
#line 68
      return (tmp);
    }
  }
#line 68
  while (1) {
#line 68
    elm->tree_entry.rbe_parent = parent;
#line 68
    tmp___0 = (struct window_pane *)((void *)0);
#line 68
    elm->tree_entry.rbe_right = tmp___0;
#line 68
    elm->tree_entry.rbe_left = tmp___0;
#line 68
    elm->tree_entry.rbe_color = 1;
#line 68
    break;
  }
#line 68
  if ((unsigned long )parent != (unsigned long )((void *)0)) {
#line 68
    if (comp < 0) {
#line 68
      parent->tree_entry.rbe_left = elm;
    } else {
#line 68
      parent->tree_entry.rbe_right = elm;
    }
#line 68
    while (1) {
#line 68
      break;
    }
  } else {
#line 68
    head->rbh_root = elm;
  }
#line 68
  window_pane_tree_RB_INSERT_COLOR(head, elm);
#line 68
  return ((struct window_pane *)((void *)0));
}
}
#line 68 "tmux_df_2.c"
struct window_pane *window_pane_tree_RB_REMOVE(struct window_pane_tree *head , struct window_pane *elm ) 
{ 
  struct window_pane *child ;
  struct window_pane *parent ;
  struct window_pane *old ;
  int color ;
  struct window_pane *left ;

  {
#line 68
  old = elm;
#line 68
  if ((unsigned long )elm->tree_entry.rbe_left == (unsigned long )((void *)0)) {
#line 68
    child = elm->tree_entry.rbe_right;
  } else
#line 68
  if ((unsigned long )elm->tree_entry.rbe_right == (unsigned long )((void *)0)) {
#line 68
    child = elm->tree_entry.rbe_left;
  } else {
#line 68
    elm = elm->tree_entry.rbe_right;
#line 68
    while (1) {
#line 68
      left = elm->tree_entry.rbe_left;
#line 68
      if (! ((unsigned long )left != (unsigned long )((void *)0))) {
#line 68
        break;
      }
#line 68
      elm = left;
    }
#line 68
    child = elm->tree_entry.rbe_right;
#line 68
    parent = elm->tree_entry.rbe_parent;
#line 68
    color = elm->tree_entry.rbe_color;
#line 68
    if (child) {
#line 68
      child->tree_entry.rbe_parent = parent;
    }
#line 68
    if (parent) {
#line 68
      if ((unsigned long )parent->tree_entry.rbe_left == (unsigned long )elm) {
#line 68
        parent->tree_entry.rbe_left = child;
      } else {
#line 68
        parent->tree_entry.rbe_right = child;
      }
#line 68
      while (1) {
#line 68
        break;
      }
    } else {
#line 68
      head->rbh_root = child;
    }
#line 68
    if ((unsigned long )elm->tree_entry.rbe_parent == (unsigned long )old) {
#line 68
      parent = elm;
    }
#line 68
    elm->tree_entry = old->tree_entry;
#line 68
    if (old->tree_entry.rbe_parent) {
#line 68
      if ((unsigned long )(old->tree_entry.rbe_parent)->tree_entry.rbe_left == (unsigned long )old) {
#line 68
        (old->tree_entry.rbe_parent)->tree_entry.rbe_left = elm;
      } else {
#line 68
        (old->tree_entry.rbe_parent)->tree_entry.rbe_right = elm;
      }
#line 68
      while (1) {
#line 68
        break;
      }
    } else {
#line 68
      head->rbh_root = elm;
    }
#line 68
    (old->tree_entry.rbe_left)->tree_entry.rbe_parent = elm;
#line 68
    if (old->tree_entry.rbe_right) {
#line 68
      (old->tree_entry.rbe_right)->tree_entry.rbe_parent = elm;
    }
#line 68
    if (parent) {
#line 68
      left = parent;
#line 68
      while (1) {
#line 68
        while (1) {
#line 68
          break;
        }
#line 68
        left = left->tree_entry.rbe_parent;
#line 68
        if (! ((unsigned long )left != (unsigned long )((void *)0))) {
#line 68
          break;
        }
      }
    }
#line 68
    goto color;
  }
#line 68
  parent = elm->tree_entry.rbe_parent;
#line 68
  color = elm->tree_entry.rbe_color;
#line 68
  if (child) {
#line 68
    child->tree_entry.rbe_parent = parent;
  }
#line 68
  if (parent) {
#line 68
    if ((unsigned long )parent->tree_entry.rbe_left == (unsigned long )elm) {
#line 68
      parent->tree_entry.rbe_left = child;
    } else {
#line 68
      parent->tree_entry.rbe_right = child;
    }
#line 68
    while (1) {
#line 68
      break;
    }
  } else {
#line 68
    head->rbh_root = child;
  }
  color: 
#line 68
  if (color == 0) {
#line 68
    window_pane_tree_RB_REMOVE_COLOR(head, parent, child);
  }
#line 68
  return (old);
}
}
#line 68 "tmux_df_2.c"
struct window_pane *window_pane_tree_RB_FIND(struct window_pane_tree *head , struct window_pane *elm ) 
{ 
  struct window_pane *tmp ;
  int comp ;

  {
#line 68
  tmp = head->rbh_root;
#line 68
  while (tmp) {
#line 68
    comp = window_pane_cmp(elm, tmp);
#line 68
    if (comp < 0) {
#line 68
      tmp = tmp->tree_entry.rbe_left;
    } else
#line 68
    if (comp > 0) {
#line 68
      tmp = tmp->tree_entry.rbe_right;
    } else {
#line 68
      return (tmp);
    }
  }
#line 68
  return ((struct window_pane *)((void *)0));
}
}
#line 68 "tmux_df_2.c"
struct window_pane *window_pane_tree_RB_NFIND(struct window_pane_tree *head , struct window_pane *elm ) 
{ 
  struct window_pane *tmp ;
  struct window_pane *res ;
  int comp ;

  {
#line 68
  tmp = head->rbh_root;
#line 68
  res = (struct window_pane *)((void *)0);
#line 68
  while (tmp) {
#line 68
    comp = window_pane_cmp(elm, tmp);
#line 68
    if (comp < 0) {
#line 68
      res = tmp;
#line 68
      tmp = tmp->tree_entry.rbe_left;
    } else
#line 68
    if (comp > 0) {
#line 68
      tmp = tmp->tree_entry.rbe_right;
    } else {
#line 68
      return (tmp);
    }
  }
#line 68
  return (res);
}
}
#line 68 "tmux_df_2.c"
struct window_pane *window_pane_tree_RB_NEXT(struct window_pane *elm ) 
{ 


  {
#line 68
  if (elm->tree_entry.rbe_right) {
#line 68
    elm = elm->tree_entry.rbe_right;
#line 68
    while (elm->tree_entry.rbe_left) {
#line 68
      elm = elm->tree_entry.rbe_left;
    }
  } else
#line 68
  if (elm->tree_entry.rbe_parent) {
#line 68
    if ((unsigned long )elm == (unsigned long )(elm->tree_entry.rbe_parent)->tree_entry.rbe_left) {
#line 68
      elm = elm->tree_entry.rbe_parent;
    } else {
#line 68
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 68
    while (1) {
#line 68
      if (elm->tree_entry.rbe_parent) {
#line 68
        if (! ((unsigned long )elm == (unsigned long )(elm->tree_entry.rbe_parent)->tree_entry.rbe_right)) {
#line 68
          break;
        }
      } else {
#line 68
        break;
      }
#line 68
      elm = elm->tree_entry.rbe_parent;
    }
#line 68
    elm = elm->tree_entry.rbe_parent;
  }
#line 68
  return (elm);
}
}
#line 68 "tmux_df_2.c"
struct window_pane *window_pane_tree_RB_PREV(struct window_pane *elm ) 
{ 


  {
#line 68
  if (elm->tree_entry.rbe_left) {
#line 68
    elm = elm->tree_entry.rbe_left;
#line 68
    while (elm->tree_entry.rbe_right) {
#line 68
      elm = elm->tree_entry.rbe_right;
    }
  } else
#line 68
  if (elm->tree_entry.rbe_parent) {
#line 68
    if ((unsigned long )elm == (unsigned long )(elm->tree_entry.rbe_parent)->tree_entry.rbe_right) {
#line 68
      elm = elm->tree_entry.rbe_parent;
    } else {
#line 68
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 68
    while (1) {
#line 68
      if (elm->tree_entry.rbe_parent) {
#line 68
        if (! ((unsigned long )elm == (unsigned long )(elm->tree_entry.rbe_parent)->tree_entry.rbe_left)) {
#line 68
          break;
        }
      } else {
#line 68
        break;
      }
#line 68
      elm = elm->tree_entry.rbe_parent;
    }
#line 68
    elm = elm->tree_entry.rbe_parent;
  }
#line 68
  return (elm);
}
}
#line 68 "tmux_df_2.c"
struct window_pane *window_pane_tree_RB_MINMAX(struct window_pane_tree *head , int val ) 
{ 
  struct window_pane *tmp ;
  struct window_pane *parent ;

  {
#line 68
  tmp = head->rbh_root;
#line 68
  parent = (struct window_pane *)((void *)0);
#line 68
  while (tmp) {
#line 68
    parent = tmp;
#line 68
    if (val < 0) {
#line 68
      tmp = tmp->tree_entry.rbe_left;
    } else {
#line 68
      tmp = tmp->tree_entry.rbe_right;
    }
  }
#line 68
  return (parent);
}
}
#line 72 "tmux_df_2.c"
struct layout_cell *layout_create_cell(struct layout_cell *lcparent ) 
{ 
  struct layout_cell *lc ;
  void *tmp ;

  {
#line 77
  tmp = malloc(sizeof(*lc));
#line 77
  lc = (struct layout_cell *)tmp;
#line 78
  lc->type = (enum layout_type )2;
#line 79
  lc->parent = lcparent;
#line 81
  while (1) {
#line 81
    lc->cells.tqh_first = (struct layout_cell *)((void *)0);
#line 81
    lc->cells.tqh_last = & lc->cells.tqh_first;
#line 81
    break;
  }
#line 83
  lc->sx = (u_int___0 )(1 << 30);
#line 84
  lc->sy = (u_int___0 )(1 << 30);
#line 86
  lc->xoff = (u_int___0 )(1 << 30);
#line 87
  lc->yoff = (u_int___0 )(1 << 30);
#line 89
  lc->wp = (struct window_pane *)((void *)0);
#line 91
  return (lc);
}
}
#line 94 "tmux_df_2.c"
void layout_set_size(struct layout_cell *lc , u_int___0 sx , u_int___0 sy , u_int___0 xoff ,
                     u_int___0 yoff ) 
{ 


  {
#line 98
  lc->sx = sx;
#line 99
  lc->sy = sy;
#line 101
  lc->xoff = xoff;
#line 102
  lc->yoff = yoff;
#line 103
  return;
}
}
#line 105 "tmux_df_2.c"
void layout_make_leaf(struct layout_cell *lc , struct window_pane *wp ) 
{ 


  {
#line 108
  lc->type = (enum layout_type )2;
#line 110
  while (1) {
#line 110
    lc->cells.tqh_first = (struct layout_cell *)((void *)0);
#line 110
    lc->cells.tqh_last = & lc->cells.tqh_first;
#line 110
    break;
  }
#line 112
  wp->layout_cell = lc;
#line 113
  lc->wp = wp;
#line 114
  return;
}
}
#line 116 "tmux_df_2.c"
void layout_free_cell(struct layout_cell *lc ) 
{ 
  struct layout_cell *lcchild ;

  {
#line 121
  switch ((unsigned int )lc->type) {
  case 1U: 
  case 0U: 
#line 124
  while (! ((unsigned long )lc->cells.tqh_first == (unsigned long )((void *)0))) {
#line 125
    lcchild = lc->cells.tqh_first;
#line 126
    while (1) {
#line 126
      if ((unsigned long )lcchild->entry.tqe_next != (unsigned long )((void *)0)) {
#line 126
        (lcchild->entry.tqe_next)->entry.tqe_prev = lcchild->entry.tqe_prev;
      } else {
#line 126
        lc->cells.tqh_last = lcchild->entry.tqe_prev;
      }
#line 126
      *(lcchild->entry.tqe_prev) = lcchild->entry.tqe_next;
#line 126
      break;
    }
#line 127
    layout_free_cell(lcchild);
  }
#line 129
  break;
  case 2U: 
#line 131
  if ((unsigned long )lc->wp != (unsigned long )((void *)0)) {
#line 132
    (lc->wp)->layout_cell = (struct layout_cell *)((void *)0);
  }
#line 133
  break;
  }
#line 136
  free((void *)lc);
#line 137
  return;
}
}
#line 139 "tmux_df_2.c"
void layout_free(struct window *w ) 
{ 


  {
#line 142
  layout_free_cell(w->layout_root);
#line 143
  return;
}
}
#line 146 "tmux_df_2.c"
void layout_init(struct window *w , struct window_pane *wp ) 
{ 
  struct layout_cell *lc ;
  struct layout_cell *tmp ;

  {
#line 151
  tmp = layout_create_cell((struct layout_cell *)((void *)0));
#line 151
  w->layout_root = tmp;
#line 151
  lc = tmp;
#line 152
  layout_set_size(lc, w->sx, w->sy, (u_int___0 )0, (u_int___0 )0);
#line 153
  layout_make_leaf(lc, wp);
#line 154
  return;
}
}
#line 156 "tmux_df_2.c"
u_int___0 window_count_panes(struct window *w ) 
{ 
  struct window_pane *wp ;
  u_int___0 n ;

  {
#line 162
  n = (u_int___0 )0;
#line 163
  wp = w->panes.tqh_first;
#line 163
  while (wp) {
#line 164
    n ++;
#line 163
    wp = wp->entry.tqe_next;
  }
#line 165
  return (n);
}
}
#line 169 "tmux_df_2.c"
void notify_window_layout_changed(struct window *w ) 
{ 


  {
#line 172
  notify_add((enum notify_type )0, (struct client *)((void *)0), (struct session *)((void *)0),
             w);
#line 173
  notify_drain();
#line 174
  return;
}
}
#line 185
int window_pane_visible(struct window_pane *wp ) ;
#line 176 "tmux_df_2.c"
int window_zoom(struct window_pane *wp ) 
{ 
  struct window *w ;
  struct window_pane *wp1 ;
  int tmp ;
  u_int___0 tmp___0 ;

  {
#line 179
  w = wp->window;
#line 182
  if (w->flags & 4096) {
#line 183
    return (-1);
  }
#line 185
  tmp = window_pane_visible(wp);
#line 185
  if (! tmp) {
#line 186
    return (-1);
  }
#line 188
  tmp___0 = window_count_panes(w);
#line 188
  if (tmp___0 == 1U) {
#line 189
    return (-1);
  }
#line 191
  wp1 = w->panes.tqh_first;
#line 191
  while (wp1) {
#line 192
    wp1->saved_layout_cell = wp1->layout_cell;
#line 193
    wp1->layout_cell = (struct layout_cell *)((void *)0);
#line 191
    wp1 = wp1->entry.tqe_next;
  }
#line 196
  w->saved_layout_root = w->layout_root;
#line 197
  layout_init(w, wp);
#line 198
  w->flags |= 4096;
#line 199
  notify_window_layout_changed(w);
#line 201
  return (0);
}
}
#line 203 "tmux_df_2.c"
int window_unzoom(struct window *w ) 
{ 
  struct window_pane *wp ;

  {
#line 208
  if (! (w->flags & 4096)) {
#line 209
    return (-1);
  }
#line 211
  w->flags &= -4097;
#line 212
  layout_free(w);
#line 213
  w->layout_root = w->saved_layout_root;
#line 214
  w->saved_layout_root = (struct layout_cell *)((void *)0);
#line 216
  wp = w->panes.tqh_first;
#line 216
  while (wp) {
#line 217
    wp->layout_cell = wp->saved_layout_cell;
#line 218
    wp->saved_layout_cell = (struct layout_cell *)((void *)0);
#line 216
    wp = wp->entry.tqe_next;
  }
#line 220
  notify_window_layout_changed(w);
#line 221
  return (0);
}
}
#line 224 "tmux_df_2.c"
void window_destroy(struct window *w ) 
{ 


  {
#line 227
  window_unzoom(w);
#line 229
  windows_RB_REMOVE(& windows, w);
#line 231
  if ((unsigned long )w->layout_root != (unsigned long )((void *)0)) {
#line 232
    layout_free(w);
  }
#line 233
  free((void *)w->old_layout);
#line 235
  free((void *)w->name);
#line 236
  free((void *)w);
#line 237
  return;
}
}
#line 239 "tmux_df_2.c"
void window_remove_ref(struct window *w ) 
{ 


  {
#line 242
  if (w->references == 0U) {
#line 243
    printf((char const   * __restrict  )"bad reference count%s", "");
#line 243
    exit(1);
  }
#line 244
  (w->references) --;
#line 245
  if (w->references == 0U) {
#line 246
    window_destroy(w);
  }
#line 247
  return;
}
}
#line 249 "tmux_df_2.c"
void notify_add(enum notify_type type , struct client *c , struct session *s , struct window *w ) 
{ 
  struct notify_entry *ne ;
  void *tmp ;

  {
#line 255
  tmp = calloc((size_t )1, sizeof(*ne));
#line 255
  ne = (struct notify_entry *)tmp;
#line 256
  ne->type = type;
#line 257
  ne->client = c;
#line 258
  ne->session = s;
#line 259
  ne->window = w;
#line 260
  while (1) {
#line 260
    ne->entry.tqe_next = (struct notify_entry *)((void *)0);
#line 260
    ne->entry.tqe_prev = notify_queue.tqh_last;
#line 260
    *(notify_queue.tqh_last) = ne;
#line 260
    notify_queue.tqh_last = & ne->entry.tqe_next;
#line 260
    break;
  }
#line 262
  if ((unsigned long )c != (unsigned long )((void *)0)) {
#line 263
    (c->references) ++;
  }
#line 264
  if ((unsigned long )s != (unsigned long )((void *)0)) {
#line 265
    (s->references) ++;
  }
#line 266
  if ((unsigned long )w != (unsigned long )((void *)0)) {
#line 267
    (w->references) ++;
  }
#line 268
  return;
}
}
#line 270 "tmux_df_2.c"
void notify_drain(void) 
{ 
  struct notify_entry *ne ;

  {
#line 275
  if (! notify_enabled) {
#line 276
    return;
  }
#line 278
  ne = notify_queue.tqh_first;
#line 278
  while (ne) {
#line 279
    if ((unsigned long )ne->window != (unsigned long )((void *)0)) {
#line 280
      window_remove_ref(ne->window);
    }
#line 282
    while (1) {
#line 282
      if ((unsigned long )ne->entry.tqe_next != (unsigned long )((void *)0)) {
#line 282
        (ne->entry.tqe_next)->entry.tqe_prev = ne->entry.tqe_prev;
      } else {
#line 282
        notify_queue.tqh_last = ne->entry.tqe_prev;
      }
#line 282
      *(ne->entry.tqe_prev) = ne->entry.tqe_next;
#line 282
      break;
    }
#line 283
    free((void *)ne);
#line 278
    ne = ne->entry.tqe_next;
  }
#line 285
  return;
}
}
#line 286 "tmux_df_2.c"
int window_pane_visible(struct window_pane *wp ) 
{ 
  struct window *w ;

  {
#line 289
  w = wp->window;
#line 291
  if ((unsigned long )wp->layout_cell == (unsigned long )((void *)0)) {
#line 292
    return (0);
  }
#line 293
  if (wp->xoff >= w->sx) {
#line 294
    return (0);
  } else
#line 293
  if (wp->yoff >= w->sy) {
#line 294
    return (0);
  }
#line 295
  if (wp->xoff + wp->sx > w->sx) {
#line 296
    return (0);
  } else
#line 295
  if (wp->yoff + wp->sy > w->sy) {
#line 296
    return (0);
  }
#line 297
  return (1);
}
}
#line 300 "tmux_df_2.c"
struct window_pane *window_get_active_at(struct window *w , u_int___0 x , u_int___0 y ) 
{ 
  struct window_pane *wp ;
  int tmp ;

  {
#line 305
  wp = w->panes.tqh_first;
#line 305
  while (wp) {
#line 306
    tmp = window_pane_visible(wp);
#line 306
    if (! tmp) {
#line 307
      goto __Cont;
    }
#line 308
    if (x < wp->xoff) {
#line 309
      goto __Cont;
    } else
#line 308
    if (x > wp->xoff + wp->sx) {
#line 309
      goto __Cont;
    }
#line 310
    if (y < wp->yoff) {
#line 311
      goto __Cont;
    } else
#line 310
    if (y > wp->yoff + wp->sy) {
#line 311
      goto __Cont;
    }
#line 312
    return (wp);
    __Cont: /* CIL Label */ 
#line 305
    wp = wp->entry.tqe_next;
  }
#line 314
  return ((struct window_pane *)((void *)0));
}
}
#line 317 "tmux_df_2.c"
struct window *window_create1(u_int___0 sx , u_int___0 sy ) 
{ 
  struct window *w ;
  void *tmp ;
  u_int___0 tmp___0 ;

  {
#line 322
  tmp = calloc((size_t )1, sizeof(*w));
#line 322
  w = (struct window *)tmp;
#line 323
  w->name = (char *)((void *)0);
#line 324
  w->flags = 0;
#line 326
  while (1) {
#line 326
    w->panes.tqh_first = (struct window_pane *)((void *)0);
#line 326
    w->panes.tqh_last = & w->panes.tqh_first;
#line 326
    break;
  }
#line 327
  w->active = (struct window_pane *)((void *)0);
#line 329
  w->lastlayout = -1;
#line 330
  w->layout_root = (struct layout_cell *)((void *)0);
#line 332
  w->sx = sx;
#line 333
  w->sy = sy;
#line 335
  w->references = (u_int___0 )0;
#line 337
  tmp___0 = next_window_id;
#line 337
  next_window_id ++;
#line 337
  w->id = tmp___0;
#line 338
  windows_RB_INSERT(& windows, w);
#line 340
  return (w);
}
}
#line 353
extern int ( /* missing proto */  strdup)() ;
#line 343 "tmux_df_2.c"
struct window *window_create(char const   *name , int argc , char **argv , char const   *path ,
                             u_int___0 sx , u_int___0 sy , u_int___0 hlimit ) 
{ 
  struct window *w ;
  struct window_pane *wp ;
  int tmp ;

  {
#line 349
  w = window_create1(sx, sy);
#line 350
  layout_init(w, wp);
#line 352
  w->active = w->panes.tqh_first;
#line 353
  tmp = strdup(name);
#line 353
  w->name = (char *)tmp;
#line 355
  return (w);
}
}
#line 358 "tmux_df_2.c"
int main(int argc , char **argv ) 
{ 
  struct window *w ;
  u_int___0 sx ;
  u_int___0 sy ;
  u_int___0 hlimit ;

  {
#line 362
  w = window_create("name", argc, argv, "path", sx, sy, hlimit);
#line 363
  window_zoom(w->active);
#line 364
  window_count_panes(w);
#line 365
  window_destroy(w);
#line 366
  return (0);
}
}
