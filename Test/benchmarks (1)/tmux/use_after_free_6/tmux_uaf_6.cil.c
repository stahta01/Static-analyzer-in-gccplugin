/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

#line 216 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h"
typedef unsigned long size_t;
#line 193 "../stdio.h"
typedef unsigned int u_int___0;
#line 14 "tmux_uaf_6.c"
struct window {
   char *name ;
   u_int___0 sx ;
   u_int___0 sy ;
   int flags ;
   u_int___0 references ;
};
#line 29 "tmux_uaf_6.c"
struct windows {
   struct window **list ;
   u_int___0 num ;
   size_t space ;
};
#line 32 "tmux_uaf_6.c"
struct __anonstruct_entry_25 {
   struct winlink *rbe_left ;
   struct winlink *rbe_right ;
   struct winlink *rbe_parent ;
   int rbe_color ;
};
#line 32 "tmux_uaf_6.c"
struct __anonstruct_sentry_26 {
   struct winlink *tqe_next ;
   struct winlink **tqe_prev ;
};
#line 32 "tmux_uaf_6.c"
struct winlink {
   int idx ;
   struct window *window ;
   struct __anonstruct_entry_25 entry ;
   struct __anonstruct_sentry_26 sentry ;
};
#line 39 "tmux_uaf_6.c"
struct winlinks {
   struct winlink *rbh_root ;
};
#line 40 "tmux_uaf_6.c"
struct winlink_stack {
   struct winlink *tqh_first ;
   struct winlink **tqh_last ;
};
#line 43 "tmux_uaf_6.c"
struct __anonstruct_gentry_27 {
   struct session *tqe_next ;
   struct session **tqe_prev ;
};
#line 43 "tmux_uaf_6.c"
struct session {
   char *name ;
   u_int___0 sx ;
   u_int___0 sy ;
   struct winlink *curw ;
   struct winlink_stack lastw ;
   struct winlinks windows ;
   int flags ;
   int references ;
   struct __anonstruct_gentry_27 gentry ;
};
#line 61 "tmux_uaf_6.c"
struct sessions {
   struct session **list ;
   u_int___0 num ;
   size_t space ;
};
#line 437
struct client;
#line 454
struct session_group;
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 65 "tmux_uaf_6.c"
struct sessions sessions  ;
#line 66 "tmux_uaf_6.c"
struct sessions dead_sessions  ;
#line 69 "tmux_uaf_6.c"
struct windows windows  ;
#line 72 "tmux_uaf_6.c"
void *xrealloc(void *oldptr , size_t nmemb , size_t size ) 
{ 
  size_t newsize ;
  void *newptr ;

  {
#line 75
  newsize = nmemb * size;
#line 78
  if (newsize == 0UL) {
#line 79
    printf((char const   * __restrict  )"zero size%s", "");
#line 79
    exit(1);
  }
#line 80
  if ((size_t )(1 << 30) / nmemb < size) {
#line 81
    printf((char const   * __restrict  )"nmemb * size > SIZE_MAX%s", "");
#line 81
    exit(1);
  }
#line 82
  newptr = realloc(oldptr, newsize);
#line 82
  if ((unsigned long )newptr == (unsigned long )((void *)0)) {
#line 83
    printf((char const   * __restrict  )"xrealloc failed%s", "");
#line 83
    exit(1);
  }
#line 85
  return (newptr);
}
}
#line 96
extern int ( /* missing proto */  strcmp)() ;
#line 88 "tmux_uaf_6.c"
struct session *session_find(char const   *name ) 
{ 
  struct session *s ;
  u_int___0 i ;
  int tmp ;

  {
#line 94
  i = (u_int___0 )0;
#line 94
  while (i < sessions.num) {
#line 95
    s = *(sessions.list + i);
#line 96
    if ((unsigned long )s != (unsigned long )((void *)0)) {
#line 96
      tmp = strcmp(s->name, name);
#line 96
      if (tmp == 0) {
#line 97
        return (s);
      }
    }
#line 94
    i ++;
  }
#line 100
  return ((struct session *)((void *)0));
}
}
#line 104 "tmux_uaf_6.c"
int winlink_cmp(struct winlink *wl1 , struct winlink *wl2 ) 
{ 


  {
#line 107
  return (wl1->idx - wl2->idx);
}
}
#line 110 "tmux_uaf_6.c"
void winlinks_RB_INSERT_COLOR(struct winlinks *head , struct winlink *elm ) 
{ 
  struct winlink *parent ;
  struct winlink *gparent ;
  struct winlink *tmp ;
  struct winlink *tmp___0 ;
  struct winlink *tmp___1 ;
  struct winlink *tmp___2 ;
  struct winlink *tmp___3 ;
  struct winlink *tmp___4 ;
  struct winlink *tmp___5 ;
  struct winlink *tmp___6 ;
  struct winlink *tmp___7 ;

  {
#line 110
  while (1) {
#line 110
    parent = elm->entry.rbe_parent;
#line 110
    if ((unsigned long )parent != (unsigned long )((void *)0)) {
#line 110
      if (! (parent->entry.rbe_color == 1)) {
#line 110
        break;
      }
    } else {
#line 110
      break;
    }
#line 110
    gparent = parent->entry.rbe_parent;
#line 110
    if ((unsigned long )parent == (unsigned long )gparent->entry.rbe_left) {
#line 110
      tmp = gparent->entry.rbe_right;
#line 110
      if (tmp) {
#line 110
        if (tmp->entry.rbe_color == 1) {
#line 110
          tmp->entry.rbe_color = 0;
#line 110
          while (1) {
#line 110
            parent->entry.rbe_color = 0;
#line 110
            gparent->entry.rbe_color = 1;
#line 110
            break;
          }
#line 110
          elm = gparent;
#line 110
          continue;
        }
      }
#line 110
      if ((unsigned long )parent->entry.rbe_right == (unsigned long )elm) {
#line 110
        while (1) {
#line 110
          tmp = parent->entry.rbe_right;
#line 110
          tmp___0 = tmp->entry.rbe_left;
#line 110
          parent->entry.rbe_right = tmp___0;
#line 110
          if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 110
            (tmp->entry.rbe_left)->entry.rbe_parent = parent;
          }
#line 110
          while (1) {
#line 110
            break;
          }
#line 110
          tmp___1 = parent->entry.rbe_parent;
#line 110
          tmp->entry.rbe_parent = tmp___1;
#line 110
          if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
#line 110
            if ((unsigned long )parent == (unsigned long )(parent->entry.rbe_parent)->entry.rbe_left) {
#line 110
              (parent->entry.rbe_parent)->entry.rbe_left = tmp;
            } else {
#line 110
              (parent->entry.rbe_parent)->entry.rbe_right = tmp;
            }
          } else {
#line 110
            head->rbh_root = tmp;
          }
#line 110
          tmp->entry.rbe_left = parent;
#line 110
          parent->entry.rbe_parent = tmp;
#line 110
          while (1) {
#line 110
            break;
          }
#line 110
          if (tmp->entry.rbe_parent) {
#line 110
            while (1) {
#line 110
              break;
            }
          }
#line 110
          break;
        }
#line 110
        tmp = parent;
#line 110
        parent = elm;
#line 110
        elm = tmp;
      }
#line 110
      while (1) {
#line 110
        parent->entry.rbe_color = 0;
#line 110
        gparent->entry.rbe_color = 1;
#line 110
        break;
      }
#line 110
      while (1) {
#line 110
        tmp = gparent->entry.rbe_left;
#line 110
        tmp___2 = tmp->entry.rbe_right;
#line 110
        gparent->entry.rbe_left = tmp___2;
#line 110
        if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
#line 110
          (tmp->entry.rbe_right)->entry.rbe_parent = gparent;
        }
#line 110
        while (1) {
#line 110
          break;
        }
#line 110
        tmp___3 = gparent->entry.rbe_parent;
#line 110
        tmp->entry.rbe_parent = tmp___3;
#line 110
        if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
#line 110
          if ((unsigned long )gparent == (unsigned long )(gparent->entry.rbe_parent)->entry.rbe_left) {
#line 110
            (gparent->entry.rbe_parent)->entry.rbe_left = tmp;
          } else {
#line 110
            (gparent->entry.rbe_parent)->entry.rbe_right = tmp;
          }
        } else {
#line 110
          head->rbh_root = tmp;
        }
#line 110
        tmp->entry.rbe_right = gparent;
#line 110
        gparent->entry.rbe_parent = tmp;
#line 110
        while (1) {
#line 110
          break;
        }
#line 110
        if (tmp->entry.rbe_parent) {
#line 110
          while (1) {
#line 110
            break;
          }
        }
#line 110
        break;
      }
    } else {
#line 110
      tmp = gparent->entry.rbe_left;
#line 110
      if (tmp) {
#line 110
        if (tmp->entry.rbe_color == 1) {
#line 110
          tmp->entry.rbe_color = 0;
#line 110
          while (1) {
#line 110
            parent->entry.rbe_color = 0;
#line 110
            gparent->entry.rbe_color = 1;
#line 110
            break;
          }
#line 110
          elm = gparent;
#line 110
          continue;
        }
      }
#line 110
      if ((unsigned long )parent->entry.rbe_left == (unsigned long )elm) {
#line 110
        while (1) {
#line 110
          tmp = parent->entry.rbe_left;
#line 110
          tmp___4 = tmp->entry.rbe_right;
#line 110
          parent->entry.rbe_left = tmp___4;
#line 110
          if ((unsigned long )tmp___4 != (unsigned long )((void *)0)) {
#line 110
            (tmp->entry.rbe_right)->entry.rbe_parent = parent;
          }
#line 110
          while (1) {
#line 110
            break;
          }
#line 110
          tmp___5 = parent->entry.rbe_parent;
#line 110
          tmp->entry.rbe_parent = tmp___5;
#line 110
          if ((unsigned long )tmp___5 != (unsigned long )((void *)0)) {
#line 110
            if ((unsigned long )parent == (unsigned long )(parent->entry.rbe_parent)->entry.rbe_left) {
#line 110
              (parent->entry.rbe_parent)->entry.rbe_left = tmp;
            } else {
#line 110
              (parent->entry.rbe_parent)->entry.rbe_right = tmp;
            }
          } else {
#line 110
            head->rbh_root = tmp;
          }
#line 110
          tmp->entry.rbe_right = parent;
#line 110
          parent->entry.rbe_parent = tmp;
#line 110
          while (1) {
#line 110
            break;
          }
#line 110
          if (tmp->entry.rbe_parent) {
#line 110
            while (1) {
#line 110
              break;
            }
          }
#line 110
          break;
        }
#line 110
        tmp = parent;
#line 110
        parent = elm;
#line 110
        elm = tmp;
      }
#line 110
      while (1) {
#line 110
        parent->entry.rbe_color = 0;
#line 110
        gparent->entry.rbe_color = 1;
#line 110
        break;
      }
#line 110
      while (1) {
#line 110
        tmp = gparent->entry.rbe_right;
#line 110
        tmp___6 = tmp->entry.rbe_left;
#line 110
        gparent->entry.rbe_right = tmp___6;
#line 110
        if ((unsigned long )tmp___6 != (unsigned long )((void *)0)) {
#line 110
          (tmp->entry.rbe_left)->entry.rbe_parent = gparent;
        }
#line 110
        while (1) {
#line 110
          break;
        }
#line 110
        tmp___7 = gparent->entry.rbe_parent;
#line 110
        tmp->entry.rbe_parent = tmp___7;
#line 110
        if ((unsigned long )tmp___7 != (unsigned long )((void *)0)) {
#line 110
          if ((unsigned long )gparent == (unsigned long )(gparent->entry.rbe_parent)->entry.rbe_left) {
#line 110
            (gparent->entry.rbe_parent)->entry.rbe_left = tmp;
          } else {
#line 110
            (gparent->entry.rbe_parent)->entry.rbe_right = tmp;
          }
        } else {
#line 110
          head->rbh_root = tmp;
        }
#line 110
        tmp->entry.rbe_left = gparent;
#line 110
        gparent->entry.rbe_parent = tmp;
#line 110
        while (1) {
#line 110
          break;
        }
#line 110
        if (tmp->entry.rbe_parent) {
#line 110
          while (1) {
#line 110
            break;
          }
        }
#line 110
        break;
      }
    }
  }
#line 110
  (head->rbh_root)->entry.rbe_color = 0;
#line 110
  return;
}
}
#line 110 "tmux_uaf_6.c"
void winlinks_RB_REMOVE_COLOR(struct winlinks *head , struct winlink *parent , struct winlink *elm ) 
{ 
  struct winlink *tmp ;
  struct winlink *tmp___0 ;
  struct winlink *tmp___1 ;
  struct winlink *oleft ;
  struct winlink *tmp___2 ;
  struct winlink *tmp___3 ;
  struct winlink *tmp___4 ;
  struct winlink *tmp___5 ;
  struct winlink *tmp___6 ;
  struct winlink *tmp___7 ;
  struct winlink *oright ;
  struct winlink *tmp___8 ;
  struct winlink *tmp___9 ;
  struct winlink *tmp___10 ;
  struct winlink *tmp___11 ;

  {
#line 110
  while (1) {
#line 110
    if ((unsigned long )elm == (unsigned long )((void *)0)) {
#line 110
      goto _L___5;
    } else
#line 110
    if (elm->entry.rbe_color == 0) {
      _L___5: /* CIL Label */ 
#line 110
      if (! ((unsigned long )elm != (unsigned long )head->rbh_root)) {
#line 110
        break;
      }
    } else {
#line 110
      break;
    }
#line 110
    if ((unsigned long )parent->entry.rbe_left == (unsigned long )elm) {
#line 110
      tmp = parent->entry.rbe_right;
#line 110
      if (tmp->entry.rbe_color == 1) {
#line 110
        while (1) {
#line 110
          tmp->entry.rbe_color = 0;
#line 110
          parent->entry.rbe_color = 1;
#line 110
          break;
        }
#line 110
        while (1) {
#line 110
          tmp = parent->entry.rbe_right;
#line 110
          tmp___0 = tmp->entry.rbe_left;
#line 110
          parent->entry.rbe_right = tmp___0;
#line 110
          if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 110
            (tmp->entry.rbe_left)->entry.rbe_parent = parent;
          }
#line 110
          while (1) {
#line 110
            break;
          }
#line 110
          tmp___1 = parent->entry.rbe_parent;
#line 110
          tmp->entry.rbe_parent = tmp___1;
#line 110
          if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
#line 110
            if ((unsigned long )parent == (unsigned long )(parent->entry.rbe_parent)->entry.rbe_left) {
#line 110
              (parent->entry.rbe_parent)->entry.rbe_left = tmp;
            } else {
#line 110
              (parent->entry.rbe_parent)->entry.rbe_right = tmp;
            }
          } else {
#line 110
            head->rbh_root = tmp;
          }
#line 110
          tmp->entry.rbe_left = parent;
#line 110
          parent->entry.rbe_parent = tmp;
#line 110
          while (1) {
#line 110
            break;
          }
#line 110
          if (tmp->entry.rbe_parent) {
#line 110
            while (1) {
#line 110
              break;
            }
          }
#line 110
          break;
        }
#line 110
        tmp = parent->entry.rbe_right;
      }
#line 110
      if ((unsigned long )tmp->entry.rbe_left == (unsigned long )((void *)0)) {
#line 110
        goto _L___1;
      } else
#line 110
      if ((tmp->entry.rbe_left)->entry.rbe_color == 0) {
        _L___1: /* CIL Label */ 
#line 110
        if ((unsigned long )tmp->entry.rbe_right == (unsigned long )((void *)0)) {
#line 110
          tmp->entry.rbe_color = 1;
#line 110
          elm = parent;
#line 110
          parent = elm->entry.rbe_parent;
        } else
#line 110
        if ((tmp->entry.rbe_right)->entry.rbe_color == 0) {
#line 110
          tmp->entry.rbe_color = 1;
#line 110
          elm = parent;
#line 110
          parent = elm->entry.rbe_parent;
        } else {
#line 110
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 110
        if ((unsigned long )tmp->entry.rbe_right == (unsigned long )((void *)0)) {
#line 110
          goto _L;
        } else
#line 110
        if ((tmp->entry.rbe_right)->entry.rbe_color == 0) {
          _L: /* CIL Label */ 
#line 110
          oleft = tmp->entry.rbe_left;
#line 110
          if ((unsigned long )oleft != (unsigned long )((void *)0)) {
#line 110
            oleft->entry.rbe_color = 0;
          }
#line 110
          tmp->entry.rbe_color = 1;
#line 110
          while (1) {
#line 110
            oleft = tmp->entry.rbe_left;
#line 110
            tmp___2 = oleft->entry.rbe_right;
#line 110
            tmp->entry.rbe_left = tmp___2;
#line 110
            if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
#line 110
              (oleft->entry.rbe_right)->entry.rbe_parent = tmp;
            }
#line 110
            while (1) {
#line 110
              break;
            }
#line 110
            tmp___3 = tmp->entry.rbe_parent;
#line 110
            oleft->entry.rbe_parent = tmp___3;
#line 110
            if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
#line 110
              if ((unsigned long )tmp == (unsigned long )(tmp->entry.rbe_parent)->entry.rbe_left) {
#line 110
                (tmp->entry.rbe_parent)->entry.rbe_left = oleft;
              } else {
#line 110
                (tmp->entry.rbe_parent)->entry.rbe_right = oleft;
              }
            } else {
#line 110
              head->rbh_root = oleft;
            }
#line 110
            oleft->entry.rbe_right = tmp;
#line 110
            tmp->entry.rbe_parent = oleft;
#line 110
            while (1) {
#line 110
              break;
            }
#line 110
            if (oleft->entry.rbe_parent) {
#line 110
              while (1) {
#line 110
                break;
              }
            }
#line 110
            break;
          }
#line 110
          tmp = parent->entry.rbe_right;
        }
#line 110
        tmp->entry.rbe_color = parent->entry.rbe_color;
#line 110
        parent->entry.rbe_color = 0;
#line 110
        if (tmp->entry.rbe_right) {
#line 110
          (tmp->entry.rbe_right)->entry.rbe_color = 0;
        }
#line 110
        while (1) {
#line 110
          tmp = parent->entry.rbe_right;
#line 110
          tmp___4 = tmp->entry.rbe_left;
#line 110
          parent->entry.rbe_right = tmp___4;
#line 110
          if ((unsigned long )tmp___4 != (unsigned long )((void *)0)) {
#line 110
            (tmp->entry.rbe_left)->entry.rbe_parent = parent;
          }
#line 110
          while (1) {
#line 110
            break;
          }
#line 110
          tmp___5 = parent->entry.rbe_parent;
#line 110
          tmp->entry.rbe_parent = tmp___5;
#line 110
          if ((unsigned long )tmp___5 != (unsigned long )((void *)0)) {
#line 110
            if ((unsigned long )parent == (unsigned long )(parent->entry.rbe_parent)->entry.rbe_left) {
#line 110
              (parent->entry.rbe_parent)->entry.rbe_left = tmp;
            } else {
#line 110
              (parent->entry.rbe_parent)->entry.rbe_right = tmp;
            }
          } else {
#line 110
            head->rbh_root = tmp;
          }
#line 110
          tmp->entry.rbe_left = parent;
#line 110
          parent->entry.rbe_parent = tmp;
#line 110
          while (1) {
#line 110
            break;
          }
#line 110
          if (tmp->entry.rbe_parent) {
#line 110
            while (1) {
#line 110
              break;
            }
          }
#line 110
          break;
        }
#line 110
        elm = head->rbh_root;
#line 110
        break;
      }
    } else {
#line 110
      tmp = parent->entry.rbe_left;
#line 110
      if (tmp->entry.rbe_color == 1) {
#line 110
        while (1) {
#line 110
          tmp->entry.rbe_color = 0;
#line 110
          parent->entry.rbe_color = 1;
#line 110
          break;
        }
#line 110
        while (1) {
#line 110
          tmp = parent->entry.rbe_left;
#line 110
          tmp___6 = tmp->entry.rbe_right;
#line 110
          parent->entry.rbe_left = tmp___6;
#line 110
          if ((unsigned long )tmp___6 != (unsigned long )((void *)0)) {
#line 110
            (tmp->entry.rbe_right)->entry.rbe_parent = parent;
          }
#line 110
          while (1) {
#line 110
            break;
          }
#line 110
          tmp___7 = parent->entry.rbe_parent;
#line 110
          tmp->entry.rbe_parent = tmp___7;
#line 110
          if ((unsigned long )tmp___7 != (unsigned long )((void *)0)) {
#line 110
            if ((unsigned long )parent == (unsigned long )(parent->entry.rbe_parent)->entry.rbe_left) {
#line 110
              (parent->entry.rbe_parent)->entry.rbe_left = tmp;
            } else {
#line 110
              (parent->entry.rbe_parent)->entry.rbe_right = tmp;
            }
          } else {
#line 110
            head->rbh_root = tmp;
          }
#line 110
          tmp->entry.rbe_right = parent;
#line 110
          parent->entry.rbe_parent = tmp;
#line 110
          while (1) {
#line 110
            break;
          }
#line 110
          if (tmp->entry.rbe_parent) {
#line 110
            while (1) {
#line 110
              break;
            }
          }
#line 110
          break;
        }
#line 110
        tmp = parent->entry.rbe_left;
      }
#line 110
      if ((unsigned long )tmp->entry.rbe_left == (unsigned long )((void *)0)) {
#line 110
        goto _L___4;
      } else
#line 110
      if ((tmp->entry.rbe_left)->entry.rbe_color == 0) {
        _L___4: /* CIL Label */ 
#line 110
        if ((unsigned long )tmp->entry.rbe_right == (unsigned long )((void *)0)) {
#line 110
          tmp->entry.rbe_color = 1;
#line 110
          elm = parent;
#line 110
          parent = elm->entry.rbe_parent;
        } else
#line 110
        if ((tmp->entry.rbe_right)->entry.rbe_color == 0) {
#line 110
          tmp->entry.rbe_color = 1;
#line 110
          elm = parent;
#line 110
          parent = elm->entry.rbe_parent;
        } else {
#line 110
          goto _L___3;
        }
      } else {
        _L___3: /* CIL Label */ 
#line 110
        if ((unsigned long )tmp->entry.rbe_left == (unsigned long )((void *)0)) {
#line 110
          goto _L___2;
        } else
#line 110
        if ((tmp->entry.rbe_left)->entry.rbe_color == 0) {
          _L___2: /* CIL Label */ 
#line 110
          oright = tmp->entry.rbe_right;
#line 110
          if ((unsigned long )oright != (unsigned long )((void *)0)) {
#line 110
            oright->entry.rbe_color = 0;
          }
#line 110
          tmp->entry.rbe_color = 1;
#line 110
          while (1) {
#line 110
            oright = tmp->entry.rbe_right;
#line 110
            tmp___8 = oright->entry.rbe_left;
#line 110
            tmp->entry.rbe_right = tmp___8;
#line 110
            if ((unsigned long )tmp___8 != (unsigned long )((void *)0)) {
#line 110
              (oright->entry.rbe_left)->entry.rbe_parent = tmp;
            }
#line 110
            while (1) {
#line 110
              break;
            }
#line 110
            tmp___9 = tmp->entry.rbe_parent;
#line 110
            oright->entry.rbe_parent = tmp___9;
#line 110
            if ((unsigned long )tmp___9 != (unsigned long )((void *)0)) {
#line 110
              if ((unsigned long )tmp == (unsigned long )(tmp->entry.rbe_parent)->entry.rbe_left) {
#line 110
                (tmp->entry.rbe_parent)->entry.rbe_left = oright;
              } else {
#line 110
                (tmp->entry.rbe_parent)->entry.rbe_right = oright;
              }
            } else {
#line 110
              head->rbh_root = oright;
            }
#line 110
            oright->entry.rbe_left = tmp;
#line 110
            tmp->entry.rbe_parent = oright;
#line 110
            while (1) {
#line 110
              break;
            }
#line 110
            if (oright->entry.rbe_parent) {
#line 110
              while (1) {
#line 110
                break;
              }
            }
#line 110
            break;
          }
#line 110
          tmp = parent->entry.rbe_left;
        }
#line 110
        tmp->entry.rbe_color = parent->entry.rbe_color;
#line 110
        parent->entry.rbe_color = 0;
#line 110
        if (tmp->entry.rbe_left) {
#line 110
          (tmp->entry.rbe_left)->entry.rbe_color = 0;
        }
#line 110
        while (1) {
#line 110
          tmp = parent->entry.rbe_left;
#line 110
          tmp___10 = tmp->entry.rbe_right;
#line 110
          parent->entry.rbe_left = tmp___10;
#line 110
          if ((unsigned long )tmp___10 != (unsigned long )((void *)0)) {
#line 110
            (tmp->entry.rbe_right)->entry.rbe_parent = parent;
          }
#line 110
          while (1) {
#line 110
            break;
          }
#line 110
          tmp___11 = parent->entry.rbe_parent;
#line 110
          tmp->entry.rbe_parent = tmp___11;
#line 110
          if ((unsigned long )tmp___11 != (unsigned long )((void *)0)) {
#line 110
            if ((unsigned long )parent == (unsigned long )(parent->entry.rbe_parent)->entry.rbe_left) {
#line 110
              (parent->entry.rbe_parent)->entry.rbe_left = tmp;
            } else {
#line 110
              (parent->entry.rbe_parent)->entry.rbe_right = tmp;
            }
          } else {
#line 110
            head->rbh_root = tmp;
          }
#line 110
          tmp->entry.rbe_right = parent;
#line 110
          parent->entry.rbe_parent = tmp;
#line 110
          while (1) {
#line 110
            break;
          }
#line 110
          if (tmp->entry.rbe_parent) {
#line 110
            while (1) {
#line 110
              break;
            }
          }
#line 110
          break;
        }
#line 110
        elm = head->rbh_root;
#line 110
        break;
      }
    }
  }
#line 110
  if (elm) {
#line 110
    elm->entry.rbe_color = 0;
  }
#line 110
  return;
}
}
#line 110 "tmux_uaf_6.c"
struct winlink *winlinks_RB_INSERT(struct winlinks *head , struct winlink *elm ) 
{ 
  struct winlink *tmp ;
  struct winlink *parent ;
  int comp ;
  struct winlink *tmp___0 ;

  {
#line 110
  parent = (struct winlink *)((void *)0);
#line 110
  comp = 0;
#line 110
  tmp = head->rbh_root;
#line 110
  while (tmp) {
#line 110
    parent = tmp;
#line 110
    comp = winlink_cmp(elm, parent);
#line 110
    if (comp < 0) {
#line 110
      tmp = tmp->entry.rbe_left;
    } else
#line 110
    if (comp > 0) {
#line 110
      tmp = tmp->entry.rbe_right;
    } else {
#line 110
      return (tmp);
    }
  }
#line 110
  while (1) {
#line 110
    elm->entry.rbe_parent = parent;
#line 110
    tmp___0 = (struct winlink *)((void *)0);
#line 110
    elm->entry.rbe_right = tmp___0;
#line 110
    elm->entry.rbe_left = tmp___0;
#line 110
    elm->entry.rbe_color = 1;
#line 110
    break;
  }
#line 110
  if ((unsigned long )parent != (unsigned long )((void *)0)) {
#line 110
    if (comp < 0) {
#line 110
      parent->entry.rbe_left = elm;
    } else {
#line 110
      parent->entry.rbe_right = elm;
    }
#line 110
    while (1) {
#line 110
      break;
    }
  } else {
#line 110
    head->rbh_root = elm;
  }
#line 110
  winlinks_RB_INSERT_COLOR(head, elm);
#line 110
  return ((struct winlink *)((void *)0));
}
}
#line 110 "tmux_uaf_6.c"
struct winlink *winlinks_RB_REMOVE(struct winlinks *head , struct winlink *elm ) 
{ 
  struct winlink *child ;
  struct winlink *parent ;
  struct winlink *old ;
  int color ;
  struct winlink *left ;

  {
#line 110
  old = elm;
#line 110
  if ((unsigned long )elm->entry.rbe_left == (unsigned long )((void *)0)) {
#line 110
    child = elm->entry.rbe_right;
  } else
#line 110
  if ((unsigned long )elm->entry.rbe_right == (unsigned long )((void *)0)) {
#line 110
    child = elm->entry.rbe_left;
  } else {
#line 110
    elm = elm->entry.rbe_right;
#line 110
    while (1) {
#line 110
      left = elm->entry.rbe_left;
#line 110
      if (! ((unsigned long )left != (unsigned long )((void *)0))) {
#line 110
        break;
      }
#line 110
      elm = left;
    }
#line 110
    child = elm->entry.rbe_right;
#line 110
    parent = elm->entry.rbe_parent;
#line 110
    color = elm->entry.rbe_color;
#line 110
    if (child) {
#line 110
      child->entry.rbe_parent = parent;
    }
#line 110
    if (parent) {
#line 110
      if ((unsigned long )parent->entry.rbe_left == (unsigned long )elm) {
#line 110
        parent->entry.rbe_left = child;
      } else {
#line 110
        parent->entry.rbe_right = child;
      }
#line 110
      while (1) {
#line 110
        break;
      }
    } else {
#line 110
      head->rbh_root = child;
    }
#line 110
    if ((unsigned long )elm->entry.rbe_parent == (unsigned long )old) {
#line 110
      parent = elm;
    }
#line 110
    elm->entry = old->entry;
#line 110
    if (old->entry.rbe_parent) {
#line 110
      if ((unsigned long )(old->entry.rbe_parent)->entry.rbe_left == (unsigned long )old) {
#line 110
        (old->entry.rbe_parent)->entry.rbe_left = elm;
      } else {
#line 110
        (old->entry.rbe_parent)->entry.rbe_right = elm;
      }
#line 110
      while (1) {
#line 110
        break;
      }
    } else {
#line 110
      head->rbh_root = elm;
    }
#line 110
    (old->entry.rbe_left)->entry.rbe_parent = elm;
#line 110
    if (old->entry.rbe_right) {
#line 110
      (old->entry.rbe_right)->entry.rbe_parent = elm;
    }
#line 110
    if (parent) {
#line 110
      left = parent;
#line 110
      while (1) {
#line 110
        while (1) {
#line 110
          break;
        }
#line 110
        left = left->entry.rbe_parent;
#line 110
        if (! ((unsigned long )left != (unsigned long )((void *)0))) {
#line 110
          break;
        }
      }
    }
#line 110
    goto color;
  }
#line 110
  parent = elm->entry.rbe_parent;
#line 110
  color = elm->entry.rbe_color;
#line 110
  if (child) {
#line 110
    child->entry.rbe_parent = parent;
  }
#line 110
  if (parent) {
#line 110
    if ((unsigned long )parent->entry.rbe_left == (unsigned long )elm) {
#line 110
      parent->entry.rbe_left = child;
    } else {
#line 110
      parent->entry.rbe_right = child;
    }
#line 110
    while (1) {
#line 110
      break;
    }
  } else {
#line 110
    head->rbh_root = child;
  }
  color: 
#line 110
  if (color == 0) {
#line 110
    winlinks_RB_REMOVE_COLOR(head, parent, child);
  }
#line 110
  return (old);
}
}
#line 110 "tmux_uaf_6.c"
struct winlink *winlinks_RB_FIND(struct winlinks *head , struct winlink *elm ) 
{ 
  struct winlink *tmp ;
  int comp ;

  {
#line 110
  tmp = head->rbh_root;
#line 110
  while (tmp) {
#line 110
    comp = winlink_cmp(elm, tmp);
#line 110
    if (comp < 0) {
#line 110
      tmp = tmp->entry.rbe_left;
    } else
#line 110
    if (comp > 0) {
#line 110
      tmp = tmp->entry.rbe_right;
    } else {
#line 110
      return (tmp);
    }
  }
#line 110
  return ((struct winlink *)((void *)0));
}
}
#line 110 "tmux_uaf_6.c"
struct winlink *winlinks_RB_NFIND(struct winlinks *head , struct winlink *elm ) 
{ 
  struct winlink *tmp ;
  struct winlink *res ;
  int comp ;

  {
#line 110
  tmp = head->rbh_root;
#line 110
  res = (struct winlink *)((void *)0);
#line 110
  while (tmp) {
#line 110
    comp = winlink_cmp(elm, tmp);
#line 110
    if (comp < 0) {
#line 110
      res = tmp;
#line 110
      tmp = tmp->entry.rbe_left;
    } else
#line 110
    if (comp > 0) {
#line 110
      tmp = tmp->entry.rbe_right;
    } else {
#line 110
      return (tmp);
    }
  }
#line 110
  return (res);
}
}
#line 110 "tmux_uaf_6.c"
struct winlink *winlinks_RB_NEXT(struct winlink *elm ) 
{ 


  {
#line 110
  if (elm->entry.rbe_right) {
#line 110
    elm = elm->entry.rbe_right;
#line 110
    while (elm->entry.rbe_left) {
#line 110
      elm = elm->entry.rbe_left;
    }
  } else
#line 110
  if (elm->entry.rbe_parent) {
#line 110
    if ((unsigned long )elm == (unsigned long )(elm->entry.rbe_parent)->entry.rbe_left) {
#line 110
      elm = elm->entry.rbe_parent;
    } else {
#line 110
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 110
    while (1) {
#line 110
      if (elm->entry.rbe_parent) {
#line 110
        if (! ((unsigned long )elm == (unsigned long )(elm->entry.rbe_parent)->entry.rbe_right)) {
#line 110
          break;
        }
      } else {
#line 110
        break;
      }
#line 110
      elm = elm->entry.rbe_parent;
    }
#line 110
    elm = elm->entry.rbe_parent;
  }
#line 110
  return (elm);
}
}
#line 110 "tmux_uaf_6.c"
struct winlink *winlinks_RB_PREV(struct winlink *elm ) 
{ 


  {
#line 110
  if (elm->entry.rbe_left) {
#line 110
    elm = elm->entry.rbe_left;
#line 110
    while (elm->entry.rbe_right) {
#line 110
      elm = elm->entry.rbe_right;
    }
  } else
#line 110
  if (elm->entry.rbe_parent) {
#line 110
    if ((unsigned long )elm == (unsigned long )(elm->entry.rbe_parent)->entry.rbe_right) {
#line 110
      elm = elm->entry.rbe_parent;
    } else {
#line 110
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 110
    while (1) {
#line 110
      if (elm->entry.rbe_parent) {
#line 110
        if (! ((unsigned long )elm == (unsigned long )(elm->entry.rbe_parent)->entry.rbe_left)) {
#line 110
          break;
        }
      } else {
#line 110
        break;
      }
#line 110
      elm = elm->entry.rbe_parent;
    }
#line 110
    elm = elm->entry.rbe_parent;
  }
#line 110
  return (elm);
}
}
#line 110 "tmux_uaf_6.c"
struct winlink *winlinks_RB_MINMAX(struct winlinks *head , int val ) 
{ 
  struct winlink *tmp ;
  struct winlink *parent ;

  {
#line 110
  tmp = head->rbh_root;
#line 110
  parent = (struct winlink *)((void *)0);
#line 110
  while (tmp) {
#line 110
    parent = tmp;
#line 110
    if (val < 0) {
#line 110
      tmp = tmp->entry.rbe_left;
    } else {
#line 110
      tmp = tmp->entry.rbe_right;
    }
  }
#line 110
  return (parent);
}
}
#line 112 "tmux_uaf_6.c"
struct winlink *winlink_find_by_window(struct winlinks *wwl , struct window *w ) 
{ 
  struct winlink *wl ;

  {
#line 117
  wl = winlinks_RB_MINMAX(wwl, -1);
#line 117
  while ((unsigned long )wl != (unsigned long )((void *)0)) {
#line 118
    if ((unsigned long )wl->window == (unsigned long )w) {
#line 119
      return (wl);
    }
#line 117
    wl = winlinks_RB_NEXT(wl);
  }
#line 122
  return ((struct winlink *)((void *)0));
}
}
#line 125 "tmux_uaf_6.c"
struct winlink *winlink_find_by_index(struct winlinks *wwl , int idx ) 
{ 
  struct winlink wl ;
  struct winlink *tmp ;

  {
#line 130
  if (idx < 0) {
#line 131
    printf((char const   * __restrict  )"bad index%s\n", "");
#line 131
    exit(1);
  }
#line 133
  wl.idx = idx;
#line 134
  tmp = winlinks_RB_FIND(wwl, & wl);
#line 134
  return (tmp);
}
}
#line 137 "tmux_uaf_6.c"
int winlink_next_index(struct winlinks *wwl , int idx ) 
{ 
  int i ;
  struct winlink *tmp ;

  {
#line 142
  i = idx;
#line 143
  while (1) {
#line 144
    tmp = winlink_find_by_index(wwl, i);
#line 144
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 145
      return (i);
    }
#line 146
    if (i == 10000) {
#line 147
      i = 0;
    } else {
#line 149
      i ++;
    }
#line 143
    if (! (i != idx)) {
#line 143
      break;
    }
  }
#line 151
  return (-1);
}
}
#line 154 "tmux_uaf_6.c"
u_int___0 winlink_count(struct winlinks *wwl ) 
{ 
  struct winlink *wl ;
  u_int___0 n ;

  {
#line 160
  n = (u_int___0 )0;
#line 161
  wl = winlinks_RB_MINMAX(wwl, -1);
#line 161
  while ((unsigned long )wl != (unsigned long )((void *)0)) {
#line 162
    n ++;
#line 161
    wl = winlinks_RB_NEXT(wl);
  }
#line 164
  return (n);
}
}
#line 167 "tmux_uaf_6.c"
struct winlink *winlink_add(struct winlinks *wwl , struct window *w , int idx ) 
{ 
  struct winlink *wl ;
  struct winlink *tmp ;
  void *tmp___0 ;

  {
#line 172
  if (idx < 0) {
#line 173
    idx = winlink_next_index(wwl, - idx - 1);
#line 173
    if (idx == -1) {
#line 174
      return ((struct winlink *)((void *)0));
    }
  } else {
#line 175
    tmp = winlink_find_by_index(wwl, idx);
#line 175
    if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 176
      return ((struct winlink *)((void *)0));
    }
  }
#line 178
  tmp___0 = malloc(sizeof(*wl));
#line 178
  wl = (struct winlink *)tmp___0;
#line 179
  wl->idx = idx;
#line 180
  wl->window = w;
#line 181
  winlinks_RB_INSERT(wwl, wl);
#line 183
  (w->references) ++;
#line 185
  return (wl);
}
}
#line 193
int window_index(struct window *s , u_int___0 *i ) ;
#line 188 "tmux_uaf_6.c"
void window_destroy(struct window *w ) 
{ 
  u_int___0 i ;
  int tmp ;

  {
#line 193
  tmp = window_index(w, & i);
#line 193
  if (tmp != 0) {
#line 194
    printf((char const   * __restrict  )"index not found%s\n", "");
#line 194
    exit(1);
  }
#line 195
  while (1) {
#line 195
    *(windows.list + i) = (struct window *)((void *)0);
#line 195
    break;
  }
#line 196
  while (1) {
#line 196
    if ((unsigned long )((void *)(& windows)) == (unsigned long )((void *)0)) {
#line 196
      break;
    } else
#line 196
    if (windows.num == 0U) {
#line 196
      break;
    } else
#line 196
    if (! ((unsigned long )*(windows.list + (windows.num - 1U)) == (unsigned long )((void *)0))) {
#line 196
      break;
    }
#line 197
    while (1) {
#line 197
      if (windows.num > 1U) {
#line 197
        (windows.num) --;
      } else {
#line 197
        while (1) {
#line 197
          free((void *)windows.list);
#line 197
          while (1) {
#line 197
            windows.num = (u_int___0 )0;
#line 197
            windows.list = (struct window **)((void *)0);
#line 197
            windows.space = (size_t )0;
#line 197
            break;
          }
#line 197
          break;
        }
      }
#line 197
      break;
    }
  }
#line 199
  free((void *)w);
#line 200
  return;
}
}
#line 202 "tmux_uaf_6.c"
void winlink_remove(struct winlinks *wwl , struct winlink *wl ) 
{ 
  struct window *w ;

  {
#line 205
  w = wl->window;
#line 207
  winlinks_RB_REMOVE(wwl, wl);
#line 208
  free((void *)wl);
#line 210
  if (w->references == 0U) {
#line 211
    printf((char const   * __restrict  )"bad reference count%s\n", "");
#line 211
    exit(1);
  }
#line 212
  (w->references) --;
#line 213
  if (w->references == 0U) {
#line 214
    window_destroy(w);
  }
#line 215
  return;
}
}
#line 217 "tmux_uaf_6.c"
struct winlink *winlink_next(struct winlinks *wwl , struct winlink *wl ) 
{ 
  struct winlink *tmp ;

  {
#line 220
  tmp = winlinks_RB_NEXT(wl);
#line 220
  return (tmp);
}
}
#line 223 "tmux_uaf_6.c"
struct winlink *winlink_previous(struct winlinks *wwl , struct winlink *wl ) 
{ 
  struct winlink *tmp ;

  {
#line 226
  tmp = winlinks_RB_PREV(wl);
#line 226
  return (tmp);
}
}
#line 229 "tmux_uaf_6.c"
void winlink_stack_remove(struct winlink_stack *stack , struct winlink *wl ) 
{ 
  struct winlink *wl2 ;

  {
#line 234
  if ((unsigned long )wl == (unsigned long )((void *)0)) {
#line 235
    return;
  }
#line 237
  wl2 = stack->tqh_first;
#line 237
  while (wl2) {
#line 238
    if ((unsigned long )wl2 == (unsigned long )wl) {
#line 239
      while (1) {
#line 239
        if ((unsigned long )wl->sentry.tqe_next != (unsigned long )((void *)0)) {
#line 239
          (wl->sentry.tqe_next)->sentry.tqe_prev = wl->sentry.tqe_prev;
        } else {
#line 239
          stack->tqh_last = wl->sentry.tqe_prev;
        }
#line 239
        *(wl->sentry.tqe_prev) = wl->sentry.tqe_next;
#line 239
        break;
      }
#line 240
      return;
    }
#line 237
    wl2 = wl2->sentry.tqe_next;
  }
#line 243
  return;
}
}
#line 244 "tmux_uaf_6.c"
void winlink_stack_push(struct winlink_stack *stack , struct winlink *wl ) 
{ 
  struct winlink *tmp ;

  {
#line 247
  if ((unsigned long )wl == (unsigned long )((void *)0)) {
#line 248
    return;
  }
#line 250
  winlink_stack_remove(stack, wl);
#line 251
  while (1) {
#line 251
    tmp = stack->tqh_first;
#line 251
    wl->sentry.tqe_next = tmp;
#line 251
    if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 251
      (stack->tqh_first)->sentry.tqe_prev = & wl->sentry.tqe_next;
    } else {
#line 251
      stack->tqh_last = & wl->sentry.tqe_next;
    }
#line 251
    stack->tqh_first = wl;
#line 251
    wl->sentry.tqe_prev = & stack->tqh_first;
#line 251
    break;
  }
#line 252
  return;
}
}
#line 254 "tmux_uaf_6.c"
int window_index(struct window *s , u_int___0 *i ) 
{ 


  {
#line 257
  *i = (u_int___0 )0;
#line 257
  while (*i < windows.num) {
#line 258
    if ((unsigned long )s == (unsigned long )*(windows.list + *i)) {
#line 259
      return (0);
    }
#line 257
    (*i) ++;
  }
#line 261
  return (-1);
}
}
#line 265 "tmux_uaf_6.c"
int session_index(struct session *s , u_int___0 *i ) 
{ 


  {
#line 268
  *i = (u_int___0 )0;
#line 268
  while (*i < sessions.num) {
#line 269
    if ((unsigned long )s == (unsigned long )*(sessions.list + *i)) {
#line 270
      return (0);
    }
#line 268
    (*i) ++;
  }
#line 272
  return (-1);
}
}
#line 276 "tmux_uaf_6.c"
int session_next(struct session *s , int activity ) 
{ 
  struct winlink *wl ;

  {
#line 281
  if ((unsigned long )s->curw == (unsigned long )((void *)0)) {
#line 282
    return (-1);
  }
#line 284
  wl = winlink_next(& s->windows, s->curw);
#line 286
  if ((unsigned long )wl == (unsigned long )((void *)0)) {
#line 287
    wl = winlinks_RB_MINMAX(& s->windows, -1);
  }
#line 289
  if ((unsigned long )wl == (unsigned long )s->curw) {
#line 290
    return (1);
  }
#line 291
  winlink_stack_remove(& s->lastw, wl);
#line 292
  winlink_stack_push(& s->lastw, s->curw);
#line 293
  s->curw = wl;
#line 294
  return (0);
}
}
#line 298 "tmux_uaf_6.c"
void session_destroy(struct session *s ) 
{ 
  u_int___0 i ;
  int tmp ;

  {
#line 303
  printf((char const   * __restrict  )"session %s destroyed\n", s->name);
#line 305
  tmp = session_index(s, & i);
#line 305
  if (tmp != 0) {
#line 306
    printf((char const   * __restrict  )"session not found%s\n", "");
#line 306
    exit(1);
  }
#line 307
  while (1) {
#line 307
    *(sessions.list + i) = (struct session *)((void *)0);
#line 307
    break;
  }
#line 308
  while (1) {
#line 308
    if ((unsigned long )((void *)(& sessions)) == (unsigned long )((void *)0)) {
#line 308
      break;
    } else
#line 308
    if (sessions.num == 0U) {
#line 308
      break;
    } else
#line 308
    if (! ((unsigned long )*(sessions.list + (sessions.num - 1U)) == (unsigned long )((void *)0))) {
#line 308
      break;
    }
#line 309
    while (1) {
#line 309
      if (sessions.num > 1U) {
#line 309
        (sessions.num) --;
      } else {
#line 309
        while (1) {
#line 309
          free((void *)sessions.list);
#line 309
          while (1) {
#line 309
            sessions.num = (u_int___0 )0;
#line 309
            sessions.list = (struct session **)((void *)0);
#line 309
            sessions.space = (size_t )0;
#line 309
            break;
          }
#line 309
          break;
        }
      }
#line 309
      break;
    }
  }
#line 311
  while (! ((unsigned long )s->lastw.tqh_first == (unsigned long )((void *)0))) {
#line 312
    winlink_stack_remove(& s->lastw, s->lastw.tqh_first);
  }
#line 313
  while (! ((unsigned long )s->windows.rbh_root == (unsigned long )((void *)0))) {
#line 314
    winlink_remove(& s->windows, s->windows.rbh_root);
  }
#line 316
  free((void *)s->name);
#line 317
  free((void *)s);
#line 318
  return;
}
}
#line 320 "tmux_uaf_6.c"
struct window *window_create1(u_int___0 sx , u_int___0 sy ) 
{ 
  struct window *w ;
  u_int___0 i ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 326
  tmp = malloc(sizeof(*w));
#line 326
  w = (struct window *)tmp;
#line 327
  w->name = (char *)((void *)0);
#line 328
  w->flags = 0;
#line 330
  w->sx = sx;
#line 331
  w->sy = sy;
#line 333
  i = (u_int___0 )0;
#line 333
  while (i < windows.num) {
#line 334
    if ((unsigned long )*(windows.list + i) == (unsigned long )((void *)0)) {
#line 335
      while (1) {
#line 335
        *(windows.list + i) = w;
#line 335
        break;
      }
#line 336
      break;
    }
#line 333
    i ++;
  }
#line 339
  if (i == windows.num) {
#line 340
    while (1) {
#line 340
      while (1) {
#line 340
        if ((u_int___0 )((1 << 30) - 1) < windows.num) {
#line 340
          printf((char const   * __restrict  )"number too big%s", "");
#line 340
          exit(1);
        }
#line 340
        if ((unsigned long )((u_int___0 )(1 << 30) / (windows.num + 1U)) < sizeof(*(windows.list))) {
#line 340
          printf((char const   * __restrict  )"size too big%s", "");
#line 340
          exit(1);
        }
#line 340
        if (windows.space == 0UL) {
#line 340
          windows.space = 10UL * sizeof(*(windows.list));
#line 340
          tmp___0 = xrealloc((void *)windows.list, (size_t )1, windows.space);
#line 340
          windows.list = (struct window **)tmp___0;
        }
#line 340
        while (windows.space <= (unsigned long )(windows.num + 1U) * sizeof(*(windows.list))) {
#line 340
          tmp___1 = xrealloc((void *)windows.list, (size_t )2, windows.space);
#line 340
          windows.list = (struct window **)tmp___1;
#line 340
          windows.space *= 2UL;
        }
#line 340
        break;
      }
#line 340
      *(windows.list + windows.num) = w;
#line 340
      (windows.num) ++;
#line 340
      break;
    }
  }
#line 341
  w->references = (u_int___0 )0;
#line 343
  return (w);
}
}
#line 347 "tmux_uaf_6.c"
struct winlink *session_attach(struct session *s , struct window *w , int idx , char **cause ) 
{ 
  struct winlink *wl ;

  {
#line 352
  wl = winlink_add(& s->windows, w, idx);
#line 352
  if ((unsigned long )wl == (unsigned long )((void *)0)) {
#line 353
    printf((char const   * __restrict  )"index in use: %d\n", idx);
  }
#line 354
  return (wl);
}
}
#line 358 "tmux_uaf_6.c"
struct winlink *session_new(struct session *s , char const   *name , char const   *cmd ,
                            int idx , char **cause ) 
{ 
  struct window *w ;
  struct winlink *tmp ;

  {
#line 367
  w = window_create1(s->sx, s->sy);
#line 368
  if ((unsigned long )w == (unsigned long )((void *)0)) {
#line 369
    return ((struct winlink *)((void *)0));
  }
#line 371
  tmp = session_attach(s, w, idx, cause);
#line 371
  return (tmp);
}
}
#line 375 "tmux_uaf_6.c"
int session_select(struct session *s , int idx ) 
{ 
  struct winlink *wl ;

  {
#line 380
  wl = winlink_find_by_index(& s->windows, idx);
#line 381
  if ((unsigned long )wl == (unsigned long )((void *)0)) {
#line 382
    return (-1);
  }
#line 383
  if ((unsigned long )wl == (unsigned long )s->curw) {
#line 384
    return (1);
  }
#line 385
  winlink_stack_remove(& s->lastw, wl);
#line 386
  winlink_stack_push(& s->lastw, s->curw);
#line 387
  s->curw = wl;
#line 388
  return (0);
}
}
#line 418
extern int ( /* missing proto */  strdup)() ;
#line 391 "tmux_uaf_6.c"
struct session *session_create(char const   *name , char const   *cmd , int idx ,
                               u_int___0 sx , u_int___0 sy , char **cause ) 
{ 
  struct session *s ;
  u_int___0 i ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  struct winlink *tmp___3 ;

  {
#line 397
  tmp = malloc(sizeof(*s));
#line 397
  s = (struct session *)tmp;
#line 398
  s->references = 0;
#line 399
  s->flags = 0;
#line 401
  s->curw = (struct winlink *)((void *)0);
#line 402
  while (1) {
#line 402
    s->lastw.tqh_first = (struct winlink *)((void *)0);
#line 402
    s->lastw.tqh_last = & s->lastw.tqh_first;
#line 402
    break;
  }
#line 403
  while (1) {
#line 403
    s->windows.rbh_root = (struct winlink *)((void *)0);
#line 403
    break;
  }
#line 405
  s->sx = sx;
#line 406
  s->sy = sy;
#line 408
  i = (u_int___0 )0;
#line 408
  while (i < sessions.num) {
#line 409
    if ((unsigned long )*(sessions.list + i) == (unsigned long )((void *)0)) {
#line 410
      while (1) {
#line 410
        *(sessions.list + i) = s;
#line 410
        break;
      }
#line 411
      break;
    }
#line 408
    i ++;
  }
#line 414
  if (i == sessions.num) {
#line 415
    while (1) {
#line 415
      while (1) {
#line 415
        if ((u_int___0 )((1 << 30) - 1) < sessions.num) {
#line 415
          printf((char const   * __restrict  )"number too big%s", "");
#line 415
          exit(1);
        }
#line 415
        if ((unsigned long )((u_int___0 )(1 << 30) / (sessions.num + 1U)) < sizeof(*(sessions.list))) {
#line 415
          printf((char const   * __restrict  )"size too big%s", "");
#line 415
          exit(1);
        }
#line 415
        if (sessions.space == 0UL) {
#line 415
          sessions.space = 10UL * sizeof(*(sessions.list));
#line 415
          tmp___0 = xrealloc((void *)sessions.list, (size_t )1, sessions.space);
#line 415
          sessions.list = (struct session **)tmp___0;
        }
#line 415
        while (sessions.space <= (unsigned long )(sessions.num + 1U) * sizeof(*(sessions.list))) {
#line 415
          tmp___1 = xrealloc((void *)sessions.list, (size_t )2, sessions.space);
#line 415
          sessions.list = (struct session **)tmp___1;
#line 415
          sessions.space *= 2UL;
        }
#line 415
        break;
      }
#line 415
      *(sessions.list + sessions.num) = s;
#line 415
      (sessions.num) ++;
#line 415
      break;
    }
  }
#line 416
  if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 417
    printf((char const   * __restrict  )"no name%s\n", "");
#line 417
    exit(1);
  }
#line 418
  tmp___2 = strdup(name);
#line 418
  s->name = (char *)tmp___2;
#line 420
  if ((unsigned long )cmd != (unsigned long )((void *)0)) {
#line 421
    tmp___3 = session_new(s, (char const   *)((void *)0), cmd, idx, cause);
#line 421
    if ((unsigned long )tmp___3 == (unsigned long )((void *)0)) {
#line 422
      session_destroy(s);
#line 423
      return ((struct session *)((void *)0));
    }
#line 425
    session_select(s, (s->windows.rbh_root)->idx);
  }
#line 427
  printf((char const   * __restrict  )"session %s created\n", s->name);
#line 429
  return (s);
}
}
#line 433 "tmux_uaf_6.c"
void server_clean_dead(void) 
{ 
  struct session *s ;
  u_int___0 i ;

  {
#line 440
  i = (u_int___0 )0;
#line 440
  while (i < dead_sessions.num) {
#line 441
    s = *(dead_sessions.list + i);
#line 442
    if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 443
      goto __Cont;
    } else
#line 442
    if (s->references != 0) {
#line 443
      goto __Cont;
    }
#line 444
    while (1) {
#line 444
      *(dead_sessions.list + i) = (struct session *)((void *)0);
#line 444
      break;
    }
#line 445
    free((void *)s);
    __Cont: /* CIL Label */ 
#line 440
    i ++;
  }
#line 447
  return;
}
}
#line 449 "tmux_uaf_6.c"
int server_link_window(struct session *src , struct winlink *srcwl , struct session *dst ,
                       int dstidx , int killflag , int selectflag , char **cause ) 
{ 
  struct winlink *dstwl ;

  {
#line 456
  dstwl = (struct winlink *)((void *)0);
#line 457
  if (dstidx != -1) {
#line 458
    dstwl = winlink_find_by_index(& dst->windows, dstidx);
  }
#line 459
  if ((unsigned long )dstwl != (unsigned long )((void *)0)) {
#line 460
    if ((unsigned long )dstwl->window == (unsigned long )srcwl->window) {
#line 461
      return (0);
    }
#line 462
    if (killflag) {
#line 467
      winlink_stack_remove(& dst->lastw, dstwl);
#line 468
      winlink_remove(& dst->windows, dstwl);
#line 471
      if ((unsigned long )dstwl == (unsigned long )dst->curw) {
#line 472
        selectflag = 1;
      }
    }
  }
#line 478
  dstidx ++;
#line 479
  dstwl = session_attach(dst, srcwl->window, dstidx, cause);
#line 480
  if ((unsigned long )dstwl == (unsigned long )((void *)0)) {
#line 481
    return (-1);
  }
#line 483
  if (selectflag) {
#line 484
    session_select(dst, dstwl->idx);
  }
#line 485
  return (0);
}
}
#line 489 "tmux_uaf_6.c"
int main(int argc , char **argv ) 
{ 
  struct session *src ;
  struct session *dst ;
  char *name ;
  char *cause ;
  int i ;
  int tmp ;

  {
#line 496
  while (1) {
#line 496
    windows.num = (u_int___0 )0;
#line 496
    windows.list = (struct window **)((void *)0);
#line 496
    windows.space = (size_t )0;
#line 496
    break;
  }
#line 497
  while (1) {
#line 497
    sessions.num = (u_int___0 )0;
#line 497
    sessions.list = (struct session **)((void *)0);
#line 497
    sessions.space = (size_t )0;
#line 497
    break;
  }
#line 498
  while (1) {
#line 498
    dead_sessions.num = (u_int___0 )0;
#line 498
    dead_sessions.list = (struct session **)((void *)0);
#line 498
    dead_sessions.space = (size_t )0;
#line 498
    break;
  }
#line 500
  src = session_create((char const   *)*(argv + 0), "cmd", 0, (u_int___0 )80, (u_int___0 )40,
                       & cause);
#line 502
  if (argc == 0) {
#line 503
    dst = (struct session *)((void *)0);
  } else {
#line 505
    tmp = strdup(*(argv + 1));
#line 505
    name = (char *)tmp;
#line 506
    dst = session_create((char const   *)*(argv + 1), "cmd", 1, (u_int___0 )80, (u_int___0 )40,
                         & cause);
  }
#line 509
  if (argc != 0) {
#line 510
    server_link_window(src, src->curw, dst, 1, 1, 0, & cause);
  }
#line 512
  i = 0;
#line 512
  while ((u_int___0 )i < sessions.num) {
#line 513
    session_destroy(*(sessions.list + i));
#line 512
    i ++;
  }
#line 515
  server_clean_dead();
#line 516
  return (0);
}
}
