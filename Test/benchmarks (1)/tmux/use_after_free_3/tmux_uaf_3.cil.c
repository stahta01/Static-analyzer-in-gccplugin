/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

#line 216 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h"
typedef unsigned long size_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 192 "../stdio.h"
typedef unsigned short u_short___0;
#line 193 "../stdio.h"
typedef unsigned int u_int___0;
#line 204 "../stdio.h"
typedef unsigned char u_char___0;
#line 210 "../stdio.h"
typedef int pid_t___0;
#line 39 "../tmux.h"
typedef char bitstr_t;
#line 41 "../tmux.h"
struct event {

};
#line 42 "../tmux.h"
struct termios {

};
#line 48
struct args;
#line 48
struct args;
#line 49
struct client;
#line 49
struct client;
#line 50
struct cmd_find_state;
#line 50
struct cmd_find_state;
#line 51
struct cmdq_item;
#line 51
struct cmdq_item;
#line 52
struct cmdq_list;
#line 52
struct cmdq_list;
#line 53
struct environ;
#line 53
struct environ;
#line 54
struct format_job_tree;
#line 54
struct format_job_tree;
#line 55
struct input_ctx;
#line 55
struct input_ctx;
#line 57
struct mouse_event;
#line 57
struct mouse_event;
#line 58
struct options;
#line 58
struct options;
#line 59
struct options_entry;
#line 59
struct options_entry;
#line 60
struct session;
#line 60
struct session;
#line 61
struct tmuxpeer;
#line 61
struct tmuxpeer;
#line 138 "../tmux.h"
typedef unsigned long long key_code;
#line 470 "../tmux.h"
struct options_tree {
   struct options_entry *rbh_root ;
};
#line 470 "../tmux.h"
struct options {
   struct options_tree tree ;
   struct options *parent ;
};
#line 494 "../tmux.h"
struct msg_command_data {
   int argc ;
};
#line 540 "../tmux.h"
struct utf8_data {
   u_char___0 data[9] ;
   u_char___0 have ;
   u_char___0 size ;
   u_char___0 width ;
};
#line 582 "../tmux.h"
struct grid_cell {
   u_char___0 flags ;
   u_short___0 attr ;
   int fg ;
   int bg ;
   struct utf8_data data ;
};
#line 589 "../tmux.h"
struct __anonstruct_data_29 {
   u_char___0 attr ;
   u_char___0 fg ;
   u_char___0 bg ;
   u_char___0 data ;
};
#line 589 "../tmux.h"
union __anonunion____missing_field_name_28 {
   u_int___0 offset ;
   struct __anonstruct_data_29 data ;
};
#line 589 "../tmux.h"
struct grid_cell_entry {
   u_char___0 flags ;
   union __anonunion____missing_field_name_28 __annonCompField1 ;
};
#line 603 "../tmux.h"
struct grid_line {
   u_int___0 cellused ;
   u_int___0 cellsize ;
   struct grid_cell_entry *celldata ;
   u_int___0 extdsize ;
   struct grid_cell *extddata ;
   int flags ;
};
#line 615 "../tmux.h"
struct grid {
   int flags ;
   u_int___0 sx ;
   u_int___0 sy ;
   u_int___0 hscrolled ;
   u_int___0 hsize ;
   u_int___0 hlimit ;
   struct grid_line *linedata ;
};
#line 630
struct cmd_list;
#line 643
struct bufferevent;
#line 668
enum __anonenum_lineflag_33 {
    LINE_SEL_NONE = 0,
    LINE_SEL_LEFT_RIGHT = 1,
    LINE_SEL_RIGHT_LEFT = 2
} ;
#line 668 "../tmux.h"
struct screen_sel {
   int flag ;
   int hidden ;
   int rectflag ;
   enum __anonenum_lineflag_33 lineflag ;
   int modekeys ;
   u_int___0 sx ;
   u_int___0 sy ;
   u_int___0 ex ;
   u_int___0 ey ;
   struct grid_cell cell ;
};
#line 690
struct screen_titles;
#line 690
struct screen_titles;
#line 691 "../tmux.h"
struct screen {
   char *title ;
   struct screen_titles *titles ;
   struct grid *grid ;
   u_int___0 cx ;
   u_int___0 cy ;
   u_int___0 cstyle ;
   char *ccolour ;
   u_int___0 rupper ;
   u_int___0 rlower ;
   u_int___0 hsize ;
   int mode ;
   bitstr_t *tabs ;
   struct screen_sel sel ;
};
#line 718
struct window_pane;
#line 743 "../tmux.h"
struct window_mode {
   char const   *name ;
   struct screen *(*init)(struct window_pane * , struct cmd_find_state * , struct args * ) ;
   void (*free)(struct window_pane * ) ;
   void (*resize)(struct window_pane * , u_int___0  , u_int___0  ) ;
   void (*key)(struct window_pane * , struct client * , struct session * , key_code  ,
               struct mouse_event * ) ;
   char const   *(*key_table)(struct window_pane * ) ;
   void (*command)(struct window_pane * , struct client * , struct session * , struct args * ,
                   struct mouse_event * ) ;
};
#line 763
struct winlink;
#line 763
struct format_tree;
#line 763 "../tmux.h"
struct window_choose_data {
   struct client *start_client ;
   struct session *start_session ;
   struct session *session ;
   u_int___0 idx ;
   int type ;
   struct session *tree_session ;
   struct winlink *wl ;
   int pane_id ;
   char *ft_template ;
   struct format_tree *ft ;
   char *command ;
};
#line 785
struct window;
#line 785
struct layout_cell;
#line 785 "../tmux.h"
struct __anonstruct_entry_34 {
   struct window_pane *tqe_next ;
   struct window_pane **tqe_prev ;
};
#line 785 "../tmux.h"
struct __anonstruct_tree_entry_35 {
   struct window_pane *rbe_left ;
   struct window_pane *rbe_right ;
   struct window_pane *rbe_parent ;
   int rbe_color ;
};
#line 785 "../tmux.h"
struct window_pane {
   u_int___0 id ;
   u_int___0 active_point ;
   struct window *window ;
   struct layout_cell *layout_cell ;
   struct layout_cell *saved_layout_cell ;
   u_int___0 sx ;
   u_int___0 sy ;
   u_int___0 osx ;
   u_int___0 osy ;
   u_int___0 xoff ;
   u_int___0 yoff ;
   int flags ;
   int argc ;
   char **argv ;
   char *shell ;
   char const   *cwd ;
   pid_t___0 pid ;
   char tty[10] ;
   int status ;
   int fd ;
   struct bufferevent *event ;
   struct event resize_timer ;
   struct input_ctx *ictx ;
   struct grid_cell colgc ;
   int *palette ;
   int pipe_fd ;
   struct bufferevent *pipe_event ;
   size_t pipe_off ;
   struct screen *screen ;
   struct screen base ;
   struct screen status_screen ;
   size_t status_size ;
   u_int___0 saved_cx ;
   u_int___0 saved_cy ;
   struct grid *saved_grid ;
   struct grid_cell saved_cell ;
   struct window_mode  const  *mode ;
   void *modedata ;
   struct event modetimer ;
   time_t modelast ;
   u_int___0 modeprefix ;
   char *searchstr ;
   struct __anonstruct_entry_34 entry ;
   struct __anonstruct_tree_entry_35 tree_entry ;
};
#line 862 "../tmux.h"
struct window_panes {
   struct window_pane *tqh_first ;
   struct window_pane **tqh_last ;
};
#line 867 "../tmux.h"
struct __anonstruct_alerts_entry_36 {
   struct window *tqe_next ;
   struct window **tqe_prev ;
};
#line 867 "../tmux.h"
struct __anonstruct_winlinks_37 {
   struct winlink *tqh_first ;
   struct winlink **tqh_last ;
};
#line 867 "../tmux.h"
struct __anonstruct_entry_38 {
   struct window *rbe_left ;
   struct window *rbe_right ;
   struct window *rbe_parent ;
   int rbe_color ;
};
#line 867 "../tmux.h"
struct window {
   u_int___0 id ;
   char *name ;
   struct event name_event ;
   struct timeval name_time ;
   struct event alerts_timer ;
   struct timeval activity_time ;
   struct window_pane *active ;
   struct window_pane *last ;
   struct window_panes panes ;
   int lastlayout ;
   struct layout_cell *layout_root ;
   struct layout_cell *saved_layout_root ;
   char *old_layout ;
   u_int___0 sx ;
   u_int___0 sy ;
   int flags ;
   int alerts_queued ;
   struct __anonstruct_alerts_entry_36 alerts_entry ;
   struct options *options ;
   struct grid_cell style ;
   struct grid_cell active_style ;
   u_int___0 references ;
   struct __anonstruct_winlinks_37 winlinks ;
   struct __anonstruct_entry_38 entry ;
};
#line 919 "../tmux.h"
struct __anonstruct_entry_39 {
   struct winlink *rbe_left ;
   struct winlink *rbe_right ;
   struct winlink *rbe_parent ;
   int rbe_color ;
};
#line 919 "../tmux.h"
struct __anonstruct_wentry_40 {
   struct winlink *tqe_next ;
   struct winlink **tqe_prev ;
};
#line 919 "../tmux.h"
struct __anonstruct_sentry_41 {
   struct winlink *tqe_next ;
   struct winlink **tqe_prev ;
};
#line 919 "../tmux.h"
struct winlink {
   int idx ;
   struct session *session ;
   struct window *window ;
   size_t status_width ;
   struct grid_cell status_cell ;
   char *status_text ;
   int flags ;
   struct __anonstruct_entry_39 entry ;
   struct __anonstruct_wentry_40 wentry ;
   struct __anonstruct_sentry_41 sentry ;
};
#line 938 "../tmux.h"
struct winlinks {
   struct winlink *rbh_root ;
};
#line 939 "../tmux.h"
struct winlink_stack {
   struct winlink *tqh_first ;
   struct winlink **tqh_last ;
};
#line 942
enum layout_type {
    LAYOUT_LEFTRIGHT = 0,
    LAYOUT_TOPBOTTOM = 1,
    LAYOUT_WINDOWPANE = 2
} ;
#line 949 "../tmux.h"
struct layout_cells {
   struct layout_cell *tqh_first ;
   struct layout_cell **tqh_last ;
};
#line 952 "../tmux.h"
struct __anonstruct_entry_42 {
   struct layout_cell *tqe_next ;
   struct layout_cell **tqe_prev ;
};
#line 952 "../tmux.h"
struct layout_cell {
   enum layout_type type ;
   struct layout_cell *parent ;
   u_int___0 sx ;
   u_int___0 sy ;
   u_int___0 xoff ;
   u_int___0 yoff ;
   struct window_pane *wp ;
   struct layout_cells cells ;
   struct __anonstruct_entry_42 entry ;
};
#line 987
struct hooks;
#line 987 "../tmux.h"
struct __anonstruct_gentry_46 {
   struct session *tqe_next ;
   struct session **tqe_prev ;
};
#line 987 "../tmux.h"
struct __anonstruct_entry_47 {
   struct session *rbe_left ;
   struct session *rbe_right ;
   struct session *rbe_parent ;
   int rbe_color ;
};
#line 987 "../tmux.h"
struct session {
   u_int___0 id ;
   char *name ;
   char const   *cwd ;
   struct timeval creation_time ;
   struct timeval last_attached_time ;
   struct timeval activity_time ;
   struct timeval last_activity_time ;
   struct event lock_timer ;
   u_int___0 sx ;
   u_int___0 sy ;
   struct winlink *curw ;
   struct winlink_stack lastw ;
   struct winlinks windows ;
   int statusat ;
   struct hooks *hooks ;
   struct options *options ;
   int flags ;
   u_int___0 attached ;
   struct termios *tio ;
   struct environ *environ ;
   int references ;
   struct __anonstruct_gentry_46 gentry ;
   struct __anonstruct_entry_47 entry ;
};
#line 1028 "../tmux.h"
struct sessions {
   struct session *rbh_root ;
};
#line 1050 "../tmux.h"
struct mouse_event {
   int valid ;
   key_code key ;
   int statusat ;
   u_int___0 x ;
   u_int___0 y ;
   u_int___0 b ;
   u_int___0 lx ;
   u_int___0 ly ;
   u_int___0 lb ;
   int s ;
   int w ;
   int wp ;
   u_int___0 sgr_type ;
   u_int___0 sgr_b ;
};
#line 1073 "../tmux.h"
struct tty_key {
   char ch ;
   key_code key ;
   struct tty_key *left ;
   struct tty_key *right ;
   struct tty_key *next ;
};
#line 1083
struct tty_code;
#line 1083
struct tty_code;
#line 1084 "../tmux.h"
struct __anonstruct_entry_48 {

};
#line 1084 "../tmux.h"
struct tty_term {
   char *name ;
   u_int___0 references ;
   char acs[11][2] ;
   struct tty_code *codes ;
   int flags ;
   struct __anonstruct_entry_48 entry ;
};
#line 1100
struct evbuffer;
#line 1100
enum __anonenum_term_type_49 {
    TTY_VT100 = 0,
    TTY_VT101 = 1,
    TTY_VT102 = 2,
    TTY_VT220 = 3,
    TTY_VT320 = 4,
    TTY_VT420 = 5,
    TTY_UNKNOWN = 6
} ;
#line 1100 "../tmux.h"
struct tty {
   struct client *client ;
   u_int___0 sx ;
   u_int___0 sy ;
   u_int___0 cx ;
   u_int___0 cy ;
   u_int___0 cstyle ;
   char *ccolour ;
   int mode ;
   u_int___0 rlower ;
   u_int___0 rupper ;
   u_int___0 rleft ;
   u_int___0 rright ;
   int fd ;
   struct event event_in ;
   struct evbuffer *in ;
   struct event event_out ;
   struct evbuffer *out ;
   struct event timer ;
   size_t discarded ;
   struct termios tio ;
   struct grid_cell cell ;
   int last_wp ;
   struct grid_cell last_cell ;
   int flags ;
   struct tty_term *term ;
   char *term_name ;
   int term_flags ;
   enum __anonenum_term_type_49 term_type ;
   struct mouse_event mouse ;
   int mouse_drag_flag ;
   void (*mouse_drag_update)(struct client * , struct mouse_event * ) ;
   void (*mouse_drag_release)(struct client * , struct mouse_event * ) ;
   struct event key_timer ;
   struct tty_key *key_tree ;
};
#line 1199 "../tmux.h"
struct __anonstruct_entry_50 {
   struct message_entry *tqe_next ;
   struct message_entry **tqe_prev ;
};
#line 1199 "../tmux.h"
struct message_entry {
   char *msg ;
   u_int___0 msg_num ;
   time_t msg_time ;
   struct __anonstruct_entry_50 entry ;
};
#line 1208 "../tmux.h"
struct __anonstruct_entry_51 {
   struct args_entry *rbe_left ;
   struct args_entry *rbe_right ;
   struct args_entry *rbe_parent ;
   int rbe_color ;
};
#line 1208 "../tmux.h"
struct args_entry {
   u_char___0 flag ;
   char *value ;
   struct __anonstruct_entry_51 entry ;
};
#line 1214 "../tmux.h"
struct args_tree {
   struct args_entry *rbh_root ;
};
#line 1215 "../tmux.h"
struct args {
   struct args_tree tree ;
   int argc ;
   char **argv ;
};
#line 1227 "../tmux.h"
struct cmd_find_state {
   int flags ;
   struct cmd_find_state *current ;
   struct session *s ;
   struct winlink *wl ;
   struct window *w ;
   struct window_pane *wp ;
   int idx ;
};
#line 1248
struct cmd_entry;
#line 1248 "../tmux.h"
struct __anonstruct_qentry_52 {
   struct cmd *tqe_next ;
   struct cmd **tqe_prev ;
};
#line 1248 "../tmux.h"
struct cmd {
   struct cmd_entry  const  *entry ;
   struct args *args ;
   char *file ;
   u_int___0 line ;
   int flags ;
   void *data ;
   struct __anonstruct_qentry_52 qentry ;
};
#line 1261 "../tmux.h"
struct __anonstruct_list_53 {
   struct cmd *tqh_first ;
   struct cmd **tqh_last ;
};
#line 1261 "../tmux.h"
struct cmd_list {
   int references ;
   struct __anonstruct_list_53 list ;
};
#line 1296
struct cmdq_item;
#line 1297 "../tmux.h"
struct cmdq_list {
   struct cmdq_item *tqh_first ;
   struct cmdq_item **tqh_last ;
};
#line 1307
struct cmd_entry;
#line 1313
struct key_table;
#line 1313 "../tmux.h"
struct __anonstruct_message_log_54 {
   struct message_entry *tqh_first ;
   struct message_entry **tqh_last ;
};
#line 1313
enum __anonenum_prompt_mode_55 {
    PROMPT_ENTRY = 0,
    PROMPT_COMMAND = 1
} ;
#line 1313
struct cmd_q;
#line 1313 "../tmux.h"
struct __anonstruct_entry_56 {
   struct client *tqe_next ;
   struct client **tqe_prev ;
};
#line 1313 "../tmux.h"
struct client {
   char const   *name ;
   struct tmuxpeer *peer ;
   struct cmdq_list queue ;
   pid_t___0 pid ;
   int fd ;
   struct event event ;
   int retval ;
   struct timeval creation_time ;
   struct timeval activity_time ;
   struct environ *environ ;
   struct format_job_tree *jobs ;
   char *title ;
   char const   *cwd ;
   char *term ;
   char *ttyname ;
   struct tty tty ;
   size_t written ;
   size_t discarded ;
   size_t redraw ;
   void (*stdin_callback)(struct client * , int  , void * ) ;
   void *stdin_callback_data ;
   struct evbuffer *stdin_data ;
   int stdin_closed ;
   struct evbuffer *stdout_data ;
   struct evbuffer *stderr_data ;
   struct event repeat_timer ;
   struct event click_timer ;
   u_int___0 click_button ;
   struct event status_timer ;
   struct screen status ;
   struct screen *old_status ;
   int flags ;
   struct key_table *keytable ;
   struct event identify_timer ;
   void (*identify_callback)(struct client * , struct window_pane * ) ;
   void *identify_callback_data ;
   char *message_string ;
   struct event message_timer ;
   u_int___0 message_next ;
   struct __anonstruct_message_log_54 message_log ;
   char *prompt_string ;
   struct utf8_data *prompt_buffer ;
   size_t prompt_index ;
   int (*prompt_inputcb)(struct client * , void * , char const   * , int  ) ;
   void (*prompt_freecb)(void * ) ;
   void *prompt_data ;
   u_int___0 prompt_hindex ;
   enum __anonenum_prompt_mode_55 prompt_mode ;
   int prompt_flags ;
   struct session *session ;
   struct session *last_session ;
   int wlmouse ;
   int references ;
   struct cmd_q *cmdq ;
   struct __anonstruct_entry_56 entry ;
};
#line 1424 "../tmux.h"
struct __anonstruct_entry_57 {
   struct key_binding *rbe_left ;
   struct key_binding *rbe_right ;
   struct key_binding *rbe_parent ;
   int rbe_color ;
};
#line 1424 "../tmux.h"
struct key_binding {
   key_code key ;
   struct cmd_list *cmdlist ;
   int flags ;
   struct __anonstruct_entry_57 entry ;
};
#line 1433 "../tmux.h"
struct key_bindings {
   struct key_binding *rbh_root ;
};
#line 1435 "../tmux.h"
struct __anonstruct_entry_58 {
   struct key_table *rbe_left ;
   struct key_table *rbe_right ;
   struct key_table *rbe_parent ;
   int rbe_color ;
};
#line 1435 "../tmux.h"
struct key_table {
   char const   *name ;
   struct key_bindings key_bindings ;
   u_int___0 references ;
   struct __anonstruct_entry_58 entry ;
};
#line 1504
struct format_tree;
#line 13 "tmux_uaf_3.c"
struct cmd_ctx {
   struct client *curclient ;
   struct client *cmdclient ;
   struct msg_command_data *msgdata ;
   void (*print)(struct cmd_ctx * , char const   *  , ...) ;
   void (*info)(struct cmd_ctx * , char const   *  , ...) ;
   void (*error)(struct cmd_ctx * , char const   *  , ...) ;
};
#line 53
enum window_choose_input_type {
    WINDOW_CHOOSE_NORMAL = -1,
    WINDOW_CHOOSE_GOTO_ITEM = 0
} ;
#line 58 "tmux_uaf_3.c"
struct window_choose_mode_item {
   struct window_choose_data *wcd ;
   char *name ;
   int pos ;
   int state ;
};
#line 66 "tmux_uaf_3.c"
struct __anonstruct_list_59 {
   struct window_choose_mode_item *list ;
   u_int___0 num ;
   size_t space ;
};
#line 66 "tmux_uaf_3.c"
struct __anonstruct_old_list_60 {
   struct window_choose_mode_item *list ;
   u_int___0 num ;
   size_t space ;
};
#line 66 "tmux_uaf_3.c"
struct window_choose_mode_data {
   struct screen screen ;
   struct __anonstruct_list_59 list ;
   struct __anonstruct_old_list_60 old_list ;
   int width ;
   u_int___0 top ;
   u_int___0 selected ;
   enum window_choose_input_type input_type ;
   char const   *input_prompt ;
   char *input_str ;
   void (*callbackfn)(struct window_choose_data * ) ;
   void (*freefn)(struct window_choose_data * ) ;
};
#line 200 "tmux_uaf_3.c"
struct __anonstruct_list_copy_61 {
   struct window_choose_mode_item *list ;
   u_int___0 num ;
   size_t space ;
};
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 538
extern int getchar(void) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 34 "tmux_uaf_3.c"
struct screen *window_choose_init(struct window_pane *wp ) ;
#line 35
void window_choose_free(struct window_pane *wp ) ;
#line 48
void window_choose_collapse(struct window_pane *wp , struct session *s ) ;
#line 49
void window_choose_expand(struct window_pane *wp , struct session *s , u_int___0 pos ) ;
#line 50
void window_choose_collapse_all(struct window_pane *wp ) ;
#line 51
void window_choose_expand_all(struct window_pane *wp ) ;
#line 91
extern int ( /* missing proto */  strcmp)() ;
#line 88 "tmux_uaf_3.c"
int session_cmp(struct session *s1 , struct session *s2 ) 
{ 
  int tmp ;

  {
#line 91
  tmp = strcmp(s1->name, s2->name);
#line 91
  return (tmp);
}
}
#line 94 "tmux_uaf_3.c"
void sessions_RB_INSERT_COLOR(struct sessions *head , struct session *elm ) 
{ 
  struct session *parent ;
  struct session *gparent ;
  struct session *tmp ;
  struct session *tmp___0 ;
  struct session *tmp___1 ;
  struct session *tmp___2 ;
  struct session *tmp___3 ;
  struct session *tmp___4 ;
  struct session *tmp___5 ;
  struct session *tmp___6 ;
  struct session *tmp___7 ;

  {
#line 94
  while (1) {
#line 94
    parent = elm->entry.rbe_parent;
#line 94
    if ((unsigned long )parent != (unsigned long )((void *)0)) {
#line 94
      if (! (parent->entry.rbe_color == 1)) {
#line 94
        break;
      }
    } else {
#line 94
      break;
    }
#line 94
    gparent = parent->entry.rbe_parent;
#line 94
    if ((unsigned long )parent == (unsigned long )gparent->entry.rbe_left) {
#line 94
      tmp = gparent->entry.rbe_right;
#line 94
      if (tmp) {
#line 94
        if (tmp->entry.rbe_color == 1) {
#line 94
          tmp->entry.rbe_color = 0;
#line 94
          while (1) {
#line 94
            parent->entry.rbe_color = 0;
#line 94
            gparent->entry.rbe_color = 1;
#line 94
            break;
          }
#line 94
          elm = gparent;
#line 94
          continue;
        }
      }
#line 94
      if ((unsigned long )parent->entry.rbe_right == (unsigned long )elm) {
#line 94
        while (1) {
#line 94
          tmp = parent->entry.rbe_right;
#line 94
          tmp___0 = tmp->entry.rbe_left;
#line 94
          parent->entry.rbe_right = tmp___0;
#line 94
          if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 94
            (tmp->entry.rbe_left)->entry.rbe_parent = parent;
          }
#line 94
          while (1) {
#line 94
            break;
          }
#line 94
          tmp___1 = parent->entry.rbe_parent;
#line 94
          tmp->entry.rbe_parent = tmp___1;
#line 94
          if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
#line 94
            if ((unsigned long )parent == (unsigned long )(parent->entry.rbe_parent)->entry.rbe_left) {
#line 94
              (parent->entry.rbe_parent)->entry.rbe_left = tmp;
            } else {
#line 94
              (parent->entry.rbe_parent)->entry.rbe_right = tmp;
            }
          } else {
#line 94
            head->rbh_root = tmp;
          }
#line 94
          tmp->entry.rbe_left = parent;
#line 94
          parent->entry.rbe_parent = tmp;
#line 94
          while (1) {
#line 94
            break;
          }
#line 94
          if (tmp->entry.rbe_parent) {
#line 94
            while (1) {
#line 94
              break;
            }
          }
#line 94
          break;
        }
#line 94
        tmp = parent;
#line 94
        parent = elm;
#line 94
        elm = tmp;
      }
#line 94
      while (1) {
#line 94
        parent->entry.rbe_color = 0;
#line 94
        gparent->entry.rbe_color = 1;
#line 94
        break;
      }
#line 94
      while (1) {
#line 94
        tmp = gparent->entry.rbe_left;
#line 94
        tmp___2 = tmp->entry.rbe_right;
#line 94
        gparent->entry.rbe_left = tmp___2;
#line 94
        if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
#line 94
          (tmp->entry.rbe_right)->entry.rbe_parent = gparent;
        }
#line 94
        while (1) {
#line 94
          break;
        }
#line 94
        tmp___3 = gparent->entry.rbe_parent;
#line 94
        tmp->entry.rbe_parent = tmp___3;
#line 94
        if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
#line 94
          if ((unsigned long )gparent == (unsigned long )(gparent->entry.rbe_parent)->entry.rbe_left) {
#line 94
            (gparent->entry.rbe_parent)->entry.rbe_left = tmp;
          } else {
#line 94
            (gparent->entry.rbe_parent)->entry.rbe_right = tmp;
          }
        } else {
#line 94
          head->rbh_root = tmp;
        }
#line 94
        tmp->entry.rbe_right = gparent;
#line 94
        gparent->entry.rbe_parent = tmp;
#line 94
        while (1) {
#line 94
          break;
        }
#line 94
        if (tmp->entry.rbe_parent) {
#line 94
          while (1) {
#line 94
            break;
          }
        }
#line 94
        break;
      }
    } else {
#line 94
      tmp = gparent->entry.rbe_left;
#line 94
      if (tmp) {
#line 94
        if (tmp->entry.rbe_color == 1) {
#line 94
          tmp->entry.rbe_color = 0;
#line 94
          while (1) {
#line 94
            parent->entry.rbe_color = 0;
#line 94
            gparent->entry.rbe_color = 1;
#line 94
            break;
          }
#line 94
          elm = gparent;
#line 94
          continue;
        }
      }
#line 94
      if ((unsigned long )parent->entry.rbe_left == (unsigned long )elm) {
#line 94
        while (1) {
#line 94
          tmp = parent->entry.rbe_left;
#line 94
          tmp___4 = tmp->entry.rbe_right;
#line 94
          parent->entry.rbe_left = tmp___4;
#line 94
          if ((unsigned long )tmp___4 != (unsigned long )((void *)0)) {
#line 94
            (tmp->entry.rbe_right)->entry.rbe_parent = parent;
          }
#line 94
          while (1) {
#line 94
            break;
          }
#line 94
          tmp___5 = parent->entry.rbe_parent;
#line 94
          tmp->entry.rbe_parent = tmp___5;
#line 94
          if ((unsigned long )tmp___5 != (unsigned long )((void *)0)) {
#line 94
            if ((unsigned long )parent == (unsigned long )(parent->entry.rbe_parent)->entry.rbe_left) {
#line 94
              (parent->entry.rbe_parent)->entry.rbe_left = tmp;
            } else {
#line 94
              (parent->entry.rbe_parent)->entry.rbe_right = tmp;
            }
          } else {
#line 94
            head->rbh_root = tmp;
          }
#line 94
          tmp->entry.rbe_right = parent;
#line 94
          parent->entry.rbe_parent = tmp;
#line 94
          while (1) {
#line 94
            break;
          }
#line 94
          if (tmp->entry.rbe_parent) {
#line 94
            while (1) {
#line 94
              break;
            }
          }
#line 94
          break;
        }
#line 94
        tmp = parent;
#line 94
        parent = elm;
#line 94
        elm = tmp;
      }
#line 94
      while (1) {
#line 94
        parent->entry.rbe_color = 0;
#line 94
        gparent->entry.rbe_color = 1;
#line 94
        break;
      }
#line 94
      while (1) {
#line 94
        tmp = gparent->entry.rbe_right;
#line 94
        tmp___6 = tmp->entry.rbe_left;
#line 94
        gparent->entry.rbe_right = tmp___6;
#line 94
        if ((unsigned long )tmp___6 != (unsigned long )((void *)0)) {
#line 94
          (tmp->entry.rbe_left)->entry.rbe_parent = gparent;
        }
#line 94
        while (1) {
#line 94
          break;
        }
#line 94
        tmp___7 = gparent->entry.rbe_parent;
#line 94
        tmp->entry.rbe_parent = tmp___7;
#line 94
        if ((unsigned long )tmp___7 != (unsigned long )((void *)0)) {
#line 94
          if ((unsigned long )gparent == (unsigned long )(gparent->entry.rbe_parent)->entry.rbe_left) {
#line 94
            (gparent->entry.rbe_parent)->entry.rbe_left = tmp;
          } else {
#line 94
            (gparent->entry.rbe_parent)->entry.rbe_right = tmp;
          }
        } else {
#line 94
          head->rbh_root = tmp;
        }
#line 94
        tmp->entry.rbe_left = gparent;
#line 94
        gparent->entry.rbe_parent = tmp;
#line 94
        while (1) {
#line 94
          break;
        }
#line 94
        if (tmp->entry.rbe_parent) {
#line 94
          while (1) {
#line 94
            break;
          }
        }
#line 94
        break;
      }
    }
  }
#line 94
  (head->rbh_root)->entry.rbe_color = 0;
#line 94
  return;
}
}
#line 94 "tmux_uaf_3.c"
void sessions_RB_REMOVE_COLOR(struct sessions *head , struct session *parent , struct session *elm ) 
{ 
  struct session *tmp ;
  struct session *tmp___0 ;
  struct session *tmp___1 ;
  struct session *oleft ;
  struct session *tmp___2 ;
  struct session *tmp___3 ;
  struct session *tmp___4 ;
  struct session *tmp___5 ;
  struct session *tmp___6 ;
  struct session *tmp___7 ;
  struct session *oright ;
  struct session *tmp___8 ;
  struct session *tmp___9 ;
  struct session *tmp___10 ;
  struct session *tmp___11 ;

  {
#line 94
  while (1) {
#line 94
    if ((unsigned long )elm == (unsigned long )((void *)0)) {
#line 94
      goto _L___5;
    } else
#line 94
    if (elm->entry.rbe_color == 0) {
      _L___5: /* CIL Label */ 
#line 94
      if (! ((unsigned long )elm != (unsigned long )head->rbh_root)) {
#line 94
        break;
      }
    } else {
#line 94
      break;
    }
#line 94
    if ((unsigned long )parent->entry.rbe_left == (unsigned long )elm) {
#line 94
      tmp = parent->entry.rbe_right;
#line 94
      if (tmp->entry.rbe_color == 1) {
#line 94
        while (1) {
#line 94
          tmp->entry.rbe_color = 0;
#line 94
          parent->entry.rbe_color = 1;
#line 94
          break;
        }
#line 94
        while (1) {
#line 94
          tmp = parent->entry.rbe_right;
#line 94
          tmp___0 = tmp->entry.rbe_left;
#line 94
          parent->entry.rbe_right = tmp___0;
#line 94
          if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 94
            (tmp->entry.rbe_left)->entry.rbe_parent = parent;
          }
#line 94
          while (1) {
#line 94
            break;
          }
#line 94
          tmp___1 = parent->entry.rbe_parent;
#line 94
          tmp->entry.rbe_parent = tmp___1;
#line 94
          if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
#line 94
            if ((unsigned long )parent == (unsigned long )(parent->entry.rbe_parent)->entry.rbe_left) {
#line 94
              (parent->entry.rbe_parent)->entry.rbe_left = tmp;
            } else {
#line 94
              (parent->entry.rbe_parent)->entry.rbe_right = tmp;
            }
          } else {
#line 94
            head->rbh_root = tmp;
          }
#line 94
          tmp->entry.rbe_left = parent;
#line 94
          parent->entry.rbe_parent = tmp;
#line 94
          while (1) {
#line 94
            break;
          }
#line 94
          if (tmp->entry.rbe_parent) {
#line 94
            while (1) {
#line 94
              break;
            }
          }
#line 94
          break;
        }
#line 94
        tmp = parent->entry.rbe_right;
      }
#line 94
      if ((unsigned long )tmp->entry.rbe_left == (unsigned long )((void *)0)) {
#line 94
        goto _L___1;
      } else
#line 94
      if ((tmp->entry.rbe_left)->entry.rbe_color == 0) {
        _L___1: /* CIL Label */ 
#line 94
        if ((unsigned long )tmp->entry.rbe_right == (unsigned long )((void *)0)) {
#line 94
          tmp->entry.rbe_color = 1;
#line 94
          elm = parent;
#line 94
          parent = elm->entry.rbe_parent;
        } else
#line 94
        if ((tmp->entry.rbe_right)->entry.rbe_color == 0) {
#line 94
          tmp->entry.rbe_color = 1;
#line 94
          elm = parent;
#line 94
          parent = elm->entry.rbe_parent;
        } else {
#line 94
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 94
        if ((unsigned long )tmp->entry.rbe_right == (unsigned long )((void *)0)) {
#line 94
          goto _L;
        } else
#line 94
        if ((tmp->entry.rbe_right)->entry.rbe_color == 0) {
          _L: /* CIL Label */ 
#line 94
          oleft = tmp->entry.rbe_left;
#line 94
          if ((unsigned long )oleft != (unsigned long )((void *)0)) {
#line 94
            oleft->entry.rbe_color = 0;
          }
#line 94
          tmp->entry.rbe_color = 1;
#line 94
          while (1) {
#line 94
            oleft = tmp->entry.rbe_left;
#line 94
            tmp___2 = oleft->entry.rbe_right;
#line 94
            tmp->entry.rbe_left = tmp___2;
#line 94
            if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
#line 94
              (oleft->entry.rbe_right)->entry.rbe_parent = tmp;
            }
#line 94
            while (1) {
#line 94
              break;
            }
#line 94
            tmp___3 = tmp->entry.rbe_parent;
#line 94
            oleft->entry.rbe_parent = tmp___3;
#line 94
            if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
#line 94
              if ((unsigned long )tmp == (unsigned long )(tmp->entry.rbe_parent)->entry.rbe_left) {
#line 94
                (tmp->entry.rbe_parent)->entry.rbe_left = oleft;
              } else {
#line 94
                (tmp->entry.rbe_parent)->entry.rbe_right = oleft;
              }
            } else {
#line 94
              head->rbh_root = oleft;
            }
#line 94
            oleft->entry.rbe_right = tmp;
#line 94
            tmp->entry.rbe_parent = oleft;
#line 94
            while (1) {
#line 94
              break;
            }
#line 94
            if (oleft->entry.rbe_parent) {
#line 94
              while (1) {
#line 94
                break;
              }
            }
#line 94
            break;
          }
#line 94
          tmp = parent->entry.rbe_right;
        }
#line 94
        tmp->entry.rbe_color = parent->entry.rbe_color;
#line 94
        parent->entry.rbe_color = 0;
#line 94
        if (tmp->entry.rbe_right) {
#line 94
          (tmp->entry.rbe_right)->entry.rbe_color = 0;
        }
#line 94
        while (1) {
#line 94
          tmp = parent->entry.rbe_right;
#line 94
          tmp___4 = tmp->entry.rbe_left;
#line 94
          parent->entry.rbe_right = tmp___4;
#line 94
          if ((unsigned long )tmp___4 != (unsigned long )((void *)0)) {
#line 94
            (tmp->entry.rbe_left)->entry.rbe_parent = parent;
          }
#line 94
          while (1) {
#line 94
            break;
          }
#line 94
          tmp___5 = parent->entry.rbe_parent;
#line 94
          tmp->entry.rbe_parent = tmp___5;
#line 94
          if ((unsigned long )tmp___5 != (unsigned long )((void *)0)) {
#line 94
            if ((unsigned long )parent == (unsigned long )(parent->entry.rbe_parent)->entry.rbe_left) {
#line 94
              (parent->entry.rbe_parent)->entry.rbe_left = tmp;
            } else {
#line 94
              (parent->entry.rbe_parent)->entry.rbe_right = tmp;
            }
          } else {
#line 94
            head->rbh_root = tmp;
          }
#line 94
          tmp->entry.rbe_left = parent;
#line 94
          parent->entry.rbe_parent = tmp;
#line 94
          while (1) {
#line 94
            break;
          }
#line 94
          if (tmp->entry.rbe_parent) {
#line 94
            while (1) {
#line 94
              break;
            }
          }
#line 94
          break;
        }
#line 94
        elm = head->rbh_root;
#line 94
        break;
      }
    } else {
#line 94
      tmp = parent->entry.rbe_left;
#line 94
      if (tmp->entry.rbe_color == 1) {
#line 94
        while (1) {
#line 94
          tmp->entry.rbe_color = 0;
#line 94
          parent->entry.rbe_color = 1;
#line 94
          break;
        }
#line 94
        while (1) {
#line 94
          tmp = parent->entry.rbe_left;
#line 94
          tmp___6 = tmp->entry.rbe_right;
#line 94
          parent->entry.rbe_left = tmp___6;
#line 94
          if ((unsigned long )tmp___6 != (unsigned long )((void *)0)) {
#line 94
            (tmp->entry.rbe_right)->entry.rbe_parent = parent;
          }
#line 94
          while (1) {
#line 94
            break;
          }
#line 94
          tmp___7 = parent->entry.rbe_parent;
#line 94
          tmp->entry.rbe_parent = tmp___7;
#line 94
          if ((unsigned long )tmp___7 != (unsigned long )((void *)0)) {
#line 94
            if ((unsigned long )parent == (unsigned long )(parent->entry.rbe_parent)->entry.rbe_left) {
#line 94
              (parent->entry.rbe_parent)->entry.rbe_left = tmp;
            } else {
#line 94
              (parent->entry.rbe_parent)->entry.rbe_right = tmp;
            }
          } else {
#line 94
            head->rbh_root = tmp;
          }
#line 94
          tmp->entry.rbe_right = parent;
#line 94
          parent->entry.rbe_parent = tmp;
#line 94
          while (1) {
#line 94
            break;
          }
#line 94
          if (tmp->entry.rbe_parent) {
#line 94
            while (1) {
#line 94
              break;
            }
          }
#line 94
          break;
        }
#line 94
        tmp = parent->entry.rbe_left;
      }
#line 94
      if ((unsigned long )tmp->entry.rbe_left == (unsigned long )((void *)0)) {
#line 94
        goto _L___4;
      } else
#line 94
      if ((tmp->entry.rbe_left)->entry.rbe_color == 0) {
        _L___4: /* CIL Label */ 
#line 94
        if ((unsigned long )tmp->entry.rbe_right == (unsigned long )((void *)0)) {
#line 94
          tmp->entry.rbe_color = 1;
#line 94
          elm = parent;
#line 94
          parent = elm->entry.rbe_parent;
        } else
#line 94
        if ((tmp->entry.rbe_right)->entry.rbe_color == 0) {
#line 94
          tmp->entry.rbe_color = 1;
#line 94
          elm = parent;
#line 94
          parent = elm->entry.rbe_parent;
        } else {
#line 94
          goto _L___3;
        }
      } else {
        _L___3: /* CIL Label */ 
#line 94
        if ((unsigned long )tmp->entry.rbe_left == (unsigned long )((void *)0)) {
#line 94
          goto _L___2;
        } else
#line 94
        if ((tmp->entry.rbe_left)->entry.rbe_color == 0) {
          _L___2: /* CIL Label */ 
#line 94
          oright = tmp->entry.rbe_right;
#line 94
          if ((unsigned long )oright != (unsigned long )((void *)0)) {
#line 94
            oright->entry.rbe_color = 0;
          }
#line 94
          tmp->entry.rbe_color = 1;
#line 94
          while (1) {
#line 94
            oright = tmp->entry.rbe_right;
#line 94
            tmp___8 = oright->entry.rbe_left;
#line 94
            tmp->entry.rbe_right = tmp___8;
#line 94
            if ((unsigned long )tmp___8 != (unsigned long )((void *)0)) {
#line 94
              (oright->entry.rbe_left)->entry.rbe_parent = tmp;
            }
#line 94
            while (1) {
#line 94
              break;
            }
#line 94
            tmp___9 = tmp->entry.rbe_parent;
#line 94
            oright->entry.rbe_parent = tmp___9;
#line 94
            if ((unsigned long )tmp___9 != (unsigned long )((void *)0)) {
#line 94
              if ((unsigned long )tmp == (unsigned long )(tmp->entry.rbe_parent)->entry.rbe_left) {
#line 94
                (tmp->entry.rbe_parent)->entry.rbe_left = oright;
              } else {
#line 94
                (tmp->entry.rbe_parent)->entry.rbe_right = oright;
              }
            } else {
#line 94
              head->rbh_root = oright;
            }
#line 94
            oright->entry.rbe_left = tmp;
#line 94
            tmp->entry.rbe_parent = oright;
#line 94
            while (1) {
#line 94
              break;
            }
#line 94
            if (oright->entry.rbe_parent) {
#line 94
              while (1) {
#line 94
                break;
              }
            }
#line 94
            break;
          }
#line 94
          tmp = parent->entry.rbe_left;
        }
#line 94
        tmp->entry.rbe_color = parent->entry.rbe_color;
#line 94
        parent->entry.rbe_color = 0;
#line 94
        if (tmp->entry.rbe_left) {
#line 94
          (tmp->entry.rbe_left)->entry.rbe_color = 0;
        }
#line 94
        while (1) {
#line 94
          tmp = parent->entry.rbe_left;
#line 94
          tmp___10 = tmp->entry.rbe_right;
#line 94
          parent->entry.rbe_left = tmp___10;
#line 94
          if ((unsigned long )tmp___10 != (unsigned long )((void *)0)) {
#line 94
            (tmp->entry.rbe_right)->entry.rbe_parent = parent;
          }
#line 94
          while (1) {
#line 94
            break;
          }
#line 94
          tmp___11 = parent->entry.rbe_parent;
#line 94
          tmp->entry.rbe_parent = tmp___11;
#line 94
          if ((unsigned long )tmp___11 != (unsigned long )((void *)0)) {
#line 94
            if ((unsigned long )parent == (unsigned long )(parent->entry.rbe_parent)->entry.rbe_left) {
#line 94
              (parent->entry.rbe_parent)->entry.rbe_left = tmp;
            } else {
#line 94
              (parent->entry.rbe_parent)->entry.rbe_right = tmp;
            }
          } else {
#line 94
            head->rbh_root = tmp;
          }
#line 94
          tmp->entry.rbe_right = parent;
#line 94
          parent->entry.rbe_parent = tmp;
#line 94
          while (1) {
#line 94
            break;
          }
#line 94
          if (tmp->entry.rbe_parent) {
#line 94
            while (1) {
#line 94
              break;
            }
          }
#line 94
          break;
        }
#line 94
        elm = head->rbh_root;
#line 94
        break;
      }
    }
  }
#line 94
  if (elm) {
#line 94
    elm->entry.rbe_color = 0;
  }
#line 94
  return;
}
}
#line 94 "tmux_uaf_3.c"
struct session *sessions_RB_INSERT(struct sessions *head , struct session *elm ) 
{ 
  struct session *tmp ;
  struct session *parent ;
  int comp ;
  struct session *tmp___0 ;

  {
#line 94
  parent = (struct session *)((void *)0);
#line 94
  comp = 0;
#line 94
  tmp = head->rbh_root;
#line 94
  while (tmp) {
#line 94
    parent = tmp;
#line 94
    comp = session_cmp(elm, parent);
#line 94
    if (comp < 0) {
#line 94
      tmp = tmp->entry.rbe_left;
    } else
#line 94
    if (comp > 0) {
#line 94
      tmp = tmp->entry.rbe_right;
    } else {
#line 94
      return (tmp);
    }
  }
#line 94
  while (1) {
#line 94
    elm->entry.rbe_parent = parent;
#line 94
    tmp___0 = (struct session *)((void *)0);
#line 94
    elm->entry.rbe_right = tmp___0;
#line 94
    elm->entry.rbe_left = tmp___0;
#line 94
    elm->entry.rbe_color = 1;
#line 94
    break;
  }
#line 94
  if ((unsigned long )parent != (unsigned long )((void *)0)) {
#line 94
    if (comp < 0) {
#line 94
      parent->entry.rbe_left = elm;
    } else {
#line 94
      parent->entry.rbe_right = elm;
    }
#line 94
    while (1) {
#line 94
      break;
    }
  } else {
#line 94
    head->rbh_root = elm;
  }
#line 94
  sessions_RB_INSERT_COLOR(head, elm);
#line 94
  return ((struct session *)((void *)0));
}
}
#line 94 "tmux_uaf_3.c"
struct session *sessions_RB_REMOVE(struct sessions *head , struct session *elm ) 
{ 
  struct session *child ;
  struct session *parent ;
  struct session *old ;
  int color ;
  struct session *left ;

  {
#line 94
  old = elm;
#line 94
  if ((unsigned long )elm->entry.rbe_left == (unsigned long )((void *)0)) {
#line 94
    child = elm->entry.rbe_right;
  } else
#line 94
  if ((unsigned long )elm->entry.rbe_right == (unsigned long )((void *)0)) {
#line 94
    child = elm->entry.rbe_left;
  } else {
#line 94
    elm = elm->entry.rbe_right;
#line 94
    while (1) {
#line 94
      left = elm->entry.rbe_left;
#line 94
      if (! ((unsigned long )left != (unsigned long )((void *)0))) {
#line 94
        break;
      }
#line 94
      elm = left;
    }
#line 94
    child = elm->entry.rbe_right;
#line 94
    parent = elm->entry.rbe_parent;
#line 94
    color = elm->entry.rbe_color;
#line 94
    if (child) {
#line 94
      child->entry.rbe_parent = parent;
    }
#line 94
    if (parent) {
#line 94
      if ((unsigned long )parent->entry.rbe_left == (unsigned long )elm) {
#line 94
        parent->entry.rbe_left = child;
      } else {
#line 94
        parent->entry.rbe_right = child;
      }
#line 94
      while (1) {
#line 94
        break;
      }
    } else {
#line 94
      head->rbh_root = child;
    }
#line 94
    if ((unsigned long )elm->entry.rbe_parent == (unsigned long )old) {
#line 94
      parent = elm;
    }
#line 94
    elm->entry = old->entry;
#line 94
    if (old->entry.rbe_parent) {
#line 94
      if ((unsigned long )(old->entry.rbe_parent)->entry.rbe_left == (unsigned long )old) {
#line 94
        (old->entry.rbe_parent)->entry.rbe_left = elm;
      } else {
#line 94
        (old->entry.rbe_parent)->entry.rbe_right = elm;
      }
#line 94
      while (1) {
#line 94
        break;
      }
    } else {
#line 94
      head->rbh_root = elm;
    }
#line 94
    (old->entry.rbe_left)->entry.rbe_parent = elm;
#line 94
    if (old->entry.rbe_right) {
#line 94
      (old->entry.rbe_right)->entry.rbe_parent = elm;
    }
#line 94
    if (parent) {
#line 94
      left = parent;
#line 94
      while (1) {
#line 94
        while (1) {
#line 94
          break;
        }
#line 94
        left = left->entry.rbe_parent;
#line 94
        if (! ((unsigned long )left != (unsigned long )((void *)0))) {
#line 94
          break;
        }
      }
    }
#line 94
    goto color;
  }
#line 94
  parent = elm->entry.rbe_parent;
#line 94
  color = elm->entry.rbe_color;
#line 94
  if (child) {
#line 94
    child->entry.rbe_parent = parent;
  }
#line 94
  if (parent) {
#line 94
    if ((unsigned long )parent->entry.rbe_left == (unsigned long )elm) {
#line 94
      parent->entry.rbe_left = child;
    } else {
#line 94
      parent->entry.rbe_right = child;
    }
#line 94
    while (1) {
#line 94
      break;
    }
  } else {
#line 94
    head->rbh_root = child;
  }
  color: 
#line 94
  if (color == 0) {
#line 94
    sessions_RB_REMOVE_COLOR(head, parent, child);
  }
#line 94
  return (old);
}
}
#line 94 "tmux_uaf_3.c"
struct session *sessions_RB_FIND(struct sessions *head , struct session *elm ) 
{ 
  struct session *tmp ;
  int comp ;

  {
#line 94
  tmp = head->rbh_root;
#line 94
  while (tmp) {
#line 94
    comp = session_cmp(elm, tmp);
#line 94
    if (comp < 0) {
#line 94
      tmp = tmp->entry.rbe_left;
    } else
#line 94
    if (comp > 0) {
#line 94
      tmp = tmp->entry.rbe_right;
    } else {
#line 94
      return (tmp);
    }
  }
#line 94
  return ((struct session *)((void *)0));
}
}
#line 94 "tmux_uaf_3.c"
struct session *sessions_RB_NFIND(struct sessions *head , struct session *elm ) 
{ 
  struct session *tmp ;
  struct session *res ;
  int comp ;

  {
#line 94
  tmp = head->rbh_root;
#line 94
  res = (struct session *)((void *)0);
#line 94
  while (tmp) {
#line 94
    comp = session_cmp(elm, tmp);
#line 94
    if (comp < 0) {
#line 94
      res = tmp;
#line 94
      tmp = tmp->entry.rbe_left;
    } else
#line 94
    if (comp > 0) {
#line 94
      tmp = tmp->entry.rbe_right;
    } else {
#line 94
      return (tmp);
    }
  }
#line 94
  return (res);
}
}
#line 94 "tmux_uaf_3.c"
struct session *sessions_RB_NEXT(struct session *elm ) 
{ 


  {
#line 94
  if (elm->entry.rbe_right) {
#line 94
    elm = elm->entry.rbe_right;
#line 94
    while (elm->entry.rbe_left) {
#line 94
      elm = elm->entry.rbe_left;
    }
  } else
#line 94
  if (elm->entry.rbe_parent) {
#line 94
    if ((unsigned long )elm == (unsigned long )(elm->entry.rbe_parent)->entry.rbe_left) {
#line 94
      elm = elm->entry.rbe_parent;
    } else {
#line 94
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 94
    while (1) {
#line 94
      if (elm->entry.rbe_parent) {
#line 94
        if (! ((unsigned long )elm == (unsigned long )(elm->entry.rbe_parent)->entry.rbe_right)) {
#line 94
          break;
        }
      } else {
#line 94
        break;
      }
#line 94
      elm = elm->entry.rbe_parent;
    }
#line 94
    elm = elm->entry.rbe_parent;
  }
#line 94
  return (elm);
}
}
#line 94 "tmux_uaf_3.c"
struct session *sessions_RB_PREV(struct session *elm ) 
{ 


  {
#line 94
  if (elm->entry.rbe_left) {
#line 94
    elm = elm->entry.rbe_left;
#line 94
    while (elm->entry.rbe_right) {
#line 94
      elm = elm->entry.rbe_right;
    }
  } else
#line 94
  if (elm->entry.rbe_parent) {
#line 94
    if ((unsigned long )elm == (unsigned long )(elm->entry.rbe_parent)->entry.rbe_right) {
#line 94
      elm = elm->entry.rbe_parent;
    } else {
#line 94
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 94
    while (1) {
#line 94
      if (elm->entry.rbe_parent) {
#line 94
        if (! ((unsigned long )elm == (unsigned long )(elm->entry.rbe_parent)->entry.rbe_left)) {
#line 94
          break;
        }
      } else {
#line 94
        break;
      }
#line 94
      elm = elm->entry.rbe_parent;
    }
#line 94
    elm = elm->entry.rbe_parent;
  }
#line 94
  return (elm);
}
}
#line 94 "tmux_uaf_3.c"
struct session *sessions_RB_MINMAX(struct sessions *head , int val ) 
{ 
  struct session *tmp ;
  struct session *parent ;

  {
#line 94
  tmp = head->rbh_root;
#line 94
  parent = (struct session *)((void *)0);
#line 94
  while (tmp) {
#line 94
    parent = tmp;
#line 94
    if (val < 0) {
#line 94
      tmp = tmp->entry.rbe_left;
    } else {
#line 94
      tmp = tmp->entry.rbe_right;
    }
  }
#line 94
  return (parent);
}
}
#line 95 "tmux_uaf_3.c"
struct sessions sessions  ;
#line 98 "tmux_uaf_3.c"
void *xrealloc(void *oldptr , size_t nmemb , size_t size ) 
{ 
  size_t newsize ;
  void *newptr ;

  {
#line 101
  newsize = nmemb * size;
#line 104
  if (newsize == 0UL) {
#line 105
    printf((char const   * __restrict  )"zero size%s", "");
#line 105
    exit(1);
  }
#line 106
  if ((size_t )(1 << 30) / nmemb < size) {
#line 107
    printf((char const   * __restrict  )"nmemb * size > SIZE_MAX%s", "");
#line 107
    exit(1);
  }
#line 108
  newptr = realloc(oldptr, newsize);
#line 108
  if ((unsigned long )newptr == (unsigned long )((void *)0)) {
#line 109
    printf((char const   * __restrict  )"xrealloc failed%s", "");
#line 109
    exit(1);
  }
#line 111
  return (newptr);
}
}
#line 114 "tmux_uaf_3.c"
void window_choose_add(struct window_pane *wp , struct window_choose_data *wcd ) 
{ 
  struct window_choose_mode_data *data ;
  struct window_choose_mode_item *item ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 117
  data = (struct window_choose_mode_data *)wp->modedata;
#line 121
  while (1) {
#line 121
    while (1) {
#line 121
      if ((u_int___0 )((1 << 30) - 1) < data->list.num) {
#line 121
        printf((char const   * __restrict  )"number too big%s", "");
#line 121
        exit(1);
      }
#line 121
      if ((unsigned long )((u_int___0 )(1 << 30) / (data->list.num + 1U)) < sizeof(*(data->list.list))) {
#line 121
        printf((char const   * __restrict  )"size too big%s", "");
#line 121
        exit(1);
      }
#line 121
      if (data->list.space == 0UL) {
#line 121
        data->list.space = 10UL * sizeof(*(data->list.list));
#line 121
        tmp___0 = xrealloc((void *)data->list.list, (size_t )1, data->list.space);
#line 121
        data->list.list = (struct window_choose_mode_item *)tmp___0;
      }
#line 121
      while (data->list.space <= (unsigned long )(data->list.num + 1U) * sizeof(*(data->list.list))) {
#line 121
        tmp___1 = xrealloc((void *)data->list.list, (size_t )2, data->list.space);
#line 121
        data->list.list = (struct window_choose_mode_item *)tmp___1;
#line 121
        data->list.space *= 2UL;
      }
#line 121
      break;
    }
#line 121
    (data->list.num) ++;
#line 121
    break;
  }
#line 122
  item = data->list.list + (data->list.num - 1U);
#line 124
  tmp___2 = malloc((size_t )10);
#line 124
  item->name = (char *)tmp___2;
#line 125
  item->wcd = wcd;
#line 126
  item->pos = (int )(data->list.num - 1U);
#line 127
  item->state = 0;
#line 129
  return;
}
}
#line 143
extern int ( /* missing proto */  strdup)() ;
#line 131 "tmux_uaf_3.c"
struct screen *window_choose_init(struct window_pane *wp ) 
{ 
  struct window_choose_mode_data *data ;
  struct screen *s ;
  void *tmp ;
  int tmp___0 ;

  {
#line 138
  tmp = malloc(sizeof(*data));
#line 138
  data = (struct window_choose_mode_data *)tmp;
#line 138
  wp->modedata = (void *)data;
#line 140
  data->callbackfn = (void (*)(struct window_choose_data * ))((void *)0);
#line 141
  data->freefn = (void (*)(struct window_choose_data * ))((void *)0);
#line 142
  data->input_type = (enum window_choose_input_type )-1;
#line 143
  tmp___0 = strdup("");
#line 143
  data->input_str = (char *)tmp___0;
#line 144
  data->input_prompt = (char const   *)((void *)0);
#line 146
  while (1) {
#line 146
    data->list.num = (u_int___0 )0;
#line 146
    data->list.list = (struct window_choose_mode_item *)((void *)0);
#line 146
    data->list.space = (size_t )0;
#line 146
    break;
  }
#line 147
  while (1) {
#line 147
    data->old_list.num = (u_int___0 )0;
#line 147
    data->old_list.list = (struct window_choose_mode_item *)((void *)0);
#line 147
    data->old_list.space = (size_t )0;
#line 147
    break;
  }
#line 148
  data->top = (u_int___0 )0;
#line 150
  s = & data->screen;
#line 151
  s->mode &= -2;
#line 153
  return (s);
}
}
#line 156 "tmux_uaf_3.c"
struct window_choose_data *window_choose_data_create(struct cmd_ctx *ctx ) 
{ 
  struct window_choose_data *wcd ;
  void *tmp ;

  {
#line 161
  tmp = malloc(sizeof(*wcd));
#line 161
  wcd = (struct window_choose_data *)tmp;
#line 162
  wcd->command = (char *)((void *)0);
#line 163
  wcd->wl = (struct winlink *)((void *)0);
#line 164
  wcd->tree_session = (struct session *)((void *)0);
#line 165
  wcd->session = (ctx->curclient)->session;
#line 166
  wcd->idx = (u_int___0 )-1;
#line 167
  wcd->type = 0;
#line 169
  return (wcd);
}
}
#line 172 "tmux_uaf_3.c"
void window_choose_free(struct window_pane *wp ) 
{ 
  struct window_choose_mode_data *data ;
  struct window_choose_mode_item *item ;
  u_int___0 i ;

  {
#line 175
  data = (struct window_choose_mode_data *)wp->modedata;
#line 179
  i = (u_int___0 )0;
#line 179
  while (i < data->list.num) {
#line 180
    item = data->list.list + i;
#line 181
    if ((unsigned long )data->freefn != (unsigned long )((void *)0)) {
#line 181
      if ((unsigned long )item->wcd != (unsigned long )((void *)0)) {
#line 182
        (*(data->freefn))(item->wcd);
      }
    }
#line 183
    free((void *)item->name);
#line 179
    i ++;
  }
#line 185
  while (1) {
#line 185
    free((void *)data->list.list);
#line 185
    while (1) {
#line 185
      data->list.num = (u_int___0 )0;
#line 185
      data->list.list = (struct window_choose_mode_item *)((void *)0);
#line 185
      data->list.space = (size_t )0;
#line 185
      break;
    }
#line 185
    break;
  }
#line 186
  while (1) {
#line 186
    free((void *)data->old_list.list);
#line 186
    while (1) {
#line 186
      data->old_list.num = (u_int___0 )0;
#line 186
      data->old_list.list = (struct window_choose_mode_item *)((void *)0);
#line 186
      data->old_list.space = (size_t )0;
#line 186
      break;
    }
#line 186
    break;
  }
#line 187
  free((void *)data->input_str);
#line 189
  free((void *)data);
#line 190
  return;
}
}
#line 238
extern int ( /* missing proto */  memcpy)() ;
#line 192 "tmux_uaf_3.c"
void window_choose_collapse(struct window_pane *wp , struct session *s ) 
{ 
  struct window_choose_mode_data *data ;
  struct window_choose_mode_item *item ;
  struct window_choose_mode_item *chosen ;
  struct window_choose_data *wcd ;
  u_int___0 i ;
  u_int___0 pos ;
  struct __anonstruct_list_copy_61 list_copy ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;

  {
#line 195
  data = (struct window_choose_mode_data *)wp->modedata;
#line 201
  while (1) {
#line 201
    list_copy.num = (u_int___0 )0;
#line 201
    list_copy.list = (struct window_choose_mode_item *)((void *)0);
#line 201
    list_copy.space = (size_t )0;
#line 201
    break;
  }
#line 203
  pos = data->selected;
#line 205
  chosen = data->list.list + pos;
#line 206
  chosen->state &= -2;
#line 213
  i = (u_int___0 )0;
#line 213
  while (i < data->list.num) {
#line 215
    item = data->list.list + i;
#line 216
    wcd = item->wcd;
#line 218
    if ((unsigned long )s == (unsigned long )wcd->tree_session) {
#line 220
      if (wcd->type & 2) {
#line 221
        item->state &= -2;
#line 223
        while (1) {
#line 223
          while (1) {
#line 223
            if ((u_int___0 )((1 << 30) - 1) < list_copy.num) {
#line 223
              printf((char const   * __restrict  )"number too big%s", "");
#line 223
              exit(1);
            }
#line 223
            if ((unsigned long )((u_int___0 )(1 << 30) / (list_copy.num + 1U)) < sizeof(*(list_copy.list))) {
#line 223
              printf((char const   * __restrict  )"size too big%s", "");
#line 223
              exit(1);
            }
#line 223
            if (list_copy.space == 0UL) {
#line 223
              list_copy.space = 10UL * sizeof(*(list_copy.list));
#line 223
              tmp = xrealloc((void *)list_copy.list, (size_t )1, list_copy.space);
#line 223
              list_copy.list = (struct window_choose_mode_item *)tmp;
            }
#line 223
            while (list_copy.space <= (unsigned long )(list_copy.num + 1U) * sizeof(*(list_copy.list))) {
#line 223
              tmp___0 = xrealloc((void *)list_copy.list, (size_t )2, list_copy.space);
#line 223
              list_copy.list = (struct window_choose_mode_item *)tmp___0;
#line 223
              list_copy.space *= 2UL;
            }
#line 223
            break;
          }
#line 223
          *(list_copy.list + list_copy.num) = *(data->list.list + i);
#line 223
          (list_copy.num) ++;
#line 223
          break;
        }
#line 230
        data->selected = i;
      }
    } else {
#line 233
      while (1) {
#line 233
        while (1) {
#line 233
          if ((u_int___0 )((1 << 30) - 1) < list_copy.num) {
#line 233
            printf((char const   * __restrict  )"number too big%s", "");
#line 233
            exit(1);
          }
#line 233
          if ((unsigned long )((u_int___0 )(1 << 30) / (list_copy.num + 1U)) < sizeof(*(list_copy.list))) {
#line 233
            printf((char const   * __restrict  )"size too big%s", "");
#line 233
            exit(1);
          }
#line 233
          if (list_copy.space == 0UL) {
#line 233
            list_copy.space = 10UL * sizeof(*(list_copy.list));
#line 233
            tmp___1 = xrealloc((void *)list_copy.list, (size_t )1, list_copy.space);
#line 233
            list_copy.list = (struct window_choose_mode_item *)tmp___1;
          }
#line 233
          while (list_copy.space <= (unsigned long )(list_copy.num + 1U) * sizeof(*(list_copy.list))) {
#line 233
            tmp___2 = xrealloc((void *)list_copy.list, (size_t )2, list_copy.space);
#line 233
            list_copy.list = (struct window_choose_mode_item *)tmp___2;
#line 233
            list_copy.space *= 2UL;
          }
#line 233
          break;
        }
#line 233
        *(list_copy.list + list_copy.num) = *(data->list.list + i);
#line 233
        (list_copy.num) ++;
#line 233
        break;
      }
    }
#line 213
    i ++;
  }
#line 236
  if (! ((unsigned long )((void *)(& list_copy)) == (unsigned long )((void *)0))) {
#line 236
    if (! (list_copy.num == 0U)) {
#line 237
      while (1) {
#line 237
        free((void *)data->list.list);
#line 237
        while (1) {
#line 237
          data->list.num = (u_int___0 )0;
#line 237
          data->list.list = (struct window_choose_mode_item *)((void *)0);
#line 237
          data->list.space = (size_t )0;
#line 237
          break;
        }
#line 237
        break;
      }
#line 238
      while (1) {
#line 238
        while (1) {
#line 238
          if ((u_int___0 )(1 << 30) - list_copy.num < data->list.num) {
#line 238
            printf((char const   * __restrict  )"number too big%s", "");
#line 238
            exit(1);
          }
#line 238
          if ((unsigned long )((u_int___0 )(1 << 30) / (data->list.num + list_copy.num)) < sizeof(*(data->list.list))) {
#line 238
            printf((char const   * __restrict  )"size too big%s", "");
#line 238
            exit(1);
          }
#line 238
          if (data->list.space == 0UL) {
#line 238
            data->list.space = 10UL * sizeof(*(data->list.list));
#line 238
            tmp___3 = xrealloc((void *)data->list.list, (size_t )1, data->list.space);
#line 238
            data->list.list = (struct window_choose_mode_item *)tmp___3;
          }
#line 238
          while (data->list.space <= (unsigned long )(data->list.num + list_copy.num) * sizeof(*(data->list.list))) {
#line 238
            tmp___4 = xrealloc((void *)data->list.list, (size_t )2, data->list.space);
#line 238
            data->list.list = (struct window_choose_mode_item *)tmp___4;
#line 238
            data->list.space *= 2UL;
          }
#line 238
          break;
        }
#line 238
        memcpy(data->list.list + data->list.num, list_copy.list, (unsigned long )list_copy.num * sizeof(*(data->list.list)));
#line 238
        data->list.num += list_copy.num;
#line 238
        break;
      }
    }
  }
#line 240
  return;
}
}
#line 242 "tmux_uaf_3.c"
void window_choose_collapse_all(struct window_pane *wp ) 
{ 
  struct window_choose_mode_data *data ;
  struct window_choose_mode_item *item ;
  struct window_choose_mode_item *chosen ;
  struct session *s ;
  u_int___0 i ;

  {
#line 245
  data = (struct window_choose_mode_data *)wp->modedata;
#line 250
  chosen = data->list.list + data->selected;
#line 252
  s = sessions_RB_MINMAX(& sessions, -1);
#line 252
  while ((unsigned long )s != (unsigned long )((void *)0)) {
#line 253
    window_choose_collapse(wp, s);
#line 252
    s = sessions_RB_NEXT(s);
  }
#line 256
  i = (u_int___0 )0;
#line 256
  while (i < data->list.num) {
#line 257
    item = data->list.list + i;
#line 259
    if ((unsigned long )(chosen->wcd)->session != (unsigned long )(item->wcd)->tree_session) {
#line 260
      goto __Cont;
    }
#line 262
    if ((item->wcd)->type & 2) {
#line 263
      data->selected = i;
    }
    __Cont: /* CIL Label */ 
#line 256
    i ++;
  }
#line 265
  return;
}
}
#line 267 "tmux_uaf_3.c"
void window_choose_expand_all(struct window_pane *wp ) 
{ 
  struct window_choose_mode_data *data ;
  struct window_choose_mode_item *item ;
  struct session *s ;
  u_int___0 i ;

  {
#line 270
  data = (struct window_choose_mode_data *)wp->modedata;
#line 275
  s = sessions_RB_MINMAX(& sessions, -1);
#line 275
  while ((unsigned long )s != (unsigned long )((void *)0)) {
#line 276
    i = (u_int___0 )0;
#line 276
    while (i < data->list.num) {
#line 277
      item = data->list.list + i;
#line 279
      if ((unsigned long )s != (unsigned long )(item->wcd)->tree_session) {
#line 280
        goto __Cont;
      }
#line 282
      if ((item->wcd)->type & 2) {
#line 283
        window_choose_expand(wp, s, i);
      }
      __Cont: /* CIL Label */ 
#line 276
      i ++;
    }
#line 275
    s = sessions_RB_NEXT(s);
  }
#line 287
  return;
}
}
#line 335
extern int ( /* missing proto */  memmove)() ;
#line 289 "tmux_uaf_3.c"
void window_choose_expand(struct window_pane *wp , struct session *s , u_int___0 pos ) 
{ 
  struct window_choose_mode_data *data ;
  struct window_choose_mode_item *item ;
  struct window_choose_mode_item *chosen ;
  struct window_choose_data *wcd ;
  u_int___0 i ;
  u_int___0 items ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 292
  data = (struct window_choose_mode_data *)wp->modedata;
#line 297
  chosen = data->list.list + pos;
#line 298
  items = data->old_list.num - 1U;
#line 301
  if (! ((chosen->wcd)->type & 2)) {
#line 302
    return;
  }
#line 305
  if (chosen->state & 1) {
#line 306
    return;
  }
#line 309
  chosen->state |= 1;
#line 316
  i = items;
#line 316
  while (i > 0U) {
#line 317
    item = data->old_list.list + i;
#line 318
    item->state |= 1;
#line 319
    wcd = item->wcd;
#line 321
    if ((unsigned long )s == (unsigned long )wcd->tree_session) {
#line 326
      if (wcd->type & 1) {
#line 334
        if (pos < i) {
#line 335
          while (1) {
#line 335
            while (1) {
#line 335
              if ((u_int___0 )((1 << 30) - 1) < data->list.num) {
#line 335
                printf((char const   * __restrict  )"number too big%s", "");
#line 335
                exit(1);
              }
#line 335
              if ((unsigned long )((u_int___0 )(1 << 30) / (data->list.num + 1U)) < sizeof(*(data->list.list))) {
#line 335
                printf((char const   * __restrict  )"size too big%s", "");
#line 335
                exit(1);
              }
#line 335
              if (data->list.space == 0UL) {
#line 335
                data->list.space = 10UL * sizeof(*(data->list.list));
#line 335
                tmp = xrealloc((void *)data->list.list, (size_t )1, data->list.space);
#line 335
                data->list.list = (struct window_choose_mode_item *)tmp;
              }
#line 335
              while (data->list.space <= (unsigned long )(data->list.num + 1U) * sizeof(*(data->list.list))) {
#line 335
                tmp___0 = xrealloc((void *)data->list.list, (size_t )2, data->list.space);
#line 335
                data->list.list = (struct window_choose_mode_item *)tmp___0;
#line 335
                data->list.space *= 2UL;
              }
#line 335
              break;
            }
#line 335
            if (pos + 1U < data->list.num) {
#line 335
              memmove((data->list.list + (pos + 1U)) + 1, data->list.list + (pos + 1U),
                      sizeof(*(data->list.list)) * (unsigned long )(data->list.num - (pos + 1U)));
            }
#line 335
            *(data->list.list + (pos + 1U)) = *(data->old_list.list + i);
#line 335
            (data->list.num) ++;
#line 335
            break;
          }
        } else {
#line 341
          while (1) {
#line 341
            while (1) {
#line 341
              if ((u_int___0 )((1 << 30) - 1) < data->list.num) {
#line 341
                printf((char const   * __restrict  )"number too big%s", "");
#line 341
                exit(1);
              }
#line 341
              if ((unsigned long )((u_int___0 )(1 << 30) / (data->list.num + 1U)) < sizeof(*(data->list.list))) {
#line 341
                printf((char const   * __restrict  )"size too big%s", "");
#line 341
                exit(1);
              }
#line 341
              if (data->list.space == 0UL) {
#line 341
                data->list.space = 10UL * sizeof(*(data->list.list));
#line 341
                tmp___1 = xrealloc((void *)data->list.list, (size_t )1, data->list.space);
#line 341
                data->list.list = (struct window_choose_mode_item *)tmp___1;
              }
#line 341
              while (data->list.space <= (unsigned long )(data->list.num + 1U) * sizeof(*(data->list.list))) {
#line 341
                tmp___2 = xrealloc((void *)data->list.list, (size_t )2, data->list.space);
#line 341
                data->list.list = (struct window_choose_mode_item *)tmp___2;
#line 341
                data->list.space *= 2UL;
              }
#line 341
              break;
            }
#line 341
            *(data->list.list + data->list.num) = *(data->old_list.list + i);
#line 341
            (data->list.num) ++;
#line 341
            break;
          }
        }
      }
    }
#line 316
    i --;
  }
#line 348
  return;
}
}
#line 350 "tmux_uaf_3.c"
struct window_choose_data *window_choose_add_item(struct window_pane *wp , struct cmd_ctx *ctx ,
                                                  struct winlink *wl , char const   *template ,
                                                  char *action , u_int___0 idx ) 
{ 
  struct window_choose_data *wcd ;
  char *action_data ;

  {
#line 357
  wcd = window_choose_data_create(ctx);
#line 358
  wcd->idx = (u_int___0 )wl->idx;
#line 360
  ((wcd->session)->references) ++;
#line 362
  window_choose_add(wp, wcd);
#line 368
  free((void *)action_data);
#line 370
  return (wcd);
}
}
#line 374 "tmux_uaf_3.c"
struct window_pane *window_pane_create(struct window *w , u_int___0 sx , u_int___0 sy ,
                                       u_int___0 hlimit ) 
{ 
  struct window_pane *wp ;
  void *tmp ;

  {
#line 379
  tmp = calloc((size_t )1, sizeof(*wp));
#line 379
  wp = (struct window_pane *)tmp;
#line 380
  wp->window = w;
#line 383
  wp->shell = (char *)((void *)0);
#line 384
  wp->cwd = (char const   *)((void *)0);
#line 386
  wp->fd = -1;
#line 387
  wp->event = (struct bufferevent *)((void *)0);
#line 389
  wp->mode = (struct window_mode  const  *)((void *)0);
#line 391
  wp->layout_cell = (struct layout_cell *)((void *)0);
#line 393
  wp->xoff = (u_int___0 )0;
#line 394
  wp->yoff = (u_int___0 )0;
#line 396
  wp->sx = sx;
#line 397
  wp->sy = sy;
#line 399
  wp->pipe_fd = -1;
#line 400
  wp->pipe_off = (size_t )0;
#line 401
  wp->pipe_event = (struct bufferevent *)((void *)0);
#line 403
  wp->saved_grid = (struct grid *)((void *)0);
#line 405
  wp->screen = & wp->base;
#line 407
  return (wp);
}
}
#line 410 "tmux_uaf_3.c"
void window_pane_destroy(struct window_pane *wp ) 
{ 


  {
#line 413
  free((void *)wp->cwd);
#line 414
  free((void *)wp->shell);
#line 415
  free((void *)wp);
#line 416
  return;
}
}
#line 419 "tmux_uaf_3.c"
int main(void) 
{ 
  struct cmd_ctx ctx ;
  struct window_pane *wp ;
  struct window_choose_data *wcd ;
  int sx ;
  int sy ;
  int hlimit ;
  int tmp ;

  {
#line 426
  wp = window_pane_create((struct window *)((void *)0), (u_int___0 )sx, (u_int___0 )sy,
                          (u_int___0 )hlimit);
#line 427
  window_choose_init(wp);
#line 428
  while (1) {
#line 428
    tmp = getchar();
#line 428
    if (! tmp) {
#line 428
      break;
    }
#line 430
    wcd = window_choose_data_create(& ctx);
#line 431
    window_choose_add(wp, wcd);
  }
#line 433
  window_choose_expand_all(wp);
#line 434
  window_choose_collapse_all(wp);
#line 435
  window_choose_free(wp);
#line 436
  window_pane_destroy(wp);
#line 437
  return (0);
}
}
