/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

#line 216 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h"
typedef unsigned long size_t;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 60 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __dev_t dev_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 193 "../stdio.h"
typedef unsigned int u_int___0;
#line 37 "tmux_leak_8.c"
struct kinfo_proc {
   int p_tdev ;
   int p_stat ;
   int p_estcpu ;
   int p_slptime ;
   int p_flag ;
   char *p_comm ;
   int p_pid ;
};
#line 480 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 68 "/usr/include/x86_64-linux-gnu/sys/sysctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sysctl)(int *__name ,
                                                                             int __nlen ,
                                                                             void *__oldval ,
                                                                             size_t *__oldlenp ,
                                                                             void *__newval ,
                                                                             size_t __newlen ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 208 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 2317 "../tmux.h"
char *get_proc_name(int fd , char *tty ) ;
#line 47 "tmux_leak_8.c"
struct kinfo_proc *cmp_procs(struct kinfo_proc *p1 , struct kinfo_proc *p2 ) ;
#line 78
extern int ( /* missing proto */  strcmp)() ;
#line 50 "tmux_leak_8.c"
struct kinfo_proc *cmp_procs(struct kinfo_proc *p1 , struct kinfo_proc *p2 ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 53
  if (p1->p_stat == 0) {
#line 53
    goto _L;
  } else
#line 53
  if (p1->p_stat == 1) {
#line 53
    goto _L;
  } else
#line 53
  if (p1->p_stat == 2) {
    _L: /* CIL Label */ 
#line 53
    if (! (p2->p_stat == 0)) {
#line 53
      if (! (p2->p_stat == 1)) {
#line 53
        if (! (p2->p_stat == 2)) {
#line 54
          return (p1);
        }
      }
    }
  }
#line 55
  if (! (p1->p_stat == 0)) {
#line 55
    if (! (p1->p_stat == 1)) {
#line 55
      if (! (p1->p_stat == 2)) {
#line 55
        if (p2->p_stat == 0) {
#line 56
          return (p2);
        } else
#line 55
        if (p2->p_stat == 1) {
#line 56
          return (p2);
        } else
#line 55
        if (p2->p_stat == 2) {
#line 56
          return (p2);
        }
      }
    }
  }
#line 58
  if (p1->p_stat == 3) {
#line 58
    goto _L___0;
  } else
#line 58
  if (p1->p_stat == 4) {
#line 58
    goto _L___0;
  } else
#line 58
  if (p1->p_stat == 5) {
    _L___0: /* CIL Label */ 
#line 58
    if (! (p2->p_stat == 3)) {
#line 58
      if (! (p2->p_stat == 4)) {
#line 58
        if (! (p2->p_stat == 5)) {
#line 59
          return (p1);
        }
      }
    }
  }
#line 60
  if (! (p1->p_stat == 3)) {
#line 60
    if (! (p1->p_stat == 4)) {
#line 60
      if (! (p1->p_stat == 5)) {
#line 60
        if (p2->p_stat == 3) {
#line 61
          return (p2);
        } else
#line 60
        if (p2->p_stat == 4) {
#line 61
          return (p2);
        } else
#line 60
        if (p2->p_stat == 5) {
#line 61
          return (p2);
        }
      }
    }
  }
#line 63
  if (p1->p_estcpu > p2->p_estcpu) {
#line 64
    return (p1);
  }
#line 65
  if (p1->p_estcpu < p2->p_estcpu) {
#line 66
    return (p2);
  }
#line 68
  if (p1->p_slptime < p2->p_slptime) {
#line 69
    return (p1);
  }
#line 70
  if (p1->p_slptime > p2->p_slptime) {
#line 71
    return (p2);
  }
#line 73
  if (p1->p_flag & 6) {
#line 73
    if (! (p2->p_flag & 6)) {
#line 74
      return (p1);
    }
  }
#line 75
  if (! (p1->p_flag & 6)) {
#line 75
    if (p2->p_flag & 6) {
#line 76
      return (p2);
    }
  }
#line 78
  tmp = strcmp(p1->p_comm, p2->p_comm);
#line 78
  if (tmp < 0) {
#line 79
    return (p1);
  }
#line 80
  tmp___0 = strcmp(p1->p_comm, p2->p_comm);
#line 80
  if (tmp___0 > 0) {
#line 81
    return (p2);
  }
#line 83
  if (p1->p_pid > p2->p_pid) {
#line 84
    return (p1);
  }
#line 85
  return (p2);
}
}
#line 104
extern int ( /* missing proto */  tcgetpgrp)() ;
#line 135
extern int ( /* missing proto */  strdup)() ;
#line 89 "tmux_leak_8.c"
char *get_proc_name(int fd , char *tty ) 
{ 
  int mib[6] ;
  struct stat sb ;
  size_t len ;
  struct kinfo_proc *buf ;
  struct kinfo_proc *newbuf ;
  struct kinfo_proc *bestp ;
  u_int___0 i ;
  char *name ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 92
  mib[0] = 0;
#line 92
  mib[1] = 0;
#line 92
  mib[2] = 0;
#line 92
  mib[3] = 0;
#line 92
  mib[4] = (int )sizeof(struct kinfo_proc );
#line 92
  mib[5] = 0;
#line 100
  buf = (struct kinfo_proc *)((void *)0);
#line 102
  tmp = stat((char const   * __restrict  )tty, (struct stat * __restrict  )(& sb));
#line 102
  if (tmp == -1) {
#line 103
    return ((char *)((void *)0));
  }
#line 104
  mib[3] = tcgetpgrp(fd);
#line 104
  if (mib[3] == -1) {
#line 105
    return ((char *)((void *)0));
  }
  retry: 
#line 108
  tmp___0 = sysctl(mib, (int )(sizeof(mib) / sizeof(mib[0])), (void *)0, & len, (void *)0,
                   (size_t )0);
#line 108
  if (tmp___0 == -1) {
#line 109
    return ((char *)((void *)0));
  }
#line 110
  len = (len * 5UL) / 4UL;
#line 112
  tmp___1 = realloc((void *)buf, len);
#line 112
  newbuf = (struct kinfo_proc *)tmp___1;
#line 112
  if ((unsigned long )newbuf == (unsigned long )((void *)0)) {
#line 113
    goto error;
  }
#line 114
  buf = newbuf;
#line 116
  mib[5] = (int )(len / sizeof(struct kinfo_proc ));
#line 117
  tmp___3 = sysctl(mib, (int )(sizeof(mib) / sizeof(mib[0])), (void *)buf, & len,
                   (void *)0, (size_t )0);
#line 117
  if (tmp___3 == -1) {
#line 118
    tmp___2 = __errno_location();
#line 118
    if (*tmp___2 == 12) {
#line 119
      goto retry;
    }
#line 120
    goto error;
  }
#line 123
  bestp = (struct kinfo_proc *)((void *)0);
#line 124
  i = (u_int___0 )0;
#line 124
  while ((size_t )i < len / sizeof(struct kinfo_proc )) {
#line 125
    if ((dev_t )(buf + i)->p_tdev != sb.st_rdev) {
#line 126
      goto __Cont;
    }
#line 127
    if ((unsigned long )bestp == (unsigned long )((void *)0)) {
#line 128
      bestp = buf + i;
    } else {
#line 130
      bestp = cmp_procs(buf + i, bestp);
    }
    __Cont: /* CIL Label */ 
#line 124
    i ++;
  }
#line 133
  name = (char *)((void *)0);
#line 134
  if ((unsigned long )bestp != (unsigned long )((void *)0)) {
#line 135
    tmp___4 = strdup(bestp->p_comm);
#line 135
    name = (char *)tmp___4;
  }
#line 137
  free((void *)buf);
#line 138
  return (name);
  error: 
#line 141
  free((void *)buf);
#line 142
  return ((char *)((void *)0));
}
}
#line 145 "tmux_leak_8.c"
int main(void) 
{ 
  int fd ;
  char *name ;

  {
#line 149
  name = get_proc_name(fd, (char *)"tty");
#line 150
  *name = (char)0;
#line 151
  free((void *)name);
#line 152
  return (0);
}
}
