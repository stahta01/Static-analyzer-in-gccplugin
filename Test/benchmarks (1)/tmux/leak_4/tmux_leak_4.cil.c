/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

#line 216 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h"
typedef unsigned long size_t;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 80 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uid_t uid_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 733
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) realpath)(char const   * __restrict  __name ,
                                                                                 char * __restrict  __resolved ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 262 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) lstat)(char const   * __restrict  __file ,
                                                                                              struct stat * __restrict  __buf ) ;
#line 320
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) mkdir)(char const   *__path ,
                                                                                            __mode_t __mode ) ;
#line 18 "tmux_leak_4.c"
size_t strlcpy(char *dst , char const   *src , size_t siz ) 
{ 
  char *d ;
  char const   *s ;
  size_t n ;
  char *tmp ;
  char tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;

  {
#line 21
  d = dst;
#line 22
  s = src;
#line 23
  n = siz;
#line 26
  if (n != 0UL) {
#line 26
    n --;
#line 26
    if (n != 0UL) {
#line 27
      while (1) {
#line 28
        tmp = d;
#line 28
        d ++;
#line 28
        tmp___1 = s;
#line 28
        s ++;
#line 28
        tmp___0 = (char )*tmp___1;
#line 28
        *tmp = tmp___0;
#line 28
        if ((int )tmp___0 == 0) {
#line 29
          break;
        }
#line 27
        n --;
#line 27
        if (! (n != 0UL)) {
#line 27
          break;
        }
      }
    }
  }
#line 34
  if (n == 0UL) {
#line 35
    if (siz != 0UL) {
#line 36
      *d = (char )'\000';
    }
#line 37
    while (1) {
#line 37
      tmp___2 = s;
#line 37
      s ++;
#line 37
      if (! *tmp___2) {
#line 37
        break;
      }
    }
  }
#line 41
  return ((size_t )((s - src) - 1L));
}
}
#line 46
extern int ( /* missing proto */  strlen)() ;
#line 44 "tmux_leak_4.c"
int vasprintf(char **ret , char const   *fmt , char *ap ) 
{ 
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
#line 46
  tmp = strlen(fmt);
#line 46
  tmp___0 = strlen(ap);
#line 46
  tmp___1 = malloc((size_t )(tmp + tmp___0));
#line 46
  *ret = (char *)tmp___1;
#line 47
  if ((unsigned long )*ret == (unsigned long )((void *)0)) {
#line 47
    return (-1);
  }
#line 48
  return (0);
}
}
#line 56
int xvasprintf(char **ret , char const   *fmt , char *ap ) ;
#line 51 "tmux_leak_4.c"
int xasprintf(char **ret , char const   *fmt , char *ap ) 
{ 
  int i ;

  {
#line 56
  i = xvasprintf(ret, fmt, ap);
#line 58
  return (i);
}
}
#line 69
extern int ( /* missing proto */  strerror)() ;
#line 61 "tmux_leak_4.c"
int xvasprintf(char **ret , char const   *fmt , char *ap ) 
{ 
  int i ;
  int *tmp ;
  int tmp___0 ;

  {
#line 66
  i = vasprintf(ret, fmt, ap);
#line 68
  if (i < 0) {
#line 69
    tmp = __errno_location();
#line 69
    tmp___0 = strerror(*tmp);
#line 69
    printf((char const   * __restrict  )"xasprintf: %s", tmp___0);
#line 69
    exit(1);
  } else
#line 68
  if ((unsigned long )*ret == (unsigned long )((void *)0)) {
#line 69
    tmp = __errno_location();
#line 69
    tmp___0 = strerror(*tmp);
#line 69
    printf((char const   * __restrict  )"xasprintf: %s", tmp___0);
#line 69
    exit(1);
  }
#line 71
  return (i);
}
}
#line 84
extern int ( /* missing proto */  getuid)() ;
#line 74 "tmux_leak_4.c"
static char *make_label(char const   *label ) 
{ 
  char *base ;
  char resolved[4096] ;
  char *path ;
  char *s ;
  struct stat sb ;
  uid_t uid ;
  int saved_errno ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  char *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;

  {
#line 82
  if ((unsigned long )label == (unsigned long )((void *)0)) {
#line 83
    label = "default";
  }
#line 84
  tmp = getuid();
#line 84
  uid = (uid_t )tmp;
#line 86
  s = getenv("TMUX_TMPDIR");
#line 86
  if ((unsigned long )s != (unsigned long )((void *)0)) {
#line 86
    if ((int )*s != 0) {
#line 87
      xasprintf(& base, "%s/tmux-", s);
    } else {
#line 89
      xasprintf(& base, "%s/tmux-", (char *)"/tmp");
    }
  } else {
#line 89
    xasprintf(& base, "%s/tmux-", (char *)"/tmp");
  }
#line 91
  tmp___0 = mkdir((char const   *)base, (__mode_t )0);
#line 91
  if (tmp___0 != 0) {
#line 91
    tmp___1 = __errno_location();
#line 91
    if (*tmp___1 != 17) {
#line 92
      goto fail;
    }
  }
#line 94
  tmp___2 = lstat((char const   * __restrict  )base, (struct stat * __restrict  )(& sb));
#line 94
  if (tmp___2 != 0) {
#line 95
    goto fail;
  }
#line 96
  if (! ((sb.st_mode & 61440U) == 16384U)) {
#line 97
    tmp___3 = __errno_location();
#line 97
    *tmp___3 = 20;
#line 98
    goto fail;
  }
#line 100
  if (sb.st_uid != uid) {
#line 101
    tmp___4 = __errno_location();
#line 101
    *tmp___4 = 13;
#line 102
    goto fail;
  }
#line 105
  tmp___5 = realpath((char const   * __restrict  )base, (char * __restrict  )(resolved));
#line 105
  if ((unsigned long )tmp___5 == (unsigned long )((void *)0)) {
#line 106
    strlcpy(resolved, (char const   *)base, sizeof(resolved));
  }
#line 109
  return (path);
  fail: 
#line 112
  tmp___6 = __errno_location();
#line 112
  saved_errno = *tmp___6;
#line 113
  free((void *)base);
#line 114
  tmp___7 = __errno_location();
#line 114
  *tmp___7 = saved_errno;
#line 115
  return ((char *)((void *)0));
}
}
#line 118 "tmux_leak_4.c"
int main(void) 
{ 


  {
#line 120
  make_label("label");
#line 122
  return (0);
}
}
