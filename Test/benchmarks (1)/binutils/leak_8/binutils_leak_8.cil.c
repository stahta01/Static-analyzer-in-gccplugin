/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

#line 216 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 144 "/usr/include/libio.h"
struct _IO_FILE;
#line 150 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 156 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 241 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 29 "../include/common.h"
typedef int bool;
#line 34 "../include/common.h"
typedef void make_cleanup_ftype(void * );
#line 36 "../include/common.h"
struct cleanup {
   struct cleanup *next ;
   void (*function)(void * ) ;
   void (*free_arg)(void * ) ;
   void *arg ;
};
#line 512 "../include/binutils.h"
typedef unsigned long long BFD_HOST_U_64_BIT;
#line 515 "../include/binutils.h"
typedef BFD_HOST_U_64_BIT bfd_vma;
#line 517 "../include/binutils.h"
typedef BFD_HOST_U_64_BIT bfd_size_type;
#line 519 "../include/binutils.h"
typedef int bfd_boolean;
#line 521 "../include/binutils.h"
typedef unsigned int flagword;
#line 522 "../include/binutils.h"
typedef unsigned char bfd_byte;
#line 524
struct bfd;
#line 17 "../include/bfd.h"
typedef int bool___0;
#line 19 "../include/bfd.h"
typedef FILE *file_ptr;
#line 21
enum bfd_flavour {
    bfd_target_unknown_flavour = 0,
    bfd_target_aout_flavour = 1,
    bfd_target_coff_flavour = 2,
    bfd_target_ecoff_flavour = 3,
    bfd_target_xcoff_flavour = 4,
    bfd_target_elf_flavour = 5,
    bfd_target_ieee_flavour = 6,
    bfd_target_nlm_flavour = 7,
    bfd_target_oasys_flavour = 8,
    bfd_target_tekhex_flavour = 9,
    bfd_target_srec_flavour = 10,
    bfd_target_verilog_flavour = 11,
    bfd_target_ihex_flavour = 12,
    bfd_target_som_flavour = 13,
    bfd_target_os9k_flavour = 14,
    bfd_target_versados_flavour = 15,
    bfd_target_msdos_flavour = 16,
    bfd_target_ovax_flavour = 17,
    bfd_target_evax_flavour = 18,
    bfd_target_mmo_flavour = 19,
    bfd_target_mach_o_flavour = 20,
    bfd_target_pef_flavour = 21,
    bfd_target_pef_xlib_flavour = 22,
    bfd_target_sym_flavour = 23
} ;
#line 50 "../include/bfd.h"
struct bfd_target {
   char *name ;
   enum bfd_flavour flavour ;
};
#line 57 "../include/bfd.h"
struct bfd {
   char *filename ;
   int direction ;
   struct bfd *archive_next ;
   struct bfd_target  const  *xvec ;
   void *memory ;
   bool___0 cacheable ;
};
#line 69 "../include/bfd.h"
typedef struct bfd bfd___0;
#line 71
struct bfd_section;
#line 71 "../include/bfd.h"
typedef struct bfd_section *sec_ptr;
#line 73
struct relax_table;
#line 73
struct reloc_cache_entry;
#line 73
struct relent_chain;
#line 73
struct bfd_symbol;
#line 73
struct bfd_link_order;
#line 73 "../include/bfd.h"
union __anonunion_map_head_25 {
   struct bfd_link_order *link_order ;
   struct bfd_section *s ;
};
#line 73 "../include/bfd.h"
struct bfd_section {
   char const   *name ;
   unsigned int id ;
   unsigned int index ;
   struct bfd_section *next ;
   struct bfd_section *prev ;
   flagword flags ;
   unsigned int user_set_vma : 1 ;
   unsigned int linker_mark : 1 ;
   unsigned int linker_has_input : 1 ;
   unsigned int gc_mark : 1 ;
   unsigned int compress_status : 2 ;
   unsigned int segment_mark : 1 ;
   unsigned int sec_info_type : 3 ;
   unsigned int use_rela_p : 1 ;
   unsigned int sec_flg0 : 1 ;
   unsigned int sec_flg1 : 1 ;
   unsigned int sec_flg2 : 1 ;
   unsigned int sec_flg3 : 1 ;
   unsigned int sec_flg4 : 1 ;
   unsigned int sec_flg5 : 1 ;
   bfd_vma vma ;
   bfd_vma lma ;
   bfd_size_type size ;
   bfd_size_type rawsize ;
   bfd_size_type compressed_size ;
   struct relax_table *relax ;
   int relax_count ;
   bfd_vma output_offset ;
   struct bfd_section *output_section ;
   unsigned int alignment_power ;
   struct reloc_cache_entry *relocation ;
   struct reloc_cache_entry **orelocation ;
   unsigned int reloc_count ;
   file_ptr filepos ;
   file_ptr rel_filepos ;
   file_ptr line_filepos ;
   void *userdata ;
   unsigned char *contents ;
   unsigned int lineno_count ;
   unsigned int entsize ;
   struct bfd_section *kept_section ;
   file_ptr moving_line_filepos ;
   int target_index ;
   void *used_by_bfd ;
   struct relent_chain *constructor_chain ;
   bfd___0 *owner ;
   struct bfd_symbol *symbol ;
   struct bfd_symbol **symbol_ptr_ptr ;
   union __anonunion_map_head_25 map_head ;
   union __anonunion_map_head_25 map_tail ;
};
#line 607 "../include/bfd.h"
struct relax_table {
   bfd_vma addr ;
   int size ;
};
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 374 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rand)(void) ;
#line 376
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) srand)(unsigned int __seed ) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 31 "../include/common.h"
bool true  =    1;
#line 32 "../include/common.h"
bool false  =    0;
#line 44 "../include/common.h"
static struct cleanup  const  sentinel_cleanup  =    {(struct cleanup *)0, (void (*)(void * ))0, (void (*)(void * ))0, (void *)0};
#line 49 "../include/common.h"
static struct cleanup *cleanup_chain  =    (struct cleanup *)(& sentinel_cleanup);
#line 50 "../include/common.h"
static struct cleanup *final_cleanup_chain  ;
#line 52
void discard_cleanups(struct cleanup *old_chain ) ;
#line 53
void discard_my_cleanups(struct cleanup **pmy_chain , struct cleanup *old_chain ) ;
#line 55
void discard_final_cleanups(struct cleanup *old_chain ) ;
#line 56
static void do_my_cleanups(struct cleanup **pmy_chain , struct cleanup *old_chain ) ;
#line 58
void do_cleanups(struct cleanup *old_chain ) ;
#line 59
static struct cleanup *make_my_cleanup2(struct cleanup **pmy_chain , make_cleanup_ftype *function ,
                                        void *arg , void (*free_arg)(void * ) ) ;
#line 62
static struct cleanup *make_my_cleanup(struct cleanup **pmy_chain , make_cleanup_ftype *function ,
                                       void *arg ) ;
#line 65
struct cleanup *make_cleanup(make_cleanup_ftype *function , void *arg ) ;
#line 68 "../include/common.h"
void discard_cleanups(struct cleanup *old_chain ) 
{ 


  {
#line 71
  discard_my_cleanups(& cleanup_chain, old_chain);
#line 72
  return;
}
}
#line 74 "../include/common.h"
void discard_final_cleanups(struct cleanup *old_chain ) 
{ 


  {
#line 77
  discard_my_cleanups(& final_cleanup_chain, old_chain);
#line 78
  return;
}
}
#line 80 "../include/common.h"
void discard_my_cleanups(struct cleanup **pmy_chain , struct cleanup *old_chain ) 
{ 
  struct cleanup *ptr ;

  {
#line 86
  while (1) {
#line 86
    ptr = *pmy_chain;
#line 86
    if (! ((unsigned long )ptr != (unsigned long )old_chain)) {
#line 86
      break;
    }
#line 88
    *pmy_chain = ptr->next;
#line 89
    if (ptr->free_arg) {
#line 90
      (*(ptr->free_arg))(ptr->arg);
    }
#line 91
    free((void *)ptr);
  }
#line 94
  printf((char const   * __restrict  )"freearg: %x\n", ptr->arg);
#line 95
  return;
}
}
#line 97 "../include/common.h"
static void do_my_cleanups(struct cleanup **pmy_chain , struct cleanup *old_chain ) 
{ 
  struct cleanup *ptr ;

  {
#line 103
  while (1) {
#line 103
    ptr = *pmy_chain;
#line 103
    if (! ((unsigned long )ptr != (unsigned long )old_chain)) {
#line 103
      break;
    }
#line 105
    *pmy_chain = ptr->next;
#line 106
    (*(ptr->function))(ptr->arg);
#line 107
    printf((char const   * __restrict  )"cleanup!!!!! =========\n");
#line 108
    printf((char const   * __restrict  )"%x\n", ptr->arg);
#line 109
    if (ptr->free_arg) {
#line 110
      (*(ptr->free_arg))(ptr->arg);
    }
#line 112
    free((void *)ptr);
  }
#line 114
  return;
}
}
#line 116 "../include/common.h"
void do_cleanups(struct cleanup *old_chain ) 
{ 


  {
#line 118
  do_my_cleanups(& cleanup_chain, old_chain);
#line 119
  return;
}
}
#line 121 "../include/common.h"
static struct cleanup *make_my_cleanup2(struct cleanup **pmy_chain , make_cleanup_ftype *function ,
                                        void *arg , void (*free_arg)(void * ) ) 
{ 
  struct cleanup *new ;
  void *tmp ;
  struct cleanup *old_chain ;

  {
#line 125
  tmp = malloc(sizeof(struct cleanup ));
#line 125
  new = (struct cleanup *)tmp;
#line 127
  old_chain = *pmy_chain;
#line 129
  new->next = *pmy_chain;
#line 130
  new->function = function;
#line 131
  new->free_arg = free_arg;
#line 132
  new->arg = arg;
#line 133
  *pmy_chain = new;
#line 135
  if ((unsigned long )old_chain == (unsigned long )((void *)0)) {
#line 136
    exit(1);
  }
#line 138
  return (old_chain);
}
}
#line 141 "../include/common.h"
static struct cleanup *make_my_cleanup(struct cleanup **pmy_chain , make_cleanup_ftype *function ,
                                       void *arg ) 
{ 
  struct cleanup *tmp ;

  {
#line 145
  tmp = make_my_cleanup2(pmy_chain, function, arg, (void (*)(void * ))((void *)0));
#line 145
  return (tmp);
}
}
#line 148 "../include/common.h"
struct cleanup *make_cleanup(make_cleanup_ftype *function , void *arg ) 
{ 
  struct cleanup *tmp ;

  {
#line 151
  tmp = make_my_cleanup(& cleanup_chain, function, arg);
#line 151
  return (tmp);
}
}
#line 10 "binutils_leak_8.c"
void *bfd_malloc(bfd_size_type size ) 
{ 
  void *ptr ;
  size_t sz ;

  {
#line 13
  sz = (size_t )size;
#line 15
  if (size != (bfd_size_type )sz) {
#line 19
    printf((char const   * __restrict  )"bfd_error_no_memory\n");
#line 20
    return ((void *)0);
  } else
#line 15
  if ((long )sz < 0L) {
#line 19
    printf((char const   * __restrict  )"bfd_error_no_memory\n");
#line 20
    return ((void *)0);
  }
#line 23
  ptr = malloc(sz);
#line 24
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
#line 24
    if (sz != 0UL) {
#line 25
      printf((char const   * __restrict  )"bfd_error_no_memory\n");
    }
  }
#line 27
  return (ptr);
}
}
#line 34
extern int ( /* missing proto */  memset)() ;
#line 30 "binutils_leak_8.c"
bfd_boolean bfd_get_section_contents(sec_ptr sec , void const   *location ) 
{ 
  int tmp___0 ;
  int tmp___1 ;

  {
#line 33
  if (location) {
#line 34
    memset(location, 0, 4);
#line 35
    return (1);
  }
#line 39
  tmp___1 = rand();
#line 39
  if (tmp___1 % 2 == 1) {
#line 39
    tmp___0 = 1;
  } else {
#line 39
    tmp___0 = 0;
  }
#line 39
  return (tmp___0);
}
}
#line 42 "binutils_leak_8.c"
bfd_boolean bfd_get_full_section_contents(sec_ptr sec , bfd_byte **ptr ) 
{ 
  bfd_byte *compressed_buffer ;
  bfd_byte *p ;
  void *tmp ;
  bfd_boolean tmp___0 ;
  void *tmp___1 ;
  int tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;

  {
#line 46
  p = *ptr;
#line 48
  switch (sec->compress_status) {
  case 0U: 
#line 51
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 53
    tmp = bfd_malloc((bfd_size_type )4);
#line 53
    p = (bfd_byte *)tmp;
#line 54
    if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 55
      return (0);
    }
  }
#line 58
  *p = (bfd_byte )12;
#line 59
  tmp___0 = bfd_get_section_contents(sec, (void const   *)p);
#line 59
  if (! tmp___0) {
#line 61
    if ((unsigned long )*ptr != (unsigned long )p) {
#line 62
      free((void *)p);
    }
#line 63
    return (0);
  }
#line 66
  *ptr = p;
#line 67
  return (1);
  case 2U: 
#line 70
  tmp___1 = bfd_malloc((bfd_size_type )4);
#line 70
  compressed_buffer = (bfd_byte *)tmp___1;
#line 71
  if ((unsigned long )compressed_buffer == (unsigned long )((void *)0)) {
#line 72
    return (0);
  }
#line 74
  tmp___4 = rand();
#line 74
  if (tmp___4 % 2 == 1) {
#line 74
    tmp___3 = 1;
  } else {
#line 74
    tmp___3 = 0;
  }
#line 74
  if (tmp___3) {
#line 75
    goto fail_compressed;
  }
#line 77
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 78
    tmp___5 = bfd_malloc((bfd_size_type )4);
#line 78
    p = (bfd_byte *)tmp___5;
  }
#line 80
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 81
    goto fail_compressed;
  }
#line 83
  free((void *)compressed_buffer);
#line 84
  *ptr = p;
#line 85
  return (1);
  fail_compressed: 
#line 88
  free((void *)compressed_buffer);
#line 89
  return (0);
  case 1U: 
#line 92
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 93
    tmp___6 = bfd_malloc((bfd_size_type )4);
#line 93
    p = (bfd_byte *)tmp___6;
  }
#line 94
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 95
    return (0);
  }
#line 97
  *ptr = p;
#line 98
  return (1);
  default: 
#line 101
  exit(1);
  }
}
}
#line 105 "binutils_leak_8.c"
bfd_boolean bfd_convert_section_contents(sec_ptr isec , bfd_byte **ptr ) 
{ 
  bfd_byte *contents ;
  bfd_boolean use_memmove ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 111
  tmp___0 = rand();
#line 111
  if (tmp___0 % 2 == 1) {
#line 111
    use_memmove = 1;
  } else {
#line 111
    use_memmove = 0;
  }
#line 113
  contents = *ptr;
#line 115
  if (! use_memmove) {
#line 117
    tmp___1 = bfd_malloc((bfd_size_type )4);
#line 117
    contents = (bfd_byte *)tmp___1;
#line 118
    if ((unsigned long )contents == (unsigned long )((void *)0)) {
#line 119
      return (0);
    }
  }
#line 122
  if (contents) {
#line 123
    printf((char const   * __restrict  )"%d\n", *((int *)contents));
  }
#line 125
  tmp___4 = rand();
#line 125
  if (tmp___4 % 2 == 1) {
#line 125
    tmp___3 = 1;
  } else {
#line 125
    tmp___3 = 0;
  }
#line 125
  return (tmp___3);
}
}
#line 129 "binutils_leak_8.c"
bfd_boolean bfd_set_section_contents(void const   *location ) 
{ 
  int tmp___0 ;
  int tmp___1 ;

  {
#line 132
  if (location) {
#line 133
    printf((char const   * __restrict  )"%d\n", *((int *)location));
  }
#line 134
  tmp___1 = rand();
#line 134
  if (tmp___1 % 2 == 1) {
#line 134
    tmp___0 = 1;
  } else {
#line 134
    tmp___0 = 0;
  }
#line 134
  return (tmp___0);
}
}
#line 137 "binutils_leak_8.c"
static void copy_section(sec_ptr isection ) 
{ 
  bfd_byte *memhunk ;
  bfd_boolean tmp ;
  bfd_boolean tmp___0 ;
  bfd_boolean tmp___1 ;
  void *memhunk___0 ;
  void *tmp___2 ;
  bfd_boolean tmp___3 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 141
  memhunk = (bfd_byte *)((void *)0);
#line 143
  tmp___6 = rand();
#line 143
  if (tmp___6 % 2 == 1) {
#line 143
    tmp___5 = 1;
  } else {
#line 143
    tmp___5 = 0;
  }
#line 143
  if (tmp___5) {
#line 149
    tmp = bfd_get_full_section_contents(isection, & memhunk);
#line 149
    if (tmp) {
#line 149
      tmp___0 = bfd_convert_section_contents(isection, & memhunk);
#line 149
      if (! tmp___0) {
#line 153
        return;
      }
    } else {
#line 153
      return;
    }
#line 156
    printf((char const   * __restrict  )"%d\n", *((int *)memhunk));
#line 158
    tmp___1 = bfd_set_section_contents((void const   *)memhunk);
#line 158
    if (! tmp___1) {
#line 161
      return;
    }
#line 164
    free((void *)memhunk);
  } else {
#line 169
    tmp___2 = malloc((size_t )4);
#line 169
    memhunk___0 = tmp___2;
#line 170
    memset(memhunk___0, 0, 4);
#line 172
    tmp___3 = bfd_set_section_contents((void const   *)memhunk___0);
#line 172
    if (! tmp___3) {
#line 175
      return;
    }
#line 178
    free(memhunk___0);
  }
#line 180
  return;
}
}
#line 183
extern int ( /* missing proto */  time)() ;
#line 182 "binutils_leak_8.c"
int main(void) 
{ 
  int tmp ;
  struct bfd_section sec ;
  sec_ptr isection ;
  int tmp___0 ;

  {
#line 183
  tmp = time((void *)0);
#line 183
  srand((unsigned int )tmp);
#line 186
  isection = & sec;
#line 187
  tmp___0 = rand();
#line 187
  sec.compress_status = (unsigned int )(tmp___0 % 3);
#line 189
  copy_section(isection);
#line 192
  return (0);
}
}
