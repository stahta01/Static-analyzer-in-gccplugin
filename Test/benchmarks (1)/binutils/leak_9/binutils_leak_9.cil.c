/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

#line 216 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h"
typedef unsigned long size_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 29 "../include/common.h"
typedef int bool;
#line 34 "../include/common.h"
typedef void make_cleanup_ftype(void * );
#line 36 "../include/common.h"
struct cleanup {
   struct cleanup *next ;
   void (*function)(void * ) ;
   void (*free_arg)(void * ) ;
   void *arg ;
};
#line 14 "binutils_leak_9.c"
struct string {
   char *b ;
   char *p ;
   char *e ;
};
#line 14 "binutils_leak_9.c"
typedef struct string string;
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 374 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rand)(void) ;
#line 376
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) srand)(unsigned int __seed ) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 31 "../include/common.h"
bool true  =    1;
#line 32 "../include/common.h"
bool false  =    0;
#line 44 "../include/common.h"
static struct cleanup  const  sentinel_cleanup  =    {(struct cleanup *)0, (void (*)(void * ))0, (void (*)(void * ))0, (void *)0};
#line 49 "../include/common.h"
static struct cleanup *cleanup_chain  =    (struct cleanup *)(& sentinel_cleanup);
#line 50 "../include/common.h"
static struct cleanup *final_cleanup_chain  ;
#line 52
void discard_cleanups(struct cleanup *old_chain ) ;
#line 53
void discard_my_cleanups(struct cleanup **pmy_chain , struct cleanup *old_chain ) ;
#line 55
void discard_final_cleanups(struct cleanup *old_chain ) ;
#line 56
static void do_my_cleanups(struct cleanup **pmy_chain , struct cleanup *old_chain ) ;
#line 58
void do_cleanups(struct cleanup *old_chain ) ;
#line 59
static struct cleanup *make_my_cleanup2(struct cleanup **pmy_chain , make_cleanup_ftype *function ,
                                        void *arg , void (*free_arg)(void * ) ) ;
#line 62
static struct cleanup *make_my_cleanup(struct cleanup **pmy_chain , make_cleanup_ftype *function ,
                                       void *arg ) ;
#line 65
struct cleanup *make_cleanup(make_cleanup_ftype *function , void *arg ) ;
#line 68 "../include/common.h"
void discard_cleanups(struct cleanup *old_chain ) 
{ 


  {
#line 71
  discard_my_cleanups(& cleanup_chain, old_chain);
#line 72
  return;
}
}
#line 74 "../include/common.h"
void discard_final_cleanups(struct cleanup *old_chain ) 
{ 


  {
#line 77
  discard_my_cleanups(& final_cleanup_chain, old_chain);
#line 78
  return;
}
}
#line 80 "../include/common.h"
void discard_my_cleanups(struct cleanup **pmy_chain , struct cleanup *old_chain ) 
{ 
  struct cleanup *ptr ;

  {
#line 86
  while (1) {
#line 86
    ptr = *pmy_chain;
#line 86
    if (! ((unsigned long )ptr != (unsigned long )old_chain)) {
#line 86
      break;
    }
#line 88
    *pmy_chain = ptr->next;
#line 89
    if (ptr->free_arg) {
#line 90
      (*(ptr->free_arg))(ptr->arg);
    }
#line 91
    free((void *)ptr);
  }
#line 94
  printf((char const   * __restrict  )"freearg: %x\n", ptr->arg);
#line 95
  return;
}
}
#line 97 "../include/common.h"
static void do_my_cleanups(struct cleanup **pmy_chain , struct cleanup *old_chain ) 
{ 
  struct cleanup *ptr ;

  {
#line 103
  while (1) {
#line 103
    ptr = *pmy_chain;
#line 103
    if (! ((unsigned long )ptr != (unsigned long )old_chain)) {
#line 103
      break;
    }
#line 105
    *pmy_chain = ptr->next;
#line 106
    (*(ptr->function))(ptr->arg);
#line 107
    printf((char const   * __restrict  )"cleanup!!!!! =========\n");
#line 108
    printf((char const   * __restrict  )"%x\n", ptr->arg);
#line 109
    if (ptr->free_arg) {
#line 110
      (*(ptr->free_arg))(ptr->arg);
    }
#line 112
    free((void *)ptr);
  }
#line 114
  return;
}
}
#line 116 "../include/common.h"
void do_cleanups(struct cleanup *old_chain ) 
{ 


  {
#line 118
  do_my_cleanups(& cleanup_chain, old_chain);
#line 119
  return;
}
}
#line 121 "../include/common.h"
static struct cleanup *make_my_cleanup2(struct cleanup **pmy_chain , make_cleanup_ftype *function ,
                                        void *arg , void (*free_arg)(void * ) ) 
{ 
  struct cleanup *new ;
  void *tmp ;
  struct cleanup *old_chain ;

  {
#line 125
  tmp = malloc(sizeof(struct cleanup ));
#line 125
  new = (struct cleanup *)tmp;
#line 127
  old_chain = *pmy_chain;
#line 129
  new->next = *pmy_chain;
#line 130
  new->function = function;
#line 131
  new->free_arg = free_arg;
#line 132
  new->arg = arg;
#line 133
  *pmy_chain = new;
#line 135
  if ((unsigned long )old_chain == (unsigned long )((void *)0)) {
#line 136
    exit(1);
  }
#line 138
  return (old_chain);
}
}
#line 141 "../include/common.h"
static struct cleanup *make_my_cleanup(struct cleanup **pmy_chain , make_cleanup_ftype *function ,
                                       void *arg ) 
{ 
  struct cleanup *tmp ;

  {
#line 145
  tmp = make_my_cleanup2(pmy_chain, function, arg, (void (*)(void * ))((void *)0));
#line 145
  return (tmp);
}
}
#line 148 "../include/common.h"
struct cleanup *make_cleanup(make_cleanup_ftype *function , void *arg ) 
{ 
  struct cleanup *tmp ;

  {
#line 151
  tmp = make_my_cleanup(& cleanup_chain, function, arg);
#line 151
  return (tmp);
}
}
#line 21 "binutils_leak_9.c"
static void string_init(string *s ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
#line 24
  tmp___0 = (char *)((void *)0);
#line 24
  s->e = tmp___0;
#line 24
  tmp = tmp___0;
#line 24
  s->p = tmp;
#line 24
  s->b = tmp;
#line 25
  return;
}
}
#line 27 "binutils_leak_9.c"
static void string_append(string *p , char const   *s ) 
{ 


  {
#line 32
  printf((char const   * __restrict  )"%d\n", *((int *)s));
#line 33
  return;
}
}
#line 44
extern int ( /* missing proto */  strncmp)() ;
#line 52
extern int ( /* missing proto */  strlen)() ;
#line 63
extern int ( /* missing proto */  isdigit)() ;
#line 73
char *ada_demangle(char const   *mangled ) ;
#line 73 "binutils_leak_9.c"
static char const   * const  operators[20][2]  = 
#line 73
  { {        (char const   * const  )"Oabs",        (char const   * const  )"abs"}, 
   {        (char const   * const  )"Oand",        (char const   * const  )"and"}, 
   {        (char const   * const  )"Omod",        (char const   * const  )"mod"}, 
   {        (char const   * const  )"Onot",        (char const   * const  )"not"}, 
   {        (char const   * const  )"Oor",        (char const   * const  )"or"}, 
   {        (char const   * const  )"Orem",        (char const   * const  )"rem"}, 
   {        (char const   * const  )"Oxor",        (char const   * const  )"xor"}, 
   {        (char const   * const  )"Oeq",        (char const   * const  )"="}, 
   {        (char const   * const  )"One",        (char const   * const  )"/="}, 
   {        (char const   * const  )"Olt",        (char const   * const  )"<"}, 
   {        (char const   * const  )"Ole",        (char const   * const  )"<="}, 
   {        (char const   * const  )"Ogt",        (char const   * const  )">"}, 
   {        (char const   * const  )"Oge",        (char const   * const  )">="}, 
   {        (char const   * const  )"Oadd",        (char const   * const  )"+"}, 
   {        (char const   * const  )"Osubtract",        (char const   * const  )"-"}, 
   {        (char const   * const  )"Oconcat",        (char const   * const  )"&"}, 
   {        (char const   * const  )"Omultiply",        (char const   * const  )"*"}, 
   {        (char const   * const  )"Odivide",        (char const   * const  )"/"}, 
   {        (char const   * const  )"Oexpon",        (char const   * const  )"**"}, 
   {        (char const   * const  )((void *)0),        (char const   * const  )((void *)0)}};
#line 91
extern int ( /* missing proto */  memcpy)() ;
#line 171
extern int ( /* missing proto */  strcpy)() ;
#line 218
char *ada_demangle(char const   *mangled ) ;
#line 218 "binutils_leak_9.c"
static char const   * const  special[6][2]  = { {        (char const   * const  )"_elabb",        (char const   * const  )"\'Elab_Body"}, 
   {        (char const   * const  )"_elabs",        (char const   * const  )"\'Elab_Spec"}, 
   {        (char const   * const  )"_size",        (char const   * const  )"\'Size"}, 
   {        (char const   * const  )"_alignment",        (char const   * const  )"\'Alignment"}, 
   {        (char const   * const  )"_assign",        (char const   * const  )".\":=\""}, 
   {        (char const   * const  )((void *)0),        (char const   * const  )((void *)0)}};
#line 35 "binutils_leak_9.c"
char *ada_demangle(char const   *mangled ) 
{ 
  int len0 ;
  char const   *p ;
  char *d ;
  char *demangled ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int k ;
  size_t slen ;
  int tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  char *tmp___11 ;
  char const   *name ;
  int tmp___12 ;
  char const   *name___0 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int k___0 ;
  size_t slen___0 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  char *tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  void *tmp___24 ;

  {
#line 44
  tmp = strncmp(mangled, "_ada_", 5);
#line 44
  if (tmp == 0) {
#line 45
    mangled += 5;
  }
#line 48
  if (97 <= (int )*(mangled + 0)) {
#line 48
    if (! ((int const   )*(mangled + 0) <= 122)) {
#line 49
      goto unknown;
    }
  } else {
#line 49
    goto unknown;
  }
#line 52
  tmp___0 = strlen(mangled);
#line 52
  len0 = (tmp___0 + 7) + 1;
#line 53
  tmp___1 = malloc(sizeof(char ) * (unsigned long )len0);
#line 53
  demangled = (char *)tmp___1;
#line 55
  d = demangled;
#line 56
  p = mangled;
#line 58
  while (1) {
#line 61
    if (97 <= (int )*p) {
#line 61
      if ((int const   )*p <= 122) {
#line 70
        if ((int const   )*(p + 0) == 79) {
#line 83
          k = 0;
#line 83
          while ((unsigned long )operators[k][0] != (unsigned long )((void *)0)) {
#line 85
            tmp___6 = strlen(operators[k][0]);
#line 85
            slen = (size_t )tmp___6;
#line 86
            tmp___10 = strncmp(p, operators[k][0], slen);
#line 86
            if (tmp___10 == 0) {
#line 88
              p += slen;
#line 89
              tmp___7 = strlen(operators[k][1]);
#line 89
              slen = (size_t )tmp___7;
#line 90
              tmp___8 = d;
#line 90
              d ++;
#line 90
              *tmp___8 = (char )'\"';
#line 91
              memcpy(d, operators[k][1], slen);
#line 92
              d += slen;
#line 93
              tmp___9 = d;
#line 93
              d ++;
#line 93
              *tmp___9 = (char )'\"';
#line 94
              break;
            }
#line 83
            k ++;
          }
#line 98
          if ((unsigned long )operators[k][0] == (unsigned long )((void *)0)) {
#line 99
            goto unknown;
          }
        } else {
#line 105
          goto unknown;
        }
      } else {
#line 61
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
#line 63
      while (1) {
#line 65
        tmp___2 = d;
#line 65
        d ++;
#line 65
        tmp___3 = p;
#line 65
        p ++;
#line 65
        *tmp___2 = (char )*tmp___3;
#line 63
        if (97 <= (int )*p) {
#line 63
          if (! ((int const   )*p <= 122)) {
#line 63
            goto _L___0;
          }
        } else {
          _L___0: /* CIL Label */ 
#line 63
          tmp___4 = isdigit((int const   )*p);
#line 63
          if (! tmp___4) {
#line 63
            if ((int const   )*(p + 0) == 95) {
#line 63
              if (97 <= (int )*(p + 1)) {
#line 63
                if (! ((int const   )*(p + 1) <= 122)) {
#line 63
                  goto _L;
                }
              } else {
                _L: /* CIL Label */ 
#line 63
                tmp___5 = isdigit((int const   )*(p + 1));
#line 63
                if (! tmp___5) {
#line 63
                  break;
                }
              }
            } else {
#line 63
              break;
            }
          }
        }
      }
    }
#line 109
    if ((int const   )*(p + 0) == 84) {
#line 109
      if ((int const   )*(p + 1) == 75) {
#line 112
        if ((int const   )*(p + 2) == 66) {
#line 112
          if ((int const   )*(p + 3) == 0) {
#line 115
            break;
          } else {
#line 112
            goto _L___2;
          }
        } else
        _L___2: /* CIL Label */ 
#line 117
        if ((int const   )*(p + 2) == 95) {
#line 117
          if ((int const   )*(p + 3) == 95) {
#line 120
            p += 4;
#line 121
            tmp___11 = d;
#line 121
            d ++;
#line 121
            *tmp___11 = (char )'.';
#line 122
            continue;
          } else {
#line 125
            goto unknown;
          }
        } else {
#line 125
          goto unknown;
        }
      }
    }
#line 127
    if ((int const   )*(p + 0) == 69) {
#line 127
      if ((int const   )*(p + 1) == 0) {
#line 130
        goto unknown;
      }
    }
#line 132
    if ((int const   )*(p + 0) == 80) {
#line 132
      goto _L___3;
    } else
#line 132
    if ((int const   )*(p + 0) == 78) {
      _L___3: /* CIL Label */ 
#line 132
      if ((int const   )*(p + 1) == 0) {
#line 135
        break;
      }
    }
#line 137
    if ((int const   )*p == 78) {
#line 137
      goto _L___4;
    } else
#line 137
    if ((int const   )*p == 83) {
      _L___4: /* CIL Label */ 
#line 137
      if ((int const   )*(p + 1) == 0) {
#line 140
        goto unknown;
      }
    }
#line 142
    if ((int const   )*(p + 0) == 88) {
#line 145
      p ++;
#line 146
      while (1) {
#line 146
        if (! ((int const   )*(p + 0) == 110)) {
#line 146
          if (! ((int const   )*(p + 0) == 98)) {
#line 146
            break;
          }
        }
#line 147
        p ++;
      }
    }
#line 149
    if ((int const   )*(p + 0) == 83) {
#line 149
      if ((int const   )*(p + 1) != 0) {
#line 149
        if ((int const   )*(p + 2) == 95) {
#line 149
          goto _L___6;
        } else
#line 149
        if ((int const   )*(p + 2) == 0) {
          _L___6: /* CIL Label */ 
#line 153
          switch ((int const   )*(p + 1)) {
          case 82: 
#line 156
          name = "\'Read";
#line 157
          break;
          case 87: 
#line 159
          name = "\'Write";
#line 160
          break;
          case 73: 
#line 162
          name = "\'Input";
#line 163
          break;
          case 79: 
#line 165
          name = "\'Output";
#line 166
          break;
          default: 
#line 168
          goto unknown;
          }
#line 170
          p += 2;
#line 171
          strcpy(d, name);
#line 172
          tmp___12 = strlen(name);
#line 172
          d += tmp___12;
        } else {
#line 149
          goto _L___7;
        }
      } else {
#line 149
        goto _L___7;
      }
    } else
    _L___7: /* CIL Label */ 
#line 174
    if ((int const   )*(p + 0) == 68) {
#line 178
      switch ((int const   )*(p + 1)) {
      case 70: 
#line 181
      name___0 = ".Finalize";
#line 182
      break;
      case 65: 
#line 184
      name___0 = ".Adjust";
#line 185
      break;
      default: 
#line 187
      goto unknown;
      }
#line 189
      strcpy(d, name___0);
#line 190
      tmp___13 = strlen(name___0);
#line 190
      d += tmp___13;
#line 191
      break;
    }
#line 194
    if ((int const   )*(p + 0) == 95) {
#line 197
      if ((int const   )*(p + 1) == 95) {
#line 200
        p += 2;
#line 202
        tmp___20 = isdigit((int const   )*p);
#line 202
        if (tmp___20) {
#line 205
          while (1) {
#line 206
            p ++;
#line 205
            tmp___14 = isdigit((int const   )*p);
#line 205
            if (! tmp___14) {
#line 205
              if ((int const   )*(p + 0) == 95) {
#line 205
                tmp___15 = isdigit((int const   )*(p + 1));
#line 205
                if (! tmp___15) {
#line 205
                  break;
                }
              } else {
#line 205
                break;
              }
            }
          }
#line 208
          if ((int const   )*p == 88) {
#line 210
            p ++;
#line 211
            while (1) {
#line 211
              if (! ((int const   )*(p + 0) == 110)) {
#line 211
                if (! ((int const   )*(p + 0) == 98)) {
#line 211
                  break;
                }
              }
#line 212
              p ++;
            }
          }
        } else
#line 215
        if ((int const   )*(p + 0) == 95) {
#line 215
          if ((int const   )*(p + 1) != 95) {
#line 228
            k___0 = 0;
#line 228
            while ((unsigned long )special[k___0][0] != (unsigned long )((void *)0)) {
#line 230
              tmp___16 = strlen(special[k___0][0]);
#line 230
              slen___0 = (size_t )tmp___16;
#line 231
              tmp___18 = strncmp(p, special[k___0][0], slen___0);
#line 231
              if (tmp___18 == 0) {
#line 233
                p += slen___0;
#line 234
                tmp___17 = strlen(special[k___0][1]);
#line 234
                slen___0 = (size_t )tmp___17;
#line 235
                memcpy(d, special[k___0][1], slen___0);
#line 236
                d += slen___0;
#line 237
                break;
              }
#line 228
              k___0 ++;
            }
#line 240
            if ((unsigned long )special[k___0][0] != (unsigned long )((void *)0)) {
#line 241
              break;
            } else {
#line 243
              goto unknown;
            }
          } else {
#line 247
            tmp___19 = d;
#line 247
            d ++;
#line 247
            *tmp___19 = (char )'.';
#line 248
            continue;
          }
        } else {
#line 247
          tmp___19 = d;
#line 247
          d ++;
#line 247
          *tmp___19 = (char )'.';
#line 248
          continue;
        }
      } else
#line 251
      if ((int const   )*(p + 1) == 66) {
#line 251
        goto _L___8;
      } else
#line 251
      if ((int const   )*(p + 1) == 69) {
        _L___8: /* CIL Label */ 
#line 254
        p += 2;
#line 255
        while (1) {
#line 255
          tmp___21 = isdigit((int const   )*p);
#line 255
          if (! tmp___21) {
#line 255
            break;
          }
#line 256
          p ++;
        }
#line 257
        if ((int const   )*(p + 0) == 115) {
#line 257
          if ((int const   )*(p + 1) == 0) {
#line 258
            break;
          } else {
#line 260
            goto unknown;
          }
        } else {
#line 260
          goto unknown;
        }
      } else {
#line 263
        goto unknown;
      }
    }
#line 266
    if ((int const   )*(p + 0) == 46) {
#line 266
      tmp___23 = isdigit((int const   )*(p + 1));
#line 266
      if (tmp___23) {
#line 269
        p += 2;
#line 270
        while (1) {
#line 270
          tmp___22 = isdigit((int const   )*p);
#line 270
          if (! tmp___22) {
#line 270
            break;
          }
#line 271
          p ++;
        }
      }
    }
#line 273
    if ((int const   )*p == 0) {
#line 276
      break;
    } else {
#line 279
      goto unknown;
    }
  }
#line 281
  *d = (char)0;
#line 282
  return (demangled);
  unknown: 
#line 285
  len0 = strlen(mangled);
#line 286
  tmp___24 = malloc(sizeof(char ) * (unsigned long )(len0 + 3));
#line 286
  demangled = (char *)tmp___24;
#line 288
  if ((int const   )*(mangled + 0) == 60) {
#line 289
    strcpy(demangled, mangled);
  } else {
#line 291
    sprintf((char * __restrict  )demangled, (char const   * __restrict  )"<%s>", mangled);
  }
#line 293
  return (demangled);
}
}
#line 300
extern int ( /* missing proto */  strdup)() ;
#line 296 "binutils_leak_9.c"
char *cplus_demangle(char const   *mangled ) 
{ 
  int tmp ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 299
  tmp___2 = rand();
#line 299
  if (tmp___2 % 2 == 1) {
#line 299
    tmp___1 = 1;
  } else {
#line 299
    tmp___1 = 0;
  }
#line 299
  if (tmp___1) {
#line 300
    tmp = strdup(mangled);
#line 300
    return ((char *)tmp);
  }
#line 302
  tmp___6 = rand();
#line 302
  if (tmp___6 % 2 == 1) {
#line 302
    tmp___5 = 1;
  } else {
#line 302
    tmp___5 = 0;
  }
#line 302
  if (tmp___5) {
#line 303
    tmp___3 = ada_demangle(mangled);
#line 303
    return (tmp___3);
  }
#line 305
  return ((char *)((void *)0));
}
}
#line 316
extern int ( /* missing proto */  strncpy)() ;
#line 308 "binutils_leak_9.c"
void demangle_template_value_parm(char const   **mangled , string *s ) 
{ 
  int symbol_len ;
  char *p ;
  void *tmp ;
  char *q ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 311
  symbol_len = 3;
#line 313
  tmp___2 = rand();
#line 313
  if (tmp___2 % 2 == 1) {
#line 313
    tmp___1 = 1;
  } else {
#line 313
    tmp___1 = 0;
  }
#line 313
  if (tmp___1) {
#line 315
    tmp = malloc(sizeof(char ) * (unsigned long )(symbol_len + 1));
#line 315
    p = (char *)tmp;
#line 316
    strncpy(p, *mangled, symbol_len);
#line 317
    *(p + symbol_len) = (char )'\000';
#line 319
    q = cplus_demangle((char const   *)p);
#line 320
    if (q) {
#line 322
      string_append(s, (char const   *)q);
#line 323
      free((void *)q);
    } else {
#line 326
      string_append(s, (char const   *)p);
#line 327
      free((void *)p);
    }
  }
#line 330
  *mangled += symbol_len;
#line 332
  return;
}
}
#line 341
extern int ( /* missing proto */  time)() ;
#line 335 "binutils_leak_9.c"
int main(void) 
{ 
  time_t t ;
  string s ;
  char const   *mangled ;
  int tmp ;

  {
#line 340
  mangled = "123456";
#line 341
  tmp = time(& t);
#line 341
  srand((unsigned int )tmp);
#line 343
  string_init(& s);
#line 344
  demangle_template_value_parm(& mangled, & s);
#line 345
  return (0);
}
}
