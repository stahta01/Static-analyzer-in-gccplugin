/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

#line 216 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h"
typedef unsigned long size_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 29 "../include/common.h"
typedef int bool;
#line 34 "../include/common.h"
typedef void make_cleanup_ftype(void * );
#line 36 "../include/common.h"
struct cleanup {
   struct cleanup *next ;
   void (*function)(void * ) ;
   void (*free_arg)(void * ) ;
   void *arg ;
};
#line 10 "binutils_leak_4.c"
typedef bool bfd_boolean;
#line 11 "binutils_leak_4.c"
typedef unsigned int bfd_size_type;
#line 13
struct fileinfo;
#line 13
struct line_sequence;
#line 13
struct line_info;
#line 13 "binutils_leak_4.c"
struct line_info_table {
   unsigned int num_files ;
   unsigned int num_sequences ;
   struct fileinfo *files ;
   struct line_sequence *sequences ;
   struct line_info *lcl_head ;
};
#line 23 "binutils_leak_4.c"
struct fileinfo {
   char *name ;
};
#line 28 "binutils_leak_4.c"
struct line_sequence {
   struct line_sequence *prev_sequence ;
   struct line_info *last_line ;
};
#line 34 "binutils_leak_4.c"
struct line_info {
   struct line_info *prev_line ;
   unsigned int line ;
   unsigned char end_sequence ;
};
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 374 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rand)(void) ;
#line 376
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) srand)(unsigned int __seed ) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 31 "../include/common.h"
bool true  =    1;
#line 32 "../include/common.h"
bool false  =    0;
#line 44 "../include/common.h"
static struct cleanup  const  sentinel_cleanup  =    {(struct cleanup *)0, (void (*)(void * ))0, (void (*)(void * ))0, (void *)0};
#line 49 "../include/common.h"
static struct cleanup *cleanup_chain  =    (struct cleanup *)(& sentinel_cleanup);
#line 50 "../include/common.h"
static struct cleanup *final_cleanup_chain  ;
#line 52
void discard_cleanups(struct cleanup *old_chain ) ;
#line 53
void discard_my_cleanups(struct cleanup **pmy_chain , struct cleanup *old_chain ) ;
#line 55
void discard_final_cleanups(struct cleanup *old_chain ) ;
#line 56
static void do_my_cleanups(struct cleanup **pmy_chain , struct cleanup *old_chain ) ;
#line 58
void do_cleanups(struct cleanup *old_chain ) ;
#line 59
static struct cleanup *make_my_cleanup2(struct cleanup **pmy_chain , make_cleanup_ftype *function ,
                                        void *arg , void (*free_arg)(void * ) ) ;
#line 62
static struct cleanup *make_my_cleanup(struct cleanup **pmy_chain , make_cleanup_ftype *function ,
                                       void *arg ) ;
#line 65
struct cleanup *make_cleanup(make_cleanup_ftype *function , void *arg ) ;
#line 68 "../include/common.h"
void discard_cleanups(struct cleanup *old_chain ) 
{ 


  {
#line 71
  discard_my_cleanups(& cleanup_chain, old_chain);
#line 72
  return;
}
}
#line 74 "../include/common.h"
void discard_final_cleanups(struct cleanup *old_chain ) 
{ 


  {
#line 77
  discard_my_cleanups(& final_cleanup_chain, old_chain);
#line 78
  return;
}
}
#line 80 "../include/common.h"
void discard_my_cleanups(struct cleanup **pmy_chain , struct cleanup *old_chain ) 
{ 
  struct cleanup *ptr ;

  {
#line 86
  while (1) {
#line 86
    ptr = *pmy_chain;
#line 86
    if (! ((unsigned long )ptr != (unsigned long )old_chain)) {
#line 86
      break;
    }
#line 88
    *pmy_chain = ptr->next;
#line 89
    if (ptr->free_arg) {
#line 90
      (*(ptr->free_arg))(ptr->arg);
    }
#line 91
    free((void *)ptr);
  }
#line 94
  printf((char const   * __restrict  )"freearg: %x\n", ptr->arg);
#line 95
  return;
}
}
#line 97 "../include/common.h"
static void do_my_cleanups(struct cleanup **pmy_chain , struct cleanup *old_chain ) 
{ 
  struct cleanup *ptr ;

  {
#line 103
  while (1) {
#line 103
    ptr = *pmy_chain;
#line 103
    if (! ((unsigned long )ptr != (unsigned long )old_chain)) {
#line 103
      break;
    }
#line 105
    *pmy_chain = ptr->next;
#line 106
    (*(ptr->function))(ptr->arg);
#line 107
    printf((char const   * __restrict  )"cleanup!!!!! =========\n");
#line 108
    printf((char const   * __restrict  )"%x\n", ptr->arg);
#line 109
    if (ptr->free_arg) {
#line 110
      (*(ptr->free_arg))(ptr->arg);
    }
#line 112
    free((void *)ptr);
  }
#line 114
  return;
}
}
#line 116 "../include/common.h"
void do_cleanups(struct cleanup *old_chain ) 
{ 


  {
#line 118
  do_my_cleanups(& cleanup_chain, old_chain);
#line 119
  return;
}
}
#line 121 "../include/common.h"
static struct cleanup *make_my_cleanup2(struct cleanup **pmy_chain , make_cleanup_ftype *function ,
                                        void *arg , void (*free_arg)(void * ) ) 
{ 
  struct cleanup *new ;
  void *tmp ;
  struct cleanup *old_chain ;

  {
#line 125
  tmp = malloc(sizeof(struct cleanup ));
#line 125
  new = (struct cleanup *)tmp;
#line 127
  old_chain = *pmy_chain;
#line 129
  new->next = *pmy_chain;
#line 130
  new->function = function;
#line 131
  new->free_arg = free_arg;
#line 132
  new->arg = arg;
#line 133
  *pmy_chain = new;
#line 135
  if ((unsigned long )old_chain == (unsigned long )((void *)0)) {
#line 136
    exit(1);
  }
#line 138
  return (old_chain);
}
}
#line 141 "../include/common.h"
static struct cleanup *make_my_cleanup(struct cleanup **pmy_chain , make_cleanup_ftype *function ,
                                       void *arg ) 
{ 
  struct cleanup *tmp ;

  {
#line 145
  tmp = make_my_cleanup2(pmy_chain, function, arg, (void (*)(void * ))((void *)0));
#line 145
  return (tmp);
}
}
#line 148 "../include/common.h"
struct cleanup *make_cleanup(make_cleanup_ftype *function , void *arg ) 
{ 
  struct cleanup *tmp ;

  {
#line 151
  tmp = make_my_cleanup(& cleanup_chain, function, arg);
#line 151
  return (tmp);
}
}
#line 42 "binutils_leak_4.c"
static bfd_boolean add_line_info(struct line_info_table *table , unsigned int line ,
                                 int end_sequence ) 
{ 
  bfd_size_type amt ;
  struct line_sequence *seq ;
  struct line_info *info ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 47
  amt = (bfd_size_type )sizeof(struct line_info );
#line 48
  seq = table->sequences;
#line 49
  tmp = malloc((size_t )amt);
#line 49
  info = (struct line_info *)tmp;
#line 51
  if ((unsigned long )info == (unsigned long )((void *)0)) {
#line 52
    return (0);
  }
#line 54
  info->prev_line = (struct line_info *)((void *)0);
#line 55
  info->line = line;
#line 56
  info->end_sequence = (unsigned char )end_sequence;
#line 60
  if (seq) {
#line 60
    if ((int )(seq->last_line)->end_sequence == end_sequence) {
#line 63
      if ((unsigned long )table->lcl_head == (unsigned long )seq->last_line) {
#line 64
        table->lcl_head = info;
      }
#line 66
      info->prev_line = (seq->last_line)->prev_line;
#line 67
      seq->last_line = info;
    } else {
#line 60
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 69
  if (! seq) {
#line 69
    goto _L;
  } else
#line 69
  if ((seq->last_line)->end_sequence) {
    _L: /* CIL Label */ 
#line 72
    amt = (bfd_size_type )sizeof(struct line_sequence );
#line 73
    tmp___0 = malloc((size_t )amt);
#line 73
    seq = (struct line_sequence *)tmp___0;
#line 74
    if ((unsigned long )seq == (unsigned long )((void *)0)) {
#line 75
      return (0);
    }
#line 77
    seq->prev_sequence = table->sequences;
#line 78
    seq->last_line = info;
#line 79
    table->lcl_head = info;
#line 80
    table->sequences = seq;
#line 81
    (table->num_sequences) ++;
  } else {
#line 86
    info->prev_line = seq->last_line;
#line 87
    seq->last_line = info;
#line 90
    if (! table->lcl_head) {
#line 91
      table->lcl_head = info;
    }
  }
#line 94
  tmp___3 = rand();
#line 94
  if (tmp___3 % 2 == 1) {
#line 94
    tmp___2 = 1;
  } else {
#line 94
    tmp___2 = 0;
  }
#line 94
  return (tmp___2);
}
}
#line 97 "binutils_leak_4.c"
static bfd_boolean sort_line_sequences(struct line_info_table *table ) 
{ 
  bfd_size_type amt ;
  struct line_sequence *sequences ;
  struct line_sequence *seq ;
  unsigned int n ;
  unsigned int num_sequences ;
  void *tmp ;
  struct line_sequence *last_seq ;

  {
#line 103
  n = 0U;
#line 104
  num_sequences = table->num_sequences;
#line 106
  if (num_sequences == 0U) {
#line 107
    return (1);
  }
#line 110
  amt = (bfd_size_type )(sizeof(struct line_sequence ) * (unsigned long )num_sequences);
#line 111
  tmp = malloc((size_t )amt);
#line 111
  sequences = (struct line_sequence *)tmp;
#line 113
  if ((unsigned long )sequences == (unsigned long )((void *)0)) {
#line 114
    return (0);
  }
#line 117
  seq = table->sequences;
#line 118
  n = 0U;
#line 118
  while (n < num_sequences) {
#line 120
    last_seq = seq;
#line 122
    if ((unsigned long )seq == (unsigned long )((void *)0)) {
#line 122
      exit(1);
    }
#line 124
    (sequences + n)->prev_sequence = (struct line_sequence *)((void *)0);
#line 125
    (sequences + n)->last_line = seq->last_line;
#line 126
    seq = seq->prev_sequence;
#line 127
    free((void *)last_seq);
#line 118
    n ++;
  }
#line 130
  if ((unsigned long )seq == (unsigned long )((void *)0)) {
#line 130
    exit(1);
  }
#line 132
  table->sequences = sequences;
#line 133
  table->num_sequences = num_sequences;
#line 134
  return (1);
}
}
#line 138 "binutils_leak_4.c"
static struct line_info_table *decode_line_info(void) 
{ 
  struct line_info_table *table ;
  bfd_size_type amt ;
  int line ;
  int end_sequence ;
  void *tmp ;
  int tmp___1 ;
  bfd_boolean tmp___2 ;
  struct fileinfo *tmp___3 ;
  void *tmp___4 ;
  bfd_boolean tmp___5 ;

  {
#line 142
  line = 0;
#line 145
  amt = (bfd_size_type )sizeof(struct line_info_table );
#line 147
  tmp = malloc((size_t )amt);
#line 147
  table = (struct line_info_table *)tmp;
#line 148
  if ((unsigned long )table == (unsigned long )((void *)0)) {
#line 149
    return ((struct line_info_table *)((void *)0));
  }
#line 151
  table->num_files = 0U;
#line 152
  table->sequences = (struct line_sequence *)((void *)0);
#line 153
  table->lcl_head = (struct line_info *)((void *)0);
#line 155
  while (line < 5) {
#line 157
    line ++;
#line 158
    tmp___1 = rand();
#line 158
    if (tmp___1 % 2 == 1) {
#line 158
      end_sequence = 1;
    } else {
#line 158
      end_sequence = 0;
    }
#line 160
    tmp___2 = add_line_info(table, (unsigned int )line, end_sequence);
#line 160
    if (! tmp___2) {
#line 161
      goto fail;
    }
#line 163
    if (table->num_files % 5U == 0U) {
#line 166
      amt = table->num_files + 5U;
#line 167
      amt = (bfd_size_type )((unsigned long )amt * sizeof(struct fileinfo ));
#line 168
      tmp___4 = realloc((void *)table->files, (size_t )amt);
#line 168
      tmp___3 = (struct fileinfo *)tmp___4;
#line 170
      if ((unsigned long )tmp___3 == (unsigned long )((void *)0)) {
#line 171
        goto fail;
      }
    }
  }
#line 175
  tmp___5 = sort_line_sequences(table);
#line 175
  if (tmp___5) {
#line 176
    return (table);
  }
  fail: 
#line 180
  if ((unsigned long )table->sequences != (unsigned long )((void *)0)) {
#line 181
    free((void *)table->sequences);
  }
#line 183
  if ((unsigned long )table->files != (unsigned long )((void *)0)) {
#line 184
    free((void *)table->files);
  }
#line 185
  return ((struct line_info_table *)0);
}
}
#line 190
extern int ( /* missing proto */  time)() ;
#line 187 "binutils_leak_4.c"
int main(void) 
{ 
  time_t t ;
  int tmp ;
  struct line_info_table *table ;

  {
#line 190
  tmp = time(& t);
#line 190
  srand((unsigned int )tmp);
#line 193
  table = decode_line_info();
#line 196
  return (0);
}
}
