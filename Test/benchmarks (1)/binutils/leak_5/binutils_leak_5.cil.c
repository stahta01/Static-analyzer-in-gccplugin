/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

#line 216 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h"
typedef unsigned long size_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 29 "../include/common.h"
typedef int bool;
#line 34 "../include/common.h"
typedef void make_cleanup_ftype(void * );
#line 36 "../include/common.h"
struct cleanup {
   struct cleanup *next ;
   void (*function)(void * ) ;
   void (*free_arg)(void * ) ;
   void *arg ;
};
#line 388 "../include/vec.h"
struct vec_prefix {
   unsigned int num ;
   unsigned int alloc ;
   void *vec[1] ;
};
#line 9 "binutils_leak_5.c"
typedef int btrace_insn;
#line 11 "binutils_leak_5.c"
struct VEC_btrace_insn {
   unsigned int num ;
   unsigned int alloc ;
   btrace_insn vec[1] ;
};
#line 11 "binutils_leak_5.c"
typedef struct VEC_btrace_insn VEC_btrace_insn;
#line 13 "binutils_leak_5.c"
struct btrace_function {
   struct btrace_function *prev ;
   struct btrace_function *next ;
   VEC_btrace_insn *insn ;
};
#line 20 "binutils_leak_5.c"
struct btrace_thread_info {
   struct btrace_function *begin ;
   struct btrace_function *end ;
};
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 374 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rand)(void) ;
#line 376
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) srand)(unsigned int __seed ) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 31 "../include/common.h"
bool true  =    1;
#line 32 "../include/common.h"
bool false  =    0;
#line 44 "../include/common.h"
static struct cleanup  const  sentinel_cleanup  =    {(struct cleanup *)0, (void (*)(void * ))0, (void (*)(void * ))0, (void *)0};
#line 49 "../include/common.h"
static struct cleanup *cleanup_chain  =    (struct cleanup *)(& sentinel_cleanup);
#line 50 "../include/common.h"
static struct cleanup *final_cleanup_chain  ;
#line 52
void discard_cleanups(struct cleanup *old_chain ) ;
#line 53
void discard_my_cleanups(struct cleanup **pmy_chain , struct cleanup *old_chain ) ;
#line 55
void discard_final_cleanups(struct cleanup *old_chain ) ;
#line 56
static void do_my_cleanups(struct cleanup **pmy_chain , struct cleanup *old_chain ) ;
#line 58
void do_cleanups(struct cleanup *old_chain ) ;
#line 59
static struct cleanup *make_my_cleanup2(struct cleanup **pmy_chain , make_cleanup_ftype *function ,
                                        void *arg , void (*free_arg)(void * ) ) ;
#line 62
static struct cleanup *make_my_cleanup(struct cleanup **pmy_chain , make_cleanup_ftype *function ,
                                       void *arg ) ;
#line 65
struct cleanup *make_cleanup(make_cleanup_ftype *function , void *arg ) ;
#line 68 "../include/common.h"
void discard_cleanups(struct cleanup *old_chain ) 
{ 


  {
#line 71
  discard_my_cleanups(& cleanup_chain, old_chain);
#line 72
  return;
}
}
#line 74 "../include/common.h"
void discard_final_cleanups(struct cleanup *old_chain ) 
{ 


  {
#line 77
  discard_my_cleanups(& final_cleanup_chain, old_chain);
#line 78
  return;
}
}
#line 80 "../include/common.h"
void discard_my_cleanups(struct cleanup **pmy_chain , struct cleanup *old_chain ) 
{ 
  struct cleanup *ptr ;

  {
#line 86
  while (1) {
#line 86
    ptr = *pmy_chain;
#line 86
    if (! ((unsigned long )ptr != (unsigned long )old_chain)) {
#line 86
      break;
    }
#line 88
    *pmy_chain = ptr->next;
#line 89
    if (ptr->free_arg) {
#line 90
      (*(ptr->free_arg))(ptr->arg);
    }
#line 91
    free((void *)ptr);
  }
#line 94
  printf((char const   * __restrict  )"freearg: %x\n", ptr->arg);
#line 95
  return;
}
}
#line 97 "../include/common.h"
static void do_my_cleanups(struct cleanup **pmy_chain , struct cleanup *old_chain ) 
{ 
  struct cleanup *ptr ;

  {
#line 103
  while (1) {
#line 103
    ptr = *pmy_chain;
#line 103
    if (! ((unsigned long )ptr != (unsigned long )old_chain)) {
#line 103
      break;
    }
#line 105
    *pmy_chain = ptr->next;
#line 106
    (*(ptr->function))(ptr->arg);
#line 107
    printf((char const   * __restrict  )"cleanup!!!!! =========\n");
#line 108
    printf((char const   * __restrict  )"%x\n", ptr->arg);
#line 109
    if (ptr->free_arg) {
#line 110
      (*(ptr->free_arg))(ptr->arg);
    }
#line 112
    free((void *)ptr);
  }
#line 114
  return;
}
}
#line 116 "../include/common.h"
void do_cleanups(struct cleanup *old_chain ) 
{ 


  {
#line 118
  do_my_cleanups(& cleanup_chain, old_chain);
#line 119
  return;
}
}
#line 121 "../include/common.h"
static struct cleanup *make_my_cleanup2(struct cleanup **pmy_chain , make_cleanup_ftype *function ,
                                        void *arg , void (*free_arg)(void * ) ) 
{ 
  struct cleanup *new ;
  void *tmp ;
  struct cleanup *old_chain ;

  {
#line 125
  tmp = malloc(sizeof(struct cleanup ));
#line 125
  new = (struct cleanup *)tmp;
#line 127
  old_chain = *pmy_chain;
#line 129
  new->next = *pmy_chain;
#line 130
  new->function = function;
#line 131
  new->free_arg = free_arg;
#line 132
  new->arg = arg;
#line 133
  *pmy_chain = new;
#line 135
  if ((unsigned long )old_chain == (unsigned long )((void *)0)) {
#line 136
    exit(1);
  }
#line 138
  return (old_chain);
}
}
#line 141 "../include/common.h"
static struct cleanup *make_my_cleanup(struct cleanup **pmy_chain , make_cleanup_ftype *function ,
                                       void *arg ) 
{ 
  struct cleanup *tmp ;

  {
#line 145
  tmp = make_my_cleanup2(pmy_chain, function, arg, (void (*)(void * ))((void *)0));
#line 145
  return (tmp);
}
}
#line 148 "../include/common.h"
struct cleanup *make_cleanup(make_cleanup_ftype *function , void *arg ) 
{ 
  struct cleanup *tmp ;

  {
#line 151
  tmp = make_my_cleanup(& cleanup_chain, function, arg);
#line 151
  return (tmp);
}
}
#line 395 "../include/vec.h"
__inline static unsigned int calculate_allocation(struct vec_prefix  const  *pfx ,
                                                  int reserve ) 
{ 
  unsigned int alloc ;
  unsigned int num ;
  int tmp ;

  {
#line 398
  alloc = 0U;
#line 399
  num = 0U;
#line 401
  if (pfx) {
#line 403
    alloc = (unsigned int )pfx->alloc;
#line 404
    num = (unsigned int )pfx->num;
  } else
#line 406
  if (! reserve) {
#line 409
    return (0U);
  }
#line 412
  if (reserve < 0) {
#line 412
    tmp = - reserve;
  } else {
#line 412
    tmp = reserve;
  }
#line 412
  if (! (alloc - num < (unsigned int )tmp)) {
#line 413
    exit(1);
  }
#line 416
  if (reserve < 0) {
#line 418
    alloc = num + (unsigned int )(- reserve);
  } else {
#line 422
    if (! alloc) {
#line 423
      alloc = 4U;
    } else
#line 424
    if (alloc < 16U) {
#line 426
      alloc *= 2U;
    } else {
#line 429
      alloc = (alloc * 3U) / 2U;
    }
#line 432
    if (alloc < num + (unsigned int )reserve) {
#line 433
      alloc = num + (unsigned int )reserve;
    }
  }
#line 435
  return (alloc);
}
}
#line 439 "../include/vec.h"
void *vec_o_reserve(void *vec , int reserve , size_t vec_offset , size_t elt_size ) 
{ 
  struct vec_prefix *pfx ;
  unsigned int alloc ;
  unsigned int tmp ;

  {
#line 441
  pfx = (struct vec_prefix *)vec;
#line 442
  tmp = calculate_allocation((struct vec_prefix  const  *)pfx, reserve);
#line 442
  alloc = tmp;
#line 444
  if (! alloc) {
#line 445
    return ((void *)0);
  }
#line 447
  vec = realloc(vec, vec_offset + (size_t )alloc * elt_size);
#line 448
  if (! vec) {
#line 448
    exit(1);
  }
#line 450
  ((struct vec_prefix *)vec)->alloc = alloc;
#line 451
  if (! pfx) {
#line 452
    ((struct vec_prefix *)vec)->num = 0U;
  }
#line 454
  return (vec);
}
}
#line 11 "binutils_leak_5.c"
__inline static int VEC_btrace_insn_space(VEC_btrace_insn *vec_ , int alloc_ , char const   *file_ ,
                                          unsigned int line_ ) 
{ 
  int tmp ;

  {
#line 11
  if (! (alloc_ >= 0)) {
#line 11
    exit(1);
  }
#line 11
  if (vec_) {
#line 11
    tmp = vec_->alloc - vec_->num >= (unsigned int )alloc_;
  } else {
#line 11
    tmp = ! alloc_;
  }
#line 11
  return (tmp);
}
}
#line 11 "binutils_leak_5.c"
__inline static btrace_insn *VEC_btrace_insn_quick_push(VEC_btrace_insn *vec_ , btrace_insn obj_ ,
                                                        char const   *file_ , unsigned int line_ ) 
{ 
  btrace_insn *slot_ ;
  unsigned int tmp ;

  {
#line 11
  if (! (vec_->num < vec_->alloc)) {
#line 11
    exit(1);
  }
#line 11
  tmp = vec_->num;
#line 11
  (vec_->num) ++;
#line 11
  slot_ = & vec_->vec[tmp];
#line 11
  *slot_ = obj_;
#line 11
  return (slot_);
}
}
#line 11 "binutils_leak_5.c"
__inline static VEC_btrace_insn *VEC_btrace_insn_alloc(int alloc_ ) 
{ 
  VEC_btrace_insn dummy ;
  void *tmp ;

  {
#line 11
  tmp = vec_o_reserve((void *)0, - alloc_, (size_t )((char *)(& dummy.vec) - (char *)(& dummy)),
                      sizeof(btrace_insn ));
#line 11
  return ((VEC_btrace_insn *)tmp);
}
}
#line 11 "binutils_leak_5.c"
__inline static int VEC_btrace_insn_reserve(VEC_btrace_insn **vec_ , int alloc_ ,
                                            char const   *file_ , unsigned int line_ ) 
{ 
  VEC_btrace_insn dummy ;
  int extend ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;

  {
#line 11
  if (alloc_ < 0) {
#line 11
    tmp = - alloc_;
  } else {
#line 11
    tmp = alloc_;
  }
#line 11
  tmp___0 = VEC_btrace_insn_space(*vec_, tmp, file_, line_);
#line 11
  if (tmp___0) {
#line 11
    tmp___1 = 0;
  } else {
#line 11
    tmp___1 = 1;
  }
#line 11
  extend = tmp___1;
#line 11
  if (extend) {
#line 11
    tmp___2 = vec_o_reserve((void *)*vec_, alloc_, (size_t )((char *)(& dummy.vec) - (char *)(& dummy)),
                            sizeof(btrace_insn ));
#line 11
    *vec_ = (VEC_btrace_insn *)tmp___2;
  }
#line 11
  return (extend);
}
}
#line 11 "binutils_leak_5.c"
__inline static btrace_insn *VEC_btrace_insn_safe_push(VEC_btrace_insn **vec_ , btrace_insn const   obj_ ,
                                                       char const   *file_ , unsigned int line_ ) 
{ 
  btrace_insn *tmp ;

  {
#line 11
  VEC_btrace_insn_reserve(vec_, 1, file_, line_);
#line 11
  tmp = VEC_btrace_insn_quick_push(*vec_, (btrace_insn )obj_, file_, line_);
#line 11
  return (tmp);
}
}
#line 25 "binutils_leak_5.c"
void btrace_clear(struct btrace_thread_info *btp ) 
{ 
  struct btrace_function *it ;
  struct btrace_function *trash ;

  {
#line 28
  it = btp->begin;
#line 30
  while ((unsigned long )it != (unsigned long )((void *)0)) {
#line 31
    trash = it;
#line 32
    it = it->next;
#line 34
    free((void *)trash);
  }
#line 37
  btp->begin = (struct btrace_function *)((void *)0);
#line 38
  btp->end = (struct btrace_function *)((void *)0);
#line 39
  return;
}
}
#line 49
extern int ( /* missing proto */  time)() ;
#line 41 "binutils_leak_5.c"
int main(void) 
{ 
  time_t t ;
  struct btrace_thread_info btinfo ;
  struct btrace_function *it ;
  struct btrace_function *next ;
  struct btrace_function *bfunc ;
  VEC_btrace_insn *insn_vec_p ;
  int tmp ;
  void *tmp___0 ;
  struct btrace_function *tmp___1 ;
  void *tmp___2 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 49
  tmp = time(& t);
#line 49
  srand((unsigned int )tmp);
#line 51
  tmp___0 = malloc(sizeof(struct btrace_function ));
#line 51
  bfunc = (struct btrace_function *)tmp___0;
#line 52
  bfunc->insn = VEC_btrace_insn_alloc(10);
#line 53
  tmp___1 = (struct btrace_function *)((void *)0);
#line 53
  bfunc->next = tmp___1;
#line 53
  bfunc->prev = tmp___1;
#line 55
  btinfo.end = bfunc;
#line 55
  btinfo.begin = btinfo.end;
#line 57
  it = btinfo.begin;
#line 58
  while (1) {
#line 58
    tmp___5 = rand();
#line 58
    if (tmp___5 % 2 == 1) {
#line 58
      tmp___4 = 1;
    } else {
#line 58
      tmp___4 = 0;
    }
#line 58
    if (! tmp___4) {
#line 58
      break;
    }
#line 59
    tmp___2 = malloc(sizeof(struct btrace_function ));
#line 59
    next = (struct btrace_function *)tmp___2;
#line 60
    insn_vec_p = VEC_btrace_insn_alloc(10);
#line 62
    next->insn = insn_vec_p;
#line 64
    it->next = next;
#line 65
    next->prev = it;
#line 66
    next->next = (struct btrace_function *)((void *)0);
#line 68
    btinfo.end = next;
#line 69
    it = it->next;
  }
#line 72
  it = btinfo.begin;
#line 73
  while ((unsigned long )it != (unsigned long )((void *)0)) {
#line 74
    insn_vec_p = it->insn;
#line 75
    VEC_btrace_insn_safe_push(& insn_vec_p, (btrace_insn const   )55, "binutils_leak_5.c",
                              75U);
#line 76
    it = it->next;
  }
#line 79
  btrace_clear(& btinfo);
#line 80
  return (0);
}
}
