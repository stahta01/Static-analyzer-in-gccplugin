/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

#line 216 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h"
typedef unsigned long size_t;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 144 "/usr/include/libio.h"
struct _IO_FILE;
#line 150 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 156 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 241 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 90 "/usr/include/stdio.h"
typedef __off_t off_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 29 "../include/common.h"
typedef int bool;
#line 34 "../include/common.h"
typedef void make_cleanup_ftype(void * );
#line 36 "../include/common.h"
struct cleanup {
   struct cleanup *next ;
   void (*function)(void * ) ;
   void (*free_arg)(void * ) ;
   void *arg ;
};
#line 7 "../include/binutils.h"
enum bfd_architecture {
    bfd_arch_unknown = 0,
    bfd_arch_obscure = 1,
    bfd_arch_m68k = 2,
    bfd_arch_vax = 3,
    bfd_arch_i960 = 4,
    bfd_arch_or1k = 5,
    bfd_arch_sparc = 6,
    bfd_arch_spu = 7,
    bfd_arch_mips = 8,
    bfd_arch_i386 = 9,
    bfd_arch_l1om = 10,
    bfd_arch_k1om = 11,
    bfd_arch_iamcu = 12,
    bfd_arch_we32k = 13,
    bfd_arch_tahoe = 14,
    bfd_arch_i860 = 15,
    bfd_arch_i370 = 16,
    bfd_arch_romp = 17,
    bfd_arch_convex = 18,
    bfd_arch_m88k = 19,
    bfd_arch_m98k = 20,
    bfd_arch_pyramid = 21,
    bfd_arch_h8300 = 22,
    bfd_arch_pdp11 = 23,
    bfd_arch_plugin = 24,
    bfd_arch_powerpc = 25,
    bfd_arch_rs6000 = 26,
    bfd_arch_hppa = 27,
    bfd_arch_d10v = 28,
    bfd_arch_d30v = 29,
    bfd_arch_dlx = 30,
    bfd_arch_m68hc11 = 31,
    bfd_arch_m68hc12 = 32,
    bfd_arch_m9s12x = 33,
    bfd_arch_m9s12xg = 34,
    bfd_arch_z8k = 35,
    bfd_arch_h8500 = 36,
    bfd_arch_sh = 37,
    bfd_arch_alpha = 38,
    bfd_arch_arm = 39,
    bfd_arch_nds32 = 40,
    bfd_arch_ns32k = 41,
    bfd_arch_w65 = 42,
    bfd_arch_tic30 = 43,
    bfd_arch_tic4x = 44,
    bfd_arch_tic54x = 45,
    bfd_arch_tic6x = 46,
    bfd_arch_tic80 = 47,
    bfd_arch_v850 = 48,
    bfd_arch_v850_rh850 = 49,
    bfd_arch_arc = 50,
    bfd_arch_m32c = 51,
    bfd_arch_m32r = 52,
    bfd_arch_mn10200 = 53,
    bfd_arch_mn10300 = 54,
    bfd_arch_fr30 = 55,
    bfd_arch_frv = 56,
    bfd_arch_moxie = 57,
    bfd_arch_ft32 = 58,
    bfd_arch_mcore = 59,
    bfd_arch_mep = 60,
    bfd_arch_metag = 61,
    bfd_arch_ia64 = 62,
    bfd_arch_ip2k = 63,
    bfd_arch_iq2000 = 64,
    bfd_arch_epiphany = 65,
    bfd_arch_mt = 66,
    bfd_arch_pj = 67,
    bfd_arch_avr = 68,
    bfd_arch_bfin = 69,
    bfd_arch_cr16 = 70,
    bfd_arch_cr16c = 71,
    bfd_arch_crx = 72,
    bfd_arch_cris = 73,
    bfd_arch_riscv = 74,
    bfd_arch_rl78 = 75,
    bfd_arch_rx = 76,
    bfd_arch_s390 = 77,
    bfd_arch_score = 78,
    bfd_arch_mmix = 79,
    bfd_arch_xstormy16 = 80,
    bfd_arch_msp430 = 81,
    bfd_arch_xc16x = 82,
    bfd_arch_xgate = 83,
    bfd_arch_xtensa = 84,
    bfd_arch_z80 = 85,
    bfd_arch_lm32 = 86,
    bfd_arch_microblaze = 87,
    bfd_arch_tilepro = 88,
    bfd_arch_tilegx = 89,
    bfd_arch_aarch64 = 90,
    bfd_arch_nios2 = 91,
    bfd_arch_visium = 92,
    bfd_arch_wasm32 = 93,
    bfd_arch_pru = 94,
    bfd_arch_last = 95
} ;
#line 512 "../include/binutils.h"
typedef unsigned long long BFD_HOST_U_64_BIT;
#line 517 "../include/binutils.h"
typedef BFD_HOST_U_64_BIT bfd_size_type;
#line 519 "../include/binutils.h"
typedef int bfd_boolean;
#line 524
struct bfd;
#line 524 "../include/binutils.h"
typedef struct bfd bfd;
#line 527 "../include/binutils.h"
struct bfd_arch_info {
   int bits_per_word ;
   int bits_per_address ;
   int bits_per_byte ;
   enum bfd_architecture arch ;
   unsigned long mach ;
   char const   *arch_name ;
   char const   *printable_name ;
   unsigned int section_align_power ;
   bfd_boolean the_default ;
   struct bfd_arch_info  const  *(*compatible)(struct bfd_arch_info  const  *a , struct bfd_arch_info  const  *b ) ;
   bfd_boolean (*scan)(struct bfd_arch_info  const  * , char const   * ) ;
   void *(*fill)(bfd_size_type count , bfd_boolean is_bigendian , bfd_boolean code ) ;
   struct bfd_arch_info  const  *next ;
};
#line 527 "../include/binutils.h"
typedef struct bfd_arch_info bfd_arch_info_type;
#line 50 "binutils_leak_1.c"
enum pos {
    pos_default = 0,
    pos_before = 1,
    pos_after = 2,
    pos_end = 3
} ;
#line 55
enum operations {
    none = 0,
    del = 1,
    replace = 2,
    print_table = 3,
    print_files = 4,
    extract = 5,
    move = 6,
    quick_append = 7
} ;
#line 180 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rename)(char const   *__old ,
                                                                             char const   *__new ) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 374 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rand)(void) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 619
extern int ( __attribute__((__nonnull__(1))) mkstemp)(char *__template ) ;
#line 262 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) lstat)(char const   * __restrict  __file ,
                                                                                              struct stat * __restrict  __buf ) ;
#line 283
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chmod)(char const   *__file ,
                                                                                            __mode_t __mode ) ;
#line 31 "../include/common.h"
bool true  =    1;
#line 32 "../include/common.h"
bool false  =    0;
#line 44 "../include/common.h"
static struct cleanup  const  sentinel_cleanup  =    {(struct cleanup *)0, (void (*)(void * ))0, (void (*)(void * ))0, (void *)0};
#line 49 "../include/common.h"
static struct cleanup *cleanup_chain  =    (struct cleanup *)(& sentinel_cleanup);
#line 50 "../include/common.h"
static struct cleanup *final_cleanup_chain  ;
#line 52
void discard_cleanups(struct cleanup *old_chain ) ;
#line 53
void discard_my_cleanups(struct cleanup **pmy_chain , struct cleanup *old_chain ) ;
#line 55
void discard_final_cleanups(struct cleanup *old_chain ) ;
#line 56
static void do_my_cleanups(struct cleanup **pmy_chain , struct cleanup *old_chain ) ;
#line 58
void do_cleanups(struct cleanup *old_chain ) ;
#line 59
static struct cleanup *make_my_cleanup2(struct cleanup **pmy_chain , make_cleanup_ftype *function ,
                                        void *arg , void (*free_arg)(void * ) ) ;
#line 62
static struct cleanup *make_my_cleanup(struct cleanup **pmy_chain , make_cleanup_ftype *function ,
                                       void *arg ) ;
#line 65
struct cleanup *make_cleanup(make_cleanup_ftype *function , void *arg ) ;
#line 68 "../include/common.h"
void discard_cleanups(struct cleanup *old_chain ) 
{ 


  {
#line 71
  discard_my_cleanups(& cleanup_chain, old_chain);
#line 72
  return;
}
}
#line 74 "../include/common.h"
void discard_final_cleanups(struct cleanup *old_chain ) 
{ 


  {
#line 77
  discard_my_cleanups(& final_cleanup_chain, old_chain);
#line 78
  return;
}
}
#line 80 "../include/common.h"
void discard_my_cleanups(struct cleanup **pmy_chain , struct cleanup *old_chain ) 
{ 
  struct cleanup *ptr ;

  {
#line 86
  while (1) {
#line 86
    ptr = *pmy_chain;
#line 86
    if (! ((unsigned long )ptr != (unsigned long )old_chain)) {
#line 86
      break;
    }
#line 88
    *pmy_chain = ptr->next;
#line 89
    if (ptr->free_arg) {
#line 90
      (*(ptr->free_arg))(ptr->arg);
    }
#line 91
    free((void *)ptr);
  }
#line 94
  printf((char const   * __restrict  )"freearg: %x\n", ptr->arg);
#line 95
  return;
}
}
#line 97 "../include/common.h"
static void do_my_cleanups(struct cleanup **pmy_chain , struct cleanup *old_chain ) 
{ 
  struct cleanup *ptr ;

  {
#line 103
  while (1) {
#line 103
    ptr = *pmy_chain;
#line 103
    if (! ((unsigned long )ptr != (unsigned long )old_chain)) {
#line 103
      break;
    }
#line 105
    *pmy_chain = ptr->next;
#line 106
    (*(ptr->function))(ptr->arg);
#line 107
    printf((char const   * __restrict  )"cleanup!!!!! =========\n");
#line 108
    printf((char const   * __restrict  )"%x\n", ptr->arg);
#line 109
    if (ptr->free_arg) {
#line 110
      (*(ptr->free_arg))(ptr->arg);
    }
#line 112
    free((void *)ptr);
  }
#line 114
  return;
}
}
#line 116 "../include/common.h"
void do_cleanups(struct cleanup *old_chain ) 
{ 


  {
#line 118
  do_my_cleanups(& cleanup_chain, old_chain);
#line 119
  return;
}
}
#line 121 "../include/common.h"
static struct cleanup *make_my_cleanup2(struct cleanup **pmy_chain , make_cleanup_ftype *function ,
                                        void *arg , void (*free_arg)(void * ) ) 
{ 
  struct cleanup *new ;
  void *tmp ;
  struct cleanup *old_chain ;

  {
#line 125
  tmp = malloc(sizeof(struct cleanup ));
#line 125
  new = (struct cleanup *)tmp;
#line 127
  old_chain = *pmy_chain;
#line 129
  new->next = *pmy_chain;
#line 130
  new->function = function;
#line 131
  new->free_arg = free_arg;
#line 132
  new->arg = arg;
#line 133
  *pmy_chain = new;
#line 135
  if ((unsigned long )old_chain == (unsigned long )((void *)0)) {
#line 136
    exit(1);
  }
#line 138
  return (old_chain);
}
}
#line 141 "../include/common.h"
static struct cleanup *make_my_cleanup(struct cleanup **pmy_chain , make_cleanup_ftype *function ,
                                       void *arg ) 
{ 
  struct cleanup *tmp ;

  {
#line 145
  tmp = make_my_cleanup2(pmy_chain, function, arg, (void (*)(void * ))((void *)0));
#line 145
  return (tmp);
}
}
#line 148 "../include/common.h"
struct cleanup *make_cleanup(make_cleanup_ftype *function , void *arg ) 
{ 
  struct cleanup *tmp ;

  {
#line 151
  tmp = make_my_cleanup(& cleanup_chain, function, arg);
#line 151
  return (tmp);
}
}
#line 16 "binutils_leak_1.c"
int silent_create  =    0;
#line 19 "binutils_leak_1.c"
int verbose  =    0;
#line 22 "binutils_leak_1.c"
int preserve_dates  =    0;
#line 26 "binutils_leak_1.c"
int newer_only  =    0;
#line 35 "binutils_leak_1.c"
int write_armap  =    0;
#line 40 "binutils_leak_1.c"
int deterministic  =    -1;
#line 44 "binutils_leak_1.c"
char *posname  =    (char *)((void *)0);
#line 50 "binutils_leak_1.c"
enum pos postype  =    (enum pos )0;
#line 55 "binutils_leak_1.c"
enum operations operation  =    (enum operations )0;
#line 103 "binutils_leak_1.c"
FILE *saved_script_handle  =    (FILE *)((void *)0);
#line 104 "binutils_leak_1.c"
FILE *previous_script_handle  =    (FILE *)((void *)0);
#line 105 "binutils_leak_1.c"
bfd_boolean force_make_executable  =    0;
#line 107 "binutils_leak_1.c"
char *default_target  ;
#line 108 "binutils_leak_1.c"
char const   *output_filename  =    "a.out";
#line 111 "binutils_leak_1.c"
char *program_name  ;
#line 114 "binutils_leak_1.c"
char const   *ld_sysroot  ;
#line 117 "binutils_leak_1.c"
char *ld_canon_sysroot  ;
#line 118 "binutils_leak_1.c"
int ld_canon_sysroot_len  ;
#line 121 "binutils_leak_1.c"
int g_switch_value  =    8;
#line 123 "binutils_leak_1.c"
int status  =    0;
#line 124 "binutils_leak_1.c"
int optind  =    1;
#line 131
extern int ( /* missing proto */  strcmp)() ;
#line 127 "binutils_leak_1.c"
int filename_cmp(char const   *s1 , char const   *s2 ) 
{ 
  int tmp ;

  {
#line 131
  tmp = strcmp(s1, s2);
#line 131
  return (tmp);
}
}
#line 170
extern int ( /* missing proto */  strrchr)() ;
#line 178
extern int ( /* missing proto */  memcpy)() ;
#line 166 "binutils_leak_1.c"
static char *template_in_dir(char const   *path ) 
{ 
  char const   *slash ;
  int tmp ;
  char *tmpname ;
  size_t len ;
  void *tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;

  {
#line 170
  tmp = strrchr(path, '/');
#line 170
  slash = (char const   *)tmp;
#line 174
  if ((unsigned long )slash != (unsigned long )((char *)((void *)0))) {
#line 176
    len = (size_t )(slash - path);
#line 177
    tmp___0 = malloc((len + sizeof("stXXXXXX")) + 2UL);
#line 177
    tmpname = (char *)tmp___0;
#line 178
    memcpy(tmpname, path, len);
#line 179
    tmp___1 = len;
#line 179
    len ++;
#line 179
    *(tmpname + tmp___1) = (char )'/';
  } else {
#line 183
    tmp___2 = malloc(sizeof("stXXXXXX"));
#line 183
    tmpname = (char *)tmp___2;
#line 184
    len = (size_t )0;
  }
#line 187
  memcpy(tmpname + len, "stXXXXXX", sizeof("stXXXXXX"));
#line 188
  return (tmpname);
}
}
#line 206
extern int ( /* missing proto */  close)() ;
#line 194 "binutils_leak_1.c"
char *make_tempname(char *filename ) 
{ 
  char *tmpname ;
  char *tmp ;
  int fd ;

  {
#line 197
  tmp = template_in_dir((char const   *)filename);
#line 197
  tmpname = tmp;
#line 200
  fd = mkstemp(tmpname);
#line 201
  if (fd == -1) {
#line 203
    free((void *)tmpname);
#line 204
    return ((char *)((void *)0));
  }
#line 206
  close(fd);
#line 207
  return (tmpname);
}
}
#line 228
extern int ( /* missing proto */  utime)() ;
#line 210 "binutils_leak_1.c"
void set_times(char const   *destination , struct stat  const  *statbuf ) 
{ 
  int result ;
  long tb[2] ;

  {
#line 226
  tb[0] = (long )statbuf->st_atim.tv_sec;
#line 227
  tb[1] = (long )statbuf->st_mtim.tv_sec;
#line 228
  result = utime(destination, tb);
#line 241
  if (result != 0) {
#line 242
    printf((char const   * __restrict  )"%s: cannot set time:", destination);
  }
#line 243
  return;
}
}
#line 281
extern int ( /* missing proto */  chown)() ;
#line 289
extern int ( /* missing proto */  unlink)() ;
#line 245 "binutils_leak_1.c"
int smart_rename(char const   *from , char const   *to , int preserve_dates___0 ) 
{ 
  bfd_boolean exists ;
  struct stat s ;
  int ret ;
  int tmp ;
  int tmp___0 ;

  {
#line 250
  ret = 0;
#line 252
  tmp = lstat((char const   * __restrict  )to, (struct stat * __restrict  )(& s));
#line 252
  exists = tmp == 0;
#line 256
  if (! exists) {
#line 256
    goto _L;
  } else
#line 256
  if (! ((s.st_mode & 61440U) == 40960U)) {
#line 256
    if ((s.st_mode & 61440U) == 32768U) {
#line 256
      if (s.st_mode & 128U) {
#line 256
        if (s.st_nlink == 1UL) {
          _L: /* CIL Label */ 
#line 263
          ret = rename(from, to);
#line 264
          if (ret == 0) {
#line 266
            if (exists) {
#line 280
              chmod(to, s.st_mode & 511U);
#line 281
              tmp___0 = chown(to, s.st_uid, s.st_gid);
#line 281
              if (tmp___0 >= 0) {
#line 282
                chmod(to, s.st_mode & 4095U);
              }
            }
          } else {
#line 288
            printf((char const   * __restrict  )"unable to rename \'%s\';", to);
#line 289
            unlink(from);
          }
        } else {
#line 256
          goto _L___2;
        }
      } else {
#line 256
        goto _L___2;
      }
    } else {
#line 256
      goto _L___2;
    }
  } else {
    _L___2: /* CIL Label */ 
#line 294
    if (ret != 0) {
#line 295
      printf((char const   * __restrict  )"unable to copy file \'%s\';", to);
    }
#line 297
    if (preserve_dates___0) {
#line 298
      set_times(to, (struct stat  const  *)(& s));
    }
#line 299
    unlink(from);
  }
#line 302
  return (ret);
}
}
#line 305 "binutils_leak_1.c"
void unlink_if_ordinary(char const   *name ) 
{ 


  {
#line 307
  printf((char const   * __restrict  )"%d\n", *((int *)name));
#line 308
  return;
}
}
#line 312 "binutils_leak_1.c"
static void copy_file(char const   *input_filename , char const   *output_filename___0 ,
                      char const   *input_target , char const   *output_target , bfd_arch_info_type const   *input_arch ) 
{ 
  off_t size ;
  int tmp___0 ;

  {
#line 322
  tmp___0 = rand();
#line 322
  if (tmp___0 % 2 == 1) {
#line 322
    size = (off_t )1;
  } else {
#line 322
    size = (off_t )0;
  }
#line 324
  if (size < 1L) {
#line 326
    if (size == 0L) {
#line 327
      printf((char const   * __restrict  )"error: the input file \'%s\' is empty",
             input_filename);
    }
#line 328
    status = 1;
#line 329
    return;
  }
#line 331
  return;
}
}
#line 337 "binutils_leak_1.c"
static int copy_main(int argc , char **argv ) 
{ 
  char *input_filename ;
  char *output_filename___0 ;
  char *tmpname ;
  char *input_target ;
  char *output_target ;
  bfd_boolean show_version ;
  bfd_boolean change_warn ;
  bfd_boolean formats_info ;
  int statbuf ;
  bfd_arch_info_type const   *input_arch ;
  int tmp ;

  {
#line 340
  input_filename = (char *)((void *)0);
#line 341
  output_filename___0 = (char *)((void *)0);
#line 343
  input_target = (char *)((void *)0);
#line 344
  output_target = (char *)((void *)0);
#line 345
  show_version = 0;
#line 346
  change_warn = 1;
#line 347
  formats_info = 0;
#line 350
  input_arch = (bfd_arch_info_type const   *)((void *)0);
#line 352
  input_filename = *(argv + optind);
#line 353
  if (optind + 1 < argc) {
#line 354
    output_filename___0 = *(argv + (optind + 1));
  }
#line 358
  if ((unsigned long )output_filename___0 == (unsigned long )((void *)0)) {
#line 359
    tmpname = make_tempname(input_filename);
  } else {
#line 361
    tmpname = output_filename___0;
  }
#line 364
  if ((unsigned long )tmpname == (unsigned long )((void *)0)) {
#line 365
    printf((char const   * __restrict  )"warning: could not create temporary file whilst copying \'%s\'",
           input_filename);
#line 365
    exit(1);
  }
#line 368
  copy_file((char const   *)input_filename, (char const   *)tmpname, (char const   *)input_target,
            (char const   *)output_target, input_arch);
#line 369
  if (status == 0) {
#line 371
    if (preserve_dates) {
#line 372
      set_times((char const   *)tmpname, (struct stat  const  *)(& statbuf));
    }
#line 373
    if ((unsigned long )tmpname != (unsigned long )output_filename___0) {
#line 374
      tmp = smart_rename((char const   *)tmpname, (char const   *)input_filename,
                         preserve_dates);
#line 374
      status = tmp != 0;
    }
  } else {
#line 377
    unlink_if_ordinary((char const   *)tmpname);
  }
#line 379
  return (0);
}
}
#line 382 "binutils_leak_1.c"
int main(int argc , char **argv ) 
{ 


  {
#line 385
  program_name = *(argv + 0);
#line 387
  copy_main(argc, argv);
#line 389
  return (status);
}
}
