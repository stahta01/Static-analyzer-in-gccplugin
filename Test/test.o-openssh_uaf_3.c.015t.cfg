
;; Function key_to_blob (key_to_blob, funcdef_no=23, decl_uid=3500, cgraph_uid=24, symbol_order=23)

Merging blocks 2 and 3
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
int key_to_blob (const struct Key * key, u_char * * blobp, u_int * lenp)
{
  int D.3552;

  <bb 2> :
  D.3552 = to_blob (key, blobp, lenp, 0);
  return D.3552;

}



;; Function to_blob (to_blob, funcdef_no=22, decl_uid=3477, cgraph_uid=23, symbol_order=22)

Merging blocks 12 and 13
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12
;; 2 succs { 3 4 }
;; 3 succs { 12 }
;; 4 succs { 5 6 }
;; 5 succs { 7 }
;; 6 succs { 7 }
;; 7 succs { 8 9 }
;; 8 succs { 9 }
;; 9 succs { 10 11 }
;; 10 succs { 11 }
;; 11 succs { 12 }
;; 12 succs { 1 }
int to_blob (const struct Key * key, u_char * * blobp, u_int * lenp, int force_plain)
{
  int type;
  int len;
  struct Buffer b;
  int iftmp.0;
  int D.3556;

  <bb 2> :
  if (key == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  error ("key_to_blob: key == NULL");
  D.3556 = 0;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 12>; [INV]

  <bb 4> :
  buffer_init (&b);
  if (force_plain != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  _1 = key->type;
  iftmp.0 = key_type_plain (_1);
  goto <bb 7>; [INV]

  <bb 6> :
  iftmp.0 = key->type;

  <bb 7> :
  type = iftmp.0;
  len = buffer_len (&b);
  if (lenp != 0B)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  len.1_2 = (unsigned int) len;
  *lenp = len.1_2;

  <bb 9> :
  if (blobp != 0B)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  _3 = (long unsigned int) len;
  _4 = malloc (_3);
  *blobp = _4;
  _5 = (long unsigned int) len;
  _6 = buffer_ptr (&b);
  _7 = (long int) _6;
  _8 = (const void *) _7;
  _9 = *blobp;
  memcpy (_9, _8, _5);

  <bb 11> :
  _10 = (long unsigned int) len;
  _11 = buffer_ptr (&b);
  _12 = (long int) _11;
  _13 = (void *) _12;
  memset (_13, 0, _10);
  buffer_free (&b);
  D.3556 = len;

  <bb 12> :
  b = {CLOBBER};
  return D.3556;

}



;; Function buffer_append (buffer_append, funcdef_no=24, decl_uid=3505, cgraph_uid=25, symbol_order=24)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
void buffer_append (struct Buffer * buffer, const void * data, u_int len)
{
  void * p;

  <bb 2> :
  _1 = buffer_append_space (buffer, len);
  _2 = (long int) _1;
  p = (void *) _2;
  _3 = (long unsigned int) len;
  memcpy (p, data, _3);
  return;

}



;; Function buffer_put_string (buffer_put_string, funcdef_no=25, decl_uid=3514, cgraph_uid=26, symbol_order=25)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
void buffer_put_string (struct Buffer * buffer, const void * buf, u_int len)
{
  <bb 2> :
  buffer_put_int (buffer, len);
  buffer_append (buffer, buf, len);
  return;

}



;; Function main (main, funcdef_no=27, decl_uid=3549, cgraph_uid=28, symbol_order=27)

Removing basic block 3
Merging blocks 2 and 4
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
int main ()
{
  int D.3567;

  <bb 2> :
  process_add ();
  D.3567 = 0;
  return D.3567;

}



;; Function process_add (process_add, funcdef_no=26, decl_uid=3519, cgraph_uid=27, symbol_order=26)

;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8
;;
;; Loop 1
;;  header 5, latch 4
;;  depth 1, outer 0
;;  nodes: 5 4
;; 2 succs { 3 7 }
;; 3 succs { 5 }
;; 4 succs { 5 }
;; 5 succs { 4 6 }
;; 6 succs { 8 }
;; 7 succs { 8 }
;; 8 succs { 1 }
void process_add ()
{
  struct Buffer msg;
  u_int blen;
  u_char * blob;
  int nkeys;
  int i;
  struct Key * * keys;
  char * pin;
  char * name;

  <bb 2> :
  buffer_init (&msg);
  _1 = get_string (0B);
  _2 = (long int) _1;
  name = (char *) _2;
  _3 = get_string (0B);
  _4 = (long int) _3;
  pin = (char *) _4;
  nkeys = pkcs11_add_provider (name, pin, &keys);
  if (nkeys > 0)
    goto <bb 3>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 3> :
  buffer_put_char (&msg, 12);
  buffer_put_int (&msg, nkeys);
  i = 0;
  goto <bb 5>; [INV]

  <bb 4> :
  keys.2_5 = keys;
  _6 = (long unsigned int) i;
  _7 = _6 * 8;
  _8 = keys.2_5 + _7;
  _9 = *_8;
  key_to_blob (_9, &blob, &blen);
  blen.3_10 = blen;
  blob.4_11 = blob;
  buffer_put_string (&msg, blob.4_11, blen.3_10);
  buffer_put_cstring (&msg, name);
  blob.5_12 = blob;
  *blob.5_12 = 1;
  blob.6_13 = blob;
  free (blob.6_13);
  keys.7_14 = keys;
  _15 = (long unsigned int) i;
  _16 = _15 * 8;
  _17 = keys.7_14 + _16;
  _18 = *_17;
  add_key (_18, name);
  i = i + 1;

  <bb 5> :
  if (i < nkeys)
    goto <bb 4>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 6> :
  keys.8_19 = keys;
  free (keys.8_19);
  goto <bb 8>; [INV]

  <bb 7> :
  buffer_put_char (&msg, 5);

  <bb 8> :
  free (pin);
  free (name);
  send_msg (&msg);
  buffer_free (&msg);
  keys = {CLOBBER};
  blob = {CLOBBER};
  blen = {CLOBBER};
  msg = {CLOBBER};
  return;

}


