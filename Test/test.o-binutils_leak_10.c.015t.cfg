
;; Function discard_cleanups (discard_cleanups, funcdef_no=22, decl_uid=3018, cgraph_uid=23, symbol_order=27)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
void discard_cleanups (struct cleanup * old_chain)
{
  <bb 2> :
  discard_my_cleanups (&cleanup_chain, old_chain);
  return;

}



;; Function discard_final_cleanups (discard_final_cleanups, funcdef_no=23, decl_uid=3023, cgraph_uid=24, symbol_order=28)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
void discard_final_cleanups (struct cleanup * old_chain)
{
  <bb 2> :
  discard_my_cleanups (&final_cleanup_chain, old_chain);
  return;

}



;; Function discard_my_cleanups (discard_my_cleanups, funcdef_no=24, decl_uid=3021, cgraph_uid=25, symbol_order=29)

;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7
;;
;; Loop 1
;;  header 6, latch 5
;;  depth 1, outer 0
;;  nodes: 6 5 3 4
;; 2 succs { 6 }
;; 3 succs { 4 5 }
;; 4 succs { 5 }
;; 5 succs { 6 }
;; 6 succs { 3 7 }
;; 7 succs { 1 }
void discard_my_cleanups (struct cleanup * * pmy_chain, struct cleanup * old_chain)
{
  struct cleanup * ptr;

  <bb 2> :
  goto <bb 6>; [INV]

  <bb 3> :
  _1 = ptr->next;
  *pmy_chain = _1;
  _2 = ptr->free_arg;
  if (_2 != 0B)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  _3 = ptr->free_arg;
  _4 = ptr->arg;
  _3 (_4);

  <bb 5> :
  free (ptr);

  <bb 6> :
  ptr = *pmy_chain;
  if (ptr != old_chain)
    goto <bb 3>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  _5 = ptr->arg;
  printf ("freearg: %x\n", _5);
  return;

}



;; Function do_cleanups (do_cleanups, funcdef_no=26, decl_uid=3028, cgraph_uid=27, symbol_order=31)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
void do_cleanups (struct cleanup * old_chain)
{
  <bb 2> :
  do_my_cleanups (&cleanup_chain, old_chain);
  return;

}



;; Function do_my_cleanups (do_my_cleanups, funcdef_no=25, decl_uid=3026, cgraph_uid=26, symbol_order=30)

;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7
;;
;; Loop 1
;;  header 6, latch 5
;;  depth 1, outer 0
;;  nodes: 6 5 3 4
;; 2 succs { 6 }
;; 3 succs { 4 5 }
;; 4 succs { 5 }
;; 5 succs { 6 }
;; 6 succs { 3 7 }
;; 7 succs { 1 }
void do_my_cleanups (struct cleanup * * pmy_chain, struct cleanup * old_chain)
{
  struct cleanup * ptr;

  <bb 2> :
  goto <bb 6>; [INV]

  <bb 3> :
  _1 = ptr->next;
  *pmy_chain = _1;
  _2 = ptr->function;
  _3 = ptr->arg;
  _2 (_3);
  __builtin_puts (&"cleanup!!!!! ========="[0]);
  _4 = ptr->arg;
  printf ("%x\n", _4);
  _5 = ptr->free_arg;
  if (_5 != 0B)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  _6 = ptr->free_arg;
  _7 = ptr->arg;
  _6 (_7);

  <bb 5> :
  free (ptr);

  <bb 6> :
  ptr = *pmy_chain;
  if (ptr != old_chain)
    goto <bb 3>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  return;

}



;; Function make_cleanup (make_cleanup, funcdef_no=29, decl_uid=3041, cgraph_uid=30, symbol_order=34)

Merging blocks 2 and 3
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
struct cleanup * make_cleanup (void (*<T59c>) (void *) function, void * arg)
{
  struct cleanup * D.3183;

  <bb 2> :
  D.3183 = make_my_cleanup (&cleanup_chain, function, arg);
  return D.3183;

}



;; Function make_my_cleanup (make_my_cleanup, funcdef_no=28, decl_uid=3038, cgraph_uid=29, symbol_order=33)

Merging blocks 2 and 3
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
struct cleanup * make_my_cleanup (struct cleanup * * pmy_chain, void (*<T59c>) (void *) function, void * arg)
{
  struct cleanup * D.3185;

  <bb 2> :
  D.3185 = make_my_cleanup2 (pmy_chain, function, arg, 0B);
  return D.3185;

}



;; Function make_my_cleanup2 (make_my_cleanup2, funcdef_no=27, decl_uid=3034, cgraph_uid=28, symbol_order=32)

Merging blocks 4 and 5
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4
;; 2 succs { 3 4 }
;; 3 succs { }
;; 4 succs { 1 }
struct cleanup * make_my_cleanup2 (struct cleanup * * pmy_chain, void (*<T59c>) (void *) function, void * arg, void (*<Tee>) (void *) free_arg)
{
  struct cleanup * old_chain;
  struct cleanup * new;
  struct cleanup * D.3189;

  <bb 2> :
  new = malloc (32);
  old_chain = *pmy_chain;
  _1 = *pmy_chain;
  new->next = _1;
  new->function = function;
  new->free_arg = free_arg;
  new->arg = arg;
  *pmy_chain = new;
  if (old_chain == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  exit (1);

  <bb 4> :
  D.3189 = old_chain;
  return D.3189;

}



;; Function newentry (newentry, funcdef_no=30, decl_uid=3103, cgraph_uid=31, symbol_order=37)

Merging blocks 2 and 3
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
struct dict_type * newentry (char * word)
{
  struct dict_type * new_d;
  struct dict_type * D.3191;

  <bb 2> :
  new_d = malloc (40);
  new_d->word = word;
  root.0_1 = root;
  new_d->next = root.0_1;
  root = new_d;
  _2 = malloc (8);
  new_d->code = _2;
  new_d->code_length = 1;
  new_d->code_end = 0;
  D.3191 = new_d;
  return D.3191;

}



;; Function add_var (add_var, funcdef_no=31, decl_uid=3106, cgraph_uid=32, symbol_order=38)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
void add_var (char * name)
{
  struct dict_type * new_d;

  <bb 2> :
  new_d = newentry (name);
  return;

}



;; Function add_to_definition (add_to_definition, funcdef_no=32, decl_uid=3110, cgraph_uid=33, symbol_order=39)

Merging blocks 4 and 5
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4
;; 2 succs { 3 4 }
;; 3 succs { 4 }
;; 4 succs { 1 }
unsigned int add_to_definition (struct dict_type * entry, void (*stinst_type) () word)
{
  unsigned int D.3195;

  <bb 2> :
  _1 = entry->code_end;
  _2 = entry->code_length;
  if (_1 == _2)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  _3 = entry->code_length;
  _4 = _3 + 2;
  entry->code_length = _4;
  _5 = entry->code_length;
  _6 = (long unsigned int) _5;
  _7 = _6 * 8;
  _8 = entry->code;
  _9 = realloc (_8, _7);
  entry->code = _9;

  <bb 4> :
  _10 = entry->code;
  _11 = entry->code_end;
  _12 = (long unsigned int) _11;
  _13 = _12 * 8;
  _14 = _10 + _13;
  *_14 = word;
  _15 = entry->code_end;
  _16 = _15;
  _17 = _16 + 1;
  entry->code_end = _17;
  D.3195 = (unsigned int) _16;
  return D.3195;

}



;; Function nextword (nextword, funcdef_no=33, decl_uid=3114, cgraph_uid=34, symbol_order=40)

Removing basic block 4
Removing basic block 6
Removing basic block 9
Removing basic block 19
Removing basic block 20
Removing basic block 29
;; 6 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30
;;
;; Loop 4
;;  header 26, latch 25
;;  depth 1, outer 0
;;  nodes: 26 25 22 24 21 23 20 19
;;
;; Loop 3
;;  header 13, latch 15
;;  depth 1, outer 0
;;  nodes: 13 15 14
;;
;; Loop 2
;;  header 17, latch 16
;;  depth 1, outer 0
;;  nodes: 17 16
;;
;; Loop 1
;;  header 8, multiple latches: 6 7
;;  depth 1, outer 0
;;  nodes: 8 6 7 4 9 5
;;
;; Loop 5
;;  header 6, latch 5
;;  depth 2, outer 1
;;  nodes: 6 5
;; 2 succs { 3 8 }
;; 3 succs { 30 }
;; 4 succs { 6 7 }
;; 5 succs { 6 }
;; 6 succs { 5 8 }
;; 7 succs { 8 }
;; 8 succs { 4 9 }
;; 9 succs { 4 10 }
;; 10 succs { 11 12 }
;; 11 succs { 30 }
;; 12 succs { 13 17 }
;; 13 succs { 14 15 }
;; 14 succs { 15 }
;; 15 succs { 13 18 }
;; 16 succs { 17 }
;; 17 succs { 16 18 }
;; 18 succs { 26 }
;; 19 succs { 20 24 }
;; 20 succs { 23 22 21 }
;; 21 succs { 25 }
;; 22 succs { 25 }
;; 23 succs { 25 }
;; 24 succs { 25 }
;; 25 succs { 26 }
;; 26 succs { 19 27 }
;; 27 succs { 28 29 }
;; 28 succs { 30 }
;; 29 succs { 30 }
;; 30 succs { 1 }
char * nextword (char * string, char * * word)
{
  int length;
  char * src;
  char * dst;
  int idx;
  char * word_start;
  char D.3202;
  char * D.3199;

  <bb 2> :
  length = 0;
  if (string == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 3> :
  D.3199 = 0B;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 30>; [INV]

  <bb 4> :
  _1 = *string;
  if (_1 == 45)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 5> :
  string = string + 1;

  <bb 6> :
  D.3202 = *string;
  _2 = D.3202 != 0;
  _3 = D.3202 != 10;
  _4 = _2 & _3;
  if (_4 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  string = string + 1;

  <bb 8> :
  _5 = *string;
  _6 = (unsigned char) _5;
  _7 = (int) _6;
  _8 = isspace (_7);
  if (_8 != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 9> :
  _9 = *string;
  if (_9 == 45)
    goto <bb 4>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 10> :
  _10 = *string;
  if (_10 == 0)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  D.3199 = 0B;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 30>; [INV]

  <bb 12> :
  word_start = string;
  _11 = *string;
  if (_11 == 34)
    goto <bb 13>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 13> :
  string = string + 1;
  length = length + 1;
  _12 = *string;
  if (_12 == 92)
    goto <bb 14>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 14> :
  string = string + 2;
  length = length + 2;

  <bb 15> :
  _13 = *string;
  if (_13 != 34)
    goto <bb 13>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 16> :
  string = string + 1;
  length = length + 1;

  <bb 17> :
  _14 = *string;
  _15 = (unsigned char) _14;
  _16 = (int) _15;
  _17 = isspace (_16);
  if (_17 == 0)
    goto <bb 16>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 18> :
  _18 = length + 1;
  _19 = (long unsigned int) _18;
  _20 = malloc (_19);
  *word = _20;
  dst = *word;
  src = word_start;
  idx = 0;
  goto <bb 26>; [INV]

  <bb 19> :
  _21 = (sizetype) idx;
  _22 = src + _21;
  _23 = *_22;
  if (_23 == 92)
    goto <bb 20>; [INV]
  else
    goto <bb 24>; [INV]

  <bb 20> :
  _24 = (sizetype) idx;
  _25 = _24 + 1;
  _26 = src + _25;
  _27 = *_26;
  _28 = (int) _27;
  switch (_28) <default: <L29> [INV], case 34: <L27> [INV], case 92: <L27> [INV], case 110: <L26> [INV]>

  <bb 21> :
<L26>:
  dst.1_29 = dst;
  dst = dst.1_29 + 1;
  *dst.1_29 = 10;
  idx = idx + 1;
  goto <bb 25>; [INV]

  <bb 22> :
<L27>:
  _30 = (sizetype) idx;
  _31 = _30 + 1;
  _32 = src + _31;
  dst.2_33 = dst;
  dst = dst.2_33 + 1;
  _34 = *_32;
  *dst.2_33 = _34;
  idx = idx + 1;
  goto <bb 25>; [INV]

  <bb 23> :
<L29>:
  dst.3_35 = dst;
  dst = dst.3_35 + 1;
  *dst.3_35 = 92;
  goto <bb 25>; [INV]

  <bb 24> :
  _36 = (sizetype) idx;
  _37 = src + _36;
  dst.4_38 = dst;
  dst = dst.4_38 + 1;
  _39 = *_37;
  *dst.4_38 = _39;

  <bb 25> :
  idx = idx + 1;

  <bb 26> :
  if (idx < length)
    goto <bb 19>; [INV]
  else
    goto <bb 27>; [INV]

  <bb 27> :
  dst.5_40 = dst;
  dst = dst.5_40 + 1;
  *dst.5_40 = 0;
  _41 = *string;
  if (_41 != 0)
    goto <bb 28>; [INV]
  else
    goto <bb 29>; [INV]

  <bb 28> :
  D.3199 = string + 1;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 30>; [INV]

  <bb 29> :
  D.3199 = 0B;
  // predicted unlikely by early return (on trees) predictor.

  <bb 30> :
  return D.3199;

}



;; Function compile (compile, funcdef_no=34, decl_uid=3147, cgraph_uid=35, symbol_order=41)

;; 3 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18
;;
;; Loop 1
;;  header 15, multiple latches: 4 13 14
;;  depth 1, outer 0
;;  nodes: 15 4 13 14 5 3 17 16 11 12 6 8 9 10 7
;;
;; Loop 2
;;  header 12, latch 11
;;  depth 2, outer 1
;;  nodes: 12 11 8 9 10 7
;; 2 succs { 15 }
;; 3 succs { 4 5 }
;; 4 succs { 15 }
;; 5 succs { 6 14 }
;; 6 succs { 12 }
;; 7 succs { 10 8 9 }
;; 8 succs { 11 }
;; 9 succs { 11 }
;; 10 succs { 11 }
;; 11 succs { 13 12 }
;; 12 succs { 7 13 }
;; 13 succs { 15 }
;; 14 succs { 15 }
;; 15 succs { 16 18 }
;; 16 succs { 17 18 }
;; 17 succs { 3 18 }
;; 18 succs { 1 }
void compile (char * string)
{
  struct dict_type * ptr;
  char * word;

  <bb 2> :
  string = nextword (string, &word);
  goto <bb 15>; [INV]

  <bb 3> :
  printf ("string: %s\n", string);
  word.6_1 = word;
  _2 = strcmp (word.6_1, "var");
  if (_2 == 0)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  string = nextword (string, &word);
  word.7_3 = word;
  add_var (word.7_3);
  string = nextword (string, &word);
  goto <bb 15>; [INV]

  <bb 5> :
  word.8_4 = word;
  _5 = *word.8_4;
  if (_5 == 58)
    goto <bb 6>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 6> :
  word.9_6 = word;
  free (word.9_6);
  string = nextword (string, &word);
  word.10_7 = word;
  ptr = newentry (word.10_7);
  string = nextword (string, &word);
  goto <bb 12>; [INV]

  <bb 7> :
  word.11_8 = word;
  _9 = *word.11_8;
  _10 = (int) _9;
  switch (_10) <default: <L16> [INV], case 34: <L5> [INV], case 48 ... 57: <L6> [INV]>

  <bb 8> :
<L5>:
  word.12_11 = word;
  _12 = word.12_11 + 1;
  _13 = (void (*<T1f8>) ()) _12;
  add_to_definition (ptr, _13);
  goto <bb 11>; [INV]

  <bb 9> :
<L6>:
  _14 = MEM[(int *)ptr];
  printf ("%d\n", _14);
  word.13_15 = word;
  free (word.13_15);
  goto <bb 11>; [INV]

  <bb 10> :
<L16>:
  _16 = MEM[(int *)ptr];
  printf ("%d\n", _16);
  word.14_17 = word;
  free (word.14_17);

  <bb 11> :
  string = nextword (string, &word);
  if (string == 0B)
    goto <bb 13>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 12> :
  word.15_18 = word;
  _19 = *word.15_18;
  if (_19 != 59)
    goto <bb 7>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 13> :
  _20 = MEM[(int *)ptr];
  printf ("%d\n", _20);
  string = nextword (string, &word);
  goto <bb 15>; [INV]

  <bb 14> :
  _21 = string + 18446744073709551615;
  stderr.16_22 = stderr;
  fprintf (stderr.16_22, "syntax error at %s\n", _21);

  <bb 15> :
  if (string != 0B)
    goto <bb 16>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 16> :
  _23 = *string;
  if (_23 != 0)
    goto <bb 17>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 17> :
  word.17_24 = word;
  _25 = *word.17_24;
  if (_25 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 18> :
  word = {CLOBBER};
  return;

}



;; Function main (main, funcdef_no=35, decl_uid=3171, cgraph_uid=36, symbol_order=42)

Merging blocks 5 and 6
;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5
;;
;; Loop 1
;;  header 4, latch 3
;;  depth 1, outer 0
;;  nodes: 4 3
;; 2 succs { 4 }
;; 3 succs { 4 }
;; 4 succs { 3 5 }
;; 5 succs { 1 }
int main ()
{
  char * string;
  struct dict_type * dict;
  int D.3227;

  <bb 2> :
  string = "var second : stored_in_dict 5 ; : next";
  compile (string);
  dict = root;
  goto <bb 4>; [INV]

  <bb 3> :
  _1 = dict->word;
  __builtin_puts (_1);
  _2 = dict->word;
  free (_2);
  dict = dict->next;

  <bb 4> :
  if (dict != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 5> :
  D.3227 = 0;
  return D.3227;

}


