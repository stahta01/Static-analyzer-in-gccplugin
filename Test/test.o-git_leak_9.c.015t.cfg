
;; Function xrealloc (xrealloc, funcdef_no=26, decl_uid=3274, cgraph_uid=27, symbol_order=27)

Merging blocks 9 and 10
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9
;; 2 succs { 3 4 }
;; 3 succs { 4 }
;; 4 succs { 5 9 }
;; 5 succs { 6 7 }
;; 6 succs { 7 }
;; 7 succs { 8 9 }
;; 8 succs { }
;; 9 succs { 1 }
void * xrealloc (void * ptr, size_t size)
{
  void * ret;
  void * D.3466;

  <bb 2> :
  ret = realloc (ptr, size);
  _1 = ret == 0B;
  _2 = size == 0;
  _3 = _1 & _2;
  if (_3 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  ret = realloc (ptr, 1);

  <bb 4> :
  if (ret == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 5> :
  ret = realloc (ptr, size);
  _4 = ret == 0B;
  _5 = size == 0;
  _6 = _4 & _5;
  if (_6 != 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  ret = realloc (ptr, 1);

  <bb 7> :
  if (ret == 0B)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  printf ("Out of memory, realloc failed%s", "");
  exit (1);

  <bb 9> :
  D.3466 = ret;
  return D.3466;

}



;; Function strbuf_grow (strbuf_grow, funcdef_no=27, decl_uid=3311, cgraph_uid=28, symbol_order=28)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14
;; 2 succs { 4 3 }
;; 3 succs { 4 5 }
;; 4 succs { }
;; 5 succs { 6 7 }
;; 6 succs { 7 }
;; 7 succs { 8 12 }
;; 8 succs { 9 10 }
;; 9 succs { 11 }
;; 10 succs { 11 }
;; 11 succs { 12 }
;; 12 succs { 13 14 }
;; 13 succs { 14 }
;; 14 succs { 1 }
void strbuf_grow (struct strbuf * sb, size_t extra)
{
  int new_buf;

  <bb 2> :
  _1 = sb->alloc;
  _2 = _1 == 0;
  new_buf = (int) _2;
  _3 = unsigned_add_overflows (extra, 1);
  if (_3 != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 3>; [INV]

  <bb 3> :
  _4 = extra + 1;
  _5 = sb->len;
  _6 = unsigned_add_overflows (_5, _4);
  if (_6 != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  printf ("you want to use way too much memory%s", "");
  exit (1);

  <bb 5> :
  if (new_buf != 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  sb->buf = 0B;

  <bb 7> :
  _7 = sb->len;
  _8 = extra + _7;
  _9 = _8 + 1;
  _10 = sb->alloc;
  if (_9 > _10)
    goto <bb 8>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 8> :
  _11 = sb->alloc;
  _12 = alloc_nr (_11);
  _13 = (long unsigned int) _12;
  _14 = sb->len;
  _15 = extra + _14;
  _16 = _15 + 1;
  if (_13 < _16)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  _17 = sb->len;
  _18 = extra + _17;
  _19 = _18 + 1;
  sb->alloc = _19;
  goto <bb 11>; [INV]

  <bb 10> :
  _20 = sb->alloc;
  _21 = alloc_nr (_20);
  _22 = (long unsigned int) _21;
  sb->alloc = _22;

  <bb 11> :
  _23 = sb->alloc;
  _24 = st_mult (1, _23);
  _25 = (long unsigned int) _24;
  _26 = sb->buf;
  _27 = xrealloc (_26, _25);
  sb->buf = _27;

  <bb 12> :
  if (new_buf != 0)
    goto <bb 13>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 13> :
  _28 = sb->buf;
  *_28 = 0;

  <bb 14> :
  return;

}



;; Function strbuf_release (strbuf_release, funcdef_no=28, decl_uid=3322, cgraph_uid=29, symbol_order=29)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4
;; 2 succs { 3 4 }
;; 3 succs { 4 }
;; 4 succs { 1 }
void strbuf_release (struct strbuf * sb)
{
  <bb 2> :
  _1 = sb->alloc;
  if (_1 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  _2 = sb->buf;
  free (_2);
  strbuf_init (sb, 0);

  <bb 4> :
  return;

}



;; Function strbuf_readlink (strbuf_readlink, funcdef_no=29, decl_uid=3329, cgraph_uid=30, symbol_order=30)

Removing basic block 4
Removing basic block 7
;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13
;;
;; Loop 1
;;  header 9, latch 8
;;  depth 1, outer 0
;;  nodes: 9 8 5 6 4
;; 2 succs { 3 9 }
;; 3 succs { 9 }
;; 4 succs { 5 6 }
;; 5 succs { 10 8 }
;; 6 succs { 7 8 }
;; 7 succs { 13 }
;; 8 succs { 9 }
;; 9 succs { 4 10 }
;; 10 succs { 11 12 }
;; 11 succs { 12 }
;; 12 succs { 13 }
;; 13 succs { 1 }
int strbuf_readlink (struct strbuf * sb, const char * path, size_t hint)
{
  int len;
  size_t oldalloc;
  int D.3490;

  <bb 2> :
  oldalloc = sb->alloc;
  if (hint <= 31)
    goto <bb 3>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 3> :
  hint = 32;
  goto <bb 9>; [INV]

  <bb 4> :
  strbuf_grow (sb, hint);
  _1 = sb->buf;
  len = readlink (path, _1, hint);
  if (len < 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  _2 = __errno_location ();
  _3 = *_2;
  if (_3 != 34)
    goto <bb 10>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 6> :
  _4 = (long unsigned int) len;
  if (hint > _4)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  strbuf_setlen (sb, len);
  D.3490 = 0;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 13>; [INV]

  <bb 8> :
  hint = hint * 2;

  <bb 9> :
  if (hint <= 8191)
    goto <bb 4>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 10> :
  if (oldalloc == 0)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  strbuf_release (sb);

  <bb 12> :
  D.3490 = -1;

  <bb 13> :
  return D.3490;

}



;; Function main (main, funcdef_no=33, decl_uid=3449, cgraph_uid=34, symbol_order=34)

Removing basic block 4
Merging blocks 2 and 3
Merging blocks 2 and 5
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
int main ()
{
  struct strbuf err;
  struct string_list affected_refnames;
  char * head_ref;
  struct ref_transaction transaction;
  struct ref_update update;
  struct files_ref_store refs;
  int D.3494;

  <bb 2> :
  lock_ref_for_update (&refs, &update, &transaction, head_ref, &affected_refnames, &err);
  D.3494 = 0;
  refs = {CLOBBER};
  update = {CLOBBER};
  transaction = {CLOBBER};
  affected_refnames = {CLOBBER};
  err = {CLOBBER};
  return D.3494;

}



;; Function lock_ref_for_update (lock_ref_for_update, funcdef_no=32, decl_uid=3417, cgraph_uid=33, symbol_order=33)

Removing basic block 12
Removing basic block 15
Removing basic block 18
Removing basic block 24
Merging blocks 32 and 33
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28
;; 2 succs { 3 5 }
;; 3 succs { 4 5 }
;; 4 succs { 28 }
;; 5 succs { 6 7 }
;; 6 succs { 28 }
;; 7 succs { 8 16 }
;; 8 succs { 9 14 }
;; 9 succs { 10 12 }
;; 10 succs { 11 18 }
;; 11 succs { 28 }
;; 12 succs { 13 18 }
;; 13 succs { 28 }
;; 14 succs { 15 18 }
;; 15 succs { 28 }
;; 16 succs { 17 18 }
;; 17 succs { 28 }
;; 18 succs { 19 24 }
;; 19 succs { 20 21 }
;; 20 succs { 24 21 }
;; 21 succs { 22 23 }
;; 22 succs { 28 }
;; 23 succs { 24 }
;; 24 succs { 25 27 }
;; 25 succs { 26 27 }
;; 26 succs { 28 }
;; 27 succs { 28 }
;; 28 succs { 1 }
int lock_ref_for_update (struct files_ref_store * refs, struct ref_update * update, struct ref_transaction * transaction, const char * head_ref, struct string_list * affected_refnames, struct strbuf * err)
{
  char * write_err;
  struct ref_update * parent_update;
  char * reason;
  struct ref_lock * lock;
  int ret;
  int mustexist;
  struct strbuf referent;
  int D.3501;

  <bb 2> :
  referent.alloc = 0;
  referent.len = 0;
  referent.buf = &strbuf_slopbuf;
  if (head_ref != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 3> :
  ret = split_head_update (update, transaction, head_ref, affected_refnames, err);
  if (ret != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  D.3501 = ret;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 28>; [INV]

  <bb 5> :
  _1 = &update->type;
  _2 = &update->refname;
  ret = lock_raw_ref (refs, _2, mustexist, affected_refnames, 0B, &lock, &referent, _1, err);
  if (ret != 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  _3 = strbuf_detach (err, 0B);
  _4 = (long int) _3;
  reason = (char *) _4;
  _5 = original_update_refname (update);
  strbuf_addf (err, "cannot lock ref \'%s\': %s", _5, reason);
  free (reason);
  D.3501 = ret;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 28>; [INV]

  <bb 7> :
  lock.0_6 = lock;
  update->backend_data = lock.0_6;
  _7 = update->type;
  _8 = _7 & 1;
  if (_8 != 0)
    goto <bb 8>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 8> :
  _9 = update->flags;
  _10 = _9 & 1;
  if (_10 != 0)
    goto <bb 9>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 9> :
  lock.1_11 = lock;
  _12 = &lock.1_11->old_oid.hash;
  _13 = referent.buf;
  _14 = &refs->base;
  _15 = refs_read_ref_full (_14, _13, 0, _12, 0B);
  if (_15 != 0)
    goto <bb 10>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 10> :
  _16 = update->flags;
  _17 = _16 & 16;
  if (_17 != 0)
    goto <bb 11>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 11> :
  _18 = original_update_refname (update);
  strbuf_addf (err, "cannot lock ref \'%s\': error reading reference", _18);
  D.3501 = -1;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 28>; [INV]

  <bb 12> :
  lock.2_19 = lock;
  _20 = &lock.2_19->old_oid;
  _21 = check_old_oid (update, _20, err);
  if (_21 != 0)
    goto <bb 13>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 13> :
  D.3501 = -2;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 28>; [INV]

  <bb 14> :
  _22 = referent.buf;
  ret = split_symref_update (refs, update, _22, transaction, affected_refnames, err);
  if (ret != 0)
    goto <bb 15>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 15> :
  D.3501 = ret;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 28>; [INV]

  <bb 16> :
  lock.3_23 = lock;
  _24 = &lock.3_23->old_oid;
  _25 = check_old_oid (update, _24, err);
  if (_25 != 0)
    goto <bb 17>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 17> :
  D.3501 = -2;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 28>; [INV]

  <bb 18> :
  _26 = BIT_FIELD_REF <*update, 32, 320>;
  _27 = _26 & 138;
  if (_27 == 8)
    goto <bb 19>; [INV]
  else
    goto <bb 24>; [INV]

  <bb 19> :
  _28 = update->type;
  _29 = _28 & 1;
  if (_29 == 0)
    goto <bb 20>; [INV]
  else
    goto <bb 21>; [INV]

  <bb 20> :
  _30 = &update->new_oid;
  lock.4_31 = lock;
  _32 = &lock.4_31->old_oid;
  _33 = oidcmp (_32, _30);
  if (_33 == 0)
    goto <bb 24>; [INV]
  else
    goto <bb 21>; [INV]

  <bb 21> :
  _34 = &update->new_oid;
  lock.5_35 = lock;
  _36 = write_ref_to_lockfile (lock.5_35, _34, err);
  if (_36 != 0)
    goto <bb 22>; [INV]
  else
    goto <bb 23>; [INV]

  <bb 22> :
  _37 = strbuf_detach (err, 0B);
  _38 = (long int) _37;
  write_err = (char *) _38;
  update->backend_data = 0B;
  D.3501 = -2;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 28>; [INV]

  <bb 23> :
  _39 = update->flags;
  _40 = _39 | 32;
  update->flags = _40;

  <bb 24> :
  _41 = update->flags;
  _42 = _41 & 32;
  if (_42 == 0)
    goto <bb 25>; [INV]
  else
    goto <bb 27>; [INV]

  <bb 25> :
  lock.6_43 = lock;
  _44 = close_ref (lock.6_43);
  if (_44 != 0)
    goto <bb 26>; [INV]
  else
    goto <bb 27>; [INV]

  <bb 26> :
  D.3501 = -2;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 28>; [INV]

  <bb 27> :
  D.3501 = 0;

  <bb 28> :
  referent = {CLOBBER};
  lock = {CLOBBER};
  return D.3501;

}



;; Function lock_raw_ref (lock_raw_ref, funcdef_no=31, decl_uid=3397, cgraph_uid=32, symbol_order=32)

Merging blocks 5 and 7
Merging blocks 8 and 9
Merging blocks 8 and 10
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7
;; 2 succs { 3 6 }
;; 3 succs { 4 6 }
;; 4 succs { 5 6 }
;; 5 succs { 7 }
;; 6 succs { 7 }
;; 7 succs { 1 }
int lock_raw_ref (struct files_ref_store * refs, const char * refname, int mustexist, const struct string_list * extras, const struct string_list * skip, struct ref_lock * * lock_p, struct strbuf * referent, unsigned int * type, struct strbuf * err)
{
  int ret;
  int attempts_remaining;
  struct strbuf ref_file;
  struct ref_lock * lock;
  int D.3541;

  <bb 2> :
  ref_file.alloc = 0;
  ref_file.len = 0;
  ref_file.buf = &strbuf_slopbuf;
  attempts_remaining = 3;
  ret = -2;
  *type = 0;
  lock = calloc (1, 40);
  *lock_p = lock;
  _1 = strdup (refname);
  lock->ref_name = _1;
  files_ref_path (refs, &ref_file, refname);
  _2 = &lock->old_oid.hash;
  _3 = &refs->base;
  _4 = files_read_raw_ref (_3, refname, _2, referent, type);
  if (_4 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 3> :
  _5 = __errno_location ();
  _6 = *_5;
  if (_6 == 2)
    goto <bb 4>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 4> :
  if (mustexist != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  strbuf_addf (err, "unable to resolve reference \'%s\'", refname);
  // predicted unlikely by goto predictor.
  unlock_ref (lock);
  *lock_p = 0B;
  goto <bb 7>; [INV]

  <bb 6> :
  ret = 0;
  // predicted unlikely by goto predictor.

  <bb 7> :
out:
  strbuf_release (&ref_file);
  D.3541 = ret;
  ref_file = {CLOBBER};
  return D.3541;

}



;; Function files_read_raw_ref (files_read_raw_ref, funcdef_no=30, decl_uid=3345, cgraph_uid=31, symbol_order=31)

Merging blocks 30 and 31
Merging blocks 30 and 32
;; 3 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30
;;
;; Loop 2
;;  header 23, latch 22
;;  depth 1, outer 0
;;  nodes: 23 22
;;
;; Loop 1
;;  header 3, latch 13
;;  depth 1, outer 0
;;  nodes: 3 13 12 11 5
;; 2 succs { 3 }
;; 3 succs { 4 5 }
;; 4 succs { 30 }
;; 5 succs { 6 11 }
;; 6 succs { 7 8 }
;; 7 succs { 30 }
;; 8 succs { 9 10 }
;; 9 succs { 30 }
;; 10 succs { 30 }
;; 11 succs { 12 15 }
;; 12 succs { 13 14 }
;; 13 succs { 3 }
;; 14 succs { 30 }
;; 15 succs { 16 18 }
;; 16 succs { 17 18 }
;; 17 succs { 30 }
;; 18 succs { 19 20 }
;; 19 succs { 30 }
;; 20 succs { 21 25 }
;; 21 succs { 23 }
;; 22 succs { 23 }
;; 23 succs { 22 24 }
;; 24 succs { 30 }
;; 25 succs { 28 26 }
;; 26 succs { 27 29 }
;; 27 succs { 28 29 }
;; 28 succs { 30 }
;; 29 succs { 30 }
;; 30 succs { 1 }
int files_read_raw_ref (struct ref_store * ref_store, const char * refname, unsigned char * sha1, struct strbuf * referent, unsigned int * type)
{
  int save_errno;
  struct stat st;
  int remaining_retries;
  int save_errno;
  int ret;
  int fd;
  const char * buf;
  const char * path;
  struct strbuf sb_path;
  struct strbuf sb_contents;
  struct files_ref_store * refs;
  int D.3569;
  int D.3554;

  <bb 2> :
  _1 = files_downcast (ref_store, 1, "read_raw_ref");
  _2 = (long int) _1;
  refs = (struct files_ref_store *) _2;
  sb_contents.alloc = 0;
  sb_contents.len = 0;
  sb_contents.buf = &strbuf_slopbuf;
  sb_path.alloc = 0;
  sb_path.len = 0;
  sb_path.buf = &strbuf_slopbuf;
  ret = -1;
  remaining_retries = 3;
  *type = 0;
  strbuf_reset (&sb_path);
  files_ref_path (refs, &sb_path, refname);
  path = sb_path.buf;

  <bb 3> :
stat_ref:
  remaining_retries.7_3 = remaining_retries;
  remaining_retries = remaining_retries.7_3 + -1;
  if (remaining_retries.7_3 <= 0)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  // predicted unlikely by goto predictor.
  goto <bb 30>; [INV]

  <bb 5> :
  _4 = lstat (path, &st);
  if (_4 < 0)
    goto <bb 6>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 6> :
  _5 = __errno_location ();
  _6 = *_5;
  if (_6 != 2)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  // predicted unlikely by goto predictor.
  goto <bb 30>; [INV]

  <bb 8> :
  _7 = resolve_packed_ref (refs, refname, sha1, type);
  if (_7 != 0)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  _8 = __errno_location ();
  *_8 = 2;
  // predicted unlikely by goto predictor.
  goto <bb 30>; [INV]

  <bb 10> :
  ret = 0;
  // predicted unlikely by goto predictor.
  goto <bb 30>; [INV]

  <bb 11> :
  strbuf_reset (&sb_contents);
  _9 = strbuf_readlink (&sb_contents, path, 0);
  if (_9 < 0)
    goto <bb 12>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 12> :
  _10 = __errno_location ();
  D.3554 = *_10;
  _11 = D.3554 == 2;
  _12 = D.3554 == 22;
  _13 = _11 | _12;
  if (_13 != 0)
    goto <bb 13>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 13> :
  // predicted unlikely by goto predictor.
  goto <bb 3>; [INV]

  <bb 14> :
  // predicted unlikely by goto predictor.
  goto <bb 30>; [INV]

  <bb 15> :
  _14 = sb_contents.buf;
  _15 = starts_with (_14, "refs/");
  if (_15 != 0)
    goto <bb 16>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 16> :
  _16 = sb_contents.buf;
  _17 = check_refname_format (_16, 0);
  if (_17 == 0)
    goto <bb 17>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 17> :
  strbuf_swap (&sb_contents, referent);
  _18 = *type;
  _19 = _18 | 1;
  *type = _19;
  ret = 0;
  // predicted unlikely by goto predictor.
  goto <bb 30>; [INV]

  <bb 18> :
  strbuf_reset (&sb_contents);
  _20 = strbuf_read (&sb_contents, fd, 256);
  if (_20 < 0)
    goto <bb 19>; [INV]
  else
    goto <bb 20>; [INV]

  <bb 19> :
  _21 = __errno_location ();
  save_errno = *_21;
  close (fd);
  _22 = __errno_location ();
  *_22 = save_errno;
  // predicted unlikely by goto predictor.
  goto <bb 30>; [INV]

  <bb 20> :
  strbuf_rtrim (&sb_contents);
  buf = sb_contents.buf;
  _23 = starts_with (buf, "ref:");
  if (_23 != 0)
    goto <bb 21>; [INV]
  else
    goto <bb 25>; [INV]

  <bb 21> :
  buf = buf + 4;
  goto <bb 23>; [INV]

  <bb 22> :
  buf = buf + 1;

  <bb 23> :
  _24 = *buf;
  _25 = (int) _24;
  _26 = isspace (_25);
  if (_26 != 0)
    goto <bb 22>; [INV]
  else
    goto <bb 24>; [INV]

  <bb 24> :
  strbuf_reset (referent);
  strbuf_addstr (referent, buf);
  _27 = *type;
  _28 = _27 | 1;
  *type = _28;
  ret = 0;
  // predicted unlikely by goto predictor.
  goto <bb 30>; [INV]

  <bb 25> :
  _29 = get_sha1_hex (buf, sha1);
  if (_29 != 0)
    goto <bb 28>; [INV]
  else
    goto <bb 26>; [INV]

  <bb 26> :
  _30 = buf + 40;
  _31 = *_30;
  if (_31 != 0)
    goto <bb 27>; [INV]
  else
    goto <bb 29>; [INV]

  <bb 27> :
  _32 = buf + 40;
  _33 = *_32;
  _34 = (int) _33;
  _35 = isspace (_34);
  if (_35 == 0)
    goto <bb 28>; [INV]
  else
    goto <bb 29>; [INV]

  <bb 28> :
  _36 = *type;
  _37 = _36 | 4;
  *type = _37;
  _38 = __errno_location ();
  *_38 = 22;
  // predicted unlikely by goto predictor.
  goto <bb 30>; [INV]

  <bb 29> :
  ret = 0;

  <bb 30> :
out:
  _39 = __errno_location ();
  save_errno = *_39;
  strbuf_release (&sb_path);
  strbuf_release (&sb_contents);
  _40 = __errno_location ();
  *_40 = save_errno;
  D.3569 = ret;
  sb_contents = {CLOBBER};
  sb_path = {CLOBBER};
  st = {CLOBBER};
  return D.3569;

}



;; Function strbuf_swap (strbuf_swap, funcdef_no=25, decl_uid=3264, cgraph_uid=26, symbol_order=26)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
void strbuf_swap (struct strbuf * a, struct strbuf * b)
{
  unsigned char _swap_buffer[24];
  void * _swap_b_ptr;
  void * _swap_a_ptr;

  <bb 2> :
  _swap_a_ptr = a;
  _swap_b_ptr = b;
  MEM <unsigned char[24]> [(char * {ref-all})&_swap_buffer] = MEM <unsigned char[24]> [(char * {ref-all})_swap_a_ptr];
  memcpy (_swap_a_ptr, _swap_b_ptr, 24);
  MEM <unsigned char[24]> [(char * {ref-all})_swap_b_ptr] = MEM <unsigned char[24]> [(char * {ref-all})&_swap_buffer];
  _swap_buffer = {CLOBBER};
  return;

}


