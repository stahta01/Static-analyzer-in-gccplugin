
;; Function printf (printf, funcdef_no=31, decl_uid=798, cgraph_uid=31, symbol_order=31)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
__fmt = &PARM_NOALIAS(9)
PARM_NOALIAS(9) = &NONLOCAL
ESCAPED = &NONLOCAL
ESCAPED = __fmt
_4 = NONLOCAL
ESCAPED = _4

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { ESCAPED NONLOCAL PARM_NOALIAS(9) }
NONLOCAL = { ESCAPED NONLOCAL } same as _4
STOREDANYTHING = { }
INTEGER = { ANYTHING }
__fmt = { PARM_NOALIAS(9) }
PARM_NOALIAS(9) = { ESCAPED NONLOCAL }
__printf_chk = { }
_4 = { ESCAPED NONLOCAL }


Alias information for printf

Aliased symbols


Call clobber information

ESCAPED, points-to non-local, points-to vars: { D.3043 } (nonlocal, escaped, restrict)

Flow-insensitive points-to information

__fmt_2(D), points-to NULL, points-to vars: { D.3043 } (nonlocal, escaped, restrict)

__attribute__((__artificial__, __gnu_inline__, __always_inline__))
printf (const char * restrict __fmt)
{
  int _4;

  <bb 2> [0.00%]:
  _4 = __printf_chk (1, __fmt_2(D), __builtin_va_arg_pack ());
  return _4;

}



;; Function foo (foo, funcdef_no=39, decl_uid=3011, cgraph_uid=39, symbol_order=39)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
z = &NONLOCAL
_1 = z
ESCAPED = _1
a_7 = &HEAP(12)
ESCAPED = &NONLOCAL
ESCAPED = &STRING
ESCAPED = i_2
_12 = NONLOCAL
i_11 = i_2
i_11 = &NONLOCAL
i_2 = &NULL
i_2 = i_11
_9 = a_7
ESCAPED = a_7

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { NULL STRING ESCAPED NONLOCAL HEAP(12) }
NONLOCAL = { ESCAPED NONLOCAL } same as _12
STOREDANYTHING = { }
INTEGER = { ANYTHING }
z = { NONLOCAL }
_1 = { NONLOCAL } same as z
malloc = { }
a_7 = { HEAP(12) }
HEAP(12) = { ESCAPED NONLOCAL }
__printf_chk = { }
i_2 = { NULL NONLOCAL }
_12 = { ESCAPED NONLOCAL }
i_11 = { NULL NONLOCAL } same as i_2
_9 = { HEAP(12) } same as a_7


Alias information for foo

Aliased symbols


Call clobber information

ESCAPED, points-to non-local, points-to NULL, points-to vars: { D.3046 } (escaped, escaped heap)

Flow-insensitive points-to information

a_7, points-to NULL, points-to vars: { D.3046 } (escaped, escaped heap)
_9, points-to NULL, points-to vars: { D.3046 } (escaped, escaped heap)

foo (int z)
{
  int D.3045;
  int i;
  int * a;
  long unsigned int _1;
  int * _9;
  int _12;

  <bb 2> [0.00%]:
  _1 = (long unsigned int) z_4(D);
  a_7 = malloc (_1);
  goto <bb 4>; [0.00%]

  <bb 3> [100.00%]:
  _12 = __printf_chk (1, "qwdwqd%d\n", i_2);
  i_11 = i_2 + 1;

  <bb 4> [0.00%]:
  # i_2 = PHI <0(2), i_11(3)>
  if (i_2 <= 2)
    goto <bb 3>; [0.00%]
  else
    goto <bb 5>; [0.00%]

  <bb 5> [0.00%]:
  _9 = a_7;
  return a_7;

}



;; Function foo2 (foo2, funcdef_no=40, decl_uid=3019, cgraph_uid=40, symbol_order=40)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
z = &NONLOCAL

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { }
NONLOCAL = { ESCAPED NONLOCAL }
STOREDANYTHING = { }
INTEGER = { ANYTHING }
z = { NONLOCAL }


Alias information for foo2

Aliased symbols


Call clobber information

ESCAPED, points-to vars: { }

Flow-insensitive points-to information

z_2(D), points-to non-local, points-to NULL, points-to vars: { }

foo2 (int * z)
{
  <bb 2> [0.00%]:
  free (z_2(D));
  return;

}



;; Function child (child, funcdef_no=41, decl_uid=3022, cgraph_uid=41, symbol_order=41)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
data = &NONLOCAL
ESCAPED = &NONLOCAL
k_7 = &HEAP(11)
ESCAPED = &NONLOCAL
i_12 = i_1
i_12 = &NONLOCAL
i_1 = &NULL
i_1 = i_12
ESCAPED = &NULL

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { NULL ESCAPED NONLOCAL }
NONLOCAL = { ESCAPED NONLOCAL }
STOREDANYTHING = { }
INTEGER = { ANYTHING }
data = { NONLOCAL }
malloc = { }
k_7 = { HEAP(11) }
HEAP(11) = { }
sleep = { }
i_12 = { NULL NONLOCAL }
i_1 = { NULL NONLOCAL } same as i_12
pthread_exit = { }


Alias information for child

Aliased symbols


Call clobber information

ESCAPED, points-to non-local, points-to NULL, points-to vars: { }

Flow-insensitive points-to information

data_3(D), points-to non-local, points-to NULL, points-to vars: { }
k_7, points-to NULL, points-to vars: { D.3047 }

child (void * data)
{
  int i;
  int * k;
  char * str;

  <bb 2> [0.00%]:
  k_7 = malloc (10);
  goto <bb 4>; [0.00%]

  <bb 3> [0.00%]:
  sleep (1);
  i_12 = i_1 + 1;

  <bb 4> [0.00%]:
  # i_1 = PHI <0(2), i_12(3)>
  if (i_1 <= 2)
    goto <bb 3>; [0.00%]
  else
    goto <bb 5>; [0.00%]

  <bb 5> [0.00%]:
  pthread_exit (0B);
  free (k_7);
  return;

}


