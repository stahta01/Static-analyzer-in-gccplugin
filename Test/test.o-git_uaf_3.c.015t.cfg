
;; Function xrealloc (xrealloc, funcdef_no=26, decl_uid=3197, cgraph_uid=27, symbol_order=27)

Merging blocks 9 and 10
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9
;; 2 succs { 3 4 }
;; 3 succs { 4 }
;; 4 succs { 5 9 }
;; 5 succs { 6 7 }
;; 6 succs { 7 }
;; 7 succs { 8 9 }
;; 8 succs { }
;; 9 succs { 1 }
void * xrealloc (void * ptr, size_t size)
{
  void * ret;
  void * D.3314;

  <bb 2> :
  ret = realloc (ptr, size);
  _1 = ret == 0B;
  _2 = size == 0;
  _3 = _1 & _2;
  if (_3 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  ret = realloc (ptr, 1);

  <bb 4> :
  if (ret == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 5> :
  ret = realloc (ptr, size);
  _4 = ret == 0B;
  _5 = size == 0;
  _6 = _4 & _5;
  if (_6 != 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  ret = realloc (ptr, 1);

  <bb 7> :
  if (ret == 0B)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  printf ("Out of memory, realloc failed%s", "");
  exit (1);

  <bb 9> :
  D.3314 = ret;
  return D.3314;

}



;; Function main (main, funcdef_no=31, decl_uid=3303, cgraph_uid=32, symbol_order=40)

Removing basic block 3
Merging blocks 2 and 4
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
int main (int argc, char * * argv)
{
  int D.3316;

  <bb 2> :
  handle_alias (&argc, &argv);
  new_handle_alias (&argc, &argv);
  D.3316 = 0;
  return D.3316;

}



;; Function handle_alias (handle_alias, funcdef_no=30, decl_uid=3274, cgraph_uid=31, symbol_order=39)

Merging blocks 19 and 20
Merging blocks 19 and 21
;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19
;;
;; Loop 1
;;  header 6, latch 5
;;  depth 1, outer 0
;;  nodes: 6 5
;; 2 succs { 3 19 }
;; 3 succs { 4 10 }
;; 4 succs { 6 }
;; 5 succs { 6 }
;; 6 succs { 5 7 }
;; 7 succs { 8 9 }
;; 8 succs { }
;; 9 succs { }
;; 10 succs { 11 12 }
;; 11 succs { }
;; 12 succs { 13 14 }
;; 13 succs { }
;; 14 succs { 15 16 }
;; 15 succs { }
;; 16 succs { 17 18 }
;; 17 succs { }
;; 18 succs { 19 }
;; 19 succs { 1 }
int handle_alias (int * argcp, const char * * * argv)
{
  int i;
  int argc;
  const char * * alias_argv;
  int unused_nongit;
  char * alias_string;
  const char * alias_command;
  const char * * new_argv;
  int option_count;
  int count;
  int saved_errno;
  int ret;
  int envchanged;
  int D.3332;

  <bb 2> :
  envchanged = 0;
  ret = 0;
  _1 = __errno_location ();
  saved_errno = *_1;
  save_env_before_alias ();
  setup_git_directory_gently (&unused_nongit);
  _2 = *argv;
  alias_command = *_2;
  _3 = alias_lookup (alias_command);
  _4 = (long int) _3;
  alias_string = (char *) _4;
  if (alias_string != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 19>; [INV]

  <bb 3> :
  _5 = *alias_string;
  if (_5 == 33)
    goto <bb 4>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 4> :
  argc = *argcp;
  commit_pager_choice ();
  restore_env (1);
  _6 = argc + 1;
  _7 = (long unsigned int) _6;
  _8 = _7 * 8;
  alias_argv = malloc (_8);
  _9 = alias_string + 1;
  *alias_argv = _9;
  i = 1;
  goto <bb 6>; [INV]

  <bb 5> :
  _10 = *argv;
  _11 = (long unsigned int) i;
  _12 = _11 * 8;
  _13 = _10 + _12;
  _14 = (long unsigned int) i;
  _15 = _14 * 8;
  _16 = alias_argv + _15;
  _17 = *_13;
  *_16 = _17;
  i = i + 1;

  <bb 6> :
  if (i < argc)
    goto <bb 5>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  _18 = (long unsigned int) argc;
  _19 = _18 * 8;
  _20 = alias_argv + _19;
  *_20 = 0B;
  ret = run_command_v_opt (alias_argv, 16);
  if (ret >= 0)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  exit (ret);

  <bb 9> :
  printf ("While expanding alias \'%s\': ", alias_command);
  exit (1);

  <bb 10> :
  _21 = split_cmdline (alias_string, &new_argv);
  count = _21;
  count.0_22 = count;
  if (count.0_22 < 0)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  printf ("Bad alias.%s string: ", alias_command);
  exit (1);

  <bb 12> :
  option_count = handle_options (&new_argv, &count, &envchanged);
  envchanged.1_23 = envchanged;
  if (envchanged.1_23 != 0)
    goto <bb 13>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 13> :
  printf ("alias \'%s\' changes environment variables\nYou can use \'!git\' in the alias to do this.", alias_command);
  exit (1);

  <bb 14> :
  count.2_24 = count;
  _25 = (long unsigned int) count.2_24;
  _26 = _25 * 8;
  new_argv.3_27 = new_argv;
  new_argv.4_28 = new_argv;
  _29 = (long unsigned int) option_count;
  _30 = _29 * 8;
  _31 = -_30;
  _32 = new_argv.4_28 + _31;
  memmove (_32, new_argv.3_27, _26);
  new_argv.5_33 = new_argv;
  _34 = (long unsigned int) option_count;
  _35 = _34 * 8;
  _36 = -_35;
  _37 = new_argv.5_33 + _36;
  new_argv = _37;
  count.6_38 = count;
  if (count.6_38 <= 0)
    goto <bb 15>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 15> :
  printf ("empty alias for %s", alias_command);
  exit (1);

  <bb 16> :
  new_argv.7_39 = new_argv;
  _40 = *new_argv.7_39;
  _41 = strcmp (alias_command, _40);
  if (_41 == 0)
    goto <bb 17>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 17> :
  printf ("recursive alias: %s", alias_command);
  exit (1);

  <bb 18> :
  new_argv.8_42 = new_argv;
  trace_argv_printf (new_argv.8_42, "trace: alias expansion: %s =>", alias_command);
  ret = 1;

  <bb 19> :
  restore_env (0);
  _43 = __errno_location ();
  *_43 = saved_errno;
  D.3332 = ret;
  envchanged = {CLOBBER};
  count = {CLOBBER};
  new_argv = {CLOBBER};
  unused_nongit = {CLOBBER};
  return D.3332;

}



;; Function save_env_before_alias (save_env_before_alias, funcdef_no=27, decl_uid=3210, cgraph_uid=28, symbol_order=36)

;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7
;;
;; Loop 1
;;  header 6, latch 5
;;  depth 1, outer 0
;;  nodes: 6 5 3 4
;; 2 succs { 6 }
;; 3 succs { 4 5 }
;; 4 succs { 5 }
;; 5 succs { 6 }
;; 6 succs { 3 7 }
;; 7 succs { 1 }
void save_env_before_alias ()
{
  int i;

  <bb 2> :
  saved_env_before_alias = 1;
  _1 = xgetcwd ();
  _2 = (long int) _1;
  _3 = (char *) _2;
  orig_cwd = _3;
  i = 0;
  goto <bb 6>; [INV]

  <bb 3> :
  _4 = env_names[i];
  _5 = getenv (_4);
  orig_env[i] = _5;
  _6 = orig_env[i];
  if (_6 != 0B)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  _7 = orig_env[i];
  _8 = strdup (_7);
  orig_env[i] = _8;

  <bb 5> :
  i = i + 1;

  <bb 6> :
  _9 = ARRAY_SIZE (&env_names);
  if (i < _9)
    goto <bb 3>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  return;

}



;; Function restore_env (restore_env, funcdef_no=28, decl_uid=3223, cgraph_uid=29, symbol_order=37)

;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
;;
;; Loop 1
;;  header 14, latch 13
;;  depth 1, outer 0
;;  nodes: 14 13 9 11 12 10 7 8
;; 2 succs { 3 6 }
;; 3 succs { 4 6 }
;; 4 succs { 5 6 }
;; 5 succs { }
;; 6 succs { 14 }
;; 7 succs { 8 10 }
;; 8 succs { 9 10 }
;; 9 succs { 13 }
;; 10 succs { 11 12 }
;; 11 succs { 13 }
;; 12 succs { 13 }
;; 13 succs { 14 }
;; 14 succs { 7 15 }
;; 15 succs { 1 }
void restore_env (int external_alias)
{
  int i;

  <bb 2> :
  if (external_alias == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 3> :
  orig_cwd.9_1 = orig_cwd;
  if (orig_cwd.9_1 != 0B)
    goto <bb 4>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 4> :
  orig_cwd.10_2 = orig_cwd;
  _3 = chdir (orig_cwd.10_2);
  if (_3 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  orig_cwd.11_4 = orig_cwd;
  printf ("could not move to %s", orig_cwd.11_4);
  exit (1);

  <bb 6> :
  orig_cwd.12_5 = orig_cwd;
  free (orig_cwd.12_5);
  i = 0;
  goto <bb 14>; [INV]

  <bb 7> :
  if (external_alias != 0)
    goto <bb 8>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 8> :
  _6 = env_names[i];
  _7 = strcmp (_6, "GIT_PREFIX");
  if (_7 == 0)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  // predicted unlikely by continue predictor.
  goto <bb 13>; [INV]

  <bb 10> :
  _8 = orig_env[i];
  if (_8 != 0B)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  _9 = orig_env[i];
  _10 = env_names[i];
  setenv (_10, _9, 1);
  goto <bb 13>; [INV]

  <bb 12> :
  _11 = env_names[i];
  unsetenv (_11);

  <bb 13> :
  i = i + 1;

  <bb 14> :
  _12 = ARRAY_SIZE (&env_names);
  if (i < _12)
    goto <bb 7>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 15> :
  return;

}



;; Function new_handle_alias (new_handle_alias, funcdef_no=29, decl_uid=3236, cgraph_uid=30, symbol_order=38)

Merging blocks 21 and 22
Merging blocks 21 and 23
;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21
;;
;; Loop 1
;;  header 8, latch 7
;;  depth 1, outer 0
;;  nodes: 8 7
;; 2 succs { 3 4 }
;; 3 succs { 21 }
;; 4 succs { 5 21 }
;; 5 succs { 6 12 }
;; 6 succs { 8 }
;; 7 succs { 8 }
;; 8 succs { 7 9 }
;; 9 succs { 10 11 }
;; 10 succs { }
;; 11 succs { }
;; 12 succs { 13 14 }
;; 13 succs { }
;; 14 succs { 15 16 }
;; 15 succs { }
;; 16 succs { 17 18 }
;; 17 succs { }
;; 18 succs { 19 20 }
;; 19 succs { }
;; 20 succs { 21 }
;; 21 succs { 1 }
int new_handle_alias (int * argcp, const char * * * argv)
{
  int i;
  int argc;
  const char * * alias_argv;
  int unexpected;
  int unused_nongit;
  char * alias_string;
  const char * alias_command;
  const char * * new_argv;
  int option_count;
  int count;
  int saved_errno;
  int ret;
  int envchanged;
  int D.3366;

  <bb 2> :
  envchanged = 0;
  ret = 0;
  _1 = __errno_location ();
  saved_errno = *_1;
  if (unexpected != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  // predicted unlikely by goto predictor.
  goto <bb 21>; [INV]

  <bb 4> :
  save_env_before_alias ();
  setup_git_directory_gently (&unused_nongit);
  _2 = *argv;
  alias_command = *_2;
  _3 = alias_lookup (alias_command);
  _4 = (long int) _3;
  alias_string = (char *) _4;
  if (alias_string != 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 21>; [INV]

  <bb 5> :
  _5 = *alias_string;
  if (_5 == 33)
    goto <bb 6>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 6> :
  argc = *argcp;
  commit_pager_choice ();
  restore_env (1);
  _6 = argc + 1;
  _7 = (long unsigned int) _6;
  _8 = _7 * 8;
  alias_argv = malloc (_8);
  _9 = alias_string + 1;
  *alias_argv = _9;
  i = 1;
  goto <bb 8>; [INV]

  <bb 7> :
  _10 = *argv;
  _11 = (long unsigned int) i;
  _12 = _11 * 8;
  _13 = _10 + _12;
  _14 = (long unsigned int) i;
  _15 = _14 * 8;
  _16 = alias_argv + _15;
  _17 = *_13;
  *_16 = _17;
  i = i + 1;

  <bb 8> :
  if (i < argc)
    goto <bb 7>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 9> :
  _18 = (long unsigned int) argc;
  _19 = _18 * 8;
  _20 = alias_argv + _19;
  *_20 = 0B;
  ret = run_command_v_opt (alias_argv, 16);
  if (ret >= 0)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  exit (ret);

  <bb 11> :
  printf ("While expanding alias \'%s\':", alias_command);
  exit (1);

  <bb 12> :
  _21 = split_cmdline (alias_string, &new_argv);
  count = _21;
  count.13_22 = count;
  if (count.13_22 < 0)
    goto <bb 13>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 13> :
  printf ("Bad alias.%s string: ", alias_command);
  exit (1);

  <bb 14> :
  option_count = handle_options (&new_argv, &count, &envchanged);
  envchanged.14_23 = envchanged;
  if (envchanged.14_23 != 0)
    goto <bb 15>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 15> :
  printf ("alias \'%s\' changes environment variables\nYou can use \'!git\' in the alias to do this.", alias_command);
  exit (1);

  <bb 16> :
  count.15_24 = count;
  _25 = (long unsigned int) count.15_24;
  _26 = _25 * 8;
  new_argv.16_27 = new_argv;
  new_argv.17_28 = new_argv;
  _29 = (long unsigned int) option_count;
  _30 = _29 * 8;
  _31 = -_30;
  _32 = new_argv.17_28 + _31;
  memmove (_32, new_argv.16_27, _26);
  new_argv.18_33 = new_argv;
  _34 = (long unsigned int) option_count;
  _35 = _34 * 8;
  _36 = -_35;
  _37 = new_argv.18_33 + _36;
  new_argv = _37;
  count.19_38 = count;
  if (count.19_38 <= 0)
    goto <bb 17>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 17> :
  printf ("empty alias for %s", alias_command);
  exit (1);

  <bb 18> :
  new_argv.20_39 = new_argv;
  _40 = *new_argv.20_39;
  _41 = strcmp (alias_command, _40);
  if (_41 == 0)
    goto <bb 19>; [INV]
  else
    goto <bb 20>; [INV]

  <bb 19> :
  printf ("recursive alias: %s", alias_command);
  exit (1);

  <bb 20> :
  new_argv.21_42 = new_argv;
  trace_argv_printf (new_argv.21_42, "trace: alias expansion: %s =>", alias_command);
  ret = 1;

  <bb 21> :
err:
  restore_env (0);
  _43 = __errno_location ();
  *_43 = saved_errno;
  D.3366 = ret;
  envchanged = {CLOBBER};
  count = {CLOBBER};
  new_argv = {CLOBBER};
  unused_nongit = {CLOBBER};
  return D.3366;

}


