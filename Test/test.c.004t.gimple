winlink_cmp (struct winlink * wl1, struct winlink * wl2)
{
  int D.4668;

  _1 = wl1->idx;
  _2 = wl2->idx;
  D.4668 = _1 - _2;
  return D.4668;
}


winlinks_RB_INSERT_COLOR (struct winlinks * head, struct winlink * elm)
{
  struct winlink * parent;
  struct winlink * gparent;
  struct winlink * tmp;

  goto <D.4307>;
  <D.4308>:
  gparent = parent->entry.rbe_parent;
  _1 = gparent->entry.rbe_left;
  if (parent == _1) goto <D.4670>; else goto <D.4671>;
  <D.4670>:
  tmp = gparent->entry.rbe_right;
  if (tmp != 0B) goto <D.4672>; else goto <D.4673>;
  <D.4672>:
  _2 = tmp->entry.rbe_color;
  if (_2 == 1) goto <D.4674>; else goto <D.4675>;
  <D.4674>:
  tmp->entry.rbe_color = 0;
  parent->entry.rbe_color = 0;
  gparent->entry.rbe_color = 1;
  elm = gparent;
  // predicted unlikely by continue predictor.
  goto <D.4307>;
  <D.4675>:
  <D.4673>:
  _3 = parent->entry.rbe_right;
  if (elm == _3) goto <D.4676>; else goto <D.4677>;
  <D.4676>:
  tmp = parent->entry.rbe_right;
  _4 = tmp->entry.rbe_left;
  parent->entry.rbe_right = _4;
  _5 = parent->entry.rbe_right;
  if (_5 != 0B) goto <D.4678>; else goto <D.4679>;
  <D.4678>:
  _6 = tmp->entry.rbe_left;
  _6->entry.rbe_parent = parent;
  <D.4679>:
  _7 = parent->entry.rbe_parent;
  tmp->entry.rbe_parent = _7;
  _8 = tmp->entry.rbe_parent;
  if (_8 != 0B) goto <D.4680>; else goto <D.4681>;
  <D.4680>:
  _9 = parent->entry.rbe_parent;
  _10 = _9->entry.rbe_left;
  if (parent == _10) goto <D.4682>; else goto <D.4683>;
  <D.4682>:
  _11 = parent->entry.rbe_parent;
  _11->entry.rbe_left = tmp;
  goto <D.4684>;
  <D.4683>:
  _12 = parent->entry.rbe_parent;
  _12->entry.rbe_right = tmp;
  <D.4684>:
  goto <D.4685>;
  <D.4681>:
  head->rbh_root = tmp;
  <D.4685>:
  tmp->entry.rbe_left = parent;
  parent->entry.rbe_parent = tmp;
  _13 = tmp->entry.rbe_parent;
  if (_13 != 0B) goto <D.4686>; else goto <D.4687>;
  <D.4686>:
  <D.4687>:
  tmp = parent;
  parent = elm;
  elm = tmp;
  <D.4677>:
  parent->entry.rbe_color = 0;
  gparent->entry.rbe_color = 1;
  tmp = gparent->entry.rbe_left;
  _14 = tmp->entry.rbe_right;
  gparent->entry.rbe_left = _14;
  _15 = gparent->entry.rbe_left;
  if (_15 != 0B) goto <D.4688>; else goto <D.4689>;
  <D.4688>:
  _16 = tmp->entry.rbe_right;
  _16->entry.rbe_parent = gparent;
  <D.4689>:
  _17 = gparent->entry.rbe_parent;
  tmp->entry.rbe_parent = _17;
  _18 = tmp->entry.rbe_parent;
  if (_18 != 0B) goto <D.4690>; else goto <D.4691>;
  <D.4690>:
  _19 = gparent->entry.rbe_parent;
  _20 = _19->entry.rbe_left;
  if (gparent == _20) goto <D.4692>; else goto <D.4693>;
  <D.4692>:
  _21 = gparent->entry.rbe_parent;
  _21->entry.rbe_left = tmp;
  goto <D.4694>;
  <D.4693>:
  _22 = gparent->entry.rbe_parent;
  _22->entry.rbe_right = tmp;
  <D.4694>:
  goto <D.4695>;
  <D.4691>:
  head->rbh_root = tmp;
  <D.4695>:
  tmp->entry.rbe_right = gparent;
  gparent->entry.rbe_parent = tmp;
  _23 = tmp->entry.rbe_parent;
  if (_23 != 0B) goto <D.4696>; else goto <D.4697>;
  <D.4696>:
  <D.4697>:
  goto <D.4698>;
  <D.4671>:
  tmp = gparent->entry.rbe_left;
  if (tmp != 0B) goto <D.4699>; else goto <D.4700>;
  <D.4699>:
  _24 = tmp->entry.rbe_color;
  if (_24 == 1) goto <D.4701>; else goto <D.4702>;
  <D.4701>:
  tmp->entry.rbe_color = 0;
  parent->entry.rbe_color = 0;
  gparent->entry.rbe_color = 1;
  elm = gparent;
  // predicted unlikely by continue predictor.
  goto <D.4307>;
  <D.4702>:
  <D.4700>:
  _25 = parent->entry.rbe_left;
  if (elm == _25) goto <D.4703>; else goto <D.4704>;
  <D.4703>:
  tmp = parent->entry.rbe_left;
  _26 = tmp->entry.rbe_right;
  parent->entry.rbe_left = _26;
  _27 = parent->entry.rbe_left;
  if (_27 != 0B) goto <D.4705>; else goto <D.4706>;
  <D.4705>:
  _28 = tmp->entry.rbe_right;
  _28->entry.rbe_parent = parent;
  <D.4706>:
  _29 = parent->entry.rbe_parent;
  tmp->entry.rbe_parent = _29;
  _30 = tmp->entry.rbe_parent;
  if (_30 != 0B) goto <D.4707>; else goto <D.4708>;
  <D.4707>:
  _31 = parent->entry.rbe_parent;
  _32 = _31->entry.rbe_left;
  if (parent == _32) goto <D.4709>; else goto <D.4710>;
  <D.4709>:
  _33 = parent->entry.rbe_parent;
  _33->entry.rbe_left = tmp;
  goto <D.4711>;
  <D.4710>:
  _34 = parent->entry.rbe_parent;
  _34->entry.rbe_right = tmp;
  <D.4711>:
  goto <D.4712>;
  <D.4708>:
  head->rbh_root = tmp;
  <D.4712>:
  tmp->entry.rbe_right = parent;
  parent->entry.rbe_parent = tmp;
  _35 = tmp->entry.rbe_parent;
  if (_35 != 0B) goto <D.4713>; else goto <D.4714>;
  <D.4713>:
  <D.4714>:
  tmp = parent;
  parent = elm;
  elm = tmp;
  <D.4704>:
  parent->entry.rbe_color = 0;
  gparent->entry.rbe_color = 1;
  tmp = gparent->entry.rbe_right;
  _36 = tmp->entry.rbe_left;
  gparent->entry.rbe_right = _36;
  _37 = gparent->entry.rbe_right;
  if (_37 != 0B) goto <D.4715>; else goto <D.4716>;
  <D.4715>:
  _38 = tmp->entry.rbe_left;
  _38->entry.rbe_parent = gparent;
  <D.4716>:
  _39 = gparent->entry.rbe_parent;
  tmp->entry.rbe_parent = _39;
  _40 = tmp->entry.rbe_parent;
  if (_40 != 0B) goto <D.4717>; else goto <D.4718>;
  <D.4717>:
  _41 = gparent->entry.rbe_parent;
  _42 = _41->entry.rbe_left;
  if (gparent == _42) goto <D.4719>; else goto <D.4720>;
  <D.4719>:
  _43 = gparent->entry.rbe_parent;
  _43->entry.rbe_left = tmp;
  goto <D.4721>;
  <D.4720>:
  _44 = gparent->entry.rbe_parent;
  _44->entry.rbe_right = tmp;
  <D.4721>:
  goto <D.4722>;
  <D.4718>:
  head->rbh_root = tmp;
  <D.4722>:
  tmp->entry.rbe_left = gparent;
  gparent->entry.rbe_parent = tmp;
  _45 = tmp->entry.rbe_parent;
  if (_45 != 0B) goto <D.4723>; else goto <D.4724>;
  <D.4723>:
  <D.4724>:
  <D.4698>:
  <D.4307>:
  parent = elm->entry.rbe_parent;
  if (parent != 0B) goto <D.4725>; else goto <D.4309>;
  <D.4725>:
  _46 = parent->entry.rbe_color;
  if (_46 == 1) goto <D.4308>; else goto <D.4309>;
  <D.4309>:
  _47 = head->rbh_root;
  _47->entry.rbe_color = 0;
}


winlinks_RB_REMOVE_COLOR (struct winlinks * head, struct winlink * parent, struct winlink * elm)
{
  struct winlink * tmp;

  goto <D.4320>;
  <D.4319>:
  _1 = parent->entry.rbe_left;
  if (elm == _1) goto <D.4726>; else goto <D.4727>;
  <D.4726>:
  tmp = parent->entry.rbe_right;
  _2 = tmp->entry.rbe_color;
  if (_2 == 1) goto <D.4728>; else goto <D.4729>;
  <D.4728>:
  tmp->entry.rbe_color = 0;
  parent->entry.rbe_color = 1;
  tmp = parent->entry.rbe_right;
  _3 = tmp->entry.rbe_left;
  parent->entry.rbe_right = _3;
  _4 = parent->entry.rbe_right;
  if (_4 != 0B) goto <D.4730>; else goto <D.4731>;
  <D.4730>:
  _5 = tmp->entry.rbe_left;
  _5->entry.rbe_parent = parent;
  <D.4731>:
  _6 = parent->entry.rbe_parent;
  tmp->entry.rbe_parent = _6;
  _7 = tmp->entry.rbe_parent;
  if (_7 != 0B) goto <D.4732>; else goto <D.4733>;
  <D.4732>:
  _8 = parent->entry.rbe_parent;
  _9 = _8->entry.rbe_left;
  if (parent == _9) goto <D.4734>; else goto <D.4735>;
  <D.4734>:
  _10 = parent->entry.rbe_parent;
  _10->entry.rbe_left = tmp;
  goto <D.4736>;
  <D.4735>:
  _11 = parent->entry.rbe_parent;
  _11->entry.rbe_right = tmp;
  <D.4736>:
  goto <D.4737>;
  <D.4733>:
  head->rbh_root = tmp;
  <D.4737>:
  tmp->entry.rbe_left = parent;
  parent->entry.rbe_parent = tmp;
  _12 = tmp->entry.rbe_parent;
  if (_12 != 0B) goto <D.4738>; else goto <D.4739>;
  <D.4738>:
  <D.4739>:
  tmp = parent->entry.rbe_right;
  <D.4729>:
  _13 = tmp->entry.rbe_left;
  if (_13 == 0B) goto <D.4740>; else goto <D.4744>;
  <D.4744>:
  _14 = tmp->entry.rbe_left;
  _15 = _14->entry.rbe_color;
  if (_15 == 0) goto <D.4740>; else goto <D.4741>;
  <D.4740>:
  _16 = tmp->entry.rbe_right;
  if (_16 == 0B) goto <D.4742>; else goto <D.4745>;
  <D.4745>:
  _17 = tmp->entry.rbe_right;
  _18 = _17->entry.rbe_color;
  if (_18 == 0) goto <D.4742>; else goto <D.4741>;
  <D.4742>:
  tmp->entry.rbe_color = 1;
  elm = parent;
  parent = elm->entry.rbe_parent;
  goto <D.4743>;
  <D.4741>:
  _19 = tmp->entry.rbe_right;
  if (_19 == 0B) goto <D.4746>; else goto <D.4748>;
  <D.4748>:
  _20 = tmp->entry.rbe_right;
  _21 = _20->entry.rbe_color;
  if (_21 == 0) goto <D.4746>; else goto <D.4747>;
  <D.4746>:
  {
    struct winlink * oleft;

    oleft = tmp->entry.rbe_left;
    if (oleft != 0B) goto <D.4749>; else goto <D.4750>;
    <D.4749>:
    oleft->entry.rbe_color = 0;
    <D.4750>:
    tmp->entry.rbe_color = 1;
    oleft = tmp->entry.rbe_left;
    _22 = oleft->entry.rbe_right;
    tmp->entry.rbe_left = _22;
    _23 = tmp->entry.rbe_left;
    if (_23 != 0B) goto <D.4751>; else goto <D.4752>;
    <D.4751>:
    _24 = oleft->entry.rbe_right;
    _24->entry.rbe_parent = tmp;
    <D.4752>:
    _25 = tmp->entry.rbe_parent;
    oleft->entry.rbe_parent = _25;
    _26 = oleft->entry.rbe_parent;
    if (_26 != 0B) goto <D.4753>; else goto <D.4754>;
    <D.4753>:
    _27 = tmp->entry.rbe_parent;
    _28 = _27->entry.rbe_left;
    if (tmp == _28) goto <D.4755>; else goto <D.4756>;
    <D.4755>:
    _29 = tmp->entry.rbe_parent;
    _29->entry.rbe_left = oleft;
    goto <D.4757>;
    <D.4756>:
    _30 = tmp->entry.rbe_parent;
    _30->entry.rbe_right = oleft;
    <D.4757>:
    goto <D.4758>;
    <D.4754>:
    head->rbh_root = oleft;
    <D.4758>:
    oleft->entry.rbe_right = tmp;
    tmp->entry.rbe_parent = oleft;
    _31 = oleft->entry.rbe_parent;
    if (_31 != 0B) goto <D.4759>; else goto <D.4760>;
    <D.4759>:
    <D.4760>:
    tmp = parent->entry.rbe_right;
  }
  <D.4747>:
  _32 = parent->entry.rbe_color;
  tmp->entry.rbe_color = _32;
  parent->entry.rbe_color = 0;
  _33 = tmp->entry.rbe_right;
  if (_33 != 0B) goto <D.4761>; else goto <D.4762>;
  <D.4761>:
  _34 = tmp->entry.rbe_right;
  _34->entry.rbe_color = 0;
  <D.4762>:
  tmp = parent->entry.rbe_right;
  _35 = tmp->entry.rbe_left;
  parent->entry.rbe_right = _35;
  _36 = parent->entry.rbe_right;
  if (_36 != 0B) goto <D.4763>; else goto <D.4764>;
  <D.4763>:
  _37 = tmp->entry.rbe_left;
  _37->entry.rbe_parent = parent;
  <D.4764>:
  _38 = parent->entry.rbe_parent;
  tmp->entry.rbe_parent = _38;
  _39 = tmp->entry.rbe_parent;
  if (_39 != 0B) goto <D.4765>; else goto <D.4766>;
  <D.4765>:
  _40 = parent->entry.rbe_parent;
  _41 = _40->entry.rbe_left;
  if (parent == _41) goto <D.4767>; else goto <D.4768>;
  <D.4767>:
  _42 = parent->entry.rbe_parent;
  _42->entry.rbe_left = tmp;
  goto <D.4769>;
  <D.4768>:
  _43 = parent->entry.rbe_parent;
  _43->entry.rbe_right = tmp;
  <D.4769>:
  goto <D.4770>;
  <D.4766>:
  head->rbh_root = tmp;
  <D.4770>:
  tmp->entry.rbe_left = parent;
  parent->entry.rbe_parent = tmp;
  _44 = tmp->entry.rbe_parent;
  if (_44 != 0B) goto <D.4771>; else goto <D.4772>;
  <D.4771>:
  <D.4772>:
  elm = head->rbh_root;
  goto <D.4317>;
  <D.4743>:
  goto <D.4773>;
  <D.4727>:
  tmp = parent->entry.rbe_left;
  _45 = tmp->entry.rbe_color;
  if (_45 == 1) goto <D.4774>; else goto <D.4775>;
  <D.4774>:
  tmp->entry.rbe_color = 0;
  parent->entry.rbe_color = 1;
  tmp = parent->entry.rbe_left;
  _46 = tmp->entry.rbe_right;
  parent->entry.rbe_left = _46;
  _47 = parent->entry.rbe_left;
  if (_47 != 0B) goto <D.4776>; else goto <D.4777>;
  <D.4776>:
  _48 = tmp->entry.rbe_right;
  _48->entry.rbe_parent = parent;
  <D.4777>:
  _49 = parent->entry.rbe_parent;
  tmp->entry.rbe_parent = _49;
  _50 = tmp->entry.rbe_parent;
  if (_50 != 0B) goto <D.4778>; else goto <D.4779>;
  <D.4778>:
  _51 = parent->entry.rbe_parent;
  _52 = _51->entry.rbe_left;
  if (parent == _52) goto <D.4780>; else goto <D.4781>;
  <D.4780>:
  _53 = parent->entry.rbe_parent;
  _53->entry.rbe_left = tmp;
  goto <D.4782>;
  <D.4781>:
  _54 = parent->entry.rbe_parent;
  _54->entry.rbe_right = tmp;
  <D.4782>:
  goto <D.4783>;
  <D.4779>:
  head->rbh_root = tmp;
  <D.4783>:
  tmp->entry.rbe_right = parent;
  parent->entry.rbe_parent = tmp;
  _55 = tmp->entry.rbe_parent;
  if (_55 != 0B) goto <D.4784>; else goto <D.4785>;
  <D.4784>:
  <D.4785>:
  tmp = parent->entry.rbe_left;
  <D.4775>:
  _56 = tmp->entry.rbe_left;
  if (_56 == 0B) goto <D.4786>; else goto <D.4790>;
  <D.4790>:
  _57 = tmp->entry.rbe_left;
  _58 = _57->entry.rbe_color;
  if (_58 == 0) goto <D.4786>; else goto <D.4787>;
  <D.4786>:
  _59 = tmp->entry.rbe_right;
  if (_59 == 0B) goto <D.4788>; else goto <D.4791>;
  <D.4791>:
  _60 = tmp->entry.rbe_right;
  _61 = _60->entry.rbe_color;
  if (_61 == 0) goto <D.4788>; else goto <D.4787>;
  <D.4788>:
  tmp->entry.rbe_color = 1;
  elm = parent;
  parent = elm->entry.rbe_parent;
  goto <D.4789>;
  <D.4787>:
  _62 = tmp->entry.rbe_left;
  if (_62 == 0B) goto <D.4792>; else goto <D.4794>;
  <D.4794>:
  _63 = tmp->entry.rbe_left;
  _64 = _63->entry.rbe_color;
  if (_64 == 0) goto <D.4792>; else goto <D.4793>;
  <D.4792>:
  {
    struct winlink * oright;

    oright = tmp->entry.rbe_right;
    if (oright != 0B) goto <D.4795>; else goto <D.4796>;
    <D.4795>:
    oright->entry.rbe_color = 0;
    <D.4796>:
    tmp->entry.rbe_color = 1;
    oright = tmp->entry.rbe_right;
    _65 = oright->entry.rbe_left;
    tmp->entry.rbe_right = _65;
    _66 = tmp->entry.rbe_right;
    if (_66 != 0B) goto <D.4797>; else goto <D.4798>;
    <D.4797>:
    _67 = oright->entry.rbe_left;
    _67->entry.rbe_parent = tmp;
    <D.4798>:
    _68 = tmp->entry.rbe_parent;
    oright->entry.rbe_parent = _68;
    _69 = oright->entry.rbe_parent;
    if (_69 != 0B) goto <D.4799>; else goto <D.4800>;
    <D.4799>:
    _70 = tmp->entry.rbe_parent;
    _71 = _70->entry.rbe_left;
    if (tmp == _71) goto <D.4801>; else goto <D.4802>;
    <D.4801>:
    _72 = tmp->entry.rbe_parent;
    _72->entry.rbe_left = oright;
    goto <D.4803>;
    <D.4802>:
    _73 = tmp->entry.rbe_parent;
    _73->entry.rbe_right = oright;
    <D.4803>:
    goto <D.4804>;
    <D.4800>:
    head->rbh_root = oright;
    <D.4804>:
    oright->entry.rbe_left = tmp;
    tmp->entry.rbe_parent = oright;
    _74 = oright->entry.rbe_parent;
    if (_74 != 0B) goto <D.4805>; else goto <D.4806>;
    <D.4805>:
    <D.4806>:
    tmp = parent->entry.rbe_left;
  }
  <D.4793>:
  _75 = parent->entry.rbe_color;
  tmp->entry.rbe_color = _75;
  parent->entry.rbe_color = 0;
  _76 = tmp->entry.rbe_left;
  if (_76 != 0B) goto <D.4807>; else goto <D.4808>;
  <D.4807>:
  _77 = tmp->entry.rbe_left;
  _77->entry.rbe_color = 0;
  <D.4808>:
  tmp = parent->entry.rbe_left;
  _78 = tmp->entry.rbe_right;
  parent->entry.rbe_left = _78;
  _79 = parent->entry.rbe_left;
  if (_79 != 0B) goto <D.4809>; else goto <D.4810>;
  <D.4809>:
  _80 = tmp->entry.rbe_right;
  _80->entry.rbe_parent = parent;
  <D.4810>:
  _81 = parent->entry.rbe_parent;
  tmp->entry.rbe_parent = _81;
  _82 = tmp->entry.rbe_parent;
  if (_82 != 0B) goto <D.4811>; else goto <D.4812>;
  <D.4811>:
  _83 = parent->entry.rbe_parent;
  _84 = _83->entry.rbe_left;
  if (parent == _84) goto <D.4813>; else goto <D.4814>;
  <D.4813>:
  _85 = parent->entry.rbe_parent;
  _85->entry.rbe_left = tmp;
  goto <D.4815>;
  <D.4814>:
  _86 = parent->entry.rbe_parent;
  _86->entry.rbe_right = tmp;
  <D.4815>:
  goto <D.4816>;
  <D.4812>:
  head->rbh_root = tmp;
  <D.4816>:
  tmp->entry.rbe_right = parent;
  parent->entry.rbe_parent = tmp;
  _87 = tmp->entry.rbe_parent;
  if (_87 != 0B) goto <D.4817>; else goto <D.4818>;
  <D.4817>:
  <D.4818>:
  elm = head->rbh_root;
  goto <D.4317>;
  <D.4789>:
  <D.4773>:
  <D.4320>:
  if (elm == 0B) goto <D.4819>; else goto <D.4820>;
  <D.4820>:
  _88 = elm->entry.rbe_color;
  if (_88 == 0) goto <D.4819>; else goto <D.4317>;
  <D.4819>:
  _89 = head->rbh_root;
  if (elm != _89) goto <D.4319>; else goto <D.4317>;
  <D.4317>:
  if (elm != 0B) goto <D.4821>; else goto <D.4822>;
  <D.4821>:
  elm->entry.rbe_color = 0;
  <D.4822>:
}


winlinks_RB_INSERT (struct winlinks * head, struct winlink * elm)
{
  struct winlink * D.4829;
  struct winlink * tmp;
  struct winlink * parent;
  int comp;

  parent = 0B;
  comp = 0;
  tmp = head->rbh_root;
  goto <D.4329>;
  <D.4328>:
  parent = tmp;
  comp = winlink_cmp (elm, parent);
  if (comp < 0) goto <D.4823>; else goto <D.4824>;
  <D.4823>:
  tmp = tmp->entry.rbe_left;
  goto <D.4825>;
  <D.4824>:
  if (comp > 0) goto <D.4826>; else goto <D.4827>;
  <D.4826>:
  tmp = tmp->entry.rbe_right;
  goto <D.4828>;
  <D.4827>:
  D.4829 = tmp;
  return D.4829;
  <D.4828>:
  <D.4825>:
  <D.4329>:
  if (tmp != 0B) goto <D.4328>; else goto <D.4330>;
  <D.4330>:
  elm->entry.rbe_parent = parent;
  elm->entry.rbe_right = 0B;
  _1 = elm->entry.rbe_right;
  elm->entry.rbe_left = _1;
  elm->entry.rbe_color = 1;
  if (parent != 0B) goto <D.4830>; else goto <D.4831>;
  <D.4830>:
  if (comp < 0) goto <D.4832>; else goto <D.4833>;
  <D.4832>:
  parent->entry.rbe_left = elm;
  goto <D.4834>;
  <D.4833>:
  parent->entry.rbe_right = elm;
  <D.4834>:
  goto <D.4835>;
  <D.4831>:
  head->rbh_root = elm;
  <D.4835>:
  winlinks_RB_INSERT_COLOR (head, elm);
  D.4829 = 0B;
  return D.4829;
}


winlinks_RB_REMOVE (struct winlinks * head, struct winlink * elm)
{
  struct winlink * D.4873;
  struct winlink * child;
  struct winlink * parent;
  struct winlink * old;
  int color;
  void color = <<< error >>>;

  old = elm;
  _1 = elm->entry.rbe_left;
  if (_1 == 0B) goto <D.4837>; else goto <D.4838>;
  <D.4837>:
  child = elm->entry.rbe_right;
  goto <D.4839>;
  <D.4838>:
  _2 = elm->entry.rbe_right;
  if (_2 == 0B) goto <D.4840>; else goto <D.4841>;
  <D.4840>:
  child = elm->entry.rbe_left;
  goto <D.4842>;
  <D.4841>:
  {
    struct winlink * left;

    elm = elm->entry.rbe_right;
    goto <D.4341>;
    <D.4340>:
    elm = left;
    <D.4341>:
    left = elm->entry.rbe_left;
    if (left != 0B) goto <D.4340>; else goto <D.4342>;
    <D.4342>:
    child = elm->entry.rbe_right;
    parent = elm->entry.rbe_parent;
    color = elm->entry.rbe_color;
    if (child != 0B) goto <D.4843>; else goto <D.4844>;
    <D.4843>:
    child->entry.rbe_parent = parent;
    <D.4844>:
    if (parent != 0B) goto <D.4845>; else goto <D.4846>;
    <D.4845>:
    _3 = parent->entry.rbe_left;
    if (elm == _3) goto <D.4847>; else goto <D.4848>;
    <D.4847>:
    parent->entry.rbe_left = child;
    goto <D.4849>;
    <D.4848>:
    parent->entry.rbe_right = child;
    <D.4849>:
    goto <D.4850>;
    <D.4846>:
    head->rbh_root = child;
    <D.4850>:
    _4 = elm->entry.rbe_parent;
    if (old == _4) goto <D.4851>; else goto <D.4852>;
    <D.4851>:
    parent = elm;
    <D.4852>:
    elm->entry = old->entry;
    _5 = old->entry.rbe_parent;
    if (_5 != 0B) goto <D.4853>; else goto <D.4854>;
    <D.4853>:
    _6 = old->entry.rbe_parent;
    _7 = _6->entry.rbe_left;
    if (old == _7) goto <D.4855>; else goto <D.4856>;
    <D.4855>:
    _8 = old->entry.rbe_parent;
    _8->entry.rbe_left = elm;
    goto <D.4857>;
    <D.4856>:
    _9 = old->entry.rbe_parent;
    _9->entry.rbe_right = elm;
    <D.4857>:
    goto <D.4858>;
    <D.4854>:
    head->rbh_root = elm;
    <D.4858>:
    _10 = old->entry.rbe_left;
    _10->entry.rbe_parent = elm;
    _11 = old->entry.rbe_right;
    if (_11 != 0B) goto <D.4859>; else goto <D.4860>;
    <D.4859>:
    _12 = old->entry.rbe_right;
    _12->entry.rbe_parent = elm;
    <D.4860>:
    if (parent != 0B) goto <D.4861>; else goto <D.4862>;
    <D.4861>:
    left = parent;
    <D.4343>:
    left = left->entry.rbe_parent;
    if (left != 0B) goto <D.4343>; else goto <D.4344>;
    <D.4344>:
    <D.4862>:
    goto color;
  }
  <D.4842>:
  <D.4839>:
  parent = elm->entry.rbe_parent;
  color = elm->entry.rbe_color;
  if (child != 0B) goto <D.4863>; else goto <D.4864>;
  <D.4863>:
  child->entry.rbe_parent = parent;
  <D.4864>:
  if (parent != 0B) goto <D.4865>; else goto <D.4866>;
  <D.4865>:
  _13 = parent->entry.rbe_left;
  if (elm == _13) goto <D.4867>; else goto <D.4868>;
  <D.4867>:
  parent->entry.rbe_left = child;
  goto <D.4869>;
  <D.4868>:
  parent->entry.rbe_right = child;
  <D.4869>:
  goto <D.4870>;
  <D.4866>:
  head->rbh_root = child;
  <D.4870>:
  color:
  if (color == 0) goto <D.4871>; else goto <D.4872>;
  <D.4871>:
  winlinks_RB_REMOVE_COLOR (head, parent, child);
  <D.4872>:
  D.4873 = old;
  return D.4873;
}


winlinks_RB_FIND (struct winlinks * head, struct winlink * elm)
{
  struct winlink * D.4881;
  struct winlink * tmp;
  int comp;

  tmp = head->rbh_root;
  goto <D.4353>;
  <D.4352>:
  comp = winlink_cmp (elm, tmp);
  if (comp < 0) goto <D.4875>; else goto <D.4876>;
  <D.4875>:
  tmp = tmp->entry.rbe_left;
  goto <D.4877>;
  <D.4876>:
  if (comp > 0) goto <D.4878>; else goto <D.4879>;
  <D.4878>:
  tmp = tmp->entry.rbe_right;
  goto <D.4880>;
  <D.4879>:
  D.4881 = tmp;
  return D.4881;
  <D.4880>:
  <D.4877>:
  <D.4353>:
  if (tmp != 0B) goto <D.4352>; else goto <D.4354>;
  <D.4354>:
  D.4881 = 0B;
  return D.4881;
}


winlinks_RB_NFIND (struct winlinks * head, struct winlink * elm)
{
  struct winlink * D.4889;
  struct winlink * tmp;
  struct winlink * res;
  int comp;

  tmp = head->rbh_root;
  res = 0B;
  goto <D.4363>;
  <D.4362>:
  comp = winlink_cmp (elm, tmp);
  if (comp < 0) goto <D.4883>; else goto <D.4884>;
  <D.4883>:
  res = tmp;
  tmp = tmp->entry.rbe_left;
  goto <D.4885>;
  <D.4884>:
  if (comp > 0) goto <D.4886>; else goto <D.4887>;
  <D.4886>:
  tmp = tmp->entry.rbe_right;
  goto <D.4888>;
  <D.4887>:
  D.4889 = tmp;
  return D.4889;
  <D.4888>:
  <D.4885>:
  <D.4363>:
  if (tmp != 0B) goto <D.4362>; else goto <D.4364>;
  <D.4364>:
  D.4889 = res;
  return D.4889;
}


winlinks_RB_NEXT (struct winlink * elm)
{
  struct winlink * D.4899;

  _1 = elm->entry.rbe_right;
  if (_1 != 0B) goto <D.4891>; else goto <D.4892>;
  <D.4891>:
  elm = elm->entry.rbe_right;
  goto <D.4369>;
  <D.4368>:
  elm = elm->entry.rbe_left;
  <D.4369>:
  _2 = elm->entry.rbe_left;
  if (_2 != 0B) goto <D.4368>; else goto <D.4370>;
  <D.4370>:
  goto <D.4893>;
  <D.4892>:
  _3 = elm->entry.rbe_parent;
  if (_3 != 0B) goto <D.4896>; else goto <D.4894>;
  <D.4896>:
  _4 = elm->entry.rbe_parent;
  _5 = _4->entry.rbe_left;
  if (elm == _5) goto <D.4897>; else goto <D.4894>;
  <D.4897>:
  elm = elm->entry.rbe_parent;
  goto <D.4895>;
  <D.4894>:
  goto <D.4372>;
  <D.4371>:
  elm = elm->entry.rbe_parent;
  <D.4372>:
  _6 = elm->entry.rbe_parent;
  if (_6 != 0B) goto <D.4898>; else goto <D.4373>;
  <D.4898>:
  _7 = elm->entry.rbe_parent;
  _8 = _7->entry.rbe_right;
  if (elm == _8) goto <D.4371>; else goto <D.4373>;
  <D.4373>:
  elm = elm->entry.rbe_parent;
  <D.4895>:
  <D.4893>:
  D.4899 = elm;
  return D.4899;
}


winlinks_RB_PREV (struct winlink * elm)
{
  struct winlink * D.4909;

  _1 = elm->entry.rbe_left;
  if (_1 != 0B) goto <D.4901>; else goto <D.4902>;
  <D.4901>:
  elm = elm->entry.rbe_left;
  goto <D.4378>;
  <D.4377>:
  elm = elm->entry.rbe_right;
  <D.4378>:
  _2 = elm->entry.rbe_right;
  if (_2 != 0B) goto <D.4377>; else goto <D.4379>;
  <D.4379>:
  goto <D.4903>;
  <D.4902>:
  _3 = elm->entry.rbe_parent;
  if (_3 != 0B) goto <D.4906>; else goto <D.4904>;
  <D.4906>:
  _4 = elm->entry.rbe_parent;
  _5 = _4->entry.rbe_right;
  if (elm == _5) goto <D.4907>; else goto <D.4904>;
  <D.4907>:
  elm = elm->entry.rbe_parent;
  goto <D.4905>;
  <D.4904>:
  goto <D.4381>;
  <D.4380>:
  elm = elm->entry.rbe_parent;
  <D.4381>:
  _6 = elm->entry.rbe_parent;
  if (_6 != 0B) goto <D.4908>; else goto <D.4382>;
  <D.4908>:
  _7 = elm->entry.rbe_parent;
  _8 = _7->entry.rbe_left;
  if (elm == _8) goto <D.4380>; else goto <D.4382>;
  <D.4382>:
  elm = elm->entry.rbe_parent;
  <D.4905>:
  <D.4903>:
  D.4909 = elm;
  return D.4909;
}


winlinks_RB_MINMAX (struct winlinks * head, int val)
{
  struct winlink * D.4914;
  struct winlink * tmp;
  struct winlink * parent;

  tmp = head->rbh_root;
  parent = 0B;
  goto <D.4390>;
  <D.4389>:
  parent = tmp;
  if (val < 0) goto <D.4911>; else goto <D.4912>;
  <D.4911>:
  tmp = tmp->entry.rbe_left;
  goto <D.4913>;
  <D.4912>:
  tmp = tmp->entry.rbe_right;
  <D.4913>:
  <D.4390>:
  if (tmp != 0B) goto <D.4389>; else goto <D.4391>;
  <D.4391>:
  D.4914 = parent;
  return D.4914;
}


xrealloc (void * oldptr, size_t nmemb, size_t size)
{
  void * D.4922;
  size_t newsize;
  void * newptr;

  newsize = nmemb * size;
  if (newsize == 0) goto <D.4916>; else goto <D.4917>;
  <D.4916>:
  printf ("zero size%s", "");
  exit (1);
  <D.4917>:
  _1 = 1073741824 / nmemb;
  if (size > _1) goto <D.4918>; else goto <D.4919>;
  <D.4918>:
  printf ("nmemb * size > SIZE_MAX%s", "");
  exit (1);
  <D.4919>:
  newptr = realloc (oldptr, newsize);
  if (newptr == 0B) goto <D.4920>; else goto <D.4921>;
  <D.4920>:
  printf ("xrealloc failed%s", "");
  exit (1);
  <D.4921>:
  D.4922 = newptr;
  return D.4922;
}


__attribute__((__artificial__, __gnu_inline__, __always_inline__))
printf (const char * restrict __fmt)
{
  int D.4924;

  D.4924 = __printf_chk (1, __fmt, __builtin_va_arg_pack ());
  return D.4924;
}


winlink_find_by_index (struct winlinks * wwl, int idx)
{
  struct winlink * D.4928;
  struct winlink wl;

  try
    {
      if (idx < 0) goto <D.4926>; else goto <D.4927>;
      <D.4926>:
      printf ("bad index%s", "");
      exit (1);
      <D.4927>:
      wl.idx = idx;
      D.4928 = winlinks_RB_FIND (wwl, &wl);
      return D.4928;
    }
  finally
    {
      wl = {CLOBBER};
    }
}


winlink_count (struct winlinks * wwl)
{
  u_int D.4931;
  struct winlink * wl;
  u_int n;

  n = 0;
  wl = winlinks_RB_MINMAX (wwl, -1);
  goto <D.4410>;
  <D.4409>:
  n = n + 1;
  wl = winlinks_RB_NEXT (wl);
  <D.4410>:
  if (wl != 0B) goto <D.4409>; else goto <D.4411>;
  <D.4411>:
  D.4931 = n;
  return D.4931;
}


winlink_next_index (struct winlinks * wwl, int idx)
{
  int D.4935;
  int i;

  i = idx;
  <D.4417>:
  _1 = winlink_find_by_index (wwl, i);
  if (_1 == 0B) goto <D.4933>; else goto <D.4934>;
  <D.4933>:
  D.4935 = i;
  return D.4935;
  <D.4934>:
  if (i == 10000) goto <D.4936>; else goto <D.4937>;
  <D.4936>:
  i = 0;
  goto <D.4938>;
  <D.4937>:
  i = i + 1;
  <D.4938>:
  if (i != idx) goto <D.4417>; else goto <D.4418>;
  <D.4418>:
  D.4935 = -1;
  return D.4935;
}


winlink_find_by_window (struct winlinks * wwl, struct window * w)
{
  struct winlink * D.4942;
  struct winlink * wl;

  wl = winlinks_RB_MINMAX (wwl, -1);
  goto <D.4425>;
  <D.4424>:
  _1 = wl->window;
  if (w == _1) goto <D.4940>; else goto <D.4941>;
  <D.4940>:
  D.4942 = wl;
  return D.4942;
  <D.4941>:
  wl = winlinks_RB_NEXT (wl);
  <D.4425>:
  if (wl != 0B) goto <D.4424>; else goto <D.4426>;
  <D.4426>:
  D.4942 = 0B;
  return D.4942;
}


cmd_find_pane (int arg, struct session * * sp)
{
  struct winlink * D.4946;
  struct session * s;
  struct winlink * wl;
  u_int idx;

  _1 = sessions.num;
  if (_1 == 0) goto <D.4944>; else goto <D.4945>;
  <D.4944>:
  printf ("can\'t establish current session\n");
  D.4946 = 0B;
  return D.4946;
  <D.4945>:
  _2 = sessions.list;
  s = MEM[(struct session * *)_2 + 8B];
  if (sp != 0B) goto <D.4947>; else goto <D.4948>;
  <D.4947>:
  *sp = s;
  <D.4948>:
  if (arg != 0) goto <D.4949>; else goto <D.4950>;
  <D.4949>:
  D.4946 = s->curw;
  return D.4946;
  <D.4950>:
  _3 = s->curw;
  D.4946 = winlinks_RB_NEXT (_3);
  return D.4946;
}


session_has (struct session * s, struct window * w)
{
  int D.4954;
  struct winlink * wl;

  _1 = &s->windows;
  wl = winlinks_RB_MINMAX (_1, -1);
  goto <D.4440>;
  <D.4439>:
  _2 = wl->window;
  if (w == _2) goto <D.4952>; else goto <D.4953>;
  <D.4952>:
  D.4954 = 1;
  return D.4954;
  <D.4953>:
  wl = winlinks_RB_NEXT (wl);
  <D.4440>:
  if (wl != 0B) goto <D.4439>; else goto <D.4441>;
  <D.4441>:
  D.4954 = 0;
  return D.4954;
}


session_group_find (struct session * target)
{
  struct session_group * D.4958;
  struct session_group * sg;
  struct session * s;

  sg = session_groups.tqh_first;
  goto <D.4451>;
  <D.4450>:
  s = sg->sessions.tqh_first;
  goto <D.4448>;
  <D.4447>:
  if (s == target) goto <D.4956>; else goto <D.4957>;
  <D.4956>:
  D.4958 = sg;
  return D.4958;
  <D.4957>:
  s = s->gentry.tqe_next;
  <D.4448>:
  if (s != 0B) goto <D.4447>; else goto <D.4449>;
  <D.4449>:
  sg = sg->entry.tqe_next;
  <D.4451>:
  if (sg != 0B) goto <D.4450>; else goto <D.4452>;
  <D.4452>:
  D.4958 = 0B;
  return D.4958;
}


session_group_add (struct session * target, struct session * s)
{
  struct session_group * sg;

  sg = session_group_find (target);
  if (sg == 0B) goto <D.4960>; else goto <D.4961>;
  <D.4960>:
  sg = malloc (32);
  sg->entry.tqe_next = 0B;
  _1 = session_groups.tqh_last;
  sg->entry.tqe_prev = _1;
  _2 = session_groups.tqh_last;
  *_2 = sg;
  _3 = &sg->entry.tqe_next;
  session_groups.tqh_last = _3;
  sg->sessions.tqh_first = 0B;
  _4 = &sg->sessions.tqh_first;
  sg->sessions.tqh_last = _4;
  target->gentry.tqe_next = 0B;
  _5 = sg->sessions.tqh_last;
  target->gentry.tqe_prev = _5;
  _6 = sg->sessions.tqh_last;
  *_6 = target;
  _7 = &target->gentry.tqe_next;
  sg->sessions.tqh_last = _7;
  <D.4961>:
  s->gentry.tqe_next = 0B;
  _8 = sg->sessions.tqh_last;
  s->gentry.tqe_prev = _8;
  _9 = sg->sessions.tqh_last;
  *_9 = s;
  _10 = &s->gentry.tqe_next;
  sg->sessions.tqh_last = _10;
}


winlink_add (struct winlinks * wwl, struct window * w, int idx)
{
  struct winlink * D.4966;
  struct winlink * wl;

  if (idx < 0) goto <D.4962>; else goto <D.4963>;
  <D.4962>:
  _1 = ~idx;
  idx = winlink_next_index (wwl, _1);
  if (idx == -1) goto <D.4964>; else goto <D.4965>;
  <D.4964>:
  D.4966 = 0B;
  return D.4966;
  <D.4965>:
  goto <D.4967>;
  <D.4963>:
  _2 = winlink_find_by_index (wwl, idx);
  if (_2 != 0B) goto <D.4968>; else goto <D.4969>;
  <D.4968>:
  D.4966 = 0B;
  return D.4966;
  <D.4969>:
  <D.4967>:
  wl = calloc (1, 136);
  wl->idx = idx;
  wl->window = w;
  winlinks_RB_INSERT (wwl, wl);
  _3 = w->references;
  _4 = _3 + 1;
  w->references = _4;
  D.4966 = wl;
  return D.4966;
}


window_index (struct window * s, u_int * i)
{
  int D.4973;

  *i = 0;
  goto <D.4469>;
  <D.4468>:
  _1 = windows.list;
  _2 = *i;
  _3 = (long unsigned int) _2;
  _4 = _3 * 8;
  _5 = _1 + _4;
  _6 = *_5;
  if (s == _6) goto <D.4971>; else goto <D.4972>;
  <D.4971>:
  D.4973 = 0;
  return D.4973;
  <D.4972>:
  _7 = *i;
  _8 = _7 + 1;
  *i = _8;
  <D.4469>:
  _9 = *i;
  _10 = windows.num;
  if (_9 < _10) goto <D.4468>; else goto <D.4470>;
  <D.4470>:
  D.4973 = -1;
  return D.4973;
}


session_group_remove (struct session * s)
{
  struct session_group * sg;

  sg = session_group_find (s);
  if (sg == 0B) goto <D.4975>; else goto <D.4976>;
  <D.4975>:
  return;
  <D.4976>:
  _1 = s->gentry.tqe_next;
  if (_1 != 0B) goto <D.4977>; else goto <D.4978>;
  <D.4977>:
  _2 = s->gentry.tqe_next;
  _3 = s->gentry.tqe_prev;
  _2->gentry.tqe_prev = _3;
  goto <D.4979>;
  <D.4978>:
  _4 = s->gentry.tqe_prev;
  sg->sessions.tqh_last = _4;
  <D.4979>:
  _5 = s->gentry.tqe_prev;
  _6 = s->gentry.tqe_next;
  *_5 = _6;
  _7 = sg->sessions.tqh_first;
  _8 = _7->gentry.tqe_next;
  if (_8 == 0B) goto <D.4980>; else goto <D.4981>;
  <D.4980>:
  _9 = sg->sessions.tqh_first;
  _10 = _9->gentry.tqe_next;
  if (_10 != 0B) goto <D.4982>; else goto <D.4983>;
  <D.4982>:
  _11 = sg->sessions.tqh_first;
  _12 = sg->sessions.tqh_first;
  _13 = _12->gentry.tqe_next;
  _14 = _11->gentry.tqe_prev;
  _13->gentry.tqe_prev = _14;
  goto <D.4984>;
  <D.4983>:
  _15 = sg->sessions.tqh_first;
  _16 = _15->gentry.tqe_prev;
  sg->sessions.tqh_last = _16;
  <D.4984>:
  _17 = sg->sessions.tqh_first;
  _18 = sg->sessions.tqh_first;
  _19 = _18->gentry.tqe_prev;
  _20 = _17->gentry.tqe_next;
  *_19 = _20;
  <D.4981>:
  _21 = sg->sessions.tqh_first;
  if (_21 == 0B) goto <D.4985>; else goto <D.4986>;
  <D.4985>:
  _22 = sg->entry.tqe_next;
  if (_22 != 0B) goto <D.4987>; else goto <D.4988>;
  <D.4987>:
  _23 = sg->entry.tqe_next;
  _24 = sg->entry.tqe_prev;
  _23->entry.tqe_prev = _24;
  goto <D.4989>;
  <D.4988>:
  _25 = sg->entry.tqe_prev;
  session_groups.tqh_last = _25;
  <D.4989>:
  _26 = sg->entry.tqe_prev;
  _27 = sg->entry.tqe_next;
  *_26 = _27;
  free (sg);
  <D.4986>:
}


session_find (const char * name)
{
  struct session * D.4995;
  struct session * s;
  u_int i;

  i = 0;
  goto <D.4481>;
  <D.4480>:
  _1 = sessions.list;
  _2 = (long unsigned int) i;
  _3 = _2 * 8;
  _4 = _1 + _3;
  s = *_4;
  if (s != 0B) goto <D.4991>; else goto <D.4992>;
  <D.4991>:
  _5 = s->name;
  _6 = strcmp (_5, name);
  if (_6 == 0) goto <D.4993>; else goto <D.4994>;
  <D.4993>:
  D.4995 = s;
  return D.4995;
  <D.4994>:
  <D.4992>:
  i = i + 1;
  <D.4481>:
  _7 = sessions.num;
  if (i < _7) goto <D.4480>; else goto <D.4482>;
  <D.4482>:
  D.4995 = 0B;
  return D.4995;
}


session_index (struct session * s, u_int * i)
{
  int D.4999;

  *i = 0;
  goto <D.4488>;
  <D.4487>:
  _1 = sessions.list;
  _2 = *i;
  _3 = (long unsigned int) _2;
  _4 = _3 * 8;
  _5 = _1 + _4;
  _6 = *_5;
  if (s == _6) goto <D.4997>; else goto <D.4998>;
  <D.4997>:
  D.4999 = 0;
  return D.4999;
  <D.4998>:
  _7 = *i;
  _8 = _7 + 1;
  *i = _8;
  <D.4488>:
  _9 = *i;
  _10 = sessions.num;
  if (_9 < _10) goto <D.4487>; else goto <D.4489>;
  <D.4489>:
  D.4999 = -1;
  return D.4999;
}


winlink_stack_remove (struct winlink_stack * stack, struct winlink * wl)
{
  struct winlink * wl2;

  if (wl == 0B) goto <D.5001>; else goto <D.5002>;
  <D.5001>:
  return;
  <D.5002>:
  wl2 = stack->tqh_first;
  goto <D.4496>;
  <D.4495>:
  if (wl2 == wl) goto <D.5003>; else goto <D.5004>;
  <D.5003>:
  _1 = wl->sentry.tqe_next;
  if (_1 != 0B) goto <D.5005>; else goto <D.5006>;
  <D.5005>:
  _2 = wl->sentry.tqe_next;
  _3 = wl->sentry.tqe_prev;
  _2->sentry.tqe_prev = _3;
  goto <D.5007>;
  <D.5006>:
  _4 = wl->sentry.tqe_prev;
  stack->tqh_last = _4;
  <D.5007>:
  _5 = wl->sentry.tqe_prev;
  _6 = wl->sentry.tqe_next;
  *_5 = _6;
  return;
  <D.5004>:
  wl2 = wl2->sentry.tqe_next;
  <D.4496>:
  if (wl2 != 0B) goto <D.4495>; else goto <D.4497>;
  <D.4497>:
}


winlink_stack_push (struct winlink_stack * stack, struct winlink * wl)
{
  if (wl == 0B) goto <D.5009>; else goto <D.5010>;
  <D.5009>:
  return;
  <D.5010>:
  winlink_stack_remove (stack, wl);
  _1 = stack->tqh_first;
  wl->sentry.tqe_next = _1;
  _2 = wl->sentry.tqe_next;
  if (_2 != 0B) goto <D.5011>; else goto <D.5012>;
  <D.5011>:
  _3 = stack->tqh_first;
  _4 = &wl->sentry.tqe_next;
  _3->sentry.tqe_prev = _4;
  goto <D.5013>;
  <D.5012>:
  _5 = &wl->sentry.tqe_next;
  stack->tqh_last = _5;
  <D.5013>:
  stack->tqh_first = wl;
  _6 = &stack->tqh_first;
  wl->sentry.tqe_prev = _6;
}


window_destroy (struct window * w)
{
  u_int i;

  try
    {
      _1 = window_index (w, &i);
      if (_1 != 0) goto <D.5015>; else goto <D.5016>;
      <D.5015>:
      printf ("index not found%s\n", "");
      exit (1);
      <D.5016>:
      _2 = windows.list;
      i.0_3 = i;
      _4 = (long unsigned int) i.0_3;
      _5 = _4 * 8;
      _6 = _2 + _5;
      *_6 = 0B;
      goto <D.4507>;
      <D.4506>:
      _7 = windows.num;
      if (_7 > 1) goto <D.5017>; else goto <D.5018>;
      <D.5017>:
      _8 = windows.num;
      _9 = _8 + 4294967295;
      windows.num = _9;
      goto <D.5019>;
      <D.5018>:
      _10 = windows.list;
      free (_10);
      windows.num = 0;
      windows.list = 0B;
      windows.space = 0;
      <D.5019>:
      <D.4507>:
      _11 = windows.num;
      if (_11 != 0) goto <D.5020>; else goto <D.4508>;
      <D.5020>:
      _12 = windows.list;
      _13 = windows.num;
      _14 = _13 + 4294967295;
      _15 = (long unsigned int) _14;
      _16 = _15 * 8;
      _17 = _12 + _16;
      _18 = *_17;
      if (_18 == 0B) goto <D.4506>; else goto <D.4508>;
      <D.4508>:
      _19 = w->name;
      if (_19 != 0B) goto <D.5021>; else goto <D.5022>;
      <D.5021>:
      _20 = w->name;
      free (_20);
      <D.5022>:
      free (w);
    }
  finally
    {
      i = {CLOBBER};
    }
}


winlink_remove (struct winlinks * wwl, struct winlink * wl)
{
  struct window * w;

  w = wl->window;
  winlinks_RB_REMOVE (wwl, wl);
  _1 = wl->status_text;
  if (_1 != 0B) goto <D.5023>; else goto <D.5024>;
  <D.5023>:
  _2 = wl->status_text;
  free (_2);
  <D.5024>:
  free (wl);
  _3 = w->references;
  if (_3 == 0) goto <D.5025>; else goto <D.5026>;
  <D.5025>:
  printf ("bad reference count%s\n", "");
  exit (1);
  <D.5026>:
  _4 = w->references;
  _5 = _4 + 4294967295;
  w->references = _5;
  _6 = w->references;
  if (_6 == 0) goto <D.5027>; else goto <D.5028>;
  <D.5027>:
  window_destroy (w);
  <D.5028>:
}


session_group_synchronize1 (struct session * target, struct session * s)
{
  struct winlinks old_windows;
  struct winlinks * ww;
  struct winlink_stack old_lastw;
  struct winlink * wl;
  struct winlink * wl2;
  typedef struct session_alert struct struct session_alert;
  struct session_alert * sa;

  try
    {
      ww = &target->windows;
      _1 = ww->rbh_root;
      if (_1 == 0B) goto <D.5029>; else goto <D.5030>;
      <D.5029>:
      return;
      <D.5030>:
      _2 = &s->windows;
      memcpy (&old_windows, _2, 8);
      s->windows.rbh_root = 0B;
      wl = winlinks_RB_MINMAX (ww, -1);
      goto <D.4526>;
      <D.4525>:
      _3 = wl->idx;
      _4 = wl->window;
      _5 = &s->windows;
      winlink_add (_5, _4, _3);
      wl = winlinks_RB_NEXT (wl);
      <D.4526>:
      if (wl != 0B) goto <D.4525>; else goto <D.4527>;
      <D.4527>:
      _6 = &s->lastw;
      memcpy (&old_lastw, _6, 16);
      s->lastw.tqh_first = 0B;
      _7 = &s->lastw.tqh_first;
      s->lastw.tqh_last = _7;
      wl = old_lastw.tqh_first;
      goto <D.4529>;
      <D.4528>:
      _8 = wl->idx;
      _9 = &s->windows;
      wl2 = winlink_find_by_index (_9, _8);
      if (wl2 != 0B) goto <D.5031>; else goto <D.5032>;
      <D.5031>:
      wl2->sentry.tqe_next = 0B;
      _10 = s->lastw.tqh_last;
      wl2->sentry.tqe_prev = _10;
      _11 = s->lastw.tqh_last;
      *_11 = wl2;
      _12 = &wl2->sentry.tqe_next;
      s->lastw.tqh_last = _12;
      <D.5032>:
      wl = wl->sentry.tqe_next;
      <D.4529>:
      if (wl != 0B) goto <D.4528>; else goto <D.4530>;
      <D.4530>:
      _13 = s->lastw.tqh_first;
      s->curw = _13;
      goto <D.4532>;
      <D.4531>:
      wl = old_windows.rbh_root;
      winlink_remove (&old_windows, wl);
      <D.4532>:
      _14 = old_windows.rbh_root;
      if (_14 != 0B) goto <D.4531>; else goto <D.4533>;
      <D.4533>:
    }
  finally
    {
      old_windows = {CLOBBER};
      old_lastw = {CLOBBER};
    }
}


__attribute__((__artificial__, __gnu_inline__, __always_inline__, __nothrow__, __leaf__))
memcpy (void * restrict __dest, const void * restrict __src, size_t __len)
{
  void * D.5036;

  _1 = __builtin_object_size (__dest, 0);
  D.5036 = __builtin___memcpy_chk (__dest, __src, __len, _1);
  return D.5036;
}


session_group_synchronize_to (struct session * s)
{
  struct session_group * sg;
  struct session * target;

  sg = session_group_find (s);
  if (sg == 0B) goto <D.5038>; else goto <D.5039>;
  <D.5038>:
  return;
  <D.5039>:
  target = 0B;
  target = sg->sessions.tqh_first;
  goto <D.4541>;
  <D.4540>:
  if (target != s) goto <D.4539>; else goto <D.5040>;
  <D.5040>:
  target = target->gentry.tqe_next;
  <D.4541>:
  if (target != 0B) goto <D.4540>; else goto <D.4539>;
  <D.4539>:
  session_group_synchronize1 (target, s);
}


session_group_synchronize_from (struct session * target)
{
  struct session_group * sg;
  struct session * s;

  sg = session_group_find (target);
  if (sg == 0B) goto <D.5042>; else goto <D.5043>;
  <D.5042>:
  return;
  <D.5043>:
  s = sg->sessions.tqh_first;
  goto <D.4548>;
  <D.4547>:
  if (s != target) goto <D.5044>; else goto <D.5045>;
  <D.5044>:
  session_group_synchronize1 (target, s);
  <D.5045>:
  s = s->gentry.tqe_next;
  <D.4548>:
  if (s != 0B) goto <D.4547>; else goto <D.4549>;
  <D.4549>:
}


session_destroy (struct session * s)
{
  u_int i;

  try
    {
      _1 = s->name;
      printf ("session %s destroyed\n", _1);
      _2 = session_index (s, &i);
      if (_2 != 0) goto <D.5047>; else goto <D.5048>;
      <D.5047>:
      printf ("session not found%s\n", "");
      exit (1);
      <D.5048>:
      _3 = sessions.list;
      i.1_4 = i;
      _5 = (long unsigned int) i.1_4;
      _6 = _5 * 8;
      _7 = _3 + _6;
      *_7 = 0B;
      goto <D.4555>;
      <D.4554>:
      _8 = sessions.num;
      if (_8 > 1) goto <D.5049>; else goto <D.5050>;
      <D.5049>:
      _9 = sessions.num;
      _10 = _9 + 4294967295;
      sessions.num = _10;
      goto <D.5051>;
      <D.5050>:
      _11 = sessions.list;
      free (_11);
      sessions.num = 0;
      sessions.list = 0B;
      sessions.space = 0;
      <D.5051>:
      <D.4555>:
      _12 = sessions.num;
      if (_12 != 0) goto <D.5052>; else goto <D.4556>;
      <D.5052>:
      _13 = sessions.list;
      _14 = sessions.num;
      _15 = _14 + 4294967295;
      _16 = (long unsigned int) _15;
      _17 = _16 * 8;
      _18 = _13 + _17;
      _19 = *_18;
      if (_19 == 0B) goto <D.4554>; else goto <D.4556>;
      <D.4556>:
      session_group_remove (s);
      goto <D.4558>;
      <D.4557>:
      _20 = s->lastw.tqh_first;
      _21 = &s->lastw;
      winlink_stack_remove (_21, _20);
      <D.4558>:
      _22 = s->lastw.tqh_first;
      if (_22 != 0B) goto <D.4557>; else goto <D.4559>;
      <D.4559>:
      goto <D.4561>;
      <D.4560>:
      _23 = s->windows.rbh_root;
      _24 = &s->windows;
      winlink_remove (_24, _23);
      <D.4561>:
      _25 = s->windows.rbh_root;
      if (_25 != 0B) goto <D.4560>; else goto <D.4562>;
      <D.4562>:
      _26 = s->name;
      free (_26);
      free (s);
    }
  finally
    {
      i = {CLOBBER};
    }
}


session_detach (struct session * s, struct winlink * wl)
{
  int D.5055;

  _1 = &s->lastw;
  winlink_stack_remove (_1, wl);
  _2 = &s->windows;
  winlink_remove (_2, wl);
  session_group_synchronize_from (s);
  _3 = s->windows.rbh_root;
  if (_3 == 0B) goto <D.5053>; else goto <D.5054>;
  <D.5053>:
  session_destroy (s);
  D.5055 = 1;
  return D.5055;
  <D.5054>:
  D.5055 = 0;
  return D.5055;
}


server_destroy_session_group (struct session * s)
{
  struct session_group * sg;

  sg = session_group_find (s);
  if (sg == 0B) goto <D.5057>; else goto <D.5058>;
  <D.5057>:
  return;
  <D.5058>:
  _1 = sg->entry.tqe_next;
  if (_1 != 0B) goto <D.5059>; else goto <D.5060>;
  <D.5059>:
  _2 = sg->entry.tqe_next;
  _3 = sg->entry.tqe_prev;
  _2->entry.tqe_prev = _3;
  goto <D.5061>;
  <D.5060>:
  _4 = sg->entry.tqe_prev;
  session_groups.tqh_last = _4;
  <D.5061>:
  _5 = sg->entry.tqe_prev;
  _6 = sg->entry.tqe_next;
  *_5 = _6;
  free (sg);
}


server_kill_window (struct window * w)
{
  struct session * s;
  struct winlink * wl;
  u_int i;

  i = 0;
  goto <D.4582>;
  <D.4581>:
  _1 = sessions.list;
  _2 = (long unsigned int) i;
  _3 = _2 * 8;
  _4 = _1 + _3;
  s = *_4;
  if (s == 0B) goto <D.5063>; else goto <D.5065>;
  <D.5065>:
  _5 = session_has (s, w);
  if (_5 == 0) goto <D.5063>; else goto <D.5064>;
  <D.5063>:
  // predicted unlikely by continue predictor.
  goto <D.4577>;
  <D.5064>:
  goto <D.4580>;
  <D.4579>:
  _6 = session_detach (s, wl);
  if (_6 != 0) goto <D.5066>; else goto <D.5067>;
  <D.5066>:
  server_destroy_session_group (s);
  goto <D.4578>;
  <D.5067>:
  <D.4580>:
  _7 = &s->windows;
  wl = winlink_find_by_window (_7, w);
  if (wl != 0B) goto <D.4579>; else goto <D.4578>;
  <D.4578>:
  <D.4577>:
  i = i + 1;
  <D.4582>:
  _8 = sessions.num;
  if (i < _8) goto <D.4581>; else goto <D.4583>;
  <D.4583>:
}


session_select (struct session * s, int idx)
{
  int D.5070;
  struct winlink * wl;

  _1 = &s->windows;
  wl = winlink_find_by_index (_1, idx);
  if (wl == 0B) goto <D.5068>; else goto <D.5069>;
  <D.5068>:
  D.5070 = -1;
  return D.5070;
  <D.5069>:
  _2 = s->curw;
  if (wl == _2) goto <D.5071>; else goto <D.5072>;
  <D.5071>:
  D.5070 = 1;
  return D.5070;
  <D.5072>:
  _3 = &s->lastw;
  winlink_stack_remove (_3, wl);
  _4 = s->curw;
  _5 = &s->lastw;
  winlink_stack_push (_5, _4);
  s->curw = wl;
  D.5070 = 0;
  return D.5070;
}


join_pane_exec ()
{
  int D.5076;
  struct session * dst_s;
  struct winlink * src_wl;
  struct winlink * dst_wl;
  struct window * src_w;
  struct window * dst_w;

  try
    {
      dst_wl = cmd_find_pane (0, &dst_s);
      if (dst_wl == 0B) goto <D.5074>; else goto <D.5075>;
      <D.5074>:
      D.5076 = -1;
      return D.5076;
      <D.5075>:
      dst_w = dst_wl->window;
      src_wl = cmd_find_pane (1, 0B);
      if (src_wl == 0B) goto <D.5077>; else goto <D.5078>;
      <D.5077>:
      D.5076 = -1;
      return D.5076;
      <D.5078>:
      src_w = src_wl->window;
      if (src_w == dst_w) goto <D.5079>; else goto <D.5080>;
      <D.5079>:
      printf ("can\'t join a pane to its own window\n");
      D.5076 = -1;
      return D.5076;
      <D.5080>:
      server_kill_window (src_w);
      _1 = dst_wl->idx;
      dst_s.2_2 = dst_s;
      session_select (dst_s.2_2, _1);
      D.5076 = 0;
      return D.5076;
    }
  finally
    {
      dst_s = {CLOBBER};
    }
}


window_create1 (u_int sx, u_int sy)
{
  struct window * D.5093;
  struct window * w;
  u_int i;

  w = malloc (88);
  w->name = 0B;
  w->flags = 0;
  w->active = 0B;
  w->lastlayout = -1;
  w->layout_root = 0B;
  w->sx = sx;
  w->sy = sy;
  i = 0;
  goto <D.4605>;
  <D.4604>:
  _1 = windows.list;
  _2 = (long unsigned int) i;
  _3 = _2 * 8;
  _4 = _1 + _3;
  _5 = *_4;
  if (_5 == 0B) goto <D.5083>; else goto <D.5084>;
  <D.5083>:
  _6 = windows.list;
  _7 = (long unsigned int) i;
  _8 = _7 * 8;
  _9 = _6 + _8;
  *_9 = w;
  goto <D.4603>;
  <D.5084>:
  i = i + 1;
  <D.4605>:
  _10 = windows.num;
  if (i < _10) goto <D.4604>; else goto <D.4603>;
  <D.4603>:
  _11 = windows.num;
  if (i == _11) goto <D.5085>; else goto <D.5086>;
  <D.5085>:
  _12 = windows.num;
  if (_12 > 1073741823) goto <D.5087>; else goto <D.5088>;
  <D.5087>:
  printf ("number too big%s", "");
  exit (1);
  <D.5088>:
  _13 = windows.num;
  _14 = _13 + 1;
  _15 = 1073741824 / _14;
  if (_15 <= 7) goto <D.5089>; else goto <D.5090>;
  <D.5089>:
  printf ("size too big%s", "");
  exit (1);
  <D.5090>:
  _16 = windows.space;
  if (_16 == 0) goto <D.5091>; else goto <D.5092>;
  <D.5091>:
  windows.space = 80;
  _17 = windows.space;
  _18 = windows.list;
  _19 = xrealloc (_18, 1, _17);
  windows.list = _19;
  <D.5092>:
  goto <D.4607>;
  <D.4606>:
  _20 = windows.space;
  _21 = windows.list;
  _22 = xrealloc (_21, 2, _20);
  windows.list = _22;
  _23 = windows.space;
  _24 = _23 * 2;
  windows.space = _24;
  <D.4607>:
  _25 = windows.space;
  _26 = windows.num;
  _27 = _26 + 1;
  _28 = (long unsigned int) _27;
  _29 = _28 * 8;
  if (_25 <= _29) goto <D.4606>; else goto <D.4608>;
  <D.4608>:
  _30 = windows.list;
  _31 = windows.num;
  _32 = (long unsigned int) _31;
  _33 = _32 * 8;
  _34 = _30 + _33;
  *_34 = w;
  _35 = windows.num;
  _36 = _35 + 1;
  windows.num = _36;
  <D.5086>:
  w->references = 0;
  D.5093 = w;
  return D.5093;
}


session_attach (struct session * s, struct window * w, int idx, char * * cause)
{
  struct winlink * D.5097;
  struct winlink * wl;

  _1 = &s->windows;
  wl = winlink_add (_1, w, idx);
  if (wl == 0B) goto <D.5095>; else goto <D.5096>;
  <D.5095>:
  printf ("index in use: %d\n", idx);
  <D.5096>:
  session_group_synchronize_from (s);
  D.5097 = wl;
  return D.5097;
}


session_new (struct session * s, const char * name, const char * cmd, const char * cwd, int idx, char * * cause)
{
  struct winlink * D.5101;
  struct window * w;
  const char * shell;
  u_int hlimit;

  _1 = s->sy;
  _2 = s->sx;
  w = window_create1 (_2, _1);
  if (w == 0B) goto <D.5099>; else goto <D.5100>;
  <D.5099>:
  D.5101 = 0B;
  return D.5101;
  <D.5100>:
  D.5101 = session_attach (s, w, idx, cause);
  return D.5101;
}


session_create (const char * name, const char * cmd, const char * cwd, struct environ * env, struct termios * tio, int idx, u_int sx, u_int sy, char * * cause)
{
  struct session * D.5119;
  struct session * s;
  u_int i;

  s = malloc (112);
  s->references = 0;
  s->flags = 0;
  s->curw = 0B;
  s->lastw.tqh_first = 0B;
  _1 = &s->lastw.tqh_first;
  s->lastw.tqh_last = _1;
  s->windows.rbh_root = 0B;
  s->tio = 0B;
  s->sx = sx;
  s->sy = sy;
  i = 0;
  goto <D.4642>;
  <D.4641>:
  _2 = sessions.list;
  _3 = (long unsigned int) i;
  _4 = _3 * 8;
  _5 = _2 + _4;
  _6 = *_5;
  if (_6 == 0B) goto <D.5103>; else goto <D.5104>;
  <D.5103>:
  _7 = sessions.list;
  _8 = (long unsigned int) i;
  _9 = _8 * 8;
  _10 = _7 + _9;
  *_10 = s;
  goto <D.4640>;
  <D.5104>:
  i = i + 1;
  <D.4642>:
  _11 = sessions.num;
  if (i < _11) goto <D.4641>; else goto <D.4640>;
  <D.4640>:
  _12 = sessions.num;
  if (i == _12) goto <D.5105>; else goto <D.5106>;
  <D.5105>:
  _13 = sessions.num;
  if (_13 > 1073741823) goto <D.5107>; else goto <D.5108>;
  <D.5107>:
  printf ("number too big%s", "");
  exit (1);
  <D.5108>:
  _14 = sessions.num;
  _15 = _14 + 1;
  _16 = 1073741824 / _15;
  if (_16 <= 7) goto <D.5109>; else goto <D.5110>;
  <D.5109>:
  printf ("size too big%s", "");
  exit (1);
  <D.5110>:
  _17 = sessions.space;
  if (_17 == 0) goto <D.5111>; else goto <D.5112>;
  <D.5111>:
  sessions.space = 80;
  _18 = sessions.space;
  _19 = sessions.list;
  _20 = xrealloc (_19, 1, _18);
  sessions.list = _20;
  <D.5112>:
  goto <D.4644>;
  <D.4643>:
  _21 = sessions.space;
  _22 = sessions.list;
  _23 = xrealloc (_22, 2, _21);
  sessions.list = _23;
  _24 = sessions.space;
  _25 = _24 * 2;
  sessions.space = _25;
  <D.4644>:
  _26 = sessions.space;
  _27 = sessions.num;
  _28 = _27 + 1;
  _29 = (long unsigned int) _28;
  _30 = _29 * 8;
  if (_26 <= _30) goto <D.4643>; else goto <D.4645>;
  <D.4645>:
  _31 = sessions.list;
  _32 = sessions.num;
  _33 = (long unsigned int) _32;
  _34 = _33 * 8;
  _35 = _31 + _34;
  *_35 = s;
  _36 = sessions.num;
  _37 = _36 + 1;
  sessions.num = _37;
  <D.5106>:
  if (name == 0B) goto <D.5113>; else goto <D.5114>;
  <D.5113>:
  printf ("no name%s\n", "");
  exit (1);
  <D.5114>:
  _38 = strdup (name);
  s->name = _38;
  if (cmd != 0B) goto <D.5115>; else goto <D.5116>;
  <D.5115>:
  _39 = session_new (s, 0B, cmd, cwd, idx, cause);
  if (_39 == 0B) goto <D.5117>; else goto <D.5118>;
  <D.5117>:
  session_destroy (s);
  D.5119 = 0B;
  return D.5119;
  <D.5118>:
  _40 = s->windows.rbh_root;
  _41 = _40->idx;
  session_select (s, _41);
  <D.5116>:
  _42 = s->name;
  printf ("session %s created\n", _42);
  D.5119 = s;
  return D.5119;
}


main (int argc, char * * argv)
{
  int D.5130;

  {
    struct session * s;
    struct session * groupwith;
    struct window * w;
    char * target;
    char * cmd;
    char * name;
    char * cause;
    int idx;
    int sx;
    int sy;

    try
      {
        idx = 0;
        windows.num = 0;
        windows.list = 0B;
        windows.space = 0;
        sessions.num = 0;
        sessions.list = 0B;
        sessions.space = 0;
        session_groups.tqh_first = 0B;
        session_groups.tqh_last = &session_groups.tqh_first;
        {
          int i;

          i = 0;
          goto <D.4662>;
          <D.4661>:
          _1 = (long unsigned int) i;
          _2 = _1 * 8;
          _3 = argv + _2;
          _4 = *_3;
          _5 = *_4;
          if (_5 == 116) goto <D.5123>; else goto <D.5121>;
          <D.5123>:
          if (i > 0) goto <D.5124>; else goto <D.5121>;
          <D.5124>:
          _6 = (long unsigned int) i;
          _7 = _6 * 8;
          _8 = _7 + 18446744073709551608;
          _9 = argv + _8;
          _10 = *_9;
          target = strdup (_10);
          goto <D.5122>;
          <D.5121>:
          target = 0B;
          <D.5122>:
          groupwith = session_find (target);
          if (target == 0B) goto <D.5125>; else goto <D.5126>;
          <D.5125>:
          cmd = strdup ("cmd");
          goto <D.5127>;
          <D.5126>:
          cmd = 0B;
          <D.5127>:
          free (target);
          _11 = (long unsigned int) i;
          _12 = _11 * 8;
          _13 = argv + _12;
          _14 = *_13;
          name = strdup (_14);
          sy.3_15 = (unsigned int) sy;
          sx.4_16 = (unsigned int) sx;
          idx.5_17 = idx;
          idx = idx.5_17 + 1;
          s = session_create (name, cmd, "cwd", 0B, 0B, idx.5_17, sx.4_16, sy.3_15, &cause);
          sy.6_18 = (unsigned int) sy;
          sx.7_19 = (unsigned int) sx;
          w = window_create1 (sx.7_19, sy.6_18);
          idx.8_20 = idx;
          idx = idx.8_20 + 1;
          session_attach (s, w, idx.8_20, &cause);
          free (cmd);
          if (groupwith != 0B) goto <D.5128>; else goto <D.5129>;
          <D.5128>:
          session_group_add (groupwith, s);
          session_group_synchronize_to (s);
          _21 = s->windows.rbh_root;
          _22 = _21->idx;
          session_select (s, _22);
          <D.5129>:
          i = i + 1;
          <D.4662>:
          if (i < argc) goto <D.4661>; else goto <D.4663>;
          <D.4663>:
        }
        join_pane_exec ();
        goto <D.4665>;
        <D.4664>:
        _23 = sessions.list;
        _24 = *_23;
        session_destroy (_24);
        <D.4665>:
        _25 = sessions.num;
        if (_25 != 0) goto <D.4664>; else goto <D.4666>;
        <D.4666>:
        D.5130 = 0;
        return D.5130;
      }
    finally
      {
        cause = {CLOBBER};
      }
  }
  D.5130 = 0;
  return D.5130;
}


