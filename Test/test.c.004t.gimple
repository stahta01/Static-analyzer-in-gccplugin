discard_cleanups (struct cleanup * old_chain)
{
  discard_my_cleanups (&cleanup_chain, old_chain);
}


discard_final_cleanups (struct cleanup * old_chain)
{
  discard_my_cleanups (&final_cleanup_chain, old_chain);
}


discard_my_cleanups (struct cleanup * * pmy_chain, struct cleanup * old_chain)
{
  struct cleanup * ptr;

  goto <D.3139>;
  <D.3138>:
  _1 = ptr->next;
  *pmy_chain = _1;
  _2 = ptr->free_arg;
  if (_2 != 0B) goto <D.3467>; else goto <D.3468>;
  <D.3467>:
  _3 = ptr->free_arg;
  _4 = ptr->arg;
  _3 (_4);
  <D.3468>:
  free (ptr);
  <D.3139>:
  ptr = *pmy_chain;
  if (ptr != old_chain) goto <D.3138>; else goto <D.3140>;
  <D.3140>:
  _5 = ptr->arg;
  printf ("freearg: %x\n", _5);
}


__attribute__((__artificial__, __gnu_inline__, __always_inline__))
printf (const char * restrict __fmt)
{
  int D.3469;

  D.3469 = __printf_chk (1, __fmt, __builtin_va_arg_pack ());
  return D.3469;
}


do_cleanups (struct cleanup * old_chain)
{
  do_my_cleanups (&cleanup_chain, old_chain);
}


do_my_cleanups (struct cleanup * * pmy_chain, struct cleanup * old_chain)
{
  struct cleanup * ptr;

  goto <D.3147>;
  <D.3146>:
  _1 = ptr->next;
  *pmy_chain = _1;
  _2 = ptr->function;
  _3 = ptr->arg;
  _2 (_3);
  printf ("cleanup!!!!! =========\n");
  _4 = ptr->arg;
  printf ("%x\n", _4);
  _5 = ptr->free_arg;
  if (_5 != 0B) goto <D.3471>; else goto <D.3472>;
  <D.3471>:
  _6 = ptr->free_arg;
  _7 = ptr->arg;
  _6 (_7);
  <D.3472>:
  free (ptr);
  <D.3147>:
  ptr = *pmy_chain;
  if (ptr != old_chain) goto <D.3146>; else goto <D.3148>;
  <D.3148>:
}


make_cleanup (void (*<T9e0>) (void *) function, void * arg)
{
  struct cleanup * D.3473;

  D.3473 = make_my_cleanup (&cleanup_chain, function, arg);
  return D.3473;
}


make_my_cleanup (struct cleanup * * pmy_chain, void (*<T9e0>) (void *) function, void * arg)
{
  struct cleanup * D.3475;

  D.3475 = make_my_cleanup2 (pmy_chain, function, arg, 0B);
  return D.3475;
}


make_my_cleanup2 (struct cleanup * * pmy_chain, void (*<T9e0>) (void *) function, void * arg, void (*<Ted>) (void *) free_arg)
{
  struct cleanup * D.3479;
  struct cleanup * new;
  struct cleanup * old_chain;

  new = malloc (32);
  old_chain = *pmy_chain;
  _1 = *pmy_chain;
  new->next = _1;
  new->function = function;
  new->free_arg = free_arg;
  new->arg = arg;
  *pmy_chain = new;
  if (old_chain == 0B) goto <D.3477>; else goto <D.3478>;
  <D.3477>:
  exit (1);
  <D.3478>:
  D.3479 = old_chain;
  return D.3479;
}


filename_cmp (const char * s1, const char * s2)
{
  int D.3481;
  extern int strcmp ();

  D.3481 = strcmp (s1, s2);
  return D.3481;
}


make_tempname (char * filename)
{
  char * D.3485;
  char * tmpname;
  int fd;
  extern int close ();

  tmpname = template_in_dir (filename);
  fd = mkstemp (tmpname);
  if (fd == -1) goto <D.3483>; else goto <D.3484>;
  <D.3483>:
  free (tmpname);
  D.3485 = 0B;
  return D.3485;
  <D.3484>:
  close (fd);
  D.3485 = tmpname;
  return D.3485;
}


template_in_dir (const char * path)
{
  char * D.3490;
  const char * slash;
  extern char * strrchr (const char *, int);
  char * tmpname;
  size_t len;
  extern void * memcpy (void *, const void *, long unsigned int);

  slash = strrchr (path, 47);
  if (slash != 0B) goto <D.3487>; else goto <D.3488>;
  <D.3487>:
  {
    extern void * memcpy (void *, const void *, long unsigned int);

    slash.0_1 = (long int) slash;
    path.1_2 = (long int) path;
    _3 = slash.0_1 - path.1_2;
    len = (size_t) _3;
    _4 = len + 11;
    tmpname = malloc (_4);
    memcpy (tmpname, path, len);
    len.2_5 = len;
    len = len.2_5 + 1;
    _6 = tmpname + len.2_5;
    *_6 = 47;
  }
  goto <D.3489>;
  <D.3488>:
  tmpname = malloc (9);
  len = 0;
  <D.3489>:
  _7 = tmpname + len;
  memcpy (_7, "stXXXXXX", 9);
  D.3490 = tmpname;
  return D.3490;
}


set_times (const char * destination, const struct stat * statbuf)
{
  int result;

  {
    long int tb[2];
    extern int utime ();

    try
      {
        _1 = statbuf->st_atim.tv_sec;
        tb[0] = _1;
        _2 = statbuf->st_mtim.tv_sec;
        tb[1] = _2;
        result = utime (destination, &tb);
      }
    finally
      {
        tb = {CLOBBER};
      }
  }
  if (result != 0) goto <D.3492>; else goto <D.3493>;
  <D.3492>:
  printf ("%s: cannot set time:", destination);
  <D.3493>:
}


smart_rename (const char * from, const char * to, int preserve_dates)
{
  int D.3510;
  bfd_boolean exists;
  struct stat s;
  int ret;

  try
    {
      ret = 0;
      _1 = lstat (to, &s);
      _2 = _1 == 0;
      exists = (bfd_boolean) _2;
      if (exists == 0) goto <D.3494>; else goto <D.3497>;
      <D.3497>:
      _3 = BIT_FIELD_REF <s, 32, 192>;
      _4 = _3 & 61568;
      if (_4 == 32896) goto <D.3498>; else goto <D.3495>;
      <D.3498>:
      _5 = s.st_nlink;
      if (_5 == 1) goto <D.3494>; else goto <D.3495>;
      <D.3494>:
      ret = rename (from, to);
      if (ret == 0) goto <D.3499>; else goto <D.3500>;
      <D.3499>:
      if (exists != 0) goto <D.3501>; else goto <D.3502>;
      <D.3501>:
      _6 = s.st_mode;
      _7 = _6 & 511;
      chmod (to, _7);
      {
        extern int chown ();

        _8 = s.st_gid;
        _9 = s.st_uid;
        _10 = chown (to, _9, _8);
        if (_10 >= 0) goto <D.3503>; else goto <D.3504>;
        <D.3503>:
        _11 = s.st_mode;
        _12 = _11 & 4095;
        chmod (to, _12);
        <D.3504>:
      }
      <D.3502>:
      goto <D.3505>;
      <D.3500>:
      {
        extern int unlink ();

        printf ("unable to rename \'%s\';", to);
        unlink (from);
      }
      <D.3505>:
      goto <D.3496>;
      <D.3495>:
      {
        extern int unlink ();

        if (ret != 0) goto <D.3506>; else goto <D.3507>;
        <D.3506>:
        printf ("unable to copy file \'%s\';", to);
        <D.3507>:
        if (preserve_dates != 0) goto <D.3508>; else goto <D.3509>;
        <D.3508>:
        set_times (to, &s);
        <D.3509>:
        unlink (from);
      }
      <D.3496>:
      D.3510 = ret;
      return D.3510;
    }
  finally
    {
      s = {CLOBBER};
    }
}


unlink_if_ordinary (const char * name)
{
  _1 = MEM[(int *)name];
  printf ("%d\n", _1);
}


main (int argc, char * * argv)
{
  int D.3513;

  {
    _1 = *argv;
    program_name = _1;
    copy_main (argc, argv);
    D.3513 = status;
    return D.3513;
  }
  D.3513 = 0;
  return D.3513;
}


copy_main (int argc, char * * argv)
{
  int D.3529;
  char * input_filename;
  char * output_filename;
  char * tmpname;
  char * input_target;
  char * output_target;
  bfd_boolean show_version;
  bfd_boolean change_warn;
  bfd_boolean formats_info;
  int c;
  int statbuf;
  const struct bfd_arch_info_type * input_arch;

  try
    {
      input_filename = 0B;
      output_filename = 0B;
      input_target = 0B;
      output_target = 0B;
      show_version = 0;
      change_warn = 1;
      formats_info = 0;
      input_arch = 0B;
      optind.3_1 = optind;
      _2 = (long unsigned int) optind.3_1;
      _3 = _2 * 8;
      _4 = argv + _3;
      input_filename = *_4;
      optind.4_5 = optind;
      _6 = optind.4_5 + 1;
      if (argc > _6) goto <D.3515>; else goto <D.3516>;
      <D.3515>:
      optind.5_7 = optind;
      _8 = (sizetype) optind.5_7;
      _9 = _8 + 1;
      _10 = _9 * 8;
      _11 = argv + _10;
      output_filename = *_11;
      <D.3516>:
      if (output_filename == 0B) goto <D.3517>; else goto <D.3518>;
      <D.3517>:
      tmpname = make_tempname (input_filename);
      goto <D.3519>;
      <D.3518>:
      tmpname = output_filename;
      <D.3519>:
      if (tmpname == 0B) goto <D.3520>; else goto <D.3521>;
      <D.3520>:
      printf ("warning: could not create temporary file whilst copying \'%s\'", input_filename);
      exit (1);
      <D.3521>:
      copy_file (input_filename, tmpname, input_target, output_target, input_arch);
      status.6_12 = status;
      if (status.6_12 == 0) goto <D.3522>; else goto <D.3523>;
      <D.3522>:
      preserve_dates.7_13 = preserve_dates;
      if (preserve_dates.7_13 != 0) goto <D.3524>; else goto <D.3525>;
      <D.3524>:
      set_times (tmpname, &statbuf);
      <D.3525>:
      if (tmpname != output_filename) goto <D.3526>; else goto <D.3527>;
      <D.3526>:
      preserve_dates.8_14 = preserve_dates;
      _15 = smart_rename (tmpname, input_filename, preserve_dates.8_14);
      _16 = _15 != 0;
      _17 = (int) _16;
      status = _17;
      <D.3527>:
      goto <D.3528>;
      <D.3523>:
      unlink_if_ordinary (tmpname);
      <D.3528>:
      D.3529 = 0;
      return D.3529;
    }
  finally
    {
      statbuf = {CLOBBER};
    }
}


copy_file (const char * input_filename, const char * output_filename, const char * input_target, const char * output_target, const struct bfd_arch_info_type * input_arch)
{
  struct bfd * ibfd;
  char * * obj_matching;
  char * * core_matching;
  off_t size;

  _1 = rand ();
  _2 = _1 % 2;
  _3 = _2 == 1;
  size = (off_t) _3;
  if (size <= 0) goto <D.3532>; else goto <D.3533>;
  <D.3532>:
  if (size == 0) goto <D.3534>; else goto <D.3535>;
  <D.3534>:
  printf ("error: the input file \'%s\' is empty", input_filename);
  <D.3535>:
  status = 1;
  return;
  <D.3533>:
}


