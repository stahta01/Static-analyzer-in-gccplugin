
;; Function discard_cleanups (discard_cleanups, funcdef_no=22, decl_uid=3018, cgraph_uid=23, symbol_order=27)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
void discard_cleanups (struct cleanup * old_chain)
{
  <bb 2> :
  discard_my_cleanups (&cleanup_chain, old_chain);
  return;

}



;; Function discard_final_cleanups (discard_final_cleanups, funcdef_no=23, decl_uid=3023, cgraph_uid=24, symbol_order=28)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
void discard_final_cleanups (struct cleanup * old_chain)
{
  <bb 2> :
  discard_my_cleanups (&final_cleanup_chain, old_chain);
  return;

}



;; Function discard_my_cleanups (discard_my_cleanups, funcdef_no=24, decl_uid=3021, cgraph_uid=25, symbol_order=29)

;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7
;;
;; Loop 1
;;  header 6, latch 5
;;  depth 1, outer 0
;;  nodes: 6 5 3 4
;; 2 succs { 6 }
;; 3 succs { 4 5 }
;; 4 succs { 5 }
;; 5 succs { 6 }
;; 6 succs { 3 7 }
;; 7 succs { 1 }
void discard_my_cleanups (struct cleanup * * pmy_chain, struct cleanup * old_chain)
{
  struct cleanup * ptr;

  <bb 2> :
  goto <bb 6>; [INV]

  <bb 3> :
  _1 = ptr->next;
  *pmy_chain = _1;
  _2 = ptr->free_arg;
  if (_2 != 0B)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  _3 = ptr->free_arg;
  _4 = ptr->arg;
  _3 (_4);

  <bb 5> :
  free (ptr);

  <bb 6> :
  ptr = *pmy_chain;
  if (ptr != old_chain)
    goto <bb 3>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  _5 = ptr->arg;
  printf ("freearg: %x\n", _5);
  return;

}



;; Function do_cleanups (do_cleanups, funcdef_no=26, decl_uid=3028, cgraph_uid=27, symbol_order=31)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
void do_cleanups (struct cleanup * old_chain)
{
  <bb 2> :
  do_my_cleanups (&cleanup_chain, old_chain);
  return;

}



;; Function do_my_cleanups (do_my_cleanups, funcdef_no=25, decl_uid=3026, cgraph_uid=26, symbol_order=30)

;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7
;;
;; Loop 1
;;  header 6, latch 5
;;  depth 1, outer 0
;;  nodes: 6 5 3 4
;; 2 succs { 6 }
;; 3 succs { 4 5 }
;; 4 succs { 5 }
;; 5 succs { 6 }
;; 6 succs { 3 7 }
;; 7 succs { 1 }
void do_my_cleanups (struct cleanup * * pmy_chain, struct cleanup * old_chain)
{
  struct cleanup * ptr;

  <bb 2> :
  goto <bb 6>; [INV]

  <bb 3> :
  _1 = ptr->next;
  *pmy_chain = _1;
  _2 = ptr->function;
  _3 = ptr->arg;
  _2 (_3);
  __builtin_puts (&"cleanup!!!!! ========="[0]);
  _4 = ptr->arg;
  printf ("%x\n", _4);
  _5 = ptr->free_arg;
  if (_5 != 0B)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  _6 = ptr->free_arg;
  _7 = ptr->arg;
  _6 (_7);

  <bb 5> :
  free (ptr);

  <bb 6> :
  ptr = *pmy_chain;
  if (ptr != old_chain)
    goto <bb 3>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  return;

}



;; Function make_cleanup (make_cleanup, funcdef_no=29, decl_uid=3041, cgraph_uid=30, symbol_order=34)

Merging blocks 2 and 3
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
struct cleanup * make_cleanup (void (*<T59c>) (void *) function, void * arg)
{
  struct cleanup * D.3160;

  <bb 2> :
  D.3160 = make_my_cleanup (&cleanup_chain, function, arg);
  return D.3160;

}



;; Function make_my_cleanup (make_my_cleanup, funcdef_no=28, decl_uid=3038, cgraph_uid=29, symbol_order=33)

Merging blocks 2 and 3
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
struct cleanup * make_my_cleanup (struct cleanup * * pmy_chain, void (*<T59c>) (void *) function, void * arg)
{
  struct cleanup * D.3162;

  <bb 2> :
  D.3162 = make_my_cleanup2 (pmy_chain, function, arg, 0B);
  return D.3162;

}



;; Function make_my_cleanup2 (make_my_cleanup2, funcdef_no=27, decl_uid=3034, cgraph_uid=28, symbol_order=32)

Merging blocks 4 and 5
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4
;; 2 succs { 3 4 }
;; 3 succs { }
;; 4 succs { 1 }
struct cleanup * make_my_cleanup2 (struct cleanup * * pmy_chain, void (*<T59c>) (void *) function, void * arg, void (*<Tee>) (void *) free_arg)
{
  struct cleanup * old_chain;
  struct cleanup * new;
  struct cleanup * D.3166;

  <bb 2> :
  new = malloc (32);
  old_chain = *pmy_chain;
  _1 = *pmy_chain;
  new->next = _1;
  new->function = function;
  new->free_arg = free_arg;
  new->arg = arg;
  *pmy_chain = new;
  if (old_chain == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  exit (1);

  <bb 4> :
  D.3166 = old_chain;
  return D.3166;

}



;; Function objalloc_create (objalloc_create, funcdef_no=30, decl_uid=3104, cgraph_uid=31, symbol_order=35)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7
;; 2 succs { 3 4 }
;; 3 succs { 7 }
;; 4 succs { 5 6 }
;; 5 succs { 7 }
;; 6 succs { 7 }
;; 7 succs { 1 }
struct objalloc * objalloc_create ()
{
  struct objalloc_chunk * chunk;
  struct objalloc * ret;
  struct objalloc * D.3170;

  <bb 2> :
  ret = malloc (24);
  if (ret == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  D.3170 = 0B;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 7>; [INV]

  <bb 4> :
  _1 = malloc (4064);
  ret->chunks = _1;
  _2 = ret->chunks;
  if (_2 == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  free (ret);
  D.3170 = 0B;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 7>; [INV]

  <bb 6> :
  chunk = ret->chunks;
  chunk->next = 0B;
  chunk->current_ptr = 0B;
  chunk->next = 0B;
  _3 = chunk + 32;
  ret->current_ptr = _3;
  ret->current_space = 4032;
  D.3170 = ret;

  <bb 7> :
  return D.3170;

}



;; Function objalloc_alloc (objalloc_alloc, funcdef_no=31, decl_uid=3110, cgraph_uid=32, symbol_order=36)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7
;; 2 succs { 3 4 }
;; 3 succs { }
;; 4 succs { 5 6 }
;; 5 succs { 7 }
;; 6 succs { 7 }
;; 7 succs { 1 }
void * objalloc_alloc (struct objalloc * o, long unsigned int len)
{
  struct objalloc_chunk * chunk;
  char * ret;
  void * D.3178;

  <bb 2> :
  if (len > 4064)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  exit (1);

  <bb 4> :
  chunk = malloc (4064);
  if (chunk == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  D.3178 = 0B;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 7>; [INV]

  <bb 6> :
  _1 = o->chunks;
  chunk->next = _1;
  chunk->current_ptr = 0B;
  _2 = chunk + 32;
  o->current_ptr = _2;
  o->current_space = 4032;
  o->chunks = chunk;
  D.3178 = chunk + 512;

  <bb 7> :
  return D.3178;

}



;; Function objalloc_free (objalloc_free, funcdef_no=32, decl_uid=3115, cgraph_uid=33, symbol_order=37)

;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5
;;
;; Loop 1
;;  header 4, latch 3
;;  depth 1, outer 0
;;  nodes: 4 3
;; 2 succs { 4 }
;; 3 succs { 4 }
;; 4 succs { 3 5 }
;; 5 succs { 1 }
void objalloc_free (struct objalloc * o)
{
  struct objalloc_chunk * next;
  void * data;
  struct objalloc_chunk * l;

  <bb 2> :
  l = o->chunks;
  goto <bb 4>; [INV]

  <bb 3> :
  data = l + 512;
  next = l->next;
  free (l);
  l = next;

  <bb 4> :
  if (l != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 5> :
  free (o);
  return;

}



;; Function bfd_hash_table_init_n (bfd_hash_table_init_n, funcdef_no=33, decl_uid=3126, cgraph_uid=34, symbol_order=38)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7
;; 2 succs { 3 4 }
;; 3 succs { 7 }
;; 4 succs { 5 6 }
;; 5 succs { 7 }
;; 6 succs { 7 }
;; 7 succs { 1 }
bfd_boolean bfd_hash_table_init_n (struct bfd_hash_table * table, unsigned int entsize, unsigned int size)
{
  long unsigned int alloc;
  bfd_boolean D.3182;

  <bb 2> :
  alloc = (long unsigned int) size;
  alloc = alloc * 8;
  _1 = objalloc_create ();
  table->memory = _1;
  _2 = table->memory;
  if (_2 == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  D.3182 = 0;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 7>; [INV]

  <bb 4> :
  _3 = table->memory;
  _4 = objalloc_alloc (_3, alloc);
  table->table = _4;
  _5 = table->table;
  if (_5 == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  objalloc_free (table);
  D.3182 = 0;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 7>; [INV]

  <bb 6> :
  _6 = table->table;
  memset (_6, 0, alloc);
  table->size = size;
  table->entsize = entsize;
  table->count = 0;
  D.3182 = 1;

  <bb 7> :
  return D.3182;

}



;; Function bfd_hash_insert (bfd_hash_insert, funcdef_no=34, decl_uid=3133, cgraph_uid=35, symbol_order=39)

Merging blocks 2 and 3
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
struct bfd_hash_entry * bfd_hash_insert (struct bfd_hash_table * table, const char * string, long unsigned int hash)
{
  unsigned int _index;
  struct bfd_hash_entry * hashp;
  struct bfd_hash_entry * D.3186;

  <bb 2> :
  _1 = table->memory;
  hashp = objalloc_alloc (_1, 24);
  hashp->hash = hash;
  hashp->string = string;
  _2 = table->size;
  _3 = (long unsigned int) _2;
  _4 = hash % _3;
  _index = (unsigned int) _4;
  _5 = table->table;
  _6 = (long unsigned int) _index;
  _7 = _6 * 8;
  _8 = _5 + _7;
  *_8 = hashp;
  _9 = table->count;
  _10 = _9 + 1;
  table->count = _10;
  D.3186 = hashp;
  return D.3186;

}



;; Function bfd_dwarf2_cleanup_debug_info (bfd_dwarf2_cleanup_debug_info, funcdef_no=35, decl_uid=3138, cgraph_uid=36, symbol_order=40)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
void bfd_dwarf2_cleanup_debug_info (struct bfd_hash_table * table)
{
  <bb 2> :
  _1 = table->memory;
  objalloc_free (_1);
  return;

}



;; Function main (main, funcdef_no=36, decl_uid=3140, cgraph_uid=37, symbol_order=41)

Merging blocks 3 and 8
Removing basic block 4
Merging blocks 7 and 9
Merging blocks 3 and 11
Merging blocks 7 and 10
;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6
;;
;; Loop 1
;;  header 5, latch 4
;;  depth 1, outer 0
;;  nodes: 5 4
;; 2 succs { 3 5 }
;; 3 succs { 1 }
;; 4 succs { 5 }
;; 5 succs { 4 6 }
;; 6 succs { 1 }
int main ()
{
  const char * hash[10];
  unsigned int cnt;
  unsigned int size;
  unsigned int entsize;
  struct bfd_hash_entry * entry;
  struct bfd_hash_table table;
  time_t t;
  int D.3190;

  <bb 2> :
  entsize = 10;
  size = 10;
  cnt = 0;
  hash[0] = "a";
  hash[1] = "b";
  hash[2] = "c";
  hash[3] = "d";
  hash[4] = "e";
  hash[5] = "f";
  hash[6] = "g";
  hash[7] = "h";
  hash[8] = "i";
  hash[9] = "j";
  _1 = time (&t);
  _2 = (unsigned int) _1;
  srand (_2);
  _3 = bfd_hash_table_init_n (&table, entsize, size);
  if (_3 == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 3> :
  // predicted unlikely by early return (on trees) predictor.
  t = {CLOBBER};
  table = {CLOBBER};
  hash = {CLOBBER};
  return;

  <bb 4> :
  _4 = (long unsigned int) cnt;
  _5 = hash[cnt];
  bfd_hash_insert (&table, _5, _4);
  cnt = cnt + 1;

  <bb 5> :
  if (cnt < entsize)
    goto <bb 4>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 6> :
  bfd_dwarf2_cleanup_debug_info (&table);
  memset (&table, 0, 32);
  t = {CLOBBER};
  table = {CLOBBER};
  hash = {CLOBBER};
  D.3190 = 0;
  return D.3190;

}


