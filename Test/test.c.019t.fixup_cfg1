
;; Function printf (printf, funcdef_no=15, decl_uid=798, cgraph_uid=15, symbol_order=15)

__attribute__((__artificial__, __gnu_inline__, __always_inline__))
printf (const char * restrict __fmt)
{
  int D.4924;

  <bb 2> [0.00%]:
  D.4924 = __printf_chk (1, __fmt, __builtin_va_arg_pack ());
  return D.4924;

}



;; Function memcpy (memcpy, funcdef_no=41, decl_uid=728, cgraph_uid=41, symbol_order=41)

__attribute__((__artificial__, __gnu_inline__, __always_inline__, __nothrow__, __leaf__))
memcpy (void * restrict __dest, const void * restrict __src, size_t __len)
{
  void * D.5036;

  <bb 2> [0.00%]:
  _1 = __builtin_object_size (__dest, 0);
  D.5036 = __memcpy_chk (__dest, __src, __len, _1);
  return D.5036;

}



;; Function winlink_cmp (winlink_cmp, funcdef_no=50, decl_uid=4298, cgraph_uid=50, symbol_order=53)

winlink_cmp (struct winlink * wl1, struct winlink * wl2)
{
  int D.4668;

  <bb 2> [0.00%]:
  _1 = wl1->idx;
  _2 = wl2->idx;
  D.4668 = _1 - _2;
  return D.4668;

}



;; Function winlinks_RB_INSERT_COLOR (winlinks_RB_INSERT_COLOR, funcdef_no=51, decl_uid=4302, cgraph_uid=51, symbol_order=54)

winlinks_RB_INSERT_COLOR (struct winlinks * head, struct winlink * elm)
{
  struct winlink * tmp;
  struct winlink * gparent;
  struct winlink * parent;

  <bb 2> [0.00%]:
  goto <bb 44>; [0.00%]

  <bb 3> [0.00%]:
  gparent = parent->entry.rbe_parent;
  _1 = gparent->entry.rbe_left;
  if (parent == _1)
    goto <bb 4>; [0.00%]
  else
    goto <bb 24>; [0.00%]

  <bb 4> [0.00%]:
  tmp = gparent->entry.rbe_right;
  if (tmp != 0B)
    goto <bb 5>; [0.00%]
  else
    goto <bb 7>; [0.00%]

  <bb 5> [0.00%]:
  _2 = tmp->entry.rbe_color;
  if (_2 == 1)
    goto <bb 6>; [0.00%]
  else
    goto <bb 7>; [0.00%]

  <bb 6> [0.00%]:
  tmp->entry.rbe_color = 0;
  parent->entry.rbe_color = 0;
  gparent->entry.rbe_color = 1;
  elm = gparent;
  // predicted unlikely by continue predictor.
  goto <bb 44>; [0.00%]

  <bb 7> [0.00%]:
  _3 = parent->entry.rbe_right;
  if (elm == _3)
    goto <bb 8>; [0.00%]
  else
    goto <bb 16>; [0.00%]

  <bb 8> [0.00%]:
  tmp = parent->entry.rbe_right;
  _4 = tmp->entry.rbe_left;
  parent->entry.rbe_right = _4;
  _5 = parent->entry.rbe_right;
  if (_5 != 0B)
    goto <bb 9>; [0.00%]
  else
    goto <bb 10>; [0.00%]

  <bb 9> [0.00%]:
  _6 = tmp->entry.rbe_left;
  _6->entry.rbe_parent = parent;

  <bb 10> [0.00%]:
  _7 = parent->entry.rbe_parent;
  tmp->entry.rbe_parent = _7;
  _8 = tmp->entry.rbe_parent;
  if (_8 != 0B)
    goto <bb 11>; [0.00%]
  else
    goto <bb 14>; [0.00%]

  <bb 11> [0.00%]:
  _9 = parent->entry.rbe_parent;
  _10 = _9->entry.rbe_left;
  if (parent == _10)
    goto <bb 12>; [0.00%]
  else
    goto <bb 13>; [0.00%]

  <bb 12> [0.00%]:
  _11 = parent->entry.rbe_parent;
  _11->entry.rbe_left = tmp;
  goto <bb 15>; [0.00%]

  <bb 13> [0.00%]:
  _12 = parent->entry.rbe_parent;
  _12->entry.rbe_right = tmp;
  goto <bb 15>; [0.00%]

  <bb 14> [0.00%]:
  head->rbh_root = tmp;

  <bb 15> [0.00%]:
  tmp->entry.rbe_left = parent;
  parent->entry.rbe_parent = tmp;
  _13 = tmp->entry.rbe_parent;
  tmp = parent;
  parent = elm;
  elm = tmp;

  <bb 16> [0.00%]:
  parent->entry.rbe_color = 0;
  gparent->entry.rbe_color = 1;
  tmp = gparent->entry.rbe_left;
  _14 = tmp->entry.rbe_right;
  gparent->entry.rbe_left = _14;
  _15 = gparent->entry.rbe_left;
  if (_15 != 0B)
    goto <bb 17>; [0.00%]
  else
    goto <bb 18>; [0.00%]

  <bb 17> [0.00%]:
  _16 = tmp->entry.rbe_right;
  _16->entry.rbe_parent = gparent;

  <bb 18> [0.00%]:
  _17 = gparent->entry.rbe_parent;
  tmp->entry.rbe_parent = _17;
  _18 = tmp->entry.rbe_parent;
  if (_18 != 0B)
    goto <bb 19>; [0.00%]
  else
    goto <bb 22>; [0.00%]

  <bb 19> [0.00%]:
  _19 = gparent->entry.rbe_parent;
  _20 = _19->entry.rbe_left;
  if (gparent == _20)
    goto <bb 20>; [0.00%]
  else
    goto <bb 21>; [0.00%]

  <bb 20> [0.00%]:
  _21 = gparent->entry.rbe_parent;
  _21->entry.rbe_left = tmp;
  goto <bb 23>; [0.00%]

  <bb 21> [0.00%]:
  _22 = gparent->entry.rbe_parent;
  _22->entry.rbe_right = tmp;
  goto <bb 23>; [0.00%]

  <bb 22> [0.00%]:
  head->rbh_root = tmp;

  <bb 23> [0.00%]:
  tmp->entry.rbe_right = gparent;
  gparent->entry.rbe_parent = tmp;
  _23 = tmp->entry.rbe_parent;
  goto <bb 44>; [0.00%]

  <bb 24> [0.00%]:
  tmp = gparent->entry.rbe_left;
  if (tmp != 0B)
    goto <bb 25>; [0.00%]
  else
    goto <bb 27>; [0.00%]

  <bb 25> [0.00%]:
  _24 = tmp->entry.rbe_color;
  if (_24 == 1)
    goto <bb 26>; [0.00%]
  else
    goto <bb 27>; [0.00%]

  <bb 26> [0.00%]:
  tmp->entry.rbe_color = 0;
  parent->entry.rbe_color = 0;
  gparent->entry.rbe_color = 1;
  elm = gparent;
  // predicted unlikely by continue predictor.
  goto <bb 44>; [0.00%]

  <bb 27> [0.00%]:
  _25 = parent->entry.rbe_left;
  if (elm == _25)
    goto <bb 28>; [0.00%]
  else
    goto <bb 36>; [0.00%]

  <bb 28> [0.00%]:
  tmp = parent->entry.rbe_left;
  _26 = tmp->entry.rbe_right;
  parent->entry.rbe_left = _26;
  _27 = parent->entry.rbe_left;
  if (_27 != 0B)
    goto <bb 29>; [0.00%]
  else
    goto <bb 30>; [0.00%]

  <bb 29> [0.00%]:
  _28 = tmp->entry.rbe_right;
  _28->entry.rbe_parent = parent;

  <bb 30> [0.00%]:
  _29 = parent->entry.rbe_parent;
  tmp->entry.rbe_parent = _29;
  _30 = tmp->entry.rbe_parent;
  if (_30 != 0B)
    goto <bb 31>; [0.00%]
  else
    goto <bb 34>; [0.00%]

  <bb 31> [0.00%]:
  _31 = parent->entry.rbe_parent;
  _32 = _31->entry.rbe_left;
  if (parent == _32)
    goto <bb 32>; [0.00%]
  else
    goto <bb 33>; [0.00%]

  <bb 32> [0.00%]:
  _33 = parent->entry.rbe_parent;
  _33->entry.rbe_left = tmp;
  goto <bb 35>; [0.00%]

  <bb 33> [0.00%]:
  _34 = parent->entry.rbe_parent;
  _34->entry.rbe_right = tmp;
  goto <bb 35>; [0.00%]

  <bb 34> [0.00%]:
  head->rbh_root = tmp;

  <bb 35> [0.00%]:
  tmp->entry.rbe_right = parent;
  parent->entry.rbe_parent = tmp;
  _35 = tmp->entry.rbe_parent;
  tmp = parent;
  parent = elm;
  elm = tmp;

  <bb 36> [0.00%]:
  parent->entry.rbe_color = 0;
  gparent->entry.rbe_color = 1;
  tmp = gparent->entry.rbe_right;
  _36 = tmp->entry.rbe_left;
  gparent->entry.rbe_right = _36;
  _37 = gparent->entry.rbe_right;
  if (_37 != 0B)
    goto <bb 37>; [0.00%]
  else
    goto <bb 38>; [0.00%]

  <bb 37> [0.00%]:
  _38 = tmp->entry.rbe_left;
  _38->entry.rbe_parent = gparent;

  <bb 38> [0.00%]:
  _39 = gparent->entry.rbe_parent;
  tmp->entry.rbe_parent = _39;
  _40 = tmp->entry.rbe_parent;
  if (_40 != 0B)
    goto <bb 39>; [0.00%]
  else
    goto <bb 42>; [0.00%]

  <bb 39> [0.00%]:
  _41 = gparent->entry.rbe_parent;
  _42 = _41->entry.rbe_left;
  if (gparent == _42)
    goto <bb 40>; [0.00%]
  else
    goto <bb 41>; [0.00%]

  <bb 40> [0.00%]:
  _43 = gparent->entry.rbe_parent;
  _43->entry.rbe_left = tmp;
  goto <bb 43>; [0.00%]

  <bb 41> [0.00%]:
  _44 = gparent->entry.rbe_parent;
  _44->entry.rbe_right = tmp;
  goto <bb 43>; [0.00%]

  <bb 42> [0.00%]:
  head->rbh_root = tmp;

  <bb 43> [0.00%]:
  tmp->entry.rbe_left = gparent;
  gparent->entry.rbe_parent = tmp;
  _45 = tmp->entry.rbe_parent;

  <bb 44> [0.00%]:
  parent = elm->entry.rbe_parent;
  if (parent != 0B)
    goto <bb 45>; [0.00%]
  else
    goto <bb 46>; [0.00%]

  <bb 45> [0.00%]:
  _46 = parent->entry.rbe_color;
  if (_46 == 1)
    goto <bb 3>; [0.00%]
  else
    goto <bb 46>; [0.00%]

  <bb 46> [0.00%]:
  _47 = head->rbh_root;
  _47->entry.rbe_color = 0;
  return;

}



;; Function winlinks_RB_REMOVE_COLOR (winlinks_RB_REMOVE_COLOR, funcdef_no=52, decl_uid=4313, cgraph_uid=52, symbol_order=55)

winlinks_RB_REMOVE_COLOR (struct winlinks * head, struct winlink * parent, struct winlink * elm)
{
  struct winlink * oright;
  struct winlink * oleft;
  struct winlink * tmp;

  <bb 2> [0.00%]:
  goto <bb 76>; [0.00%]

  <bb 3> [0.00%]:
  _1 = parent->entry.rbe_left;
  if (elm == _1)
    goto <bb 4>; [0.00%]
  else
    goto <bb 40>; [0.00%]

  <bb 4> [0.00%]:
  tmp = parent->entry.rbe_right;
  _2 = tmp->entry.rbe_color;
  if (_2 == 1)
    goto <bb 5>; [0.00%]
  else
    goto <bb 13>; [0.00%]

  <bb 5> [0.00%]:
  tmp->entry.rbe_color = 0;
  parent->entry.rbe_color = 1;
  tmp = parent->entry.rbe_right;
  _3 = tmp->entry.rbe_left;
  parent->entry.rbe_right = _3;
  _4 = parent->entry.rbe_right;
  if (_4 != 0B)
    goto <bb 6>; [0.00%]
  else
    goto <bb 7>; [0.00%]

  <bb 6> [0.00%]:
  _5 = tmp->entry.rbe_left;
  _5->entry.rbe_parent = parent;

  <bb 7> [0.00%]:
  _6 = parent->entry.rbe_parent;
  tmp->entry.rbe_parent = _6;
  _7 = tmp->entry.rbe_parent;
  if (_7 != 0B)
    goto <bb 8>; [0.00%]
  else
    goto <bb 11>; [0.00%]

  <bb 8> [0.00%]:
  _8 = parent->entry.rbe_parent;
  _9 = _8->entry.rbe_left;
  if (parent == _9)
    goto <bb 9>; [0.00%]
  else
    goto <bb 10>; [0.00%]

  <bb 9> [0.00%]:
  _10 = parent->entry.rbe_parent;
  _10->entry.rbe_left = tmp;
  goto <bb 12>; [0.00%]

  <bb 10> [0.00%]:
  _11 = parent->entry.rbe_parent;
  _11->entry.rbe_right = tmp;
  goto <bb 12>; [0.00%]

  <bb 11> [0.00%]:
  head->rbh_root = tmp;

  <bb 12> [0.00%]:
  tmp->entry.rbe_left = parent;
  parent->entry.rbe_parent = tmp;
  _12 = tmp->entry.rbe_parent;
  tmp = parent->entry.rbe_right;

  <bb 13> [0.00%]:
  _13 = tmp->entry.rbe_left;
  if (_13 == 0B)
    goto <bb 15>; [0.00%]
  else
    goto <bb 14>; [0.00%]

  <bb 14> [0.00%]:
  _14 = tmp->entry.rbe_left;
  _15 = _14->entry.rbe_color;
  if (_15 == 0)
    goto <bb 15>; [0.00%]
  else
    goto <bb 18>; [0.00%]

  <bb 15> [0.00%]:
  _16 = tmp->entry.rbe_right;
  if (_16 == 0B)
    goto <bb 17>; [0.00%]
  else
    goto <bb 16>; [0.00%]

  <bb 16> [0.00%]:
  _17 = tmp->entry.rbe_right;
  _18 = _17->entry.rbe_color;
  if (_18 == 0)
    goto <bb 17>; [0.00%]
  else
    goto <bb 18>; [0.00%]

  <bb 17> [0.00%]:
  tmp->entry.rbe_color = 1;
  elm = parent;
  parent = elm->entry.rbe_parent;
  goto <bb 76>; [0.00%]

  <bb 18> [0.00%]:
  _19 = tmp->entry.rbe_right;
  if (_19 == 0B)
    goto <bb 20>; [0.00%]
  else
    goto <bb 19>; [0.00%]

  <bb 19> [0.00%]:
  _20 = tmp->entry.rbe_right;
  _21 = _20->entry.rbe_color;
  if (_21 == 0)
    goto <bb 20>; [0.00%]
  else
    goto <bb 30>; [0.00%]

  <bb 20> [0.00%]:
  oleft = tmp->entry.rbe_left;
  if (oleft != 0B)
    goto <bb 21>; [0.00%]
  else
    goto <bb 22>; [0.00%]

  <bb 21> [0.00%]:
  oleft->entry.rbe_color = 0;

  <bb 22> [0.00%]:
  tmp->entry.rbe_color = 1;
  oleft = tmp->entry.rbe_left;
  _22 = oleft->entry.rbe_right;
  tmp->entry.rbe_left = _22;
  _23 = tmp->entry.rbe_left;
  if (_23 != 0B)
    goto <bb 23>; [0.00%]
  else
    goto <bb 24>; [0.00%]

  <bb 23> [0.00%]:
  _24 = oleft->entry.rbe_right;
  _24->entry.rbe_parent = tmp;

  <bb 24> [0.00%]:
  _25 = tmp->entry.rbe_parent;
  oleft->entry.rbe_parent = _25;
  _26 = oleft->entry.rbe_parent;
  if (_26 != 0B)
    goto <bb 25>; [0.00%]
  else
    goto <bb 28>; [0.00%]

  <bb 25> [0.00%]:
  _27 = tmp->entry.rbe_parent;
  _28 = _27->entry.rbe_left;
  if (tmp == _28)
    goto <bb 26>; [0.00%]
  else
    goto <bb 27>; [0.00%]

  <bb 26> [0.00%]:
  _29 = tmp->entry.rbe_parent;
  _29->entry.rbe_left = oleft;
  goto <bb 29>; [0.00%]

  <bb 27> [0.00%]:
  _30 = tmp->entry.rbe_parent;
  _30->entry.rbe_right = oleft;
  goto <bb 29>; [0.00%]

  <bb 28> [0.00%]:
  head->rbh_root = oleft;

  <bb 29> [0.00%]:
  oleft->entry.rbe_right = tmp;
  tmp->entry.rbe_parent = oleft;
  _31 = oleft->entry.rbe_parent;
  tmp = parent->entry.rbe_right;

  <bb 30> [0.00%]:
  _32 = parent->entry.rbe_color;
  tmp->entry.rbe_color = _32;
  parent->entry.rbe_color = 0;
  _33 = tmp->entry.rbe_right;
  if (_33 != 0B)
    goto <bb 31>; [0.00%]
  else
    goto <bb 32>; [0.00%]

  <bb 31> [0.00%]:
  _34 = tmp->entry.rbe_right;
  _34->entry.rbe_color = 0;

  <bb 32> [0.00%]:
  tmp = parent->entry.rbe_right;
  _35 = tmp->entry.rbe_left;
  parent->entry.rbe_right = _35;
  _36 = parent->entry.rbe_right;
  if (_36 != 0B)
    goto <bb 33>; [0.00%]
  else
    goto <bb 34>; [0.00%]

  <bb 33> [0.00%]:
  _37 = tmp->entry.rbe_left;
  _37->entry.rbe_parent = parent;

  <bb 34> [0.00%]:
  _38 = parent->entry.rbe_parent;
  tmp->entry.rbe_parent = _38;
  _39 = tmp->entry.rbe_parent;
  if (_39 != 0B)
    goto <bb 35>; [0.00%]
  else
    goto <bb 38>; [0.00%]

  <bb 35> [0.00%]:
  _40 = parent->entry.rbe_parent;
  _41 = _40->entry.rbe_left;
  if (parent == _41)
    goto <bb 36>; [0.00%]
  else
    goto <bb 37>; [0.00%]

  <bb 36> [0.00%]:
  _42 = parent->entry.rbe_parent;
  _42->entry.rbe_left = tmp;
  goto <bb 39>; [0.00%]

  <bb 37> [0.00%]:
  _43 = parent->entry.rbe_parent;
  _43->entry.rbe_right = tmp;
  goto <bb 39>; [0.00%]

  <bb 38> [0.00%]:
  head->rbh_root = tmp;

  <bb 39> [0.00%]:
  tmp->entry.rbe_left = parent;
  parent->entry.rbe_parent = tmp;
  _44 = tmp->entry.rbe_parent;
  elm = head->rbh_root;
  goto <bb 79>; [0.00%]

  <bb 40> [0.00%]:
  tmp = parent->entry.rbe_left;
  _45 = tmp->entry.rbe_color;
  if (_45 == 1)
    goto <bb 41>; [0.00%]
  else
    goto <bb 49>; [0.00%]

  <bb 41> [0.00%]:
  tmp->entry.rbe_color = 0;
  parent->entry.rbe_color = 1;
  tmp = parent->entry.rbe_left;
  _46 = tmp->entry.rbe_right;
  parent->entry.rbe_left = _46;
  _47 = parent->entry.rbe_left;
  if (_47 != 0B)
    goto <bb 42>; [0.00%]
  else
    goto <bb 43>; [0.00%]

  <bb 42> [0.00%]:
  _48 = tmp->entry.rbe_right;
  _48->entry.rbe_parent = parent;

  <bb 43> [0.00%]:
  _49 = parent->entry.rbe_parent;
  tmp->entry.rbe_parent = _49;
  _50 = tmp->entry.rbe_parent;
  if (_50 != 0B)
    goto <bb 44>; [0.00%]
  else
    goto <bb 47>; [0.00%]

  <bb 44> [0.00%]:
  _51 = parent->entry.rbe_parent;
  _52 = _51->entry.rbe_left;
  if (parent == _52)
    goto <bb 45>; [0.00%]
  else
    goto <bb 46>; [0.00%]

  <bb 45> [0.00%]:
  _53 = parent->entry.rbe_parent;
  _53->entry.rbe_left = tmp;
  goto <bb 48>; [0.00%]

  <bb 46> [0.00%]:
  _54 = parent->entry.rbe_parent;
  _54->entry.rbe_right = tmp;
  goto <bb 48>; [0.00%]

  <bb 47> [0.00%]:
  head->rbh_root = tmp;

  <bb 48> [0.00%]:
  tmp->entry.rbe_right = parent;
  parent->entry.rbe_parent = tmp;
  _55 = tmp->entry.rbe_parent;
  tmp = parent->entry.rbe_left;

  <bb 49> [0.00%]:
  _56 = tmp->entry.rbe_left;
  if (_56 == 0B)
    goto <bb 51>; [0.00%]
  else
    goto <bb 50>; [0.00%]

  <bb 50> [0.00%]:
  _57 = tmp->entry.rbe_left;
  _58 = _57->entry.rbe_color;
  if (_58 == 0)
    goto <bb 51>; [0.00%]
  else
    goto <bb 54>; [0.00%]

  <bb 51> [0.00%]:
  _59 = tmp->entry.rbe_right;
  if (_59 == 0B)
    goto <bb 53>; [0.00%]
  else
    goto <bb 52>; [0.00%]

  <bb 52> [0.00%]:
  _60 = tmp->entry.rbe_right;
  _61 = _60->entry.rbe_color;
  if (_61 == 0)
    goto <bb 53>; [0.00%]
  else
    goto <bb 54>; [0.00%]

  <bb 53> [0.00%]:
  tmp->entry.rbe_color = 1;
  elm = parent;
  parent = elm->entry.rbe_parent;
  goto <bb 76>; [0.00%]

  <bb 54> [0.00%]:
  _62 = tmp->entry.rbe_left;
  if (_62 == 0B)
    goto <bb 56>; [0.00%]
  else
    goto <bb 55>; [0.00%]

  <bb 55> [0.00%]:
  _63 = tmp->entry.rbe_left;
  _64 = _63->entry.rbe_color;
  if (_64 == 0)
    goto <bb 56>; [0.00%]
  else
    goto <bb 66>; [0.00%]

  <bb 56> [0.00%]:
  oright = tmp->entry.rbe_right;
  if (oright != 0B)
    goto <bb 57>; [0.00%]
  else
    goto <bb 58>; [0.00%]

  <bb 57> [0.00%]:
  oright->entry.rbe_color = 0;

  <bb 58> [0.00%]:
  tmp->entry.rbe_color = 1;
  oright = tmp->entry.rbe_right;
  _65 = oright->entry.rbe_left;
  tmp->entry.rbe_right = _65;
  _66 = tmp->entry.rbe_right;
  if (_66 != 0B)
    goto <bb 59>; [0.00%]
  else
    goto <bb 60>; [0.00%]

  <bb 59> [0.00%]:
  _67 = oright->entry.rbe_left;
  _67->entry.rbe_parent = tmp;

  <bb 60> [0.00%]:
  _68 = tmp->entry.rbe_parent;
  oright->entry.rbe_parent = _68;
  _69 = oright->entry.rbe_parent;
  if (_69 != 0B)
    goto <bb 61>; [0.00%]
  else
    goto <bb 64>; [0.00%]

  <bb 61> [0.00%]:
  _70 = tmp->entry.rbe_parent;
  _71 = _70->entry.rbe_left;
  if (tmp == _71)
    goto <bb 62>; [0.00%]
  else
    goto <bb 63>; [0.00%]

  <bb 62> [0.00%]:
  _72 = tmp->entry.rbe_parent;
  _72->entry.rbe_left = oright;
  goto <bb 65>; [0.00%]

  <bb 63> [0.00%]:
  _73 = tmp->entry.rbe_parent;
  _73->entry.rbe_right = oright;
  goto <bb 65>; [0.00%]

  <bb 64> [0.00%]:
  head->rbh_root = oright;

  <bb 65> [0.00%]:
  oright->entry.rbe_left = tmp;
  tmp->entry.rbe_parent = oright;
  _74 = oright->entry.rbe_parent;
  tmp = parent->entry.rbe_left;

  <bb 66> [0.00%]:
  _75 = parent->entry.rbe_color;
  tmp->entry.rbe_color = _75;
  parent->entry.rbe_color = 0;
  _76 = tmp->entry.rbe_left;
  if (_76 != 0B)
    goto <bb 67>; [0.00%]
  else
    goto <bb 68>; [0.00%]

  <bb 67> [0.00%]:
  _77 = tmp->entry.rbe_left;
  _77->entry.rbe_color = 0;

  <bb 68> [0.00%]:
  tmp = parent->entry.rbe_left;
  _78 = tmp->entry.rbe_right;
  parent->entry.rbe_left = _78;
  _79 = parent->entry.rbe_left;
  if (_79 != 0B)
    goto <bb 69>; [0.00%]
  else
    goto <bb 70>; [0.00%]

  <bb 69> [0.00%]:
  _80 = tmp->entry.rbe_right;
  _80->entry.rbe_parent = parent;

  <bb 70> [0.00%]:
  _81 = parent->entry.rbe_parent;
  tmp->entry.rbe_parent = _81;
  _82 = tmp->entry.rbe_parent;
  if (_82 != 0B)
    goto <bb 71>; [0.00%]
  else
    goto <bb 74>; [0.00%]

  <bb 71> [0.00%]:
  _83 = parent->entry.rbe_parent;
  _84 = _83->entry.rbe_left;
  if (parent == _84)
    goto <bb 72>; [0.00%]
  else
    goto <bb 73>; [0.00%]

  <bb 72> [0.00%]:
  _85 = parent->entry.rbe_parent;
  _85->entry.rbe_left = tmp;
  goto <bb 75>; [0.00%]

  <bb 73> [0.00%]:
  _86 = parent->entry.rbe_parent;
  _86->entry.rbe_right = tmp;
  goto <bb 75>; [0.00%]

  <bb 74> [0.00%]:
  head->rbh_root = tmp;

  <bb 75> [0.00%]:
  tmp->entry.rbe_right = parent;
  parent->entry.rbe_parent = tmp;
  _87 = tmp->entry.rbe_parent;
  elm = head->rbh_root;
  goto <bb 79>; [0.00%]

  <bb 76> [0.00%]:
  if (elm == 0B)
    goto <bb 78>; [0.00%]
  else
    goto <bb 77>; [0.00%]

  <bb 77> [0.00%]:
  _88 = elm->entry.rbe_color;
  if (_88 == 0)
    goto <bb 78>; [0.00%]
  else
    goto <bb 79>; [0.00%]

  <bb 78> [0.00%]:
  _89 = head->rbh_root;
  if (elm != _89)
    goto <bb 3>; [0.00%]
  else
    goto <bb 79>; [0.00%]

  <bb 79> [0.00%]:
  if (elm != 0B)
    goto <bb 80>; [0.00%]
  else
    goto <bb 81>; [0.00%]

  <bb 80> [0.00%]:
  elm->entry.rbe_color = 0;

  <bb 81> [0.00%]:
  return;

}



;; Function winlinks_RB_INSERT (winlinks_RB_INSERT, funcdef_no=53, decl_uid=4323, cgraph_uid=53, symbol_order=56)

winlinks_RB_INSERT (struct winlinks * head, struct winlink * elm)
{
  int comp;
  struct winlink * parent;
  struct winlink * tmp;
  struct winlink * D.4829;

  <bb 2> [0.00%]:
  parent = 0B;
  comp = 0;
  tmp = head->rbh_root;
  goto <bb 8>; [0.00%]

  <bb 3> [0.00%]:
  parent = tmp;
  comp = winlink_cmp (elm, parent);
  if (comp < 0)
    goto <bb 4>; [0.00%]
  else
    goto <bb 5>; [0.00%]

  <bb 4> [0.00%]:
  tmp = tmp->entry.rbe_left;
  goto <bb 8>; [0.00%]

  <bb 5> [0.00%]:
  if (comp > 0)
    goto <bb 6>; [0.00%]
  else
    goto <bb 7>; [0.00%]

  <bb 6> [0.00%]:
  tmp = tmp->entry.rbe_right;
  goto <bb 8>; [0.00%]

  <bb 7> [0.00%]:
  D.4829 = tmp;
  goto <bb 15>; [0.00%]

  <bb 8> [0.00%]:
  if (tmp != 0B)
    goto <bb 3>; [0.00%]
  else
    goto <bb 9>; [0.00%]

  <bb 9> [0.00%]:
  elm->entry.rbe_parent = parent;
  elm->entry.rbe_right = 0B;
  _1 = elm->entry.rbe_right;
  elm->entry.rbe_left = _1;
  elm->entry.rbe_color = 1;
  if (parent != 0B)
    goto <bb 10>; [0.00%]
  else
    goto <bb 13>; [0.00%]

  <bb 10> [0.00%]:
  if (comp < 0)
    goto <bb 11>; [0.00%]
  else
    goto <bb 12>; [0.00%]

  <bb 11> [0.00%]:
  parent->entry.rbe_left = elm;
  goto <bb 14>; [0.00%]

  <bb 12> [0.00%]:
  parent->entry.rbe_right = elm;
  goto <bb 14>; [0.00%]

  <bb 13> [0.00%]:
  head->rbh_root = elm;

  <bb 14> [0.00%]:
  winlinks_RB_INSERT_COLOR (head, elm);
  D.4829 = 0B;

  <bb 15> [0.00%]:
  return D.4829;

}



;; Function winlinks_RB_REMOVE (winlinks_RB_REMOVE, funcdef_no=54, decl_uid=4333, cgraph_uid=54, symbol_order=57)

winlinks_RB_REMOVE (struct winlinks * head, struct winlink * elm)
{
  struct winlink * left;
  int color;
  struct winlink * old;
  struct winlink * parent;
  struct winlink * child;
  struct winlink * D.4873;

  <bb 2> [0.00%]:
  old = elm;
  _1 = elm->entry.rbe_left;
  if (_1 == 0B)
    goto <bb 3>; [0.00%]
  else
    goto <bb 4>; [0.00%]

  <bb 3> [0.00%]:
  child = elm->entry.rbe_right;
  goto <bb 28>; [0.00%]

  <bb 4> [0.00%]:
  _2 = elm->entry.rbe_right;
  if (_2 == 0B)
    goto <bb 5>; [0.00%]
  else
    goto <bb 6>; [0.00%]

  <bb 5> [0.00%]:
  child = elm->entry.rbe_left;
  goto <bb 28>; [0.00%]

  <bb 6> [0.00%]:
  elm = elm->entry.rbe_right;
  goto <bb 8>; [0.00%]

  <bb 7> [0.00%]:
  elm = left;

  <bb 8> [0.00%]:
  left = elm->entry.rbe_left;
  if (left != 0B)
    goto <bb 7>; [0.00%]
  else
    goto <bb 9>; [0.00%]

  <bb 9> [0.00%]:
  child = elm->entry.rbe_right;
  parent = elm->entry.rbe_parent;
  color = elm->entry.rbe_color;
  if (child != 0B)
    goto <bb 10>; [0.00%]
  else
    goto <bb 11>; [0.00%]

  <bb 10> [0.00%]:
  child->entry.rbe_parent = parent;

  <bb 11> [0.00%]:
  if (parent != 0B)
    goto <bb 12>; [0.00%]
  else
    goto <bb 15>; [0.00%]

  <bb 12> [0.00%]:
  _3 = parent->entry.rbe_left;
  if (elm == _3)
    goto <bb 13>; [0.00%]
  else
    goto <bb 14>; [0.00%]

  <bb 13> [0.00%]:
  parent->entry.rbe_left = child;
  goto <bb 16>; [0.00%]

  <bb 14> [0.00%]:
  parent->entry.rbe_right = child;
  goto <bb 16>; [0.00%]

  <bb 15> [0.00%]:
  head->rbh_root = child;

  <bb 16> [0.00%]:
  _4 = elm->entry.rbe_parent;
  if (old == _4)
    goto <bb 17>; [0.00%]
  else
    goto <bb 18>; [0.00%]

  <bb 17> [0.00%]:
  parent = elm;

  <bb 18> [0.00%]:
  elm->entry = old->entry;
  _5 = old->entry.rbe_parent;
  if (_5 != 0B)
    goto <bb 19>; [0.00%]
  else
    goto <bb 22>; [0.00%]

  <bb 19> [0.00%]:
  _6 = old->entry.rbe_parent;
  _7 = _6->entry.rbe_left;
  if (old == _7)
    goto <bb 20>; [0.00%]
  else
    goto <bb 21>; [0.00%]

  <bb 20> [0.00%]:
  _8 = old->entry.rbe_parent;
  _8->entry.rbe_left = elm;
  goto <bb 23>; [0.00%]

  <bb 21> [0.00%]:
  _9 = old->entry.rbe_parent;
  _9->entry.rbe_right = elm;
  goto <bb 23>; [0.00%]

  <bb 22> [0.00%]:
  head->rbh_root = elm;

  <bb 23> [0.00%]:
  _10 = old->entry.rbe_left;
  _10->entry.rbe_parent = elm;
  _11 = old->entry.rbe_right;
  if (_11 != 0B)
    goto <bb 24>; [0.00%]
  else
    goto <bb 25>; [0.00%]

  <bb 24> [0.00%]:
  _12 = old->entry.rbe_right;
  _12->entry.rbe_parent = elm;

  <bb 25> [0.00%]:
  if (parent != 0B)
    goto <bb 26>; [0.00%]
  else
    goto <bb 35> (color); [0.00%]

  <bb 26> [0.00%]:
  left = parent;

  <bb 27> [0.00%]:
  left = left->entry.rbe_parent;
  if (left != 0B)
    goto <bb 27>; [0.00%]
  else
    goto <bb 35> (color); [0.00%]

  <bb 28> [0.00%]:
  parent = elm->entry.rbe_parent;
  color = elm->entry.rbe_color;
  if (child != 0B)
    goto <bb 29>; [0.00%]
  else
    goto <bb 30>; [0.00%]

  <bb 29> [0.00%]:
  child->entry.rbe_parent = parent;

  <bb 30> [0.00%]:
  if (parent != 0B)
    goto <bb 31>; [0.00%]
  else
    goto <bb 34>; [0.00%]

  <bb 31> [0.00%]:
  _13 = parent->entry.rbe_left;
  if (elm == _13)
    goto <bb 32>; [0.00%]
  else
    goto <bb 33>; [0.00%]

  <bb 32> [0.00%]:
  parent->entry.rbe_left = child;
  goto <bb 35> (color); [0.00%]

  <bb 33> [0.00%]:
  parent->entry.rbe_right = child;
  goto <bb 35> (color); [0.00%]

  <bb 34> [0.00%]:
  head->rbh_root = child;

color [0.00%]:
  if (color == 0)
    goto <bb 36>; [0.00%]
  else
    goto <bb 37>; [0.00%]

  <bb 36> [0.00%]:
  winlinks_RB_REMOVE_COLOR (head, parent, child);

  <bb 37> [0.00%]:
  D.4873 = old;
  return D.4873;

}



;; Function winlinks_RB_FIND (winlinks_RB_FIND, funcdef_no=55, decl_uid=4348, cgraph_uid=55, symbol_order=58)

winlinks_RB_FIND (struct winlinks * head, struct winlink * elm)
{
  int comp;
  struct winlink * tmp;
  struct winlink * D.4881;

  <bb 2> [0.00%]:
  tmp = head->rbh_root;
  goto <bb 8>; [0.00%]

  <bb 3> [0.00%]:
  comp = winlink_cmp (elm, tmp);
  if (comp < 0)
    goto <bb 4>; [0.00%]
  else
    goto <bb 5>; [0.00%]

  <bb 4> [0.00%]:
  tmp = tmp->entry.rbe_left;
  goto <bb 8>; [0.00%]

  <bb 5> [0.00%]:
  if (comp > 0)
    goto <bb 6>; [0.00%]
  else
    goto <bb 7>; [0.00%]

  <bb 6> [0.00%]:
  tmp = tmp->entry.rbe_right;
  goto <bb 8>; [0.00%]

  <bb 7> [0.00%]:
  D.4881 = tmp;
  goto <bb 10>; [0.00%]

  <bb 8> [0.00%]:
  if (tmp != 0B)
    goto <bb 3>; [0.00%]
  else
    goto <bb 9>; [0.00%]

  <bb 9> [0.00%]:
  D.4881 = 0B;

  <bb 10> [0.00%]:
  return D.4881;

}



;; Function winlinks_RB_NFIND (winlinks_RB_NFIND, funcdef_no=56, decl_uid=4357, cgraph_uid=56, symbol_order=59)

winlinks_RB_NFIND (struct winlinks * head, struct winlink * elm)
{
  int comp;
  struct winlink * res;
  struct winlink * tmp;
  struct winlink * D.4889;

  <bb 2> [0.00%]:
  tmp = head->rbh_root;
  res = 0B;
  goto <bb 8>; [0.00%]

  <bb 3> [0.00%]:
  comp = winlink_cmp (elm, tmp);
  if (comp < 0)
    goto <bb 4>; [0.00%]
  else
    goto <bb 5>; [0.00%]

  <bb 4> [0.00%]:
  res = tmp;
  tmp = tmp->entry.rbe_left;
  goto <bb 8>; [0.00%]

  <bb 5> [0.00%]:
  if (comp > 0)
    goto <bb 6>; [0.00%]
  else
    goto <bb 7>; [0.00%]

  <bb 6> [0.00%]:
  tmp = tmp->entry.rbe_right;
  goto <bb 8>; [0.00%]

  <bb 7> [0.00%]:
  D.4889 = tmp;
  goto <bb 10>; [0.00%]

  <bb 8> [0.00%]:
  if (tmp != 0B)
    goto <bb 3>; [0.00%]
  else
    goto <bb 9>; [0.00%]

  <bb 9> [0.00%]:
  D.4889 = res;

  <bb 10> [0.00%]:
  return D.4889;

}



;; Function winlinks_RB_NEXT (winlinks_RB_NEXT, funcdef_no=57, decl_uid=4366, cgraph_uid=57, symbol_order=60)

winlinks_RB_NEXT (struct winlink * elm)
{
  struct winlink * D.4899;

  <bb 2> [0.00%]:
  _1 = elm->entry.rbe_right;
  if (_1 != 0B)
    goto <bb 3>; [0.00%]
  else
    goto <bb 6>; [0.00%]

  <bb 3> [0.00%]:
  elm = elm->entry.rbe_right;
  goto <bb 5>; [0.00%]

  <bb 4> [0.00%]:
  elm = elm->entry.rbe_left;

  <bb 5> [0.00%]:
  _2 = elm->entry.rbe_left;
  if (_2 != 0B)
    goto <bb 4>; [0.00%]
  else
    goto <bb 13>; [0.00%]

  <bb 6> [0.00%]:
  _3 = elm->entry.rbe_parent;
  if (_3 != 0B)
    goto <bb 7>; [0.00%]
  else
    goto <bb 10>; [0.00%]

  <bb 7> [0.00%]:
  _4 = elm->entry.rbe_parent;
  _5 = _4->entry.rbe_left;
  if (elm == _5)
    goto <bb 8>; [0.00%]
  else
    goto <bb 10>; [0.00%]

  <bb 8> [0.00%]:
  elm = elm->entry.rbe_parent;
  goto <bb 13>; [0.00%]

  <bb 9> [0.00%]:
  elm = elm->entry.rbe_parent;

  <bb 10> [0.00%]:
  _6 = elm->entry.rbe_parent;
  if (_6 != 0B)
    goto <bb 11>; [0.00%]
  else
    goto <bb 12>; [0.00%]

  <bb 11> [0.00%]:
  _7 = elm->entry.rbe_parent;
  _8 = _7->entry.rbe_right;
  if (elm == _8)
    goto <bb 9>; [0.00%]
  else
    goto <bb 12>; [0.00%]

  <bb 12> [0.00%]:
  elm = elm->entry.rbe_parent;

  <bb 13> [0.00%]:
  D.4899 = elm;
  return D.4899;

}



;; Function winlinks_RB_PREV (winlinks_RB_PREV, funcdef_no=58, decl_uid=4375, cgraph_uid=58, symbol_order=61)

winlinks_RB_PREV (struct winlink * elm)
{
  struct winlink * D.4909;

  <bb 2> [0.00%]:
  _1 = elm->entry.rbe_left;
  if (_1 != 0B)
    goto <bb 3>; [0.00%]
  else
    goto <bb 6>; [0.00%]

  <bb 3> [0.00%]:
  elm = elm->entry.rbe_left;
  goto <bb 5>; [0.00%]

  <bb 4> [0.00%]:
  elm = elm->entry.rbe_right;

  <bb 5> [0.00%]:
  _2 = elm->entry.rbe_right;
  if (_2 != 0B)
    goto <bb 4>; [0.00%]
  else
    goto <bb 13>; [0.00%]

  <bb 6> [0.00%]:
  _3 = elm->entry.rbe_parent;
  if (_3 != 0B)
    goto <bb 7>; [0.00%]
  else
    goto <bb 10>; [0.00%]

  <bb 7> [0.00%]:
  _4 = elm->entry.rbe_parent;
  _5 = _4->entry.rbe_right;
  if (elm == _5)
    goto <bb 8>; [0.00%]
  else
    goto <bb 10>; [0.00%]

  <bb 8> [0.00%]:
  elm = elm->entry.rbe_parent;
  goto <bb 13>; [0.00%]

  <bb 9> [0.00%]:
  elm = elm->entry.rbe_parent;

  <bb 10> [0.00%]:
  _6 = elm->entry.rbe_parent;
  if (_6 != 0B)
    goto <bb 11>; [0.00%]
  else
    goto <bb 12>; [0.00%]

  <bb 11> [0.00%]:
  _7 = elm->entry.rbe_parent;
  _8 = _7->entry.rbe_left;
  if (elm == _8)
    goto <bb 9>; [0.00%]
  else
    goto <bb 12>; [0.00%]

  <bb 12> [0.00%]:
  elm = elm->entry.rbe_parent;

  <bb 13> [0.00%]:
  D.4909 = elm;
  return D.4909;

}



;; Function winlinks_RB_MINMAX (winlinks_RB_MINMAX, funcdef_no=59, decl_uid=4385, cgraph_uid=59, symbol_order=62)

winlinks_RB_MINMAX (struct winlinks * head, int val)
{
  struct winlink * parent;
  struct winlink * tmp;
  struct winlink * D.4914;

  <bb 2> [0.00%]:
  tmp = head->rbh_root;
  parent = 0B;
  goto <bb 6>; [0.00%]

  <bb 3> [0.00%]:
  parent = tmp;
  if (val < 0)
    goto <bb 4>; [0.00%]
  else
    goto <bb 5>; [0.00%]

  <bb 4> [0.00%]:
  tmp = tmp->entry.rbe_left;
  goto <bb 6>; [0.00%]

  <bb 5> [0.00%]:
  tmp = tmp->entry.rbe_right;

  <bb 6> [0.00%]:
  if (tmp != 0B)
    goto <bb 3>; [0.00%]
  else
    goto <bb 7>; [0.00%]

  <bb 7> [0.00%]:
  D.4914 = parent;
  return D.4914;

}



;; Function xrealloc (xrealloc, funcdef_no=60, decl_uid=4395, cgraph_uid=60, symbol_order=63)

xrealloc (void * oldptr, size_t nmemb, size_t size)
{
  void * newptr;
  size_t newsize;
  void * D.4922;

  <bb 2> [0.00%]:
  newsize = nmemb * size;
  if (newsize == 0)
    goto <bb 3>; [0.00%]
  else
    goto <bb 4>; [0.00%]

  <bb 3> [0.00%]:
  printf ("zero size%s", "");
  exit (1);

  <bb 4> [0.00%]:
  _1 = 1073741824 / nmemb;
  if (size > _1)
    goto <bb 5>; [0.00%]
  else
    goto <bb 6>; [0.00%]

  <bb 5> [0.00%]:
  printf ("nmemb * size > SIZE_MAX%s", "");
  exit (1);

  <bb 6> [0.00%]:
  newptr = realloc (oldptr, newsize);
  if (newptr == 0B)
    goto <bb 7>; [0.00%]
  else
    goto <bb 8>; [0.00%]

  <bb 7> [0.00%]:
  printf ("xrealloc failed%s", "");
  exit (1);

  <bb 8> [0.00%]:
  D.4922 = newptr;
  return D.4922;

}



;; Function winlink_find_by_index (winlink_find_by_index, funcdef_no=61, decl_uid=4401, cgraph_uid=61, symbol_order=64)

winlink_find_by_index (struct winlinks * wwl, int idx)
{
  struct winlink wl;
  struct winlink * D.4928;

  <bb 2> [0.00%]:
  if (idx < 0)
    goto <bb 3>; [0.00%]
  else
    goto <bb 4>; [0.00%]

  <bb 3> [0.00%]:
  printf ("bad index%s", "");
  exit (1);

  <bb 4> [0.00%]:
  wl.idx = idx;
  D.4928 = winlinks_RB_FIND (wwl, &wl);
  wl = {CLOBBER};
  return D.4928;

}



;; Function winlink_count (winlink_count, funcdef_no=62, decl_uid=4405, cgraph_uid=62, symbol_order=65)

winlink_count (struct winlinks * wwl)
{
  u_int n;
  struct winlink * wl;
  u_int D.4931;

  <bb 2> [0.00%]:
  n = 0;
  wl = winlinks_RB_MINMAX (wwl, -1);
  goto <bb 4>; [0.00%]

  <bb 3> [0.00%]:
  n = n + 1;
  wl = winlinks_RB_NEXT (wl);

  <bb 4> [0.00%]:
  if (wl != 0B)
    goto <bb 3>; [0.00%]
  else
    goto <bb 5>; [0.00%]

  <bb 5> [0.00%]:
  D.4931 = n;
  return D.4931;

}



;; Function winlink_next_index (winlink_next_index, funcdef_no=63, decl_uid=4414, cgraph_uid=63, symbol_order=66)

winlink_next_index (struct winlinks * wwl, int idx)
{
  int i;
  int D.4935;

  <bb 2> [0.00%]:
  i = idx;

  <bb 3> [0.00%]:
  _1 = winlink_find_by_index (wwl, i);
  if (_1 == 0B)
    goto <bb 4>; [0.00%]
  else
    goto <bb 5>; [0.00%]

  <bb 4> [0.00%]:
  D.4935 = i;
  goto <bb 10>; [0.00%]

  <bb 5> [0.00%]:
  if (i == 10000)
    goto <bb 6>; [0.00%]
  else
    goto <bb 7>; [0.00%]

  <bb 6> [0.00%]:
  i = 0;
  goto <bb 8>; [0.00%]

  <bb 7> [0.00%]:
  i = i + 1;

  <bb 8> [0.00%]:
  if (i != idx)
    goto <bb 3>; [0.00%]
  else
    goto <bb 9>; [0.00%]

  <bb 9> [0.00%]:
  D.4935 = -1;

  <bb 10> [0.00%]:
  return D.4935;

}



;; Function winlink_find_by_window (winlink_find_by_window, funcdef_no=64, decl_uid=4421, cgraph_uid=64, symbol_order=67)

winlink_find_by_window (struct winlinks * wwl, struct window * w)
{
  struct winlink * wl;
  struct winlink * D.4942;

  <bb 2> [0.00%]:
  wl = winlinks_RB_MINMAX (wwl, -1);
  goto <bb 6>; [0.00%]

  <bb 3> [0.00%]:
  _1 = wl->window;
  if (w == _1)
    goto <bb 4>; [0.00%]
  else
    goto <bb 5>; [0.00%]

  <bb 4> [0.00%]:
  D.4942 = wl;
  goto <bb 8>; [0.00%]

  <bb 5> [0.00%]:
  wl = winlinks_RB_NEXT (wl);

  <bb 6> [0.00%]:
  if (wl != 0B)
    goto <bb 3>; [0.00%]
  else
    goto <bb 7>; [0.00%]

  <bb 7> [0.00%]:
  D.4942 = 0B;

  <bb 8> [0.00%]:
  return D.4942;

}



;; Function cmd_find_pane (cmd_find_pane, funcdef_no=65, decl_uid=4429, cgraph_uid=65, symbol_order=68)

cmd_find_pane (int arg, struct session * * sp)
{
  u_int idx;
  struct winlink * wl;
  struct session * s;
  struct winlink * D.4946;

  <bb 2> [0.00%]:
  _1 = sessions.num;
  if (_1 == 0)
    goto <bb 3>; [0.00%]
  else
    goto <bb 4>; [0.00%]

  <bb 3> [0.00%]:
  printf ("can\'t establish current session\n");
  D.4946 = 0B;
  goto <bb 9>; [0.00%]

  <bb 4> [0.00%]:
  _2 = sessions.list;
  s = MEM[(struct session * *)_2 + 8B];
  if (sp != 0B)
    goto <bb 5>; [0.00%]
  else
    goto <bb 6>; [0.00%]

  <bb 5> [0.00%]:
  *sp = s;

  <bb 6> [0.00%]:
  if (arg != 0)
    goto <bb 7>; [0.00%]
  else
    goto <bb 8>; [0.00%]

  <bb 7> [0.00%]:
  D.4946 = s->curw;
  goto <bb 9>; [0.00%]

  <bb 8> [0.00%]:
  _3 = s->curw;
  D.4946 = winlinks_RB_NEXT (_3);

  <bb 9> [0.00%]:
  return D.4946;

}



;; Function session_has (session_has, funcdef_no=66, decl_uid=4436, cgraph_uid=66, symbol_order=69)

session_has (struct session * s, struct window * w)
{
  struct winlink * wl;
  int D.4954;

  <bb 2> [0.00%]:
  _1 = &s->windows;
  wl = winlinks_RB_MINMAX (_1, -1);
  goto <bb 6>; [0.00%]

  <bb 3> [0.00%]:
  _2 = wl->window;
  if (w == _2)
    goto <bb 4>; [0.00%]
  else
    goto <bb 5>; [0.00%]

  <bb 4> [0.00%]:
  D.4954 = 1;
  goto <bb 8>; [0.00%]

  <bb 5> [0.00%]:
  wl = winlinks_RB_NEXT (wl);

  <bb 6> [0.00%]:
  if (wl != 0B)
    goto <bb 3>; [0.00%]
  else
    goto <bb 7>; [0.00%]

  <bb 7> [0.00%]:
  D.4954 = 0;

  <bb 8> [0.00%]:
  return D.4954;

}



;; Function session_group_find (session_group_find, funcdef_no=67, decl_uid=4443, cgraph_uid=67, symbol_order=70)

session_group_find (struct session * target)
{
  struct session * s;
  struct session_group * sg;
  struct session_group * D.4958;

  <bb 2> [0.00%]:
  sg = session_groups.tqh_first;
  goto <bb 9>; [0.00%]

  <bb 3> [0.00%]:
  s = sg->sessions.tqh_first;
  goto <bb 7>; [0.00%]

  <bb 4> [0.00%]:
  if (s == target)
    goto <bb 5>; [0.00%]
  else
    goto <bb 6>; [0.00%]

  <bb 5> [0.00%]:
  D.4958 = sg;
  goto <bb 11>; [0.00%]

  <bb 6> [0.00%]:
  s = s->gentry.tqe_next;

  <bb 7> [0.00%]:
  if (s != 0B)
    goto <bb 4>; [0.00%]
  else
    goto <bb 8>; [0.00%]

  <bb 8> [0.00%]:
  sg = sg->entry.tqe_next;

  <bb 9> [0.00%]:
  if (sg != 0B)
    goto <bb 3>; [0.00%]
  else
    goto <bb 10>; [0.00%]

  <bb 10> [0.00%]:
  D.4958 = 0B;

  <bb 11> [0.00%]:
  return D.4958;

}



;; Function session_group_add (session_group_add, funcdef_no=68, decl_uid=4455, cgraph_uid=68, symbol_order=71)

session_group_add (struct session * target, struct session * s)
{
  struct session_group * sg;

  <bb 2> [0.00%]:
  sg = session_group_find (target);
  if (sg == 0B)
    goto <bb 3>; [0.00%]
  else
    goto <bb 4>; [0.00%]

  <bb 3> [0.00%]:
  sg = malloc (32);
  sg->entry.tqe_next = 0B;
  _1 = session_groups.tqh_last;
  sg->entry.tqe_prev = _1;
  _2 = session_groups.tqh_last;
  *_2 = sg;
  _3 = &sg->entry.tqe_next;
  session_groups.tqh_last = _3;
  sg->sessions.tqh_first = 0B;
  _4 = &sg->sessions.tqh_first;
  sg->sessions.tqh_last = _4;
  target->gentry.tqe_next = 0B;
  _5 = sg->sessions.tqh_last;
  target->gentry.tqe_prev = _5;
  _6 = sg->sessions.tqh_last;
  *_6 = target;
  _7 = &target->gentry.tqe_next;
  sg->sessions.tqh_last = _7;

  <bb 4> [0.00%]:
  s->gentry.tqe_next = 0B;
  _8 = sg->sessions.tqh_last;
  s->gentry.tqe_prev = _8;
  _9 = sg->sessions.tqh_last;
  *_9 = s;
  _10 = &s->gentry.tqe_next;
  sg->sessions.tqh_last = _10;
  return;

}



;; Function winlink_add (winlink_add, funcdef_no=69, decl_uid=4461, cgraph_uid=69, symbol_order=72)

winlink_add (struct winlinks * wwl, struct window * w, int idx)
{
  struct winlink * wl;
  struct winlink * D.4966;

  <bb 2> [0.00%]:
  if (idx < 0)
    goto <bb 3>; [0.00%]
  else
    goto <bb 5>; [0.00%]

  <bb 3> [0.00%]:
  _1 = ~idx;
  idx = winlink_next_index (wwl, _1);
  if (idx == -1)
    goto <bb 4>; [0.00%]
  else
    goto <bb 7>; [0.00%]

  <bb 4> [0.00%]:
  D.4966 = 0B;
  goto <bb 8>; [0.00%]

  <bb 5> [0.00%]:
  _2 = winlink_find_by_index (wwl, idx);
  if (_2 != 0B)
    goto <bb 6>; [0.00%]
  else
    goto <bb 7>; [0.00%]

  <bb 6> [0.00%]:
  D.4966 = 0B;
  goto <bb 8>; [0.00%]

  <bb 7> [0.00%]:
  wl = calloc (1, 136);
  wl->idx = idx;
  wl->window = w;
  winlinks_RB_INSERT (wwl, wl);
  _3 = w->references;
  _4 = _3 + 1;
  w->references = _4;
  D.4966 = wl;

  <bb 8> [0.00%]:
  return D.4966;

}



;; Function window_index (window_index, funcdef_no=70, decl_uid=4466, cgraph_uid=70, symbol_order=73)

window_index (struct window * s, u_int * i)
{
  int D.4973;

  <bb 2> [0.00%]:
  *i = 0;
  goto <bb 6>; [0.00%]

  <bb 3> [0.00%]:
  _1 = windows.list;
  _2 = *i;
  _3 = (long unsigned int) _2;
  _4 = _3 * 8;
  _5 = _1 + _4;
  _6 = *_5;
  if (s == _6)
    goto <bb 4>; [0.00%]
  else
    goto <bb 5>; [0.00%]

  <bb 4> [0.00%]:
  D.4973 = 0;
  goto <bb 8>; [0.00%]

  <bb 5> [0.00%]:
  _7 = *i;
  _8 = _7 + 1;
  *i = _8;

  <bb 6> [0.00%]:
  _9 = *i;
  _10 = windows.num;
  if (_9 < _10)
    goto <bb 3>; [0.00%]
  else
    goto <bb 7>; [0.00%]

  <bb 7> [0.00%]:
  D.4973 = -1;

  <bb 8> [0.00%]:
  return D.4973;

}



;; Function session_group_remove (session_group_remove, funcdef_no=71, decl_uid=4472, cgraph_uid=71, symbol_order=74)

session_group_remove (struct session * s)
{
  struct session_group * sg;

  <bb 2> [0.00%]:
  sg = session_group_find (s);
  if (sg == 0B)
    goto <bb 16>; [0.00%]
  else
    goto <bb 3>; [0.00%]

  <bb 3> [0.00%]:
  _1 = s->gentry.tqe_next;
  if (_1 != 0B)
    goto <bb 4>; [0.00%]
  else
    goto <bb 5>; [0.00%]

  <bb 4> [0.00%]:
  _2 = s->gentry.tqe_next;
  _3 = s->gentry.tqe_prev;
  _2->gentry.tqe_prev = _3;
  goto <bb 6>; [0.00%]

  <bb 5> [0.00%]:
  _4 = s->gentry.tqe_prev;
  sg->sessions.tqh_last = _4;

  <bb 6> [0.00%]:
  _5 = s->gentry.tqe_prev;
  _6 = s->gentry.tqe_next;
  *_5 = _6;
  _7 = sg->sessions.tqh_first;
  _8 = _7->gentry.tqe_next;
  if (_8 == 0B)
    goto <bb 7>; [0.00%]
  else
    goto <bb 11>; [0.00%]

  <bb 7> [0.00%]:
  _9 = sg->sessions.tqh_first;
  _10 = _9->gentry.tqe_next;
  if (_10 != 0B)
    goto <bb 8>; [0.00%]
  else
    goto <bb 9>; [0.00%]

  <bb 8> [0.00%]:
  _11 = sg->sessions.tqh_first;
  _12 = sg->sessions.tqh_first;
  _13 = _12->gentry.tqe_next;
  _14 = _11->gentry.tqe_prev;
  _13->gentry.tqe_prev = _14;
  goto <bb 10>; [0.00%]

  <bb 9> [0.00%]:
  _15 = sg->sessions.tqh_first;
  _16 = _15->gentry.tqe_prev;
  sg->sessions.tqh_last = _16;

  <bb 10> [0.00%]:
  _17 = sg->sessions.tqh_first;
  _18 = sg->sessions.tqh_first;
  _19 = _18->gentry.tqe_prev;
  _20 = _17->gentry.tqe_next;
  *_19 = _20;

  <bb 11> [0.00%]:
  _21 = sg->sessions.tqh_first;
  if (_21 == 0B)
    goto <bb 12>; [0.00%]
  else
    goto <bb 16>; [0.00%]

  <bb 12> [0.00%]:
  _22 = sg->entry.tqe_next;
  if (_22 != 0B)
    goto <bb 13>; [0.00%]
  else
    goto <bb 14>; [0.00%]

  <bb 13> [0.00%]:
  _23 = sg->entry.tqe_next;
  _24 = sg->entry.tqe_prev;
  _23->entry.tqe_prev = _24;
  goto <bb 15>; [0.00%]

  <bb 14> [0.00%]:
  _25 = sg->entry.tqe_prev;
  session_groups.tqh_last = _25;

  <bb 15> [0.00%]:
  _26 = sg->entry.tqe_prev;
  _27 = sg->entry.tqe_next;
  *_26 = _27;
  free (sg);

  <bb 16> [0.00%]:
  return;

}



;; Function session_find (session_find, funcdef_no=72, decl_uid=4476, cgraph_uid=72, symbol_order=75)

session_find (const char * name)
{
  u_int i;
  struct session * s;
  struct session * D.4995;

  <bb 2> [0.00%]:
  i = 0;
  goto <bb 7>; [0.00%]

  <bb 3> [0.00%]:
  _1 = sessions.list;
  _2 = (long unsigned int) i;
  _3 = _2 * 8;
  _4 = _1 + _3;
  s = *_4;
  if (s != 0B)
    goto <bb 4>; [0.00%]
  else
    goto <bb 6>; [0.00%]

  <bb 4> [0.00%]:
  _5 = s->name;
  _6 = strcmp (_5, name);
  if (_6 == 0)
    goto <bb 5>; [0.00%]
  else
    goto <bb 6>; [0.00%]

  <bb 5> [0.00%]:
  D.4995 = s;
  goto <bb 9>; [0.00%]

  <bb 6> [0.00%]:
  i = i + 1;

  <bb 7> [0.00%]:
  _7 = sessions.num;
  if (i < _7)
    goto <bb 3>; [0.00%]
  else
    goto <bb 8>; [0.00%]

  <bb 8> [0.00%]:
  D.4995 = 0B;

  <bb 9> [0.00%]:
  return D.4995;

}



;; Function session_index (session_index, funcdef_no=73, decl_uid=4485, cgraph_uid=73, symbol_order=76)

session_index (struct session * s, u_int * i)
{
  int D.4999;

  <bb 2> [0.00%]:
  *i = 0;
  goto <bb 6>; [0.00%]

  <bb 3> [0.00%]:
  _1 = sessions.list;
  _2 = *i;
  _3 = (long unsigned int) _2;
  _4 = _3 * 8;
  _5 = _1 + _4;
  _6 = *_5;
  if (s == _6)
    goto <bb 4>; [0.00%]
  else
    goto <bb 5>; [0.00%]

  <bb 4> [0.00%]:
  D.4999 = 0;
  goto <bb 8>; [0.00%]

  <bb 5> [0.00%]:
  _7 = *i;
  _8 = _7 + 1;
  *i = _8;

  <bb 6> [0.00%]:
  _9 = *i;
  _10 = sessions.num;
  if (_9 < _10)
    goto <bb 3>; [0.00%]
  else
    goto <bb 7>; [0.00%]

  <bb 7> [0.00%]:
  D.4999 = -1;

  <bb 8> [0.00%]:
  return D.4999;

}



;; Function winlink_stack_remove (winlink_stack_remove, funcdef_no=74, decl_uid=4492, cgraph_uid=74, symbol_order=77)

winlink_stack_remove (struct winlink_stack * stack, struct winlink * wl)
{
  struct winlink * wl2;

  <bb 2> [0.00%]:
  if (wl == 0B)
    goto <bb 11>; [0.00%]
  else
    goto <bb 3>; [0.00%]

  <bb 3> [0.00%]:
  wl2 = stack->tqh_first;
  goto <bb 10>; [0.00%]

  <bb 4> [0.00%]:
  if (wl2 == wl)
    goto <bb 5>; [0.00%]
  else
    goto <bb 9>; [0.00%]

  <bb 5> [0.00%]:
  _1 = wl->sentry.tqe_next;
  if (_1 != 0B)
    goto <bb 6>; [0.00%]
  else
    goto <bb 7>; [0.00%]

  <bb 6> [0.00%]:
  _2 = wl->sentry.tqe_next;
  _3 = wl->sentry.tqe_prev;
  _2->sentry.tqe_prev = _3;
  goto <bb 8>; [0.00%]

  <bb 7> [0.00%]:
  _4 = wl->sentry.tqe_prev;
  stack->tqh_last = _4;

  <bb 8> [0.00%]:
  _5 = wl->sentry.tqe_prev;
  _6 = wl->sentry.tqe_next;
  *_5 = _6;
  goto <bb 11>; [0.00%]

  <bb 9> [0.00%]:
  wl2 = wl2->sentry.tqe_next;

  <bb 10> [0.00%]:
  if (wl2 != 0B)
    goto <bb 4>; [0.00%]
  else
    goto <bb 11>; [0.00%]

  <bb 11> [0.00%]:
  return;

}



;; Function winlink_stack_push (winlink_stack_push, funcdef_no=75, decl_uid=4500, cgraph_uid=75, symbol_order=78)

winlink_stack_push (struct winlink_stack * stack, struct winlink * wl)
{
  <bb 2> [0.00%]:
  if (wl == 0B)
    goto <bb 7>; [0.00%]
  else
    goto <bb 3>; [0.00%]

  <bb 3> [0.00%]:
  winlink_stack_remove (stack, wl);
  _1 = stack->tqh_first;
  wl->sentry.tqe_next = _1;
  _2 = wl->sentry.tqe_next;
  if (_2 != 0B)
    goto <bb 4>; [0.00%]
  else
    goto <bb 5>; [0.00%]

  <bb 4> [0.00%]:
  _3 = stack->tqh_first;
  _4 = &wl->sentry.tqe_next;
  _3->sentry.tqe_prev = _4;
  goto <bb 6>; [0.00%]

  <bb 5> [0.00%]:
  _5 = &wl->sentry.tqe_next;
  stack->tqh_last = _5;

  <bb 6> [0.00%]:
  stack->tqh_first = wl;
  _6 = &stack->tqh_first;
  wl->sentry.tqe_prev = _6;

  <bb 7> [0.00%]:
  return;

}



;; Function window_destroy (window_destroy, funcdef_no=76, decl_uid=4503, cgraph_uid=76, symbol_order=79)

window_destroy (struct window * w)
{
  u_int i;

  <bb 2> [0.00%]:
  _1 = window_index (w, &i);
  if (_1 != 0)
    goto <bb 3>; [0.00%]
  else
    goto <bb 4>; [0.00%]

  <bb 3> [0.00%]:
  printf ("index not found%s\n", "");
  exit (1);

  <bb 4> [0.00%]:
  _2 = windows.list;
  i.0_3 = i;
  _4 = (long unsigned int) i.0_3;
  _5 = _4 * 8;
  _6 = _2 + _5;
  *_6 = 0B;
  goto <bb 8>; [0.00%]

  <bb 5> [0.00%]:
  _7 = windows.num;
  if (_7 > 1)
    goto <bb 6>; [0.00%]
  else
    goto <bb 7>; [0.00%]

  <bb 6> [0.00%]:
  _8 = windows.num;
  _9 = _8 + 4294967295;
  windows.num = _9;
  goto <bb 8>; [0.00%]

  <bb 7> [0.00%]:
  _10 = windows.list;
  free (_10);
  windows.num = 0;
  windows.list = 0B;
  windows.space = 0;

  <bb 8> [0.00%]:
  _11 = windows.num;
  if (_11 != 0)
    goto <bb 9>; [0.00%]
  else
    goto <bb 10>; [0.00%]

  <bb 9> [0.00%]:
  _12 = windows.list;
  _13 = windows.num;
  _14 = _13 + 4294967295;
  _15 = (long unsigned int) _14;
  _16 = _15 * 8;
  _17 = _12 + _16;
  _18 = *_17;
  if (_18 == 0B)
    goto <bb 5>; [0.00%]
  else
    goto <bb 10>; [0.00%]

  <bb 10> [0.00%]:
  _19 = w->name;
  if (_19 != 0B)
    goto <bb 11>; [0.00%]
  else
    goto <bb 12>; [0.00%]

  <bb 11> [0.00%]:
  _20 = w->name;
  free (_20);

  <bb 12> [0.00%]:
  free (w);
  i = {CLOBBER};
  return;

}



;; Function winlink_remove (winlink_remove, funcdef_no=77, decl_uid=4511, cgraph_uid=77, symbol_order=80)

winlink_remove (struct winlinks * wwl, struct winlink * wl)
{
  struct window * w;

  <bb 2> [0.00%]:
  w = wl->window;
  winlinks_RB_REMOVE (wwl, wl);
  _1 = wl->status_text;
  if (_1 != 0B)
    goto <bb 3>; [0.00%]
  else
    goto <bb 4>; [0.00%]

  <bb 3> [0.00%]:
  _2 = wl->status_text;
  free (_2);

  <bb 4> [0.00%]:
  free (wl);
  _3 = w->references;
  if (_3 == 0)
    goto <bb 5>; [0.00%]
  else
    goto <bb 6>; [0.00%]

  <bb 5> [0.00%]:
  printf ("bad reference count%s\n", "");
  exit (1);

  <bb 6> [0.00%]:
  _4 = w->references;
  _5 = _4 + 4294967295;
  w->references = _5;
  _6 = w->references;
  if (_6 == 0)
    goto <bb 7>; [0.00%]
  else
    goto <bb 8>; [0.00%]

  <bb 7> [0.00%]:
  window_destroy (w);

  <bb 8> [0.00%]:
  return;

}



;; Function session_group_synchronize1 (session_group_synchronize1, funcdef_no=78, decl_uid=4516, cgraph_uid=78, symbol_order=81)

session_group_synchronize1 (struct session * target, struct session * s)
{
  struct session_alert * sa;
  struct winlink * wl2;
  struct winlink * wl;
  struct winlink_stack old_lastw;
  struct winlinks * ww;
  struct winlinks old_windows;

  <bb 2> [0.00%]:
  ww = &target->windows;
  _1 = ww->rbh_root;
  if (_1 == 0B)
    goto <bb 15>; [0.00%]
  else
    goto <bb 3>; [0.00%]

  <bb 3> [0.00%]:
  _2 = &s->windows;
  memcpy (&old_windows, _2, 8);
  s->windows.rbh_root = 0B;
  wl = winlinks_RB_MINMAX (ww, -1);
  goto <bb 5>; [0.00%]

  <bb 4> [0.00%]:
  _3 = wl->idx;
  _4 = wl->window;
  _5 = &s->windows;
  winlink_add (_5, _4, _3);
  wl = winlinks_RB_NEXT (wl);

  <bb 5> [0.00%]:
  if (wl != 0B)
    goto <bb 4>; [0.00%]
  else
    goto <bb 6>; [0.00%]

  <bb 6> [0.00%]:
  _6 = &s->lastw;
  memcpy (&old_lastw, _6, 16);
  s->lastw.tqh_first = 0B;
  _7 = &s->lastw.tqh_first;
  s->lastw.tqh_last = _7;
  wl = old_lastw.tqh_first;
  goto <bb 10>; [0.00%]

  <bb 7> [0.00%]:
  _8 = wl->idx;
  _9 = &s->windows;
  wl2 = winlink_find_by_index (_9, _8);
  if (wl2 != 0B)
    goto <bb 8>; [0.00%]
  else
    goto <bb 9>; [0.00%]

  <bb 8> [0.00%]:
  wl2->sentry.tqe_next = 0B;
  _10 = s->lastw.tqh_last;
  wl2->sentry.tqe_prev = _10;
  _11 = s->lastw.tqh_last;
  *_11 = wl2;
  _12 = &wl2->sentry.tqe_next;
  s->lastw.tqh_last = _12;

  <bb 9> [0.00%]:
  wl = wl->sentry.tqe_next;

  <bb 10> [0.00%]:
  if (wl != 0B)
    goto <bb 7>; [0.00%]
  else
    goto <bb 11>; [0.00%]

  <bb 11> [0.00%]:
  _13 = s->lastw.tqh_first;
  s->curw = _13;
  goto <bb 13>; [0.00%]

  <bb 12> [0.00%]:
  wl = old_windows.rbh_root;
  winlink_remove (&old_windows, wl);

  <bb 13> [0.00%]:
  _14 = old_windows.rbh_root;
  if (_14 != 0B)
    goto <bb 12>; [0.00%]
  else
    goto <bb 14>; [0.00%]

  <bb 14> [0.00%]:
  old_windows = {CLOBBER};
  old_lastw = {CLOBBER};
  goto <bb 16>; [0.00%]

  <bb 15> [0.00%]:
  old_windows = {CLOBBER};
  old_lastw = {CLOBBER};

  <bb 16> [0.00%]:
  return;

}



;; Function session_group_synchronize_to (session_group_synchronize_to, funcdef_no=79, decl_uid=4535, cgraph_uid=79, symbol_order=82)

session_group_synchronize_to (struct session * s)
{
  struct session * target;
  struct session_group * sg;

  <bb 2> [0.00%]:
  sg = session_group_find (s);
  if (sg == 0B)
    goto <bb 8>; [0.00%]
  else
    goto <bb 3>; [0.00%]

  <bb 3> [0.00%]:
  target = 0B;
  target = sg->sessions.tqh_first;
  goto <bb 6>; [0.00%]

  <bb 4> [0.00%]:
  if (target != s)
    goto <bb 7>; [0.00%]
  else
    goto <bb 5>; [0.00%]

  <bb 5> [0.00%]:
  target = target->gentry.tqe_next;

  <bb 6> [0.00%]:
  if (target != 0B)
    goto <bb 4>; [0.00%]
  else
    goto <bb 7>; [0.00%]

  <bb 7> [0.00%]:
  session_group_synchronize1 (target, s);

  <bb 8> [0.00%]:
  return;

}



;; Function session_group_synchronize_from (session_group_synchronize_from, funcdef_no=80, decl_uid=4543, cgraph_uid=80, symbol_order=83)

session_group_synchronize_from (struct session * target)
{
  struct session * s;
  struct session_group * sg;

  <bb 2> [0.00%]:
  sg = session_group_find (target);
  if (sg == 0B)
    goto <bb 8>; [0.00%]
  else
    goto <bb 3>; [0.00%]

  <bb 3> [0.00%]:
  s = sg->sessions.tqh_first;
  goto <bb 7>; [0.00%]

  <bb 4> [0.00%]:
  if (s != target)
    goto <bb 5>; [0.00%]
  else
    goto <bb 6>; [0.00%]

  <bb 5> [0.00%]:
  session_group_synchronize1 (target, s);

  <bb 6> [0.00%]:
  s = s->gentry.tqe_next;

  <bb 7> [0.00%]:
  if (s != 0B)
    goto <bb 4>; [0.00%]
  else
    goto <bb 8>; [0.00%]

  <bb 8> [0.00%]:
  return;

}



;; Function session_destroy (session_destroy, funcdef_no=81, decl_uid=4551, cgraph_uid=81, symbol_order=84)

session_destroy (struct session * s)
{
  u_int i;

  <bb 2> [0.00%]:
  _1 = s->name;
  printf ("session %s destroyed\n", _1);
  _2 = session_index (s, &i);
  if (_2 != 0)
    goto <bb 3>; [0.00%]
  else
    goto <bb 4>; [0.00%]

  <bb 3> [0.00%]:
  printf ("session not found%s\n", "");
  exit (1);

  <bb 4> [0.00%]:
  _3 = sessions.list;
  i.1_4 = i;
  _5 = (long unsigned int) i.1_4;
  _6 = _5 * 8;
  _7 = _3 + _6;
  *_7 = 0B;
  goto <bb 8>; [0.00%]

  <bb 5> [0.00%]:
  _8 = sessions.num;
  if (_8 > 1)
    goto <bb 6>; [0.00%]
  else
    goto <bb 7>; [0.00%]

  <bb 6> [0.00%]:
  _9 = sessions.num;
  _10 = _9 + 4294967295;
  sessions.num = _10;
  goto <bb 8>; [0.00%]

  <bb 7> [0.00%]:
  _11 = sessions.list;
  free (_11);
  sessions.num = 0;
  sessions.list = 0B;
  sessions.space = 0;

  <bb 8> [0.00%]:
  _12 = sessions.num;
  if (_12 != 0)
    goto <bb 9>; [0.00%]
  else
    goto <bb 10>; [0.00%]

  <bb 9> [0.00%]:
  _13 = sessions.list;
  _14 = sessions.num;
  _15 = _14 + 4294967295;
  _16 = (long unsigned int) _15;
  _17 = _16 * 8;
  _18 = _13 + _17;
  _19 = *_18;
  if (_19 == 0B)
    goto <bb 5>; [0.00%]
  else
    goto <bb 10>; [0.00%]

  <bb 10> [0.00%]:
  session_group_remove (s);
  goto <bb 12>; [0.00%]

  <bb 11> [0.00%]:
  _20 = s->lastw.tqh_first;
  _21 = &s->lastw;
  winlink_stack_remove (_21, _20);

  <bb 12> [0.00%]:
  _22 = s->lastw.tqh_first;
  if (_22 != 0B)
    goto <bb 11>; [0.00%]
  else
    goto <bb 14>; [0.00%]

  <bb 13> [0.00%]:
  _23 = s->windows.rbh_root;
  _24 = &s->windows;
  winlink_remove (_24, _23);

  <bb 14> [0.00%]:
  _25 = s->windows.rbh_root;
  if (_25 != 0B)
    goto <bb 13>; [0.00%]
  else
    goto <bb 15>; [0.00%]

  <bb 15> [0.00%]:
  _26 = s->name;
  free (_26);
  free (s);
  i = {CLOBBER};
  return;

}



;; Function session_detach (session_detach, funcdef_no=82, decl_uid=4565, cgraph_uid=82, symbol_order=85)

session_detach (struct session * s, struct winlink * wl)
{
  int D.5055;

  <bb 2> [0.00%]:
  _1 = &s->lastw;
  winlink_stack_remove (_1, wl);
  _2 = &s->windows;
  winlink_remove (_2, wl);
  session_group_synchronize_from (s);
  _3 = s->windows.rbh_root;
  if (_3 == 0B)
    goto <bb 3>; [0.00%]
  else
    goto <bb 4>; [0.00%]

  <bb 3> [0.00%]:
  session_destroy (s);
  D.5055 = 1;
  goto <bb 5>; [0.00%]

  <bb 4> [0.00%]:
  D.5055 = 0;

  <bb 5> [0.00%]:
  return D.5055;

}



;; Function server_destroy_session_group (server_destroy_session_group, funcdef_no=83, decl_uid=4568, cgraph_uid=83, symbol_order=86)

server_destroy_session_group (struct session * s)
{
  struct session_group * sg;

  <bb 2> [0.00%]:
  sg = session_group_find (s);
  if (sg == 0B)
    goto <bb 7>; [0.00%]
  else
    goto <bb 3>; [0.00%]

  <bb 3> [0.00%]:
  _1 = sg->entry.tqe_next;
  if (_1 != 0B)
    goto <bb 4>; [0.00%]
  else
    goto <bb 5>; [0.00%]

  <bb 4> [0.00%]:
  _2 = sg->entry.tqe_next;
  _3 = sg->entry.tqe_prev;
  _2->entry.tqe_prev = _3;
  goto <bb 6>; [0.00%]

  <bb 5> [0.00%]:
  _4 = sg->entry.tqe_prev;
  session_groups.tqh_last = _4;

  <bb 6> [0.00%]:
  _5 = sg->entry.tqe_prev;
  _6 = sg->entry.tqe_next;
  *_5 = _6;
  free (sg);

  <bb 7> [0.00%]:
  return;

}



;; Function server_kill_window (server_kill_window, funcdef_no=84, decl_uid=4572, cgraph_uid=84, symbol_order=87)

server_kill_window (struct window * w)
{
  u_int i;
  struct winlink * wl;
  struct session * s;

  <bb 2> [0.00%]:
  i = 0;
  goto <bb 10>; [0.00%]

  <bb 3> [0.00%]:
  _1 = sessions.list;
  _2 = (long unsigned int) i;
  _3 = _2 * 8;
  _4 = _1 + _3;
  s = *_4;
  if (s == 0B)
    goto <bb 5>; [0.00%]
  else
    goto <bb 4>; [0.00%]

  <bb 4> [0.00%]:
  _5 = session_has (s, w);
  if (_5 == 0)
    goto <bb 5>; [0.00%]
  else
    goto <bb 8>; [0.00%]

  <bb 5> [0.00%]:
  // predicted unlikely by continue predictor.
  goto <bb 9>; [0.00%]

  <bb 6> [0.00%]:
  _6 = session_detach (s, wl);
  if (_6 != 0)
    goto <bb 7>; [0.00%]
  else
    goto <bb 8>; [0.00%]

  <bb 7> [0.00%]:
  server_destroy_session_group (s);
  goto <bb 9>; [0.00%]

  <bb 8> [0.00%]:
  _7 = &s->windows;
  wl = winlink_find_by_window (_7, w);
  if (wl != 0B)
    goto <bb 6>; [0.00%]
  else
    goto <bb 9>; [0.00%]

  <bb 9> [0.00%]:
  i = i + 1;

  <bb 10> [0.00%]:
  _8 = sessions.num;
  if (i < _8)
    goto <bb 3>; [0.00%]
  else
    goto <bb 11>; [0.00%]

  <bb 11> [0.00%]:
  return;

}



;; Function session_select (session_select, funcdef_no=85, decl_uid=4586, cgraph_uid=85, symbol_order=88)

session_select (struct session * s, int idx)
{
  struct winlink * wl;
  int D.5070;

  <bb 2> [0.00%]:
  _1 = &s->windows;
  wl = winlink_find_by_index (_1, idx);
  if (wl == 0B)
    goto <bb 3>; [0.00%]
  else
    goto <bb 4>; [0.00%]

  <bb 3> [0.00%]:
  D.5070 = -1;
  goto <bb 7>; [0.00%]

  <bb 4> [0.00%]:
  _2 = s->curw;
  if (wl == _2)
    goto <bb 5>; [0.00%]
  else
    goto <bb 6>; [0.00%]

  <bb 5> [0.00%]:
  D.5070 = 1;
  goto <bb 7>; [0.00%]

  <bb 6> [0.00%]:
  _3 = &s->lastw;
  winlink_stack_remove (_3, wl);
  _4 = s->curw;
  _5 = &s->lastw;
  winlink_stack_push (_5, _4);
  s->curw = wl;
  D.5070 = 0;

  <bb 7> [0.00%]:
  return D.5070;

}



;; Function join_pane_exec (join_pane_exec, funcdef_no=86, decl_uid=4590, cgraph_uid=86, symbol_order=89)

join_pane_exec ()
{
  struct window * dst_w;
  struct window * src_w;
  struct winlink * dst_wl;
  struct winlink * src_wl;
  struct session * dst_s;
  int D.5076;

  <bb 2> [0.00%]:
  dst_wl = cmd_find_pane (0, &dst_s);
  if (dst_wl == 0B)
    goto <bb 3>; [0.00%]
  else
    goto <bb 4>; [0.00%]

  <bb 3> [0.00%]:
  D.5076 = -1;
  goto <bb 9>; [0.00%]

  <bb 4> [0.00%]:
  dst_w = dst_wl->window;
  src_wl = cmd_find_pane (1, 0B);
  if (src_wl == 0B)
    goto <bb 5>; [0.00%]
  else
    goto <bb 6>; [0.00%]

  <bb 5> [0.00%]:
  D.5076 = -1;
  goto <bb 9>; [0.00%]

  <bb 6> [0.00%]:
  src_w = src_wl->window;
  if (src_w == dst_w)
    goto <bb 7>; [0.00%]
  else
    goto <bb 8>; [0.00%]

  <bb 7> [0.00%]:
  printf ("can\'t join a pane to its own window\n");
  D.5076 = -1;
  goto <bb 9>; [0.00%]

  <bb 8> [0.00%]:
  server_kill_window (src_w);
  _1 = dst_wl->idx;
  dst_s.2_2 = dst_s;
  session_select (dst_s.2_2, _1);
  D.5076 = 0;

  <bb 9> [0.00%]:
  dst_s = {CLOBBER};
  return D.5076;

}



;; Function window_create1 (window_create1, funcdef_no=87, decl_uid=4599, cgraph_uid=87, symbol_order=90)

Removing basic block 15
window_create1 (u_int sx, u_int sy)
{
  u_int i;
  struct window * w;
  struct window * D.5093;

  <bb 2> [0.00%]:
  w = malloc (88);
  w->name = 0B;
  w->flags = 0;
  w->active = 0B;
  w->lastlayout = -1;
  w->layout_root = 0B;
  w->sx = sx;
  w->sy = sy;
  i = 0;
  goto <bb 6>; [0.00%]

  <bb 3> [0.00%]:
  _1 = windows.list;
  _2 = (long unsigned int) i;
  _3 = _2 * 8;
  _4 = _1 + _3;
  _5 = *_4;
  if (_5 == 0B)
    goto <bb 4>; [0.00%]
  else
    goto <bb 5>; [0.00%]

  <bb 4> [0.00%]:
  _6 = windows.list;
  _7 = (long unsigned int) i;
  _8 = _7 * 8;
  _9 = _6 + _8;
  *_9 = w;
  goto <bb 7>; [0.00%]

  <bb 5> [0.00%]:
  i = i + 1;

  <bb 6> [0.00%]:
  _10 = windows.num;
  if (i < _10)
    goto <bb 3>; [0.00%]
  else
    goto <bb 7>; [0.00%]

  <bb 7> [0.00%]:
  _11 = windows.num;
  if (i == _11)
    goto <bb 8>; [0.00%]
  else
    goto <bb 17>; [0.00%]

  <bb 8> [0.00%]:
  _12 = windows.num;
  if (_12 > 1073741823)
    goto <bb 9>; [0.00%]
  else
    goto <bb 10>; [0.00%]

  <bb 9> [0.00%]:
  printf ("number too big%s", "");
  exit (1);

  <bb 10> [0.00%]:
  _13 = windows.num;
  _14 = _13 + 1;
  _15 = 1073741824 / _14;
  if (_15 <= 7)
    goto <bb 11>; [0.00%]
  else
    goto <bb 12>; [0.00%]

  <bb 11> [0.00%]:
  printf ("size too big%s", "");
  exit (1);

  <bb 12> [0.00%]:
  _16 = windows.space;
  if (_16 == 0)
    goto <bb 13>; [0.00%]
  else
    goto <bb 15>; [0.00%]

  <bb 13> [0.00%]:
  windows.space = 80;
  _17 = windows.space;
  _18 = windows.list;
  _19 = xrealloc (_18, 1, _17);
  windows.list = _19;
  goto <bb 15>; [0.00%]

  <bb 14> [0.00%]:
  _20 = windows.space;
  _21 = windows.list;
  _22 = xrealloc (_21, 2, _20);
  windows.list = _22;
  _23 = windows.space;
  _24 = _23 * 2;
  windows.space = _24;

  <bb 15> [0.00%]:
  _25 = windows.space;
  _26 = windows.num;
  _27 = _26 + 1;
  _28 = (long unsigned int) _27;
  _29 = _28 * 8;
  if (_25 <= _29)
    goto <bb 14>; [0.00%]
  else
    goto <bb 16>; [0.00%]

  <bb 16> [0.00%]:
  _30 = windows.list;
  _31 = windows.num;
  _32 = (long unsigned int) _31;
  _33 = _32 * 8;
  _34 = _30 + _33;
  *_34 = w;
  _35 = windows.num;
  _36 = _35 + 1;
  windows.num = _36;

  <bb 17> [0.00%]:
  w->references = 0;
  D.5093 = w;
  return D.5093;

}



;; Function session_attach (session_attach, funcdef_no=88, decl_uid=4613, cgraph_uid=88, symbol_order=91)

session_attach (struct session * s, struct window * w, int idx, char * * cause)
{
  struct winlink * wl;
  struct winlink * D.5097;

  <bb 2> [0.00%]:
  _1 = &s->windows;
  wl = winlink_add (_1, w, idx);
  if (wl == 0B)
    goto <bb 3>; [0.00%]
  else
    goto <bb 4>; [0.00%]

  <bb 3> [0.00%]:
  printf ("index in use: %d\n", idx);

  <bb 4> [0.00%]:
  session_group_synchronize_from (s);
  D.5097 = wl;
  return D.5097;

}



;; Function session_new (session_new, funcdef_no=89, decl_uid=4622, cgraph_uid=89, symbol_order=92)

session_new (struct session * s, const char * name, const char * cmd, const char * cwd, int idx, char * * cause)
{
  u_int hlimit;
  const char * shell;
  struct window * w;
  struct winlink * D.5101;

  <bb 2> [0.00%]:
  _1 = s->sy;
  _2 = s->sx;
  w = window_create1 (_2, _1);
  if (w == 0B)
    goto <bb 3>; [0.00%]
  else
    goto <bb 4>; [0.00%]

  <bb 3> [0.00%]:
  D.5101 = 0B;
  goto <bb 5>; [0.00%]

  <bb 4> [0.00%]:
  D.5101 = session_attach (s, w, idx, cause);

  <bb 5> [0.00%]:
  return D.5101;

}



;; Function session_create (session_create, funcdef_no=90, decl_uid=4636, cgraph_uid=90, symbol_order=93)

Removing basic block 15
session_create (const char * name, const char * cmd, const char * cwd, struct environ * env, struct termios * tio, int idx, u_int sx, u_int sy, char * * cause)
{
  u_int i;
  struct session * s;
  struct session * D.5119;

  <bb 2> [0.00%]:
  s = malloc (112);
  s->references = 0;
  s->flags = 0;
  s->curw = 0B;
  s->lastw.tqh_first = 0B;
  _1 = &s->lastw.tqh_first;
  s->lastw.tqh_last = _1;
  s->windows.rbh_root = 0B;
  s->tio = 0B;
  s->sx = sx;
  s->sy = sy;
  i = 0;
  goto <bb 6>; [0.00%]

  <bb 3> [0.00%]:
  _2 = sessions.list;
  _3 = (long unsigned int) i;
  _4 = _3 * 8;
  _5 = _2 + _4;
  _6 = *_5;
  if (_6 == 0B)
    goto <bb 4>; [0.00%]
  else
    goto <bb 5>; [0.00%]

  <bb 4> [0.00%]:
  _7 = sessions.list;
  _8 = (long unsigned int) i;
  _9 = _8 * 8;
  _10 = _7 + _9;
  *_10 = s;
  goto <bb 7>; [0.00%]

  <bb 5> [0.00%]:
  i = i + 1;

  <bb 6> [0.00%]:
  _11 = sessions.num;
  if (i < _11)
    goto <bb 3>; [0.00%]
  else
    goto <bb 7>; [0.00%]

  <bb 7> [0.00%]:
  _12 = sessions.num;
  if (i == _12)
    goto <bb 8>; [0.00%]
  else
    goto <bb 17>; [0.00%]

  <bb 8> [0.00%]:
  _13 = sessions.num;
  if (_13 > 1073741823)
    goto <bb 9>; [0.00%]
  else
    goto <bb 10>; [0.00%]

  <bb 9> [0.00%]:
  printf ("number too big%s", "");
  exit (1);

  <bb 10> [0.00%]:
  _14 = sessions.num;
  _15 = _14 + 1;
  _16 = 1073741824 / _15;
  if (_16 <= 7)
    goto <bb 11>; [0.00%]
  else
    goto <bb 12>; [0.00%]

  <bb 11> [0.00%]:
  printf ("size too big%s", "");
  exit (1);

  <bb 12> [0.00%]:
  _17 = sessions.space;
  if (_17 == 0)
    goto <bb 13>; [0.00%]
  else
    goto <bb 15>; [0.00%]

  <bb 13> [0.00%]:
  sessions.space = 80;
  _18 = sessions.space;
  _19 = sessions.list;
  _20 = xrealloc (_19, 1, _18);
  sessions.list = _20;
  goto <bb 15>; [0.00%]

  <bb 14> [0.00%]:
  _21 = sessions.space;
  _22 = sessions.list;
  _23 = xrealloc (_22, 2, _21);
  sessions.list = _23;
  _24 = sessions.space;
  _25 = _24 * 2;
  sessions.space = _25;

  <bb 15> [0.00%]:
  _26 = sessions.space;
  _27 = sessions.num;
  _28 = _27 + 1;
  _29 = (long unsigned int) _28;
  _30 = _29 * 8;
  if (_26 <= _30)
    goto <bb 14>; [0.00%]
  else
    goto <bb 16>; [0.00%]

  <bb 16> [0.00%]:
  _31 = sessions.list;
  _32 = sessions.num;
  _33 = (long unsigned int) _32;
  _34 = _33 * 8;
  _35 = _31 + _34;
  *_35 = s;
  _36 = sessions.num;
  _37 = _36 + 1;
  sessions.num = _37;

  <bb 17> [0.00%]:
  if (name == 0B)
    goto <bb 18>; [0.00%]
  else
    goto <bb 19>; [0.00%]

  <bb 18> [0.00%]:
  printf ("no name%s\n", "");
  exit (1);

  <bb 19> [0.00%]:
  _38 = strdup (name);
  s->name = _38;
  if (cmd != 0B)
    goto <bb 20>; [0.00%]
  else
    goto <bb 23>; [0.00%]

  <bb 20> [0.00%]:
  _39 = session_new (s, 0B, cmd, cwd, idx, cause);
  if (_39 == 0B)
    goto <bb 21>; [0.00%]
  else
    goto <bb 22>; [0.00%]

  <bb 21> [0.00%]:
  session_destroy (s);
  D.5119 = 0B;
  goto <bb 24>; [0.00%]

  <bb 22> [0.00%]:
  _40 = s->windows.rbh_root;
  _41 = _40->idx;
  session_select (s, _41);

  <bb 23> [0.00%]:
  _42 = s->name;
  printf ("session %s created\n", _42);
  D.5119 = s;

  <bb 24> [0.00%]:
  return D.5119;

}



;; Function main (main, funcdef_no=91, decl_uid=4648, cgraph_uid=91, symbol_order=94)

main (int argc, char * * argv)
{
  int i;
  int sy;
  int sx;
  int idx;
  char * cause;
  char * name;
  char * cmd;
  char * target;
  struct window * w;
  struct session * groupwith;
  struct session * s;
  int D.5130;

  <bb 2> [0.00%]:
  idx = 0;
  windows.num = 0;
  windows.list = 0B;
  windows.space = 0;
  sessions.num = 0;
  sessions.list = 0B;
  sessions.space = 0;
  session_groups.tqh_first = 0B;
  session_groups.tqh_last = &session_groups.tqh_first;
  i = 0;
  goto <bb 13>; [0.00%]

  <bb 3> [0.00%]:
  _1 = (long unsigned int) i;
  _2 = _1 * 8;
  _3 = argv + _2;
  _4 = *_3;
  _5 = *_4;
  if (_5 == 116)
    goto <bb 4>; [0.00%]
  else
    goto <bb 6>; [0.00%]

  <bb 4> [0.00%]:
  if (i > 0)
    goto <bb 5>; [0.00%]
  else
    goto <bb 6>; [0.00%]

  <bb 5> [0.00%]:
  _6 = (long unsigned int) i;
  _7 = _6 * 8;
  _8 = _7 + 18446744073709551608;
  _9 = argv + _8;
  _10 = *_9;
  target = strdup (_10);
  goto <bb 7>; [0.00%]

  <bb 6> [0.00%]:
  target = 0B;

  <bb 7> [0.00%]:
  groupwith = session_find (target);
  if (target == 0B)
    goto <bb 8>; [0.00%]
  else
    goto <bb 9>; [0.00%]

  <bb 8> [0.00%]:
  cmd = strdup ("cmd");
  goto <bb 10>; [0.00%]

  <bb 9> [0.00%]:
  cmd = 0B;

  <bb 10> [0.00%]:
  free (target);
  _11 = (long unsigned int) i;
  _12 = _11 * 8;
  _13 = argv + _12;
  _14 = *_13;
  name = strdup (_14);
  sy.3_15 = (unsigned int) sy;
  sx.4_16 = (unsigned int) sx;
  idx.5_17 = idx;
  idx = idx.5_17 + 1;
  s = session_create (name, cmd, "cwd", 0B, 0B, idx.5_17, sx.4_16, sy.3_15, &cause);
  sy.6_18 = (unsigned int) sy;
  sx.7_19 = (unsigned int) sx;
  w = window_create1 (sx.7_19, sy.6_18);
  idx.8_20 = idx;
  idx = idx.8_20 + 1;
  session_attach (s, w, idx.8_20, &cause);
  free (cmd);
  if (groupwith != 0B)
    goto <bb 11>; [0.00%]
  else
    goto <bb 12>; [0.00%]

  <bb 11> [0.00%]:
  session_group_add (groupwith, s);
  session_group_synchronize_to (s);
  _21 = s->windows.rbh_root;
  _22 = _21->idx;
  session_select (s, _22);

  <bb 12> [0.00%]:
  i = i + 1;

  <bb 13> [0.00%]:
  if (i < argc)
    goto <bb 3>; [0.00%]
  else
    goto <bb 14>; [0.00%]

  <bb 14> [0.00%]:
  join_pane_exec ();
  goto <bb 16>; [0.00%]

  <bb 15> [0.00%]:
  _23 = sessions.list;
  _24 = *_23;
  session_destroy (_24);

  <bb 16> [0.00%]:
  _25 = sessions.num;
  if (_25 != 0)
    goto <bb 15>; [0.00%]
  else
    goto <bb 17>; [0.00%]

  <bb 17> [0.00%]:
  D.5130 = 0;
  cause = {CLOBBER};
  return D.5130;

}


