
;; Function discard_cleanups (discard_cleanups, funcdef_no=22, decl_uid=3018, cgraph_uid=23, symbol_order=27)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
void discard_cleanups (struct cleanup * old_chain)
{
  <bb 2> :
  discard_my_cleanups (&cleanup_chain, old_chain);
  return;

}



;; Function discard_final_cleanups (discard_final_cleanups, funcdef_no=23, decl_uid=3023, cgraph_uid=24, symbol_order=28)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
void discard_final_cleanups (struct cleanup * old_chain)
{
  <bb 2> :
  discard_my_cleanups (&final_cleanup_chain, old_chain);
  return;

}



;; Function discard_my_cleanups (discard_my_cleanups, funcdef_no=24, decl_uid=3021, cgraph_uid=25, symbol_order=29)

;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7
;;
;; Loop 1
;;  header 6, latch 5
;;  depth 1, outer 0
;;  nodes: 6 5 3 4
;; 2 succs { 6 }
;; 3 succs { 4 5 }
;; 4 succs { 5 }
;; 5 succs { 6 }
;; 6 succs { 3 7 }
;; 7 succs { 1 }
void discard_my_cleanups (struct cleanup * * pmy_chain, struct cleanup * old_chain)
{
  struct cleanup * ptr;

  <bb 2> :
  goto <bb 6>; [INV]

  <bb 3> :
  _1 = ptr->next;
  *pmy_chain = _1;
  _2 = ptr->free_arg;
  if (_2 != 0B)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  _3 = ptr->free_arg;
  _4 = ptr->arg;
  _3 (_4);

  <bb 5> :
  free (ptr);

  <bb 6> :
  ptr = *pmy_chain;
  if (ptr != old_chain)
    goto <bb 3>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  _5 = ptr->arg;
  printf ("freearg: %x\n", _5);
  return;

}



;; Function do_cleanups (do_cleanups, funcdef_no=26, decl_uid=3028, cgraph_uid=27, symbol_order=31)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
void do_cleanups (struct cleanup * old_chain)
{
  <bb 2> :
  do_my_cleanups (&cleanup_chain, old_chain);
  return;

}



;; Function do_my_cleanups (do_my_cleanups, funcdef_no=25, decl_uid=3026, cgraph_uid=26, symbol_order=30)

;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7
;;
;; Loop 1
;;  header 6, latch 5
;;  depth 1, outer 0
;;  nodes: 6 5 3 4
;; 2 succs { 6 }
;; 3 succs { 4 5 }
;; 4 succs { 5 }
;; 5 succs { 6 }
;; 6 succs { 3 7 }
;; 7 succs { 1 }
void do_my_cleanups (struct cleanup * * pmy_chain, struct cleanup * old_chain)
{
  struct cleanup * ptr;

  <bb 2> :
  goto <bb 6>; [INV]

  <bb 3> :
  _1 = ptr->next;
  *pmy_chain = _1;
  _2 = ptr->function;
  _3 = ptr->arg;
  _2 (_3);
  __builtin_puts (&"cleanup!!!!! ========="[0]);
  _4 = ptr->arg;
  printf ("%x\n", _4);
  _5 = ptr->free_arg;
  if (_5 != 0B)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  _6 = ptr->free_arg;
  _7 = ptr->arg;
  _6 (_7);

  <bb 5> :
  free (ptr);

  <bb 6> :
  ptr = *pmy_chain;
  if (ptr != old_chain)
    goto <bb 3>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  return;

}



;; Function make_cleanup (make_cleanup, funcdef_no=29, decl_uid=3041, cgraph_uid=30, symbol_order=34)

Merging blocks 2 and 3
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
struct cleanup * make_cleanup (void (*<T59c>) (void *) function, void * arg)
{
  struct cleanup * D.3320;

  <bb 2> :
  D.3320 = make_my_cleanup (&cleanup_chain, function, arg);
  return D.3320;

}



;; Function make_my_cleanup (make_my_cleanup, funcdef_no=28, decl_uid=3038, cgraph_uid=29, symbol_order=33)

Merging blocks 2 and 3
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
struct cleanup * make_my_cleanup (struct cleanup * * pmy_chain, void (*<T59c>) (void *) function, void * arg)
{
  struct cleanup * D.3322;

  <bb 2> :
  D.3322 = make_my_cleanup2 (pmy_chain, function, arg, 0B);
  return D.3322;

}



;; Function make_my_cleanup2 (make_my_cleanup2, funcdef_no=27, decl_uid=3034, cgraph_uid=28, symbol_order=32)

Merging blocks 4 and 5
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4
;; 2 succs { 3 4 }
;; 3 succs { }
;; 4 succs { 1 }
struct cleanup * make_my_cleanup2 (struct cleanup * * pmy_chain, void (*<T59c>) (void *) function, void * arg, void (*<Tee>) (void *) free_arg)
{
  struct cleanup * old_chain;
  struct cleanup * new;
  struct cleanup * D.3326;

  <bb 2> :
  new = malloc (32);
  old_chain = *pmy_chain;
  _1 = *pmy_chain;
  new->next = _1;
  new->function = function;
  new->free_arg = free_arg;
  new->arg = arg;
  *pmy_chain = new;
  if (old_chain == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  exit (1);

  <bb 4> :
  D.3326 = old_chain;
  return D.3326;

}



;; Function vec_o_reserve (vec_o_reserve, funcdef_no=31, decl_uid=3102, cgraph_uid=32, symbol_order=36)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9
;; 2 succs { 3 4 }
;; 3 succs { 9 }
;; 4 succs { 5 6 }
;; 5 succs { }
;; 6 succs { 7 8 }
;; 7 succs { 8 }
;; 8 succs { 9 }
;; 9 succs { 1 }
void * vec_o_reserve (void * vec, int reserve, size_t vec_offset, size_t elt_size)
{
  unsigned int alloc;
  struct vec_prefix * pfx;
  void * D.3330;

  <bb 2> :
  pfx = vec;
  alloc = calculate_allocation (pfx, reserve);
  if (alloc == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  D.3330 = 0B;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 9>; [INV]

  <bb 4> :
  _1 = (long unsigned int) alloc;
  _2 = elt_size * _1;
  _3 = vec_offset + _2;
  vec = realloc (vec, _3);
  if (vec == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  exit (1);

  <bb 6> :
  MEM[(struct vec_prefix *)vec].alloc = alloc;
  if (pfx == 0B)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  MEM[(struct vec_prefix *)vec].num = 0;

  <bb 8> :
  D.3330 = vec;

  <bb 9> :
  return D.3330;

}



;; Function calculate_allocation (calculate_allocation, funcdef_no=30, decl_uid=3091, cgraph_uid=31, symbol_order=35)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18
;; 2 succs { 3 4 }
;; 3 succs { 6 }
;; 4 succs { 5 6 }
;; 5 succs { 18 }
;; 6 succs { 7 8 }
;; 7 succs { }
;; 8 succs { 9 10 }
;; 9 succs { 17 }
;; 10 succs { 11 12 }
;; 11 succs { 15 }
;; 12 succs { 13 14 }
;; 13 succs { 15 }
;; 14 succs { 15 }
;; 15 succs { 16 17 }
;; 16 succs { 17 }
;; 17 succs { 18 }
;; 18 succs { 1 }
unsigned int calculate_allocation (const struct vec_prefix * pfx, int reserve)
{
  unsigned int num;
  unsigned int alloc;
  unsigned int D.3341;

  <bb 2> :
  alloc = 0;
  num = 0;
  if (pfx != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  alloc = pfx->alloc;
  num = pfx->num;
  goto <bb 6>; [INV]

  <bb 4> :
  if (reserve == 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  D.3341 = 0;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 18>; [INV]

  <bb 6> :
  _1 = alloc - num;
  _2 = ABS_EXPR <reserve>;
  _3 = (unsigned int) _2;
  if (_1 >= _3)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  exit (1);

  <bb 8> :
  if (reserve < 0)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  reserve.0_4 = (unsigned int) reserve;
  alloc = num - reserve.0_4;
  goto <bb 17>; [INV]

  <bb 10> :
  if (alloc == 0)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  alloc = 4;
  goto <bb 15>; [INV]

  <bb 12> :
  if (alloc <= 15)
    goto <bb 13>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 13> :
  alloc = alloc * 2;
  goto <bb 15>; [INV]

  <bb 14> :
  _5 = alloc * 3;
  alloc = _5 / 2;

  <bb 15> :
  reserve.1_6 = (unsigned int) reserve;
  _7 = num + reserve.1_6;
  if (alloc < _7)
    goto <bb 16>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 16> :
  reserve.2_8 = (unsigned int) reserve;
  alloc = num + reserve.2_8;

  <bb 17> :
  D.3341 = alloc;

  <bb 18> :
  return D.3341;

}



;; Function btrace_clear (btrace_clear, funcdef_no=59, decl_uid=3292, cgraph_uid=60, symbol_order=64)

;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5
;;
;; Loop 1
;;  header 4, latch 3
;;  depth 1, outer 0
;;  nodes: 4 3
;; 2 succs { 4 }
;; 3 succs { 4 }
;; 4 succs { 3 5 }
;; 5 succs { 1 }
void btrace_clear (struct btrace_thread_info * btp)
{
  struct btrace_function * trash;
  struct btrace_function * it;

  <bb 2> :
  it = btp->begin;
  goto <bb 4>; [INV]

  <bb 3> :
  trash = it;
  it = it->next;
  free (trash);

  <bb 4> :
  if (it != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 5> :
  btp->begin = 0B;
  btp->end = 0B;
  return;

}



;; Function main (main, funcdef_no=60, decl_uid=3299, cgraph_uid=61, symbol_order=65)

Merging blocks 8 and 9
;; 3 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8
;;
;; Loop 2
;;  header 7, latch 6
;;  depth 1, outer 0
;;  nodes: 7 6
;;
;; Loop 1
;;  header 4, latch 3
;;  depth 1, outer 0
;;  nodes: 4 3
;; 2 succs { 4 }
;; 3 succs { 4 }
;; 4 succs { 3 5 }
;; 5 succs { 7 }
;; 6 succs { 7 }
;; 7 succs { 6 8 }
;; 8 succs { 1 }
int main ()
{
  struct VEC_btrace_insn * insn_vec_p;
  struct btrace_function * bfunc;
  struct btrace_function * next;
  struct btrace_function * it;
  struct btrace_thread_info btinfo;
  time_t t;
  int D.3356;

  <bb 2> :
  _1 = time (&t);
  _2 = (unsigned int) _1;
  srand (_2);
  bfunc = malloc (24);
  _3 = VEC_btrace_insn_alloc (10);
  bfunc->insn = _3;
  bfunc->next = 0B;
  _4 = bfunc->next;
  bfunc->prev = _4;
  btinfo.end = bfunc;
  _5 = btinfo.end;
  btinfo.begin = _5;
  it = btinfo.begin;
  goto <bb 4>; [INV]

  <bb 3> :
  next = malloc (24);
  _6 = VEC_btrace_insn_alloc (10);
  insn_vec_p = _6;
  insn_vec_p.3_7 = insn_vec_p;
  next->insn = insn_vec_p.3_7;
  it->next = next;
  next->prev = it;
  next->next = 0B;
  btinfo.end = next;
  it = it->next;

  <bb 4> :
  _8 = rand ();
  _9 = _8 % 2;
  if (_9 == 1)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 5> :
  it = btinfo.begin;
  goto <bb 7>; [INV]

  <bb 6> :
  _10 = it->insn;
  insn_vec_p = _10;
  VEC_btrace_insn_safe_push (&insn_vec_p, 55, "./benchmarks/binutils/leak_5/binutils_leak_5.c", 75);
  it = it->next;

  <bb 7> :
  if (it != 0B)
    goto <bb 6>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 8> :
  btrace_clear (&btinfo);
  t = {CLOBBER};
  btinfo = {CLOBBER};
  insn_vec_p = {CLOBBER};
  D.3356 = 0;
  return D.3356;

}



;; Function VEC_btrace_insn_alloc (VEC_btrace_insn_alloc, funcdef_no=50, decl_uid=3231, cgraph_uid=51, symbol_order=55)

Merging blocks 2 and 3
Merging blocks 2 and 4
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
struct VEC_btrace_insn * VEC_btrace_insn_alloc (int alloc_)
{
  struct VEC_btrace_insn dummy;
  struct VEC_btrace_insn * D.3358;

  <bb 2> :
  _1 = -alloc_;
  D.3358 = vec_o_reserve (0B, _1, 8, 4);
  dummy = {CLOBBER};
  return D.3358;

}



;; Function VEC_btrace_insn_safe_push (VEC_btrace_insn_safe_push, funcdef_no=57, decl_uid=3274, cgraph_uid=58, symbol_order=62)

Merging blocks 2 and 3
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
btrace_insn * VEC_btrace_insn_safe_push (struct VEC_btrace_insn * * vec_, const btrace_insn obj_, const char * file_, unsigned int line_)
{
  btrace_insn * D.3361;

  <bb 2> :
  VEC_btrace_insn_reserve (vec_, 1, file_, line_);
  _1 = *vec_;
  D.3361 = VEC_btrace_insn_quick_push (_1, obj_, file_, line_);
  return D.3361;

}



;; Function VEC_btrace_insn_reserve (VEC_btrace_insn_reserve, funcdef_no=55, decl_uid=3260, cgraph_uid=56, symbol_order=60)

Merging blocks 4 and 5
Merging blocks 4 and 6
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4
;; 2 succs { 3 4 }
;; 3 succs { 4 }
;; 4 succs { 1 }
int VEC_btrace_insn_reserve (struct VEC_btrace_insn * * vec_, int alloc_, const char * file_, unsigned int line_)
{
  int extend;
  struct VEC_btrace_insn dummy;
  int D.3365;

  <bb 2> :
  _1 = ABS_EXPR <alloc_>;
  _2 = *vec_;
  _3 = VEC_btrace_insn_space (_2, _1, file_, line_);
  _4 = _3 == 0;
  extend = (int) _4;
  if (extend != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  _5 = *vec_;
  _6 = vec_o_reserve (_5, alloc_, 8, 4);
  *vec_ = _6;

  <bb 4> :
  D.3365 = extend;
  dummy = {CLOBBER};
  return D.3365;

}



;; Function VEC_btrace_insn_space (VEC_btrace_insn_space, funcdef_no=39, decl_uid=3146, cgraph_uid=40, symbol_order=44)

Merging blocks 7 and 8
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7
;; 2 succs { 3 4 }
;; 3 succs { }
;; 4 succs { 5 6 }
;; 5 succs { 7 }
;; 6 succs { 7 }
;; 7 succs { 1 }
int VEC_btrace_insn_space (struct VEC_btrace_insn * vec_, int alloc_, const char * file_, unsigned int line_)
{
  int iftmp.4;
  int D.3370;

  <bb 2> :
  if (alloc_ < 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  exit (1);

  <bb 4> :
  if (vec_ != 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  _1 = vec_->alloc;
  _2 = vec_->num;
  _3 = _1 - _2;
  alloc_.5_4 = (unsigned int) alloc_;
  _5 = _3 >= alloc_.5_4;
  iftmp.4 = (int) _5;
  goto <bb 7>; [INV]

  <bb 6> :
  _6 = alloc_ == 0;
  iftmp.4 = (int) _6;

  <bb 7> :
  D.3370 = iftmp.4;
  return D.3370;

}



;; Function VEC_btrace_insn_quick_push (VEC_btrace_insn_quick_push, funcdef_no=40, decl_uid=3152, cgraph_uid=41, symbol_order=45)

Merging blocks 4 and 5
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4
;; 2 succs { 3 4 }
;; 3 succs { }
;; 4 succs { 1 }
btrace_insn * VEC_btrace_insn_quick_push (struct VEC_btrace_insn * vec_, btrace_insn obj_, const char * file_, unsigned int line_)
{
  btrace_insn * slot_;
  btrace_insn * D.3378;

  <bb 2> :
  _1 = vec_->num;
  _2 = vec_->alloc;
  if (_1 >= _2)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  exit (1);

  <bb 4> :
  _3 = vec_->num;
  _4 = _3;
  _5 = _4 + 1;
  vec_->num = _5;
  slot_ = &vec_->vec[_4];
  *slot_ = obj_;
  D.3378 = slot_;
  return D.3378;

}


