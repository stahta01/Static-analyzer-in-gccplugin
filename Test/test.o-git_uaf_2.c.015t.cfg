
;; Function xrealloc (xrealloc, funcdef_no=26, decl_uid=3197, cgraph_uid=27, symbol_order=27)

Merging blocks 9 and 10
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9
;; 2 succs { 3 4 }
;; 3 succs { 4 }
;; 4 succs { 5 9 }
;; 5 succs { 6 7 }
;; 6 succs { 7 }
;; 7 succs { 8 9 }
;; 8 succs { }
;; 9 succs { 1 }
void * xrealloc (void * ptr, size_t size)
{
  void * ret;
  void * D.3456;

  <bb 2> :
  ret = realloc (ptr, size);
  _1 = ret == 0B;
  _2 = size == 0;
  _3 = _1 & _2;
  if (_3 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  ret = realloc (ptr, 1);

  <bb 4> :
  if (ret == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 5> :
  ret = realloc (ptr, size);
  _4 = ret == 0B;
  _5 = size == 0;
  _6 = _4 & _5;
  if (_6 != 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  ret = realloc (ptr, 1);

  <bb 7> :
  if (ret == 0B)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  printf ("Out of memory, realloc failed%s", "");
  exit (1);

  <bb 9> :
  D.3456 = ret;
  return D.3456;

}



;; Function finish_command (finish_command, funcdef_no=33, decl_uid=3352, cgraph_uid=34, symbol_order=35)

Merging blocks 2 and 3
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
int finish_command (struct child_process * cmd)
{
  int ret;
  int D.3458;

  <bb 2> :
  _1 = cmd->argv;
  _2 = *_1;
  _3 = cmd->pid;
  ret = wait_or_whine (_3, _2, 0);
  child_process_clear (cmd);
  D.3458 = ret;
  return D.3458;

}



;; Function child_process_clear (child_process_clear, funcdef_no=34, decl_uid=3374, cgraph_uid=35, symbol_order=36)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
void child_process_clear (struct child_process * child)
{
  <bb 2> :
  _1 = &child->args;
  argv_array_clear (_1);
  _2 = &child->env_array;
  argv_array_clear (_2);
  return;

}



;; Function run_processes_parallel (run_processes_parallel, funcdef_no=35, decl_uid=3387, cgraph_uid=36, symbol_order=37)

Merging blocks 5 and 9
Removing basic block 8
Removing basic block 17
Merging blocks 18 and 19
Merging blocks 18 and 20
;; 3 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
;;
;; Loop 1
;;  header 3, multiple latches: 13 12 14
;;  depth 1, outer 0
;;  nodes: 3 13 12 14 11 7 8 9 10 6 4 5
;;
;; Loop 2
;;  header 8, latch 5
;;  depth 2, outer 1
;;  nodes: 8 5 4 10 9
;; 2 succs { 3 }
;; 3 succs { 8 }
;; 4 succs { 5 6 }
;; 5 succs { 8 }
;; 6 succs { 7 11 }
;; 7 succs { 11 }
;; 8 succs { 9 11 }
;; 9 succs { 10 11 }
;; 10 succs { 4 11 }
;; 11 succs { 15 12 }
;; 12 succs { 13 3 }
;; 13 succs { 14 3 }
;; 14 succs { 3 }
;; 15 succs { 1 }
int run_processes_parallel (int n, int (*get_next_task_fn) (struct child_process *, struct strbuf *, void *, void * *) get_next_task, int (*start_failure_fn) (struct child_process *, struct strbuf *, void *, void *) start_failure, int (*task_finished_fn) (int, struct child_process *, struct strbuf *, void *, void *) task_finished, void * pp_cb)
{
  struct parallel_processes pp;
  int spawn_cap;
  int output_timeout;
  int code;
  int i;
  int D.3471;

  <bb 2> :
  output_timeout = 100;
  spawn_cap = 4;
  pp_init (&pp, n, get_next_task, start_failure, task_finished, pp_cb);

  <bb 3> :
  i = 0;
  goto <bb 8>; [INV]

  <bb 4> :
  code = pp_start_one (&pp);
  if (code == 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  // predicted unlikely by continue predictor.
  i = i + 1;
  goto <bb 8>; [INV]

  <bb 6> :
  if (code < 0)
    goto <bb 7>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 7> :
  pp.shutdown = 1;
  _1 = -code;
  kill_children (&pp, _1);
  goto <bb 11>; [INV]

  <bb 8> :
  if (i < spawn_cap)
    goto <bb 9>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 9> :
  _2 = BIT_FIELD_REF <pp, 8, 448>;
  _3 = _2 & 1;
  if (_3 == 0)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  _4 = pp.nr_processes;
  _5 = pp.max_processes;
  if (_4 < _5)
    goto <bb 4>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 11> :
  _6 = pp.nr_processes;
  if (_6 == 0)
    goto <bb 15>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 12> :
  pp_buffer_stderr (&pp, output_timeout);
  pp_output (&pp);
  code = pp_collect_finished (&pp);
  if (code != 0)
    goto <bb 13>; [INV]
  else
    goto <bb 3>; [INV]

  <bb 13> :
  pp.shutdown = 1;
  if (code < 0)
    goto <bb 14>; [INV]
  else
    goto <bb 3>; [INV]

  <bb 14> :
  _7 = -code;
  kill_children (&pp, _7);
  goto <bb 3>; [INV]

  <bb 15> :
  pp_cleanup (&pp);
  D.3471 = 0;
  pp = {CLOBBER};
  return D.3471;

}



;; Function pp_init (pp_init, funcdef_no=29, decl_uid=3301, cgraph_uid=30, symbol_order=31)

;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
;;
;; Loop 1
;;  header 14, latch 13
;;  depth 1, outer 0
;;  nodes: 14 13
;; 2 succs { 3 4 }
;; 3 succs { 4 }
;; 4 succs { 5 6 }
;; 5 succs { }
;; 6 succs { 7 8 }
;; 7 succs { 9 }
;; 8 succs { 9 }
;; 9 succs { 10 11 }
;; 10 succs { 12 }
;; 11 succs { 12 }
;; 12 succs { 14 }
;; 13 succs { 14 }
;; 14 succs { 13 15 }
;; 15 succs { 1 }
void pp_init (struct parallel_processes * pp, int n, int (*get_next_task_fn) (struct child_process *, struct strbuf *, void *, void * *) get_next_task, int (*start_failure_fn) (struct child_process *, struct strbuf *, void *, void *) start_failure, int (*task_finished_fn) (int, struct child_process *, struct strbuf *, void *, void *) task_finished, void * data)
{
  int i;
  int (*<T5f1>) (int, struct child_process *, struct strbuf *, void *, void *) iftmp.1;
  int (*<T5ee>) (struct child_process *, struct strbuf *, void *, void *) iftmp.0;

  <bb 2> :
  if (n <= 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  n = online_cpus ();

  <bb 4> :
  pp->max_processes = n;
  trace_printf ("run_processes_parallel: preparing to run up to %d tasks", n);
  pp->data = data;
  if (get_next_task == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  printf ("BUG: you need to specify a get_next_task function%s", "");
  exit (1);

  <bb 6> :
  pp->get_next_task = get_next_task;
  if (start_failure != 0B)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  iftmp.0 = start_failure;
  goto <bb 9>; [INV]

  <bb 8> :
  iftmp.0 = default_start_failure;

  <bb 9> :
  pp->start_failure = iftmp.0;
  if (task_finished != 0B)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  iftmp.1 = task_finished;
  goto <bb 12>; [INV]

  <bb 11> :
  iftmp.1 = default_task_finished;

  <bb 12> :
  pp->task_finished = iftmp.1;
  pp->nr_processes = 0;
  pp->output_owner = 0;
  pp->shutdown = 0;
  _1 = (long unsigned int) n;
  _2 = calloc (_1, 120);
  pp->children = _2;
  _3 = (long unsigned int) n;
  _4 = calloc (_3, 8);
  pp->pfd = _4;
  _5 = &pp->buffered_output;
  strbuf_init (_5, 0);
  i = 0;
  goto <bb 14>; [INV]

  <bb 13> :
  _6 = pp->children;
  _7 = (long unsigned int) i;
  _8 = _7 * 120;
  _9 = _6 + _8;
  _10 = &_9->err;
  strbuf_init (_10, 0);
  _11 = pp->children;
  _12 = (long unsigned int) i;
  _13 = _12 * 120;
  _14 = _11 + _13;
  _15 = &_14->process;
  child_process_init (_15);
  _16 = pp->pfd;
  _17 = (long unsigned int) i;
  _18 = _17 * 8;
  _19 = _16 + _18;
  _19->events = 17;
  _20 = pp->pfd;
  _21 = (long unsigned int) i;
  _22 = _21 * 8;
  _23 = _20 + _22;
  _23->fd = -1;
  i = i + 1;

  <bb 14> :
  if (i < n)
    goto <bb 13>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 15> :
  pp_for_signal = pp;
  return;

}



;; Function default_task_finished (default_task_finished, funcdef_no=28, decl_uid=3286, cgraph_uid=29, symbol_order=29)

;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8
;;
;; Loop 1
;;  header 6, latch 5
;;  depth 1, outer 0
;;  nodes: 6 5
;; 2 succs { 3 4 }
;; 3 succs { 8 }
;; 4 succs { 6 }
;; 5 succs { 6 }
;; 6 succs { 5 7 }
;; 7 succs { 8 }
;; 8 succs { 1 }
int default_task_finished (int result, struct child_process * cp, struct strbuf * err, void * pp_cb, void * pp_task_cb)
{
  int i;
  int D.3488;

  <bb 2> :
  if (result == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  D.3488 = 0;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 8>; [INV]

  <bb 4> :
  strbuf_addf (err, "A child failed with return code %d:", result);
  i = 0;
  goto <bb 6>; [INV]

  <bb 5> :
  _1 = cp->argv;
  _2 = (long unsigned int) i;
  _3 = _2 * 8;
  _4 = _1 + _3;
  _5 = *_4;
  strbuf_addf (err, " %s", _5);
  i = i + 1;

  <bb 6> :
  _6 = cp->argv;
  _7 = (long unsigned int) i;
  _8 = _7 * 8;
  _9 = _6 + _8;
  _10 = *_9;
  if (_10 != 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  D.3488 = 0;

  <bb 8> :
  return D.3488;

}



;; Function default_start_failure (default_start_failure, funcdef_no=27, decl_uid=3270, cgraph_uid=28, symbol_order=28)

Merging blocks 5 and 6
;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5
;;
;; Loop 1
;;  header 4, latch 3
;;  depth 1, outer 0
;;  nodes: 4 3
;; 2 succs { 4 }
;; 3 succs { 4 }
;; 4 succs { 3 5 }
;; 5 succs { 1 }
int default_start_failure (struct child_process * cp, struct strbuf * err, void * pp_cb, void * pp_task_cb)
{
  int i;
  int D.3490;

  <bb 2> :
  strbuf_addstr (err, "Starting a child failed:");
  i = 0;
  goto <bb 4>; [INV]

  <bb 3> :
  _1 = cp->argv;
  _2 = (long unsigned int) i;
  _3 = _2 * 8;
  _4 = _1 + _3;
  _5 = *_4;
  strbuf_addf (err, " %s", _5);
  i = i + 1;

  <bb 4> :
  _6 = cp->argv;
  _7 = (long unsigned int) i;
  _8 = _7 * 8;
  _9 = _6 + _8;
  _10 = *_9;
  if (_10 != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 5> :
  D.3490 = 0;
  return D.3490;

}



;; Function pp_start_one (pp_start_one, funcdef_no=30, decl_uid=3317, cgraph_uid=31, symbol_order=32)

;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
;;
;; Loop 1
;;  header 5, latch 4
;;  depth 1, outer 0
;;  nodes: 5 4 3
;; 2 succs { 5 }
;; 3 succs { 6 4 }
;; 4 succs { 5 }
;; 5 succs { 3 6 }
;; 6 succs { 7 8 }
;; 7 succs { }
;; 8 succs { 9 10 }
;; 9 succs { 15 }
;; 10 succs { 11 14 }
;; 11 succs { 12 13 }
;; 12 succs { 13 }
;; 13 succs { 15 }
;; 14 succs { 15 }
;; 15 succs { 1 }
int pp_start_one (struct parallel_processes * pp)
{
  int code;
  int i;
  int D.3497;

  <bb 2> :
  i = 0;
  goto <bb 5>; [INV]

  <bb 3> :
  _1 = pp->children;
  _2 = (long unsigned int) i;
  _3 = _2 * 120;
  _4 = _1 + _3;
  _5 = _4->state;
  if (_5 == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 4> :
  i = i + 1;

  <bb 5> :
  _6 = pp->max_processes;
  if (i < _6)
    goto <bb 3>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 6> :
  _7 = pp->max_processes;
  if (i == _7)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  printf ("BUG: bookkeeping is hard%s", "");
  exit (1);

  <bb 8> :
  _8 = pp->get_next_task;
  _9 = pp->children;
  _10 = (long unsigned int) i;
  _11 = _10 * 120;
  _12 = _9 + _11;
  _13 = &_12->data;
  _14 = pp->data;
  _15 = pp->children;
  _16 = (long unsigned int) i;
  _17 = _16 * 120;
  _18 = _15 + _17;
  _19 = &_18->err;
  _20 = pp->children;
  _21 = (long unsigned int) i;
  _22 = _21 * 120;
  _23 = _20 + _22;
  _24 = &_23->process;
  code = _8 (_24, _19, _14, _13);
  if (code == 0)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  _25 = pp->children;
  _26 = (long unsigned int) i;
  _27 = _26 * 120;
  _28 = _25 + _27;
  _29 = &_28->err;
  _30 = &pp->buffered_output;
  strbuf_addbuf (_30, _29);
  _31 = pp->children;
  _32 = (long unsigned int) i;
  _33 = _32 * 120;
  _34 = _31 + _33;
  _35 = &_34->err;
  strbuf_reset (_35);
  D.3497 = 1;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 15>; [INV]

  <bb 10> :
  _36 = pp->children;
  _37 = (long unsigned int) i;
  _38 = _37 * 120;
  _39 = _36 + _38;
  _39->process.err = -1;
  _40 = pp->children;
  _41 = (long unsigned int) i;
  _42 = _41 * 120;
  _43 = _40 + _42;
  _43->process.stdout_to_stderr = 1;
  _44 = pp->children;
  _45 = (long unsigned int) i;
  _46 = _45 * 120;
  _47 = _44 + _46;
  _47->process.no_stdin = 1;
  _48 = pp->children;
  _49 = (long unsigned int) i;
  _50 = _49 * 120;
  _51 = _48 + _50;
  _52 = &_51->process;
  _53 = start_command (_52);
  if (_53 != 0)
    goto <bb 11>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 11> :
  _54 = pp->start_failure;
  _55 = pp->children;
  _56 = (long unsigned int) i;
  _57 = _56 * 120;
  _58 = _55 + _57;
  _59 = &_58->data;
  _60 = pp->data;
  _61 = pp->children;
  _62 = (long unsigned int) i;
  _63 = _62 * 120;
  _64 = _61 + _63;
  _65 = &_64->err;
  _66 = pp->children;
  _67 = (long unsigned int) i;
  _68 = _67 * 120;
  _69 = _66 + _68;
  _70 = &_69->process;
  code = _54 (_70, _65, _60, _59);
  _71 = pp->children;
  _72 = (long unsigned int) i;
  _73 = _72 * 120;
  _74 = _71 + _73;
  _75 = &_74->err;
  _76 = &pp->buffered_output;
  strbuf_addbuf (_76, _75);
  _77 = pp->children;
  _78 = (long unsigned int) i;
  _79 = _78 * 120;
  _80 = _77 + _79;
  _81 = &_80->err;
  strbuf_reset (_81);
  if (code != 0)
    goto <bb 12>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 12> :
  pp->shutdown = 1;

  <bb 13> :
  D.3497 = code;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 15>; [INV]

  <bb 14> :
  _82 = pp->nr_processes;
  _83 = _82 + 1;
  pp->nr_processes = _83;
  _84 = pp->children;
  _85 = (long unsigned int) i;
  _86 = _85 * 120;
  _87 = _84 + _86;
  _87->state = 1;
  _88 = pp->children;
  _89 = (long unsigned int) i;
  _90 = _89 * 120;
  _91 = _88 + _90;
  _92 = pp->pfd;
  _93 = (long unsigned int) i;
  _94 = _93 * 8;
  _95 = _92 + _94;
  _96 = _91->process.err;
  _95->fd = _96;
  D.3497 = 0;

  <bb 15> :
  return D.3497;

}



;; Function pp_collect_finished (pp_collect_finished, funcdef_no=32, decl_uid=3346, cgraph_uid=33, symbol_order=34)

Merging blocks 19 and 20
;; 4 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19
;;
;; Loop 1
;;  header 18, multiple latches: 12 17
;;  depth 1, outer 0
;;  nodes: 18 12 17 14 16 13 15 11 10 8 9 7 4 6 3 5
;;
;; Loop 3
;;  header 16, latch 15
;;  depth 2, outer 1
;;  nodes: 16 15 14
;;
;; Loop 2
;;  header 6, latch 5
;;  depth 2, outer 1
;;  nodes: 6 5 4
;; 2 succs { 18 }
;; 3 succs { 6 }
;; 4 succs { 7 5 }
;; 5 succs { 6 }
;; 6 succs { 4 7 }
;; 7 succs { 19 8 }
;; 8 succs { 9 10 }
;; 9 succs { 10 }
;; 10 succs { 19 11 }
;; 11 succs { 12 13 }
;; 12 succs { 18 }
;; 13 succs { 16 }
;; 14 succs { 17 15 }
;; 15 succs { 16 }
;; 16 succs { 14 17 }
;; 17 succs { 18 }
;; 18 succs { 3 19 }
;; 19 succs { 1 }
int pp_collect_finished (struct parallel_processes * pp)
{
  int result;
  int n;
  int code;
  int i;
  int D.3512;

  <bb 2> :
  n = pp->max_processes;
  result = 0;
  goto <bb 18>; [INV]

  <bb 3> :
  i = 0;
  goto <bb 6>; [INV]

  <bb 4> :
  _1 = pp->children;
  _2 = (long unsigned int) i;
  _3 = _2 * 120;
  _4 = _1 + _3;
  _5 = _4->state;
  if (_5 == 2)
    goto <bb 7>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 5> :
  i = i + 1;

  <bb 6> :
  _6 = pp->max_processes;
  if (i < _6)
    goto <bb 4>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  _7 = pp->max_processes;
  if (i == _7)
    goto <bb 19>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 8> :
  _8 = pp->children;
  _9 = (long unsigned int) i;
  _10 = _9 * 120;
  _11 = _8 + _10;
  _12 = &_11->process;
  code = finish_command (_12);
  _13 = pp->task_finished;
  _14 = pp->children;
  _15 = (long unsigned int) i;
  _16 = _15 * 120;
  _17 = _14 + _16;
  _18 = &_17->data;
  _19 = pp->data;
  _20 = pp->children;
  _21 = (long unsigned int) i;
  _22 = _21 * 120;
  _23 = _20 + _22;
  _24 = &_23->err;
  _25 = pp->children;
  _26 = (long unsigned int) i;
  _27 = _26 * 120;
  _28 = _25 + _27;
  _29 = &_28->process;
  code = _13 (code, _29, _24, _19, _18);
  if (code != 0)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  result = code;

  <bb 10> :
  if (code < 0)
    goto <bb 19>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 11> :
  _30 = pp->nr_processes;
  _31 = _30 + -1;
  pp->nr_processes = _31;
  _32 = pp->children;
  _33 = (long unsigned int) i;
  _34 = _33 * 120;
  _35 = _32 + _34;
  _35->state = 0;
  _36 = pp->pfd;
  _37 = (long unsigned int) i;
  _38 = _37 * 8;
  _39 = _36 + _38;
  _39->fd = -1;
  _40 = pp->children;
  _41 = (long unsigned int) i;
  _42 = _41 * 120;
  _43 = _40 + _42;
  _44 = &_43->process;
  child_process_init (_44);
  _45 = pp->output_owner;
  if (i != _45)
    goto <bb 12>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 12> :
  _46 = pp->children;
  _47 = (long unsigned int) i;
  _48 = _47 * 120;
  _49 = _46 + _48;
  _50 = &_49->err;
  _51 = &pp->buffered_output;
  strbuf_addbuf (_51, _50);
  _52 = pp->children;
  _53 = (long unsigned int) i;
  _54 = _53 * 120;
  _55 = _52 + _54;
  _56 = &_55->err;
  strbuf_reset (_56);
  goto <bb 18>; [INV]

  <bb 13> :
  stderr.2_57 = stderr;
  _58 = pp->children;
  _59 = (long unsigned int) i;
  _60 = _59 * 120;
  _61 = _58 + _60;
  _62 = _61->err.buf;
  fputs (_62, stderr.2_57);
  _63 = pp->children;
  _64 = (long unsigned int) i;
  _65 = _64 * 120;
  _66 = _63 + _65;
  _67 = &_66->err;
  strbuf_reset (_67);
  stderr.3_68 = stderr;
  _69 = pp->buffered_output.buf;
  fputs (_69, stderr.3_68);
  _70 = &pp->buffered_output;
  strbuf_reset (_70);
  i = 0;
  goto <bb 16>; [INV]

  <bb 14> :
  _71 = pp->children;
  _72 = pp->output_owner;
  _73 = i + _72;
  _74 = _73 % n;
  _75 = (long unsigned int) _74;
  _76 = _75 * 120;
  _77 = _71 + _76;
  _78 = _77->state;
  if (_78 == 1)
    goto <bb 17>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 15> :
  i = i + 1;

  <bb 16> :
  if (i < n)
    goto <bb 14>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 17> :
  _79 = pp->output_owner;
  _80 = i + _79;
  _81 = _80 % n;
  pp->output_owner = _81;

  <bb 18> :
  _82 = pp->nr_processes;
  if (_82 > 0)
    goto <bb 3>; [INV]
  else
    goto <bb 19>; [INV]

  <bb 19> :
  D.3512 = result;
  return D.3512;

}



;; Function kill_children (kill_children, funcdef_no=31, decl_uid=3335, cgraph_uid=32, symbol_order=33)

;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7
;;
;; Loop 1
;;  header 6, latch 5
;;  depth 1, outer 0
;;  nodes: 6 5 3 4
;; 2 succs { 6 }
;; 3 succs { 4 5 }
;; 4 succs { 5 }
;; 5 succs { 6 }
;; 6 succs { 3 7 }
;; 7 succs { 1 }
void kill_children (struct parallel_processes * pp, int signo)
{
  int n;
  int i;

  <bb 2> :
  n = pp->max_processes;
  i = 0;
  goto <bb 6>; [INV]

  <bb 3> :
  _1 = pp->children;
  _2 = (long unsigned int) i;
  _3 = _2 * 120;
  _4 = _1 + _3;
  _5 = _4->state;
  if (_5 == 1)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  _6 = pp->children;
  _7 = (long unsigned int) i;
  _8 = _7 * 120;
  _9 = _6 + _8;
  _10 = _9->process.pid;
  kill (_10, signo);

  <bb 5> :
  i = i + 1;

  <bb 6> :
  if (i < n)
    goto <bb 3>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  return;

}



;; Function main (main, funcdef_no=39, decl_uid=3435, cgraph_uid=40, symbol_order=42)

Removing basic block 19
Merging blocks 18 and 20
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18
;; 2 succs { 3 4 }
;; 3 succs { 18 }
;; 4 succs { 5 9 }
;; 5 succs { 6 8 }
;; 6 succs { 7 8 }
;; 7 succs { 18 }
;; 8 succs { 18 }
;; 9 succs { 10 11 }
;; 10 succs { }
;; 11 succs { 12 13 }
;; 12 succs { }
;; 13 succs { 14 15 }
;; 14 succs { }
;; 15 succs { 16 17 }
;; 16 succs { }
;; 17 succs { 18 }
;; 18 succs { 1 }
int main (int argc, char * * argv)
{
  int jobs;
  struct child_process proc;
  int D.3518;

  <bb 2> :
  proc = {};
  proc.args.argv = &empty_argv;
  proc.env_array.argv = &empty_argv;
  if (argc <= 2)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  D.3518 = 1;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 18>; [INV]

  <bb 4> :
  _1 = argv + 16;
  proc.argv = _1;
  _2 = argv + 8;
  _3 = *_2;
  _4 = strcmp (_3, "start-command-ENOENT");
  if (_4 == 0)
    goto <bb 5>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 5> :
  _5 = start_command (&proc);
  if (_5 < 0)
    goto <bb 6>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 6> :
  _6 = __errno_location ();
  _7 = *_6;
  if (_7 == 2)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  D.3518 = 0;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 18>; [INV]

  <bb 8> :
  _8 = argv + 8;
  _9 = *_8;
  stderr.4_10 = stderr;
  fprintf (stderr.4_10, "FAIL %s\n", _9);
  D.3518 = 1;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 18>; [INV]

  <bb 9> :
  _11 = argv + 8;
  _12 = *_11;
  _13 = strcmp (_12, "run-command");
  if (_13 == 0)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  _14 = run_command (&proc);
  exit (_14);

  <bb 11> :
  _15 = argv + 16;
  _16 = *_15;
  jobs = atoi (_16);
  _17 = argv + 24;
  proc.argv = _17;
  _18 = argv + 8;
  _19 = *_18;
  _20 = strcmp (_19, "run-command-parallel");
  if (_20 == 0)
    goto <bb 12>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 12> :
  _21 = run_processes_parallel (jobs, parallel_next, 0B, 0B, &proc);
  exit (_21);

  <bb 13> :
  _22 = argv + 8;
  _23 = *_22;
  _24 = strcmp (_23, "run-command-abort");
  if (_24 == 0)
    goto <bb 14>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 14> :
  _25 = run_processes_parallel (jobs, parallel_next, 0B, task_finished, &proc);
  exit (_25);

  <bb 15> :
  _26 = argv + 8;
  _27 = *_26;
  _28 = strcmp (_27, "run-command-no-jobs");
  if (_28 == 0)
    goto <bb 16>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 16> :
  _29 = run_processes_parallel (jobs, no_job, 0B, task_finished, &proc);
  exit (_29);

  <bb 17> :
  stderr.5_30 = stderr;
  __builtin_fwrite ("check usage\n", 1, 12, stderr.5_30);
  D.3518 = 1;

  <bb 18> :
  proc = {CLOBBER};
  return D.3518;

}



;; Function no_job (no_job, funcdef_no=37, decl_uid=3422, cgraph_uid=38, symbol_order=40)

Merging blocks 2 and 3
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
int no_job (struct child_process * cp, struct strbuf * err, void * cb, void * * task_cb)
{
  int D.3535;

  <bb 2> :
  strbuf_addf (err, "no further jobs available\n");
  D.3535 = 0;
  return D.3535;

}



;; Function task_finished (task_finished, funcdef_no=38, decl_uid=3430, cgraph_uid=39, symbol_order=41)

Merging blocks 2 and 3
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
int task_finished (int result, struct child_process * cp, struct strbuf * err, void * pp_cb, void * pp_task_cb)
{
  int D.3537;

  <bb 2> :
  strbuf_addf (err, "asking for a quick stop\n");
  D.3537 = 1;
  return D.3537;

}



;; Function parallel_next (parallel_next, funcdef_no=36, decl_uid=3412, cgraph_uid=37, symbol_order=39)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5
;; 2 succs { 3 4 }
;; 3 succs { 5 }
;; 4 succs { 5 }
;; 5 succs { 1 }
int parallel_next (struct child_process * cp, struct strbuf * err, void * cb, void * * task_cb)
{
  struct child_process * d;
  int D.3541;

  <bb 2> :
  d = cb;
  number_callbacks.6_1 = number_callbacks;
  if (number_callbacks.6_1 > 3)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  D.3541 = 0;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 5>; [INV]

  <bb 4> :
  _2 = d->argv;
  _3 = &cp->args;
  argv_array_pushv (_3, _2);
  strbuf_addf (err, "preloaded output of a child\n");
  number_callbacks.7_4 = number_callbacks;
  _5 = number_callbacks.7_4 + 1;
  number_callbacks = _5;
  D.3541 = 1;

  <bb 5> :
  return D.3541;

}



;; Function atoi (atoi, funcdef_no=11, decl_uid=2398, cgraph_uid=12, symbol_order=11)

Merging blocks 2 and 3
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
__attribute__((gnu_inline, pure, leaf, nothrow))
__attribute__((nonnull (1)))
int atoi (const char * __nptr)
{
  int D.3543;

  <bb 2> :
  _1 = strtol (__nptr, 0B, 10);
  D.3543 = (int) _1;
  return D.3543;

}


