
;; Function xrealloc (xrealloc, funcdef_no=26, decl_uid=3197, cgraph_uid=27, symbol_order=27)

Merging blocks 9 and 10
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9
;; 2 succs { 3 4 }
;; 3 succs { 4 }
;; 4 succs { 5 9 }
;; 5 succs { 6 7 }
;; 6 succs { 7 }
;; 7 succs { 8 9 }
;; 8 succs { }
;; 9 succs { 1 }
void * xrealloc (void * ptr, size_t size)
{
  void * ret;
  void * D.3314;

  <bb 2> :
  ret = realloc (ptr, size);
  _1 = ret == 0B;
  _2 = size == 0;
  _3 = _1 & _2;
  if (_3 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  ret = realloc (ptr, 1);

  <bb 4> :
  if (ret == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 5> :
  ret = realloc (ptr, size);
  _4 = ret == 0B;
  _5 = size == 0;
  _6 = _4 & _5;
  if (_6 != 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  ret = realloc (ptr, 1);

  <bb 7> :
  if (ret == 0B)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  printf ("Out of memory, realloc failed%s", "");
  exit (1);

  <bb 9> :
  D.3314 = ret;
  return D.3314;

}



;; Function strbuf_release (strbuf_release, funcdef_no=27, decl_uid=3201, cgraph_uid=28, symbol_order=28)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
void strbuf_release (struct strbuf * sb)
{
  <bb 2> :
  _1 = sb->buf;
  free (_1);
  memset (sb, 0, 24);
  return;

}



;; Function strbuf_grow (strbuf_grow, funcdef_no=28, decl_uid=3206, cgraph_uid=29, symbol_order=29)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9
;; 2 succs { 3 4 }
;; 3 succs { }
;; 4 succs { 5 9 }
;; 5 succs { 6 7 }
;; 6 succs { 8 }
;; 7 succs { 8 }
;; 8 succs { 9 }
;; 9 succs { 1 }
void strbuf_grow (struct strbuf * sb, size_t extra)
{
  <bb 2> :
  _1 = sb->len;
  _2 = extra + _1;
  _3 = _2 + 1;
  _4 = sb->len;
  if (_3 <= _4)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  printf ("you want to use way too much memory %s", "");
  exit (1);

  <bb 4> :
  _5 = sb->len;
  _6 = extra + _5;
  _7 = _6 + 1;
  _8 = sb->alloc;
  if (_7 > _8)
    goto <bb 5>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 5> :
  _9 = sb->alloc;
  _10 = alloc_nr (_9);
  _11 = (long unsigned int) _10;
  _12 = sb->len;
  _13 = extra + _12;
  _14 = _13 + 1;
  if (_11 < _14)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  _15 = sb->len;
  _16 = extra + _15;
  _17 = _16 + 1;
  sb->alloc = _17;
  goto <bb 8>; [INV]

  <bb 7> :
  _18 = sb->alloc;
  _19 = alloc_nr (_18);
  _20 = (long unsigned int) _19;
  sb->alloc = _20;

  <bb 8> :
  _21 = sb->alloc;
  _22 = st_mult (1, _21);
  _23 = (long unsigned int) _22;
  _24 = sb->buf;
  _25 = xrealloc (_24, _23);
  sb->buf = _25;

  <bb 9> :
  return;

}



;; Function strbuf_reset (strbuf_reset, funcdef_no=29, decl_uid=3214, cgraph_uid=30, symbol_order=30)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4
;; 2 succs { 3 4 }
;; 3 succs { 4 }
;; 4 succs { 1 }
void strbuf_reset (struct strbuf * sb)
{
  <bb 2> :
  _1 = sb->len;
  if (_1 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  strbuf_setlen (sb, 0);

  <bb 4> :
  return;

}



;; Function strbuf_add (strbuf_add, funcdef_no=30, decl_uid=3221, cgraph_uid=31, symbol_order=31)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
void strbuf_add (struct strbuf * sb, const void * data, size_t len)
{
  <bb 2> :
  strbuf_grow (sb, len);
  _1 = sb->buf;
  _2 = sb->len;
  _3 = _1 + _2;
  memcpy (_3, data, len);
  _4 = sb->len;
  _5 = len + _4;
  strbuf_setlen (sb, _5);
  return;

}



;; Function strbuf_getline (strbuf_getline, funcdef_no=31, decl_uid=3228, cgraph_uid=32, symbol_order=32)

;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12
;;
;; Loop 1
;;  header 7, latch 6
;;  depth 1, outer 0
;;  nodes: 7 6 5
;; 2 succs { 3 4 }
;; 3 succs { 12 }
;; 4 succs { 7 }
;; 5 succs { 8 6 }
;; 6 succs { 7 }
;; 7 succs { 5 8 }
;; 8 succs { 9 11 }
;; 9 succs { 10 11 }
;; 10 succs { 12 }
;; 11 succs { 12 }
;; 12 succs { 1 }
int strbuf_getline (struct strbuf * sb, struct FILE * fp, int term)
{
  int ch;
  int D.3327;

  <bb 2> :
  strbuf_grow (sb, 0);
  _1 = feof (fp);
  if (_1 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  D.3327 = -1;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 12>; [INV]

  <bb 4> :
  strbuf_reset (sb);
  goto <bb 7>; [INV]

  <bb 5> :
  if (ch == term)
    goto <bb 8>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 6> :
  strbuf_grow (sb, 1);
  _2 = sb->buf;
  _3 = sb->len;
  _4 = _3;
  _5 = _4 + 1;
  sb->len = _5;
  _6 = _2 + _4;
  _7 = (char) ch;
  *_6 = _7;

  <bb 7> :
  ch = fgetc (fp);
  if (ch != -1)
    goto <bb 5>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 8> :
  if (ch == -1)
    goto <bb 9>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 9> :
  _8 = sb->len;
  if (_8 == 0)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  D.3327 = -1;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 12>; [INV]

  <bb 11> :
  _9 = sb->buf;
  _10 = sb->len;
  _11 = _9 + _10;
  *_11 = 0;
  D.3327 = 0;

  <bb 12> :
  return D.3327;

}



;; Function strtoul (strtoul, funcdef_no=32, decl_uid=2419, cgraph_uid=33, symbol_order=33)

Merging blocks 2 and 3
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
__attribute__((leaf, nothrow))
__attribute__((nonnull (1)))
long unsigned int strtoul (const char * str, char * * endptr, int base)
{
  long unsigned int D.3334;

  <bb 2> :
  _1 = (sizetype) base;
  _2 = str + _1;
  *endptr = _2;
  D.3334 = (long unsigned int) base;
  return D.3334;

}



;; Function unquote_c_style (unquote_c_style, funcdef_no=33, decl_uid=3242, cgraph_uid=34, symbol_order=34)

Removing basic block 8
Removing basic block 18
;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27
;;
;; Loop 1
;;  header 4, latch 25
;;  depth 1, outer 0
;;  nodes: 4 25 10 11 12 13 14 15 16 9 23 21 20 18 17
;; 2 succs { 3 4 }
;; 3 succs { 27 }
;; 4 succs { 8 5 9 }
;; 5 succs { 6 7 }
;; 6 succs { 7 }
;; 7 succs { 27 }
;; 8 succs { 26 }
;; 9 succs { 24 25 17 10 11 12 13 14 15 16 }
;; 10 succs { 25 }
;; 11 succs { 25 }
;; 12 succs { 25 }
;; 13 succs { 25 }
;; 14 succs { 25 }
;; 15 succs { 25 }
;; 16 succs { 25 }
;; 17 succs { 19 18 }
;; 18 succs { 19 20 }
;; 19 succs { 26 }
;; 20 succs { 22 21 }
;; 21 succs { 22 23 }
;; 22 succs { 26 }
;; 23 succs { 25 }
;; 24 succs { 26 }
;; 25 succs { 4 }
;; 26 succs { 27 }
;; 27 succs { 1 }
int unquote_c_style (struct strbuf * sb, const char * quoted, const char * * endp)
{
  int ac;
  int ch;
  size_t len;
  size_t oldlen;
  int D.3338;

  <bb 2> :
  oldlen = sb->len;
  quoted.0_1 = quoted;
  quoted = quoted.0_1 + 1;
  _2 = *quoted.0_1;
  if (_2 != 34)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  D.3338 = -1;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 27>; [INV]

  <bb 4> :
  len = strcspn (quoted, "\"\\");
  strbuf_add (sb, quoted, len);
  quoted = quoted + len;
  quoted.1_3 = quoted;
  quoted = quoted.1_3 + 1;
  _4 = *quoted.1_3;
  _5 = (int) _4;
  switch (_5) <default: <L7> [INV], case 34: <L3> [INV], case 92: <L32> [INV]>

  <bb 5> :
<L3>:
  if (endp != 0B)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  _6 = quoted + 1;
  *endp = _6;

  <bb 7> :
  D.3338 = 0;
  goto <bb 27>; [INV]

  <bb 8> :
<L7>:
  // predicted unlikely by goto predictor.
  goto <bb 26>; [INV]

  <bb 9> :
<L32>:
  quoted.2_7 = quoted;
  quoted = quoted.2_7 + 1;
  _8 = *quoted.2_7;
  ch = (int) _8;
  switch (ch) <default: <L28> [INV], case 34: <L33> [INV], case 48 ... 51: <L18> [INV], case 92: <L33> [INV], case 97: <L9> [INV], case 98: <L10> [INV], case 102: <L11> [INV], case 110: <L12> [INV], case 114: <L13> [INV], case 116: <L14> [INV], case 118: <L15> [INV]>

  <bb 10> :
<L9>:
  ch = 7;
  goto <bb 25>; [INV]

  <bb 11> :
<L10>:
  ch = 8;
  goto <bb 25>; [INV]

  <bb 12> :
<L11>:
  ch = 12;
  goto <bb 25>; [INV]

  <bb 13> :
<L12>:
  ch = 10;
  goto <bb 25>; [INV]

  <bb 14> :
<L13>:
  ch = 13;
  goto <bb 25>; [INV]

  <bb 15> :
<L14>:
  ch = 9;
  goto <bb 25>; [INV]

  <bb 16> :
<L15>:
  ch = 11;
  goto <bb 25>; [INV]

  <bb 17> :
<L18>:
  _9 = ch + -48;
  ac = _9 << 6;
  quoted.3_10 = quoted;
  quoted = quoted.3_10 + 1;
  _11 = *quoted.3_10;
  ch = (int) _11;
  if (ch <= 47)
    goto <bb 19>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 18> :
  if (ch > 55)
    goto <bb 19>; [INV]
  else
    goto <bb 20>; [INV]

  <bb 19> :
  // predicted unlikely by goto predictor.
  goto <bb 26>; [INV]

  <bb 20> :
  _12 = ch + -48;
  _13 = _12 << 3;
  ac = ac | _13;
  quoted.4_14 = quoted;
  quoted = quoted.4_14 + 1;
  _15 = *quoted.4_14;
  ch = (int) _15;
  if (ch <= 47)
    goto <bb 22>; [INV]
  else
    goto <bb 21>; [INV]

  <bb 21> :
  if (ch > 55)
    goto <bb 22>; [INV]
  else
    goto <bb 23>; [INV]

  <bb 22> :
  // predicted unlikely by goto predictor.
  goto <bb 26>; [INV]

  <bb 23> :
  _16 = ch + -48;
  ac = ac | _16;
  ch = ac;
  goto <bb 25>; [INV]

  <bb 24> :
<L28>:
  // predicted unlikely by goto predictor.
  goto <bb 26>; [INV]

  <bb 25> :
<L33>:
  strbuf_addch (sb, ch);
  goto <bb 4>; [INV]

  <bb 26> :
error:
  strbuf_setlen (sb, oldlen);
  D.3338 = -1;

  <bb 27> :
  return D.3338;

}



;; Function main (main, funcdef_no=35, decl_uid=3302, cgraph_uid=36, symbol_order=36)

Removing basic block 3
Merging blocks 2 and 4
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
int main ()
{
  int line;
  int D.3350;

  <bb 2> :
  read_index_info (line);
  D.3350 = 0;
  return D.3350;

}



;; Function read_index_info (read_index_info, funcdef_no=34, decl_uid=3276, cgraph_uid=35, symbol_order=35)

Removing basic block 29
;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37
;;
;; Loop 1
;;  header 36, latch 35
;;  depth 1, outer 0
;;  nodes: 36 35 25 33 31 32 27 29 26 24 19 20 23 21 17 16 14 15 11 12 13 9 8 6 5 4 3
;; 2 succs { 36 }
;; 3 succs { 7 4 }
;; 4 succs { 7 5 }
;; 5 succs { 7 6 }
;; 6 succs { 7 8 }
;; 7 succs { 34 }
;; 8 succs { 10 9 }
;; 9 succs { 10 11 }
;; 10 succs { 34 }
;; 11 succs { 12 15 }
;; 12 succs { 13 15 }
;; 13 succs { 14 15 }
;; 14 succs { 16 }
;; 15 succs { 16 }
;; 16 succs { 18 17 }
;; 17 succs { 18 19 }
;; 18 succs { 34 }
;; 19 succs { 20 24 }
;; 20 succs { 21 24 }
;; 21 succs { 22 23 }
;; 22 succs { }
;; 23 succs { 24 }
;; 24 succs { 25 26 }
;; 25 succs { 35 }
;; 26 succs { 27 29 }
;; 27 succs { 28 31 }
;; 28 succs { }
;; 29 succs { 30 31 }
;; 30 succs { }
;; 31 succs { 32 33 }
;; 32 succs { 33 }
;; 33 succs { 35 }
;; 34 succs { }
;; 35 succs { 36 }
;; 36 succs { 3 37 }
;; 37 succs { 1 }
void read_index_info (int line_termination)
{
  int stage;
  long unsigned int ul;
  unsigned int mode;
  unsigned char sha1[20];
  char * path_name;
  char * tab;
  char * ptr;
  struct strbuf uq;
  struct strbuf buf;

  <bb 2> :
  strbuf_init (&buf, 0);
  strbuf_init (&uq, 0);
  goto <bb 36>; [INV]

  <bb 3> :
  _1 = __errno_location ();
  *_1 = 0;
  _2 = buf.buf;
  ul = strtoul (_2, &ptr, 8);
  _3 = buf.buf;
  ptr.5_4 = ptr;
  if (_3 == ptr.5_4)
    goto <bb 7>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 4> :
  ptr.6_5 = ptr;
  _6 = *ptr.6_5;
  if (_6 != 32)
    goto <bb 7>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 5> :
  _7 = __errno_location ();
  _8 = *_7;
  if (_8 != 0)
    goto <bb 7>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 6> :
  _9 = (unsigned int) ul;
  _10 = (long unsigned int) _9;
  if (ul != _10)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  // predicted unlikely by goto predictor.
  goto <bb 34>; [INV]

  <bb 8> :
  mode = (unsigned int) ul;
  ptr.7_11 = ptr;
  tab = strchr (ptr.7_11, 9);
  if (tab == 0B)
    goto <bb 10>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 9> :
  ptr.8_12 = ptr;
  _13 = tab - ptr.8_12;
  if (_13 <= 40)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  // predicted unlikely by goto predictor.
  goto <bb 34>; [INV]

  <bb 11> :
  _14 = tab + 18446744073709551614;
  _15 = *_14;
  if (_15 == 32)
    goto <bb 12>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 12> :
  _16 = tab + 18446744073709551615;
  _17 = *_16;
  if (_17 > 47)
    goto <bb 13>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 13> :
  _18 = tab + 18446744073709551615;
  _19 = *_18;
  if (_19 <= 51)
    goto <bb 14>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 14> :
  _20 = tab + 18446744073709551615;
  _21 = *_20;
  _22 = (int) _21;
  stage = _22 + -48;
  _23 = tab + 1;
  ptr = _23;
  tab = tab + 18446744073709551614;
  goto <bb 16>; [INV]

  <bb 15> :
  stage = 0;
  _24 = tab + 1;
  ptr = _24;

  <bb 16> :
  _25 = tab + 18446744073709551576;
  _26 = get_sha1_hex (_25, &sha1);
  if (_26 != 0)
    goto <bb 18>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 17> :
  _27 = tab + 18446744073709551575;
  _28 = *_27;
  if (_28 != 32)
    goto <bb 18>; [INV]
  else
    goto <bb 19>; [INV]

  <bb 18> :
  // predicted unlikely by goto predictor.
  goto <bb 34>; [INV]

  <bb 19> :
  path_name = ptr;
  if (line_termination != 0)
    goto <bb 20>; [INV]
  else
    goto <bb 24>; [INV]

  <bb 20> :
  _29 = *path_name;
  if (_29 == 34)
    goto <bb 21>; [INV]
  else
    goto <bb 24>; [INV]

  <bb 21> :
  strbuf_reset (&uq);
  _30 = unquote_c_style (&uq, path_name, 0B);
  if (_30 != 0)
    goto <bb 22>; [INV]
  else
    goto <bb 23>; [INV]

  <bb 22> :
  printf ("git-update-index: bad quoting of path name%s", "");
  exit (1);

  <bb 23> :
  path_name = uq.buf;

  <bb 24> :
  _31 = verify_path (path_name);
  if (_31 == 0)
    goto <bb 25>; [INV]
  else
    goto <bb 26>; [INV]

  <bb 25> :
  stderr.9_32 = stderr;
  fprintf (stderr.9_32, "Ignoring path %s\n", path_name);
  // predicted unlikely by continue predictor.
  goto <bb 35>; [INV]

  <bb 26> :
  if (mode == 0)
    goto <bb 27>; [INV]
  else
    goto <bb 29>; [INV]

  <bb 27> :
  _33 = remove_file_from_cache (path_name);
  if (_33 != 0)
    goto <bb 28>; [INV]
  else
    goto <bb 31>; [INV]

  <bb 28> :
  ptr.10_34 = ptr;
  printf ("git-update-index: unable to remove %s", ptr.10_34);
  exit (1);

  <bb 29> :
  ptr.11_35 = ptr;
  _36 = ptr.11_35 + 18446744073709551615;
  *_36 = 0;
  ptr.12_37 = ptr;
  _38 = ptr.12_37 + 18446744073709551574;
  _39 = *_36;
  *_38 = _39;
  _40 = add_cacheinfo (mode, &sha1, path_name, stage);
  if (_40 != 0)
    goto <bb 30>; [INV]
  else
    goto <bb 31>; [INV]

  <bb 30> :
  printf ("git-update-index: unable to update %s", path_name);
  exit (1);

  <bb 31> :
  ptr.13_41 = ptr;
  if (path_name != ptr.13_41)
    goto <bb 32>; [INV]
  else
    goto <bb 33>; [INV]

  <bb 32> :
  free (path_name);

  <bb 33> :
  // predicted unlikely by continue predictor.
  goto <bb 35>; [INV]

  <bb 34> :
bad_line:
  _42 = buf.buf;
  printf ("malformed index info %s", _42);
  exit (1);

  <bb 35> :
  ptr = {CLOBBER};
  sha1 = {CLOBBER};

  <bb 36> :
  stdin.14_43 = stdin;
  _44 = strbuf_getline (&buf, stdin.14_43, line_termination);
  if (_44 != -1)
    goto <bb 3>; [INV]
  else
    goto <bb 37>; [INV]

  <bb 37> :
  strbuf_release (&buf);
  strbuf_release (&uq);
  buf = {CLOBBER};
  uq = {CLOBBER};
  return;

}


