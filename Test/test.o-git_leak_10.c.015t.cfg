
;; Function xrealloc (xrealloc, funcdef_no=26, decl_uid=3195, cgraph_uid=27, symbol_order=27)

Merging blocks 9 and 10
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9
;; 2 succs { 3 4 }
;; 3 succs { 4 }
;; 4 succs { 5 9 }
;; 5 succs { 6 7 }
;; 6 succs { 7 }
;; 7 succs { 8 9 }
;; 8 succs { }
;; 9 succs { 1 }
void * xrealloc (void * ptr, size_t size)
{
  void * ret;
  void * D.3406;

  <bb 2> :
  ret = realloc (ptr, size);
  _1 = ret == 0B;
  _2 = size == 0;
  _3 = _1 & _2;
  if (_3 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  ret = realloc (ptr, 1);

  <bb 4> :
  if (ret == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 5> :
  ret = realloc (ptr, size);
  _4 = ret == 0B;
  _5 = size == 0;
  _6 = _4 & _5;
  if (_6 != 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  ret = realloc (ptr, 1);

  <bb 7> :
  if (ret == 0B)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  printf ("Out of memory, realloc failed%s", "");
  exit (1);

  <bb 9> :
  D.3406 = ret;
  return D.3406;

}



;; Function update_tree_entry (update_tree_entry, funcdef_no=28, decl_uid=3292, cgraph_uid=29, symbol_order=32)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4
;; 2 succs { 3 4 }
;; 3 succs { }
;; 4 succs { 1 }
void update_tree_entry (struct tree_desc * desc)
{
  struct strbuf err;

  <bb 2> :
  err.alloc = 0;
  err.len = 0;
  err.buf = &strbuf_slopbuf;
  _1 = update_tree_entry_internal (desc, &err);
  if (_1 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  _2 = err.buf;
  printf ("%s", _2);
  exit (1);

  <bb 4> :
  strbuf_release (&err);
  err = {CLOBBER};
  return;

}



;; Function update_tree_entry_internal (update_tree_entry_internal, funcdef_no=27, decl_uid=3283, cgraph_uid=28, symbol_order=31)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7
;; 2 succs { 3 4 }
;; 3 succs { }
;; 4 succs { 5 6 }
;; 5 succs { 7 }
;; 6 succs { 7 }
;; 7 succs { 1 }
int update_tree_entry_internal (struct tree_desc * desc, struct strbuf * err)
{
  long unsigned int len;
  long unsigned int size;
  const unsigned char * end;
  const void * buf;
  int D.3414;

  <bb 2> :
  buf = desc->buffer;
  _1 = desc->entry.oid;
  _2 = &_1->hash;
  end = _2 + 20;
  _3 = desc->size;
  size = (long unsigned int) _3;
  _4 = end - buf;
  len = (long unsigned int) _4;
  if (size < len)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  printf ("too-short tree file%s", buf);
  exit (1);

  <bb 4> :
  buf = end;
  size = size - len;
  desc->buffer = buf;
  _5 = (unsigned int) size;
  desc->size = _5;
  if (size != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  D.3414 = decode_tree_entry (desc, buf, size, err);
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 7>; [INV]

  <bb 6> :
  D.3414 = 0;

  <bb 7> :
  return D.3414;

}



;; Function traverse_trees (traverse_trees, funcdef_no=30, decl_uid=3322, cgraph_uid=31, symbol_order=34)

Merging blocks 8 and 9
;; 3 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8
;;
;; Loop 2
;;  header 7, latch 6
;;  depth 1, outer 0
;;  nodes: 7 6
;;
;; Loop 1
;;  header 4, latch 3
;;  depth 1, outer 0
;;  nodes: 4 3
;; 2 succs { 4 }
;; 3 succs { 4 }
;; 4 succs { 3 5 }
;; 5 succs { 7 }
;; 6 succs { 7 }
;; 7 succs { 6 8 }
;; 8 succs { 1 }
int traverse_trees (int n, struct tree_desc * t, struct traverse_info * info)
{
  struct name_entry * e;
  struct name_entry * entry;
  struct tree_desc_x * tx;
  int n;
  int i;
  int D.3416;

  <bb 2> :
  _1 = (long unsigned int) n;
  tx = calloc (_1, 48);
  _2 = (long unsigned int) n;
  _3 = _2 * 24;
  entry = malloc (_3);
  e = 0B;
  i = 0;
  goto <bb 4>; [INV]

  <bb 3> :
  _4 = (long unsigned int) i;
  _5 = _4 * 40;
  _6 = t + _5;
  _7 = (long unsigned int) i;
  _8 = _7 * 48;
  _9 = tx + _8;
  _9->d = *_6;
  i = i + 1;

  <bb 4> :
  if (i < n)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 5> :
  i = 0;
  goto <bb 7>; [INV]

  <bb 6> :
  _10 = (long unsigned int) i;
  _11 = _10 * 24;
  e = entry + _11;
  _12 = (long unsigned int) i;
  _13 = _12 * 48;
  _14 = tx + _13;
  extended_entry_extract (_14, e, 0B, 0);
  i = i + 1;

  <bb 7> :
  if (i < n)
    goto <bb 6>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 8> :
  free (tx);
  D.3416 = 1;
  return D.3416;

}



;; Function extended_entry_extract (extended_entry_extract, funcdef_no=29, decl_uid=3301, cgraph_uid=30, symbol_order=33)

;; 3 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10
;;
;; Loop 1
;;  header 2, latch 9
;;  depth 1, outer 0
;;  nodes: 2 9 8 5 7 4 6
;;
;; Loop 2
;;  header 7, latch 6
;;  depth 2, outer 1
;;  nodes: 7 6 5
;; 2 succs { 3 4 }
;; 3 succs { 10 }
;; 4 succs { 7 }
;; 5 succs { 8 6 }
;; 6 succs { 7 }
;; 7 succs { 5 8 }
;; 8 succs { 10 9 }
;; 9 succs { 2 }
;; 10 succs { 1 }
void extended_entry_extract (struct tree_desc_x * t, struct name_entry * a, const char * first, int first_len)
{
  struct tree_desc_skip * skip;
  struct tree_desc probe;
  int len;
  const char * path;

  <bb 2> :
  _1 = t->d.size;
  if (_1 == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  entry_clear (a);
  goto <bb 10>; [INV]

  <bb 4> :
  _2 = &t->d;
  entry_extract (_2, a);
  skip = t->skip;
  goto <bb 7>; [INV]

  <bb 5> :
  _3 = a->path;
  _4 = skip->ptr;
  if (_3 == _4)
    goto <bb 8>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 6> :
  skip = skip->prev;

  <bb 7> :
  if (skip != 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 8> :
  if (skip == 0B)
    goto <bb 10>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 9> :
  _5 = &t->d;
  update_tree_entry (_5);
  goto <bb 2>; [INV]

  <bb 10> :
  probe = {CLOBBER};
  return;

}



;; Function unpack_trees (unpack_trees, funcdef_no=31, decl_uid=3340, cgraph_uid=32, symbol_order=35)

Merging blocks 2 and 3
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
int unpack_trees (unsigned int len, struct tree_desc * t, struct unpack_trees_options * o)
{
  int D.3422;

  <bb 2> :
  len.0_1 = (int) len;
  traverse_trees (len.0_1, t, 0B);
  D.3422 = 0;
  return D.3422;

}



;; Function init_tree_desc (init_tree_desc, funcdef_no=33, decl_uid=3352, cgraph_uid=34, symbol_order=37)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4
;; 2 succs { 3 4 }
;; 3 succs { }
;; 4 succs { 1 }
void init_tree_desc (struct tree_desc * desc, const void * buffer, long unsigned int size)
{
  struct strbuf err;

  <bb 2> :
  err.alloc = 0;
  err.len = 0;
  err.buf = &strbuf_slopbuf;
  _1 = init_tree_desc_internal (desc, buffer, size, &err);
  if (_1 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  _2 = err.buf;
  printf ("%s", _2);
  exit (1);

  <bb 4> :
  strbuf_release (&err);
  err = {CLOBBER};
  return;

}



;; Function init_tree_desc_internal (init_tree_desc_internal, funcdef_no=32, decl_uid=3346, cgraph_uid=33, symbol_order=36)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5
;; 2 succs { 3 4 }
;; 3 succs { 5 }
;; 4 succs { 5 }
;; 5 succs { 1 }
int init_tree_desc_internal (struct tree_desc * desc, const void * buffer, long unsigned int size, struct strbuf * err)
{
  int D.3428;

  <bb 2> :
  desc->buffer = buffer;
  _1 = (unsigned int) size;
  desc->size = _1;
  if (size != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  D.3428 = decode_tree_entry (desc, buffer, size, err);
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 5>; [INV]

  <bb 4> :
  D.3428 = 0;

  <bb 5> :
  return D.3428;

}



;; Function fill_tree_descriptor (fill_tree_descriptor, funcdef_no=34, decl_uid=3358, cgraph_uid=35, symbol_order=38)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5
;; 2 succs { 3 5 }
;; 3 succs { 4 5 }
;; 4 succs { }
;; 5 succs { 1 }
void fill_tree_descriptor (struct tree_desc * desc, const struct object_id * oid)
{
  void * buf;
  long unsigned int size;

  <bb 2> :
  size = 0;
  buf = 0B;
  if (oid != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 3> :
  buf = malloc (100);
  if (buf == 0B)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  _1 = oid_to_hex (oid);
  printf ("unable to read tree %s", _1);
  exit (1);

  <bb 5> :
  init_tree_desc (desc, buf, size);
  return;

}



;; Function main (main, funcdef_no=36, decl_uid=3392, cgraph_uid=37, symbol_order=40)

Removing basic block 4
Merging blocks 2 and 3
Merging blocks 2 and 5
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
int main ()
{
  int quiet;
  int type;
  struct object_id oid;
  int D.3434;

  <bb 2> :
  reset_index (&oid, type, quiet);
  D.3434 = 0;
  oid = {CLOBBER};
  return D.3434;

}



;; Function reset_index (reset_index, funcdef_no=35, decl_uid=3367, cgraph_uid=36, symbol_order=39)

Merging blocks 10 and 12
Merging blocks 18 and 19
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17
;; 2 succs { 3 4 }
;; 3 succs { 4 }
;; 4 succs { 7 6 5 }
;; 5 succs { 8 }
;; 6 succs { 7 }
;; 7 succs { 8 }
;; 8 succs { 9 12 }
;; 9 succs { 10 11 }
;; 10 succs { 17 }
;; 11 succs { 12 }
;; 12 succs { 13 14 }
;; 13 succs { 17 }
;; 14 succs { 15 16 }
;; 15 succs { 16 }
;; 16 succs { 17 }
;; 17 succs { 1 }
int reset_index (const struct object_id * oid, int reset_type, int quiet)
{
  struct object_id head_oid;
  struct unpack_trees_options opts;
  struct tree * tree;
  struct tree_desc desc[2];
  int nr;
  int D.3443;

  <bb 2> :
  nr = 0;
  memset (&opts, 0, 640);
  opts.head_idx = 1;
  opts.src_index = &the_index;
  opts.dst_index = &the_index;
  opts.fn = oneway_merge;
  opts.merge = 1;
  if (quiet == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  opts.verbose_update = 1;

  <bb 4> :
  switch (reset_type) <default: <L5> [INV], case 2: <L4> [INV], case 3 ... 4: <L2> [INV]>

  <bb 5> :
<L2>:
  opts.update = 1;
  goto <bb 8>; [INV]

  <bb 6> :
<L4>:
  opts.update = 1;

  <bb 7> :
<L5>:
  opts.reset = 1;

  <bb 8> :
  read_cache_unmerged ();
  if (reset_type == 4)
    goto <bb 9>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 9> :
  _1 = get_oid ("HEAD", &head_oid);
  if (_1 != 0)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  _2 = _ ("You do not have a valid HEAD.");
  D.3443 = error (_2);
  // predicted unlikely by early return (on trees) predictor.
  head_oid = {CLOBBER};
  goto <bb 17>; [INV]

  <bb 11> :
  _3 = (long unsigned int) nr;
  _4 = _3 * 40;
  _5 = &desc + _4;
  fill_tree_descriptor (_5, &head_oid);
  nr = nr + 1;
  opts.fn = twoway_merge;
  head_oid = {CLOBBER};

  <bb 12> :
  _6 = (long unsigned int) nr;
  _7 = _6 * 40;
  _8 = &desc + _7;
  fill_tree_descriptor (_8, oid);
  nr = nr + 1;
  _9 = desc[nr].buffer;
  printf ("%d\n", _9);
  nr.1_10 = (unsigned int) nr;
  _11 = unpack_trees (nr.1_10, &desc, &opts);
  if (_11 != 0)
    goto <bb 13>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 13> :
  D.3443 = -1;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 17>; [INV]

  <bb 14> :
  _12 = reset_type == 0;
  _13 = reset_type == 2;
  _14 = _12 | _13;
  if (_14 != 0)
    goto <bb 15>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 15> :
  _15 = parse_tree_indirect (oid);
  _16 = (long int) _15;
  tree = (struct tree *) _16;
  prime_cache_tree (&the_index, tree);

  <bb 16> :
  D.3443 = 0;

  <bb 17> :
  desc = {CLOBBER};
  opts = {CLOBBER};
  return D.3443;

}


