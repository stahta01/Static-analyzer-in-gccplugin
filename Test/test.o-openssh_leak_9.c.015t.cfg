
;; Function xrealloc (xrealloc, funcdef_no=22, decl_uid=3509, cgraph_uid=23, symbol_order=23)

Merging blocks 11 and 12
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11
;; 2 succs { 3 4 }
;; 3 succs { }
;; 4 succs { 5 6 }
;; 5 succs { }
;; 6 succs { 7 8 }
;; 7 succs { 9 }
;; 8 succs { 9 }
;; 9 succs { 10 11 }
;; 10 succs { }
;; 11 succs { 1 }
void * xrealloc (void * ptr, size_t nmemb, size_t size)
{
  size_t new_size;
  void * new_ptr;
  void * D.3578;

  <bb 2> :
  new_size = nmemb * size;
  if (new_size == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  printf ("xrealloc: zero size%s\n", "");
  exit (1);

  <bb 4> :
  _1 = 10000 / nmemb;
  if (size > _1)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  printf ("xrealloc: nmemb * size > SIZE_T_MAX%s\n", "");
  exit (1);

  <bb 6> :
  if (ptr == 0B)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  new_ptr = malloc (new_size);
  goto <bb 9>; [INV]

  <bb 8> :
  new_ptr = realloc (ptr, new_size);

  <bb 9> :
  if (new_ptr == 0B)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  printf ("xrealloc: out of memory (new_size %lu bytes\n)", new_size);
  exit (1);

  <bb 11> :
  D.3578 = new_ptr;
  return D.3578;

}



;; Function free_sftp_dirents (free_sftp_dirents, funcdef_no=23, decl_uid=3514, cgraph_uid=24, symbol_order=24)

;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5
;;
;; Loop 1
;;  header 4, latch 3
;;  depth 1, outer 0
;;  nodes: 4 3
;; 2 succs { 4 }
;; 3 succs { 4 }
;; 4 succs { 3 5 }
;; 5 succs { 1 }
void free_sftp_dirents (struct SFTP_DIRENT * * s)
{
  int i;

  <bb 2> :
  i = 0;
  goto <bb 4>; [INV]

  <bb 3> :
  _1 = (long unsigned int) i;
  _2 = _1 * 8;
  _3 = s + _2;
  _4 = *_3;
  _5 = _4->filename;
  free (_5);
  _6 = (long unsigned int) i;
  _7 = _6 * 8;
  _8 = s + _7;
  _9 = *_8;
  _10 = _9->longname;
  free (_10);
  _11 = (long unsigned int) i;
  _12 = _11 * 8;
  _13 = s + _12;
  _14 = *_13;
  free (_14);
  i = i + 1;

  <bb 4> :
  _15 = (long unsigned int) i;
  _16 = _15 * 8;
  _17 = s + _16;
  _18 = *_17;
  if (_18 != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 5> :
  free (s);
  return;

}



;; Function do_readdir (do_readdir, funcdef_no=25, decl_uid=3549, cgraph_uid=26, symbol_order=26)

Merging blocks 2 and 3
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
int do_readdir (char * path, struct SFTP_DIRENT * * * dir)
{
  int D.3580;

  <bb 2> :
  D.3580 = do_lsreaddir (path, 0, dir);
  return D.3580;

}



;; Function do_lsreaddir (do_lsreaddir, funcdef_no=24, decl_uid=3524, cgraph_uid=25, symbol_order=25)

Removing basic block 4
Merging blocks 23 and 24
;; 3 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22
;;
;; Loop 1
;;  header 16, latch 15
;;  depth 1, outer 0
;;  nodes: 16 15 7 14 11 12 13 10 8 9 6 4
;;
;; Loop 2
;;  header 15, latch 14
;;  depth 2, outer 1
;;  nodes: 15 14 11 12 13 10 8 9
;; 2 succs { 3 16 }
;; 3 succs { 16 }
;; 4 succs { 5 6 }
;; 5 succs { 22 }
;; 6 succs { 17 7 }
;; 7 succs { 15 }
;; 8 succs { 9 10 }
;; 9 succs { 10 }
;; 10 succs { 11 12 }
;; 11 succs { 14 }
;; 12 succs { 13 14 }
;; 13 succs { 14 }
;; 14 succs { 15 }
;; 15 succs { 8 16 }
;; 16 succs { 4 17 }
;; 17 succs { 18 21 }
;; 18 succs { 19 21 }
;; 19 succs { 20 21 }
;; 20 succs { 21 }
;; 21 succs { 22 }
;; 22 succs { 1 }
int do_lsreaddir (char * path, int print_flag, struct SFTP_DIRENT * * * dir)
{
  char * longname;
  char * filename;
  char * handle;
  u_int ents;
  u_int expected_id;
  u_int i;
  u_int handle_len;
  u_int id;
  u_int type;
  u_int count;
  struct Buffer msg;
  int D.3586;

  <bb 2> :
  ents = 0;
  if (dir != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 3> :
  ents = 0;
  _1 = calloc (1, 8);
  *dir = _1;
  _2 = *dir;
  *_2 = 0B;
  goto <bb 16>; [INV]

  <bb 4> :
  _3 = rand ();
  _4 = _3 % 2;
  if (_4 == 1)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  D.3586 = -1;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 22>; [INV]

  <bb 6> :
  _5 = rand ();
  _6 = _5 % 5;
  count = (u_int) _6;
  if (count == 0)
    goto <bb 17>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  i = 0;
  goto <bb 15>; [INV]

  <bb 8> :
  filename = path;
  longname = "longname";
  if (print_flag != 0)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  __builtin_puts (longname);

  <bb 10> :
  _7 = strchr (filename, 47);
  if (_7 != 0B)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  printf ("Server sent suspect path \"%s\" during readdir of \"%s\"", filename, path);
  // predicted unlikely by goto predictor.
  goto <bb 14>; [INV]

  <bb 12> :
  if (dir != 0B)
    goto <bb 13>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 13> :
  _8 = ents + 2;
  _9 = (long unsigned int) _8;
  _10 = *dir;
  _11 = xrealloc (_10, _9, 8);
  *dir = _11;
  _12 = *dir;
  _13 = (long unsigned int) ents;
  _14 = _13 * 8;
  _15 = _12 + _14;
  _16 = calloc (1, 56);
  *_15 = _16;
  _17 = *dir;
  _18 = (long unsigned int) ents;
  _19 = _18 * 8;
  _20 = _17 + _19;
  _21 = *_20;
  _22 = strdup (filename);
  _21->filename = _22;
  _23 = *dir;
  _24 = (long unsigned int) ents;
  _25 = _24 * 8;
  _26 = _23 + _25;
  _27 = *_26;
  _28 = strdup (longname);
  _27->longname = _28;
  _29 = *dir;
  ents = ents + 1;
  _30 = (long unsigned int) ents;
  _31 = _30 * 8;
  _32 = _29 + _31;
  *_32 = 0B;

  <bb 14> :
next:
  _33 = rand ();
  _34 = _33 % 2;
  _35 = _34 == 1;
  _36 = (int) _35;
  interrupted = _36;
  i = i + 1;

  <bb 15> :
  if (i < count)
    goto <bb 8>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 16> :
  interrupted.0_37 = interrupted;
  if (interrupted.0_37 == 0)
    goto <bb 4>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 17> :
  interrupted.1_38 = interrupted;
  if (interrupted.1_38 != 0)
    goto <bb 18>; [INV]
  else
    goto <bb 21>; [INV]

  <bb 18> :
  if (dir != 0B)
    goto <bb 19>; [INV]
  else
    goto <bb 21>; [INV]

  <bb 19> :
  _39 = *dir;
  if (_39 != 0B)
    goto <bb 20>; [INV]
  else
    goto <bb 21>; [INV]

  <bb 20> :
  _40 = *dir;
  free_sftp_dirents (_40);
  _41 = calloc (1, 8);
  *dir = _41;
  _42 = *dir;
  *_42 = 0B;

  <bb 21> :
  D.3586 = 0;

  <bb 22> :
  msg = {CLOBBER};
  return D.3586;

}



;; Function main (main, funcdef_no=26, decl_uid=3553, cgraph_uid=27, symbol_order=27)

Removing basic block 15
Merging blocks 14 and 16
;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14
;;
;; Loop 1
;;  header 12, latch 11
;;  depth 1, outer 0
;;  nodes: 12 11 9 10 8
;; 2 succs { 3 4 }
;; 3 succs { 5 }
;; 4 succs { 5 }
;; 5 succs { 6 7 }
;; 6 succs { 14 }
;; 7 succs { 12 }
;; 8 succs { 10 9 }
;; 9 succs { 10 11 }
;; 10 succs { 11 }
;; 11 succs { 12 }
;; 12 succs { 8 13 }
;; 13 succs { 14 }
;; 14 succs { 1 }
int main (int argc, char * * argv)
{
  char * filename;
  struct SFTP_DIRENT * * dir_entries;
  int ret;
  int i;
  char * dst;
  char * src;
  int D.3607;

  <bb 2> :
  ret = 0;
  _1 = time (0B);
  _2 = (unsigned int) _1;
  srand (_2);
  if (argc == 1)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  src = *argv;
  goto <bb 5>; [INV]

  <bb 4> :
  src = MEM[(char * *)argv + 8B];

  <bb 5> :
  _3 = do_readdir (src, &dir_entries);
  if (_3 == -1)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  printf ("%s: Failed to get directory contents", src);
  D.3607 = -1;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 14>; [INV]

  <bb 7> :
  i = 0;
  goto <bb 12>; [INV]

  <bb 8> :
  dir_entries.2_4 = dir_entries;
  _5 = (long unsigned int) i;
  _6 = _5 * 8;
  _7 = dir_entries.2_4 + _6;
  _8 = *_7;
  filename = _8->filename;
  _9 = strcmp (filename, ".");
  if (_9 == 0)
    goto <bb 10>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 9> :
  _10 = strcmp (filename, "..");
  if (_10 == 0)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  // predicted unlikely by continue predictor.

  <bb 11> :
  i = i + 1;

  <bb 12> :
  dir_entries.3_11 = dir_entries;
  _12 = (long unsigned int) i;
  _13 = _12 * 8;
  _14 = dir_entries.3_11 + _13;
  _15 = *_14;
  if (_15 != 0B)
    goto <bb 8>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 13> :
  dir_entries.4_16 = dir_entries;
  free_sftp_dirents (dir_entries.4_16);
  D.3607 = 0;

  <bb 14> :
  dir_entries = {CLOBBER};
  return D.3607;

}


