
;; Function xrealloc (xrealloc, funcdef_no=26, decl_uid=3195, cgraph_uid=27, symbol_order=27)

Merging blocks 9 and 10
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9
;; 2 succs { 3 4 }
;; 3 succs { 4 }
;; 4 succs { 5 9 }
;; 5 succs { 6 7 }
;; 6 succs { 7 }
;; 7 succs { 8 9 }
;; 8 succs { }
;; 9 succs { 1 }
void * xrealloc (void * ptr, size_t size)
{
  void * ret;
  void * D.3255;

  <bb 2> :
  ret = realloc (ptr, size);
  _1 = ret == 0B;
  _2 = size == 0;
  _3 = _1 & _2;
  if (_3 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  ret = realloc (ptr, 1);

  <bb 4> :
  if (ret == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 5> :
  ret = realloc (ptr, size);
  _4 = ret == 0B;
  _5 = size == 0;
  _6 = _4 & _5;
  if (_6 != 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  ret = realloc (ptr, 1);

  <bb 7> :
  if (ret == 0B)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  printf ("Out of memory, realloc failed%s", "");
  exit (1);

  <bb 9> :
  D.3255 = ret;
  return D.3255;

}



;; Function find_bisection (find_bisection, funcdef_no=27, decl_uid=3202, cgraph_uid=28, symbol_order=28)

;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10
;;
;; Loop 1
;;  header 9, latch 8
;;  depth 1, outer 0
;;  nodes: 9 8 4 7 5 6 3
;; 2 succs { 9 }
;; 3 succs { 4 5 }
;; 4 succs { 8 }
;; 5 succs { 6 7 }
;; 6 succs { 7 }
;; 7 succs { 8 }
;; 8 succs { 9 }
;; 9 succs { 3 10 }
;; 10 succs { 1 }
void find_bisection (struct commit_list * * commit_list, int * reaches, int * all, int find_all)
{
  unsigned int flags;
  int * weights;
  struct commit_list * last;
  struct commit_list * next;
  struct commit_list * best;
  struct commit_list * p;
  struct commit_list * list;
  int on_list;
  int nr;

  <bb 2> :
  _1 = *commit_list;
  show_list ("bisection 2 entry", 0, 0, _1);
  on_list = 0;
  nr = on_list;
  last = 0B;
  p = *commit_list;
  goto <bb 9>; [INV]

  <bb 3> :
  _2 = p->item;
  _3 = _2->object.flags;
  flags = (unsigned int) _3;
  next = p->next;
  _4 = flags & 2;
  if (_4 != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  // predicted unlikely by continue predictor.
  goto <bb 8>; [INV]

  <bb 5> :
  p->next = last;
  last = p;
  _5 = flags & 4;
  if (_5 == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  nr = nr + 1;

  <bb 7> :
  on_list = on_list + 1;

  <bb 8> :
  p = next;

  <bb 9> :
  if (p != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 10> :
  list = last;
  show_list ("bisection 2 sorted", 0, nr, list);
  *all = nr;
  *commit_list = list;
  return;

}



;; Function commit_list_insert (commit_list_insert, funcdef_no=28, decl_uid=3221, cgraph_uid=29, symbol_order=29)

Merging blocks 2 and 3
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
struct commit_list * commit_list_insert (struct commit * item, struct commit_list * * list_p)
{
  struct commit_list * new_list;
  struct commit_list * D.3261;

  <bb 2> :
  new_list = malloc (16);
  new_list->item = item;
  _1 = *list_p;
  new_list->next = _1;
  *list_p = new_list;
  D.3261 = new_list;
  return D.3261;

}



;; Function pop_commit (pop_commit, funcdef_no=29, decl_uid=3225, cgraph_uid=30, symbol_order=30)

Merging blocks 7 and 8
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7
;; 2 succs { 3 4 }
;; 3 succs { 5 }
;; 4 succs { 5 }
;; 5 succs { 6 7 }
;; 6 succs { 7 }
;; 7 succs { 1 }
struct commit * pop_commit (struct commit_list * * stack)
{
  struct commit * item;
  struct commit_list * top;
  struct commit * D.3269;
  struct commit * iftmp.0;

  <bb 2> :
  top = *stack;
  if (top != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  iftmp.0 = top->item;
  goto <bb 5>; [INV]

  <bb 4> :
  iftmp.0 = 0B;

  <bb 5> :
  item = iftmp.0;
  if (top != 0B)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  _1 = top->next;
  *stack = _1;
  free (top);

  <bb 7> :
  D.3269 = item;
  return D.3269;

}



;; Function free_commit_list (free_commit_list, funcdef_no=30, decl_uid=3230, cgraph_uid=31, symbol_order=31)

;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5
;;
;; Loop 1
;;  header 4, latch 3
;;  depth 1, outer 0
;;  nodes: 4 3
;; 2 succs { 4 }
;; 3 succs { 4 }
;; 4 succs { 3 5 }
;; 5 succs { 1 }
void free_commit_list (struct commit_list * list)
{
  <bb 2> :
  goto <bb 4>; [INV]

  <bb 3> :
  pop_commit (&list);

  <bb 4> :
  list.1_1 = list;
  if (list.1_1 != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 5> :
  return;

}



;; Function main (main, funcdef_no=31, decl_uid=3235, cgraph_uid=32, symbol_order=32)

Removing basic block 7
Merging blocks 5 and 6
Merging blocks 5 and 8
;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5
;;
;; Loop 1
;;  header 4, latch 3
;;  depth 1, outer 0
;;  nodes: 4 3
;; 2 succs { 4 }
;; 3 succs { 4 }
;; 4 succs { 3 5 }
;; 5 succs { 1 }
int main ()
{
  int i;
  int find_all;
  int all;
  int reaches;
  struct commit_list * list;
  int D.3271;

  <bb 2> :
  i = 0;
  goto <bb 4>; [INV]

  <bb 3> :
  commit_list_insert (0B, &list);
  i = i + 1;

  <bb 4> :
  if (i <= 9)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 5> :
  find_bisection (&list, &reaches, &all, find_all);
  list.2_1 = list;
  free_commit_list (list.2_1);
  D.3271 = 0;
  list = {CLOBBER};
  reaches = {CLOBBER};
  all = {CLOBBER};
  return D.3271;

}


