
;; Function discard_cleanups (discard_cleanups, funcdef_no=22, decl_uid=3018, cgraph_uid=23, symbol_order=27)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
void discard_cleanups (struct cleanup * old_chain)
{
  <bb 2> :
  discard_my_cleanups (&cleanup_chain, old_chain);
  return;

}



;; Function discard_final_cleanups (discard_final_cleanups, funcdef_no=23, decl_uid=3023, cgraph_uid=24, symbol_order=28)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
void discard_final_cleanups (struct cleanup * old_chain)
{
  <bb 2> :
  discard_my_cleanups (&final_cleanup_chain, old_chain);
  return;

}



;; Function discard_my_cleanups (discard_my_cleanups, funcdef_no=24, decl_uid=3021, cgraph_uid=25, symbol_order=29)

;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7
;;
;; Loop 1
;;  header 6, latch 5
;;  depth 1, outer 0
;;  nodes: 6 5 3 4
;; 2 succs { 6 }
;; 3 succs { 4 5 }
;; 4 succs { 5 }
;; 5 succs { 6 }
;; 6 succs { 3 7 }
;; 7 succs { 1 }
void discard_my_cleanups (struct cleanup * * pmy_chain, struct cleanup * old_chain)
{
  struct cleanup * ptr;

  <bb 2> :
  goto <bb 6>; [INV]

  <bb 3> :
  _1 = ptr->next;
  *pmy_chain = _1;
  _2 = ptr->free_arg;
  if (_2 != 0B)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  _3 = ptr->free_arg;
  _4 = ptr->arg;
  _3 (_4);

  <bb 5> :
  free (ptr);

  <bb 6> :
  ptr = *pmy_chain;
  if (ptr != old_chain)
    goto <bb 3>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  _5 = ptr->arg;
  printf ("freearg: %x\n", _5);
  return;

}



;; Function do_cleanups (do_cleanups, funcdef_no=26, decl_uid=3028, cgraph_uid=27, symbol_order=31)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
void do_cleanups (struct cleanup * old_chain)
{
  <bb 2> :
  do_my_cleanups (&cleanup_chain, old_chain);
  return;

}



;; Function do_my_cleanups (do_my_cleanups, funcdef_no=25, decl_uid=3026, cgraph_uid=26, symbol_order=30)

;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7
;;
;; Loop 1
;;  header 6, latch 5
;;  depth 1, outer 0
;;  nodes: 6 5 3 4
;; 2 succs { 6 }
;; 3 succs { 4 5 }
;; 4 succs { 5 }
;; 5 succs { 6 }
;; 6 succs { 3 7 }
;; 7 succs { 1 }
void do_my_cleanups (struct cleanup * * pmy_chain, struct cleanup * old_chain)
{
  struct cleanup * ptr;

  <bb 2> :
  goto <bb 6>; [INV]

  <bb 3> :
  _1 = ptr->next;
  *pmy_chain = _1;
  _2 = ptr->function;
  _3 = ptr->arg;
  _2 (_3);
  __builtin_puts (&"cleanup!!!!! ========="[0]);
  _4 = ptr->arg;
  printf ("%x\n", _4);
  _5 = ptr->free_arg;
  if (_5 != 0B)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  _6 = ptr->free_arg;
  _7 = ptr->arg;
  _6 (_7);

  <bb 5> :
  free (ptr);

  <bb 6> :
  ptr = *pmy_chain;
  if (ptr != old_chain)
    goto <bb 3>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  return;

}



;; Function make_cleanup (make_cleanup, funcdef_no=29, decl_uid=3041, cgraph_uid=30, symbol_order=34)

Merging blocks 2 and 3
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
struct cleanup * make_cleanup (void (*<T59c>) (void *) function, void * arg)
{
  struct cleanup * D.3146;

  <bb 2> :
  D.3146 = make_my_cleanup (&cleanup_chain, function, arg);
  return D.3146;

}



;; Function make_my_cleanup (make_my_cleanup, funcdef_no=28, decl_uid=3038, cgraph_uid=29, symbol_order=33)

Merging blocks 2 and 3
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
struct cleanup * make_my_cleanup (struct cleanup * * pmy_chain, void (*<T59c>) (void *) function, void * arg)
{
  struct cleanup * D.3148;

  <bb 2> :
  D.3148 = make_my_cleanup2 (pmy_chain, function, arg, 0B);
  return D.3148;

}



;; Function make_my_cleanup2 (make_my_cleanup2, funcdef_no=27, decl_uid=3034, cgraph_uid=28, symbol_order=32)

Merging blocks 4 and 5
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4
;; 2 succs { 3 4 }
;; 3 succs { }
;; 4 succs { 1 }
struct cleanup * make_my_cleanup2 (struct cleanup * * pmy_chain, void (*<T59c>) (void *) function, void * arg, void (*<Tee>) (void *) free_arg)
{
  struct cleanup * old_chain;
  struct cleanup * new;
  struct cleanup * D.3152;

  <bb 2> :
  new = malloc (32);
  old_chain = *pmy_chain;
  _1 = *pmy_chain;
  new->next = _1;
  new->function = function;
  new->free_arg = free_arg;
  new->arg = arg;
  *pmy_chain = new;
  if (old_chain == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  exit (1);

  <bb 4> :
  D.3152 = old_chain;
  return D.3152;

}



;; Function main (main, funcdef_no=33, decl_uid=3135, cgraph_uid=34, symbol_order=38)

Merging blocks 2 and 3
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
int main ()
{
  struct line_info_table * table;
  time_t t;
  int D.3154;

  <bb 2> :
  _1 = time (&t);
  _2 = (unsigned int) _1;
  srand (_2);
  table = decode_line_info ();
  t = {CLOBBER};
  D.3154 = 0;
  return D.3154;

}



;; Function decode_line_info (decode_line_info, funcdef_no=32, decl_uid=3124, cgraph_uid=33, symbol_order=37)

;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18
;;
;; Loop 1
;;  header 10, multiple latches: 7 8
;;  depth 1, outer 0
;;  nodes: 10 7 8 5
;; 2 succs { 3 4 }
;; 3 succs { 18 }
;; 4 succs { 10 }
;; 5 succs { 6 7 }
;; 6 succs { 13 }
;; 7 succs { 8 10 }
;; 8 succs { 9 10 }
;; 9 succs { 13 }
;; 10 succs { 5 11 }
;; 11 succs { 12 13 }
;; 12 succs { 18 }
;; 13 succs { 14 15 }
;; 14 succs { 15 }
;; 15 succs { 16 17 }
;; 16 succs { 17 }
;; 17 succs { 1 }
;; 18 succs { 1 }
struct line_info_table * decode_line_info ()
{
  struct fileinfo * tmp;
  int end_sequence;
  int line;
  bfd_size_type amt;
  struct line_info_table * table;
  struct line_info_table * D.3158;

  <bb 2> :
  line = 0;
  amt = 32;
  _1 = (long unsigned int) amt;
  table = malloc (_1);
  if (table == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  D.3158 = 0B;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 18>; [INV]

  <bb 4> :
  table->num_files = 0;
  table->sequences = 0B;
  table->lcl_head = 0B;
  goto <bb 10>; [INV]

  <bb 5> :
  line = line + 1;
  _2 = rand ();
  _3 = _2 % 2;
  _4 = _3 == 1;
  end_sequence = (int) _4;
  line.0_5 = (unsigned int) line;
  _6 = add_line_info (table, line.0_5, end_sequence);
  if (_6 == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  // predicted unlikely by goto predictor.
  goto <bb 13>; [INV]

  <bb 7> :
  _7 = table->num_files;
  _8 = _7 % 5;
  if (_8 == 0)
    goto <bb 8>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 8> :
  _9 = table->num_files;
  amt = _9 + 5;
  amt = amt * 8;
  _10 = (long unsigned int) amt;
  _11 = table->files;
  tmp = realloc (_11, _10);
  if (tmp == 0B)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  // predicted unlikely by goto predictor.
  goto <bb 13>; [INV]

  <bb 10> :
  if (line <= 4)
    goto <bb 5>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 11> :
  _12 = sort_line_sequences (table);
  if (_12 != 0)
    goto <bb 12>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 12> :
  D.3158 = table;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 18>; [INV]

  <bb 13> :
fail:
  _13 = table->sequences;
  if (_13 != 0B)
    goto <bb 14>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 14> :
  _14 = table->sequences;
  free (_14);

  <bb 15> :
  _15 = table->files;
  if (_15 != 0B)
    goto <bb 16>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 16> :
  _16 = table->files;
  free (_16);

  <bb 17> :
  return;

  <bb 18> :
  return D.3158;

}



;; Function add_line_info (add_line_info, funcdef_no=30, decl_uid=3105, cgraph_uid=31, symbol_order=35)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17
;; 2 succs { 3 4 }
;; 3 succs { 17 }
;; 4 succs { 5 9 }
;; 5 succs { 6 9 }
;; 6 succs { 7 8 }
;; 7 succs { 8 }
;; 8 succs { 16 }
;; 9 succs { 11 10 }
;; 10 succs { 11 14 }
;; 11 succs { 12 13 }
;; 12 succs { 17 }
;; 13 succs { 16 }
;; 14 succs { 15 16 }
;; 15 succs { 16 }
;; 16 succs { 17 }
;; 17 succs { 1 }
bfd_boolean add_line_info (struct line_info_table * table, unsigned int line, int end_sequence)
{
  struct line_info * info;
  struct line_sequence * seq;
  bfd_size_type amt;
  bfd_boolean D.3174;

  <bb 2> :
  amt = 16;
  seq = table->sequences;
  _1 = (long unsigned int) amt;
  info = malloc (_1);
  if (info == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  D.3174 = 0;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 17>; [INV]

  <bb 4> :
  info->prev_line = 0B;
  info->line = line;
  _2 = (unsigned char) end_sequence;
  info->end_sequence = _2;
  if (seq != 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 5> :
  _3 = seq->last_line;
  _4 = _3->end_sequence;
  _5 = (int) _4;
  if (end_sequence == _5)
    goto <bb 6>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 6> :
  _6 = table->lcl_head;
  _7 = seq->last_line;
  if (_6 == _7)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  table->lcl_head = info;

  <bb 8> :
  _8 = seq->last_line;
  _9 = _8->prev_line;
  info->prev_line = _9;
  seq->last_line = info;
  goto <bb 16>; [INV]

  <bb 9> :
  if (seq == 0B)
    goto <bb 11>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 10> :
  _10 = seq->last_line;
  _11 = _10->end_sequence;
  if (_11 != 0)
    goto <bb 11>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 11> :
  amt = 16;
  _12 = (long unsigned int) amt;
  seq = malloc (_12);
  if (seq == 0B)
    goto <bb 12>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 12> :
  D.3174 = 0;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 17>; [INV]

  <bb 13> :
  _13 = table->sequences;
  seq->prev_sequence = _13;
  seq->last_line = info;
  table->lcl_head = info;
  table->sequences = seq;
  _14 = table->num_sequences;
  _15 = _14 + 1;
  table->num_sequences = _15;
  goto <bb 16>; [INV]

  <bb 14> :
  _16 = seq->last_line;
  info->prev_line = _16;
  seq->last_line = info;
  _17 = table->lcl_head;
  if (_17 == 0B)
    goto <bb 15>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 15> :
  table->lcl_head = info;

  <bb 16> :
  _18 = rand ();
  _19 = _18 % 2;
  _20 = _19 == 1;
  D.3174 = (bfd_boolean) _20;

  <bb 17> :
  return D.3174;

}



;; Function sort_line_sequences (sort_line_sequences, funcdef_no=31, decl_uid=3111, cgraph_uid=32, symbol_order=36)

;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14
;;
;; Loop 1
;;  header 10, latch 9
;;  depth 1, outer 0
;;  nodes: 10 9 7
;; 2 succs { 3 4 }
;; 3 succs { 14 }
;; 4 succs { 5 6 }
;; 5 succs { 14 }
;; 6 succs { 10 }
;; 7 succs { 8 9 }
;; 8 succs { }
;; 9 succs { 10 }
;; 10 succs { 7 11 }
;; 11 succs { 12 13 }
;; 12 succs { }
;; 13 succs { 14 }
;; 14 succs { 1 }
bfd_boolean sort_line_sequences (struct line_info_table * table)
{
  struct line_sequence * last_seq;
  unsigned int num_sequences;
  unsigned int n;
  struct line_sequence * seq;
  struct line_sequence * sequences;
  bfd_size_type amt;
  bfd_boolean D.3192;

  <bb 2> :
  n = 0;
  num_sequences = table->num_sequences;
  if (num_sequences == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  D.3192 = 1;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 14>; [INV]

  <bb 4> :
  amt = num_sequences * 16;
  _1 = (long unsigned int) amt;
  sequences = malloc (_1);
  if (sequences == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  D.3192 = 0;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 14>; [INV]

  <bb 6> :
  seq = table->sequences;
  n = 0;
  goto <bb 10>; [INV]

  <bb 7> :
  last_seq = seq;
  if (seq == 0B)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  exit (1);

  <bb 9> :
  _2 = (long unsigned int) n;
  _3 = _2 * 16;
  _4 = sequences + _3;
  _4->prev_sequence = 0B;
  _5 = (long unsigned int) n;
  _6 = _5 * 16;
  _7 = sequences + _6;
  _8 = seq->last_line;
  _7->last_line = _8;
  seq = seq->prev_sequence;
  free (last_seq);
  n = n + 1;

  <bb 10> :
  if (n < num_sequences)
    goto <bb 7>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 11> :
  if (seq == 0B)
    goto <bb 12>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 12> :
  exit (1);

  <bb 13> :
  table->sequences = sequences;
  table->num_sequences = num_sequences;
  D.3192 = 1;

  <bb 14> :
  return D.3192;

}


