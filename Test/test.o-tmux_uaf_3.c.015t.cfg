
;; Function session_cmp (session_cmp, funcdef_no=22, decl_uid=4103, cgraph_uid=23, symbol_order=22)

Merging blocks 2 and 3
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
int session_cmp (struct session * s1, struct session * s2)
{
  int D.4498;

  <bb 2> :
  _1 = s2->name;
  _2 = s1->name;
  D.4498 = strcmp (_2, _1);
  return D.4498;

}



;; Function sessions_RB_INSERT_COLOR (sessions_RB_INSERT_COLOR, funcdef_no=23, decl_uid=4108, cgraph_uid=24, symbol_order=23)

Removing basic block 14
Merging blocks 16 and 17
Removing basic block 24
Merging blocks 26 and 27
Removing basic block 38
Merging blocks 40 and 41
Removing basic block 48
;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46
;;
;; Loop 1
;;  header 44, multiple latches: 6 23 26 43
;;  depth 1, outer 0
;;  nodes: 44 6 23 26 43 41 42 40 39 38 36 37 27 35 33 34 32 31 30 28 29 24 25 3 45 21 22 20 19 18 16 17 7 15 13 14 12 11 10 8 9 4 5
;; 2 succs { 44 }
;; 3 succs { 4 24 }
;; 4 succs { 5 7 }
;; 5 succs { 6 7 }
;; 6 succs { 44 }
;; 7 succs { 8 16 }
;; 8 succs { 9 10 }
;; 9 succs { 10 }
;; 10 succs { 11 14 }
;; 11 succs { 12 13 }
;; 12 succs { 15 }
;; 13 succs { 15 }
;; 14 succs { 15 }
;; 15 succs { 16 }
;; 16 succs { 17 18 }
;; 17 succs { 18 }
;; 18 succs { 19 22 }
;; 19 succs { 20 21 }
;; 20 succs { 23 }
;; 21 succs { 23 }
;; 22 succs { 23 }
;; 23 succs { 44 }
;; 24 succs { 25 27 }
;; 25 succs { 26 27 }
;; 26 succs { 44 }
;; 27 succs { 28 36 }
;; 28 succs { 29 30 }
;; 29 succs { 30 }
;; 30 succs { 31 34 }
;; 31 succs { 32 33 }
;; 32 succs { 35 }
;; 33 succs { 35 }
;; 34 succs { 35 }
;; 35 succs { 36 }
;; 36 succs { 37 38 }
;; 37 succs { 38 }
;; 38 succs { 39 42 }
;; 39 succs { 40 41 }
;; 40 succs { 43 }
;; 41 succs { 43 }
;; 42 succs { 43 }
;; 43 succs { 44 }
;; 44 succs { 45 46 }
;; 45 succs { 3 46 }
;; 46 succs { 1 }
void sessions_RB_INSERT_COLOR (struct sessions * head, struct session * elm)
{
  struct session * tmp;
  struct session * gparent;
  struct session * parent;

  <bb 2> :
  goto <bb 44>; [INV]

  <bb 3> :
  gparent = parent->entry.rbe_parent;
  _1 = gparent->entry.rbe_left;
  if (parent == _1)
    goto <bb 4>; [INV]
  else
    goto <bb 24>; [INV]

  <bb 4> :
  tmp = gparent->entry.rbe_right;
  if (tmp != 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 5> :
  _2 = tmp->entry.rbe_color;
  if (_2 == 1)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  tmp->entry.rbe_color = 0;
  parent->entry.rbe_color = 0;
  gparent->entry.rbe_color = 1;
  elm = gparent;
  // predicted unlikely by continue predictor.
  goto <bb 44>; [INV]

  <bb 7> :
  _3 = parent->entry.rbe_right;
  if (elm == _3)
    goto <bb 8>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 8> :
  tmp = parent->entry.rbe_right;
  _4 = tmp->entry.rbe_left;
  parent->entry.rbe_right = _4;
  _5 = parent->entry.rbe_right;
  if (_5 != 0B)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  _6 = tmp->entry.rbe_left;
  _6->entry.rbe_parent = parent;

  <bb 10> :
  _7 = parent->entry.rbe_parent;
  tmp->entry.rbe_parent = _7;
  _8 = tmp->entry.rbe_parent;
  if (_8 != 0B)
    goto <bb 11>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 11> :
  _9 = parent->entry.rbe_parent;
  _10 = _9->entry.rbe_left;
  if (parent == _10)
    goto <bb 12>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 12> :
  _11 = parent->entry.rbe_parent;
  _11->entry.rbe_left = tmp;
  goto <bb 15>; [INV]

  <bb 13> :
  _12 = parent->entry.rbe_parent;
  _12->entry.rbe_right = tmp;
  goto <bb 15>; [INV]

  <bb 14> :
  head->rbh_root = tmp;

  <bb 15> :
  tmp->entry.rbe_left = parent;
  parent->entry.rbe_parent = tmp;
  _13 = tmp->entry.rbe_parent;
  tmp = parent;
  parent = elm;
  elm = tmp;

  <bb 16> :
  parent->entry.rbe_color = 0;
  gparent->entry.rbe_color = 1;
  tmp = gparent->entry.rbe_left;
  _14 = tmp->entry.rbe_right;
  gparent->entry.rbe_left = _14;
  _15 = gparent->entry.rbe_left;
  if (_15 != 0B)
    goto <bb 17>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 17> :
  _16 = tmp->entry.rbe_right;
  _16->entry.rbe_parent = gparent;

  <bb 18> :
  _17 = gparent->entry.rbe_parent;
  tmp->entry.rbe_parent = _17;
  _18 = tmp->entry.rbe_parent;
  if (_18 != 0B)
    goto <bb 19>; [INV]
  else
    goto <bb 22>; [INV]

  <bb 19> :
  _19 = gparent->entry.rbe_parent;
  _20 = _19->entry.rbe_left;
  if (gparent == _20)
    goto <bb 20>; [INV]
  else
    goto <bb 21>; [INV]

  <bb 20> :
  _21 = gparent->entry.rbe_parent;
  _21->entry.rbe_left = tmp;
  goto <bb 23>; [INV]

  <bb 21> :
  _22 = gparent->entry.rbe_parent;
  _22->entry.rbe_right = tmp;
  goto <bb 23>; [INV]

  <bb 22> :
  head->rbh_root = tmp;

  <bb 23> :
  tmp->entry.rbe_right = gparent;
  gparent->entry.rbe_parent = tmp;
  _23 = tmp->entry.rbe_parent;
  goto <bb 44>; [INV]

  <bb 24> :
  tmp = gparent->entry.rbe_left;
  if (tmp != 0B)
    goto <bb 25>; [INV]
  else
    goto <bb 27>; [INV]

  <bb 25> :
  _24 = tmp->entry.rbe_color;
  if (_24 == 1)
    goto <bb 26>; [INV]
  else
    goto <bb 27>; [INV]

  <bb 26> :
  tmp->entry.rbe_color = 0;
  parent->entry.rbe_color = 0;
  gparent->entry.rbe_color = 1;
  elm = gparent;
  // predicted unlikely by continue predictor.
  goto <bb 44>; [INV]

  <bb 27> :
  _25 = parent->entry.rbe_left;
  if (elm == _25)
    goto <bb 28>; [INV]
  else
    goto <bb 36>; [INV]

  <bb 28> :
  tmp = parent->entry.rbe_left;
  _26 = tmp->entry.rbe_right;
  parent->entry.rbe_left = _26;
  _27 = parent->entry.rbe_left;
  if (_27 != 0B)
    goto <bb 29>; [INV]
  else
    goto <bb 30>; [INV]

  <bb 29> :
  _28 = tmp->entry.rbe_right;
  _28->entry.rbe_parent = parent;

  <bb 30> :
  _29 = parent->entry.rbe_parent;
  tmp->entry.rbe_parent = _29;
  _30 = tmp->entry.rbe_parent;
  if (_30 != 0B)
    goto <bb 31>; [INV]
  else
    goto <bb 34>; [INV]

  <bb 31> :
  _31 = parent->entry.rbe_parent;
  _32 = _31->entry.rbe_left;
  if (parent == _32)
    goto <bb 32>; [INV]
  else
    goto <bb 33>; [INV]

  <bb 32> :
  _33 = parent->entry.rbe_parent;
  _33->entry.rbe_left = tmp;
  goto <bb 35>; [INV]

  <bb 33> :
  _34 = parent->entry.rbe_parent;
  _34->entry.rbe_right = tmp;
  goto <bb 35>; [INV]

  <bb 34> :
  head->rbh_root = tmp;

  <bb 35> :
  tmp->entry.rbe_right = parent;
  parent->entry.rbe_parent = tmp;
  _35 = tmp->entry.rbe_parent;
  tmp = parent;
  parent = elm;
  elm = tmp;

  <bb 36> :
  parent->entry.rbe_color = 0;
  gparent->entry.rbe_color = 1;
  tmp = gparent->entry.rbe_right;
  _36 = tmp->entry.rbe_left;
  gparent->entry.rbe_right = _36;
  _37 = gparent->entry.rbe_right;
  if (_37 != 0B)
    goto <bb 37>; [INV]
  else
    goto <bb 38>; [INV]

  <bb 37> :
  _38 = tmp->entry.rbe_left;
  _38->entry.rbe_parent = gparent;

  <bb 38> :
  _39 = gparent->entry.rbe_parent;
  tmp->entry.rbe_parent = _39;
  _40 = tmp->entry.rbe_parent;
  if (_40 != 0B)
    goto <bb 39>; [INV]
  else
    goto <bb 42>; [INV]

  <bb 39> :
  _41 = gparent->entry.rbe_parent;
  _42 = _41->entry.rbe_left;
  if (gparent == _42)
    goto <bb 40>; [INV]
  else
    goto <bb 41>; [INV]

  <bb 40> :
  _43 = gparent->entry.rbe_parent;
  _43->entry.rbe_left = tmp;
  goto <bb 43>; [INV]

  <bb 41> :
  _44 = gparent->entry.rbe_parent;
  _44->entry.rbe_right = tmp;
  goto <bb 43>; [INV]

  <bb 42> :
  head->rbh_root = tmp;

  <bb 43> :
  tmp->entry.rbe_left = gparent;
  gparent->entry.rbe_parent = tmp;
  _45 = tmp->entry.rbe_parent;

  <bb 44> :
  parent = elm->entry.rbe_parent;
  if (parent != 0B)
    goto <bb 45>; [INV]
  else
    goto <bb 46>; [INV]

  <bb 45> :
  _46 = parent->entry.rbe_color;
  if (_46 == 1)
    goto <bb 3>; [INV]
  else
    goto <bb 46>; [INV]

  <bb 46> :
  _47 = head->rbh_root;
  _47->entry.rbe_color = 0;
  return;

}



;; Function sessions_RB_REMOVE_COLOR (sessions_RB_REMOVE_COLOR, funcdef_no=24, decl_uid=4159, cgraph_uid=25, symbol_order=24)

Removing basic block 11
Merging blocks 13 and 14
Merging blocks 19 and 46
Removing basic block 30
Merging blocks 32 and 33
Removing basic block 42
Merging blocks 44 and 45
Removing basic block 54
Merging blocks 56 and 57
Removing basic block 73
Merging blocks 75 and 76
Removing basic block 85
Merging blocks 87 and 88
;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81
;;
;; Loop 1
;;  header 76, multiple latches: 17 53
;;  depth 1, outer 0
;;  nodes: 76 17 53 51 52 49 50 40 48 46 47 45 44 43 41 42 3 78 77 15 16 13 14 4 12 10 11 9 8 7 5 6
;; 2 succs { 76 }
;; 3 succs { 4 40 }
;; 4 succs { 5 13 }
;; 5 succs { 6 7 }
;; 6 succs { 7 }
;; 7 succs { 8 11 }
;; 8 succs { 9 10 }
;; 9 succs { 12 }
;; 10 succs { 12 }
;; 11 succs { 12 }
;; 12 succs { 13 }
;; 13 succs { 15 14 }
;; 14 succs { 15 18 }
;; 15 succs { 17 16 }
;; 16 succs { 17 18 }
;; 17 succs { 76 }
;; 18 succs { 20 19 }
;; 19 succs { 20 30 }
;; 20 succs { 21 22 }
;; 21 succs { 22 }
;; 22 succs { 23 24 }
;; 23 succs { 24 }
;; 24 succs { 25 28 }
;; 25 succs { 26 27 }
;; 26 succs { 29 }
;; 27 succs { 29 }
;; 28 succs { 29 }
;; 29 succs { 30 }
;; 30 succs { 31 32 }
;; 31 succs { 32 }
;; 32 succs { 33 34 }
;; 33 succs { 34 }
;; 34 succs { 35 38 }
;; 35 succs { 36 37 }
;; 36 succs { 39 }
;; 37 succs { 39 }
;; 38 succs { 39 }
;; 39 succs { 79 }
;; 40 succs { 41 49 }
;; 41 succs { 42 43 }
;; 42 succs { 43 }
;; 43 succs { 44 47 }
;; 44 succs { 45 46 }
;; 45 succs { 48 }
;; 46 succs { 48 }
;; 47 succs { 48 }
;; 48 succs { 49 }
;; 49 succs { 51 50 }
;; 50 succs { 51 54 }
;; 51 succs { 53 52 }
;; 52 succs { 53 54 }
;; 53 succs { 76 }
;; 54 succs { 56 55 }
;; 55 succs { 56 66 }
;; 56 succs { 57 58 }
;; 57 succs { 58 }
;; 58 succs { 59 60 }
;; 59 succs { 60 }
;; 60 succs { 61 64 }
;; 61 succs { 62 63 }
;; 62 succs { 65 }
;; 63 succs { 65 }
;; 64 succs { 65 }
;; 65 succs { 66 }
;; 66 succs { 67 68 }
;; 67 succs { 68 }
;; 68 succs { 69 70 }
;; 69 succs { 70 }
;; 70 succs { 71 74 }
;; 71 succs { 72 73 }
;; 72 succs { 75 }
;; 73 succs { 75 }
;; 74 succs { 75 }
;; 75 succs { 79 }
;; 76 succs { 78 77 }
;; 77 succs { 78 79 }
;; 78 succs { 3 79 }
;; 79 succs { 80 81 }
;; 80 succs { 81 }
;; 81 succs { 1 }
void sessions_RB_REMOVE_COLOR (struct sessions * head, struct session * parent, struct session * elm)
{
  struct session * oright;
  struct session * oleft;
  struct session * tmp;

  <bb 2> :
  goto <bb 76>; [INV]

  <bb 3> :
  _1 = parent->entry.rbe_left;
  if (elm == _1)
    goto <bb 4>; [INV]
  else
    goto <bb 40>; [INV]

  <bb 4> :
  tmp = parent->entry.rbe_right;
  _2 = tmp->entry.rbe_color;
  if (_2 == 1)
    goto <bb 5>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 5> :
  tmp->entry.rbe_color = 0;
  parent->entry.rbe_color = 1;
  tmp = parent->entry.rbe_right;
  _3 = tmp->entry.rbe_left;
  parent->entry.rbe_right = _3;
  _4 = parent->entry.rbe_right;
  if (_4 != 0B)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  _5 = tmp->entry.rbe_left;
  _5->entry.rbe_parent = parent;

  <bb 7> :
  _6 = parent->entry.rbe_parent;
  tmp->entry.rbe_parent = _6;
  _7 = tmp->entry.rbe_parent;
  if (_7 != 0B)
    goto <bb 8>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 8> :
  _8 = parent->entry.rbe_parent;
  _9 = _8->entry.rbe_left;
  if (parent == _9)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  _10 = parent->entry.rbe_parent;
  _10->entry.rbe_left = tmp;
  goto <bb 12>; [INV]

  <bb 10> :
  _11 = parent->entry.rbe_parent;
  _11->entry.rbe_right = tmp;
  goto <bb 12>; [INV]

  <bb 11> :
  head->rbh_root = tmp;

  <bb 12> :
  tmp->entry.rbe_left = parent;
  parent->entry.rbe_parent = tmp;
  _12 = tmp->entry.rbe_parent;
  tmp = parent->entry.rbe_right;

  <bb 13> :
  _13 = tmp->entry.rbe_left;
  if (_13 == 0B)
    goto <bb 15>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 14> :
  _14 = tmp->entry.rbe_left;
  _15 = _14->entry.rbe_color;
  if (_15 == 0)
    goto <bb 15>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 15> :
  _16 = tmp->entry.rbe_right;
  if (_16 == 0B)
    goto <bb 17>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 16> :
  _17 = tmp->entry.rbe_right;
  _18 = _17->entry.rbe_color;
  if (_18 == 0)
    goto <bb 17>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 17> :
  tmp->entry.rbe_color = 1;
  elm = parent;
  parent = elm->entry.rbe_parent;
  goto <bb 76>; [INV]

  <bb 18> :
  _19 = tmp->entry.rbe_right;
  if (_19 == 0B)
    goto <bb 20>; [INV]
  else
    goto <bb 19>; [INV]

  <bb 19> :
  _20 = tmp->entry.rbe_right;
  _21 = _20->entry.rbe_color;
  if (_21 == 0)
    goto <bb 20>; [INV]
  else
    goto <bb 30>; [INV]

  <bb 20> :
  oleft = tmp->entry.rbe_left;
  if (oleft != 0B)
    goto <bb 21>; [INV]
  else
    goto <bb 22>; [INV]

  <bb 21> :
  oleft->entry.rbe_color = 0;

  <bb 22> :
  tmp->entry.rbe_color = 1;
  oleft = tmp->entry.rbe_left;
  _22 = oleft->entry.rbe_right;
  tmp->entry.rbe_left = _22;
  _23 = tmp->entry.rbe_left;
  if (_23 != 0B)
    goto <bb 23>; [INV]
  else
    goto <bb 24>; [INV]

  <bb 23> :
  _24 = oleft->entry.rbe_right;
  _24->entry.rbe_parent = tmp;

  <bb 24> :
  _25 = tmp->entry.rbe_parent;
  oleft->entry.rbe_parent = _25;
  _26 = oleft->entry.rbe_parent;
  if (_26 != 0B)
    goto <bb 25>; [INV]
  else
    goto <bb 28>; [INV]

  <bb 25> :
  _27 = tmp->entry.rbe_parent;
  _28 = _27->entry.rbe_left;
  if (tmp == _28)
    goto <bb 26>; [INV]
  else
    goto <bb 27>; [INV]

  <bb 26> :
  _29 = tmp->entry.rbe_parent;
  _29->entry.rbe_left = oleft;
  goto <bb 29>; [INV]

  <bb 27> :
  _30 = tmp->entry.rbe_parent;
  _30->entry.rbe_right = oleft;
  goto <bb 29>; [INV]

  <bb 28> :
  head->rbh_root = oleft;

  <bb 29> :
  oleft->entry.rbe_right = tmp;
  tmp->entry.rbe_parent = oleft;
  _31 = oleft->entry.rbe_parent;
  tmp = parent->entry.rbe_right;

  <bb 30> :
  _32 = parent->entry.rbe_color;
  tmp->entry.rbe_color = _32;
  parent->entry.rbe_color = 0;
  _33 = tmp->entry.rbe_right;
  if (_33 != 0B)
    goto <bb 31>; [INV]
  else
    goto <bb 32>; [INV]

  <bb 31> :
  _34 = tmp->entry.rbe_right;
  _34->entry.rbe_color = 0;

  <bb 32> :
  tmp = parent->entry.rbe_right;
  _35 = tmp->entry.rbe_left;
  parent->entry.rbe_right = _35;
  _36 = parent->entry.rbe_right;
  if (_36 != 0B)
    goto <bb 33>; [INV]
  else
    goto <bb 34>; [INV]

  <bb 33> :
  _37 = tmp->entry.rbe_left;
  _37->entry.rbe_parent = parent;

  <bb 34> :
  _38 = parent->entry.rbe_parent;
  tmp->entry.rbe_parent = _38;
  _39 = tmp->entry.rbe_parent;
  if (_39 != 0B)
    goto <bb 35>; [INV]
  else
    goto <bb 38>; [INV]

  <bb 35> :
  _40 = parent->entry.rbe_parent;
  _41 = _40->entry.rbe_left;
  if (parent == _41)
    goto <bb 36>; [INV]
  else
    goto <bb 37>; [INV]

  <bb 36> :
  _42 = parent->entry.rbe_parent;
  _42->entry.rbe_left = tmp;
  goto <bb 39>; [INV]

  <bb 37> :
  _43 = parent->entry.rbe_parent;
  _43->entry.rbe_right = tmp;
  goto <bb 39>; [INV]

  <bb 38> :
  head->rbh_root = tmp;

  <bb 39> :
  tmp->entry.rbe_left = parent;
  parent->entry.rbe_parent = tmp;
  _44 = tmp->entry.rbe_parent;
  elm = head->rbh_root;
  goto <bb 79>; [INV]

  <bb 40> :
  tmp = parent->entry.rbe_left;
  _45 = tmp->entry.rbe_color;
  if (_45 == 1)
    goto <bb 41>; [INV]
  else
    goto <bb 49>; [INV]

  <bb 41> :
  tmp->entry.rbe_color = 0;
  parent->entry.rbe_color = 1;
  tmp = parent->entry.rbe_left;
  _46 = tmp->entry.rbe_right;
  parent->entry.rbe_left = _46;
  _47 = parent->entry.rbe_left;
  if (_47 != 0B)
    goto <bb 42>; [INV]
  else
    goto <bb 43>; [INV]

  <bb 42> :
  _48 = tmp->entry.rbe_right;
  _48->entry.rbe_parent = parent;

  <bb 43> :
  _49 = parent->entry.rbe_parent;
  tmp->entry.rbe_parent = _49;
  _50 = tmp->entry.rbe_parent;
  if (_50 != 0B)
    goto <bb 44>; [INV]
  else
    goto <bb 47>; [INV]

  <bb 44> :
  _51 = parent->entry.rbe_parent;
  _52 = _51->entry.rbe_left;
  if (parent == _52)
    goto <bb 45>; [INV]
  else
    goto <bb 46>; [INV]

  <bb 45> :
  _53 = parent->entry.rbe_parent;
  _53->entry.rbe_left = tmp;
  goto <bb 48>; [INV]

  <bb 46> :
  _54 = parent->entry.rbe_parent;
  _54->entry.rbe_right = tmp;
  goto <bb 48>; [INV]

  <bb 47> :
  head->rbh_root = tmp;

  <bb 48> :
  tmp->entry.rbe_right = parent;
  parent->entry.rbe_parent = tmp;
  _55 = tmp->entry.rbe_parent;
  tmp = parent->entry.rbe_left;

  <bb 49> :
  _56 = tmp->entry.rbe_left;
  if (_56 == 0B)
    goto <bb 51>; [INV]
  else
    goto <bb 50>; [INV]

  <bb 50> :
  _57 = tmp->entry.rbe_left;
  _58 = _57->entry.rbe_color;
  if (_58 == 0)
    goto <bb 51>; [INV]
  else
    goto <bb 54>; [INV]

  <bb 51> :
  _59 = tmp->entry.rbe_right;
  if (_59 == 0B)
    goto <bb 53>; [INV]
  else
    goto <bb 52>; [INV]

  <bb 52> :
  _60 = tmp->entry.rbe_right;
  _61 = _60->entry.rbe_color;
  if (_61 == 0)
    goto <bb 53>; [INV]
  else
    goto <bb 54>; [INV]

  <bb 53> :
  tmp->entry.rbe_color = 1;
  elm = parent;
  parent = elm->entry.rbe_parent;
  goto <bb 76>; [INV]

  <bb 54> :
  _62 = tmp->entry.rbe_left;
  if (_62 == 0B)
    goto <bb 56>; [INV]
  else
    goto <bb 55>; [INV]

  <bb 55> :
  _63 = tmp->entry.rbe_left;
  _64 = _63->entry.rbe_color;
  if (_64 == 0)
    goto <bb 56>; [INV]
  else
    goto <bb 66>; [INV]

  <bb 56> :
  oright = tmp->entry.rbe_right;
  if (oright != 0B)
    goto <bb 57>; [INV]
  else
    goto <bb 58>; [INV]

  <bb 57> :
  oright->entry.rbe_color = 0;

  <bb 58> :
  tmp->entry.rbe_color = 1;
  oright = tmp->entry.rbe_right;
  _65 = oright->entry.rbe_left;
  tmp->entry.rbe_right = _65;
  _66 = tmp->entry.rbe_right;
  if (_66 != 0B)
    goto <bb 59>; [INV]
  else
    goto <bb 60>; [INV]

  <bb 59> :
  _67 = oright->entry.rbe_left;
  _67->entry.rbe_parent = tmp;

  <bb 60> :
  _68 = tmp->entry.rbe_parent;
  oright->entry.rbe_parent = _68;
  _69 = oright->entry.rbe_parent;
  if (_69 != 0B)
    goto <bb 61>; [INV]
  else
    goto <bb 64>; [INV]

  <bb 61> :
  _70 = tmp->entry.rbe_parent;
  _71 = _70->entry.rbe_left;
  if (tmp == _71)
    goto <bb 62>; [INV]
  else
    goto <bb 63>; [INV]

  <bb 62> :
  _72 = tmp->entry.rbe_parent;
  _72->entry.rbe_left = oright;
  goto <bb 65>; [INV]

  <bb 63> :
  _73 = tmp->entry.rbe_parent;
  _73->entry.rbe_right = oright;
  goto <bb 65>; [INV]

  <bb 64> :
  head->rbh_root = oright;

  <bb 65> :
  oright->entry.rbe_left = tmp;
  tmp->entry.rbe_parent = oright;
  _74 = oright->entry.rbe_parent;
  tmp = parent->entry.rbe_left;

  <bb 66> :
  _75 = parent->entry.rbe_color;
  tmp->entry.rbe_color = _75;
  parent->entry.rbe_color = 0;
  _76 = tmp->entry.rbe_left;
  if (_76 != 0B)
    goto <bb 67>; [INV]
  else
    goto <bb 68>; [INV]

  <bb 67> :
  _77 = tmp->entry.rbe_left;
  _77->entry.rbe_color = 0;

  <bb 68> :
  tmp = parent->entry.rbe_left;
  _78 = tmp->entry.rbe_right;
  parent->entry.rbe_left = _78;
  _79 = parent->entry.rbe_left;
  if (_79 != 0B)
    goto <bb 69>; [INV]
  else
    goto <bb 70>; [INV]

  <bb 69> :
  _80 = tmp->entry.rbe_right;
  _80->entry.rbe_parent = parent;

  <bb 70> :
  _81 = parent->entry.rbe_parent;
  tmp->entry.rbe_parent = _81;
  _82 = tmp->entry.rbe_parent;
  if (_82 != 0B)
    goto <bb 71>; [INV]
  else
    goto <bb 74>; [INV]

  <bb 71> :
  _83 = parent->entry.rbe_parent;
  _84 = _83->entry.rbe_left;
  if (parent == _84)
    goto <bb 72>; [INV]
  else
    goto <bb 73>; [INV]

  <bb 72> :
  _85 = parent->entry.rbe_parent;
  _85->entry.rbe_left = tmp;
  goto <bb 75>; [INV]

  <bb 73> :
  _86 = parent->entry.rbe_parent;
  _86->entry.rbe_right = tmp;
  goto <bb 75>; [INV]

  <bb 74> :
  head->rbh_root = tmp;

  <bb 75> :
  tmp->entry.rbe_right = parent;
  parent->entry.rbe_parent = tmp;
  _87 = tmp->entry.rbe_parent;
  elm = head->rbh_root;
  goto <bb 79>; [INV]

  <bb 76> :
  if (elm == 0B)
    goto <bb 78>; [INV]
  else
    goto <bb 77>; [INV]

  <bb 77> :
  _88 = elm->entry.rbe_color;
  if (_88 == 0)
    goto <bb 78>; [INV]
  else
    goto <bb 79>; [INV]

  <bb 78> :
  _89 = head->rbh_root;
  if (elm != _89)
    goto <bb 3>; [INV]
  else
    goto <bb 79>; [INV]

  <bb 79> :
  if (elm != 0B)
    goto <bb 80>; [INV]
  else
    goto <bb 81>; [INV]

  <bb 80> :
  elm->entry.rbe_color = 0;

  <bb 81> :
  return;

}



;; Function sessions_RB_INSERT (sessions_RB_INSERT, funcdef_no=25, decl_uid=4221, cgraph_uid=26, symbol_order=25)

Removing basic block 13
;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
;;
;; Loop 1
;;  header 8, multiple latches: 4 6
;;  depth 1, outer 0
;;  nodes: 8 4 6 5 3
;; 2 succs { 8 }
;; 3 succs { 4 5 }
;; 4 succs { 8 }
;; 5 succs { 6 7 }
;; 6 succs { 8 }
;; 7 succs { 15 }
;; 8 succs { 3 9 }
;; 9 succs { 10 13 }
;; 10 succs { 11 12 }
;; 11 succs { 14 }
;; 12 succs { 14 }
;; 13 succs { 14 }
;; 14 succs { 15 }
;; 15 succs { 1 }
struct session * sessions_RB_INSERT (struct sessions * head, struct session * elm)
{
  int comp;
  struct session * parent;
  struct session * tmp;
  struct session * D.4659;

  <bb 2> :
  parent = 0B;
  comp = 0;
  tmp = head->rbh_root;
  goto <bb 8>; [INV]

  <bb 3> :
  parent = tmp;
  comp = session_cmp (elm, parent);
  if (comp < 0)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  tmp = tmp->entry.rbe_left;
  goto <bb 8>; [INV]

  <bb 5> :
  if (comp > 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  tmp = tmp->entry.rbe_right;
  goto <bb 8>; [INV]

  <bb 7> :
  D.4659 = tmp;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 15>; [INV]

  <bb 8> :
  if (tmp != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 9> :
  elm->entry.rbe_parent = parent;
  elm->entry.rbe_right = 0B;
  _1 = elm->entry.rbe_right;
  elm->entry.rbe_left = _1;
  elm->entry.rbe_color = 1;
  if (parent != 0B)
    goto <bb 10>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 10> :
  if (comp < 0)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  parent->entry.rbe_left = elm;
  goto <bb 14>; [INV]

  <bb 12> :
  parent->entry.rbe_right = elm;
  goto <bb 14>; [INV]

  <bb 13> :
  head->rbh_root = elm;

  <bb 14> :
  sessions_RB_INSERT_COLOR (head, elm);
  D.4659 = 0B;

  <bb 15> :
  return D.4659;

}



;; Function sessions_RB_REMOVE (sessions_RB_REMOVE, funcdef_no=26, decl_uid=4235, cgraph_uid=27, symbol_order=26)

Removing basic block 15
Removing basic block 23
Removing basic block 37
Merging blocks 41 and 42
;; 3 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38
;;
;; Loop 2
;;  header 27, latch 27
;;  depth 1, outer 0
;;  nodes: 27
;;
;; Loop 1
;;  header 8, latch 7
;;  depth 1, outer 0
;;  nodes: 8 7
;; 2 succs { 3 4 }
;; 3 succs { 29 }
;; 4 succs { 5 6 }
;; 5 succs { 29 }
;; 6 succs { 8 }
;; 7 succs { 8 }
;; 8 succs { 7 9 }
;; 9 succs { 10 11 }
;; 10 succs { 11 }
;; 11 succs { 12 15 }
;; 12 succs { 13 14 }
;; 13 succs { 16 }
;; 14 succs { 16 }
;; 15 succs { 16 }
;; 16 succs { 17 18 }
;; 17 succs { 18 }
;; 18 succs { 19 22 }
;; 19 succs { 20 21 }
;; 20 succs { 23 }
;; 21 succs { 23 }
;; 22 succs { 23 }
;; 23 succs { 24 25 }
;; 24 succs { 25 }
;; 25 succs { 26 28 }
;; 26 succs { 27 }
;; 27 succs { 27 28 }
;; 28 succs { 36 }
;; 29 succs { 30 31 }
;; 30 succs { 31 }
;; 31 succs { 32 35 }
;; 32 succs { 33 34 }
;; 33 succs { 36 }
;; 34 succs { 36 }
;; 35 succs { 36 }
;; 36 succs { 37 38 }
;; 37 succs { 38 }
;; 38 succs { 1 }
struct session * sessions_RB_REMOVE (struct sessions * head, struct session * elm)
{
  struct session * left;
  int color;
  struct session * old;
  struct session * parent;
  struct session * child;
  struct session * D.4703;

  <bb 2> :
  old = elm;
  _1 = elm->entry.rbe_left;
  if (_1 == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  child = elm->entry.rbe_right;
  goto <bb 29>; [INV]

  <bb 4> :
  _2 = elm->entry.rbe_right;
  if (_2 == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  child = elm->entry.rbe_left;
  goto <bb 29>; [INV]

  <bb 6> :
  elm = elm->entry.rbe_right;
  goto <bb 8>; [INV]

  <bb 7> :
  elm = left;

  <bb 8> :
  left = elm->entry.rbe_left;
  if (left != 0B)
    goto <bb 7>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 9> :
  child = elm->entry.rbe_right;
  parent = elm->entry.rbe_parent;
  color = elm->entry.rbe_color;
  if (child != 0B)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  child->entry.rbe_parent = parent;

  <bb 11> :
  if (parent != 0B)
    goto <bb 12>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 12> :
  _3 = parent->entry.rbe_left;
  if (elm == _3)
    goto <bb 13>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 13> :
  parent->entry.rbe_left = child;
  goto <bb 16>; [INV]

  <bb 14> :
  parent->entry.rbe_right = child;
  goto <bb 16>; [INV]

  <bb 15> :
  head->rbh_root = child;

  <bb 16> :
  _4 = elm->entry.rbe_parent;
  if (old == _4)
    goto <bb 17>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 17> :
  parent = elm;

  <bb 18> :
  elm->entry = old->entry;
  _5 = old->entry.rbe_parent;
  if (_5 != 0B)
    goto <bb 19>; [INV]
  else
    goto <bb 22>; [INV]

  <bb 19> :
  _6 = old->entry.rbe_parent;
  _7 = _6->entry.rbe_left;
  if (old == _7)
    goto <bb 20>; [INV]
  else
    goto <bb 21>; [INV]

  <bb 20> :
  _8 = old->entry.rbe_parent;
  _8->entry.rbe_left = elm;
  goto <bb 23>; [INV]

  <bb 21> :
  _9 = old->entry.rbe_parent;
  _9->entry.rbe_right = elm;
  goto <bb 23>; [INV]

  <bb 22> :
  head->rbh_root = elm;

  <bb 23> :
  _10 = old->entry.rbe_left;
  _10->entry.rbe_parent = elm;
  _11 = old->entry.rbe_right;
  if (_11 != 0B)
    goto <bb 24>; [INV]
  else
    goto <bb 25>; [INV]

  <bb 24> :
  _12 = old->entry.rbe_right;
  _12->entry.rbe_parent = elm;

  <bb 25> :
  if (parent != 0B)
    goto <bb 26>; [INV]
  else
    goto <bb 28>; [INV]

  <bb 26> :
  left = parent;

  <bb 27> :
  left = left->entry.rbe_parent;
  if (left != 0B)
    goto <bb 27>; [INV]
  else
    goto <bb 28>; [INV]

  <bb 28> :
  // predicted unlikely by goto predictor.
  goto <bb 36>; [INV]

  <bb 29> :
  parent = elm->entry.rbe_parent;
  color = elm->entry.rbe_color;
  if (child != 0B)
    goto <bb 30>; [INV]
  else
    goto <bb 31>; [INV]

  <bb 30> :
  child->entry.rbe_parent = parent;

  <bb 31> :
  if (parent != 0B)
    goto <bb 32>; [INV]
  else
    goto <bb 35>; [INV]

  <bb 32> :
  _13 = parent->entry.rbe_left;
  if (elm == _13)
    goto <bb 33>; [INV]
  else
    goto <bb 34>; [INV]

  <bb 33> :
  parent->entry.rbe_left = child;
  goto <bb 36>; [INV]

  <bb 34> :
  parent->entry.rbe_right = child;
  goto <bb 36>; [INV]

  <bb 35> :
  head->rbh_root = child;

  <bb 36> :
color:
  if (color == 0)
    goto <bb 37>; [INV]
  else
    goto <bb 38>; [INV]

  <bb 37> :
  sessions_RB_REMOVE_COLOR (head, parent, child);

  <bb 38> :
  D.4703 = old;
  return D.4703;

}



;; Function sessions_RB_FIND (sessions_RB_FIND, funcdef_no=27, decl_uid=4259, cgraph_uid=28, symbol_order=27)

;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10
;;
;; Loop 1
;;  header 8, multiple latches: 4 6
;;  depth 1, outer 0
;;  nodes: 8 4 6 5 3
;; 2 succs { 8 }
;; 3 succs { 4 5 }
;; 4 succs { 8 }
;; 5 succs { 6 7 }
;; 6 succs { 8 }
;; 7 succs { 10 }
;; 8 succs { 3 9 }
;; 9 succs { 10 }
;; 10 succs { 1 }
struct session * sessions_RB_FIND (struct sessions * head, struct session * elm)
{
  int comp;
  struct session * tmp;
  struct session * D.4711;

  <bb 2> :
  tmp = head->rbh_root;
  goto <bb 8>; [INV]

  <bb 3> :
  comp = session_cmp (elm, tmp);
  if (comp < 0)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  tmp = tmp->entry.rbe_left;
  goto <bb 8>; [INV]

  <bb 5> :
  if (comp > 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  tmp = tmp->entry.rbe_right;
  goto <bb 8>; [INV]

  <bb 7> :
  D.4711 = tmp;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 10>; [INV]

  <bb 8> :
  if (tmp != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 9> :
  D.4711 = 0B;

  <bb 10> :
  return D.4711;

}



;; Function sessions_RB_NFIND (sessions_RB_NFIND, funcdef_no=28, decl_uid=4268, cgraph_uid=29, symbol_order=28)

;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10
;;
;; Loop 1
;;  header 8, multiple latches: 4 6
;;  depth 1, outer 0
;;  nodes: 8 4 6 5 3
;; 2 succs { 8 }
;; 3 succs { 4 5 }
;; 4 succs { 8 }
;; 5 succs { 6 7 }
;; 6 succs { 8 }
;; 7 succs { 10 }
;; 8 succs { 3 9 }
;; 9 succs { 10 }
;; 10 succs { 1 }
struct session * sessions_RB_NFIND (struct sessions * head, struct session * elm)
{
  int comp;
  struct session * res;
  struct session * tmp;
  struct session * D.4719;

  <bb 2> :
  tmp = head->rbh_root;
  res = 0B;
  goto <bb 8>; [INV]

  <bb 3> :
  comp = session_cmp (elm, tmp);
  if (comp < 0)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  res = tmp;
  tmp = tmp->entry.rbe_left;
  goto <bb 8>; [INV]

  <bb 5> :
  if (comp > 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  tmp = tmp->entry.rbe_right;
  goto <bb 8>; [INV]

  <bb 7> :
  D.4719 = tmp;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 10>; [INV]

  <bb 8> :
  if (tmp != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 9> :
  D.4719 = res;

  <bb 10> :
  return D.4719;

}



;; Function sessions_RB_NEXT (sessions_RB_NEXT, funcdef_no=29, decl_uid=4277, cgraph_uid=30, symbol_order=29)

Removing basic block 6
Removing basic block 10
Merging blocks 15 and 16
;; 3 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13
;;
;; Loop 2
;;  header 5, latch 4
;;  depth 1, outer 0
;;  nodes: 5 4
;;
;; Loop 1
;;  header 10, latch 9
;;  depth 1, outer 0
;;  nodes: 10 9 11
;; 2 succs { 3 6 }
;; 3 succs { 5 }
;; 4 succs { 5 }
;; 5 succs { 4 13 }
;; 6 succs { 7 10 }
;; 7 succs { 8 10 }
;; 8 succs { 13 }
;; 9 succs { 10 }
;; 10 succs { 11 12 }
;; 11 succs { 9 12 }
;; 12 succs { 13 }
;; 13 succs { 1 }
struct session * sessions_RB_NEXT (struct session * elm)
{
  struct session * D.4729;

  <bb 2> :
  _1 = elm->entry.rbe_right;
  if (_1 != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 3> :
  elm = elm->entry.rbe_right;
  goto <bb 5>; [INV]

  <bb 4> :
  elm = elm->entry.rbe_left;

  <bb 5> :
  _2 = elm->entry.rbe_left;
  if (_2 != 0B)
    goto <bb 4>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 6> :
  _3 = elm->entry.rbe_parent;
  if (_3 != 0B)
    goto <bb 7>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 7> :
  _4 = elm->entry.rbe_parent;
  _5 = _4->entry.rbe_left;
  if (elm == _5)
    goto <bb 8>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 8> :
  elm = elm->entry.rbe_parent;
  goto <bb 13>; [INV]

  <bb 9> :
  elm = elm->entry.rbe_parent;

  <bb 10> :
  _6 = elm->entry.rbe_parent;
  if (_6 != 0B)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  _7 = elm->entry.rbe_parent;
  _8 = _7->entry.rbe_right;
  if (elm == _8)
    goto <bb 9>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 12> :
  elm = elm->entry.rbe_parent;

  <bb 13> :
  D.4729 = elm;
  return D.4729;

}



;; Function sessions_RB_PREV (sessions_RB_PREV, funcdef_no=30, decl_uid=4286, cgraph_uid=31, symbol_order=30)

Removing basic block 6
Removing basic block 10
Merging blocks 15 and 16
;; 3 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13
;;
;; Loop 2
;;  header 5, latch 4
;;  depth 1, outer 0
;;  nodes: 5 4
;;
;; Loop 1
;;  header 10, latch 9
;;  depth 1, outer 0
;;  nodes: 10 9 11
;; 2 succs { 3 6 }
;; 3 succs { 5 }
;; 4 succs { 5 }
;; 5 succs { 4 13 }
;; 6 succs { 7 10 }
;; 7 succs { 8 10 }
;; 8 succs { 13 }
;; 9 succs { 10 }
;; 10 succs { 11 12 }
;; 11 succs { 9 12 }
;; 12 succs { 13 }
;; 13 succs { 1 }
struct session * sessions_RB_PREV (struct session * elm)
{
  struct session * D.4739;

  <bb 2> :
  _1 = elm->entry.rbe_left;
  if (_1 != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 3> :
  elm = elm->entry.rbe_left;
  goto <bb 5>; [INV]

  <bb 4> :
  elm = elm->entry.rbe_right;

  <bb 5> :
  _2 = elm->entry.rbe_right;
  if (_2 != 0B)
    goto <bb 4>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 6> :
  _3 = elm->entry.rbe_parent;
  if (_3 != 0B)
    goto <bb 7>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 7> :
  _4 = elm->entry.rbe_parent;
  _5 = _4->entry.rbe_right;
  if (elm == _5)
    goto <bb 8>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 8> :
  elm = elm->entry.rbe_parent;
  goto <bb 13>; [INV]

  <bb 9> :
  elm = elm->entry.rbe_parent;

  <bb 10> :
  _6 = elm->entry.rbe_parent;
  if (_6 != 0B)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  _7 = elm->entry.rbe_parent;
  _8 = _7->entry.rbe_left;
  if (elm == _8)
    goto <bb 9>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 12> :
  elm = elm->entry.rbe_parent;

  <bb 13> :
  D.4739 = elm;
  return D.4739;

}



;; Function sessions_RB_MINMAX (sessions_RB_MINMAX, funcdef_no=31, decl_uid=4296, cgraph_uid=32, symbol_order=31)

Merging blocks 7 and 8
;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7
;;
;; Loop 1
;;  header 6, multiple latches: 4 5
;;  depth 1, outer 0
;;  nodes: 6 4 5 3
;; 2 succs { 6 }
;; 3 succs { 4 5 }
;; 4 succs { 6 }
;; 5 succs { 6 }
;; 6 succs { 3 7 }
;; 7 succs { 1 }
struct session * sessions_RB_MINMAX (struct sessions * head, int val)
{
  struct session * parent;
  struct session * tmp;
  struct session * D.4744;

  <bb 2> :
  tmp = head->rbh_root;
  parent = 0B;
  goto <bb 6>; [INV]

  <bb 3> :
  parent = tmp;
  if (val < 0)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  tmp = tmp->entry.rbe_left;
  goto <bb 6>; [INV]

  <bb 5> :
  tmp = tmp->entry.rbe_right;

  <bb 6> :
  if (tmp != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  D.4744 = parent;
  return D.4744;

}



;; Function xrealloc (xrealloc, funcdef_no=32, decl_uid=4307, cgraph_uid=33, symbol_order=33)

Merging blocks 8 and 9
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8
;; 2 succs { 3 4 }
;; 3 succs { }
;; 4 succs { 5 6 }
;; 5 succs { }
;; 6 succs { 7 8 }
;; 7 succs { }
;; 8 succs { 1 }
void * xrealloc (void * oldptr, size_t nmemb, size_t size)
{
  void * newptr;
  size_t newsize;
  void * D.4752;

  <bb 2> :
  newsize = nmemb * size;
  if (newsize == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  printf ("zero size%s", "");
  exit (1);

  <bb 4> :
  _1 = 1073741824 / nmemb;
  if (size > _1)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  printf ("nmemb * size > SIZE_MAX%s", "");
  exit (1);

  <bb 6> :
  newptr = realloc (oldptr, newsize);
  if (newptr == 0B)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  printf ("xrealloc failed%s", "");
  exit (1);

  <bb 8> :
  D.4752 = newptr;
  return D.4752;

}



;; Function window_choose_add (window_choose_add, funcdef_no=33, decl_uid=4313, cgraph_uid=34, symbol_order=34)

Removing basic block 8
;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10
;;
;; Loop 1
;;  header 9, latch 8
;;  depth 1, outer 0
;;  nodes: 9 8
;; 2 succs { 3 4 }
;; 3 succs { }
;; 4 succs { 5 6 }
;; 5 succs { }
;; 6 succs { 7 9 }
;; 7 succs { 9 }
;; 8 succs { 9 }
;; 9 succs { 8 10 }
;; 10 succs { 1 }
void window_choose_add (struct window_pane * wp, struct window_choose_data * wcd)
{
  char tmp[10];
  struct window_choose_mode_item * item;
  struct window_choose_mode_data * data;

  <bb 2> :
  data = wp->modedata;
  _1 = data->list.num;
  if (_1 > 1073741823)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  printf ("number too big%s", "");
  exit (1);

  <bb 4> :
  _2 = data->list.num;
  _3 = _2 + 1;
  _4 = 1073741824 / _3;
  if (_4 <= 23)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  printf ("size too big%s", "");
  exit (1);

  <bb 6> :
  _5 = data->list.space;
  if (_5 == 0)
    goto <bb 7>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 7> :
  data->list.space = 240;
  _6 = data->list.space;
  _7 = data->list.list;
  _8 = xrealloc (_7, 1, _6);
  data->list.list = _8;
  goto <bb 9>; [INV]

  <bb 8> :
  _9 = data->list.space;
  _10 = data->list.list;
  _11 = xrealloc (_10, 2, _9);
  data->list.list = _11;
  _12 = data->list.space;
  _13 = _12 * 2;
  data->list.space = _13;

  <bb 9> :
  _14 = data->list.space;
  _15 = data->list.num;
  _16 = _15 + 1;
  _17 = (long unsigned int) _16;
  _18 = _17 * 24;
  if (_14 <= _18)
    goto <bb 8>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 10> :
  _19 = data->list.num;
  _20 = _19 + 1;
  data->list.num = _20;
  _21 = data->list.list;
  _22 = data->list.num;
  _23 = _22 + 4294967295;
  _24 = (long unsigned int) _23;
  _25 = _24 * 24;
  item = _21 + _25;
  _26 = malloc (10);
  item->name = _26;
  item->wcd = wcd;
  _27 = data->list.num;
  _28 = _27 + 4294967295;
  _29 = (int) _28;
  item->pos = _29;
  item->state = 0;
  tmp = {CLOBBER};
  return;

}



;; Function window_choose_init (window_choose_init, funcdef_no=34, decl_uid=4027, cgraph_uid=35, symbol_order=35)

Merging blocks 2 and 3
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
struct screen * window_choose_init (struct window_pane * wp)
{
  int keys;
  struct screen * s;
  struct window_choose_mode_data * data;
  struct screen * D.4760;

  <bb 2> :
  data = malloc (232);
  wp->modedata = data;
  data->callbackfn = 0B;
  data->freefn = 0B;
  data->input_type = -1;
  _1 = strdup ("");
  data->input_str = _1;
  data->input_prompt = 0B;
  data->list.num = 0;
  data->list.list = 0B;
  data->list.space = 0;
  data->old_list.num = 0;
  data->old_list.list = 0B;
  data->old_list.space = 0;
  data->top = 0;
  s = &data->screen;
  _2 = s->mode;
  _3 = _2 & -2;
  s->mode = _3;
  D.4760 = s;
  return D.4760;

}



;; Function window_choose_data_create (window_choose_data_create, funcdef_no=35, decl_uid=4337, cgraph_uid=36, symbol_order=36)

Merging blocks 2 and 3
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
struct window_choose_data * window_choose_data_create (struct cmd_ctx * ctx)
{
  struct window_choose_data * wcd;
  struct window_choose_data * D.4762;

  <bb 2> :
  wcd = malloc (80);
  wcd->command = 0B;
  wcd->wl = 0B;
  wcd->tree_session = 0B;
  _1 = ctx->curclient;
  _2 = _1->session;
  wcd->session = _2;
  wcd->idx = 4294967295;
  wcd->type = 0;
  D.4762 = wcd;
  return D.4762;

}



;; Function window_choose_free (window_choose_free, funcdef_no=36, decl_uid=4029, cgraph_uid=37, symbol_order=37)

;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8
;;
;; Loop 1
;;  header 7, latch 6
;;  depth 1, outer 0
;;  nodes: 7 6 3 4 5
;; 2 succs { 7 }
;; 3 succs { 4 6 }
;; 4 succs { 5 6 }
;; 5 succs { 6 }
;; 6 succs { 7 }
;; 7 succs { 3 8 }
;; 8 succs { 1 }
void window_choose_free (struct window_pane * wp)
{
  u_int i;
  struct window_choose_mode_item * item;
  struct window_choose_mode_data * data;

  <bb 2> :
  data = wp->modedata;
  i = 0;
  goto <bb 7>; [INV]

  <bb 3> :
  _1 = data->list.list;
  _2 = (long unsigned int) i;
  _3 = _2 * 24;
  item = _1 + _3;
  _4 = data->freefn;
  if (_4 != 0B)
    goto <bb 4>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 4> :
  _5 = item->wcd;
  if (_5 != 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  _6 = data->freefn;
  _7 = item->wcd;
  _6 (_7);

  <bb 6> :
  _8 = item->name;
  free (_8);
  i = i + 1;

  <bb 7> :
  _9 = data->list.num;
  if (i < _9)
    goto <bb 3>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 8> :
  _10 = data->list.list;
  free (_10);
  data->list.num = 0;
  data->list.list = 0B;
  data->list.space = 0;
  _11 = data->old_list.list;
  free (_11);
  data->old_list.num = 0;
  data->old_list.list = 0B;
  data->old_list.space = 0;
  _12 = data->input_str;
  free (_12);
  free (data);
  return;

}



;; Function window_choose_collapse (window_choose_collapse, funcdef_no=37, decl_uid=4051, cgraph_uid=38, symbol_order=38)

Removing basic block 11
Removing basic block 15
Removing basic block 22
Removing basic block 35
;; 5 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35
;;
;; Loop 2
;;  header 33, latch 32
;;  depth 1, outer 0
;;  nodes: 33 32
;;
;; Loop 1
;;  header 24, latch 23
;;  depth 1, outer 0
;;  nodes: 24 23 13 22 4 3 21 19 20 18 16 14 12 10 11 9 7 5
;;
;; Loop 4
;;  header 12, latch 11
;;  depth 2, outer 1
;;  nodes: 12 11
;;
;; Loop 3
;;  header 21, latch 20
;;  depth 2, outer 1
;;  nodes: 21 20
;; 2 succs { 24 }
;; 3 succs { 4 14 }
;; 4 succs { 5 23 }
;; 5 succs { 6 7 }
;; 6 succs { }
;; 7 succs { 8 9 }
;; 8 succs { }
;; 9 succs { 10 12 }
;; 10 succs { 12 }
;; 11 succs { 12 }
;; 12 succs { 11 13 }
;; 13 succs { 23 }
;; 14 succs { 15 16 }
;; 15 succs { }
;; 16 succs { 17 18 }
;; 17 succs { }
;; 18 succs { 19 21 }
;; 19 succs { 21 }
;; 20 succs { 21 }
;; 21 succs { 20 22 }
;; 22 succs { 23 }
;; 23 succs { 24 }
;; 24 succs { 3 25 }
;; 25 succs { 26 35 }
;; 26 succs { 27 28 }
;; 27 succs { }
;; 28 succs { 29 30 }
;; 29 succs { }
;; 30 succs { 31 33 }
;; 31 succs { 33 }
;; 32 succs { 33 }
;; 33 succs { 32 34 }
;; 34 succs { 35 }
;; 35 succs { 1 }
void window_choose_collapse (struct window_pane * wp, struct session * s)
{
  struct 
  {
    struct window_choose_mode_item * list;
    u_int num;
    size_t space;
  } list_copy;
  u_int pos;
  u_int i;
  struct window_choose_data * wcd;
  struct window_choose_mode_item * chosen;
  struct window_choose_mode_item * item;
  struct window_choose_mode_data * data;

  <bb 2> :
  data = wp->modedata;
  list_copy.num = 0;
  list_copy.list = 0B;
  list_copy.space = 0;
  pos = data->selected;
  _1 = data->list.list;
  _2 = (long unsigned int) pos;
  _3 = _2 * 24;
  chosen = _1 + _3;
  _4 = chosen->state;
  _5 = _4 & -2;
  chosen->state = _5;
  i = 0;
  goto <bb 24>; [INV]

  <bb 3> :
  _6 = data->list.list;
  _7 = (long unsigned int) i;
  _8 = _7 * 24;
  item = _6 + _8;
  wcd = item->wcd;
  _9 = wcd->tree_session;
  if (s == _9)
    goto <bb 4>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 4> :
  _10 = wcd->type;
  _11 = _10 & 2;
  if (_11 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 23>; [INV]

  <bb 5> :
  _12 = item->state;
  _13 = _12 & -2;
  item->state = _13;
  _14 = list_copy.num;
  if (_14 > 1073741823)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  printf ("number too big%s", "");
  exit (1);

  <bb 7> :
  _15 = list_copy.num;
  _16 = _15 + 1;
  _17 = 1073741824 / _16;
  if (_17 <= 23)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  printf ("size too big%s", "");
  exit (1);

  <bb 9> :
  _18 = list_copy.space;
  if (_18 == 0)
    goto <bb 10>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 10> :
  list_copy.space = 240;
  _19 = list_copy.space;
  _20 = list_copy.list;
  _21 = xrealloc (_20, 1, _19);
  list_copy.list = _21;
  goto <bb 12>; [INV]

  <bb 11> :
  _22 = list_copy.space;
  _23 = list_copy.list;
  _24 = xrealloc (_23, 2, _22);
  list_copy.list = _24;
  _25 = list_copy.space;
  _26 = _25 * 2;
  list_copy.space = _26;

  <bb 12> :
  _27 = list_copy.space;
  _28 = list_copy.num;
  _29 = _28 + 1;
  _30 = (long unsigned int) _29;
  _31 = _30 * 24;
  if (_27 <= _31)
    goto <bb 11>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 13> :
  _32 = data->list.list;
  _33 = (long unsigned int) i;
  _34 = _33 * 24;
  _35 = _32 + _34;
  _36 = list_copy.list;
  _37 = list_copy.num;
  _38 = (long unsigned int) _37;
  _39 = _38 * 24;
  _40 = _36 + _39;
  *_40 = *_35;
  _41 = list_copy.num;
  _42 = _41 + 1;
  list_copy.num = _42;
  data->selected = i;
  goto <bb 23>; [INV]

  <bb 14> :
  _43 = list_copy.num;
  if (_43 > 1073741823)
    goto <bb 15>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 15> :
  printf ("number too big%s", "");
  exit (1);

  <bb 16> :
  _44 = list_copy.num;
  _45 = _44 + 1;
  _46 = 1073741824 / _45;
  if (_46 <= 23)
    goto <bb 17>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 17> :
  printf ("size too big%s", "");
  exit (1);

  <bb 18> :
  _47 = list_copy.space;
  if (_47 == 0)
    goto <bb 19>; [INV]
  else
    goto <bb 21>; [INV]

  <bb 19> :
  list_copy.space = 240;
  _48 = list_copy.space;
  _49 = list_copy.list;
  _50 = xrealloc (_49, 1, _48);
  list_copy.list = _50;
  goto <bb 21>; [INV]

  <bb 20> :
  _51 = list_copy.space;
  _52 = list_copy.list;
  _53 = xrealloc (_52, 2, _51);
  list_copy.list = _53;
  _54 = list_copy.space;
  _55 = _54 * 2;
  list_copy.space = _55;

  <bb 21> :
  _56 = list_copy.space;
  _57 = list_copy.num;
  _58 = _57 + 1;
  _59 = (long unsigned int) _58;
  _60 = _59 * 24;
  if (_56 <= _60)
    goto <bb 20>; [INV]
  else
    goto <bb 22>; [INV]

  <bb 22> :
  _61 = data->list.list;
  _62 = (long unsigned int) i;
  _63 = _62 * 24;
  _64 = _61 + _63;
  _65 = list_copy.list;
  _66 = list_copy.num;
  _67 = (long unsigned int) _66;
  _68 = _67 * 24;
  _69 = _65 + _68;
  *_69 = *_64;
  _70 = list_copy.num;
  _71 = _70 + 1;
  list_copy.num = _71;

  <bb 23> :
  i = i + 1;

  <bb 24> :
  _72 = data->list.num;
  if (i < _72)
    goto <bb 3>; [INV]
  else
    goto <bb 25>; [INV]

  <bb 25> :
  _73 = list_copy.num;
  if (_73 != 0)
    goto <bb 26>; [INV]
  else
    goto <bb 35>; [INV]

  <bb 26> :
  _74 = data->list.list;
  free (_74);
  data->list.num = 0;
  data->list.list = 0B;
  data->list.space = 0;
  _75 = list_copy.num;
  _76 = 1073741824 - _75;
  _77 = data->list.num;
  if (_76 < _77)
    goto <bb 27>; [INV]
  else
    goto <bb 28>; [INV]

  <bb 27> :
  printf ("number too big%s", "");
  exit (1);

  <bb 28> :
  _78 = data->list.num;
  _79 = list_copy.num;
  _80 = _78 + _79;
  _81 = 1073741824 / _80;
  if (_81 <= 23)
    goto <bb 29>; [INV]
  else
    goto <bb 30>; [INV]

  <bb 29> :
  printf ("size too big%s", "");
  exit (1);

  <bb 30> :
  _82 = data->list.space;
  if (_82 == 0)
    goto <bb 31>; [INV]
  else
    goto <bb 33>; [INV]

  <bb 31> :
  data->list.space = 240;
  _83 = data->list.space;
  _84 = data->list.list;
  _85 = xrealloc (_84, 1, _83);
  data->list.list = _85;
  goto <bb 33>; [INV]

  <bb 32> :
  _86 = data->list.space;
  _87 = data->list.list;
  _88 = xrealloc (_87, 2, _86);
  data->list.list = _88;
  _89 = data->list.space;
  _90 = _89 * 2;
  data->list.space = _90;

  <bb 33> :
  _91 = data->list.space;
  _92 = data->list.num;
  _93 = list_copy.num;
  _94 = _92 + _93;
  _95 = (long unsigned int) _94;
  _96 = _95 * 24;
  if (_91 <= _96)
    goto <bb 32>; [INV]
  else
    goto <bb 34>; [INV]

  <bb 34> :
  _97 = list_copy.num;
  _98 = (long unsigned int) _97;
  _99 = _98 * 24;
  _100 = list_copy.list;
  _101 = data->list.list;
  _102 = data->list.num;
  _103 = (long unsigned int) _102;
  _104 = _103 * 24;
  _105 = _101 + _104;
  memcpy (_105, _100, _99);
  _106 = data->list.num;
  _107 = list_copy.num;
  _108 = _106 + _107;
  data->list.num = _108;

  <bb 35> :
  list_copy = {CLOBBER};
  return;

}



;; Function window_choose_collapse_all (window_choose_collapse_all, funcdef_no=38, decl_uid=4057, cgraph_uid=39, symbol_order=39)

;; 3 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12
;;
;; Loop 2
;;  header 11, latch 10
;;  depth 1, outer 0
;;  nodes: 11 10 7 8 9 6
;;
;; Loop 1
;;  header 4, latch 3
;;  depth 1, outer 0
;;  nodes: 4 3
;; 2 succs { 4 }
;; 3 succs { 4 }
;; 4 succs { 3 5 }
;; 5 succs { 11 }
;; 6 succs { 7 8 }
;; 7 succs { 10 }
;; 8 succs { 9 10 }
;; 9 succs { 10 }
;; 10 succs { 11 }
;; 11 succs { 6 12 }
;; 12 succs { 1 }
void window_choose_collapse_all (struct window_pane * wp)
{
  u_int i;
  struct session * s;
  struct window_choose_mode_item * chosen;
  struct window_choose_mode_item * item;
  struct window_choose_mode_data * data;

  <bb 2> :
  data = wp->modedata;
  _1 = data->list.list;
  _2 = data->selected;
  _3 = (long unsigned int) _2;
  _4 = _3 * 24;
  chosen = _1 + _4;
  s = sessions_RB_MINMAX (&sessions, -1);
  goto <bb 4>; [INV]

  <bb 3> :
  window_choose_collapse (wp, s);
  s = sessions_RB_NEXT (s);

  <bb 4> :
  if (s != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 5> :
  i = 0;
  goto <bb 11>; [INV]

  <bb 6> :
  _5 = data->list.list;
  _6 = (long unsigned int) i;
  _7 = _6 * 24;
  item = _5 + _7;
  _8 = chosen->wcd;
  _9 = _8->session;
  _10 = item->wcd;
  _11 = _10->tree_session;
  if (_9 != _11)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  // predicted unlikely by continue predictor.
  goto <bb 10>; [INV]

  <bb 8> :
  _12 = item->wcd;
  _13 = _12->type;
  _14 = _13 & 2;
  if (_14 != 0)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  data->selected = i;

  <bb 10> :
  i = i + 1;

  <bb 11> :
  _15 = data->list.num;
  if (i < _15)
    goto <bb 6>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 12> :
  return;

}



;; Function window_choose_expand_all (window_choose_expand_all, funcdef_no=39, decl_uid=4059, cgraph_uid=40, symbol_order=40)

;; 3 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12
;;
;; Loop 1
;;  header 11, latch 10
;;  depth 1, outer 0
;;  nodes: 11 10 9 3 8 5 6 7 4
;;
;; Loop 2
;;  header 9, latch 8
;;  depth 2, outer 1
;;  nodes: 9 8 5 6 7 4
;; 2 succs { 11 }
;; 3 succs { 9 }
;; 4 succs { 5 6 }
;; 5 succs { 8 }
;; 6 succs { 7 8 }
;; 7 succs { 8 }
;; 8 succs { 9 }
;; 9 succs { 4 10 }
;; 10 succs { 11 }
;; 11 succs { 3 12 }
;; 12 succs { 1 }
void window_choose_expand_all (struct window_pane * wp)
{
  u_int i;
  struct session * s;
  struct window_choose_mode_item * item;
  struct window_choose_mode_data * data;

  <bb 2> :
  data = wp->modedata;
  s = sessions_RB_MINMAX (&sessions, -1);
  goto <bb 11>; [INV]

  <bb 3> :
  i = 0;
  goto <bb 9>; [INV]

  <bb 4> :
  _1 = data->list.list;
  _2 = (long unsigned int) i;
  _3 = _2 * 24;
  item = _1 + _3;
  _4 = item->wcd;
  _5 = _4->tree_session;
  if (s != _5)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  // predicted unlikely by continue predictor.
  goto <bb 8>; [INV]

  <bb 6> :
  _6 = item->wcd;
  _7 = _6->type;
  _8 = _7 & 2;
  if (_8 != 0)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  window_choose_expand (wp, s, i);

  <bb 8> :
  i = i + 1;

  <bb 9> :
  _9 = data->list.num;
  if (i < _9)
    goto <bb 4>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 10> :
  s = sessions_RB_NEXT (s);

  <bb 11> :
  if (s != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 12> :
  return;

}



;; Function window_choose_expand (window_choose_expand, funcdef_no=40, decl_uid=4055, cgraph_uid=41, symbol_order=41)

Removing basic block 16
Removing basic block 28
;; 4 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32
;;
;; Loop 1
;;  header 31, latch 30
;;  depth 1, outer 0
;;  nodes: 31 30 7 8 20 29 28 26 27 25 23 21 9 18 19 17 15 16 14 12 10
;;
;; Loop 3
;;  header 17, latch 16
;;  depth 2, outer 1
;;  nodes: 17 16
;;
;; Loop 2
;;  header 28, latch 27
;;  depth 2, outer 1
;;  nodes: 28 27
;; 2 succs { 3 4 }
;; 3 succs { 32 }
;; 4 succs { 5 6 }
;; 5 succs { 32 }
;; 6 succs { 31 }
;; 7 succs { 8 30 }
;; 8 succs { 9 30 }
;; 9 succs { 10 21 }
;; 10 succs { 11 12 }
;; 11 succs { }
;; 12 succs { 13 14 }
;; 13 succs { }
;; 14 succs { 15 17 }
;; 15 succs { 17 }
;; 16 succs { 17 }
;; 17 succs { 16 18 }
;; 18 succs { 19 20 }
;; 19 succs { 20 }
;; 20 succs { 30 }
;; 21 succs { 22 23 }
;; 22 succs { }
;; 23 succs { 24 25 }
;; 24 succs { }
;; 25 succs { 26 28 }
;; 26 succs { 28 }
;; 27 succs { 28 }
;; 28 succs { 27 29 }
;; 29 succs { 30 }
;; 30 succs { 31 }
;; 31 succs { 7 32 }
;; 32 succs { 1 }
void window_choose_expand (struct window_pane * wp, struct session * s, u_int pos)
{
  u_int items;
  u_int i;
  struct window_choose_data * wcd;
  struct window_choose_mode_item * chosen;
  struct window_choose_mode_item * item;
  struct window_choose_mode_data * data;

  <bb 2> :
  data = wp->modedata;
  _1 = data->list.list;
  _2 = (long unsigned int) pos;
  _3 = _2 * 24;
  chosen = _1 + _3;
  _4 = data->old_list.num;
  items = _4 + 4294967295;
  _5 = chosen->wcd;
  _6 = _5->type;
  _7 = _6 & 2;
  if (_7 == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 32>; [INV]

  <bb 4> :
  _8 = chosen->state;
  _9 = _8 & 1;
  if (_9 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 32>; [INV]

  <bb 6> :
  _10 = chosen->state;
  _11 = _10 | 1;
  chosen->state = _11;
  i = items;
  goto <bb 31>; [INV]

  <bb 7> :
  _12 = data->old_list.list;
  _13 = (long unsigned int) i;
  _14 = _13 * 24;
  item = _12 + _14;
  _15 = item->state;
  _16 = _15 | 1;
  item->state = _16;
  wcd = item->wcd;
  _17 = wcd->tree_session;
  if (s == _17)
    goto <bb 8>; [INV]
  else
    goto <bb 30>; [INV]

  <bb 8> :
  _18 = wcd->type;
  _19 = _18 & 1;
  if (_19 != 0)
    goto <bb 9>; [INV]
  else
    goto <bb 30>; [INV]

  <bb 9> :
  if (pos < i)
    goto <bb 10>; [INV]
  else
    goto <bb 21>; [INV]

  <bb 10> :
  _20 = data->list.num;
  if (_20 > 1073741823)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  printf ("number too big%s", "");
  exit (1);

  <bb 12> :
  _21 = data->list.num;
  _22 = _21 + 1;
  _23 = 1073741824 / _22;
  if (_23 <= 23)
    goto <bb 13>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 13> :
  printf ("size too big%s", "");
  exit (1);

  <bb 14> :
  _24 = data->list.space;
  if (_24 == 0)
    goto <bb 15>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 15> :
  data->list.space = 240;
  _25 = data->list.space;
  _26 = data->list.list;
  _27 = xrealloc (_26, 1, _25);
  data->list.list = _27;
  goto <bb 17>; [INV]

  <bb 16> :
  _28 = data->list.space;
  _29 = data->list.list;
  _30 = xrealloc (_29, 2, _28);
  data->list.list = _30;
  _31 = data->list.space;
  _32 = _31 * 2;
  data->list.space = _32;

  <bb 17> :
  _33 = data->list.space;
  _34 = data->list.num;
  _35 = _34 + 1;
  _36 = (long unsigned int) _35;
  _37 = _36 * 24;
  if (_33 <= _37)
    goto <bb 16>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 18> :
  _38 = pos + 1;
  _39 = data->list.num;
  if (_38 < _39)
    goto <bb 19>; [INV]
  else
    goto <bb 20>; [INV]

  <bb 19> :
  _40 = data->list.num;
  _41 = _40 - pos;
  _42 = _41 + 4294967295;
  _43 = (long unsigned int) _42;
  _44 = _43 * 24;
  _45 = data->list.list;
  _46 = pos + 1;
  _47 = (long unsigned int) _46;
  _48 = _47 * 24;
  _49 = _45 + _48;
  _50 = data->list.list;
  _51 = pos + 1;
  _52 = (sizetype) _51;
  _53 = _52 + 1;
  _54 = _53 * 24;
  _55 = _50 + _54;
  memmove (_55, _49, _44);

  <bb 20> :
  _56 = data->old_list.list;
  _57 = (long unsigned int) i;
  _58 = _57 * 24;
  _59 = _56 + _58;
  _60 = data->list.list;
  _61 = pos + 1;
  _62 = (long unsigned int) _61;
  _63 = _62 * 24;
  _64 = _60 + _63;
  *_64 = *_59;
  _65 = data->list.num;
  _66 = _65 + 1;
  data->list.num = _66;
  goto <bb 30>; [INV]

  <bb 21> :
  _67 = data->list.num;
  if (_67 > 1073741823)
    goto <bb 22>; [INV]
  else
    goto <bb 23>; [INV]

  <bb 22> :
  printf ("number too big%s", "");
  exit (1);

  <bb 23> :
  _68 = data->list.num;
  _69 = _68 + 1;
  _70 = 1073741824 / _69;
  if (_70 <= 23)
    goto <bb 24>; [INV]
  else
    goto <bb 25>; [INV]

  <bb 24> :
  printf ("size too big%s", "");
  exit (1);

  <bb 25> :
  _71 = data->list.space;
  if (_71 == 0)
    goto <bb 26>; [INV]
  else
    goto <bb 28>; [INV]

  <bb 26> :
  data->list.space = 240;
  _72 = data->list.space;
  _73 = data->list.list;
  _74 = xrealloc (_73, 1, _72);
  data->list.list = _74;
  goto <bb 28>; [INV]

  <bb 27> :
  _75 = data->list.space;
  _76 = data->list.list;
  _77 = xrealloc (_76, 2, _75);
  data->list.list = _77;
  _78 = data->list.space;
  _79 = _78 * 2;
  data->list.space = _79;

  <bb 28> :
  _80 = data->list.space;
  _81 = data->list.num;
  _82 = _81 + 1;
  _83 = (long unsigned int) _82;
  _84 = _83 * 24;
  if (_80 <= _84)
    goto <bb 27>; [INV]
  else
    goto <bb 29>; [INV]

  <bb 29> :
  _85 = data->old_list.list;
  _86 = (long unsigned int) i;
  _87 = _86 * 24;
  _88 = _85 + _87;
  _89 = data->list.list;
  _90 = data->list.num;
  _91 = (long unsigned int) _90;
  _92 = _91 * 24;
  _93 = _89 + _92;
  *_93 = *_88;
  _94 = data->list.num;
  _95 = _94 + 1;
  data->list.num = _95;

  <bb 30> :
  i = i + 4294967295;

  <bb 31> :
  if (i != 0)
    goto <bb 7>; [INV]
  else
    goto <bb 32>; [INV]

  <bb 32> :
  return;

}



;; Function window_choose_add_item (window_choose_add_item, funcdef_no=41, decl_uid=4472, cgraph_uid=42, symbol_order=42)

Merging blocks 2 and 3
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
struct window_choose_data * window_choose_add_item (struct window_pane * wp, struct cmd_ctx * ctx, struct winlink * wl, const char * template, char * action, u_int idx)
{
  char * action_data;
  struct window_choose_data * wcd;
  struct window_choose_data * D.4827;

  <bb 2> :
  wcd = window_choose_data_create (ctx);
  _1 = wl->idx;
  _2 = (unsigned int) _1;
  wcd->idx = _2;
  _3 = wcd->session;
  _4 = _3->references;
  _5 = _4 + 1;
  _3->references = _5;
  window_choose_add (wp, wcd);
  free (action_data);
  D.4827 = wcd;
  return D.4827;

}



;; Function window_pane_create (window_pane_create, funcdef_no=42, decl_uid=4480, cgraph_uid=43, symbol_order=43)

Merging blocks 2 and 3
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
struct window_pane * window_pane_create (struct window * w, u_int sx, u_int sy, u_int hlimit)
{
  struct window_pane * wp;
  struct window_pane * D.4829;

  <bb 2> :
  wp = calloc (1, 600);
  wp->window = w;
  wp->shell = 0B;
  wp->cwd = 0B;
  wp->fd = -1;
  wp->event = 0B;
  wp->mode = 0B;
  wp->layout_cell = 0B;
  wp->xoff = 0;
  wp->yoff = 0;
  wp->sx = sx;
  wp->sy = sy;
  wp->pipe_fd = -1;
  wp->pipe_off = 0;
  wp->pipe_event = 0B;
  wp->saved_grid = 0B;
  _1 = &wp->base;
  wp->screen = _1;
  D.4829 = wp;
  return D.4829;

}



;; Function window_pane_destroy (window_pane_destroy, funcdef_no=43, decl_uid=4484, cgraph_uid=44, symbol_order=44)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
void window_pane_destroy (struct window_pane * wp)
{
  <bb 2> :
  _1 = wp->cwd;
  free (_1);
  _2 = wp->shell;
  free (_2);
  free (wp);
  return;

}



;; Function main (main, funcdef_no=44, decl_uid=4486, cgraph_uid=45, symbol_order=45)

Merging blocks 5 and 6
;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5
;;
;; Loop 1
;;  header 4, latch 3
;;  depth 1, outer 0
;;  nodes: 4 3
;; 2 succs { 4 }
;; 3 succs { 4 }
;; 4 succs { 3 5 }
;; 5 succs { 1 }
int main ()
{
  int hlimit;
  int sy;
  int sx;
  struct window_choose_data * wcd;
  struct window_pane * wp;
  struct cmd_ctx ctx;
  int D.4831;

  <bb 2> :
  hlimit.0_1 = (unsigned int) hlimit;
  sy.1_2 = (unsigned int) sy;
  sx.2_3 = (unsigned int) sx;
  wp = window_pane_create (0B, sx.2_3, sy.1_2, hlimit.0_1);
  window_choose_init (wp);
  goto <bb 4>; [INV]

  <bb 3> :
  wcd = window_choose_data_create (&ctx);
  window_choose_add (wp, wcd);

  <bb 4> :
  _4 = getchar ();
  if (_4 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 5> :
  window_choose_expand_all (wp);
  window_choose_collapse_all (wp);
  window_choose_free (wp);
  window_pane_destroy (wp);
  ctx = {CLOBBER};
  D.4831 = 0;
  return D.4831;

}



;; Function getchar (getchar, funcdef_no=1, decl_uid=2214, cgraph_uid=2, symbol_order=1)

Merging blocks 2 and 3
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
__attribute__((gnu_inline))
int getchar ()
{
  int D.4833;

  <bb 2> :
  stdin.3_1 = stdin;
  D.4833 = getc (stdin.3_1);
  return D.4833;

}


