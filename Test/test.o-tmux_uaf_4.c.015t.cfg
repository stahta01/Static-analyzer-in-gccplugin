
;; Function winlink_cmp (winlink_cmp, funcdef_no=22, decl_uid=4158, cgraph_uid=23, symbol_order=25)

Merging blocks 2 and 3
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
int winlink_cmp (struct winlink * wl1, struct winlink * wl2)
{
  int D.4714;

  <bb 2> :
  _1 = wl1->idx;
  _2 = wl2->idx;
  D.4714 = _1 - _2;
  return D.4714;

}



;; Function winlinks_RB_INSERT_COLOR (winlinks_RB_INSERT_COLOR, funcdef_no=23, decl_uid=4162, cgraph_uid=24, symbol_order=26)

Removing basic block 14
Merging blocks 16 and 17
Removing basic block 24
Merging blocks 26 and 27
Removing basic block 38
Merging blocks 40 and 41
Removing basic block 48
;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46
;;
;; Loop 1
;;  header 44, multiple latches: 6 23 26 43
;;  depth 1, outer 0
;;  nodes: 44 6 23 26 43 41 42 40 39 38 36 37 27 35 33 34 32 31 30 28 29 24 25 3 45 21 22 20 19 18 16 17 7 15 13 14 12 11 10 8 9 4 5
;; 2 succs { 44 }
;; 3 succs { 4 24 }
;; 4 succs { 5 7 }
;; 5 succs { 6 7 }
;; 6 succs { 44 }
;; 7 succs { 8 16 }
;; 8 succs { 9 10 }
;; 9 succs { 10 }
;; 10 succs { 11 14 }
;; 11 succs { 12 13 }
;; 12 succs { 15 }
;; 13 succs { 15 }
;; 14 succs { 15 }
;; 15 succs { 16 }
;; 16 succs { 17 18 }
;; 17 succs { 18 }
;; 18 succs { 19 22 }
;; 19 succs { 20 21 }
;; 20 succs { 23 }
;; 21 succs { 23 }
;; 22 succs { 23 }
;; 23 succs { 44 }
;; 24 succs { 25 27 }
;; 25 succs { 26 27 }
;; 26 succs { 44 }
;; 27 succs { 28 36 }
;; 28 succs { 29 30 }
;; 29 succs { 30 }
;; 30 succs { 31 34 }
;; 31 succs { 32 33 }
;; 32 succs { 35 }
;; 33 succs { 35 }
;; 34 succs { 35 }
;; 35 succs { 36 }
;; 36 succs { 37 38 }
;; 37 succs { 38 }
;; 38 succs { 39 42 }
;; 39 succs { 40 41 }
;; 40 succs { 43 }
;; 41 succs { 43 }
;; 42 succs { 43 }
;; 43 succs { 44 }
;; 44 succs { 45 46 }
;; 45 succs { 3 46 }
;; 46 succs { 1 }
void winlinks_RB_INSERT_COLOR (struct winlinks * head, struct winlink * elm)
{
  struct winlink * tmp;
  struct winlink * gparent;
  struct winlink * parent;

  <bb 2> :
  goto <bb 44>; [INV]

  <bb 3> :
  gparent = parent->entry.rbe_parent;
  _1 = gparent->entry.rbe_left;
  if (parent == _1)
    goto <bb 4>; [INV]
  else
    goto <bb 24>; [INV]

  <bb 4> :
  tmp = gparent->entry.rbe_right;
  if (tmp != 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 5> :
  _2 = tmp->entry.rbe_color;
  if (_2 == 1)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  tmp->entry.rbe_color = 0;
  parent->entry.rbe_color = 0;
  gparent->entry.rbe_color = 1;
  elm = gparent;
  // predicted unlikely by continue predictor.
  goto <bb 44>; [INV]

  <bb 7> :
  _3 = parent->entry.rbe_right;
  if (elm == _3)
    goto <bb 8>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 8> :
  tmp = parent->entry.rbe_right;
  _4 = tmp->entry.rbe_left;
  parent->entry.rbe_right = _4;
  _5 = parent->entry.rbe_right;
  if (_5 != 0B)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  _6 = tmp->entry.rbe_left;
  _6->entry.rbe_parent = parent;

  <bb 10> :
  _7 = parent->entry.rbe_parent;
  tmp->entry.rbe_parent = _7;
  _8 = tmp->entry.rbe_parent;
  if (_8 != 0B)
    goto <bb 11>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 11> :
  _9 = parent->entry.rbe_parent;
  _10 = _9->entry.rbe_left;
  if (parent == _10)
    goto <bb 12>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 12> :
  _11 = parent->entry.rbe_parent;
  _11->entry.rbe_left = tmp;
  goto <bb 15>; [INV]

  <bb 13> :
  _12 = parent->entry.rbe_parent;
  _12->entry.rbe_right = tmp;
  goto <bb 15>; [INV]

  <bb 14> :
  head->rbh_root = tmp;

  <bb 15> :
  tmp->entry.rbe_left = parent;
  parent->entry.rbe_parent = tmp;
  _13 = tmp->entry.rbe_parent;
  tmp = parent;
  parent = elm;
  elm = tmp;

  <bb 16> :
  parent->entry.rbe_color = 0;
  gparent->entry.rbe_color = 1;
  tmp = gparent->entry.rbe_left;
  _14 = tmp->entry.rbe_right;
  gparent->entry.rbe_left = _14;
  _15 = gparent->entry.rbe_left;
  if (_15 != 0B)
    goto <bb 17>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 17> :
  _16 = tmp->entry.rbe_right;
  _16->entry.rbe_parent = gparent;

  <bb 18> :
  _17 = gparent->entry.rbe_parent;
  tmp->entry.rbe_parent = _17;
  _18 = tmp->entry.rbe_parent;
  if (_18 != 0B)
    goto <bb 19>; [INV]
  else
    goto <bb 22>; [INV]

  <bb 19> :
  _19 = gparent->entry.rbe_parent;
  _20 = _19->entry.rbe_left;
  if (gparent == _20)
    goto <bb 20>; [INV]
  else
    goto <bb 21>; [INV]

  <bb 20> :
  _21 = gparent->entry.rbe_parent;
  _21->entry.rbe_left = tmp;
  goto <bb 23>; [INV]

  <bb 21> :
  _22 = gparent->entry.rbe_parent;
  _22->entry.rbe_right = tmp;
  goto <bb 23>; [INV]

  <bb 22> :
  head->rbh_root = tmp;

  <bb 23> :
  tmp->entry.rbe_right = gparent;
  gparent->entry.rbe_parent = tmp;
  _23 = tmp->entry.rbe_parent;
  goto <bb 44>; [INV]

  <bb 24> :
  tmp = gparent->entry.rbe_left;
  if (tmp != 0B)
    goto <bb 25>; [INV]
  else
    goto <bb 27>; [INV]

  <bb 25> :
  _24 = tmp->entry.rbe_color;
  if (_24 == 1)
    goto <bb 26>; [INV]
  else
    goto <bb 27>; [INV]

  <bb 26> :
  tmp->entry.rbe_color = 0;
  parent->entry.rbe_color = 0;
  gparent->entry.rbe_color = 1;
  elm = gparent;
  // predicted unlikely by continue predictor.
  goto <bb 44>; [INV]

  <bb 27> :
  _25 = parent->entry.rbe_left;
  if (elm == _25)
    goto <bb 28>; [INV]
  else
    goto <bb 36>; [INV]

  <bb 28> :
  tmp = parent->entry.rbe_left;
  _26 = tmp->entry.rbe_right;
  parent->entry.rbe_left = _26;
  _27 = parent->entry.rbe_left;
  if (_27 != 0B)
    goto <bb 29>; [INV]
  else
    goto <bb 30>; [INV]

  <bb 29> :
  _28 = tmp->entry.rbe_right;
  _28->entry.rbe_parent = parent;

  <bb 30> :
  _29 = parent->entry.rbe_parent;
  tmp->entry.rbe_parent = _29;
  _30 = tmp->entry.rbe_parent;
  if (_30 != 0B)
    goto <bb 31>; [INV]
  else
    goto <bb 34>; [INV]

  <bb 31> :
  _31 = parent->entry.rbe_parent;
  _32 = _31->entry.rbe_left;
  if (parent == _32)
    goto <bb 32>; [INV]
  else
    goto <bb 33>; [INV]

  <bb 32> :
  _33 = parent->entry.rbe_parent;
  _33->entry.rbe_left = tmp;
  goto <bb 35>; [INV]

  <bb 33> :
  _34 = parent->entry.rbe_parent;
  _34->entry.rbe_right = tmp;
  goto <bb 35>; [INV]

  <bb 34> :
  head->rbh_root = tmp;

  <bb 35> :
  tmp->entry.rbe_right = parent;
  parent->entry.rbe_parent = tmp;
  _35 = tmp->entry.rbe_parent;
  tmp = parent;
  parent = elm;
  elm = tmp;

  <bb 36> :
  parent->entry.rbe_color = 0;
  gparent->entry.rbe_color = 1;
  tmp = gparent->entry.rbe_right;
  _36 = tmp->entry.rbe_left;
  gparent->entry.rbe_right = _36;
  _37 = gparent->entry.rbe_right;
  if (_37 != 0B)
    goto <bb 37>; [INV]
  else
    goto <bb 38>; [INV]

  <bb 37> :
  _38 = tmp->entry.rbe_left;
  _38->entry.rbe_parent = gparent;

  <bb 38> :
  _39 = gparent->entry.rbe_parent;
  tmp->entry.rbe_parent = _39;
  _40 = tmp->entry.rbe_parent;
  if (_40 != 0B)
    goto <bb 39>; [INV]
  else
    goto <bb 42>; [INV]

  <bb 39> :
  _41 = gparent->entry.rbe_parent;
  _42 = _41->entry.rbe_left;
  if (gparent == _42)
    goto <bb 40>; [INV]
  else
    goto <bb 41>; [INV]

  <bb 40> :
  _43 = gparent->entry.rbe_parent;
  _43->entry.rbe_left = tmp;
  goto <bb 43>; [INV]

  <bb 41> :
  _44 = gparent->entry.rbe_parent;
  _44->entry.rbe_right = tmp;
  goto <bb 43>; [INV]

  <bb 42> :
  head->rbh_root = tmp;

  <bb 43> :
  tmp->entry.rbe_left = gparent;
  gparent->entry.rbe_parent = tmp;
  _45 = tmp->entry.rbe_parent;

  <bb 44> :
  parent = elm->entry.rbe_parent;
  if (parent != 0B)
    goto <bb 45>; [INV]
  else
    goto <bb 46>; [INV]

  <bb 45> :
  _46 = parent->entry.rbe_color;
  if (_46 == 1)
    goto <bb 3>; [INV]
  else
    goto <bb 46>; [INV]

  <bb 46> :
  _47 = head->rbh_root;
  _47->entry.rbe_color = 0;
  return;

}



;; Function winlinks_RB_REMOVE_COLOR (winlinks_RB_REMOVE_COLOR, funcdef_no=24, decl_uid=4213, cgraph_uid=25, symbol_order=27)

Removing basic block 11
Merging blocks 13 and 14
Merging blocks 19 and 46
Removing basic block 30
Merging blocks 32 and 33
Removing basic block 42
Merging blocks 44 and 45
Removing basic block 54
Merging blocks 56 and 57
Removing basic block 73
Merging blocks 75 and 76
Removing basic block 85
Merging blocks 87 and 88
;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81
;;
;; Loop 1
;;  header 76, multiple latches: 17 53
;;  depth 1, outer 0
;;  nodes: 76 17 53 51 52 49 50 40 48 46 47 45 44 43 41 42 3 78 77 15 16 13 14 4 12 10 11 9 8 7 5 6
;; 2 succs { 76 }
;; 3 succs { 4 40 }
;; 4 succs { 5 13 }
;; 5 succs { 6 7 }
;; 6 succs { 7 }
;; 7 succs { 8 11 }
;; 8 succs { 9 10 }
;; 9 succs { 12 }
;; 10 succs { 12 }
;; 11 succs { 12 }
;; 12 succs { 13 }
;; 13 succs { 15 14 }
;; 14 succs { 15 18 }
;; 15 succs { 17 16 }
;; 16 succs { 17 18 }
;; 17 succs { 76 }
;; 18 succs { 20 19 }
;; 19 succs { 20 30 }
;; 20 succs { 21 22 }
;; 21 succs { 22 }
;; 22 succs { 23 24 }
;; 23 succs { 24 }
;; 24 succs { 25 28 }
;; 25 succs { 26 27 }
;; 26 succs { 29 }
;; 27 succs { 29 }
;; 28 succs { 29 }
;; 29 succs { 30 }
;; 30 succs { 31 32 }
;; 31 succs { 32 }
;; 32 succs { 33 34 }
;; 33 succs { 34 }
;; 34 succs { 35 38 }
;; 35 succs { 36 37 }
;; 36 succs { 39 }
;; 37 succs { 39 }
;; 38 succs { 39 }
;; 39 succs { 79 }
;; 40 succs { 41 49 }
;; 41 succs { 42 43 }
;; 42 succs { 43 }
;; 43 succs { 44 47 }
;; 44 succs { 45 46 }
;; 45 succs { 48 }
;; 46 succs { 48 }
;; 47 succs { 48 }
;; 48 succs { 49 }
;; 49 succs { 51 50 }
;; 50 succs { 51 54 }
;; 51 succs { 53 52 }
;; 52 succs { 53 54 }
;; 53 succs { 76 }
;; 54 succs { 56 55 }
;; 55 succs { 56 66 }
;; 56 succs { 57 58 }
;; 57 succs { 58 }
;; 58 succs { 59 60 }
;; 59 succs { 60 }
;; 60 succs { 61 64 }
;; 61 succs { 62 63 }
;; 62 succs { 65 }
;; 63 succs { 65 }
;; 64 succs { 65 }
;; 65 succs { 66 }
;; 66 succs { 67 68 }
;; 67 succs { 68 }
;; 68 succs { 69 70 }
;; 69 succs { 70 }
;; 70 succs { 71 74 }
;; 71 succs { 72 73 }
;; 72 succs { 75 }
;; 73 succs { 75 }
;; 74 succs { 75 }
;; 75 succs { 79 }
;; 76 succs { 78 77 }
;; 77 succs { 78 79 }
;; 78 succs { 3 79 }
;; 79 succs { 80 81 }
;; 80 succs { 81 }
;; 81 succs { 1 }
void winlinks_RB_REMOVE_COLOR (struct winlinks * head, struct winlink * parent, struct winlink * elm)
{
  struct winlink * oright;
  struct winlink * oleft;
  struct winlink * tmp;

  <bb 2> :
  goto <bb 76>; [INV]

  <bb 3> :
  _1 = parent->entry.rbe_left;
  if (elm == _1)
    goto <bb 4>; [INV]
  else
    goto <bb 40>; [INV]

  <bb 4> :
  tmp = parent->entry.rbe_right;
  _2 = tmp->entry.rbe_color;
  if (_2 == 1)
    goto <bb 5>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 5> :
  tmp->entry.rbe_color = 0;
  parent->entry.rbe_color = 1;
  tmp = parent->entry.rbe_right;
  _3 = tmp->entry.rbe_left;
  parent->entry.rbe_right = _3;
  _4 = parent->entry.rbe_right;
  if (_4 != 0B)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  _5 = tmp->entry.rbe_left;
  _5->entry.rbe_parent = parent;

  <bb 7> :
  _6 = parent->entry.rbe_parent;
  tmp->entry.rbe_parent = _6;
  _7 = tmp->entry.rbe_parent;
  if (_7 != 0B)
    goto <bb 8>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 8> :
  _8 = parent->entry.rbe_parent;
  _9 = _8->entry.rbe_left;
  if (parent == _9)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  _10 = parent->entry.rbe_parent;
  _10->entry.rbe_left = tmp;
  goto <bb 12>; [INV]

  <bb 10> :
  _11 = parent->entry.rbe_parent;
  _11->entry.rbe_right = tmp;
  goto <bb 12>; [INV]

  <bb 11> :
  head->rbh_root = tmp;

  <bb 12> :
  tmp->entry.rbe_left = parent;
  parent->entry.rbe_parent = tmp;
  _12 = tmp->entry.rbe_parent;
  tmp = parent->entry.rbe_right;

  <bb 13> :
  _13 = tmp->entry.rbe_left;
  if (_13 == 0B)
    goto <bb 15>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 14> :
  _14 = tmp->entry.rbe_left;
  _15 = _14->entry.rbe_color;
  if (_15 == 0)
    goto <bb 15>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 15> :
  _16 = tmp->entry.rbe_right;
  if (_16 == 0B)
    goto <bb 17>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 16> :
  _17 = tmp->entry.rbe_right;
  _18 = _17->entry.rbe_color;
  if (_18 == 0)
    goto <bb 17>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 17> :
  tmp->entry.rbe_color = 1;
  elm = parent;
  parent = elm->entry.rbe_parent;
  goto <bb 76>; [INV]

  <bb 18> :
  _19 = tmp->entry.rbe_right;
  if (_19 == 0B)
    goto <bb 20>; [INV]
  else
    goto <bb 19>; [INV]

  <bb 19> :
  _20 = tmp->entry.rbe_right;
  _21 = _20->entry.rbe_color;
  if (_21 == 0)
    goto <bb 20>; [INV]
  else
    goto <bb 30>; [INV]

  <bb 20> :
  oleft = tmp->entry.rbe_left;
  if (oleft != 0B)
    goto <bb 21>; [INV]
  else
    goto <bb 22>; [INV]

  <bb 21> :
  oleft->entry.rbe_color = 0;

  <bb 22> :
  tmp->entry.rbe_color = 1;
  oleft = tmp->entry.rbe_left;
  _22 = oleft->entry.rbe_right;
  tmp->entry.rbe_left = _22;
  _23 = tmp->entry.rbe_left;
  if (_23 != 0B)
    goto <bb 23>; [INV]
  else
    goto <bb 24>; [INV]

  <bb 23> :
  _24 = oleft->entry.rbe_right;
  _24->entry.rbe_parent = tmp;

  <bb 24> :
  _25 = tmp->entry.rbe_parent;
  oleft->entry.rbe_parent = _25;
  _26 = oleft->entry.rbe_parent;
  if (_26 != 0B)
    goto <bb 25>; [INV]
  else
    goto <bb 28>; [INV]

  <bb 25> :
  _27 = tmp->entry.rbe_parent;
  _28 = _27->entry.rbe_left;
  if (tmp == _28)
    goto <bb 26>; [INV]
  else
    goto <bb 27>; [INV]

  <bb 26> :
  _29 = tmp->entry.rbe_parent;
  _29->entry.rbe_left = oleft;
  goto <bb 29>; [INV]

  <bb 27> :
  _30 = tmp->entry.rbe_parent;
  _30->entry.rbe_right = oleft;
  goto <bb 29>; [INV]

  <bb 28> :
  head->rbh_root = oleft;

  <bb 29> :
  oleft->entry.rbe_right = tmp;
  tmp->entry.rbe_parent = oleft;
  _31 = oleft->entry.rbe_parent;
  tmp = parent->entry.rbe_right;

  <bb 30> :
  _32 = parent->entry.rbe_color;
  tmp->entry.rbe_color = _32;
  parent->entry.rbe_color = 0;
  _33 = tmp->entry.rbe_right;
  if (_33 != 0B)
    goto <bb 31>; [INV]
  else
    goto <bb 32>; [INV]

  <bb 31> :
  _34 = tmp->entry.rbe_right;
  _34->entry.rbe_color = 0;

  <bb 32> :
  tmp = parent->entry.rbe_right;
  _35 = tmp->entry.rbe_left;
  parent->entry.rbe_right = _35;
  _36 = parent->entry.rbe_right;
  if (_36 != 0B)
    goto <bb 33>; [INV]
  else
    goto <bb 34>; [INV]

  <bb 33> :
  _37 = tmp->entry.rbe_left;
  _37->entry.rbe_parent = parent;

  <bb 34> :
  _38 = parent->entry.rbe_parent;
  tmp->entry.rbe_parent = _38;
  _39 = tmp->entry.rbe_parent;
  if (_39 != 0B)
    goto <bb 35>; [INV]
  else
    goto <bb 38>; [INV]

  <bb 35> :
  _40 = parent->entry.rbe_parent;
  _41 = _40->entry.rbe_left;
  if (parent == _41)
    goto <bb 36>; [INV]
  else
    goto <bb 37>; [INV]

  <bb 36> :
  _42 = parent->entry.rbe_parent;
  _42->entry.rbe_left = tmp;
  goto <bb 39>; [INV]

  <bb 37> :
  _43 = parent->entry.rbe_parent;
  _43->entry.rbe_right = tmp;
  goto <bb 39>; [INV]

  <bb 38> :
  head->rbh_root = tmp;

  <bb 39> :
  tmp->entry.rbe_left = parent;
  parent->entry.rbe_parent = tmp;
  _44 = tmp->entry.rbe_parent;
  elm = head->rbh_root;
  goto <bb 79>; [INV]

  <bb 40> :
  tmp = parent->entry.rbe_left;
  _45 = tmp->entry.rbe_color;
  if (_45 == 1)
    goto <bb 41>; [INV]
  else
    goto <bb 49>; [INV]

  <bb 41> :
  tmp->entry.rbe_color = 0;
  parent->entry.rbe_color = 1;
  tmp = parent->entry.rbe_left;
  _46 = tmp->entry.rbe_right;
  parent->entry.rbe_left = _46;
  _47 = parent->entry.rbe_left;
  if (_47 != 0B)
    goto <bb 42>; [INV]
  else
    goto <bb 43>; [INV]

  <bb 42> :
  _48 = tmp->entry.rbe_right;
  _48->entry.rbe_parent = parent;

  <bb 43> :
  _49 = parent->entry.rbe_parent;
  tmp->entry.rbe_parent = _49;
  _50 = tmp->entry.rbe_parent;
  if (_50 != 0B)
    goto <bb 44>; [INV]
  else
    goto <bb 47>; [INV]

  <bb 44> :
  _51 = parent->entry.rbe_parent;
  _52 = _51->entry.rbe_left;
  if (parent == _52)
    goto <bb 45>; [INV]
  else
    goto <bb 46>; [INV]

  <bb 45> :
  _53 = parent->entry.rbe_parent;
  _53->entry.rbe_left = tmp;
  goto <bb 48>; [INV]

  <bb 46> :
  _54 = parent->entry.rbe_parent;
  _54->entry.rbe_right = tmp;
  goto <bb 48>; [INV]

  <bb 47> :
  head->rbh_root = tmp;

  <bb 48> :
  tmp->entry.rbe_right = parent;
  parent->entry.rbe_parent = tmp;
  _55 = tmp->entry.rbe_parent;
  tmp = parent->entry.rbe_left;

  <bb 49> :
  _56 = tmp->entry.rbe_left;
  if (_56 == 0B)
    goto <bb 51>; [INV]
  else
    goto <bb 50>; [INV]

  <bb 50> :
  _57 = tmp->entry.rbe_left;
  _58 = _57->entry.rbe_color;
  if (_58 == 0)
    goto <bb 51>; [INV]
  else
    goto <bb 54>; [INV]

  <bb 51> :
  _59 = tmp->entry.rbe_right;
  if (_59 == 0B)
    goto <bb 53>; [INV]
  else
    goto <bb 52>; [INV]

  <bb 52> :
  _60 = tmp->entry.rbe_right;
  _61 = _60->entry.rbe_color;
  if (_61 == 0)
    goto <bb 53>; [INV]
  else
    goto <bb 54>; [INV]

  <bb 53> :
  tmp->entry.rbe_color = 1;
  elm = parent;
  parent = elm->entry.rbe_parent;
  goto <bb 76>; [INV]

  <bb 54> :
  _62 = tmp->entry.rbe_left;
  if (_62 == 0B)
    goto <bb 56>; [INV]
  else
    goto <bb 55>; [INV]

  <bb 55> :
  _63 = tmp->entry.rbe_left;
  _64 = _63->entry.rbe_color;
  if (_64 == 0)
    goto <bb 56>; [INV]
  else
    goto <bb 66>; [INV]

  <bb 56> :
  oright = tmp->entry.rbe_right;
  if (oright != 0B)
    goto <bb 57>; [INV]
  else
    goto <bb 58>; [INV]

  <bb 57> :
  oright->entry.rbe_color = 0;

  <bb 58> :
  tmp->entry.rbe_color = 1;
  oright = tmp->entry.rbe_right;
  _65 = oright->entry.rbe_left;
  tmp->entry.rbe_right = _65;
  _66 = tmp->entry.rbe_right;
  if (_66 != 0B)
    goto <bb 59>; [INV]
  else
    goto <bb 60>; [INV]

  <bb 59> :
  _67 = oright->entry.rbe_left;
  _67->entry.rbe_parent = tmp;

  <bb 60> :
  _68 = tmp->entry.rbe_parent;
  oright->entry.rbe_parent = _68;
  _69 = oright->entry.rbe_parent;
  if (_69 != 0B)
    goto <bb 61>; [INV]
  else
    goto <bb 64>; [INV]

  <bb 61> :
  _70 = tmp->entry.rbe_parent;
  _71 = _70->entry.rbe_left;
  if (tmp == _71)
    goto <bb 62>; [INV]
  else
    goto <bb 63>; [INV]

  <bb 62> :
  _72 = tmp->entry.rbe_parent;
  _72->entry.rbe_left = oright;
  goto <bb 65>; [INV]

  <bb 63> :
  _73 = tmp->entry.rbe_parent;
  _73->entry.rbe_right = oright;
  goto <bb 65>; [INV]

  <bb 64> :
  head->rbh_root = oright;

  <bb 65> :
  oright->entry.rbe_left = tmp;
  tmp->entry.rbe_parent = oright;
  _74 = oright->entry.rbe_parent;
  tmp = parent->entry.rbe_left;

  <bb 66> :
  _75 = parent->entry.rbe_color;
  tmp->entry.rbe_color = _75;
  parent->entry.rbe_color = 0;
  _76 = tmp->entry.rbe_left;
  if (_76 != 0B)
    goto <bb 67>; [INV]
  else
    goto <bb 68>; [INV]

  <bb 67> :
  _77 = tmp->entry.rbe_left;
  _77->entry.rbe_color = 0;

  <bb 68> :
  tmp = parent->entry.rbe_left;
  _78 = tmp->entry.rbe_right;
  parent->entry.rbe_left = _78;
  _79 = parent->entry.rbe_left;
  if (_79 != 0B)
    goto <bb 69>; [INV]
  else
    goto <bb 70>; [INV]

  <bb 69> :
  _80 = tmp->entry.rbe_right;
  _80->entry.rbe_parent = parent;

  <bb 70> :
  _81 = parent->entry.rbe_parent;
  tmp->entry.rbe_parent = _81;
  _82 = tmp->entry.rbe_parent;
  if (_82 != 0B)
    goto <bb 71>; [INV]
  else
    goto <bb 74>; [INV]

  <bb 71> :
  _83 = parent->entry.rbe_parent;
  _84 = _83->entry.rbe_left;
  if (parent == _84)
    goto <bb 72>; [INV]
  else
    goto <bb 73>; [INV]

  <bb 72> :
  _85 = parent->entry.rbe_parent;
  _85->entry.rbe_left = tmp;
  goto <bb 75>; [INV]

  <bb 73> :
  _86 = parent->entry.rbe_parent;
  _86->entry.rbe_right = tmp;
  goto <bb 75>; [INV]

  <bb 74> :
  head->rbh_root = tmp;

  <bb 75> :
  tmp->entry.rbe_right = parent;
  parent->entry.rbe_parent = tmp;
  _87 = tmp->entry.rbe_parent;
  elm = head->rbh_root;
  goto <bb 79>; [INV]

  <bb 76> :
  if (elm == 0B)
    goto <bb 78>; [INV]
  else
    goto <bb 77>; [INV]

  <bb 77> :
  _88 = elm->entry.rbe_color;
  if (_88 == 0)
    goto <bb 78>; [INV]
  else
    goto <bb 79>; [INV]

  <bb 78> :
  _89 = head->rbh_root;
  if (elm != _89)
    goto <bb 3>; [INV]
  else
    goto <bb 79>; [INV]

  <bb 79> :
  if (elm != 0B)
    goto <bb 80>; [INV]
  else
    goto <bb 81>; [INV]

  <bb 80> :
  elm->entry.rbe_color = 0;

  <bb 81> :
  return;

}



;; Function winlinks_RB_INSERT (winlinks_RB_INSERT, funcdef_no=25, decl_uid=4275, cgraph_uid=26, symbol_order=28)

Removing basic block 13
;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
;;
;; Loop 1
;;  header 8, multiple latches: 4 6
;;  depth 1, outer 0
;;  nodes: 8 4 6 5 3
;; 2 succs { 8 }
;; 3 succs { 4 5 }
;; 4 succs { 8 }
;; 5 succs { 6 7 }
;; 6 succs { 8 }
;; 7 succs { 15 }
;; 8 succs { 3 9 }
;; 9 succs { 10 13 }
;; 10 succs { 11 12 }
;; 11 succs { 14 }
;; 12 succs { 14 }
;; 13 succs { 14 }
;; 14 succs { 15 }
;; 15 succs { 1 }
struct winlink * winlinks_RB_INSERT (struct winlinks * head, struct winlink * elm)
{
  int comp;
  struct winlink * parent;
  struct winlink * tmp;
  struct winlink * D.4875;

  <bb 2> :
  parent = 0B;
  comp = 0;
  tmp = head->rbh_root;
  goto <bb 8>; [INV]

  <bb 3> :
  parent = tmp;
  comp = winlink_cmp (elm, parent);
  if (comp < 0)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  tmp = tmp->entry.rbe_left;
  goto <bb 8>; [INV]

  <bb 5> :
  if (comp > 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  tmp = tmp->entry.rbe_right;
  goto <bb 8>; [INV]

  <bb 7> :
  D.4875 = tmp;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 15>; [INV]

  <bb 8> :
  if (tmp != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 9> :
  elm->entry.rbe_parent = parent;
  elm->entry.rbe_right = 0B;
  _1 = elm->entry.rbe_right;
  elm->entry.rbe_left = _1;
  elm->entry.rbe_color = 1;
  if (parent != 0B)
    goto <bb 10>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 10> :
  if (comp < 0)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  parent->entry.rbe_left = elm;
  goto <bb 14>; [INV]

  <bb 12> :
  parent->entry.rbe_right = elm;
  goto <bb 14>; [INV]

  <bb 13> :
  head->rbh_root = elm;

  <bb 14> :
  winlinks_RB_INSERT_COLOR (head, elm);
  D.4875 = 0B;

  <bb 15> :
  return D.4875;

}



;; Function winlinks_RB_REMOVE (winlinks_RB_REMOVE, funcdef_no=26, decl_uid=4289, cgraph_uid=27, symbol_order=29)

Removing basic block 15
Removing basic block 23
Removing basic block 37
Merging blocks 41 and 42
;; 3 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38
;;
;; Loop 2
;;  header 27, latch 27
;;  depth 1, outer 0
;;  nodes: 27
;;
;; Loop 1
;;  header 8, latch 7
;;  depth 1, outer 0
;;  nodes: 8 7
;; 2 succs { 3 4 }
;; 3 succs { 29 }
;; 4 succs { 5 6 }
;; 5 succs { 29 }
;; 6 succs { 8 }
;; 7 succs { 8 }
;; 8 succs { 7 9 }
;; 9 succs { 10 11 }
;; 10 succs { 11 }
;; 11 succs { 12 15 }
;; 12 succs { 13 14 }
;; 13 succs { 16 }
;; 14 succs { 16 }
;; 15 succs { 16 }
;; 16 succs { 17 18 }
;; 17 succs { 18 }
;; 18 succs { 19 22 }
;; 19 succs { 20 21 }
;; 20 succs { 23 }
;; 21 succs { 23 }
;; 22 succs { 23 }
;; 23 succs { 24 25 }
;; 24 succs { 25 }
;; 25 succs { 26 28 }
;; 26 succs { 27 }
;; 27 succs { 27 28 }
;; 28 succs { 36 }
;; 29 succs { 30 31 }
;; 30 succs { 31 }
;; 31 succs { 32 35 }
;; 32 succs { 33 34 }
;; 33 succs { 36 }
;; 34 succs { 36 }
;; 35 succs { 36 }
;; 36 succs { 37 38 }
;; 37 succs { 38 }
;; 38 succs { 1 }
struct winlink * winlinks_RB_REMOVE (struct winlinks * head, struct winlink * elm)
{
  struct winlink * left;
  int color;
  struct winlink * old;
  struct winlink * parent;
  struct winlink * child;
  struct winlink * D.4919;

  <bb 2> :
  old = elm;
  _1 = elm->entry.rbe_left;
  if (_1 == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  child = elm->entry.rbe_right;
  goto <bb 29>; [INV]

  <bb 4> :
  _2 = elm->entry.rbe_right;
  if (_2 == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  child = elm->entry.rbe_left;
  goto <bb 29>; [INV]

  <bb 6> :
  elm = elm->entry.rbe_right;
  goto <bb 8>; [INV]

  <bb 7> :
  elm = left;

  <bb 8> :
  left = elm->entry.rbe_left;
  if (left != 0B)
    goto <bb 7>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 9> :
  child = elm->entry.rbe_right;
  parent = elm->entry.rbe_parent;
  color = elm->entry.rbe_color;
  if (child != 0B)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  child->entry.rbe_parent = parent;

  <bb 11> :
  if (parent != 0B)
    goto <bb 12>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 12> :
  _3 = parent->entry.rbe_left;
  if (elm == _3)
    goto <bb 13>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 13> :
  parent->entry.rbe_left = child;
  goto <bb 16>; [INV]

  <bb 14> :
  parent->entry.rbe_right = child;
  goto <bb 16>; [INV]

  <bb 15> :
  head->rbh_root = child;

  <bb 16> :
  _4 = elm->entry.rbe_parent;
  if (old == _4)
    goto <bb 17>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 17> :
  parent = elm;

  <bb 18> :
  elm->entry = old->entry;
  _5 = old->entry.rbe_parent;
  if (_5 != 0B)
    goto <bb 19>; [INV]
  else
    goto <bb 22>; [INV]

  <bb 19> :
  _6 = old->entry.rbe_parent;
  _7 = _6->entry.rbe_left;
  if (old == _7)
    goto <bb 20>; [INV]
  else
    goto <bb 21>; [INV]

  <bb 20> :
  _8 = old->entry.rbe_parent;
  _8->entry.rbe_left = elm;
  goto <bb 23>; [INV]

  <bb 21> :
  _9 = old->entry.rbe_parent;
  _9->entry.rbe_right = elm;
  goto <bb 23>; [INV]

  <bb 22> :
  head->rbh_root = elm;

  <bb 23> :
  _10 = old->entry.rbe_left;
  _10->entry.rbe_parent = elm;
  _11 = old->entry.rbe_right;
  if (_11 != 0B)
    goto <bb 24>; [INV]
  else
    goto <bb 25>; [INV]

  <bb 24> :
  _12 = old->entry.rbe_right;
  _12->entry.rbe_parent = elm;

  <bb 25> :
  if (parent != 0B)
    goto <bb 26>; [INV]
  else
    goto <bb 28>; [INV]

  <bb 26> :
  left = parent;

  <bb 27> :
  left = left->entry.rbe_parent;
  if (left != 0B)
    goto <bb 27>; [INV]
  else
    goto <bb 28>; [INV]

  <bb 28> :
  // predicted unlikely by goto predictor.
  goto <bb 36>; [INV]

  <bb 29> :
  parent = elm->entry.rbe_parent;
  color = elm->entry.rbe_color;
  if (child != 0B)
    goto <bb 30>; [INV]
  else
    goto <bb 31>; [INV]

  <bb 30> :
  child->entry.rbe_parent = parent;

  <bb 31> :
  if (parent != 0B)
    goto <bb 32>; [INV]
  else
    goto <bb 35>; [INV]

  <bb 32> :
  _13 = parent->entry.rbe_left;
  if (elm == _13)
    goto <bb 33>; [INV]
  else
    goto <bb 34>; [INV]

  <bb 33> :
  parent->entry.rbe_left = child;
  goto <bb 36>; [INV]

  <bb 34> :
  parent->entry.rbe_right = child;
  goto <bb 36>; [INV]

  <bb 35> :
  head->rbh_root = child;

  <bb 36> :
color:
  if (color == 0)
    goto <bb 37>; [INV]
  else
    goto <bb 38>; [INV]

  <bb 37> :
  winlinks_RB_REMOVE_COLOR (head, parent, child);

  <bb 38> :
  D.4919 = old;
  return D.4919;

}



;; Function winlinks_RB_FIND (winlinks_RB_FIND, funcdef_no=27, decl_uid=4313, cgraph_uid=28, symbol_order=30)

;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10
;;
;; Loop 1
;;  header 8, multiple latches: 4 6
;;  depth 1, outer 0
;;  nodes: 8 4 6 5 3
;; 2 succs { 8 }
;; 3 succs { 4 5 }
;; 4 succs { 8 }
;; 5 succs { 6 7 }
;; 6 succs { 8 }
;; 7 succs { 10 }
;; 8 succs { 3 9 }
;; 9 succs { 10 }
;; 10 succs { 1 }
struct winlink * winlinks_RB_FIND (struct winlinks * head, struct winlink * elm)
{
  int comp;
  struct winlink * tmp;
  struct winlink * D.4927;

  <bb 2> :
  tmp = head->rbh_root;
  goto <bb 8>; [INV]

  <bb 3> :
  comp = winlink_cmp (elm, tmp);
  if (comp < 0)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  tmp = tmp->entry.rbe_left;
  goto <bb 8>; [INV]

  <bb 5> :
  if (comp > 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  tmp = tmp->entry.rbe_right;
  goto <bb 8>; [INV]

  <bb 7> :
  D.4927 = tmp;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 10>; [INV]

  <bb 8> :
  if (tmp != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 9> :
  D.4927 = 0B;

  <bb 10> :
  return D.4927;

}



;; Function winlinks_RB_NFIND (winlinks_RB_NFIND, funcdef_no=28, decl_uid=4322, cgraph_uid=29, symbol_order=31)

;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10
;;
;; Loop 1
;;  header 8, multiple latches: 4 6
;;  depth 1, outer 0
;;  nodes: 8 4 6 5 3
;; 2 succs { 8 }
;; 3 succs { 4 5 }
;; 4 succs { 8 }
;; 5 succs { 6 7 }
;; 6 succs { 8 }
;; 7 succs { 10 }
;; 8 succs { 3 9 }
;; 9 succs { 10 }
;; 10 succs { 1 }
struct winlink * winlinks_RB_NFIND (struct winlinks * head, struct winlink * elm)
{
  int comp;
  struct winlink * res;
  struct winlink * tmp;
  struct winlink * D.4935;

  <bb 2> :
  tmp = head->rbh_root;
  res = 0B;
  goto <bb 8>; [INV]

  <bb 3> :
  comp = winlink_cmp (elm, tmp);
  if (comp < 0)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  res = tmp;
  tmp = tmp->entry.rbe_left;
  goto <bb 8>; [INV]

  <bb 5> :
  if (comp > 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  tmp = tmp->entry.rbe_right;
  goto <bb 8>; [INV]

  <bb 7> :
  D.4935 = tmp;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 10>; [INV]

  <bb 8> :
  if (tmp != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 9> :
  D.4935 = res;

  <bb 10> :
  return D.4935;

}



;; Function winlinks_RB_NEXT (winlinks_RB_NEXT, funcdef_no=29, decl_uid=4331, cgraph_uid=30, symbol_order=32)

Removing basic block 6
Removing basic block 10
Merging blocks 15 and 16
;; 3 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13
;;
;; Loop 2
;;  header 5, latch 4
;;  depth 1, outer 0
;;  nodes: 5 4
;;
;; Loop 1
;;  header 10, latch 9
;;  depth 1, outer 0
;;  nodes: 10 9 11
;; 2 succs { 3 6 }
;; 3 succs { 5 }
;; 4 succs { 5 }
;; 5 succs { 4 13 }
;; 6 succs { 7 10 }
;; 7 succs { 8 10 }
;; 8 succs { 13 }
;; 9 succs { 10 }
;; 10 succs { 11 12 }
;; 11 succs { 9 12 }
;; 12 succs { 13 }
;; 13 succs { 1 }
struct winlink * winlinks_RB_NEXT (struct winlink * elm)
{
  struct winlink * D.4945;

  <bb 2> :
  _1 = elm->entry.rbe_right;
  if (_1 != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 3> :
  elm = elm->entry.rbe_right;
  goto <bb 5>; [INV]

  <bb 4> :
  elm = elm->entry.rbe_left;

  <bb 5> :
  _2 = elm->entry.rbe_left;
  if (_2 != 0B)
    goto <bb 4>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 6> :
  _3 = elm->entry.rbe_parent;
  if (_3 != 0B)
    goto <bb 7>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 7> :
  _4 = elm->entry.rbe_parent;
  _5 = _4->entry.rbe_left;
  if (elm == _5)
    goto <bb 8>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 8> :
  elm = elm->entry.rbe_parent;
  goto <bb 13>; [INV]

  <bb 9> :
  elm = elm->entry.rbe_parent;

  <bb 10> :
  _6 = elm->entry.rbe_parent;
  if (_6 != 0B)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  _7 = elm->entry.rbe_parent;
  _8 = _7->entry.rbe_right;
  if (elm == _8)
    goto <bb 9>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 12> :
  elm = elm->entry.rbe_parent;

  <bb 13> :
  D.4945 = elm;
  return D.4945;

}



;; Function winlinks_RB_PREV (winlinks_RB_PREV, funcdef_no=30, decl_uid=4340, cgraph_uid=31, symbol_order=33)

Removing basic block 6
Removing basic block 10
Merging blocks 15 and 16
;; 3 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13
;;
;; Loop 2
;;  header 5, latch 4
;;  depth 1, outer 0
;;  nodes: 5 4
;;
;; Loop 1
;;  header 10, latch 9
;;  depth 1, outer 0
;;  nodes: 10 9 11
;; 2 succs { 3 6 }
;; 3 succs { 5 }
;; 4 succs { 5 }
;; 5 succs { 4 13 }
;; 6 succs { 7 10 }
;; 7 succs { 8 10 }
;; 8 succs { 13 }
;; 9 succs { 10 }
;; 10 succs { 11 12 }
;; 11 succs { 9 12 }
;; 12 succs { 13 }
;; 13 succs { 1 }
struct winlink * winlinks_RB_PREV (struct winlink * elm)
{
  struct winlink * D.4955;

  <bb 2> :
  _1 = elm->entry.rbe_left;
  if (_1 != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 3> :
  elm = elm->entry.rbe_left;
  goto <bb 5>; [INV]

  <bb 4> :
  elm = elm->entry.rbe_right;

  <bb 5> :
  _2 = elm->entry.rbe_right;
  if (_2 != 0B)
    goto <bb 4>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 6> :
  _3 = elm->entry.rbe_parent;
  if (_3 != 0B)
    goto <bb 7>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 7> :
  _4 = elm->entry.rbe_parent;
  _5 = _4->entry.rbe_right;
  if (elm == _5)
    goto <bb 8>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 8> :
  elm = elm->entry.rbe_parent;
  goto <bb 13>; [INV]

  <bb 9> :
  elm = elm->entry.rbe_parent;

  <bb 10> :
  _6 = elm->entry.rbe_parent;
  if (_6 != 0B)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  _7 = elm->entry.rbe_parent;
  _8 = _7->entry.rbe_left;
  if (elm == _8)
    goto <bb 9>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 12> :
  elm = elm->entry.rbe_parent;

  <bb 13> :
  D.4955 = elm;
  return D.4955;

}



;; Function winlinks_RB_MINMAX (winlinks_RB_MINMAX, funcdef_no=31, decl_uid=4350, cgraph_uid=32, symbol_order=34)

Merging blocks 7 and 8
;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7
;;
;; Loop 1
;;  header 6, multiple latches: 4 5
;;  depth 1, outer 0
;;  nodes: 6 4 5 3
;; 2 succs { 6 }
;; 3 succs { 4 5 }
;; 4 succs { 6 }
;; 5 succs { 6 }
;; 6 succs { 3 7 }
;; 7 succs { 1 }
struct winlink * winlinks_RB_MINMAX (struct winlinks * head, int val)
{
  struct winlink * parent;
  struct winlink * tmp;
  struct winlink * D.4960;

  <bb 2> :
  tmp = head->rbh_root;
  parent = 0B;
  goto <bb 6>; [INV]

  <bb 3> :
  parent = tmp;
  if (val < 0)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  tmp = tmp->entry.rbe_left;
  goto <bb 6>; [INV]

  <bb 5> :
  tmp = tmp->entry.rbe_right;

  <bb 6> :
  if (tmp != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  D.4960 = parent;
  return D.4960;

}



;; Function xrealloc (xrealloc, funcdef_no=32, decl_uid=4360, cgraph_uid=33, symbol_order=35)

Merging blocks 8 and 9
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8
;; 2 succs { 3 4 }
;; 3 succs { }
;; 4 succs { 5 6 }
;; 5 succs { }
;; 6 succs { 7 8 }
;; 7 succs { }
;; 8 succs { 1 }
void * xrealloc (void * oldptr, size_t nmemb, size_t size)
{
  void * newptr;
  size_t newsize;
  void * D.4968;

  <bb 2> :
  newsize = nmemb * size;
  if (newsize == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  printf ("zero size%s", "");
  exit (1);

  <bb 4> :
  _1 = 1073741824 / nmemb;
  if (size > _1)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  printf ("nmemb * size > SIZE_MAX%s", "");
  exit (1);

  <bb 6> :
  newptr = realloc (oldptr, newsize);
  if (newptr == 0B)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  printf ("xrealloc failed%s", "");
  exit (1);

  <bb 8> :
  D.4968 = newptr;
  return D.4968;

}



;; Function winlink_find_by_index (winlink_find_by_index, funcdef_no=33, decl_uid=4366, cgraph_uid=34, symbol_order=36)

Merging blocks 4 and 5
Merging blocks 4 and 6
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4
;; 2 succs { 3 4 }
;; 3 succs { }
;; 4 succs { 1 }
struct winlink * winlink_find_by_index (struct winlinks * wwl, int idx)
{
  struct winlink wl;
  struct winlink * D.4972;

  <bb 2> :
  if (idx < 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  printf ("bad index%s", "");
  exit (1);

  <bb 4> :
  wl.idx = idx;
  D.4972 = winlinks_RB_FIND (wwl, &wl);
  wl = {CLOBBER};
  return D.4972;

}



;; Function winlink_count (winlink_count, funcdef_no=34, decl_uid=4370, cgraph_uid=35, symbol_order=37)

Merging blocks 5 and 6
;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5
;;
;; Loop 1
;;  header 4, latch 3
;;  depth 1, outer 0
;;  nodes: 4 3
;; 2 succs { 4 }
;; 3 succs { 4 }
;; 4 succs { 3 5 }
;; 5 succs { 1 }
u_int winlink_count (struct winlinks * wwl)
{
  u_int n;
  struct winlink * wl;
  u_int D.4975;

  <bb 2> :
  n = 0;
  wl = winlinks_RB_MINMAX (wwl, -1);
  goto <bb 4>; [INV]

  <bb 3> :
  n = n + 1;
  wl = winlinks_RB_NEXT (wl);

  <bb 4> :
  if (wl != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 5> :
  D.4975 = n;
  return D.4975;

}



;; Function winlink_next_index (winlink_next_index, funcdef_no=35, decl_uid=4380, cgraph_uid=36, symbol_order=38)

;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10
;;
;; Loop 1
;;  header 3, latch 8
;;  depth 1, outer 0
;;  nodes: 3 8 6 7 5
;; 2 succs { 3 }
;; 3 succs { 4 5 }
;; 4 succs { 10 }
;; 5 succs { 6 7 }
;; 6 succs { 8 }
;; 7 succs { 8 }
;; 8 succs { 3 9 }
;; 9 succs { 10 }
;; 10 succs { 1 }
int winlink_next_index (struct winlinks * wwl, int idx)
{
  int i;
  int D.4979;

  <bb 2> :
  i = idx;

  <bb 3> :
  _1 = winlink_find_by_index (wwl, i);
  if (_1 == 0B)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  D.4979 = i;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 10>; [INV]

  <bb 5> :
  if (i == 10000)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  i = 0;
  goto <bb 8>; [INV]

  <bb 7> :
  i = i + 1;

  <bb 8> :
  if (i != idx)
    goto <bb 3>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 9> :
  D.4979 = -1;

  <bb 10> :
  return D.4979;

}



;; Function winlink_find_by_window (winlink_find_by_window, funcdef_no=36, decl_uid=4388, cgraph_uid=37, symbol_order=39)

;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8
;;
;; Loop 1
;;  header 6, latch 5
;;  depth 1, outer 0
;;  nodes: 6 5 3
;; 2 succs { 6 }
;; 3 succs { 4 5 }
;; 4 succs { 8 }
;; 5 succs { 6 }
;; 6 succs { 3 7 }
;; 7 succs { 8 }
;; 8 succs { 1 }
struct winlink * winlink_find_by_window (struct winlinks * wwl, struct window * w)
{
  struct winlink * wl;
  struct winlink * D.4986;

  <bb 2> :
  wl = winlinks_RB_MINMAX (wwl, -1);
  goto <bb 6>; [INV]

  <bb 3> :
  _1 = wl->window;
  if (w == _1)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  D.4986 = wl;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 8>; [INV]

  <bb 5> :
  wl = winlinks_RB_NEXT (wl);

  <bb 6> :
  if (wl != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  D.4986 = 0B;

  <bb 8> :
  return D.4986;

}



;; Function cmd_find_pane (cmd_find_pane, funcdef_no=37, decl_uid=4397, cgraph_uid=38, symbol_order=40)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9
;; 2 succs { 3 4 }
;; 3 succs { 9 }
;; 4 succs { 5 6 }
;; 5 succs { 6 }
;; 6 succs { 7 8 }
;; 7 succs { 9 }
;; 8 succs { 9 }
;; 9 succs { 1 }
struct winlink * cmd_find_pane (int arg, struct session * * sp)
{
  u_int idx;
  struct winlink * wl;
  struct session * s;
  struct winlink * D.4990;

  <bb 2> :
  _1 = sessions.num;
  if (_1 == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  __builtin_puts (&"can\'t establish current session"[0]);
  D.4990 = 0B;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 9>; [INV]

  <bb 4> :
  _2 = sessions.list;
  s = MEM[(struct session * *)_2 + 8B];
  if (sp != 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  *sp = s;

  <bb 6> :
  if (arg != 0)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  D.4990 = s->curw;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 9>; [INV]

  <bb 8> :
  _3 = s->curw;
  D.4990 = winlinks_RB_NEXT (_3);

  <bb 9> :
  return D.4990;

}



;; Function session_has (session_has, funcdef_no=38, decl_uid=4404, cgraph_uid=39, symbol_order=41)

;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8
;;
;; Loop 1
;;  header 6, latch 5
;;  depth 1, outer 0
;;  nodes: 6 5 3
;; 2 succs { 6 }
;; 3 succs { 4 5 }
;; 4 succs { 8 }
;; 5 succs { 6 }
;; 6 succs { 3 7 }
;; 7 succs { 8 }
;; 8 succs { 1 }
int session_has (struct session * s, struct window * w)
{
  struct winlink * wl;
  int D.4998;

  <bb 2> :
  _1 = &s->windows;
  wl = winlinks_RB_MINMAX (_1, -1);
  goto <bb 6>; [INV]

  <bb 3> :
  _2 = wl->window;
  if (w == _2)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  D.4998 = 1;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 8>; [INV]

  <bb 5> :
  wl = winlinks_RB_NEXT (wl);

  <bb 6> :
  if (wl != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  D.4998 = 0;

  <bb 8> :
  return D.4998;

}



;; Function session_group_find (session_group_find, funcdef_no=39, decl_uid=4412, cgraph_uid=40, symbol_order=42)

;; 3 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11
;;
;; Loop 1
;;  header 9, latch 8
;;  depth 1, outer 0
;;  nodes: 9 8 7 3 6 4
;;
;; Loop 2
;;  header 7, latch 6
;;  depth 2, outer 1
;;  nodes: 7 6 4
;; 2 succs { 9 }
;; 3 succs { 7 }
;; 4 succs { 5 6 }
;; 5 succs { 11 }
;; 6 succs { 7 }
;; 7 succs { 4 8 }
;; 8 succs { 9 }
;; 9 succs { 3 10 }
;; 10 succs { 11 }
;; 11 succs { 1 }
struct session_group * session_group_find (struct session * target)
{
  struct session * s;
  struct session_group * sg;
  struct session_group * D.5002;

  <bb 2> :
  sg = session_groups.tqh_first;
  goto <bb 9>; [INV]

  <bb 3> :
  s = sg->sessions.tqh_first;
  goto <bb 7>; [INV]

  <bb 4> :
  if (s == target)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  D.5002 = sg;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 11>; [INV]

  <bb 6> :
  s = s->gentry.tqe_next;

  <bb 7> :
  if (s != 0B)
    goto <bb 4>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 8> :
  sg = sg->entry.tqe_next;

  <bb 9> :
  if (sg != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 10> :
  D.5002 = 0B;

  <bb 11> :
  return D.5002;

}



;; Function session_group_add (session_group_add, funcdef_no=40, decl_uid=4426, cgraph_uid=41, symbol_order=43)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4
;; 2 succs { 3 4 }
;; 3 succs { 4 }
;; 4 succs { 1 }
void session_group_add (struct session * target, struct session * s)
{
  struct session_group * sg;

  <bb 2> :
  sg = session_group_find (target);
  if (sg == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  sg = malloc (32);
  sg->entry.tqe_next = 0B;
  _1 = session_groups.tqh_last;
  sg->entry.tqe_prev = _1;
  _2 = session_groups.tqh_last;
  *_2 = sg;
  _3 = &sg->entry.tqe_next;
  session_groups.tqh_last = _3;
  sg->sessions.tqh_first = 0B;
  _4 = &sg->sessions.tqh_first;
  sg->sessions.tqh_last = _4;
  target->gentry.tqe_next = 0B;
  _5 = sg->sessions.tqh_last;
  target->gentry.tqe_prev = _5;
  _6 = sg->sessions.tqh_last;
  *_6 = target;
  _7 = &target->gentry.tqe_next;
  sg->sessions.tqh_last = _7;

  <bb 4> :
  s->gentry.tqe_next = 0B;
  _8 = sg->sessions.tqh_last;
  s->gentry.tqe_prev = _8;
  _9 = sg->sessions.tqh_last;
  *_9 = s;
  _10 = &s->gentry.tqe_next;
  sg->sessions.tqh_last = _10;
  return;

}



;; Function winlink_add (winlink_add, funcdef_no=41, decl_uid=4440, cgraph_uid=42, symbol_order=44)

Removing basic block 5
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8
;; 2 succs { 3 5 }
;; 3 succs { 4 7 }
;; 4 succs { 8 }
;; 5 succs { 6 7 }
;; 6 succs { 8 }
;; 7 succs { 8 }
;; 8 succs { 1 }
struct winlink * winlink_add (struct winlinks * wwl, struct window * w, int idx)
{
  struct winlink * wl;
  struct winlink * D.5010;

  <bb 2> :
  if (idx < 0)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 3> :
  _1 = ~idx;
  idx = winlink_next_index (wwl, _1);
  if (idx == -1)
    goto <bb 4>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 4> :
  D.5010 = 0B;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 8>; [INV]

  <bb 5> :
  _2 = winlink_find_by_index (wwl, idx);
  if (_2 != 0B)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  D.5010 = 0B;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 8>; [INV]

  <bb 7> :
  wl = calloc (1, 136);
  wl->idx = idx;
  wl->window = w;
  winlinks_RB_INSERT (wwl, wl);
  _3 = w->references;
  _4 = _3 + 1;
  w->references = _4;
  D.5010 = wl;

  <bb 8> :
  return D.5010;

}



;; Function window_index (window_index, funcdef_no=42, decl_uid=4445, cgraph_uid=43, symbol_order=45)

;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8
;;
;; Loop 1
;;  header 6, latch 5
;;  depth 1, outer 0
;;  nodes: 6 5 3
;; 2 succs { 6 }
;; 3 succs { 4 5 }
;; 4 succs { 8 }
;; 5 succs { 6 }
;; 6 succs { 3 7 }
;; 7 succs { 8 }
;; 8 succs { 1 }
int window_index (struct window * s, u_int * i)
{
  int D.5017;

  <bb 2> :
  *i = 0;
  goto <bb 6>; [INV]

  <bb 3> :
  _1 = windows.list;
  _2 = *i;
  _3 = (long unsigned int) _2;
  _4 = _3 * 8;
  _5 = _1 + _4;
  _6 = *_5;
  if (s == _6)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  D.5017 = 0;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 8>; [INV]

  <bb 5> :
  _7 = *i;
  _8 = _7 + 1;
  *i = _8;

  <bb 6> :
  _9 = *i;
  _10 = windows.num;
  if (_9 < _10)
    goto <bb 3>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  D.5017 = -1;

  <bb 8> :
  return D.5017;

}



;; Function session_group_remove (session_group_remove, funcdef_no=43, decl_uid=4452, cgraph_uid=44, symbol_order=46)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17
;; 2 succs { 3 4 }
;; 3 succs { 17 }
;; 4 succs { 5 6 }
;; 5 succs { 7 }
;; 6 succs { 7 }
;; 7 succs { 8 12 }
;; 8 succs { 9 10 }
;; 9 succs { 11 }
;; 10 succs { 11 }
;; 11 succs { 12 }
;; 12 succs { 13 17 }
;; 13 succs { 14 15 }
;; 14 succs { 16 }
;; 15 succs { 16 }
;; 16 succs { 17 }
;; 17 succs { 1 }
void session_group_remove (struct session * s)
{
  struct session_group * sg;

  <bb 2> :
  sg = session_group_find (s);
  if (sg == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 17>; [INV]

  <bb 4> :
  _1 = s->gentry.tqe_next;
  if (_1 != 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  _2 = s->gentry.tqe_next;
  _3 = s->gentry.tqe_prev;
  _2->gentry.tqe_prev = _3;
  goto <bb 7>; [INV]

  <bb 6> :
  _4 = s->gentry.tqe_prev;
  sg->sessions.tqh_last = _4;

  <bb 7> :
  _5 = s->gentry.tqe_prev;
  _6 = s->gentry.tqe_next;
  *_5 = _6;
  _7 = sg->sessions.tqh_first;
  _8 = _7->gentry.tqe_next;
  if (_8 == 0B)
    goto <bb 8>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 8> :
  _9 = sg->sessions.tqh_first;
  _10 = _9->gentry.tqe_next;
  if (_10 != 0B)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  _11 = sg->sessions.tqh_first;
  _12 = sg->sessions.tqh_first;
  _13 = _12->gentry.tqe_next;
  _14 = _11->gentry.tqe_prev;
  _13->gentry.tqe_prev = _14;
  goto <bb 11>; [INV]

  <bb 10> :
  _15 = sg->sessions.tqh_first;
  _16 = _15->gentry.tqe_prev;
  sg->sessions.tqh_last = _16;

  <bb 11> :
  _17 = sg->sessions.tqh_first;
  _18 = sg->sessions.tqh_first;
  _19 = _18->gentry.tqe_prev;
  _20 = _17->gentry.tqe_next;
  *_19 = _20;

  <bb 12> :
  _21 = sg->sessions.tqh_first;
  if (_21 == 0B)
    goto <bb 13>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 13> :
  _22 = sg->entry.tqe_next;
  if (_22 != 0B)
    goto <bb 14>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 14> :
  _23 = sg->entry.tqe_next;
  _24 = sg->entry.tqe_prev;
  _23->entry.tqe_prev = _24;
  goto <bb 16>; [INV]

  <bb 15> :
  _25 = sg->entry.tqe_prev;
  session_groups.tqh_last = _25;

  <bb 16> :
  _26 = sg->entry.tqe_prev;
  _27 = sg->entry.tqe_next;
  *_26 = _27;
  free (sg);

  <bb 17> :
  return;

}



;; Function session_find (session_find, funcdef_no=44, decl_uid=4462, cgraph_uid=45, symbol_order=47)

;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9
;;
;; Loop 1
;;  header 7, latch 6
;;  depth 1, outer 0
;;  nodes: 7 6 3 4
;; 2 succs { 7 }
;; 3 succs { 4 6 }
;; 4 succs { 5 6 }
;; 5 succs { 9 }
;; 6 succs { 7 }
;; 7 succs { 3 8 }
;; 8 succs { 9 }
;; 9 succs { 1 }
struct session * session_find (const char * name)
{
  u_int i;
  struct session * s;
  struct session * D.5039;

  <bb 2> :
  i = 0;
  goto <bb 7>; [INV]

  <bb 3> :
  _1 = sessions.list;
  _2 = (long unsigned int) i;
  _3 = _2 * 8;
  _4 = _1 + _3;
  s = *_4;
  if (s != 0B)
    goto <bb 4>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 4> :
  _5 = s->name;
  _6 = strcmp (_5, name);
  if (_6 == 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  D.5039 = s;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 9>; [INV]

  <bb 6> :
  i = i + 1;

  <bb 7> :
  _7 = sessions.num;
  if (i < _7)
    goto <bb 3>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 8> :
  D.5039 = 0B;

  <bb 9> :
  return D.5039;

}



;; Function session_index (session_index, funcdef_no=45, decl_uid=4472, cgraph_uid=46, symbol_order=48)

;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8
;;
;; Loop 1
;;  header 6, latch 5
;;  depth 1, outer 0
;;  nodes: 6 5 3
;; 2 succs { 6 }
;; 3 succs { 4 5 }
;; 4 succs { 8 }
;; 5 succs { 6 }
;; 6 succs { 3 7 }
;; 7 succs { 8 }
;; 8 succs { 1 }
int session_index (struct session * s, u_int * i)
{
  int D.5043;

  <bb 2> :
  *i = 0;
  goto <bb 6>; [INV]

  <bb 3> :
  _1 = sessions.list;
  _2 = *i;
  _3 = (long unsigned int) _2;
  _4 = _3 * 8;
  _5 = _1 + _4;
  _6 = *_5;
  if (s == _6)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  D.5043 = 0;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 8>; [INV]

  <bb 5> :
  _7 = *i;
  _8 = _7 + 1;
  *i = _8;

  <bb 6> :
  _9 = *i;
  _10 = sessions.num;
  if (_9 < _10)
    goto <bb 3>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  D.5043 = -1;

  <bb 8> :
  return D.5043;

}



;; Function winlink_stack_remove (winlink_stack_remove, funcdef_no=46, decl_uid=4480, cgraph_uid=47, symbol_order=49)

;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12
;;
;; Loop 1
;;  header 11, latch 10
;;  depth 1, outer 0
;;  nodes: 11 10 5
;; 2 succs { 3 4 }
;; 3 succs { 12 }
;; 4 succs { 11 }
;; 5 succs { 6 10 }
;; 6 succs { 7 8 }
;; 7 succs { 9 }
;; 8 succs { 9 }
;; 9 succs { 12 }
;; 10 succs { 11 }
;; 11 succs { 5 12 }
;; 12 succs { 1 }
void winlink_stack_remove (struct winlink_stack * stack, struct winlink * wl)
{
  struct winlink * wl2;

  <bb 2> :
  if (wl == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 12>; [INV]

  <bb 4> :
  wl2 = stack->tqh_first;
  goto <bb 11>; [INV]

  <bb 5> :
  if (wl2 == wl)
    goto <bb 6>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 6> :
  _1 = wl->sentry.tqe_next;
  if (_1 != 0B)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  _2 = wl->sentry.tqe_next;
  _3 = wl->sentry.tqe_prev;
  _2->sentry.tqe_prev = _3;
  goto <bb 9>; [INV]

  <bb 8> :
  _4 = wl->sentry.tqe_prev;
  stack->tqh_last = _4;

  <bb 9> :
  _5 = wl->sentry.tqe_prev;
  _6 = wl->sentry.tqe_next;
  *_5 = _6;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 12>; [INV]

  <bb 10> :
  wl2 = wl2->sentry.tqe_next;

  <bb 11> :
  if (wl2 != 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 12> :
  return;

}



;; Function winlink_stack_push (winlink_stack_push, funcdef_no=47, decl_uid=4491, cgraph_uid=48, symbol_order=50)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8
;; 2 succs { 3 4 }
;; 3 succs { 8 }
;; 4 succs { 5 6 }
;; 5 succs { 7 }
;; 6 succs { 7 }
;; 7 succs { 8 }
;; 8 succs { 1 }
void winlink_stack_push (struct winlink_stack * stack, struct winlink * wl)
{
  <bb 2> :
  if (wl == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 8>; [INV]

  <bb 4> :
  winlink_stack_remove (stack, wl);
  _1 = stack->tqh_first;
  wl->sentry.tqe_next = _1;
  _2 = wl->sentry.tqe_next;
  if (_2 != 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  _3 = stack->tqh_first;
  _4 = &wl->sentry.tqe_next;
  _3->sentry.tqe_prev = _4;
  goto <bb 7>; [INV]

  <bb 6> :
  _5 = &wl->sentry.tqe_next;
  stack->tqh_last = _5;

  <bb 7> :
  stack->tqh_first = wl;
  _6 = &stack->tqh_first;
  wl->sentry.tqe_prev = _6;

  <bb 8> :
  return;

}



;; Function window_destroy (window_destroy, funcdef_no=48, decl_uid=4496, cgraph_uid=49, symbol_order=51)

;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12
;;
;; Loop 1
;;  header 8, multiple latches: 6 7
;;  depth 1, outer 0
;;  nodes: 8 6 7 5 9
;; 2 succs { 3 4 }
;; 3 succs { }
;; 4 succs { 8 }
;; 5 succs { 6 7 }
;; 6 succs { 8 }
;; 7 succs { 8 }
;; 8 succs { 9 10 }
;; 9 succs { 5 10 }
;; 10 succs { 11 12 }
;; 11 succs { 12 }
;; 12 succs { 1 }
void window_destroy (struct window * w)
{
  u_int i;

  <bb 2> :
  _1 = window_index (w, &i);
  if (_1 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  printf ("index not found%s\n", "");
  exit (1);

  <bb 4> :
  _2 = windows.list;
  i.0_3 = i;
  _4 = (long unsigned int) i.0_3;
  _5 = _4 * 8;
  _6 = _2 + _5;
  *_6 = 0B;
  goto <bb 8>; [INV]

  <bb 5> :
  _7 = windows.num;
  if (_7 > 1)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  _8 = windows.num;
  _9 = _8 + 4294967295;
  windows.num = _9;
  goto <bb 8>; [INV]

  <bb 7> :
  _10 = windows.list;
  free (_10);
  windows.num = 0;
  windows.list = 0B;
  windows.space = 0;

  <bb 8> :
  _11 = windows.num;
  if (_11 != 0)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  _12 = windows.list;
  _13 = windows.num;
  _14 = _13 + 4294967295;
  _15 = (long unsigned int) _14;
  _16 = _15 * 8;
  _17 = _12 + _16;
  _18 = *_17;
  if (_18 == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 10> :
  _19 = w->name;
  if (_19 != 0B)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  _20 = w->name;
  free (_20);

  <bb 12> :
  free (w);
  i = {CLOBBER};
  return;

}



;; Function winlink_remove (winlink_remove, funcdef_no=49, decl_uid=4512, cgraph_uid=50, symbol_order=52)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8
;; 2 succs { 3 4 }
;; 3 succs { 4 }
;; 4 succs { 5 6 }
;; 5 succs { }
;; 6 succs { 7 8 }
;; 7 succs { 8 }
;; 8 succs { 1 }
void winlink_remove (struct winlinks * wwl, struct winlink * wl)
{
  struct window * w;

  <bb 2> :
  w = wl->window;
  winlinks_RB_REMOVE (wwl, wl);
  _1 = wl->status_text;
  if (_1 != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  _2 = wl->status_text;
  free (_2);

  <bb 4> :
  free (wl);
  _3 = w->references;
  if (_3 == 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  printf ("bad reference count%s\n", "");
  exit (1);

  <bb 6> :
  _4 = w->references;
  _5 = _4 + 4294967295;
  w->references = _5;
  _6 = w->references;
  if (_6 == 0)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  window_destroy (w);

  <bb 8> :
  return;

}



;; Function session_group_synchronize1 (session_group_synchronize1, funcdef_no=50, decl_uid=4517, cgraph_uid=51, symbol_order=53)

Merging blocks 3 and 16
;; 4 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16
;;
;; Loop 3
;;  header 14, latch 13
;;  depth 1, outer 0
;;  nodes: 14 13
;;
;; Loop 2
;;  header 11, latch 10
;;  depth 1, outer 0
;;  nodes: 11 10 8 9
;;
;; Loop 1
;;  header 6, latch 5
;;  depth 1, outer 0
;;  nodes: 6 5
;; 2 succs { 3 4 }
;; 3 succs { 16 }
;; 4 succs { 6 }
;; 5 succs { 6 }
;; 6 succs { 5 7 }
;; 7 succs { 11 }
;; 8 succs { 9 10 }
;; 9 succs { 10 }
;; 10 succs { 11 }
;; 11 succs { 8 12 }
;; 12 succs { 14 }
;; 13 succs { 14 }
;; 14 succs { 13 15 }
;; 15 succs { 16 }
;; 16 succs { 1 }
void session_group_synchronize1 (struct session * target, struct session * s)
{
  __int128 unsigned D.5079;
  long unsigned int D.5078;
  struct session_alert * sa;
  struct winlink * wl2;
  struct winlink * wl;
  struct winlink_stack old_lastw;
  struct winlinks * ww;
  struct winlinks old_windows;

  <bb 2> :
  ww = &target->windows;
  _1 = ww->rbh_root;
  if (_1 == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  // predicted unlikely by early return (on trees) predictor.
  old_windows = {CLOBBER};
  old_lastw = {CLOBBER};
  goto <bb 16>; [INV]

  <bb 4> :
  _2 = &s->windows;
  D.5078 = MEM <long unsigned int> [(char * {ref-all})_2];
  MEM <long unsigned int> [(char * {ref-all})&old_windows] = D.5078;
  s->windows.rbh_root = 0B;
  wl = winlinks_RB_MINMAX (ww, -1);
  goto <bb 6>; [INV]

  <bb 5> :
  _3 = wl->idx;
  _4 = wl->window;
  _5 = &s->windows;
  winlink_add (_5, _4, _3);
  wl = winlinks_RB_NEXT (wl);

  <bb 6> :
  if (wl != 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  _6 = &s->lastw;
  D.5079 = MEM <__int128 unsigned> [(char * {ref-all})_6];
  MEM <__int128 unsigned> [(char * {ref-all})&old_lastw] = D.5079;
  s->lastw.tqh_first = 0B;
  _7 = &s->lastw.tqh_first;
  s->lastw.tqh_last = _7;
  wl = old_lastw.tqh_first;
  goto <bb 11>; [INV]

  <bb 8> :
  _8 = wl->idx;
  _9 = &s->windows;
  wl2 = winlink_find_by_index (_9, _8);
  if (wl2 != 0B)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  wl2->sentry.tqe_next = 0B;
  _10 = s->lastw.tqh_last;
  wl2->sentry.tqe_prev = _10;
  _11 = s->lastw.tqh_last;
  *_11 = wl2;
  _12 = &wl2->sentry.tqe_next;
  s->lastw.tqh_last = _12;

  <bb 10> :
  wl = wl->sentry.tqe_next;

  <bb 11> :
  if (wl != 0B)
    goto <bb 8>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 12> :
  _13 = s->lastw.tqh_first;
  s->curw = _13;
  goto <bb 14>; [INV]

  <bb 13> :
  wl = old_windows.rbh_root;
  winlink_remove (&old_windows, wl);

  <bb 14> :
  _14 = old_windows.rbh_root;
  if (_14 != 0B)
    goto <bb 13>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 15> :
  old_windows = {CLOBBER};
  old_lastw = {CLOBBER};

  <bb 16> :
  return;

}



;; Function session_group_synchronize_to (session_group_synchronize_to, funcdef_no=51, decl_uid=4544, cgraph_uid=52, symbol_order=54)

;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9
;;
;; Loop 1
;;  header 7, latch 6
;;  depth 1, outer 0
;;  nodes: 7 6 5
;; 2 succs { 3 4 }
;; 3 succs { 9 }
;; 4 succs { 7 }
;; 5 succs { 8 6 }
;; 6 succs { 7 }
;; 7 succs { 5 8 }
;; 8 succs { 9 }
;; 9 succs { 1 }
void session_group_synchronize_to (struct session * s)
{
  struct session * target;
  struct session_group * sg;

  <bb 2> :
  sg = session_group_find (s);
  if (sg == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 9>; [INV]

  <bb 4> :
  target = 0B;
  target = sg->sessions.tqh_first;
  goto <bb 7>; [INV]

  <bb 5> :
  if (target != s)
    goto <bb 8>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 6> :
  target = target->gentry.tqe_next;

  <bb 7> :
  if (target != 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 8> :
  session_group_synchronize1 (target, s);

  <bb 9> :
  return;

}



;; Function session_group_synchronize_from (session_group_synchronize_from, funcdef_no=52, decl_uid=4553, cgraph_uid=53, symbol_order=55)

;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9
;;
;; Loop 1
;;  header 8, latch 7
;;  depth 1, outer 0
;;  nodes: 8 7 5 6
;; 2 succs { 3 4 }
;; 3 succs { 9 }
;; 4 succs { 8 }
;; 5 succs { 6 7 }
;; 6 succs { 7 }
;; 7 succs { 8 }
;; 8 succs { 5 9 }
;; 9 succs { 1 }
void session_group_synchronize_from (struct session * target)
{
  struct session * s;
  struct session_group * sg;

  <bb 2> :
  sg = session_group_find (target);
  if (sg == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 9>; [INV]

  <bb 4> :
  s = sg->sessions.tqh_first;
  goto <bb 8>; [INV]

  <bb 5> :
  if (s != target)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  session_group_synchronize1 (target, s);

  <bb 7> :
  s = s->gentry.tqe_next;

  <bb 8> :
  if (s != 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 9> :
  return;

}



;; Function session_destroy (session_destroy, funcdef_no=53, decl_uid=4562, cgraph_uid=54, symbol_order=56)

Removing basic block 13
;; 4 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
;;
;; Loop 3
;;  header 14, latch 13
;;  depth 1, outer 0
;;  nodes: 14 13
;;
;; Loop 2
;;  header 12, latch 11
;;  depth 1, outer 0
;;  nodes: 12 11
;;
;; Loop 1
;;  header 8, multiple latches: 6 7
;;  depth 1, outer 0
;;  nodes: 8 6 7 5 9
;; 2 succs { 3 4 }
;; 3 succs { }
;; 4 succs { 8 }
;; 5 succs { 6 7 }
;; 6 succs { 8 }
;; 7 succs { 8 }
;; 8 succs { 9 10 }
;; 9 succs { 5 10 }
;; 10 succs { 12 }
;; 11 succs { 12 }
;; 12 succs { 11 14 }
;; 13 succs { 14 }
;; 14 succs { 13 15 }
;; 15 succs { 1 }
void session_destroy (struct session * s)
{
  u_int i;

  <bb 2> :
  _1 = s->name;
  printf ("session %s destroyed\n", _1);
  _2 = session_index (s, &i);
  if (_2 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  printf ("session not found%s\n", "");
  exit (1);

  <bb 4> :
  _3 = sessions.list;
  i.1_4 = i;
  _5 = (long unsigned int) i.1_4;
  _6 = _5 * 8;
  _7 = _3 + _6;
  *_7 = 0B;
  goto <bb 8>; [INV]

  <bb 5> :
  _8 = sessions.num;
  if (_8 > 1)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  _9 = sessions.num;
  _10 = _9 + 4294967295;
  sessions.num = _10;
  goto <bb 8>; [INV]

  <bb 7> :
  _11 = sessions.list;
  free (_11);
  sessions.num = 0;
  sessions.list = 0B;
  sessions.space = 0;

  <bb 8> :
  _12 = sessions.num;
  if (_12 != 0)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  _13 = sessions.list;
  _14 = sessions.num;
  _15 = _14 + 4294967295;
  _16 = (long unsigned int) _15;
  _17 = _16 * 8;
  _18 = _13 + _17;
  _19 = *_18;
  if (_19 == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 10> :
  session_group_remove (s);
  goto <bb 12>; [INV]

  <bb 11> :
  _20 = s->lastw.tqh_first;
  _21 = &s->lastw;
  winlink_stack_remove (_21, _20);

  <bb 12> :
  _22 = s->lastw.tqh_first;
  if (_22 != 0B)
    goto <bb 11>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 13> :
  _23 = s->windows.rbh_root;
  _24 = &s->windows;
  winlink_remove (_24, _23);

  <bb 14> :
  _25 = s->windows.rbh_root;
  if (_25 != 0B)
    goto <bb 13>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 15> :
  _26 = s->name;
  free (_26);
  free (s);
  i = {CLOBBER};
  return;

}



;; Function session_detach (session_detach, funcdef_no=54, decl_uid=4584, cgraph_uid=55, symbol_order=57)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5
;; 2 succs { 3 4 }
;; 3 succs { 5 }
;; 4 succs { 5 }
;; 5 succs { 1 }
int session_detach (struct session * s, struct winlink * wl)
{
  int D.5099;

  <bb 2> :
  _1 = &s->lastw;
  winlink_stack_remove (_1, wl);
  _2 = &s->windows;
  winlink_remove (_2, wl);
  session_group_synchronize_from (s);
  _3 = s->windows.rbh_root;
  if (_3 == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  session_destroy (s);
  D.5099 = 1;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 5>; [INV]

  <bb 4> :
  D.5099 = 0;

  <bb 5> :
  return D.5099;

}



;; Function server_destroy_session_group (server_destroy_session_group, funcdef_no=55, decl_uid=4587, cgraph_uid=56, symbol_order=58)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8
;; 2 succs { 3 4 }
;; 3 succs { 8 }
;; 4 succs { 5 6 }
;; 5 succs { 7 }
;; 6 succs { 7 }
;; 7 succs { 8 }
;; 8 succs { 1 }
void server_destroy_session_group (struct session * s)
{
  struct session_group * sg;

  <bb 2> :
  sg = session_group_find (s);
  if (sg == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 8>; [INV]

  <bb 4> :
  _1 = sg->entry.tqe_next;
  if (_1 != 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  _2 = sg->entry.tqe_next;
  _3 = sg->entry.tqe_prev;
  _2->entry.tqe_prev = _3;
  goto <bb 7>; [INV]

  <bb 6> :
  _4 = sg->entry.tqe_prev;
  session_groups.tqh_last = _4;

  <bb 7> :
  _5 = sg->entry.tqe_prev;
  _6 = sg->entry.tqe_next;
  *_5 = _6;
  free (sg);

  <bb 8> :
  return;

}



;; Function server_kill_window (server_kill_window, funcdef_no=56, decl_uid=4593, cgraph_uid=57, symbol_order=59)

Removing basic block 6
;; 3 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11
;;
;; Loop 1
;;  header 10, latch 9
;;  depth 1, outer 0
;;  nodes: 10 9 5 7 8 4 6 3
;;
;; Loop 2
;;  header 8, latch 6
;;  depth 2, outer 1
;;  nodes: 8 6
;; 2 succs { 10 }
;; 3 succs { 5 4 }
;; 4 succs { 5 8 }
;; 5 succs { 9 }
;; 6 succs { 7 8 }
;; 7 succs { 9 }
;; 8 succs { 6 9 }
;; 9 succs { 10 }
;; 10 succs { 3 11 }
;; 11 succs { 1 }
void server_kill_window (struct window * w)
{
  u_int i;
  struct winlink * wl;
  struct session * s;

  <bb 2> :
  i = 0;
  goto <bb 10>; [INV]

  <bb 3> :
  _1 = sessions.list;
  _2 = (long unsigned int) i;
  _3 = _2 * 8;
  _4 = _1 + _3;
  s = *_4;
  if (s == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 4> :
  _5 = session_has (s, w);
  if (_5 == 0)
    goto <bb 5>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 5> :
  // predicted unlikely by continue predictor.
  goto <bb 9>; [INV]

  <bb 6> :
  _6 = session_detach (s, wl);
  if (_6 != 0)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  server_destroy_session_group (s);
  goto <bb 9>; [INV]

  <bb 8> :
  _7 = &s->windows;
  wl = winlink_find_by_window (_7, w);
  if (wl != 0B)
    goto <bb 6>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 9> :
  i = i + 1;

  <bb 10> :
  _8 = sessions.num;
  if (i < _8)
    goto <bb 3>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 11> :
  return;

}



;; Function session_select (session_select, funcdef_no=57, decl_uid=4607, cgraph_uid=58, symbol_order=60)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7
;; 2 succs { 3 4 }
;; 3 succs { 7 }
;; 4 succs { 5 6 }
;; 5 succs { 7 }
;; 6 succs { 7 }
;; 7 succs { 1 }
int session_select (struct session * s, int idx)
{
  struct winlink * wl;
  int D.5114;

  <bb 2> :
  _1 = &s->windows;
  wl = winlink_find_by_index (_1, idx);
  if (wl == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  D.5114 = -1;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 7>; [INV]

  <bb 4> :
  _2 = s->curw;
  if (wl == _2)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  D.5114 = 1;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 7>; [INV]

  <bb 6> :
  _3 = &s->lastw;
  winlink_stack_remove (_3, wl);
  _4 = s->curw;
  _5 = &s->lastw;
  winlink_stack_push (_5, _4);
  s->curw = wl;
  D.5114 = 0;

  <bb 7> :
  return D.5114;

}



;; Function join_pane_exec (join_pane_exec, funcdef_no=58, decl_uid=4611, cgraph_uid=59, symbol_order=61)

Merging blocks 9 and 10
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9
;; 2 succs { 3 4 }
;; 3 succs { 9 }
;; 4 succs { 5 6 }
;; 5 succs { 9 }
;; 6 succs { 7 8 }
;; 7 succs { 9 }
;; 8 succs { 9 }
;; 9 succs { 1 }
int join_pane_exec ()
{
  struct window * dst_w;
  struct window * src_w;
  struct winlink * dst_wl;
  struct winlink * src_wl;
  struct session * dst_s;
  int D.5120;

  <bb 2> :
  dst_wl = cmd_find_pane (0, &dst_s);
  if (dst_wl == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  D.5120 = -1;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 9>; [INV]

  <bb 4> :
  dst_w = dst_wl->window;
  src_wl = cmd_find_pane (1, 0B);
  if (src_wl == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  D.5120 = -1;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 9>; [INV]

  <bb 6> :
  src_w = src_wl->window;
  if (src_w == dst_w)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  __builtin_puts (&"can\'t join a pane to its own window"[0]);
  D.5120 = -1;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 9>; [INV]

  <bb 8> :
  server_kill_window (src_w);
  _1 = dst_wl->idx;
  dst_s.2_2 = dst_s;
  session_select (dst_s.2_2, _1);
  D.5120 = 0;

  <bb 9> :
  dst_s = {CLOBBER};
  return D.5120;

}



;; Function window_create1 (window_create1, funcdef_no=59, decl_uid=4620, cgraph_uid=60, symbol_order=62)

Removing basic block 14
Merging blocks 18 and 19
;; 3 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17
;;
;; Loop 2
;;  header 15, latch 14
;;  depth 1, outer 0
;;  nodes: 15 14
;;
;; Loop 1
;;  header 6, latch 5
;;  depth 1, outer 0
;;  nodes: 6 5 3
;; 2 succs { 6 }
;; 3 succs { 4 5 }
;; 4 succs { 7 }
;; 5 succs { 6 }
;; 6 succs { 3 7 }
;; 7 succs { 8 17 }
;; 8 succs { 9 10 }
;; 9 succs { }
;; 10 succs { 11 12 }
;; 11 succs { }
;; 12 succs { 13 15 }
;; 13 succs { 15 }
;; 14 succs { 15 }
;; 15 succs { 14 16 }
;; 16 succs { 17 }
;; 17 succs { 1 }
struct window * window_create1 (u_int sx, u_int sy)
{
  u_int i;
  struct window * w;
  struct window * D.5137;

  <bb 2> :
  w = malloc (88);
  w->name = 0B;
  w->flags = 0;
  w->active = 0B;
  w->lastlayout = -1;
  w->layout_root = 0B;
  w->sx = sx;
  w->sy = sy;
  i = 0;
  goto <bb 6>; [INV]

  <bb 3> :
  _1 = windows.list;
  _2 = (long unsigned int) i;
  _3 = _2 * 8;
  _4 = _1 + _3;
  _5 = *_4;
  if (_5 == 0B)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  _6 = windows.list;
  _7 = (long unsigned int) i;
  _8 = _7 * 8;
  _9 = _6 + _8;
  *_9 = w;
  goto <bb 7>; [INV]

  <bb 5> :
  i = i + 1;

  <bb 6> :
  _10 = windows.num;
  if (i < _10)
    goto <bb 3>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  _11 = windows.num;
  if (i == _11)
    goto <bb 8>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 8> :
  _12 = windows.num;
  if (_12 > 1073741823)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  printf ("number too big%s", "");
  exit (1);

  <bb 10> :
  _13 = windows.num;
  _14 = _13 + 1;
  _15 = 1073741824 / _14;
  if (_15 <= 7)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  printf ("size too big%s", "");
  exit (1);

  <bb 12> :
  _16 = windows.space;
  if (_16 == 0)
    goto <bb 13>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 13> :
  windows.space = 80;
  _17 = windows.space;
  _18 = windows.list;
  _19 = xrealloc (_18, 1, _17);
  windows.list = _19;
  goto <bb 15>; [INV]

  <bb 14> :
  _20 = windows.space;
  _21 = windows.list;
  _22 = xrealloc (_21, 2, _20);
  windows.list = _22;
  _23 = windows.space;
  _24 = _23 * 2;
  windows.space = _24;

  <bb 15> :
  _25 = windows.space;
  _26 = windows.num;
  _27 = _26 + 1;
  _28 = (long unsigned int) _27;
  _29 = _28 * 8;
  if (_25 <= _29)
    goto <bb 14>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 16> :
  _30 = windows.list;
  _31 = windows.num;
  _32 = (long unsigned int) _31;
  _33 = _32 * 8;
  _34 = _30 + _33;
  *_34 = w;
  _35 = windows.num;
  _36 = _35 + 1;
  windows.num = _36;

  <bb 17> :
  w->references = 0;
  D.5137 = w;
  return D.5137;

}



;; Function session_attach (session_attach, funcdef_no=60, decl_uid=4641, cgraph_uid=61, symbol_order=63)

Merging blocks 4 and 5
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4
;; 2 succs { 3 4 }
;; 3 succs { 4 }
;; 4 succs { 1 }
struct winlink * session_attach (struct session * s, struct window * w, int idx, char * * cause)
{
  struct winlink * wl;
  struct winlink * D.5141;

  <bb 2> :
  _1 = &s->windows;
  wl = winlink_add (_1, w, idx);
  if (wl == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  printf ("index in use: %d\n", idx);

  <bb 4> :
  session_group_synchronize_from (s);
  D.5141 = wl;
  return D.5141;

}



;; Function session_new (session_new, funcdef_no=61, decl_uid=4650, cgraph_uid=62, symbol_order=64)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5
;; 2 succs { 3 4 }
;; 3 succs { 5 }
;; 4 succs { 5 }
;; 5 succs { 1 }
struct winlink * session_new (struct session * s, const char * name, const char * cmd, const char * cwd, int idx, char * * cause)
{
  u_int hlimit;
  const char * shell;
  struct window * w;
  struct winlink * D.5145;

  <bb 2> :
  _1 = s->sy;
  _2 = s->sx;
  w = window_create1 (_2, _1);
  if (w == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  D.5145 = 0B;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 5>; [INV]

  <bb 4> :
  D.5145 = session_attach (s, w, idx, cause);

  <bb 5> :
  return D.5145;

}



;; Function session_create (session_create, funcdef_no=62, decl_uid=4664, cgraph_uid=63, symbol_order=65)

Removing basic block 14
;; 3 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24
;;
;; Loop 2
;;  header 15, latch 14
;;  depth 1, outer 0
;;  nodes: 15 14
;;
;; Loop 1
;;  header 6, latch 5
;;  depth 1, outer 0
;;  nodes: 6 5 3
;; 2 succs { 6 }
;; 3 succs { 4 5 }
;; 4 succs { 7 }
;; 5 succs { 6 }
;; 6 succs { 3 7 }
;; 7 succs { 8 17 }
;; 8 succs { 9 10 }
;; 9 succs { }
;; 10 succs { 11 12 }
;; 11 succs { }
;; 12 succs { 13 15 }
;; 13 succs { 15 }
;; 14 succs { 15 }
;; 15 succs { 14 16 }
;; 16 succs { 17 }
;; 17 succs { 18 19 }
;; 18 succs { }
;; 19 succs { 20 23 }
;; 20 succs { 21 22 }
;; 21 succs { 24 }
;; 22 succs { 23 }
;; 23 succs { 24 }
;; 24 succs { 1 }
struct session * session_create (const char * name, const char * cmd, const char * cwd, struct environ * env, struct termios * tio, int idx, u_int sx, u_int sy, char * * cause)
{
  u_int i;
  struct session * s;
  struct session * D.5163;

  <bb 2> :
  s = malloc (112);
  s->references = 0;
  s->flags = 0;
  s->curw = 0B;
  s->lastw.tqh_first = 0B;
  _1 = &s->lastw.tqh_first;
  s->lastw.tqh_last = _1;
  s->windows.rbh_root = 0B;
  s->tio = 0B;
  s->sx = sx;
  s->sy = sy;
  i = 0;
  goto <bb 6>; [INV]

  <bb 3> :
  _2 = sessions.list;
  _3 = (long unsigned int) i;
  _4 = _3 * 8;
  _5 = _2 + _4;
  _6 = *_5;
  if (_6 == 0B)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  _7 = sessions.list;
  _8 = (long unsigned int) i;
  _9 = _8 * 8;
  _10 = _7 + _9;
  *_10 = s;
  goto <bb 7>; [INV]

  <bb 5> :
  i = i + 1;

  <bb 6> :
  _11 = sessions.num;
  if (i < _11)
    goto <bb 3>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  _12 = sessions.num;
  if (i == _12)
    goto <bb 8>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 8> :
  _13 = sessions.num;
  if (_13 > 1073741823)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  printf ("number too big%s", "");
  exit (1);

  <bb 10> :
  _14 = sessions.num;
  _15 = _14 + 1;
  _16 = 1073741824 / _15;
  if (_16 <= 7)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  printf ("size too big%s", "");
  exit (1);

  <bb 12> :
  _17 = sessions.space;
  if (_17 == 0)
    goto <bb 13>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 13> :
  sessions.space = 80;
  _18 = sessions.space;
  _19 = sessions.list;
  _20 = xrealloc (_19, 1, _18);
  sessions.list = _20;
  goto <bb 15>; [INV]

  <bb 14> :
  _21 = sessions.space;
  _22 = sessions.list;
  _23 = xrealloc (_22, 2, _21);
  sessions.list = _23;
  _24 = sessions.space;
  _25 = _24 * 2;
  sessions.space = _25;

  <bb 15> :
  _26 = sessions.space;
  _27 = sessions.num;
  _28 = _27 + 1;
  _29 = (long unsigned int) _28;
  _30 = _29 * 8;
  if (_26 <= _30)
    goto <bb 14>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 16> :
  _31 = sessions.list;
  _32 = sessions.num;
  _33 = (long unsigned int) _32;
  _34 = _33 * 8;
  _35 = _31 + _34;
  *_35 = s;
  _36 = sessions.num;
  _37 = _36 + 1;
  sessions.num = _37;

  <bb 17> :
  if (name == 0B)
    goto <bb 18>; [INV]
  else
    goto <bb 19>; [INV]

  <bb 18> :
  printf ("no name%s\n", "");
  exit (1);

  <bb 19> :
  _38 = strdup (name);
  s->name = _38;
  if (cmd != 0B)
    goto <bb 20>; [INV]
  else
    goto <bb 23>; [INV]

  <bb 20> :
  _39 = session_new (s, 0B, cmd, cwd, idx, cause);
  if (_39 == 0B)
    goto <bb 21>; [INV]
  else
    goto <bb 22>; [INV]

  <bb 21> :
  session_destroy (s);
  D.5163 = 0B;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 24>; [INV]

  <bb 22> :
  _40 = s->windows.rbh_root;
  _41 = _40->idx;
  session_select (s, _41);

  <bb 23> :
  _42 = s->name;
  printf ("session %s created\n", _42);
  D.5163 = s;

  <bb 24> :
  return D.5163;

}



;; Function main (main, funcdef_no=63, decl_uid=4687, cgraph_uid=64, symbol_order=66)

Removing basic block 19
Merging blocks 17 and 18
Merging blocks 17 and 20
;; 3 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17
;;
;; Loop 2
;;  header 16, latch 15
;;  depth 1, outer 0
;;  nodes: 16 15
;;
;; Loop 1
;;  header 13, latch 12
;;  depth 1, outer 0
;;  nodes: 13 12 10 11 8 9 7 5 6 3 4
;; 2 succs { 13 }
;; 3 succs { 4 6 }
;; 4 succs { 5 6 }
;; 5 succs { 7 }
;; 6 succs { 7 }
;; 7 succs { 8 9 }
;; 8 succs { 10 }
;; 9 succs { 10 }
;; 10 succs { 11 12 }
;; 11 succs { 12 }
;; 12 succs { 13 }
;; 13 succs { 3 14 }
;; 14 succs { 16 }
;; 15 succs { 16 }
;; 16 succs { 15 17 }
;; 17 succs { 1 }
int main (int argc, char * * argv)
{
  int i;
  int sy;
  int sx;
  int idx;
  char * cause;
  char * name;
  char * cmd;
  char * target;
  struct window * w;
  struct session * groupwith;
  struct session * s;
  int D.5174;

  <bb 2> :
  idx = 0;
  windows.num = 0;
  windows.list = 0B;
  windows.space = 0;
  sessions.num = 0;
  sessions.list = 0B;
  sessions.space = 0;
  session_groups.tqh_first = 0B;
  session_groups.tqh_last = &session_groups.tqh_first;
  i = 0;
  goto <bb 13>; [INV]

  <bb 3> :
  _1 = (long unsigned int) i;
  _2 = _1 * 8;
  _3 = argv + _2;
  _4 = *_3;
  _5 = *_4;
  if (_5 == 116)
    goto <bb 4>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 4> :
  if (i > 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  _6 = (long unsigned int) i;
  _7 = _6 * 8;
  _8 = _7 + 18446744073709551608;
  _9 = argv + _8;
  _10 = *_9;
  target = strdup (_10);
  goto <bb 7>; [INV]

  <bb 6> :
  target = 0B;

  <bb 7> :
  groupwith = session_find (target);
  if (target == 0B)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  cmd = strdup ("cmd");
  goto <bb 10>; [INV]

  <bb 9> :
  cmd = 0B;

  <bb 10> :
  free (target);
  _11 = (long unsigned int) i;
  _12 = _11 * 8;
  _13 = argv + _12;
  _14 = *_13;
  name = strdup (_14);
  sy.3_15 = (unsigned int) sy;
  sx.4_16 = (unsigned int) sx;
  idx.5_17 = idx;
  idx = idx.5_17 + 1;
  s = session_create (name, cmd, "cwd", 0B, 0B, idx.5_17, sx.4_16, sy.3_15, &cause);
  sy.6_18 = (unsigned int) sy;
  sx.7_19 = (unsigned int) sx;
  w = window_create1 (sx.7_19, sy.6_18);
  idx.8_20 = idx;
  idx = idx.8_20 + 1;
  session_attach (s, w, idx.8_20, &cause);
  free (cmd);
  if (groupwith != 0B)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  session_group_add (groupwith, s);
  session_group_synchronize_to (s);
  _21 = s->windows.rbh_root;
  _22 = _21->idx;
  session_select (s, _22);

  <bb 12> :
  i = i + 1;

  <bb 13> :
  if (i < argc)
    goto <bb 3>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 14> :
  join_pane_exec ();
  goto <bb 16>; [INV]

  <bb 15> :
  _23 = sessions.list;
  _24 = *_23;
  session_destroy (_24);

  <bb 16> :
  _25 = sessions.num;
  if (_25 != 0)
    goto <bb 15>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 17> :
  D.5174 = 0;
  cause = {CLOBBER};
  return D.5174;

}


