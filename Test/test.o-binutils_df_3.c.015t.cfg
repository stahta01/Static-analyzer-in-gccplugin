
;; Function discard_cleanups (discard_cleanups, funcdef_no=22, decl_uid=3018, cgraph_uid=23, symbol_order=27)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
void discard_cleanups (struct cleanup * old_chain)
{
  <bb 2> :
  discard_my_cleanups (&cleanup_chain, old_chain);
  return;

}



;; Function discard_final_cleanups (discard_final_cleanups, funcdef_no=23, decl_uid=3023, cgraph_uid=24, symbol_order=28)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
void discard_final_cleanups (struct cleanup * old_chain)
{
  <bb 2> :
  discard_my_cleanups (&final_cleanup_chain, old_chain);
  return;

}



;; Function discard_my_cleanups (discard_my_cleanups, funcdef_no=24, decl_uid=3021, cgraph_uid=25, symbol_order=29)

;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7
;;
;; Loop 1
;;  header 6, latch 5
;;  depth 1, outer 0
;;  nodes: 6 5 3 4
;; 2 succs { 6 }
;; 3 succs { 4 5 }
;; 4 succs { 5 }
;; 5 succs { 6 }
;; 6 succs { 3 7 }
;; 7 succs { 1 }
void discard_my_cleanups (struct cleanup * * pmy_chain, struct cleanup * old_chain)
{
  struct cleanup * ptr;

  <bb 2> :
  goto <bb 6>; [INV]

  <bb 3> :
  _1 = ptr->next;
  *pmy_chain = _1;
  _2 = ptr->free_arg;
  if (_2 != 0B)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  _3 = ptr->free_arg;
  _4 = ptr->arg;
  _3 (_4);

  <bb 5> :
  free (ptr);

  <bb 6> :
  ptr = *pmy_chain;
  if (ptr != old_chain)
    goto <bb 3>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  _5 = ptr->arg;
  printf ("freearg: %x\n", _5);
  return;

}



;; Function do_cleanups (do_cleanups, funcdef_no=26, decl_uid=3028, cgraph_uid=27, symbol_order=31)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
void do_cleanups (struct cleanup * old_chain)
{
  <bb 2> :
  do_my_cleanups (&cleanup_chain, old_chain);
  return;

}



;; Function do_my_cleanups (do_my_cleanups, funcdef_no=25, decl_uid=3026, cgraph_uid=26, symbol_order=30)

;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7
;;
;; Loop 1
;;  header 6, latch 5
;;  depth 1, outer 0
;;  nodes: 6 5 3 4
;; 2 succs { 6 }
;; 3 succs { 4 5 }
;; 4 succs { 5 }
;; 5 succs { 6 }
;; 6 succs { 3 7 }
;; 7 succs { 1 }
void do_my_cleanups (struct cleanup * * pmy_chain, struct cleanup * old_chain)
{
  struct cleanup * ptr;

  <bb 2> :
  goto <bb 6>; [INV]

  <bb 3> :
  _1 = ptr->next;
  *pmy_chain = _1;
  _2 = ptr->function;
  _3 = ptr->arg;
  _2 (_3);
  __builtin_puts (&"cleanup!!!!! ========="[0]);
  _4 = ptr->arg;
  printf ("%x\n", _4);
  _5 = ptr->free_arg;
  if (_5 != 0B)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  _6 = ptr->free_arg;
  _7 = ptr->arg;
  _6 (_7);

  <bb 5> :
  free (ptr);

  <bb 6> :
  ptr = *pmy_chain;
  if (ptr != old_chain)
    goto <bb 3>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  return;

}



;; Function make_cleanup (make_cleanup, funcdef_no=29, decl_uid=3041, cgraph_uid=30, symbol_order=34)

Merging blocks 2 and 3
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
struct cleanup * make_cleanup (void (*<T59c>) (void *) function, void * arg)
{
  struct cleanup * D.3318;

  <bb 2> :
  D.3318 = make_my_cleanup (&cleanup_chain, function, arg);
  return D.3318;

}



;; Function make_my_cleanup (make_my_cleanup, funcdef_no=28, decl_uid=3038, cgraph_uid=29, symbol_order=33)

Merging blocks 2 and 3
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
struct cleanup * make_my_cleanup (struct cleanup * * pmy_chain, void (*<T59c>) (void *) function, void * arg)
{
  struct cleanup * D.3320;

  <bb 2> :
  D.3320 = make_my_cleanup2 (pmy_chain, function, arg, 0B);
  return D.3320;

}



;; Function make_my_cleanup2 (make_my_cleanup2, funcdef_no=27, decl_uid=3034, cgraph_uid=28, symbol_order=32)

Merging blocks 4 and 5
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4
;; 2 succs { 3 4 }
;; 3 succs { }
;; 4 succs { 1 }
struct cleanup * make_my_cleanup2 (struct cleanup * * pmy_chain, void (*<T59c>) (void *) function, void * arg, void (*<Tee>) (void *) free_arg)
{
  struct cleanup * old_chain;
  struct cleanup * new;
  struct cleanup * D.3324;

  <bb 2> :
  new = malloc (32);
  old_chain = *pmy_chain;
  _1 = *pmy_chain;
  new->next = _1;
  new->function = function;
  new->free_arg = free_arg;
  new->arg = arg;
  *pmy_chain = new;
  if (old_chain == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  exit (1);

  <bb 4> :
  D.3324 = old_chain;
  return D.3324;

}



;; Function lrealpath (lrealpath, funcdef_no=30, decl_uid=3262, cgraph_uid=31, symbol_order=37)

Merging blocks 2 and 3
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
char * lrealpath (const char * filename)
{
  char * D.3326;

  <bb 2> :
  D.3326 = strdup (filename);
  return D.3326;

}



;; Function main (main, funcdef_no=32, decl_uid=3310, cgraph_uid=33, symbol_order=39)

Removing basic block 4
Merging blocks 2 and 3
Merging blocks 2 and 5
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
int main ()
{
  struct objfile objfile;
  int D.3328;

  <bb 2> :
  find_separate_debug_file (&objfile);
  D.3328 = 0;
  objfile = {CLOBBER};
  return D.3328;

}



;; Function find_separate_debug_file (find_separate_debug_file, funcdef_no=31, decl_uid=3266, cgraph_uid=32, symbol_order=38)

Merging blocks 35 and 36
;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35
;;
;; Loop 1
;;  header 13, latch 12
;;  depth 1, outer 0
;;  nodes: 13 12 11
;; 2 succs { 3 8 }
;; 3 succs { 4 6 }
;; 4 succs { 5 6 }
;; 5 succs { 8 }
;; 6 succs { 7 8 }
;; 7 succs { 35 }
;; 8 succs { 9 10 }
;; 9 succs { 35 }
;; 10 succs { 13 }
;; 11 succs { 14 12 }
;; 12 succs { 13 }
;; 13 succs { 11 14 }
;; 14 succs { 15 17 }
;; 15 succs { 16 17 }
;; 16 succs { 18 }
;; 17 succs { 18 }
;; 18 succs { 19 21 }
;; 19 succs { 20 21 }
;; 20 succs { 21 }
;; 21 succs { 22 23 }
;; 22 succs { 35 }
;; 23 succs { 24 25 }
;; 24 succs { 35 }
;; 25 succs { 26 27 }
;; 26 succs { 35 }
;; 27 succs { 28 32 }
;; 28 succs { 29 32 }
;; 29 succs { 30 32 }
;; 30 succs { 31 32 }
;; 31 succs { 35 }
;; 32 succs { 33 34 }
;; 33 succs { 34 }
;; 34 succs { 35 }
;; 35 succs { 1 }
char * find_separate_debug_file (struct objfile * objfile)
{
  char * D.3376;
  long unsigned int D.3375;
  char * D.3374;
  long unsigned int D.3373;
  char * D.3372;
  long unsigned int D.3371;
  char * D.3370;
  long unsigned int D.3369;
  char * build_id_name;
  struct build_id * build_id;
  int i;
  long unsigned int crc32;
  bfd_size_type debuglink_size;
  char * canon_name;
  char * name_copy;
  char * debugfile;
  char * dir;
  char * basename;
  struct asection * sect;
  int iftmp.0;
  char * D.3339;

  <bb 2> :
  _1 = objfile->obfd;
  _2 = build_id_bfd_get (_1);
  _3 = (long int) _2;
  build_id = (struct build_id *) _3;
  if (build_id != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 3> :
  _4 = build_id_to_debug_filename (build_id);
  _5 = (long int) _4;
  build_id_name = (char *) _5;
  free (build_id);
  if (build_id_name != 0B)
    goto <bb 4>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 4> :
  _6 = objfile->name;
  _7 = strcmp (build_id_name, _6);
  if (_7 == 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  _8 = _ ("\"%s\": separate debug info file has no debug info");
  warning (_8, build_id_name);
  free (build_id_name);
  goto <bb 8>; [INV]

  <bb 6> :
  if (build_id_name != 0B)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  D.3339 = build_id_name;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 35>; [INV]

  <bb 8> :
  _9 = get_debug_link_info (objfile, &crc32);
  _10 = (long int) _9;
  basename = (char *) _10;
  if (basename == 0B)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  D.3339 = 0B;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 35>; [INV]

  <bb 10> :
  _11 = objfile->name;
  dir = strdup (_11);
  _12 = strlen (dir);
  _13 = (unsigned int) _12;
  _14 = _13 + 4294967295;
  i = (int) _14;
  goto <bb 13>; [INV]

  <bb 11> :
  _15 = (sizetype) i;
  _16 = dir + _15;
  _17 = *_16;
  _18 = (int) _17;
  _19 = IS_DIR_SEPARATOR (_18);
  if (_19 != 0)
    goto <bb 14>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 12> :
  i = i + -1;

  <bb 13> :
  if (i >= 0)
    goto <bb 11>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 14> :
  if (i >= 0)
    goto <bb 15>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 15> :
  _20 = (sizetype) i;
  _21 = dir + _20;
  _22 = *_21;
  _23 = (int) _22;
  _24 = IS_DIR_SEPARATOR (_23);
  if (_24 != 0)
    goto <bb 16>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 16> :
  iftmp.0 = 1;
  goto <bb 18>; [INV]

  <bb 17> :
  iftmp.0 = 0;

  <bb 18> :
  gdb_assert (iftmp.0);
  _25 = (sizetype) i;
  _26 = _25 + 1;
  _27 = dir + _26;
  *_27 = 0;
  canon_name = lrealpath (dir);
  _28 = strlen (dir);
  i = (int) _28;
  if (canon_name != 0B)
    goto <bb 19>; [INV]
  else
    goto <bb 21>; [INV]

  <bb 19> :
  _29 = strlen (canon_name);
  _30 = (long unsigned int) i;
  if (_29 > _30)
    goto <bb 20>; [INV]
  else
    goto <bb 21>; [INV]

  <bb 20> :
  _31 = strlen (canon_name);
  i = (int) _31;

  <bb 21> :
  debug_file_directory.1_32 = debug_file_directory;
  _33 = strlen (debug_file_directory.1_32);
  _34 = (long unsigned int) i;
  _35 = _33 + _34;
  _36 = strlen (basename);
  _37 = _35 + _36;
  _38 = _37 + 9;
  debugfile = __builtin_alloca (_38);
  strcpy (debugfile, dir);
  strcat (debugfile, basename);
  crc32.2_39 = crc32;
  _40 = separate_debug_file_exists (debugfile, crc32.2_39);
  if (_40 != 0)
    goto <bb 22>; [INV]
  else
    goto <bb 23>; [INV]

  <bb 22> :
  free (basename);
  free (dir);
  free (canon_name);
  D.3339 = strdup (debugfile);
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 35>; [INV]

  <bb 23> :
  strcpy (debugfile, dir);
  D.3369 = __builtin_strlen (debugfile);
  D.3370 = debugfile + D.3369;
  __builtin_memcpy (D.3370, ".debug", 7);
  D.3371 = __builtin_strlen (debugfile);
  D.3372 = debugfile + D.3371;
  __builtin_memcpy (D.3372, "/", 2);
  strcat (debugfile, basename);
  crc32.3_41 = crc32;
  _42 = separate_debug_file_exists (debugfile, crc32.3_41);
  if (_42 != 0)
    goto <bb 24>; [INV]
  else
    goto <bb 25>; [INV]

  <bb 24> :
  free (basename);
  free (dir);
  free (canon_name);
  D.3339 = strdup (debugfile);
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 35>; [INV]

  <bb 25> :
  debug_file_directory.4_43 = debug_file_directory;
  strcpy (debugfile, debug_file_directory.4_43);
  D.3373 = __builtin_strlen (debugfile);
  D.3374 = debugfile + D.3373;
  __builtin_memcpy (D.3374, "/", 2);
  strcat (debugfile, dir);
  strcat (debugfile, basename);
  crc32.5_44 = crc32;
  _45 = separate_debug_file_exists (debugfile, crc32.5_44);
  if (_45 != 0)
    goto <bb 26>; [INV]
  else
    goto <bb 27>; [INV]

  <bb 26> :
  free (basename);
  free (dir);
  free (canon_name);
  D.3339 = strdup (debugfile);
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 35>; [INV]

  <bb 27> :
  if (canon_name != 0B)
    goto <bb 28>; [INV]
  else
    goto <bb 32>; [INV]

  <bb 28> :
  gdb_sysroot.6_46 = gdb_sysroot;
  _47 = strlen (gdb_sysroot.6_46);
  gdb_sysroot.7_48 = gdb_sysroot;
  _49 = strncmp (canon_name, gdb_sysroot.7_48, _47);
  if (_49 == 0)
    goto <bb 29>; [INV]
  else
    goto <bb 32>; [INV]

  <bb 29> :
  gdb_sysroot.8_50 = gdb_sysroot;
  _51 = strlen (gdb_sysroot.8_50);
  _52 = canon_name + _51;
  _53 = *_52;
  _54 = (int) _53;
  _55 = IS_DIR_SEPARATOR (_54);
  if (_55 != 0)
    goto <bb 30>; [INV]
  else
    goto <bb 32>; [INV]

  <bb 30> :
  debug_file_directory.9_56 = debug_file_directory;
  strcpy (debugfile, debug_file_directory.9_56);
  gdb_sysroot.10_57 = gdb_sysroot;
  _58 = strlen (gdb_sysroot.10_57);
  _59 = canon_name + _58;
  strcat (debugfile, _59);
  D.3375 = __builtin_strlen (debugfile);
  D.3376 = debugfile + D.3375;
  __builtin_memcpy (D.3376, "/", 2);
  strcat (debugfile, basename);
  crc32.11_60 = crc32;
  _61 = separate_debug_file_exists (debugfile, crc32.11_60);
  if (_61 != 0)
    goto <bb 31>; [INV]
  else
    goto <bb 32>; [INV]

  <bb 31> :
  free (canon_name);
  free (basename);
  free (dir);
  free (canon_name);
  D.3339 = strdup (debugfile);
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 35>; [INV]

  <bb 32> :
  if (canon_name != 0B)
    goto <bb 33>; [INV]
  else
    goto <bb 34>; [INV]

  <bb 33> :
  free (canon_name);

  <bb 34> :
  free (basename);
  free (dir);
  D.3339 = 0B;

  <bb 35> :
  crc32 = {CLOBBER};
  return D.3339;

}


