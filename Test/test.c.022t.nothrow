
;; Function printf (printf, funcdef_no=15, decl_uid=798, cgraph_uid=15, symbol_order=15)

Function found to be nothrow: printf
__attribute__((__artificial__, __gnu_inline__, __always_inline__))
printf (const char * restrict __fmt)
{
  int _4;

  <bb 2> [0.00%]:
  _4 = __printf_chk (1, __fmt_2(D), __builtin_va_arg_pack ());
  return _4;

}



;; Function memcpy (memcpy, funcdef_no=41, decl_uid=728, cgraph_uid=41, symbol_order=41)

__attribute__((__artificial__, __gnu_inline__, __always_inline__, __nothrow__, __leaf__))
memcpy (void * restrict __dest, const void * restrict __src, size_t __len)
{
  long unsigned int _1;
  void * _7;

  <bb 2> [0.00%]:
  _1 = __builtin_object_size (__dest_3(D), 0);
  _7 = __memcpy_chk (__dest_3(D), __src_4(D), __len_5(D), _1);
  return _7;

}



;; Function winlink_cmp (winlink_cmp, funcdef_no=50, decl_uid=4298, cgraph_uid=50, symbol_order=53)

Function found to be nothrow: winlink_cmp
winlink_cmp (struct winlink * wl1, struct winlink * wl2)
{
  int _1;
  int _2;
  int _6;

  <bb 2> [0.00%]:
  _1 = wl1_4(D)->idx;
  _2 = wl2_5(D)->idx;
  _6 = _1 - _2;
  return _6;

}



;; Function winlinks_RB_INSERT_COLOR (winlinks_RB_INSERT_COLOR, funcdef_no=51, decl_uid=4302, cgraph_uid=51, symbol_order=54)

Function found to be nothrow: winlinks_RB_INSERT_COLOR
winlinks_RB_INSERT_COLOR (struct winlinks * head, struct winlink * elm)
{
  struct winlink * tmp;
  struct winlink * gparent;
  struct winlink * parent;
  struct winlink * _1;
  int _2;
  struct winlink * _3;
  struct winlink * _4;
  struct winlink * _5;
  struct winlink * _6;
  struct winlink * _7;
  struct winlink * _8;
  struct winlink * _9;
  struct winlink * _10;
  struct winlink * _11;
  struct winlink * _12;
  struct winlink * _13;
  struct winlink * _14;
  struct winlink * _15;
  struct winlink * _16;
  struct winlink * _17;
  struct winlink * _18;
  struct winlink * _19;
  struct winlink * _20;
  struct winlink * _21;
  struct winlink * _22;
  struct winlink * _23;
  int _24;
  struct winlink * _25;
  struct winlink * _26;
  struct winlink * _27;
  struct winlink * _28;
  struct winlink * _29;
  struct winlink * _30;
  struct winlink * _31;
  struct winlink * _32;
  struct winlink * _33;
  struct winlink * _34;
  struct winlink * _35;
  struct winlink * _36;
  struct winlink * _37;
  struct winlink * _38;
  struct winlink * _39;
  struct winlink * _40;
  struct winlink * _41;
  struct winlink * _42;
  struct winlink * _43;
  struct winlink * _44;
  struct winlink * _45;
  int _46;
  struct winlink * _47;

  <bb 2> [0.00%]:
  goto <bb 44>; [0.00%]

  <bb 3> [0.00%]:
  gparent_67 = parent_66->entry.rbe_parent;
  _1 = gparent_67->entry.rbe_left;
  if (parent_66 == _1)
    goto <bb 4>; [0.00%]
  else
    goto <bb 24>; [0.00%]

  <bb 4> [0.00%]:
  tmp_97 = gparent_67->entry.rbe_right;
  if (tmp_97 != 0B)
    goto <bb 5>; [0.00%]
  else
    goto <bb 7>; [0.00%]

  <bb 5> [0.00%]:
  _2 = tmp_97->entry.rbe_color;
  if (_2 == 1)
    goto <bb 6>; [0.00%]
  else
    goto <bb 7>; [0.00%]

  <bb 6> [0.00%]:
  tmp_97->entry.rbe_color = 0;
  parent_66->entry.rbe_color = 0;
  gparent_67->entry.rbe_color = 1;
  elm_101 = gparent_67;
  // predicted unlikely by continue predictor.
  goto <bb 44>; [0.00%]

  <bb 7> [0.00%]:
  _3 = parent_66->entry.rbe_right;
  if (elm_50 == _3)
    goto <bb 8>; [0.00%]
  else
    goto <bb 16>; [0.00%]

  <bb 8> [0.00%]:
  tmp_102 = parent_66->entry.rbe_right;
  _4 = tmp_102->entry.rbe_left;
  parent_66->entry.rbe_right = _4;
  _5 = parent_66->entry.rbe_right;
  if (_5 != 0B)
    goto <bb 9>; [0.00%]
  else
    goto <bb 10>; [0.00%]

  <bb 9> [0.00%]:
  _6 = tmp_102->entry.rbe_left;
  _6->entry.rbe_parent = parent_66;

  <bb 10> [0.00%]:
  _7 = parent_66->entry.rbe_parent;
  tmp_102->entry.rbe_parent = _7;
  _8 = tmp_102->entry.rbe_parent;
  if (_8 != 0B)
    goto <bb 11>; [0.00%]
  else
    goto <bb 14>; [0.00%]

  <bb 11> [0.00%]:
  _9 = parent_66->entry.rbe_parent;
  _10 = _9->entry.rbe_left;
  if (parent_66 == _10)
    goto <bb 12>; [0.00%]
  else
    goto <bb 13>; [0.00%]

  <bb 12> [0.00%]:
  _11 = parent_66->entry.rbe_parent;
  _11->entry.rbe_left = tmp_102;
  goto <bb 15>; [0.00%]

  <bb 13> [0.00%]:
  _12 = parent_66->entry.rbe_parent;
  _12->entry.rbe_right = tmp_102;
  goto <bb 15>; [0.00%]

  <bb 14> [0.00%]:
  head_77(D)->rbh_root = tmp_102;

  <bb 15> [0.00%]:
  tmp_102->entry.rbe_left = parent_66;
  parent_66->entry.rbe_parent = tmp_102;
  _13 = tmp_102->entry.rbe_parent;
  tmp_111 = parent_66;
  parent_112 = elm_50;
  elm_113 = tmp_111;

  <bb 16> [0.00%]:
  # elm_48 = PHI <elm_50(7), elm_113(15)>
  # parent_51 = PHI <parent_66(7), parent_112(15)>
  parent_51->entry.rbe_color = 0;
  gparent_67->entry.rbe_color = 1;
  tmp_116 = gparent_67->entry.rbe_left;
  _14 = tmp_116->entry.rbe_right;
  gparent_67->entry.rbe_left = _14;
  _15 = gparent_67->entry.rbe_left;
  if (_15 != 0B)
    goto <bb 17>; [0.00%]
  else
    goto <bb 18>; [0.00%]

  <bb 17> [0.00%]:
  _16 = tmp_116->entry.rbe_right;
  _16->entry.rbe_parent = gparent_67;

  <bb 18> [0.00%]:
  _17 = gparent_67->entry.rbe_parent;
  tmp_116->entry.rbe_parent = _17;
  _18 = tmp_116->entry.rbe_parent;
  if (_18 != 0B)
    goto <bb 19>; [0.00%]
  else
    goto <bb 22>; [0.00%]

  <bb 19> [0.00%]:
  _19 = gparent_67->entry.rbe_parent;
  _20 = _19->entry.rbe_left;
  if (gparent_67 == _20)
    goto <bb 20>; [0.00%]
  else
    goto <bb 21>; [0.00%]

  <bb 20> [0.00%]:
  _21 = gparent_67->entry.rbe_parent;
  _21->entry.rbe_left = tmp_116;
  goto <bb 23>; [0.00%]

  <bb 21> [0.00%]:
  _22 = gparent_67->entry.rbe_parent;
  _22->entry.rbe_right = tmp_116;
  goto <bb 23>; [0.00%]

  <bb 22> [0.00%]:
  head_77(D)->rbh_root = tmp_116;

  <bb 23> [0.00%]:
  tmp_116->entry.rbe_right = gparent_67;
  gparent_67->entry.rbe_parent = tmp_116;
  _23 = tmp_116->entry.rbe_parent;
  goto <bb 44>; [0.00%]

  <bb 24> [0.00%]:
  tmp_68 = gparent_67->entry.rbe_left;
  if (tmp_68 != 0B)
    goto <bb 25>; [0.00%]
  else
    goto <bb 27>; [0.00%]

  <bb 25> [0.00%]:
  _24 = tmp_68->entry.rbe_color;
  if (_24 == 1)
    goto <bb 26>; [0.00%]
  else
    goto <bb 27>; [0.00%]

  <bb 26> [0.00%]:
  tmp_68->entry.rbe_color = 0;
  parent_66->entry.rbe_color = 0;
  gparent_67->entry.rbe_color = 1;
  elm_72 = gparent_67;
  // predicted unlikely by continue predictor.
  goto <bb 44>; [0.00%]

  <bb 27> [0.00%]:
  _25 = parent_66->entry.rbe_left;
  if (elm_50 == _25)
    goto <bb 28>; [0.00%]
  else
    goto <bb 36>; [0.00%]

  <bb 28> [0.00%]:
  tmp_73 = parent_66->entry.rbe_left;
  _26 = tmp_73->entry.rbe_right;
  parent_66->entry.rbe_left = _26;
  _27 = parent_66->entry.rbe_left;
  if (_27 != 0B)
    goto <bb 29>; [0.00%]
  else
    goto <bb 30>; [0.00%]

  <bb 29> [0.00%]:
  _28 = tmp_73->entry.rbe_right;
  _28->entry.rbe_parent = parent_66;

  <bb 30> [0.00%]:
  _29 = parent_66->entry.rbe_parent;
  tmp_73->entry.rbe_parent = _29;
  _30 = tmp_73->entry.rbe_parent;
  if (_30 != 0B)
    goto <bb 31>; [0.00%]
  else
    goto <bb 34>; [0.00%]

  <bb 31> [0.00%]:
  _31 = parent_66->entry.rbe_parent;
  _32 = _31->entry.rbe_left;
  if (parent_66 == _32)
    goto <bb 32>; [0.00%]
  else
    goto <bb 33>; [0.00%]

  <bb 32> [0.00%]:
  _33 = parent_66->entry.rbe_parent;
  _33->entry.rbe_left = tmp_73;
  goto <bb 35>; [0.00%]

  <bb 33> [0.00%]:
  _34 = parent_66->entry.rbe_parent;
  _34->entry.rbe_right = tmp_73;
  goto <bb 35>; [0.00%]

  <bb 34> [0.00%]:
  head_77(D)->rbh_root = tmp_73;

  <bb 35> [0.00%]:
  tmp_73->entry.rbe_right = parent_66;
  parent_66->entry.rbe_parent = tmp_73;
  _35 = tmp_73->entry.rbe_parent;
  tmp_83 = parent_66;
  parent_84 = elm_50;
  elm_85 = tmp_83;

  <bb 36> [0.00%]:
  # elm_49 = PHI <elm_50(27), elm_85(35)>
  # parent_52 = PHI <parent_66(27), parent_84(35)>
  parent_52->entry.rbe_color = 0;
  gparent_67->entry.rbe_color = 1;
  tmp_88 = gparent_67->entry.rbe_right;
  _36 = tmp_88->entry.rbe_left;
  gparent_67->entry.rbe_right = _36;
  _37 = gparent_67->entry.rbe_right;
  if (_37 != 0B)
    goto <bb 37>; [0.00%]
  else
    goto <bb 38>; [0.00%]

  <bb 37> [0.00%]:
  _38 = tmp_88->entry.rbe_left;
  _38->entry.rbe_parent = gparent_67;

  <bb 38> [0.00%]:
  _39 = gparent_67->entry.rbe_parent;
  tmp_88->entry.rbe_parent = _39;
  _40 = tmp_88->entry.rbe_parent;
  if (_40 != 0B)
    goto <bb 39>; [0.00%]
  else
    goto <bb 42>; [0.00%]

  <bb 39> [0.00%]:
  _41 = gparent_67->entry.rbe_parent;
  _42 = _41->entry.rbe_left;
  if (gparent_67 == _42)
    goto <bb 40>; [0.00%]
  else
    goto <bb 41>; [0.00%]

  <bb 40> [0.00%]:
  _43 = gparent_67->entry.rbe_parent;
  _43->entry.rbe_left = tmp_88;
  goto <bb 43>; [0.00%]

  <bb 41> [0.00%]:
  _44 = gparent_67->entry.rbe_parent;
  _44->entry.rbe_right = tmp_88;
  goto <bb 43>; [0.00%]

  <bb 42> [0.00%]:
  head_77(D)->rbh_root = tmp_88;

  <bb 43> [0.00%]:
  tmp_88->entry.rbe_left = gparent_67;
  gparent_67->entry.rbe_parent = tmp_88;
  _45 = tmp_88->entry.rbe_parent;

  <bb 44> [0.00%]:
  # elm_50 = PHI <elm_64(D)(2), elm_101(6), elm_48(23), elm_72(26), elm_49(43)>
  parent_66 = elm_50->entry.rbe_parent;
  if (parent_66 != 0B)
    goto <bb 45>; [0.00%]
  else
    goto <bb 46>; [0.00%]

  <bb 45> [0.00%]:
  _46 = parent_66->entry.rbe_color;
  if (_46 == 1)
    goto <bb 3>; [0.00%]
  else
    goto <bb 46>; [0.00%]

  <bb 46> [0.00%]:
  _47 = head_77(D)->rbh_root;
  _47->entry.rbe_color = 0;
  return;

}



;; Function winlinks_RB_REMOVE_COLOR (winlinks_RB_REMOVE_COLOR, funcdef_no=52, decl_uid=4313, cgraph_uid=52, symbol_order=55)

Function found to be nothrow: winlinks_RB_REMOVE_COLOR
winlinks_RB_REMOVE_COLOR (struct winlinks * head, struct winlink * parent, struct winlink * elm)
{
  struct winlink * oright;
  struct winlink * oleft;
  struct winlink * tmp;
  struct winlink * _1;
  int _2;
  struct winlink * _3;
  struct winlink * _4;
  struct winlink * _5;
  struct winlink * _6;
  struct winlink * _7;
  struct winlink * _8;
  struct winlink * _9;
  struct winlink * _10;
  struct winlink * _11;
  struct winlink * _12;
  struct winlink * _13;
  struct winlink * _14;
  int _15;
  struct winlink * _16;
  struct winlink * _17;
  int _18;
  struct winlink * _19;
  struct winlink * _20;
  int _21;
  struct winlink * _22;
  struct winlink * _23;
  struct winlink * _24;
  struct winlink * _25;
  struct winlink * _26;
  struct winlink * _27;
  struct winlink * _28;
  struct winlink * _29;
  struct winlink * _30;
  struct winlink * _31;
  int _32;
  struct winlink * _33;
  struct winlink * _34;
  struct winlink * _35;
  struct winlink * _36;
  struct winlink * _37;
  struct winlink * _38;
  struct winlink * _39;
  struct winlink * _40;
  struct winlink * _41;
  struct winlink * _42;
  struct winlink * _43;
  struct winlink * _44;
  int _45;
  struct winlink * _46;
  struct winlink * _47;
  struct winlink * _48;
  struct winlink * _49;
  struct winlink * _50;
  struct winlink * _51;
  struct winlink * _52;
  struct winlink * _53;
  struct winlink * _54;
  struct winlink * _55;
  struct winlink * _56;
  struct winlink * _57;
  int _58;
  struct winlink * _59;
  struct winlink * _60;
  int _61;
  struct winlink * _62;
  struct winlink * _63;
  int _64;
  struct winlink * _65;
  struct winlink * _66;
  struct winlink * _67;
  struct winlink * _68;
  struct winlink * _69;
  struct winlink * _70;
  struct winlink * _71;
  struct winlink * _72;
  struct winlink * _73;
  struct winlink * _74;
  int _75;
  struct winlink * _76;
  struct winlink * _77;
  struct winlink * _78;
  struct winlink * _79;
  struct winlink * _80;
  struct winlink * _81;
  struct winlink * _82;
  struct winlink * _83;
  struct winlink * _84;
  struct winlink * _85;
  struct winlink * _86;
  struct winlink * _87;
  int _88;
  struct winlink * _89;

  <bb 2> [0.00%]:
  goto <bb 76>; [0.00%]

  <bb 3> [0.00%]:
  _1 = parent_90->entry.rbe_left;
  if (elm_91 == _1)
    goto <bb 4>; [0.00%]
  else
    goto <bb 40>; [0.00%]

  <bb 4> [0.00%]:
  tmp_166 = parent_90->entry.rbe_right;
  _2 = tmp_166->entry.rbe_color;
  if (_2 == 1)
    goto <bb 5>; [0.00%]
  else
    goto <bb 13>; [0.00%]

  <bb 5> [0.00%]:
  tmp_166->entry.rbe_color = 0;
  parent_90->entry.rbe_color = 1;
  tmp_169 = parent_90->entry.rbe_right;
  _3 = tmp_169->entry.rbe_left;
  parent_90->entry.rbe_right = _3;
  _4 = parent_90->entry.rbe_right;
  if (_4 != 0B)
    goto <bb 6>; [0.00%]
  else
    goto <bb 7>; [0.00%]

  <bb 6> [0.00%]:
  _5 = tmp_169->entry.rbe_left;
  _5->entry.rbe_parent = parent_90;

  <bb 7> [0.00%]:
  _6 = parent_90->entry.rbe_parent;
  tmp_169->entry.rbe_parent = _6;
  _7 = tmp_169->entry.rbe_parent;
  if (_7 != 0B)
    goto <bb 8>; [0.00%]
  else
    goto <bb 11>; [0.00%]

  <bb 8> [0.00%]:
  _8 = parent_90->entry.rbe_parent;
  _9 = _8->entry.rbe_left;
  if (parent_90 == _9)
    goto <bb 9>; [0.00%]
  else
    goto <bb 10>; [0.00%]

  <bb 9> [0.00%]:
  _10 = parent_90->entry.rbe_parent;
  _10->entry.rbe_left = tmp_169;
  goto <bb 12>; [0.00%]

  <bb 10> [0.00%]:
  _11 = parent_90->entry.rbe_parent;
  _11->entry.rbe_right = tmp_169;
  goto <bb 12>; [0.00%]

  <bb 11> [0.00%]:
  head_123(D)->rbh_root = tmp_169;

  <bb 12> [0.00%]:
  tmp_169->entry.rbe_left = parent_90;
  parent_90->entry.rbe_parent = tmp_169;
  _12 = tmp_169->entry.rbe_parent;
  tmp_178 = parent_90->entry.rbe_right;

  <bb 13> [0.00%]:
  # tmp_93 = PHI <tmp_166(4), tmp_178(12)>
  _13 = tmp_93->entry.rbe_left;
  if (_13 == 0B)
    goto <bb 15>; [0.00%]
  else
    goto <bb 14>; [0.00%]

  <bb 14> [0.00%]:
  _14 = tmp_93->entry.rbe_left;
  _15 = _14->entry.rbe_color;
  if (_15 == 0)
    goto <bb 15>; [0.00%]
  else
    goto <bb 18>; [0.00%]

  <bb 15> [0.00%]:
  _16 = tmp_93->entry.rbe_right;
  if (_16 == 0B)
    goto <bb 17>; [0.00%]
  else
    goto <bb 16>; [0.00%]

  <bb 16> [0.00%]:
  _17 = tmp_93->entry.rbe_right;
  _18 = _17->entry.rbe_color;
  if (_18 == 0)
    goto <bb 17>; [0.00%]
  else
    goto <bb 18>; [0.00%]

  <bb 17> [0.00%]:
  tmp_93->entry.rbe_color = 1;
  elm_180 = parent_90;
  parent_181 = elm_180->entry.rbe_parent;
  goto <bb 76>; [0.00%]

  <bb 18> [0.00%]:
  _19 = tmp_93->entry.rbe_right;
  if (_19 == 0B)
    goto <bb 20>; [0.00%]
  else
    goto <bb 19>; [0.00%]

  <bb 19> [0.00%]:
  _20 = tmp_93->entry.rbe_right;
  _21 = _20->entry.rbe_color;
  if (_21 == 0)
    goto <bb 20>; [0.00%]
  else
    goto <bb 30>; [0.00%]

  <bb 20> [0.00%]:
  oleft_182 = tmp_93->entry.rbe_left;
  if (oleft_182 != 0B)
    goto <bb 21>; [0.00%]
  else
    goto <bb 22>; [0.00%]

  <bb 21> [0.00%]:
  oleft_182->entry.rbe_color = 0;

  <bb 22> [0.00%]:
  tmp_93->entry.rbe_color = 1;
  oleft_185 = tmp_93->entry.rbe_left;
  _22 = oleft_185->entry.rbe_right;
  tmp_93->entry.rbe_left = _22;
  _23 = tmp_93->entry.rbe_left;
  if (_23 != 0B)
    goto <bb 23>; [0.00%]
  else
    goto <bb 24>; [0.00%]

  <bb 23> [0.00%]:
  _24 = oleft_185->entry.rbe_right;
  _24->entry.rbe_parent = tmp_93;

  <bb 24> [0.00%]:
  _25 = tmp_93->entry.rbe_parent;
  oleft_185->entry.rbe_parent = _25;
  _26 = oleft_185->entry.rbe_parent;
  if (_26 != 0B)
    goto <bb 25>; [0.00%]
  else
    goto <bb 28>; [0.00%]

  <bb 25> [0.00%]:
  _27 = tmp_93->entry.rbe_parent;
  _28 = _27->entry.rbe_left;
  if (tmp_93 == _28)
    goto <bb 26>; [0.00%]
  else
    goto <bb 27>; [0.00%]

  <bb 26> [0.00%]:
  _29 = tmp_93->entry.rbe_parent;
  _29->entry.rbe_left = oleft_185;
  goto <bb 29>; [0.00%]

  <bb 27> [0.00%]:
  _30 = tmp_93->entry.rbe_parent;
  _30->entry.rbe_right = oleft_185;
  goto <bb 29>; [0.00%]

  <bb 28> [0.00%]:
  head_123(D)->rbh_root = oleft_185;

  <bb 29> [0.00%]:
  oleft_185->entry.rbe_right = tmp_93;
  tmp_93->entry.rbe_parent = oleft_185;
  _31 = oleft_185->entry.rbe_parent;
  tmp_194 = parent_90->entry.rbe_right;

  <bb 30> [0.00%]:
  # tmp_94 = PHI <tmp_93(19), tmp_194(29)>
  _32 = parent_90->entry.rbe_color;
  tmp_94->entry.rbe_color = _32;
  parent_90->entry.rbe_color = 0;
  _33 = tmp_94->entry.rbe_right;
  if (_33 != 0B)
    goto <bb 31>; [0.00%]
  else
    goto <bb 32>; [0.00%]

  <bb 31> [0.00%]:
  _34 = tmp_94->entry.rbe_right;
  _34->entry.rbe_color = 0;

  <bb 32> [0.00%]:
  tmp_198 = parent_90->entry.rbe_right;
  _35 = tmp_198->entry.rbe_left;
  parent_90->entry.rbe_right = _35;
  _36 = parent_90->entry.rbe_right;
  if (_36 != 0B)
    goto <bb 33>; [0.00%]
  else
    goto <bb 34>; [0.00%]

  <bb 33> [0.00%]:
  _37 = tmp_198->entry.rbe_left;
  _37->entry.rbe_parent = parent_90;

  <bb 34> [0.00%]:
  _38 = parent_90->entry.rbe_parent;
  tmp_198->entry.rbe_parent = _38;
  _39 = tmp_198->entry.rbe_parent;
  if (_39 != 0B)
    goto <bb 35>; [0.00%]
  else
    goto <bb 38>; [0.00%]

  <bb 35> [0.00%]:
  _40 = parent_90->entry.rbe_parent;
  _41 = _40->entry.rbe_left;
  if (parent_90 == _41)
    goto <bb 36>; [0.00%]
  else
    goto <bb 37>; [0.00%]

  <bb 36> [0.00%]:
  _42 = parent_90->entry.rbe_parent;
  _42->entry.rbe_left = tmp_198;
  goto <bb 39>; [0.00%]

  <bb 37> [0.00%]:
  _43 = parent_90->entry.rbe_parent;
  _43->entry.rbe_right = tmp_198;
  goto <bb 39>; [0.00%]

  <bb 38> [0.00%]:
  head_123(D)->rbh_root = tmp_198;

  <bb 39> [0.00%]:
  tmp_198->entry.rbe_left = parent_90;
  parent_90->entry.rbe_parent = tmp_198;
  _44 = tmp_198->entry.rbe_parent;
  elm_207 = head_123(D)->rbh_root;
  goto <bb 79>; [0.00%]

  <bb 40> [0.00%]:
  tmp_124 = parent_90->entry.rbe_left;
  _45 = tmp_124->entry.rbe_color;
  if (_45 == 1)
    goto <bb 41>; [0.00%]
  else
    goto <bb 49>; [0.00%]

  <bb 41> [0.00%]:
  tmp_124->entry.rbe_color = 0;
  parent_90->entry.rbe_color = 1;
  tmp_127 = parent_90->entry.rbe_left;
  _46 = tmp_127->entry.rbe_right;
  parent_90->entry.rbe_left = _46;
  _47 = parent_90->entry.rbe_left;
  if (_47 != 0B)
    goto <bb 42>; [0.00%]
  else
    goto <bb 43>; [0.00%]

  <bb 42> [0.00%]:
  _48 = tmp_127->entry.rbe_right;
  _48->entry.rbe_parent = parent_90;

  <bb 43> [0.00%]:
  _49 = parent_90->entry.rbe_parent;
  tmp_127->entry.rbe_parent = _49;
  _50 = tmp_127->entry.rbe_parent;
  if (_50 != 0B)
    goto <bb 44>; [0.00%]
  else
    goto <bb 47>; [0.00%]

  <bb 44> [0.00%]:
  _51 = parent_90->entry.rbe_parent;
  _52 = _51->entry.rbe_left;
  if (parent_90 == _52)
    goto <bb 45>; [0.00%]
  else
    goto <bb 46>; [0.00%]

  <bb 45> [0.00%]:
  _53 = parent_90->entry.rbe_parent;
  _53->entry.rbe_left = tmp_127;
  goto <bb 48>; [0.00%]

  <bb 46> [0.00%]:
  _54 = parent_90->entry.rbe_parent;
  _54->entry.rbe_right = tmp_127;
  goto <bb 48>; [0.00%]

  <bb 47> [0.00%]:
  head_123(D)->rbh_root = tmp_127;

  <bb 48> [0.00%]:
  tmp_127->entry.rbe_right = parent_90;
  parent_90->entry.rbe_parent = tmp_127;
  _55 = tmp_127->entry.rbe_parent;
  tmp_136 = parent_90->entry.rbe_left;

  <bb 49> [0.00%]:
  # tmp_95 = PHI <tmp_124(40), tmp_136(48)>
  _56 = tmp_95->entry.rbe_left;
  if (_56 == 0B)
    goto <bb 51>; [0.00%]
  else
    goto <bb 50>; [0.00%]

  <bb 50> [0.00%]:
  _57 = tmp_95->entry.rbe_left;
  _58 = _57->entry.rbe_color;
  if (_58 == 0)
    goto <bb 51>; [0.00%]
  else
    goto <bb 54>; [0.00%]

  <bb 51> [0.00%]:
  _59 = tmp_95->entry.rbe_right;
  if (_59 == 0B)
    goto <bb 53>; [0.00%]
  else
    goto <bb 52>; [0.00%]

  <bb 52> [0.00%]:
  _60 = tmp_95->entry.rbe_right;
  _61 = _60->entry.rbe_color;
  if (_61 == 0)
    goto <bb 53>; [0.00%]
  else
    goto <bb 54>; [0.00%]

  <bb 53> [0.00%]:
  tmp_95->entry.rbe_color = 1;
  elm_138 = parent_90;
  parent_139 = elm_138->entry.rbe_parent;
  goto <bb 76>; [0.00%]

  <bb 54> [0.00%]:
  _62 = tmp_95->entry.rbe_left;
  if (_62 == 0B)
    goto <bb 56>; [0.00%]
  else
    goto <bb 55>; [0.00%]

  <bb 55> [0.00%]:
  _63 = tmp_95->entry.rbe_left;
  _64 = _63->entry.rbe_color;
  if (_64 == 0)
    goto <bb 56>; [0.00%]
  else
    goto <bb 66>; [0.00%]

  <bb 56> [0.00%]:
  oright_140 = tmp_95->entry.rbe_right;
  if (oright_140 != 0B)
    goto <bb 57>; [0.00%]
  else
    goto <bb 58>; [0.00%]

  <bb 57> [0.00%]:
  oright_140->entry.rbe_color = 0;

  <bb 58> [0.00%]:
  tmp_95->entry.rbe_color = 1;
  oright_143 = tmp_95->entry.rbe_right;
  _65 = oright_143->entry.rbe_left;
  tmp_95->entry.rbe_right = _65;
  _66 = tmp_95->entry.rbe_right;
  if (_66 != 0B)
    goto <bb 59>; [0.00%]
  else
    goto <bb 60>; [0.00%]

  <bb 59> [0.00%]:
  _67 = oright_143->entry.rbe_left;
  _67->entry.rbe_parent = tmp_95;

  <bb 60> [0.00%]:
  _68 = tmp_95->entry.rbe_parent;
  oright_143->entry.rbe_parent = _68;
  _69 = oright_143->entry.rbe_parent;
  if (_69 != 0B)
    goto <bb 61>; [0.00%]
  else
    goto <bb 64>; [0.00%]

  <bb 61> [0.00%]:
  _70 = tmp_95->entry.rbe_parent;
  _71 = _70->entry.rbe_left;
  if (tmp_95 == _71)
    goto <bb 62>; [0.00%]
  else
    goto <bb 63>; [0.00%]

  <bb 62> [0.00%]:
  _72 = tmp_95->entry.rbe_parent;
  _72->entry.rbe_left = oright_143;
  goto <bb 65>; [0.00%]

  <bb 63> [0.00%]:
  _73 = tmp_95->entry.rbe_parent;
  _73->entry.rbe_right = oright_143;
  goto <bb 65>; [0.00%]

  <bb 64> [0.00%]:
  head_123(D)->rbh_root = oright_143;

  <bb 65> [0.00%]:
  oright_143->entry.rbe_left = tmp_95;
  tmp_95->entry.rbe_parent = oright_143;
  _74 = oright_143->entry.rbe_parent;
  tmp_152 = parent_90->entry.rbe_left;

  <bb 66> [0.00%]:
  # tmp_96 = PHI <tmp_95(55), tmp_152(65)>
  _75 = parent_90->entry.rbe_color;
  tmp_96->entry.rbe_color = _75;
  parent_90->entry.rbe_color = 0;
  _76 = tmp_96->entry.rbe_left;
  if (_76 != 0B)
    goto <bb 67>; [0.00%]
  else
    goto <bb 68>; [0.00%]

  <bb 67> [0.00%]:
  _77 = tmp_96->entry.rbe_left;
  _77->entry.rbe_color = 0;

  <bb 68> [0.00%]:
  tmp_156 = parent_90->entry.rbe_left;
  _78 = tmp_156->entry.rbe_right;
  parent_90->entry.rbe_left = _78;
  _79 = parent_90->entry.rbe_left;
  if (_79 != 0B)
    goto <bb 69>; [0.00%]
  else
    goto <bb 70>; [0.00%]

  <bb 69> [0.00%]:
  _80 = tmp_156->entry.rbe_right;
  _80->entry.rbe_parent = parent_90;

  <bb 70> [0.00%]:
  _81 = parent_90->entry.rbe_parent;
  tmp_156->entry.rbe_parent = _81;
  _82 = tmp_156->entry.rbe_parent;
  if (_82 != 0B)
    goto <bb 71>; [0.00%]
  else
    goto <bb 74>; [0.00%]

  <bb 71> [0.00%]:
  _83 = parent_90->entry.rbe_parent;
  _84 = _83->entry.rbe_left;
  if (parent_90 == _84)
    goto <bb 72>; [0.00%]
  else
    goto <bb 73>; [0.00%]

  <bb 72> [0.00%]:
  _85 = parent_90->entry.rbe_parent;
  _85->entry.rbe_left = tmp_156;
  goto <bb 75>; [0.00%]

  <bb 73> [0.00%]:
  _86 = parent_90->entry.rbe_parent;
  _86->entry.rbe_right = tmp_156;
  goto <bb 75>; [0.00%]

  <bb 74> [0.00%]:
  head_123(D)->rbh_root = tmp_156;

  <bb 75> [0.00%]:
  tmp_156->entry.rbe_right = parent_90;
  parent_90->entry.rbe_parent = tmp_156;
  _87 = tmp_156->entry.rbe_parent;
  elm_165 = head_123(D)->rbh_root;
  goto <bb 79>; [0.00%]

  <bb 76> [0.00%]:
  # parent_90 = PHI <parent_120(D)(2), parent_181(17), parent_139(53)>
  # elm_91 = PHI <elm_121(D)(2), elm_180(17), elm_138(53)>
  if (elm_91 == 0B)
    goto <bb 78>; [0.00%]
  else
    goto <bb 77>; [0.00%]

  <bb 77> [0.00%]:
  _88 = elm_91->entry.rbe_color;
  if (_88 == 0)
    goto <bb 78>; [0.00%]
  else
    goto <bb 79>; [0.00%]

  <bb 78> [0.00%]:
  _89 = head_123(D)->rbh_root;
  if (elm_91 != _89)
    goto <bb 3>; [0.00%]
  else
    goto <bb 79>; [0.00%]

  <bb 79> [0.00%]:
  # elm_92 = PHI <elm_207(39), elm_165(75), elm_91(77), elm_91(78)>
  if (elm_92 != 0B)
    goto <bb 80>; [0.00%]
  else
    goto <bb 81>; [0.00%]

  <bb 80> [0.00%]:
  elm_92->entry.rbe_color = 0;

  <bb 81> [0.00%]:
  return;

}



;; Function winlinks_RB_INSERT (winlinks_RB_INSERT, funcdef_no=53, decl_uid=4323, cgraph_uid=53, symbol_order=56)

Function found to be nothrow: winlinks_RB_INSERT
winlinks_RB_INSERT (struct winlinks * head, struct winlink * elm)
{
  int comp;
  struct winlink * parent;
  struct winlink * tmp;
  struct winlink * _1;
  struct winlink * _5;
  struct winlink * _23;
  struct winlink * _27;

  <bb 2> [0.00%]:
  parent_9 = 0B;
  comp_10 = 0;
  tmp_13 = head_12(D)->rbh_root;
  goto <bb 8>; [0.00%]

  <bb 3> [0.00%]:
  parent_24 = tmp_2;
  comp_26 = winlink_cmp (elm_14(D), parent_24);
  if (comp_26 < 0)
    goto <bb 4>; [0.00%]
  else
    goto <bb 5>; [0.00%]

  <bb 4> [0.00%]:
  tmp_29 = tmp_2->entry.rbe_left;
  goto <bb 8>; [0.00%]

  <bb 5> [0.00%]:
  if (comp_26 > 0)
    goto <bb 6>; [0.00%]
  else
    goto <bb 7>; [0.00%]

  <bb 6> [0.00%]:
  tmp_28 = tmp_2->entry.rbe_right;
  goto <bb 8>; [0.00%]

  <bb 7> [0.00%]:
  _27 = tmp_2;
  goto <bb 15>; [0.00%]

  <bb 8> [0.00%]:
  # tmp_2 = PHI <tmp_13(2), tmp_29(4), tmp_28(6)>
  # parent_3 = PHI <parent_9(2), parent_24(4), parent_24(6)>
  # comp_4 = PHI <comp_10(2), comp_26(4), comp_26(6)>
  if (tmp_2 != 0B)
    goto <bb 3>; [0.00%]
  else
    goto <bb 9>; [0.00%]

  <bb 9> [0.00%]:
  elm_14(D)->entry.rbe_parent = parent_3;
  elm_14(D)->entry.rbe_right = 0B;
  _1 = elm_14(D)->entry.rbe_right;
  elm_14(D)->entry.rbe_left = _1;
  elm_14(D)->entry.rbe_color = 1;
  if (parent_3 != 0B)
    goto <bb 10>; [0.00%]
  else
    goto <bb 13>; [0.00%]

  <bb 10> [0.00%]:
  if (comp_4 < 0)
    goto <bb 11>; [0.00%]
  else
    goto <bb 12>; [0.00%]

  <bb 11> [0.00%]:
  parent_3->entry.rbe_left = elm_14(D);
  goto <bb 14>; [0.00%]

  <bb 12> [0.00%]:
  parent_3->entry.rbe_right = elm_14(D);
  goto <bb 14>; [0.00%]

  <bb 13> [0.00%]:
  head_12(D)->rbh_root = elm_14(D);

  <bb 14> [0.00%]:
  winlinks_RB_INSERT_COLOR (head_12(D), elm_14(D));
  _23 = 0B;

  <bb 15> [0.00%]:
  # _5 = PHI <_27(7), _23(14)>
  return _5;

}



;; Function winlinks_RB_REMOVE (winlinks_RB_REMOVE, funcdef_no=54, decl_uid=4333, cgraph_uid=54, symbol_order=57)

Function found to be nothrow: winlinks_RB_REMOVE
winlinks_RB_REMOVE (struct winlinks * head, struct winlink * elm)
{
  struct winlink * left;
  int color;
  struct winlink * old;
  struct winlink * parent;
  struct winlink * child;
  struct winlink * _1;
  struct winlink * _2;
  struct winlink * _3;
  struct winlink * _4;
  struct winlink * _5;
  struct winlink * _6;
  struct winlink * _7;
  struct winlink * _8;
  struct winlink * _9;
  struct winlink * _10;
  struct winlink * _11;
  struct winlink * _12;
  struct winlink * _13;
  struct winlink * _60;

  <bb 2> [0.00%]:
  old_29 = elm_28(D);
  _1 = elm_28(D)->entry.rbe_left;
  if (_1 == 0B)
    goto <bb 3>; [0.00%]
  else
    goto <bb 4>; [0.00%]

  <bb 3> [0.00%]:
  child_52 = elm_28(D)->entry.rbe_right;
  goto <bb 28>; [0.00%]

  <bb 4> [0.00%]:
  _2 = elm_28(D)->entry.rbe_right;
  if (_2 == 0B)
    goto <bb 5>; [0.00%]
  else
    goto <bb 6>; [0.00%]

  <bb 5> [0.00%]:
  child_51 = elm_28(D)->entry.rbe_left;
  goto <bb 28>; [0.00%]

  <bb 6> [0.00%]:
  elm_31 = elm_28(D)->entry.rbe_right;
  goto <bb 8>; [0.00%]

  <bb 7> [0.00%]:
  elm_50 = left_32;

  <bb 8> [0.00%]:
  # elm_14 = PHI <elm_31(6), elm_50(7)>
  left_32 = elm_14->entry.rbe_left;
  if (left_32 != 0B)
    goto <bb 7>; [0.00%]
  else
    goto <bb 9>; [0.00%]

  <bb 9> [0.00%]:
  child_33 = elm_14->entry.rbe_right;
  parent_34 = elm_14->entry.rbe_parent;
  color_35 = elm_14->entry.rbe_color;
  if (child_33 != 0B)
    goto <bb 10>; [0.00%]
  else
    goto <bb 11>; [0.00%]

  <bb 10> [0.00%]:
  child_33->entry.rbe_parent = parent_34;

  <bb 11> [0.00%]:
  if (parent_34 != 0B)
    goto <bb 12>; [0.00%]
  else
    goto <bb 15>; [0.00%]

  <bb 12> [0.00%]:
  _3 = parent_34->entry.rbe_left;
  if (elm_14 == _3)
    goto <bb 13>; [0.00%]
  else
    goto <bb 14>; [0.00%]

  <bb 13> [0.00%]:
  parent_34->entry.rbe_left = child_33;
  goto <bb 16>; [0.00%]

  <bb 14> [0.00%]:
  parent_34->entry.rbe_right = child_33;
  goto <bb 16>; [0.00%]

  <bb 15> [0.00%]:
  head_37(D)->rbh_root = child_33;

  <bb 16> [0.00%]:
  _4 = elm_14->entry.rbe_parent;
  if (old_29 == _4)
    goto <bb 17>; [0.00%]
  else
    goto <bb 18>; [0.00%]

  <bb 17> [0.00%]:
  parent_41 = elm_14;

  <bb 18> [0.00%]:
  # parent_17 = PHI <parent_34(16), parent_41(17)>
  elm_14->entry = old_29->entry;
  _5 = old_29->entry.rbe_parent;
  if (_5 != 0B)
    goto <bb 19>; [0.00%]
  else
    goto <bb 22>; [0.00%]

  <bb 19> [0.00%]:
  _6 = old_29->entry.rbe_parent;
  _7 = _6->entry.rbe_left;
  if (old_29 == _7)
    goto <bb 20>; [0.00%]
  else
    goto <bb 21>; [0.00%]

  <bb 20> [0.00%]:
  _8 = old_29->entry.rbe_parent;
  _8->entry.rbe_left = elm_14;
  goto <bb 23>; [0.00%]

  <bb 21> [0.00%]:
  _9 = old_29->entry.rbe_parent;
  _9->entry.rbe_right = elm_14;
  goto <bb 23>; [0.00%]

  <bb 22> [0.00%]:
  head_37(D)->rbh_root = elm_14;

  <bb 23> [0.00%]:
  _10 = old_29->entry.rbe_left;
  _10->entry.rbe_parent = elm_14;
  _11 = old_29->entry.rbe_right;
  if (_11 != 0B)
    goto <bb 24>; [0.00%]
  else
    goto <bb 25>; [0.00%]

  <bb 24> [0.00%]:
  _12 = old_29->entry.rbe_right;
  _12->entry.rbe_parent = elm_14;

  <bb 25> [0.00%]:
  if (parent_17 != 0B)
    goto <bb 26>; [0.00%]
  else
    goto <bb 35> (color); [0.00%]

  <bb 26> [0.00%]:
  left_48 = parent_17;

  <bb 27> [0.00%]:
  # left_20 = PHI <left_48(26), left_49(27)>
  left_49 = left_20->entry.rbe_parent;
  if (left_49 != 0B)
    goto <bb 27>; [0.00%]
  else
    goto <bb 35> (color); [0.00%]

  <bb 28> [0.00%]:
  # child_15 = PHI <child_52(3), child_51(5)>
  parent_53 = elm_28(D)->entry.rbe_parent;
  color_54 = elm_28(D)->entry.rbe_color;
  if (child_15 != 0B)
    goto <bb 29>; [0.00%]
  else
    goto <bb 30>; [0.00%]

  <bb 29> [0.00%]:
  child_15->entry.rbe_parent = parent_53;

  <bb 30> [0.00%]:
  if (parent_53 != 0B)
    goto <bb 31>; [0.00%]
  else
    goto <bb 34>; [0.00%]

  <bb 31> [0.00%]:
  _13 = parent_53->entry.rbe_left;
  if (elm_28(D) == _13)
    goto <bb 32>; [0.00%]
  else
    goto <bb 33>; [0.00%]

  <bb 32> [0.00%]:
  parent_53->entry.rbe_left = child_15;
  goto <bb 35> (color); [0.00%]

  <bb 33> [0.00%]:
  parent_53->entry.rbe_right = child_15;
  goto <bb 35> (color); [0.00%]

  <bb 34> [0.00%]:
  head_37(D)->rbh_root = child_15;

  # child_16 = PHI <child_33(27), child_15(33), child_15(34), child_33(25), child_15(32)>
  # parent_18 = PHI <parent_17(27), parent_53(33), parent_53(34), parent_17(25), parent_53(32)>
  # color_19 = PHI <color_35(27), color_54(33), color_54(34), color_35(25), color_54(32)>
color [0.00%]:
  if (color_19 == 0)
    goto <bb 36>; [0.00%]
  else
    goto <bb 37>; [0.00%]

  <bb 36> [0.00%]:
  winlinks_RB_REMOVE_COLOR (head_37(D), parent_18, child_16);

  <bb 37> [0.00%]:
  _60 = old_29;
  return _60;

}



;; Function winlinks_RB_FIND (winlinks_RB_FIND, funcdef_no=55, decl_uid=4348, cgraph_uid=55, symbol_order=58)

Function found to be nothrow: winlinks_RB_FIND
winlinks_RB_FIND (struct winlinks * head, struct winlink * elm)
{
  int comp;
  struct winlink * tmp;
  struct winlink * _2;
  struct winlink * _8;
  struct winlink * _12;

  <bb 2> [0.00%]:
  tmp_7 = head_6(D)->rbh_root;
  goto <bb 8>; [0.00%]

  <bb 3> [0.00%]:
  comp_11 = winlink_cmp (elm_9(D), tmp_1);
  if (comp_11 < 0)
    goto <bb 4>; [0.00%]
  else
    goto <bb 5>; [0.00%]

  <bb 4> [0.00%]:
  tmp_14 = tmp_1->entry.rbe_left;
  goto <bb 8>; [0.00%]

  <bb 5> [0.00%]:
  if (comp_11 > 0)
    goto <bb 6>; [0.00%]
  else
    goto <bb 7>; [0.00%]

  <bb 6> [0.00%]:
  tmp_13 = tmp_1->entry.rbe_right;
  goto <bb 8>; [0.00%]

  <bb 7> [0.00%]:
  _12 = tmp_1;
  goto <bb 10>; [0.00%]

  <bb 8> [0.00%]:
  # tmp_1 = PHI <tmp_7(2), tmp_14(4), tmp_13(6)>
  if (tmp_1 != 0B)
    goto <bb 3>; [0.00%]
  else
    goto <bb 9>; [0.00%]

  <bb 9> [0.00%]:
  _8 = 0B;

  <bb 10> [0.00%]:
  # _2 = PHI <_12(7), _8(9)>
  return _2;

}



;; Function winlinks_RB_NFIND (winlinks_RB_NFIND, funcdef_no=56, decl_uid=4357, cgraph_uid=56, symbol_order=59)

Function found to be nothrow: winlinks_RB_NFIND
winlinks_RB_NFIND (struct winlinks * head, struct winlink * elm)
{
  int comp;
  struct winlink * res;
  struct winlink * tmp;
  struct winlink * _3;
  struct winlink * _10;
  struct winlink * _14;

  <bb 2> [0.00%]:
  tmp_8 = head_7(D)->rbh_root;
  res_9 = 0B;
  goto <bb 8>; [0.00%]

  <bb 3> [0.00%]:
  comp_13 = winlink_cmp (elm_11(D), tmp_1);
  if (comp_13 < 0)
    goto <bb 4>; [0.00%]
  else
    goto <bb 5>; [0.00%]

  <bb 4> [0.00%]:
  res_16 = tmp_1;
  tmp_17 = tmp_1->entry.rbe_left;
  goto <bb 8>; [0.00%]

  <bb 5> [0.00%]:
  if (comp_13 > 0)
    goto <bb 6>; [0.00%]
  else
    goto <bb 7>; [0.00%]

  <bb 6> [0.00%]:
  tmp_15 = tmp_1->entry.rbe_right;
  goto <bb 8>; [0.00%]

  <bb 7> [0.00%]:
  _14 = tmp_1;
  goto <bb 10>; [0.00%]

  <bb 8> [0.00%]:
  # tmp_1 = PHI <tmp_8(2), tmp_17(4), tmp_15(6)>
  # res_2 = PHI <res_9(2), res_16(4), res_2(6)>
  if (tmp_1 != 0B)
    goto <bb 3>; [0.00%]
  else
    goto <bb 9>; [0.00%]

  <bb 9> [0.00%]:
  _10 = res_2;

  <bb 10> [0.00%]:
  # _3 = PHI <_14(7), _10(9)>
  return _3;

}



;; Function winlinks_RB_NEXT (winlinks_RB_NEXT, funcdef_no=57, decl_uid=4366, cgraph_uid=57, symbol_order=60)

Function found to be nothrow: winlinks_RB_NEXT
winlinks_RB_NEXT (struct winlink * elm)
{
  struct winlink * _1;
  struct winlink * _2;
  struct winlink * _3;
  struct winlink * _4;
  struct winlink * _5;
  struct winlink * _6;
  struct winlink * _7;
  struct winlink * _8;
  struct winlink * _19;

  <bb 2> [0.00%]:
  _1 = elm_13(D)->entry.rbe_right;
  if (_1 != 0B)
    goto <bb 3>; [0.00%]
  else
    goto <bb 6>; [0.00%]

  <bb 3> [0.00%]:
  elm_17 = elm_13(D)->entry.rbe_right;
  goto <bb 5>; [0.00%]

  <bb 4> [0.00%]:
  elm_18 = elm_9->entry.rbe_left;

  <bb 5> [0.00%]:
  # elm_9 = PHI <elm_17(3), elm_18(4)>
  _2 = elm_9->entry.rbe_left;
  if (_2 != 0B)
    goto <bb 4>; [0.00%]
  else
    goto <bb 13>; [0.00%]

  <bb 6> [0.00%]:
  _3 = elm_13(D)->entry.rbe_parent;
  if (_3 != 0B)
    goto <bb 7>; [0.00%]
  else
    goto <bb 10>; [0.00%]

  <bb 7> [0.00%]:
  _4 = elm_13(D)->entry.rbe_parent;
  _5 = _4->entry.rbe_left;
  if (elm_13(D) == _5)
    goto <bb 8>; [0.00%]
  else
    goto <bb 10>; [0.00%]

  <bb 8> [0.00%]:
  elm_14 = elm_13(D)->entry.rbe_parent;
  goto <bb 13>; [0.00%]

  <bb 9> [0.00%]:
  elm_15 = elm_10->entry.rbe_parent;

  <bb 10> [0.00%]:
  # elm_10 = PHI <elm_13(D)(7), elm_15(9), elm_13(D)(6)>
  _6 = elm_10->entry.rbe_parent;
  if (_6 != 0B)
    goto <bb 11>; [0.00%]
  else
    goto <bb 12>; [0.00%]

  <bb 11> [0.00%]:
  _7 = elm_10->entry.rbe_parent;
  _8 = _7->entry.rbe_right;
  if (elm_10 == _8)
    goto <bb 9>; [0.00%]
  else
    goto <bb 12>; [0.00%]

  <bb 12> [0.00%]:
  elm_16 = elm_10->entry.rbe_parent;

  <bb 13> [0.00%]:
  # elm_11 = PHI <elm_9(5), elm_14(8), elm_16(12)>
  _19 = elm_11;
  return _19;

}



;; Function winlinks_RB_PREV (winlinks_RB_PREV, funcdef_no=58, decl_uid=4375, cgraph_uid=58, symbol_order=61)

Function found to be nothrow: winlinks_RB_PREV
winlinks_RB_PREV (struct winlink * elm)
{
  struct winlink * _1;
  struct winlink * _2;
  struct winlink * _3;
  struct winlink * _4;
  struct winlink * _5;
  struct winlink * _6;
  struct winlink * _7;
  struct winlink * _8;
  struct winlink * _19;

  <bb 2> [0.00%]:
  _1 = elm_13(D)->entry.rbe_left;
  if (_1 != 0B)
    goto <bb 3>; [0.00%]
  else
    goto <bb 6>; [0.00%]

  <bb 3> [0.00%]:
  elm_17 = elm_13(D)->entry.rbe_left;
  goto <bb 5>; [0.00%]

  <bb 4> [0.00%]:
  elm_18 = elm_9->entry.rbe_right;

  <bb 5> [0.00%]:
  # elm_9 = PHI <elm_17(3), elm_18(4)>
  _2 = elm_9->entry.rbe_right;
  if (_2 != 0B)
    goto <bb 4>; [0.00%]
  else
    goto <bb 13>; [0.00%]

  <bb 6> [0.00%]:
  _3 = elm_13(D)->entry.rbe_parent;
  if (_3 != 0B)
    goto <bb 7>; [0.00%]
  else
    goto <bb 10>; [0.00%]

  <bb 7> [0.00%]:
  _4 = elm_13(D)->entry.rbe_parent;
  _5 = _4->entry.rbe_right;
  if (elm_13(D) == _5)
    goto <bb 8>; [0.00%]
  else
    goto <bb 10>; [0.00%]

  <bb 8> [0.00%]:
  elm_14 = elm_13(D)->entry.rbe_parent;
  goto <bb 13>; [0.00%]

  <bb 9> [0.00%]:
  elm_15 = elm_10->entry.rbe_parent;

  <bb 10> [0.00%]:
  # elm_10 = PHI <elm_13(D)(7), elm_15(9), elm_13(D)(6)>
  _6 = elm_10->entry.rbe_parent;
  if (_6 != 0B)
    goto <bb 11>; [0.00%]
  else
    goto <bb 12>; [0.00%]

  <bb 11> [0.00%]:
  _7 = elm_10->entry.rbe_parent;
  _8 = _7->entry.rbe_left;
  if (elm_10 == _8)
    goto <bb 9>; [0.00%]
  else
    goto <bb 12>; [0.00%]

  <bb 12> [0.00%]:
  elm_16 = elm_10->entry.rbe_parent;

  <bb 13> [0.00%]:
  # elm_11 = PHI <elm_9(5), elm_14(8), elm_16(12)>
  _19 = elm_11;
  return _19;

}



;; Function winlinks_RB_MINMAX (winlinks_RB_MINMAX, funcdef_no=59, decl_uid=4385, cgraph_uid=59, symbol_order=62)

Function found to be nothrow: winlinks_RB_MINMAX
winlinks_RB_MINMAX (struct winlinks * head, int val)
{
  struct winlink * parent;
  struct winlink * tmp;
  struct winlink * _7;

  <bb 2> [0.00%]:
  tmp_5 = head_4(D)->rbh_root;
  parent_6 = 0B;
  goto <bb 6>; [0.00%]

  <bb 3> [0.00%]:
  parent_8 = tmp_1;
  if (val_9(D) < 0)
    goto <bb 4>; [0.00%]
  else
    goto <bb 5>; [0.00%]

  <bb 4> [0.00%]:
  tmp_11 = tmp_1->entry.rbe_left;
  goto <bb 6>; [0.00%]

  <bb 5> [0.00%]:
  tmp_10 = tmp_1->entry.rbe_right;

  <bb 6> [0.00%]:
  # tmp_1 = PHI <tmp_5(2), tmp_11(4), tmp_10(5)>
  # parent_2 = PHI <parent_6(2), parent_8(4), parent_8(5)>
  if (tmp_1 != 0B)
    goto <bb 3>; [0.00%]
  else
    goto <bb 7>; [0.00%]

  <bb 7> [0.00%]:
  _7 = parent_2;
  return _7;

}



;; Function xrealloc (xrealloc, funcdef_no=60, decl_uid=4395, cgraph_uid=60, symbol_order=63)

Function found to be nothrow: xrealloc
xrealloc (void * oldptr, size_t nmemb, size_t size)
{
  void * newptr;
  size_t newsize;
  long unsigned int _1;
  void * _9;

  <bb 2> [0.00%]:
  newsize_4 = nmemb_2(D) * size_3(D);
  if (newsize_4 == 0)
    goto <bb 3>; [0.00%]
  else
    goto <bb 4>; [0.00%]

  <bb 3> [0.00%]:
  printf ("zero size%s", "");
  exit (1);

  <bb 4> [0.00%]:
  _1 = 1073741824 / nmemb_2(D);
  if (size_3(D) > _1)
    goto <bb 5>; [0.00%]
  else
    goto <bb 6>; [0.00%]

  <bb 5> [0.00%]:
  printf ("nmemb * size > SIZE_MAX%s", "");
  exit (1);

  <bb 6> [0.00%]:
  newptr_8 = realloc (oldptr_6(D), newsize_4);
  if (newptr_8 == 0B)
    goto <bb 7>; [0.00%]
  else
    goto <bb 8>; [0.00%]

  <bb 7> [0.00%]:
  printf ("xrealloc failed%s", "");
  exit (1);

  <bb 8> [0.00%]:
  _9 = newptr_8;
  return _9;

}



;; Function winlink_find_by_index (winlink_find_by_index, funcdef_no=61, decl_uid=4401, cgraph_uid=61, symbol_order=64)

Function found to be nothrow: winlink_find_by_index
winlink_find_by_index (struct winlinks * wwl, int idx)
{
  struct winlink wl;
  struct winlink * _6;

  <bb 2> [0.00%]:
  if (idx_1(D) < 0)
    goto <bb 3>; [0.00%]
  else
    goto <bb 4>; [0.00%]

  <bb 3> [0.00%]:
  printf ("bad index%s", "");
  exit (1);

  <bb 4> [0.00%]:
  wl.idx = idx_1(D);
  _6 = winlinks_RB_FIND (wwl_4(D), &wl);
  wl ={v} {CLOBBER};
  return _6;

}



;; Function winlink_count (winlink_count, funcdef_no=62, decl_uid=4405, cgraph_uid=62, symbol_order=65)

Function found to be nothrow: winlink_count
winlink_count (struct winlinks * wwl)
{
  u_int n;
  struct winlink * wl;
  u_int _9;

  <bb 2> [0.00%]:
  n_4 = 0;
  wl_8 = winlinks_RB_MINMAX (wwl_6(D), -1);
  goto <bb 4>; [0.00%]

  <bb 3> [0.00%]:
  n_10 = n_2 + 1;
  wl_12 = winlinks_RB_NEXT (wl_1);

  <bb 4> [0.00%]:
  # wl_1 = PHI <wl_8(2), wl_12(3)>
  # n_2 = PHI <n_4(2), n_10(3)>
  if (wl_1 != 0B)
    goto <bb 3>; [0.00%]
  else
    goto <bb 5>; [0.00%]

  <bb 5> [0.00%]:
  _9 = n_2;
  return _9;

}



;; Function winlink_next_index (winlink_next_index, funcdef_no=63, decl_uid=4414, cgraph_uid=63, symbol_order=66)

Function found to be nothrow: winlink_next_index
winlink_next_index (struct winlinks * wwl, int idx)
{
  int i;
  struct winlink * _1;
  int _4;
  int _13;
  int _14;

  <bb 2> [0.00%]:
  i_7 = idx_6(D);

  <bb 3> [0.00%]:
  # i_2 = PHI <i_7(2), i_3(8)>
  _1 = winlink_find_by_index (wwl_9(D), i_2);
  if (_1 == 0B)
    goto <bb 4>; [0.00%]
  else
    goto <bb 5>; [0.00%]

  <bb 4> [0.00%]:
  _14 = i_2;
  goto <bb 10>; [0.00%]

  <bb 5> [0.00%]:
  if (i_2 == 10000)
    goto <bb 6>; [0.00%]
  else
    goto <bb 7>; [0.00%]

  <bb 6> [0.00%]:
  i_12 = 0;
  goto <bb 8>; [0.00%]

  <bb 7> [0.00%]:
  i_11 = i_2 + 1;

  <bb 8> [0.00%]:
  # i_3 = PHI <i_12(6), i_11(7)>
  if (i_3 != idx_6(D))
    goto <bb 3>; [0.00%]
  else
    goto <bb 9>; [0.00%]

  <bb 9> [0.00%]:
  _13 = -1;

  <bb 10> [0.00%]:
  # _4 = PHI <_14(4), _13(9)>
  return _4;

}



;; Function winlink_find_by_window (winlink_find_by_window, funcdef_no=64, decl_uid=4421, cgraph_uid=64, symbol_order=67)

Function found to be nothrow: winlink_find_by_window
winlink_find_by_window (struct winlinks * wwl, struct window * w)
{
  struct winlink * wl;
  struct window * _1;
  struct winlink * _3;
  struct winlink * _9;
  struct winlink * _13;

  <bb 2> [0.00%]:
  wl_8 = winlinks_RB_MINMAX (wwl_6(D), -1);
  goto <bb 6>; [0.00%]

  <bb 3> [0.00%]:
  _1 = wl_2->window;
  if (w_10(D) == _1)
    goto <bb 4>; [0.00%]
  else
    goto <bb 5>; [0.00%]

  <bb 4> [0.00%]:
  _13 = wl_2;
  goto <bb 8>; [0.00%]

  <bb 5> [0.00%]:
  wl_12 = winlinks_RB_NEXT (wl_2);

  <bb 6> [0.00%]:
  # wl_2 = PHI <wl_8(2), wl_12(5)>
  if (wl_2 != 0B)
    goto <bb 3>; [0.00%]
  else
    goto <bb 7>; [0.00%]

  <bb 7> [0.00%]:
  _9 = 0B;

  <bb 8> [0.00%]:
  # _3 = PHI <_13(4), _9(7)>
  return _3;

}



;; Function cmd_find_pane (cmd_find_pane, funcdef_no=65, decl_uid=4429, cgraph_uid=65, symbol_order=68)

Function found to be nothrow: cmd_find_pane
cmd_find_pane (int arg, struct session * * sp)
{
  struct session * s;
  unsigned int _1;
  struct session * * _2;
  struct winlink * _3;
  struct winlink * _4;
  struct winlink * _13;
  struct winlink * _14;
  struct winlink * _16;

  <bb 2> [0.00%]:
  _1 = sessions.num;
  if (_1 == 0)
    goto <bb 3>; [0.00%]
  else
    goto <bb 4>; [0.00%]

  <bb 3> [0.00%]:
  printf ("can\'t establish current session\n");
  _16 = 0B;
  goto <bb 9>; [0.00%]

  <bb 4> [0.00%]:
  _2 = sessions.list;
  s_8 = MEM[(struct session * *)_2 + 8B];
  if (sp_9(D) != 0B)
    goto <bb 5>; [0.00%]
  else
    goto <bb 6>; [0.00%]

  <bb 5> [0.00%]:
  *sp_9(D) = s_8;

  <bb 6> [0.00%]:
  if (arg_11(D) != 0)
    goto <bb 7>; [0.00%]
  else
    goto <bb 8>; [0.00%]

  <bb 7> [0.00%]:
  _14 = s_8->curw;
  goto <bb 9>; [0.00%]

  <bb 8> [0.00%]:
  _3 = s_8->curw;
  _13 = winlinks_RB_NEXT (_3);

  <bb 9> [0.00%]:
  # _4 = PHI <_16(3), _14(7), _13(8)>
  return _4;

}



;; Function session_has (session_has, funcdef_no=66, decl_uid=4436, cgraph_uid=66, symbol_order=69)

Function found to be nothrow: session_has
session_has (struct session * s, struct window * w)
{
  struct winlink * wl;
  struct winlinks * _1;
  struct window * _2;
  int _4;
  int _10;
  int _14;

  <bb 2> [0.00%]:
  _1 = &s_6(D)->windows;
  wl_9 = winlinks_RB_MINMAX (_1, -1);
  goto <bb 6>; [0.00%]

  <bb 3> [0.00%]:
  _2 = wl_3->window;
  if (w_11(D) == _2)
    goto <bb 4>; [0.00%]
  else
    goto <bb 5>; [0.00%]

  <bb 4> [0.00%]:
  _14 = 1;
  goto <bb 8>; [0.00%]

  <bb 5> [0.00%]:
  wl_13 = winlinks_RB_NEXT (wl_3);

  <bb 6> [0.00%]:
  # wl_3 = PHI <wl_9(2), wl_13(5)>
  if (wl_3 != 0B)
    goto <bb 3>; [0.00%]
  else
    goto <bb 7>; [0.00%]

  <bb 7> [0.00%]:
  _10 = 0;

  <bb 8> [0.00%]:
  # _4 = PHI <_14(4), _10(7)>
  return _4;

}



;; Function session_group_find (session_group_find, funcdef_no=67, decl_uid=4443, cgraph_uid=67, symbol_order=70)

Function found to be nothrow: session_group_find
session_group_find (struct session * target)
{
  struct session * s;
  struct session_group * sg;
  struct session_group * _3;
  struct session_group * _6;
  struct session_group * _11;

  <bb 2> [0.00%]:
  sg_5 = session_groups.tqh_first;
  goto <bb 9>; [0.00%]

  <bb 3> [0.00%]:
  s_7 = sg_1->sessions.tqh_first;
  goto <bb 7>; [0.00%]

  <bb 4> [0.00%]:
  if (s_2 == target_9(D))
    goto <bb 5>; [0.00%]
  else
    goto <bb 6>; [0.00%]

  <bb 5> [0.00%]:
  _11 = sg_1;
  goto <bb 11>; [0.00%]

  <bb 6> [0.00%]:
  s_10 = s_2->gentry.tqe_next;

  <bb 7> [0.00%]:
  # s_2 = PHI <s_7(3), s_10(6)>
  if (s_2 != 0B)
    goto <bb 4>; [0.00%]
  else
    goto <bb 8>; [0.00%]

  <bb 8> [0.00%]:
  sg_8 = sg_1->entry.tqe_next;

  <bb 9> [0.00%]:
  # sg_1 = PHI <sg_5(2), sg_8(8)>
  if (sg_1 != 0B)
    goto <bb 3>; [0.00%]
  else
    goto <bb 10>; [0.00%]

  <bb 10> [0.00%]:
  _6 = 0B;

  <bb 11> [0.00%]:
  # _3 = PHI <_11(5), _6(10)>
  return _3;

}



;; Function session_group_add (session_group_add, funcdef_no=68, decl_uid=4455, cgraph_uid=68, symbol_order=71)

Function found to be nothrow: session_group_add
session_group_add (struct session * target, struct session * s)
{
  struct session_group * sg;
  struct session_group * * _1;
  struct session_group * * _2;
  struct session_group * * _3;
  struct session * * _4;
  struct session * * _5;
  struct session * * _6;
  struct session * * _7;
  struct session * * _8;
  struct session * * _9;
  struct session * * _10;

  <bb 2> [0.00%]:
  sg_16 = session_group_find (target_14(D));
  if (sg_16 == 0B)
    goto <bb 3>; [0.00%]
  else
    goto <bb 4>; [0.00%]

  <bb 3> [0.00%]:
  sg_18 = malloc (32);
  sg_18->entry.tqe_next = 0B;
  _1 = session_groups.tqh_last;
  sg_18->entry.tqe_prev = _1;
  _2 = session_groups.tqh_last;
  *_2 = sg_18;
  _3 = &sg_18->entry.tqe_next;
  session_groups.tqh_last = _3;
  sg_18->sessions.tqh_first = 0B;
  _4 = &sg_18->sessions.tqh_first;
  sg_18->sessions.tqh_last = _4;
  target_14(D)->gentry.tqe_next = 0B;
  _5 = sg_18->sessions.tqh_last;
  target_14(D)->gentry.tqe_prev = _5;
  _6 = sg_18->sessions.tqh_last;
  *_6 = target_14(D);
  _7 = &target_14(D)->gentry.tqe_next;
  sg_18->sessions.tqh_last = _7;

  <bb 4> [0.00%]:
  # sg_11 = PHI <sg_16(2), sg_18(3)>
  s_29(D)->gentry.tqe_next = 0B;
  _8 = sg_11->sessions.tqh_last;
  s_29(D)->gentry.tqe_prev = _8;
  _9 = sg_11->sessions.tqh_last;
  *_9 = s_29(D);
  _10 = &s_29(D)->gentry.tqe_next;
  sg_11->sessions.tqh_last = _10;
  return;

}



;; Function winlink_add (winlink_add, funcdef_no=69, decl_uid=4461, cgraph_uid=69, symbol_order=72)

Function found to be nothrow: winlink_add
winlink_add (struct winlinks * wwl, struct window * w, int idx)
{
  struct winlink * wl;
  int _1;
  struct winlink * _2;
  unsigned int _3;
  unsigned int _4;
  struct winlink * _6;
  struct winlink * _13;
  struct winlink * _16;
  struct winlink * _24;

  <bb 2> [0.00%]:
  if (idx_9(D) < 0)
    goto <bb 3>; [0.00%]
  else
    goto <bb 5>; [0.00%]

  <bb 3> [0.00%]:
  _1 = ~idx_9(D);
  idx_15 = winlink_next_index (wwl_11(D), _1);
  if (idx_15 == -1)
    goto <bb 4>; [0.00%]
  else
    goto <bb 7>; [0.00%]

  <bb 4> [0.00%]:
  _16 = 0B;
  goto <bb 8>; [0.00%]

  <bb 5> [0.00%]:
  _2 = winlink_find_by_index (wwl_11(D), idx_9(D));
  if (_2 != 0B)
    goto <bb 6>; [0.00%]
  else
    goto <bb 7>; [0.00%]

  <bb 6> [0.00%]:
  _13 = 0B;
  goto <bb 8>; [0.00%]

  <bb 7> [0.00%]:
  # idx_5 = PHI <idx_15(3), idx_9(D)(5)>
  wl_18 = calloc (1, 136);
  wl_18->idx = idx_5;
  wl_18->window = w_20(D);
  winlinks_RB_INSERT (wwl_11(D), wl_18);
  _3 = w_20(D)->references;
  _4 = _3 + 1;
  w_20(D)->references = _4;
  _24 = wl_18;

  <bb 8> [0.00%]:
  # _6 = PHI <_16(4), _13(6), _24(7)>
  return _6;

}



;; Function window_index (window_index, funcdef_no=70, decl_uid=4466, cgraph_uid=70, symbol_order=73)

Function found to be nothrow: window_index
window_index (struct window * s, u_int * i)
{
  struct window * * _1;
  unsigned int _2;
  long unsigned int _3;
  long unsigned int _4;
  struct window * * _5;
  struct window * _6;
  unsigned int _7;
  unsigned int _8;
  unsigned int _9;
  unsigned int _10;
  int _11;
  int _16;
  int _19;

  <bb 2> [0.00%]:
  *i_14(D) = 0;
  goto <bb 6>; [0.00%]

  <bb 3> [0.00%]:
  _1 = windows.list;
  _2 = *i_14(D);
  _3 = (long unsigned int) _2;
  _4 = _3 * 8;
  _5 = _1 + _4;
  _6 = *_5;
  if (s_17(D) == _6)
    goto <bb 4>; [0.00%]
  else
    goto <bb 5>; [0.00%]

  <bb 4> [0.00%]:
  _19 = 0;
  goto <bb 8>; [0.00%]

  <bb 5> [0.00%]:
  _7 = *i_14(D);
  _8 = _7 + 1;
  *i_14(D) = _8;

  <bb 6> [0.00%]:
  _9 = *i_14(D);
  _10 = windows.num;
  if (_9 < _10)
    goto <bb 3>; [0.00%]
  else
    goto <bb 7>; [0.00%]

  <bb 7> [0.00%]:
  _16 = -1;

  <bb 8> [0.00%]:
  # _11 = PHI <_19(4), _16(7)>
  return _11;

}



;; Function session_group_remove (session_group_remove, funcdef_no=71, decl_uid=4472, cgraph_uid=71, symbol_order=74)

Function found to be nothrow: session_group_remove
session_group_remove (struct session * s)
{
  struct session_group * sg;
  struct session * _1;
  struct session * _2;
  struct session * * _3;
  struct session * * _4;
  struct session * * _5;
  struct session * _6;
  struct session * _7;
  struct session * _8;
  struct session * _9;
  struct session * _10;
  struct session * _11;
  struct session * _12;
  struct session * _13;
  struct session * * _14;
  struct session * _15;
  struct session * * _16;
  struct session * _17;
  struct session * _18;
  struct session * * _19;
  struct session * _20;
  struct session * _21;
  struct session_group * _22;
  struct session_group * _23;
  struct session_group * * _24;
  struct session_group * * _25;
  struct session_group * * _26;
  struct session_group * _27;

  <bb 2> [0.00%]:
  sg_36 = session_group_find (s_34(D));
  if (sg_36 == 0B)
    goto <bb 16>; [0.00%]
  else
    goto <bb 3>; [0.00%]

  <bb 3> [0.00%]:
  _1 = s_34(D)->gentry.tqe_next;
  if (_1 != 0B)
    goto <bb 4>; [0.00%]
  else
    goto <bb 5>; [0.00%]

  <bb 4> [0.00%]:
  _2 = s_34(D)->gentry.tqe_next;
  _3 = s_34(D)->gentry.tqe_prev;
  _2->gentry.tqe_prev = _3;
  goto <bb 6>; [0.00%]

  <bb 5> [0.00%]:
  _4 = s_34(D)->gentry.tqe_prev;
  sg_36->sessions.tqh_last = _4;

  <bb 6> [0.00%]:
  _5 = s_34(D)->gentry.tqe_prev;
  _6 = s_34(D)->gentry.tqe_next;
  *_5 = _6;
  _7 = sg_36->sessions.tqh_first;
  _8 = _7->gentry.tqe_next;
  if (_8 == 0B)
    goto <bb 7>; [0.00%]
  else
    goto <bb 11>; [0.00%]

  <bb 7> [0.00%]:
  _9 = sg_36->sessions.tqh_first;
  _10 = _9->gentry.tqe_next;
  if (_10 != 0B)
    goto <bb 8>; [0.00%]
  else
    goto <bb 9>; [0.00%]

  <bb 8> [0.00%]:
  _11 = sg_36->sessions.tqh_first;
  _12 = sg_36->sessions.tqh_first;
  _13 = _12->gentry.tqe_next;
  _14 = _11->gentry.tqe_prev;
  _13->gentry.tqe_prev = _14;
  goto <bb 10>; [0.00%]

  <bb 9> [0.00%]:
  _15 = sg_36->sessions.tqh_first;
  _16 = _15->gentry.tqe_prev;
  sg_36->sessions.tqh_last = _16;

  <bb 10> [0.00%]:
  _17 = sg_36->sessions.tqh_first;
  _18 = sg_36->sessions.tqh_first;
  _19 = _18->gentry.tqe_prev;
  _20 = _17->gentry.tqe_next;
  *_19 = _20;

  <bb 11> [0.00%]:
  _21 = sg_36->sessions.tqh_first;
  if (_21 == 0B)
    goto <bb 12>; [0.00%]
  else
    goto <bb 16>; [0.00%]

  <bb 12> [0.00%]:
  _22 = sg_36->entry.tqe_next;
  if (_22 != 0B)
    goto <bb 13>; [0.00%]
  else
    goto <bb 14>; [0.00%]

  <bb 13> [0.00%]:
  _23 = sg_36->entry.tqe_next;
  _24 = sg_36->entry.tqe_prev;
  _23->entry.tqe_prev = _24;
  goto <bb 15>; [0.00%]

  <bb 14> [0.00%]:
  _25 = sg_36->entry.tqe_prev;
  session_groups.tqh_last = _25;

  <bb 15> [0.00%]:
  _26 = sg_36->entry.tqe_prev;
  _27 = sg_36->entry.tqe_next;
  *_26 = _27;
  free (sg_36);

  <bb 16> [0.00%]:
  return;

}



;; Function session_find (session_find, funcdef_no=72, decl_uid=4476, cgraph_uid=72, symbol_order=75)

Function found to be nothrow: session_find
session_find (const char * name)
{
  u_int i;
  struct session * s;
  struct session * * _1;
  long unsigned int _2;
  long unsigned int _3;
  struct session * * _4;
  char * _5;
  int _6;
  unsigned int _7;
  struct session * _9;
  struct session * _12;
  struct session * _15;

  <bb 2> [0.00%]:
  i_10 = 0;
  goto <bb 7>; [0.00%]

  <bb 3> [0.00%]:
  _1 = sessions.list;
  _2 = (long unsigned int) i_8;
  _3 = _2 * 8;
  _4 = _1 + _3;
  s_13 = *_4;
  if (s_13 != 0B)
    goto <bb 4>; [0.00%]
  else
    goto <bb 6>; [0.00%]

  <bb 4> [0.00%]:
  _5 = s_13->name;
  _6 = strcmp (_5, name_14(D));
  if (_6 == 0)
    goto <bb 5>; [0.00%]
  else
    goto <bb 6>; [0.00%]

  <bb 5> [0.00%]:
  _15 = s_13;
  goto <bb 9>; [0.00%]

  <bb 6> [0.00%]:
  i_16 = i_8 + 1;

  <bb 7> [0.00%]:
  # i_8 = PHI <i_10(2), i_16(6)>
  _7 = sessions.num;
  if (i_8 < _7)
    goto <bb 3>; [0.00%]
  else
    goto <bb 8>; [0.00%]

  <bb 8> [0.00%]:
  _12 = 0B;

  <bb 9> [0.00%]:
  # _9 = PHI <_15(5), _12(8)>
  return _9;

}



;; Function session_index (session_index, funcdef_no=73, decl_uid=4485, cgraph_uid=73, symbol_order=76)

Function found to be nothrow: session_index
session_index (struct session * s, u_int * i)
{
  struct session * * _1;
  unsigned int _2;
  long unsigned int _3;
  long unsigned int _4;
  struct session * * _5;
  struct session * _6;
  unsigned int _7;
  unsigned int _8;
  unsigned int _9;
  unsigned int _10;
  int _11;
  int _16;
  int _19;

  <bb 2> [0.00%]:
  *i_14(D) = 0;
  goto <bb 6>; [0.00%]

  <bb 3> [0.00%]:
  _1 = sessions.list;
  _2 = *i_14(D);
  _3 = (long unsigned int) _2;
  _4 = _3 * 8;
  _5 = _1 + _4;
  _6 = *_5;
  if (s_17(D) == _6)
    goto <bb 4>; [0.00%]
  else
    goto <bb 5>; [0.00%]

  <bb 4> [0.00%]:
  _19 = 0;
  goto <bb 8>; [0.00%]

  <bb 5> [0.00%]:
  _7 = *i_14(D);
  _8 = _7 + 1;
  *i_14(D) = _8;

  <bb 6> [0.00%]:
  _9 = *i_14(D);
  _10 = sessions.num;
  if (_9 < _10)
    goto <bb 3>; [0.00%]
  else
    goto <bb 7>; [0.00%]

  <bb 7> [0.00%]:
  _16 = -1;

  <bb 8> [0.00%]:
  # _11 = PHI <_19(4), _16(7)>
  return _11;

}



;; Function winlink_stack_remove (winlink_stack_remove, funcdef_no=74, decl_uid=4492, cgraph_uid=74, symbol_order=77)

Function found to be nothrow: winlink_stack_remove
winlink_stack_remove (struct winlink_stack * stack, struct winlink * wl)
{
  struct winlink * wl2;
  struct winlink * _1;
  struct winlink * _2;
  struct winlink * * _3;
  struct winlink * * _4;
  struct winlink * * _5;
  struct winlink * _6;

  <bb 2> [0.00%]:
  if (wl_10(D) == 0B)
    goto <bb 11>; [0.00%]
  else
    goto <bb 3>; [0.00%]

  <bb 3> [0.00%]:
  wl2_13 = stack_12(D)->tqh_first;
  goto <bb 10>; [0.00%]

  <bb 4> [0.00%]:
  if (wl2_7 == wl_10(D))
    goto <bb 5>; [0.00%]
  else
    goto <bb 9>; [0.00%]

  <bb 5> [0.00%]:
  _1 = wl_10(D)->sentry.tqe_next;
  if (_1 != 0B)
    goto <bb 6>; [0.00%]
  else
    goto <bb 7>; [0.00%]

  <bb 6> [0.00%]:
  _2 = wl_10(D)->sentry.tqe_next;
  _3 = wl_10(D)->sentry.tqe_prev;
  _2->sentry.tqe_prev = _3;
  goto <bb 8>; [0.00%]

  <bb 7> [0.00%]:
  _4 = wl_10(D)->sentry.tqe_prev;
  stack_12(D)->tqh_last = _4;

  <bb 8> [0.00%]:
  _5 = wl_10(D)->sentry.tqe_prev;
  _6 = wl_10(D)->sentry.tqe_next;
  *_5 = _6;
  goto <bb 11>; [0.00%]

  <bb 9> [0.00%]:
  wl2_14 = wl2_7->sentry.tqe_next;

  <bb 10> [0.00%]:
  # wl2_7 = PHI <wl2_13(3), wl2_14(9)>
  if (wl2_7 != 0B)
    goto <bb 4>; [0.00%]
  else
    goto <bb 11>; [0.00%]

  <bb 11> [0.00%]:
  return;

}



;; Function winlink_stack_push (winlink_stack_push, funcdef_no=75, decl_uid=4500, cgraph_uid=75, symbol_order=78)

Function found to be nothrow: winlink_stack_push
winlink_stack_push (struct winlink_stack * stack, struct winlink * wl)
{
  struct winlink * _1;
  struct winlink * _2;
  struct winlink * _3;
  struct winlink * * _4;
  struct winlink * * _5;
  struct winlink * * _6;

  <bb 2> [0.00%]:
  if (wl_9(D) == 0B)
    goto <bb 7>; [0.00%]
  else
    goto <bb 3>; [0.00%]

  <bb 3> [0.00%]:
  winlink_stack_remove (stack_11(D), wl_9(D));
  _1 = stack_11(D)->tqh_first;
  wl_9(D)->sentry.tqe_next = _1;
  _2 = wl_9(D)->sentry.tqe_next;
  if (_2 != 0B)
    goto <bb 4>; [0.00%]
  else
    goto <bb 5>; [0.00%]

  <bb 4> [0.00%]:
  _3 = stack_11(D)->tqh_first;
  _4 = &wl_9(D)->sentry.tqe_next;
  _3->sentry.tqe_prev = _4;
  goto <bb 6>; [0.00%]

  <bb 5> [0.00%]:
  _5 = &wl_9(D)->sentry.tqe_next;
  stack_11(D)->tqh_last = _5;

  <bb 6> [0.00%]:
  stack_11(D)->tqh_first = wl_9(D);
  _6 = &stack_11(D)->tqh_first;
  wl_9(D)->sentry.tqe_prev = _6;

  <bb 7> [0.00%]:
  return;

}



;; Function window_destroy (window_destroy, funcdef_no=76, decl_uid=4503, cgraph_uid=76, symbol_order=79)

Function found to be nothrow: window_destroy
window_destroy (struct window * w)
{
  u_int i;
  int _1;
  struct window * * _2;
  unsigned int i.0_3;
  long unsigned int _4;
  long unsigned int _5;
  struct window * * _6;
  unsigned int _7;
  unsigned int _8;
  unsigned int _9;
  struct window * * _10;
  unsigned int _11;
  struct window * * _12;
  unsigned int _13;
  unsigned int _14;
  long unsigned int _15;
  long unsigned int _16;
  struct window * * _17;
  struct window * _18;
  char * _19;
  char * _20;

  <bb 2> [0.00%]:
  _1 = window_index (w_24(D), &i);
  if (_1 != 0)
    goto <bb 3>; [0.00%]
  else
    goto <bb 4>; [0.00%]

  <bb 3> [0.00%]:
  printf ("index not found%s\n", "");
  exit (1);

  <bb 4> [0.00%]:
  _2 = windows.list;
  i.0_3 = i;
  _4 = (long unsigned int) i.0_3;
  _5 = _4 * 8;
  _6 = _2 + _5;
  *_6 = 0B;
  goto <bb 8>; [0.00%]

  <bb 5> [0.00%]:
  _7 = windows.num;
  if (_7 > 1)
    goto <bb 6>; [0.00%]
  else
    goto <bb 7>; [0.00%]

  <bb 6> [0.00%]:
  _8 = windows.num;
  _9 = _8 + 4294967295;
  windows.num = _9;
  goto <bb 8>; [0.00%]

  <bb 7> [0.00%]:
  _10 = windows.list;
  free (_10);
  windows.num = 0;
  windows.list = 0B;
  windows.space = 0;

  <bb 8> [0.00%]:
  _11 = windows.num;
  if (_11 != 0)
    goto <bb 9>; [0.00%]
  else
    goto <bb 10>; [0.00%]

  <bb 9> [0.00%]:
  _12 = windows.list;
  _13 = windows.num;
  _14 = _13 + 4294967295;
  _15 = (long unsigned int) _14;
  _16 = _15 * 8;
  _17 = _12 + _16;
  _18 = *_17;
  if (_18 == 0B)
    goto <bb 5>; [0.00%]
  else
    goto <bb 10>; [0.00%]

  <bb 10> [0.00%]:
  _19 = w_24(D)->name;
  if (_19 != 0B)
    goto <bb 11>; [0.00%]
  else
    goto <bb 12>; [0.00%]

  <bb 11> [0.00%]:
  _20 = w_24(D)->name;
  free (_20);

  <bb 12> [0.00%]:
  free (w_24(D));
  i ={v} {CLOBBER};
  return;

}



;; Function winlink_remove (winlink_remove, funcdef_no=77, decl_uid=4511, cgraph_uid=77, symbol_order=80)

Function found to be nothrow: winlink_remove
winlink_remove (struct winlinks * wwl, struct winlink * wl)
{
  struct window * w;
  char * _1;
  char * _2;
  unsigned int _3;
  unsigned int _4;
  unsigned int _5;
  unsigned int _6;

  <bb 2> [0.00%]:
  w_11 = wl_10(D)->window;
  winlinks_RB_REMOVE (wwl_12(D), wl_10(D));
  _1 = wl_10(D)->status_text;
  if (_1 != 0B)
    goto <bb 3>; [0.00%]
  else
    goto <bb 4>; [0.00%]

  <bb 3> [0.00%]:
  _2 = wl_10(D)->status_text;
  free (_2);

  <bb 4> [0.00%]:
  free (wl_10(D));
  _3 = w_11->references;
  if (_3 == 0)
    goto <bb 5>; [0.00%]
  else
    goto <bb 6>; [0.00%]

  <bb 5> [0.00%]:
  printf ("bad reference count%s\n", "");
  exit (1);

  <bb 6> [0.00%]:
  _4 = w_11->references;
  _5 = _4 + 4294967295;
  w_11->references = _5;
  _6 = w_11->references;
  if (_6 == 0)
    goto <bb 7>; [0.00%]
  else
    goto <bb 8>; [0.00%]

  <bb 7> [0.00%]:
  window_destroy (w_11);

  <bb 8> [0.00%]:
  return;

}



;; Function session_group_synchronize1 (session_group_synchronize1, funcdef_no=78, decl_uid=4516, cgraph_uid=78, symbol_order=81)

Function found to be nothrow: session_group_synchronize1
session_group_synchronize1 (struct session * target, struct session * s)
{
  struct winlink * wl2;
  struct winlink * wl;
  struct winlink_stack old_lastw;
  struct winlinks * ww;
  struct winlinks old_windows;
  struct winlink * _1;
  struct winlinks * _2;
  int _3;
  struct window * _4;
  struct winlinks * _5;
  struct winlink_stack * _6;
  struct winlink * * _7;
  int _8;
  struct winlinks * _9;
  struct winlink * * _10;
  struct winlink * * _11;
  struct winlink * * _12;
  struct winlink * _13;
  struct winlink * _14;

  <bb 2> [0.00%]:
  ww_23 = &target_22(D)->windows;
  _1 = ww_23->rbh_root;
  if (_1 == 0B)
    goto <bb 15>; [0.00%]
  else
    goto <bb 3>; [0.00%]

  <bb 3> [0.00%]:
  _2 = &s_25(D)->windows;
  memcpy (&old_windows, _2, 8);
  s_25(D)->windows.rbh_root = 0B;
  wl_29 = winlinks_RB_MINMAX (ww_23, -1);
  goto <bb 5>; [0.00%]

  <bb 4> [0.00%]:
  _3 = wl_15->idx;
  _4 = wl_15->window;
  _5 = &s_25(D)->windows;
  winlink_add (_5, _4, _3);
  wl_48 = winlinks_RB_NEXT (wl_15);

  <bb 5> [0.00%]:
  # wl_15 = PHI <wl_29(3), wl_48(4)>
  if (wl_15 != 0B)
    goto <bb 4>; [0.00%]
  else
    goto <bb 6>; [0.00%]

  <bb 6> [0.00%]:
  _6 = &s_25(D)->lastw;
  memcpy (&old_lastw, _6, 16);
  s_25(D)->lastw.tqh_first = 0B;
  _7 = &s_25(D)->lastw.tqh_first;
  s_25(D)->lastw.tqh_last = _7;
  wl_33 = old_lastw.tqh_first;
  goto <bb 10>; [0.00%]

  <bb 7> [0.00%]:
  _8 = wl_16->idx;
  _9 = &s_25(D)->windows;
  wl2_40 = winlink_find_by_index (_9, _8);
  if (wl2_40 != 0B)
    goto <bb 8>; [0.00%]
  else
    goto <bb 9>; [0.00%]

  <bb 8> [0.00%]:
  wl2_40->sentry.tqe_next = 0B;
  _10 = s_25(D)->lastw.tqh_last;
  wl2_40->sentry.tqe_prev = _10;
  _11 = s_25(D)->lastw.tqh_last;
  *_11 = wl2_40;
  _12 = &wl2_40->sentry.tqe_next;
  s_25(D)->lastw.tqh_last = _12;

  <bb 9> [0.00%]:
  wl_45 = wl_16->sentry.tqe_next;

  <bb 10> [0.00%]:
  # wl_16 = PHI <wl_33(6), wl_45(9)>
  if (wl_16 != 0B)
    goto <bb 7>; [0.00%]
  else
    goto <bb 11>; [0.00%]

  <bb 11> [0.00%]:
  _13 = s_25(D)->lastw.tqh_first;
  s_25(D)->curw = _13;
  goto <bb 13>; [0.00%]

  <bb 12> [0.00%]:
  wl_37 = old_windows.rbh_root;
  winlink_remove (&old_windows, wl_37);

  <bb 13> [0.00%]:
  _14 = old_windows.rbh_root;
  if (_14 != 0B)
    goto <bb 12>; [0.00%]
  else
    goto <bb 14>; [0.00%]

  <bb 14> [0.00%]:
  old_windows ={v} {CLOBBER};
  old_lastw ={v} {CLOBBER};
  goto <bb 16>; [0.00%]

  <bb 15> [0.00%]:
  old_windows ={v} {CLOBBER};
  old_lastw ={v} {CLOBBER};

  <bb 16> [0.00%]:
  return;

}



;; Function session_group_synchronize_to (session_group_synchronize_to, funcdef_no=79, decl_uid=4535, cgraph_uid=79, symbol_order=82)

Function found to be nothrow: session_group_synchronize_to
session_group_synchronize_to (struct session * s)
{
  struct session * target;
  struct session_group * sg;

  <bb 2> [0.00%]:
  sg_6 = session_group_find (s_4(D));
  if (sg_6 == 0B)
    goto <bb 8>; [0.00%]
  else
    goto <bb 3>; [0.00%]

  <bb 3> [0.00%]:
  target_7 = 0B;
  target_8 = sg_6->sessions.tqh_first;
  goto <bb 6>; [0.00%]

  <bb 4> [0.00%]:
  if (target_1 != s_4(D))
    goto <bb 7>; [0.00%]
  else
    goto <bb 5>; [0.00%]

  <bb 5> [0.00%]:
  target_9 = target_1->gentry.tqe_next;

  <bb 6> [0.00%]:
  # target_1 = PHI <target_8(3), target_9(5)>
  if (target_1 != 0B)
    goto <bb 4>; [0.00%]
  else
    goto <bb 7>; [0.00%]

  <bb 7> [0.00%]:
  session_group_synchronize1 (target_1, s_4(D));

  <bb 8> [0.00%]:
  return;

}



;; Function session_group_synchronize_from (session_group_synchronize_from, funcdef_no=80, decl_uid=4543, cgraph_uid=80, symbol_order=83)

Function found to be nothrow: session_group_synchronize_from
session_group_synchronize_from (struct session * target)
{
  struct session * s;
  struct session_group * sg;

  <bb 2> [0.00%]:
  sg_8 = session_group_find (target_6(D));
  if (sg_8 == 0B)
    goto <bb 8>; [0.00%]
  else
    goto <bb 3>; [0.00%]

  <bb 3> [0.00%]:
  s_9 = sg_8->sessions.tqh_first;
  goto <bb 7>; [0.00%]

  <bb 4> [0.00%]:
  if (s_1 != target_6(D))
    goto <bb 5>; [0.00%]
  else
    goto <bb 6>; [0.00%]

  <bb 5> [0.00%]:
  session_group_synchronize1 (target_6(D), s_1);

  <bb 6> [0.00%]:
  s_11 = s_1->gentry.tqe_next;

  <bb 7> [0.00%]:
  # s_1 = PHI <s_9(3), s_11(6)>
  if (s_1 != 0B)
    goto <bb 4>; [0.00%]
  else
    goto <bb 8>; [0.00%]

  <bb 8> [0.00%]:
  return;

}



;; Function session_destroy (session_destroy, funcdef_no=81, decl_uid=4551, cgraph_uid=81, symbol_order=84)

Function found to be nothrow: session_destroy
session_destroy (struct session * s)
{
  u_int i;
  char * _1;
  int _2;
  struct session * * _3;
  unsigned int i.1_4;
  long unsigned int _5;
  long unsigned int _6;
  struct session * * _7;
  unsigned int _8;
  unsigned int _9;
  unsigned int _10;
  struct session * * _11;
  unsigned int _12;
  struct session * * _13;
  unsigned int _14;
  unsigned int _15;
  long unsigned int _16;
  long unsigned int _17;
  struct session * * _18;
  struct session * _19;
  struct winlink * _20;
  struct winlink_stack * _21;
  struct winlink * _22;
  struct winlink * _23;
  struct winlinks * _24;
  struct winlink * _25;
  char * _26;

  <bb 2> [0.00%]:
  _1 = s_31(D)->name;
  printf ("session %s destroyed\n", _1);
  _2 = session_index (s_31(D), &i);
  if (_2 != 0)
    goto <bb 3>; [0.00%]
  else
    goto <bb 4>; [0.00%]

  <bb 3> [0.00%]:
  printf ("session not found%s\n", "");
  exit (1);

  <bb 4> [0.00%]:
  _3 = sessions.list;
  i.1_4 = i;
  _5 = (long unsigned int) i.1_4;
  _6 = _5 * 8;
  _7 = _3 + _6;
  *_7 = 0B;
  goto <bb 8>; [0.00%]

  <bb 5> [0.00%]:
  _8 = sessions.num;
  if (_8 > 1)
    goto <bb 6>; [0.00%]
  else
    goto <bb 7>; [0.00%]

  <bb 6> [0.00%]:
  _9 = sessions.num;
  _10 = _9 + 4294967295;
  sessions.num = _10;
  goto <bb 8>; [0.00%]

  <bb 7> [0.00%]:
  _11 = sessions.list;
  free (_11);
  sessions.num = 0;
  sessions.list = 0B;
  sessions.space = 0;

  <bb 8> [0.00%]:
  _12 = sessions.num;
  if (_12 != 0)
    goto <bb 9>; [0.00%]
  else
    goto <bb 10>; [0.00%]

  <bb 9> [0.00%]:
  _13 = sessions.list;
  _14 = sessions.num;
  _15 = _14 + 4294967295;
  _16 = (long unsigned int) _15;
  _17 = _16 * 8;
  _18 = _13 + _17;
  _19 = *_18;
  if (_19 == 0B)
    goto <bb 5>; [0.00%]
  else
    goto <bb 10>; [0.00%]

  <bb 10> [0.00%]:
  session_group_remove (s_31(D));
  goto <bb 12>; [0.00%]

  <bb 11> [0.00%]:
  _20 = s_31(D)->lastw.tqh_first;
  _21 = &s_31(D)->lastw;
  winlink_stack_remove (_21, _20);

  <bb 12> [0.00%]:
  _22 = s_31(D)->lastw.tqh_first;
  if (_22 != 0B)
    goto <bb 11>; [0.00%]
  else
    goto <bb 14>; [0.00%]

  <bb 13> [0.00%]:
  _23 = s_31(D)->windows.rbh_root;
  _24 = &s_31(D)->windows;
  winlink_remove (_24, _23);

  <bb 14> [0.00%]:
  _25 = s_31(D)->windows.rbh_root;
  if (_25 != 0B)
    goto <bb 13>; [0.00%]
  else
    goto <bb 15>; [0.00%]

  <bb 15> [0.00%]:
  _26 = s_31(D)->name;
  free (_26);
  free (s_31(D));
  i ={v} {CLOBBER};
  return;

}



;; Function session_detach (session_detach, funcdef_no=82, decl_uid=4565, cgraph_uid=82, symbol_order=85)

Function found to be nothrow: session_detach
session_detach (struct session * s, struct winlink * wl)
{
  struct winlink_stack * _1;
  struct winlinks * _2;
  struct winlink * _3;
  int _4;
  int _12;
  int _14;

  <bb 2> [0.00%]:
  _1 = &s_6(D)->lastw;
  winlink_stack_remove (_1, wl_8(D));
  _2 = &s_6(D)->windows;
  winlink_remove (_2, wl_8(D));
  session_group_synchronize_from (s_6(D));
  _3 = s_6(D)->windows.rbh_root;
  if (_3 == 0B)
    goto <bb 3>; [0.00%]
  else
    goto <bb 4>; [0.00%]

  <bb 3> [0.00%]:
  session_destroy (s_6(D));
  _14 = 1;
  goto <bb 5>; [0.00%]

  <bb 4> [0.00%]:
  _12 = 0;

  <bb 5> [0.00%]:
  # _4 = PHI <_14(3), _12(4)>
  return _4;

}



;; Function server_destroy_session_group (server_destroy_session_group, funcdef_no=83, decl_uid=4568, cgraph_uid=83, symbol_order=86)

Function found to be nothrow: server_destroy_session_group
server_destroy_session_group (struct session * s)
{
  struct session_group * sg;
  struct session_group * _1;
  struct session_group * _2;
  struct session_group * * _3;
  struct session_group * * _4;
  struct session_group * * _5;
  struct session_group * _6;

  <bb 2> [0.00%]:
  sg_12 = session_group_find (s_10(D));
  if (sg_12 == 0B)
    goto <bb 7>; [0.00%]
  else
    goto <bb 3>; [0.00%]

  <bb 3> [0.00%]:
  _1 = sg_12->entry.tqe_next;
  if (_1 != 0B)
    goto <bb 4>; [0.00%]
  else
    goto <bb 5>; [0.00%]

  <bb 4> [0.00%]:
  _2 = sg_12->entry.tqe_next;
  _3 = sg_12->entry.tqe_prev;
  _2->entry.tqe_prev = _3;
  goto <bb 6>; [0.00%]

  <bb 5> [0.00%]:
  _4 = sg_12->entry.tqe_prev;
  session_groups.tqh_last = _4;

  <bb 6> [0.00%]:
  _5 = sg_12->entry.tqe_prev;
  _6 = sg_12->entry.tqe_next;
  *_5 = _6;
  free (sg_12);

  <bb 7> [0.00%]:
  return;

}



;; Function server_kill_window (server_kill_window, funcdef_no=84, decl_uid=4572, cgraph_uid=84, symbol_order=87)

Function found to be nothrow: server_kill_window
server_kill_window (struct window * w)
{
  u_int i;
  struct winlink * wl;
  struct session * s;
  struct session * * _1;
  long unsigned int _2;
  long unsigned int _3;
  struct session * * _4;
  int _5;
  int _6;
  struct winlinks * _7;
  unsigned int _8;

  <bb 2> [0.00%]:
  i_14 = 0;
  goto <bb 10>; [0.00%]

  <bb 3> [0.00%]:
  _1 = sessions.list;
  _2 = (long unsigned int) i_9;
  _3 = _2 * 8;
  _4 = _1 + _3;
  s_16 = *_4;
  if (s_16 == 0B)
    goto <bb 5>; [0.00%]
  else
    goto <bb 4>; [0.00%]

  <bb 4> [0.00%]:
  _5 = session_has (s_16, w_17(D));
  if (_5 == 0)
    goto <bb 5>; [0.00%]
  else
    goto <bb 8>; [0.00%]

  <bb 5> [0.00%]:
  // predicted unlikely by continue predictor.
  goto <bb 9>; [0.00%]

  <bb 6> [0.00%]:
  _6 = session_detach (s_16, wl_20);
  if (_6 != 0)
    goto <bb 7>; [0.00%]
  else
    goto <bb 8>; [0.00%]

  <bb 7> [0.00%]:
  server_destroy_session_group (s_16);
  goto <bb 9>; [0.00%]

  <bb 8> [0.00%]:
  _7 = &s_16->windows;
  wl_20 = winlink_find_by_window (_7, w_17(D));
  if (wl_20 != 0B)
    goto <bb 6>; [0.00%]
  else
    goto <bb 9>; [0.00%]

  <bb 9> [0.00%]:
  i_23 = i_9 + 1;

  <bb 10> [0.00%]:
  # i_9 = PHI <i_14(2), i_23(9)>
  _8 = sessions.num;
  if (i_9 < _8)
    goto <bb 3>; [0.00%]
  else
    goto <bb 11>; [0.00%]

  <bb 11> [0.00%]:
  return;

}



;; Function session_select (session_select, funcdef_no=85, decl_uid=4586, cgraph_uid=85, symbol_order=88)

Function found to be nothrow: session_select
session_select (struct session * s, int idx)
{
  struct winlink * wl;
  struct winlinks * _1;
  struct winlink * _2;
  struct winlink_stack * _3;
  struct winlink * _4;
  struct winlink_stack * _5;
  int _6;
  int _16;
  int _17;
  int _18;

  <bb 2> [0.00%]:
  _1 = &s_8(D)->windows;
  wl_12 = winlink_find_by_index (_1, idx_10(D));
  if (wl_12 == 0B)
    goto <bb 3>; [0.00%]
  else
    goto <bb 4>; [0.00%]

  <bb 3> [0.00%]:
  _18 = -1;
  goto <bb 7>; [0.00%]

  <bb 4> [0.00%]:
  _2 = s_8(D)->curw;
  if (wl_12 == _2)
    goto <bb 5>; [0.00%]
  else
    goto <bb 6>; [0.00%]

  <bb 5> [0.00%]:
  _17 = 1;
  goto <bb 7>; [0.00%]

  <bb 6> [0.00%]:
  _3 = &s_8(D)->lastw;
  winlink_stack_remove (_3, wl_12);
  _4 = s_8(D)->curw;
  _5 = &s_8(D)->lastw;
  winlink_stack_push (_5, _4);
  s_8(D)->curw = wl_12;
  _16 = 0;

  <bb 7> [0.00%]:
  # _6 = PHI <_18(3), _17(5), _16(6)>
  return _6;

}



;; Function join_pane_exec (join_pane_exec, funcdef_no=86, decl_uid=4590, cgraph_uid=86, symbol_order=89)

Function found to be nothrow: join_pane_exec
join_pane_exec ()
{
  struct window * dst_w;
  struct window * src_w;
  struct winlink * dst_wl;
  struct winlink * src_wl;
  struct session * dst_s;
  int _1;
  struct session * dst_s.2_2;
  int _3;
  int _14;
  int _16;
  int _17;
  int _18;

  <bb 2> [0.00%]:
  dst_wl_7 = cmd_find_pane (0, &dst_s);
  if (dst_wl_7 == 0B)
    goto <bb 3>; [0.00%]
  else
    goto <bb 4>; [0.00%]

  <bb 3> [0.00%]:
  _18 = -1;
  goto <bb 9>; [0.00%]

  <bb 4> [0.00%]:
  dst_w_8 = dst_wl_7->window;
  src_wl_10 = cmd_find_pane (1, 0B);
  if (src_wl_10 == 0B)
    goto <bb 5>; [0.00%]
  else
    goto <bb 6>; [0.00%]

  <bb 5> [0.00%]:
  _17 = -1;
  goto <bb 9>; [0.00%]

  <bb 6> [0.00%]:
  src_w_11 = src_wl_10->window;
  if (src_w_11 == dst_w_8)
    goto <bb 7>; [0.00%]
  else
    goto <bb 8>; [0.00%]

  <bb 7> [0.00%]:
  printf ("can\'t join a pane to its own window\n");
  _16 = -1;
  goto <bb 9>; [0.00%]

  <bb 8> [0.00%]:
  server_kill_window (src_w_11);
  _1 = dst_wl_7->idx;
  dst_s.2_2 = dst_s;
  session_select (dst_s.2_2, _1);
  _14 = 0;

  <bb 9> [0.00%]:
  # _3 = PHI <_18(3), _17(5), _16(7), _14(8)>
  dst_s ={v} {CLOBBER};
  return _3;

}



;; Function window_create1 (window_create1, funcdef_no=87, decl_uid=4599, cgraph_uid=87, symbol_order=90)

Function found to be nothrow: window_create1
window_create1 (u_int sx, u_int sy)
{
  u_int i;
  struct window * w;
  struct window * * _1;
  long unsigned int _2;
  long unsigned int _3;
  struct window * * _4;
  struct window * _5;
  struct window * * _6;
  long unsigned int _7;
  long unsigned int _8;
  struct window * * _9;
  unsigned int _10;
  unsigned int _11;
  unsigned int _12;
  unsigned int _13;
  unsigned int _14;
  unsigned int _15;
  long unsigned int _16;
  long unsigned int _17;
  struct window * * _18;
  void * _19;
  long unsigned int _20;
  struct window * * _21;
  void * _22;
  long unsigned int _23;
  long unsigned int _24;
  long unsigned int _25;
  unsigned int _26;
  unsigned int _27;
  long unsigned int _28;
  long unsigned int _29;
  struct window * * _30;
  unsigned int _31;
  long unsigned int _32;
  long unsigned int _33;
  struct window * * _34;
  unsigned int _35;
  unsigned int _36;
  struct window * _69;

  <bb 2> [0.00%]:
  w_43 = malloc (88);
  w_43->name = 0B;
  w_43->flags = 0;
  w_43->active = 0B;
  w_43->lastlayout = -1;
  w_43->layout_root = 0B;
  w_43->sx = sx_49(D);
  w_43->sy = sy_51(D);
  i_53 = 0;
  goto <bb 6>; [0.00%]

  <bb 3> [0.00%]:
  _1 = windows.list;
  _2 = (long unsigned int) i_37;
  _3 = _2 * 8;
  _4 = _1 + _3;
  _5 = *_4;
  if (_5 == 0B)
    goto <bb 4>; [0.00%]
  else
    goto <bb 5>; [0.00%]

  <bb 4> [0.00%]:
  _6 = windows.list;
  _7 = (long unsigned int) i_37;
  _8 = _7 * 8;
  _9 = _6 + _8;
  *_9 = w_43;
  goto <bb 7>; [0.00%]

  <bb 5> [0.00%]:
  i_54 = i_37 + 1;

  <bb 6> [0.00%]:
  # i_37 = PHI <i_53(2), i_54(5)>
  _10 = windows.num;
  if (i_37 < _10)
    goto <bb 3>; [0.00%]
  else
    goto <bb 7>; [0.00%]

  <bb 7> [0.00%]:
  _11 = windows.num;
  if (i_37 == _11)
    goto <bb 8>; [0.00%]
  else
    goto <bb 17>; [0.00%]

  <bb 8> [0.00%]:
  _12 = windows.num;
  if (_12 > 1073741823)
    goto <bb 9>; [0.00%]
  else
    goto <bb 10>; [0.00%]

  <bb 9> [0.00%]:
  printf ("number too big%s", "");
  exit (1);

  <bb 10> [0.00%]:
  _13 = windows.num;
  _14 = _13 + 1;
  _15 = 1073741824 / _14;
  if (_15 <= 7)
    goto <bb 11>; [0.00%]
  else
    goto <bb 12>; [0.00%]

  <bb 11> [0.00%]:
  printf ("size too big%s", "");
  exit (1);

  <bb 12> [0.00%]:
  _16 = windows.space;
  if (_16 == 0)
    goto <bb 13>; [0.00%]
  else
    goto <bb 15>; [0.00%]

  <bb 13> [0.00%]:
  windows.space = 80;
  _17 = windows.space;
  _18 = windows.list;
  _19 = xrealloc (_18, 1, _17);
  windows.list = _19;
  goto <bb 15>; [0.00%]

  <bb 14> [0.00%]:
  _20 = windows.space;
  _21 = windows.list;
  _22 = xrealloc (_21, 2, _20);
  windows.list = _22;
  _23 = windows.space;
  _24 = _23 * 2;
  windows.space = _24;

  <bb 15> [0.00%]:
  _25 = windows.space;
  _26 = windows.num;
  _27 = _26 + 1;
  _28 = (long unsigned int) _27;
  _29 = _28 * 8;
  if (_25 <= _29)
    goto <bb 14>; [0.00%]
  else
    goto <bb 16>; [0.00%]

  <bb 16> [0.00%]:
  _30 = windows.list;
  _31 = windows.num;
  _32 = (long unsigned int) _31;
  _33 = _32 * 8;
  _34 = _30 + _33;
  *_34 = w_43;
  _35 = windows.num;
  _36 = _35 + 1;
  windows.num = _36;

  <bb 17> [0.00%]:
  w_43->references = 0;
  _69 = w_43;
  return _69;

}



;; Function session_attach (session_attach, funcdef_no=88, decl_uid=4613, cgraph_uid=88, symbol_order=91)

Function found to be nothrow: session_attach
session_attach (struct session * s, struct window * w, int idx, char * * cause)
{
  struct winlink * wl;
  struct winlinks * _1;
  struct winlink * _11;

  <bb 2> [0.00%]:
  _1 = &s_3(D)->windows;
  wl_8 = winlink_add (_1, w_5(D), idx_6(D));
  if (wl_8 == 0B)
    goto <bb 3>; [0.00%]
  else
    goto <bb 4>; [0.00%]

  <bb 3> [0.00%]:
  printf ("index in use: %d\n", idx_6(D));

  <bb 4> [0.00%]:
  session_group_synchronize_from (s_3(D));
  _11 = wl_8;
  return _11;

}



;; Function session_new (session_new, funcdef_no=89, decl_uid=4622, cgraph_uid=89, symbol_order=92)

Function found to be nothrow: session_new
session_new (struct session * s, const char * name, const char * cmd, const char * cwd, int idx, char * * cause)
{
  struct window * w;
  unsigned int _1;
  unsigned int _2;
  struct winlink * _3;
  struct winlink * _12;
  struct winlink * _13;

  <bb 2> [0.00%]:
  _1 = s_6(D)->sy;
  _2 = s_6(D)->sx;
  w_8 = window_create1 (_2, _1);
  if (w_8 == 0B)
    goto <bb 3>; [0.00%]
  else
    goto <bb 4>; [0.00%]

  <bb 3> [0.00%]:
  _13 = 0B;
  goto <bb 5>; [0.00%]

  <bb 4> [0.00%]:
  _12 = session_attach (s_6(D), w_8, idx_9(D), cause_10(D));

  <bb 5> [0.00%]:
  # _3 = PHI <_13(3), _12(4)>
  return _3;

}



;; Function session_create (session_create, funcdef_no=90, decl_uid=4636, cgraph_uid=90, symbol_order=93)

Function found to be nothrow: session_create
session_create (const char * name, const char * cmd, const char * cwd, struct environ * env, struct termios * tio, int idx, u_int sx, u_int sy, char * * cause)
{
  u_int i;
  struct session * s;
  struct winlink * * _1;
  struct session * * _2;
  long unsigned int _3;
  long unsigned int _4;
  struct session * * _5;
  struct session * _6;
  struct session * * _7;
  long unsigned int _8;
  long unsigned int _9;
  struct session * * _10;
  unsigned int _11;
  unsigned int _12;
  unsigned int _13;
  unsigned int _14;
  unsigned int _15;
  unsigned int _16;
  long unsigned int _17;
  long unsigned int _18;
  struct session * * _19;
  void * _20;
  long unsigned int _21;
  struct session * * _22;
  void * _23;
  long unsigned int _24;
  long unsigned int _25;
  long unsigned int _26;
  unsigned int _27;
  unsigned int _28;
  long unsigned int _29;
  long unsigned int _30;
  struct session * * _31;
  unsigned int _32;
  long unsigned int _33;
  long unsigned int _34;
  struct session * * _35;
  unsigned int _36;
  unsigned int _37;
  char * _38;
  struct winlink * _39;
  struct winlink * _40;
  int _41;
  char * _42;
  struct session * _44;
  struct session * _89;
  struct session * _91;

  <bb 2> [0.00%]:
  s_52 = malloc (112);
  s_52->references = 0;
  s_52->flags = 0;
  s_52->curw = 0B;
  s_52->lastw.tqh_first = 0B;
  _1 = &s_52->lastw.tqh_first;
  s_52->lastw.tqh_last = _1;
  s_52->windows.rbh_root = 0B;
  s_52->tio = 0B;
  s_52->sx = sx_60(D);
  s_52->sy = sy_62(D);
  i_64 = 0;
  goto <bb 6>; [0.00%]

  <bb 3> [0.00%]:
  _2 = sessions.list;
  _3 = (long unsigned int) i_43;
  _4 = _3 * 8;
  _5 = _2 + _4;
  _6 = *_5;
  if (_6 == 0B)
    goto <bb 4>; [0.00%]
  else
    goto <bb 5>; [0.00%]

  <bb 4> [0.00%]:
  _7 = sessions.list;
  _8 = (long unsigned int) i_43;
  _9 = _8 * 8;
  _10 = _7 + _9;
  *_10 = s_52;
  goto <bb 7>; [0.00%]

  <bb 5> [0.00%]:
  i_65 = i_43 + 1;

  <bb 6> [0.00%]:
  # i_43 = PHI <i_64(2), i_65(5)>
  _11 = sessions.num;
  if (i_43 < _11)
    goto <bb 3>; [0.00%]
  else
    goto <bb 7>; [0.00%]

  <bb 7> [0.00%]:
  _12 = sessions.num;
  if (i_43 == _12)
    goto <bb 8>; [0.00%]
  else
    goto <bb 17>; [0.00%]

  <bb 8> [0.00%]:
  _13 = sessions.num;
  if (_13 > 1073741823)
    goto <bb 9>; [0.00%]
  else
    goto <bb 10>; [0.00%]

  <bb 9> [0.00%]:
  printf ("number too big%s", "");
  exit (1);

  <bb 10> [0.00%]:
  _14 = sessions.num;
  _15 = _14 + 1;
  _16 = 1073741824 / _15;
  if (_16 <= 7)
    goto <bb 11>; [0.00%]
  else
    goto <bb 12>; [0.00%]

  <bb 11> [0.00%]:
  printf ("size too big%s", "");
  exit (1);

  <bb 12> [0.00%]:
  _17 = sessions.space;
  if (_17 == 0)
    goto <bb 13>; [0.00%]
  else
    goto <bb 15>; [0.00%]

  <bb 13> [0.00%]:
  sessions.space = 80;
  _18 = sessions.space;
  _19 = sessions.list;
  _20 = xrealloc (_19, 1, _18);
  sessions.list = _20;
  goto <bb 15>; [0.00%]

  <bb 14> [0.00%]:
  _21 = sessions.space;
  _22 = sessions.list;
  _23 = xrealloc (_22, 2, _21);
  sessions.list = _23;
  _24 = sessions.space;
  _25 = _24 * 2;
  sessions.space = _25;

  <bb 15> [0.00%]:
  _26 = sessions.space;
  _27 = sessions.num;
  _28 = _27 + 1;
  _29 = (long unsigned int) _28;
  _30 = _29 * 8;
  if (_26 <= _30)
    goto <bb 14>; [0.00%]
  else
    goto <bb 16>; [0.00%]

  <bb 16> [0.00%]:
  _31 = sessions.list;
  _32 = sessions.num;
  _33 = (long unsigned int) _32;
  _34 = _33 * 8;
  _35 = _31 + _34;
  *_35 = s_52;
  _36 = sessions.num;
  _37 = _36 + 1;
  sessions.num = _37;

  <bb 17> [0.00%]:
  if (name_79(D) == 0B)
    goto <bb 18>; [0.00%]
  else
    goto <bb 19>; [0.00%]

  <bb 18> [0.00%]:
  printf ("no name%s\n", "");
  exit (1);

  <bb 19> [0.00%]:
  _38 = strdup (name_79(D));
  s_52->name = _38;
  if (cmd_82(D) != 0B)
    goto <bb 20>; [0.00%]
  else
    goto <bb 23>; [0.00%]

  <bb 20> [0.00%]:
  _39 = session_new (s_52, 0B, cmd_82(D), cwd_83(D), idx_84(D), cause_85(D));
  if (_39 == 0B)
    goto <bb 21>; [0.00%]
  else
    goto <bb 22>; [0.00%]

  <bb 21> [0.00%]:
  session_destroy (s_52);
  _89 = 0B;
  goto <bb 24>; [0.00%]

  <bb 22> [0.00%]:
  _40 = s_52->windows.rbh_root;
  _41 = _40->idx;
  session_select (s_52, _41);

  <bb 23> [0.00%]:
  _42 = s_52->name;
  printf ("session %s created\n", _42);
  _91 = s_52;

  <bb 24> [0.00%]:
  # _44 = PHI <_89(21), _91(23)>
  return _44;

}



;; Function main (main, funcdef_no=91, decl_uid=4648, cgraph_uid=91, symbol_order=94)

Function found to be nothrow: main
main (int argc, char * * argv)
{
  int i;
  int sy;
  int sx;
  int idx;
  char * cause;
  char * name;
  char * cmd;
  char * target;
  struct window * w;
  struct session * groupwith;
  struct session * s;
  long unsigned int _1;
  long unsigned int _2;
  char * * _3;
  char * _4;
  char _5;
  long unsigned int _6;
  long unsigned int _7;
  sizetype _8;
  char * * _9;
  char * _10;
  long unsigned int _11;
  long unsigned int _12;
  char * * _13;
  char * _14;
  unsigned int sy.3_15;
  unsigned int sx.4_16;
  int idx.5_17;
  unsigned int sy.6_18;
  unsigned int sx.7_19;
  int idx.8_20;
  struct winlink * _21;
  int _22;
  struct session * * _23;
  struct session * _24;
  unsigned int _25;
  int _48;

  <bb 2> [0.00%]:
  idx_35 = 0;
  windows.num = 0;
  windows.list = 0B;
  windows.space = 0;
  sessions.num = 0;
  sessions.list = 0B;
  sessions.space = 0;
  session_groups.tqh_first = 0B;
  session_groups.tqh_last = &session_groups.tqh_first;
  i_45 = 0;
  goto <bb 13>; [0.00%]

  <bb 3> [0.00%]:
  _1 = (long unsigned int) i_29;
  _2 = _1 * 8;
  _3 = argv_51(D) + _2;
  _4 = *_3;
  _5 = *_4;
  if (_5 == 116)
    goto <bb 4>; [0.00%]
  else
    goto <bb 6>; [0.00%]

  <bb 4> [0.00%]:
  if (i_29 > 0)
    goto <bb 5>; [0.00%]
  else
    goto <bb 6>; [0.00%]

  <bb 5> [0.00%]:
  _6 = (long unsigned int) i_29;
  _7 = _6 * 8;
  _8 = _7 + 18446744073709551608;
  _9 = argv_51(D) + _8;
  _10 = *_9;
  target_53 = strdup (_10);
  goto <bb 7>; [0.00%]

  <bb 6> [0.00%]:
  target_54 = 0B;

  <bb 7> [0.00%]:
  # target_26 = PHI <target_53(5), target_54(6)>
  groupwith_56 = session_find (target_26);
  if (target_26 == 0B)
    goto <bb 8>; [0.00%]
  else
    goto <bb 9>; [0.00%]

  <bb 8> [0.00%]:
  cmd_59 = strdup ("cmd");
  goto <bb 10>; [0.00%]

  <bb 9> [0.00%]:
  cmd_57 = 0B;

  <bb 10> [0.00%]:
  # cmd_27 = PHI <cmd_59(8), cmd_57(9)>
  free (target_26);
  _11 = (long unsigned int) i_29;
  _12 = _11 * 8;
  _13 = argv_51(D) + _12;
  _14 = *_13;
  name_62 = strdup (_14);
  sy.3_15 = (unsigned int) sy_63(D);
  sx.4_16 = (unsigned int) sx_64(D);
  idx.5_17 = idx_28;
  idx_65 = idx.5_17 + 1;
  s_67 = session_create (name_62, cmd_27, "cwd", 0B, 0B, idx.5_17, sx.4_16, sy.3_15, &cause);
  sy.6_18 = (unsigned int) sy_63(D);
  sx.7_19 = (unsigned int) sx_64(D);
  w_69 = window_create1 (sx.7_19, sy.6_18);
  idx.8_20 = idx_65;
  idx_70 = idx.8_20 + 1;
  session_attach (s_67, w_69, idx.8_20, &cause);
  free (cmd_27);
  if (groupwith_56 != 0B)
    goto <bb 11>; [0.00%]
  else
    goto <bb 12>; [0.00%]

  <bb 11> [0.00%]:
  session_group_add (groupwith_56, s_67);
  session_group_synchronize_to (s_67);
  _21 = s_67->windows.rbh_root;
  _22 = _21->idx;
  session_select (s_67, _22);

  <bb 12> [0.00%]:
  i_76 = i_29 + 1;

  <bb 13> [0.00%]:
  # idx_28 = PHI <idx_35(2), idx_70(12)>
  # i_29 = PHI <i_45(2), i_76(12)>
  if (i_29 < argc_46(D))
    goto <bb 3>; [0.00%]
  else
    goto <bb 14>; [0.00%]

  <bb 14> [0.00%]:
  join_pane_exec ();
  goto <bb 16>; [0.00%]

  <bb 15> [0.00%]:
  _23 = sessions.list;
  _24 = *_23;
  session_destroy (_24);

  <bb 16> [0.00%]:
  _25 = sessions.num;
  if (_25 != 0)
    goto <bb 15>; [0.00%]
  else
    goto <bb 17>; [0.00%]

  <bb 17> [0.00%]:
  _48 = 0;
  cause ={v} {CLOBBER};
  return _48;

}


