
;; Function buffer_get_string_ret (buffer_get_string_ret, funcdef_no=23, decl_uid=3489, cgraph_uid=24, symbol_order=25)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7
;; 2 succs { 3 4 }
;; 3 succs { 7 }
;; 4 succs { 5 6 }
;; 5 succs { 6 }
;; 6 succs { 7 }
;; 7 succs { 1 }
void * buffer_get_string_ret (u_int * length_ptr)
{
  u_int len;
  u_char * value;
  void * D.3539;

  <bb 2> :
  _1 = rand ();
  _2 = _1 % 1024;
  len = (u_int) _2;
  _3 = len + 1;
  _4 = (long unsigned int) _3;
  value = malloc (_4);
  _5 = rand ();
  _6 = _5 % 2;
  if (_6 == 1)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  __builtin_puts (&"buffer_get_string_ret: buffer_get failed"[0]);
  free (value);
  D.3539 = 0B;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 7>; [INV]

  <bb 4> :
  _7 = (sizetype) len;
  _8 = value + _7;
  *_8 = 0;
  if (length_ptr != 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  *length_ptr = len;

  <bb 6> :
  D.3539 = value;

  <bb 7> :
  return D.3539;

}



;; Function buffer_get_string (buffer_get_string, funcdef_no=24, decl_uid=3494, cgraph_uid=25, symbol_order=26)

Merging blocks 4 and 5
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4
;; 2 succs { 3 4 }
;; 3 succs { }
;; 4 succs { 1 }
void * buffer_get_string (u_int * length_ptr)
{
  void * ret;
  void * D.3545;

  <bb 2> :
  ret = buffer_get_string_ret (length_ptr);
  if (ret == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  printf ("buffer_get_string: buffer error%s\n", "");
  exit (1);

  <bb 4> :
  D.3545 = ret;
  return D.3545;

}



;; Function key_load_public_type (key_load_public_type, funcdef_no=27, decl_uid=3509, cgraph_uid=28, symbol_order=29)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5
;; 2 succs { 3 4 }
;; 3 succs { 5 }
;; 4 succs { 5 }
;; 5 succs { 1 }
struct Key * key_load_public_type (int type, const char * filename, char * * commentp)
{
  struct Key * pub;
  struct Key * D.3549;

  <bb 2> :
  if (type == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  pub = key_load_public_rsa1 (filename, commentp);
  D.3549 = pub;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 5>; [INV]

  <bb 4> :
  D.3549 = 0B;

  <bb 5> :
  return D.3549;

}



;; Function key_load_public_rsa1 (key_load_public_rsa1, funcdef_no=26, decl_uid=3503, cgraph_uid=27, symbol_order=28)

Merging blocks 4 and 5
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4
;; 2 succs { 3 4 }
;; 3 succs { 4 }
;; 4 succs { 1 }
struct Key * key_load_public_rsa1 (const char * filename, char * * commentp)
{
  struct Key * pub;
  struct Key * D.3553;

  <bb 2> :
  pub = key_parse_public_rsa1 (commentp);
  if (pub == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  printf ("Could not load \"%s\" as a RSA1 public key", filename);

  <bb 4> :
  D.3553 = pub;
  return D.3553;

}



;; Function key_parse_public_rsa1 (key_parse_public_rsa1, funcdef_no=25, decl_uid=3498, cgraph_uid=26, symbol_order=27)

Merging blocks 4 and 5
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4
;; 2 succs { 3 4 }
;; 3 succs { 4 }
;; 4 succs { 1 }
struct Key * key_parse_public_rsa1 (char * * commentp)
{
  struct Key * pub;
  struct Key * D.3557;

  <bb 2> :
  pub = &key;
  if (commentp != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  _1 = buffer_get_string (0B);
  *commentp = _1;

  <bb 4> :
  D.3557 = pub;
  return D.3557;

}



;; Function key_load_public (key_load_public, funcdef_no=28, decl_uid=3514, cgraph_uid=29, symbol_order=30)

Merging blocks 9 and 10
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9
;; 2 succs { 3 4 }
;; 3 succs { 9 }
;; 4 succs { 5 6 }
;; 5 succs { 9 }
;; 6 succs { 7 8 }
;; 7 succs { 9 }
;; 8 succs { 9 }
;; 9 succs { 1 }
struct Key * key_load_public (const char * filename, char * * commentp)
{
  char file[64];
  struct Key * pub;
  struct Key * D.3561;

  <bb 2> :
  pub = key_load_public_type (0, filename, commentp);
  if (pub != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  D.3561 = pub;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 9>; [INV]

  <bb 4> :
  pub = &key;
  _1 = key_try_load_public (pub, filename, commentp);
  if (_1 == 1)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  D.3561 = pub;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 9>; [INV]

  <bb 6> :
  pub = &key;
  _2 = key_try_load_public (pub, filename, commentp);
  if (_2 == 1)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  D.3561 = pub;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 9>; [INV]

  <bb 8> :
  D.3561 = 0B;

  <bb 9> :
  file = {CLOBBER};
  return D.3561;

}



;; Function key_try_load_public (key_try_load_public, funcdef_no=22, decl_uid=3478, cgraph_uid=23, symbol_order=24)

Removing basic block 3
Merging blocks 10 and 11
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9
;; 2 succs { 6 8 }
;; 3 succs { 4 5 }
;; 4 succs { 5 }
;; 5 succs { 9 }
;; 6 succs { 3 7 }
;; 7 succs { 8 }
;; 8 succs { 9 }
;; 9 succs { 1 }
int key_try_load_public (struct Key * k, const char * filename, char * * commentp)
{
  u_long linenum;
  char * cp;
  char line[16384];
  struct FILE * f;
  int D.3572;

  <bb 2> :
  linenum = 0;
  f = fopen (filename, "r");
  if (f != 0B)
    goto <bb 6>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 3> :
  if (commentp != 0B)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  _1 = strdup (filename);
  *commentp = _1;

  <bb 5> :
  fclose (f);
  D.3572 = 1;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 9>; [INV]

  <bb 6> :
  _2 = rand ();
  _3 = _2 % 2;
  if (_3 == 1)
    goto <bb 3>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  fclose (f);

  <bb 8> :
  D.3572 = 0;

  <bb 9> :
  line = {CLOBBER};
  return D.3572;

}



;; Function main (main, funcdef_no=30, decl_uid=3530, cgraph_uid=31, symbol_order=32)

Removing basic block 6
Merging blocks 5 and 7
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5
;; 2 succs { 3 4 }
;; 3 succs { 5 }
;; 4 succs { 5 }
;; 5 succs { 1 }
int main (int argc, char * * argv)
{
  char * filename;
  int key_only;
  int D.3579;
  char * iftmp.0;

  <bb 2> :
  _1 = argc == 1;
  key_only = (int) _1;
  if (argc == 1)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  iftmp.0 = *argv;
  goto <bb 5>; [INV]

  <bb 4> :
  iftmp.0 = MEM[(char * *)argv + 8B];

  <bb 5> :
  filename = iftmp.0;
  _2 = time (0B);
  _3 = (unsigned int) _2;
  srand (_3);
  delete_file (filename, key_only);
  D.3579 = 0;
  return D.3579;

}



;; Function delete_file (delete_file, funcdef_no=29, decl_uid=3520, cgraph_uid=30, symbol_order=31)

Merging blocks 12 and 13
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12
;; 2 succs { 3 4 }
;; 3 succs { 12 }
;; 4 succs { 5 6 }
;; 5 succs { 11 }
;; 6 succs { 7 8 }
;; 7 succs { 11 }
;; 8 succs { 9 10 }
;; 9 succs { 11 }
;; 10 succs { 11 }
;; 11 succs { 12 }
;; 12 succs { 1 }
int delete_file (const char * filename, int key_only)
{
  int ret;
  char * comment;
  char * certpath;
  struct Key * cert;
  struct Key * public;
  int D.3583;

  <bb 2> :
  public = 0B;
  cert = 0B;
  certpath = 0B;
  comment = 0B;
  ret = -1;
  public = key_load_public (filename, &comment);
  if (public == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  printf ("Bad key file %s\n", filename);
  D.3583 = -1;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 12>; [INV]

  <bb 4> :
  comment.1_1 = comment;
  stderr.2_2 = stderr;
  fprintf (stderr.2_2, "Identity removed: %s (%s)\n", filename, comment.1_1);
  if (key_only != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  // predicted unlikely by goto predictor.
  goto <bb 11>; [INV]

  <bb 6> :
  comment.3_3 = comment;
  free (comment.3_3);
  certpath = "filename";
  cert = key_load_public (certpath, &comment);
  if (cert == 0B)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  // predicted unlikely by goto predictor.
  goto <bb 11>; [INV]

  <bb 8> :
  _4 = rand ();
  _5 = _4 % 2;
  if (_5 == 1)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  comment.4_6 = comment;
  stderr.5_7 = stderr;
  fprintf (stderr.5_7, "Identity removed: %s (%s)\n", certpath, comment.4_6);
  ret = 0;
  goto <bb 11>; [INV]

  <bb 10> :
  stderr.6_8 = stderr;
  fprintf (stderr.6_8, "Could not remove identity: %s\n", certpath);

  <bb 11> :
out:
  comment.7_9 = comment;
  free (comment.7_9);
  D.3583 = ret;

  <bb 12> :
  comment = {CLOBBER};
  return D.3583;

}


