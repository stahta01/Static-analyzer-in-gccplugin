
;; Function discard_cleanups (discard_cleanups, funcdef_no=22, decl_uid=3027, cgraph_uid=23, symbol_order=27)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
void discard_cleanups (struct cleanup * old_chain)
{
  <bb 2> :
  discard_my_cleanups (&cleanup_chain, old_chain);
  return;

}



;; Function discard_final_cleanups (discard_final_cleanups, funcdef_no=23, decl_uid=3032, cgraph_uid=24, symbol_order=28)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
void discard_final_cleanups (struct cleanup * old_chain)
{
  <bb 2> :
  discard_my_cleanups (&final_cleanup_chain, old_chain);
  return;

}



;; Function discard_my_cleanups (discard_my_cleanups, funcdef_no=24, decl_uid=3030, cgraph_uid=25, symbol_order=29)

;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7
;;
;; Loop 1
;;  header 6, latch 5
;;  depth 1, outer 0
;;  nodes: 6 5 3 4
;; 2 succs { 6 }
;; 3 succs { 4 5 }
;; 4 succs { 5 }
;; 5 succs { 6 }
;; 6 succs { 3 7 }
;; 7 succs { 1 }
void discard_my_cleanups (struct cleanup * * pmy_chain, struct cleanup * old_chain)
{
  struct cleanup * ptr;

  <bb 2> :
  goto <bb 6>; [INV]

  <bb 3> :
  _1 = ptr->next;
  *pmy_chain = _1;
  _2 = ptr->free_arg;
  if (_2 != 0B)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  _3 = ptr->free_arg;
  _4 = ptr->arg;
  _3 (_4);

  <bb 5> :
  free (ptr);

  <bb 6> :
  ptr = *pmy_chain;
  if (ptr != old_chain)
    goto <bb 3>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  _5 = ptr->arg;
  printf ("freearg: %x\n", _5);
  return;

}



;; Function do_cleanups (do_cleanups, funcdef_no=26, decl_uid=3037, cgraph_uid=27, symbol_order=31)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
void do_cleanups (struct cleanup * old_chain)
{
  <bb 2> :
  do_my_cleanups (&cleanup_chain, old_chain);
  return;

}



;; Function do_my_cleanups (do_my_cleanups, funcdef_no=25, decl_uid=3035, cgraph_uid=26, symbol_order=30)

;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7
;;
;; Loop 1
;;  header 6, latch 5
;;  depth 1, outer 0
;;  nodes: 6 5 3 4
;; 2 succs { 6 }
;; 3 succs { 4 5 }
;; 4 succs { 5 }
;; 5 succs { 6 }
;; 6 succs { 3 7 }
;; 7 succs { 1 }
void do_my_cleanups (struct cleanup * * pmy_chain, struct cleanup * old_chain)
{
  struct cleanup * ptr;

  <bb 2> :
  goto <bb 6>; [INV]

  <bb 3> :
  _1 = ptr->next;
  *pmy_chain = _1;
  _2 = ptr->function;
  _3 = ptr->arg;
  _2 (_3);
  __builtin_puts (&"cleanup!!!!! ========="[0]);
  _4 = ptr->arg;
  printf ("%x\n", _4);
  _5 = ptr->free_arg;
  if (_5 != 0B)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  _6 = ptr->free_arg;
  _7 = ptr->arg;
  _6 (_7);

  <bb 5> :
  free (ptr);

  <bb 6> :
  ptr = *pmy_chain;
  if (ptr != old_chain)
    goto <bb 3>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  return;

}



;; Function make_cleanup (make_cleanup, funcdef_no=29, decl_uid=3050, cgraph_uid=30, symbol_order=34)

Merging blocks 2 and 3
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
struct cleanup * make_cleanup (void (*<T59c>) (void *) function, void * arg)
{
  struct cleanup * D.3322;

  <bb 2> :
  D.3322 = make_my_cleanup (&cleanup_chain, function, arg);
  return D.3322;

}



;; Function make_my_cleanup (make_my_cleanup, funcdef_no=28, decl_uid=3047, cgraph_uid=29, symbol_order=33)

Merging blocks 2 and 3
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
struct cleanup * make_my_cleanup (struct cleanup * * pmy_chain, void (*<T59c>) (void *) function, void * arg)
{
  struct cleanup * D.3324;

  <bb 2> :
  D.3324 = make_my_cleanup2 (pmy_chain, function, arg, 0B);
  return D.3324;

}



;; Function make_my_cleanup2 (make_my_cleanup2, funcdef_no=27, decl_uid=3043, cgraph_uid=28, symbol_order=32)

Merging blocks 4 and 5
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4
;; 2 succs { 3 4 }
;; 3 succs { }
;; 4 succs { 1 }
struct cleanup * make_my_cleanup2 (struct cleanup * * pmy_chain, void (*<T59c>) (void *) function, void * arg, void (*<Tee>) (void *) free_arg)
{
  struct cleanup * old_chain;
  struct cleanup * new;
  struct cleanup * D.3328;

  <bb 2> :
  new = malloc (32);
  old_chain = *pmy_chain;
  _1 = *pmy_chain;
  new->next = _1;
  new->function = function;
  new->free_arg = free_arg;
  new->arg = arg;
  *pmy_chain = new;
  if (old_chain == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  exit (1);

  <bb 4> :
  D.3328 = old_chain;
  return D.3328;

}



;; Function unix_lbasename (unix_lbasename, funcdef_no=30, decl_uid=3262, cgraph_uid=31, symbol_order=36)

Merging blocks 5 and 6
;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5
;;
;; Loop 1
;;  header 4, latch 3
;;  depth 1, outer 0
;;  nodes: 4 3
;; 2 succs { 4 }
;; 3 succs { 4 }
;; 4 succs { 3 5 }
;; 5 succs { 1 }
const char * unix_lbasename (const char * name)
{
  const char * base;
  const char * D.3330;

  <bb 2> :
  base = name;
  goto <bb 4>; [INV]

  <bb 3> :
  base = name + 1;
  name = name + 1;

  <bb 4> :
  _1 = *name;
  if (_1 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 5> :
  D.3330 = base;
  return D.3330;

}



;; Function lbasename (lbasename, funcdef_no=31, decl_uid=3270, cgraph_uid=32, symbol_order=37)

Merging blocks 2 and 3
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
const char * lbasename (const char * name)
{
  const char * D.3332;

  <bb 2> :
  D.3332 = unix_lbasename (name);
  return D.3332;

}



;; Function ldirname (ldirname, funcdef_no=32, decl_uid=3273, cgraph_uid=33, symbol_order=38)

;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13
;;
;; Loop 1
;;  header 4, latch 3
;;  depth 1, outer 0
;;  nodes: 4 3 5
;; 2 succs { 4 }
;; 3 succs { 4 }
;; 4 succs { 5 6 }
;; 5 succs { 3 6 }
;; 6 succs { 7 8 }
;; 7 succs { 13 }
;; 8 succs { 9 12 }
;; 9 succs { 10 12 }
;; 10 succs { 11 12 }
;; 11 succs { 12 }
;; 12 succs { 13 }
;; 13 succs { 1 }
char * ldirname (const char * filename)
{
  char * dirname;
  const char * base;
  char * D.3337;

  <bb 2> :
  base = lbasename (filename);
  goto <bb 4>; [INV]

  <bb 3> :
  base = base + 18446744073709551615;

  <bb 4> :
  if (base > filename)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  _1 = base + 18446744073709551615;
  _2 = *_1;
  if (_2 == 47)
    goto <bb 3>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 6> :
  if (base == filename)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  D.3337 = 0B;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 13>; [INV]

  <bb 8> :
  _3 = base - filename;
  _4 = _3 + 2;
  _5 = (long unsigned int) _4;
  dirname = malloc (_5);
  _6 = base - filename;
  _7 = (long unsigned int) _6;
  memcpy (dirname, filename, _7);
  _8 = base - filename;
  if (_8 == 2)
    goto <bb 9>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 9> :
  _9 = *base;
  if (_9 == 47)
    goto <bb 10>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 10> :
  _10 = *filename;
  if (_10 != 47)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  base.0_11 = base;
  base = base.0_11 + 1;
  _12 = base.0_11 - filename;
  _13 = (sizetype) _12;
  _14 = dirname + _13;
  *_14 = 46;

  <bb 12> :
  _15 = base - filename;
  _16 = (sizetype) _15;
  _17 = dirname + _16;
  *_17 = 0;
  D.3337 = dirname;

  <bb 13> :
  return D.3337;

}



;; Function concat (concat, funcdef_no=34, decl_uid=3292, cgraph_uid=35, symbol_order=40)

Merging blocks 2 and 3
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
char * concat (const char * first, const char * arg)
{
  char * newstr;
  char * D.3345;

  <bb 2> :
  newstr = malloc (1);
  vconcat_copy (newstr, first, arg);
  D.3345 = newstr;
  return D.3345;

}



;; Function vconcat_copy (vconcat_copy, funcdef_no=33, decl_uid=3284, cgraph_uid=34, symbol_order=39)

Merging blocks 2 and 3
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
char * vconcat_copy (char * dst, const char * first, const char * arg)
{
  long unsigned int length;
  char * end;
  char * D.3347;

  <bb 2> :
  end = dst;
  length = strlen (arg);
  memcpy (end, arg, length);
  end = end + length;
  *end = 0;
  D.3347 = dst;
  return D.3347;

}



;; Function PyMem_Malloc (PyMem_Malloc, funcdef_no=35, decl_uid=3296, cgraph_uid=36, symbol_order=41)

Merging blocks 2 and 3
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
void * PyMem_Malloc (size_t size)
{
  void * ret;
  void * D.3349;

  <bb 2> :
  ret = malloc (size);
  D.3349 = ret;
  return D.3349;

}



;; Function Py_SetProgramName (Py_SetProgramName, funcdef_no=36, decl_uid=3300, cgraph_uid=37, symbol_order=42)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
void Py_SetProgramName (const wchar_t * progname)
{
  <bb 2> :
  _1 = MEM[(int *)progname];
  printf ("%d\n", _1);
  return;

}



;; Function main (main, funcdef_no=38, decl_uid=3314, cgraph_uid=39, symbol_order=44)

Removing basic block 3
Merging blocks 2 and 4
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
int main ()
{
  char * dummy;
  int D.3351;

  <bb 2> :
  do_start_initialization ();
  dummy = "dummy";
  concat (dummy, "");
  _1 = MEM[(int *)dummy];
  printf ("%d\n", _1);
  D.3351 = 0;
  return D.3351;

}



;; Function do_start_initialization (do_start_initialization, funcdef_no=37, decl_uid=3302, cgraph_uid=38, symbol_order=43)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7
;; 2 succs { 3 4 }
;; 3 succs { 7 }
;; 4 succs { 5 6 }
;; 5 succs { 7 }
;; 6 succs { 7 }
;; 7 succs { 1 }
bool do_start_initialization ()
{
  wchar_t * progname_copy;
  char * oldloc;
  size_t count;
  size_t progsize;
  int i;
  char * progname;
  bool D.3355;

  <bb 2> :
  python_libdir.1_1 = python_libdir;
  _2 = ldirname (python_libdir.1_1);
  progname = concat (_2, "bin");
  _3 = setlocale ("LC_ALL", 0B);
  _4 = (long int) _3;
  _5 = (const char *) _4;
  oldloc = strdup (_5);
  setlocale ("LC_ALL", "");
  progsize = strlen (progname);
  _6 = progsize + 1;
  _7 = _6 * 4;
  progname_copy = PyMem_Malloc (_7);
  if (progname_copy == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  free (oldloc);
  stderr.2_8 = stderr;
  __builtin_fwrite ("out of memory\n", 1, 14, stderr.2_8);
  D.3355 = false;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 7>; [INV]

  <bb 4> :
  _9 = progsize + 1;
  count = mbstowcs (progname_copy, progname, _9);
  if (count == 18446744073709551615)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  free (oldloc);
  free (progname_copy);
  stderr.3_10 = stderr;
  __builtin_fwrite ("Could not convert python path to string\n", 1, 40, stderr.3_10);
  D.3355 = false;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 7>; [INV]

  <bb 6> :
  setlocale ("LC_ALL", oldloc);
  free (oldloc);
  Py_SetProgramName (progname_copy);
  free (progname_copy);
  D.3355 = true;

  <bb 7> :
  return D.3355;

}


