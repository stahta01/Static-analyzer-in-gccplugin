
;; Function args_cmp (args_cmp, funcdef_no=22, decl_uid=4102, cgraph_uid=23, symbol_order=30)

Merging blocks 2 and 3
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
int args_cmp (struct args_entry * a1, struct args_entry * a2)
{
  int D.4414;

  <bb 2> :
  _1 = a1->flag;
  _2 = (int) _1;
  _3 = a2->flag;
  _4 = (int) _3;
  D.4414 = _2 - _4;
  return D.4414;

}



;; Function args_tree_RB_INSERT_COLOR (args_tree_RB_INSERT_COLOR, funcdef_no=23, decl_uid=4106, cgraph_uid=24, symbol_order=31)

Removing basic block 14
Merging blocks 16 and 17
Removing basic block 24
Merging blocks 26 and 27
Removing basic block 38
Merging blocks 40 and 41
Removing basic block 48
;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46
;;
;; Loop 1
;;  header 44, multiple latches: 6 23 26 43
;;  depth 1, outer 0
;;  nodes: 44 6 23 26 43 41 42 40 39 38 36 37 27 35 33 34 32 31 30 28 29 24 25 3 45 21 22 20 19 18 16 17 7 15 13 14 12 11 10 8 9 4 5
;; 2 succs { 44 }
;; 3 succs { 4 24 }
;; 4 succs { 5 7 }
;; 5 succs { 6 7 }
;; 6 succs { 44 }
;; 7 succs { 8 16 }
;; 8 succs { 9 10 }
;; 9 succs { 10 }
;; 10 succs { 11 14 }
;; 11 succs { 12 13 }
;; 12 succs { 15 }
;; 13 succs { 15 }
;; 14 succs { 15 }
;; 15 succs { 16 }
;; 16 succs { 17 18 }
;; 17 succs { 18 }
;; 18 succs { 19 22 }
;; 19 succs { 20 21 }
;; 20 succs { 23 }
;; 21 succs { 23 }
;; 22 succs { 23 }
;; 23 succs { 44 }
;; 24 succs { 25 27 }
;; 25 succs { 26 27 }
;; 26 succs { 44 }
;; 27 succs { 28 36 }
;; 28 succs { 29 30 }
;; 29 succs { 30 }
;; 30 succs { 31 34 }
;; 31 succs { 32 33 }
;; 32 succs { 35 }
;; 33 succs { 35 }
;; 34 succs { 35 }
;; 35 succs { 36 }
;; 36 succs { 37 38 }
;; 37 succs { 38 }
;; 38 succs { 39 42 }
;; 39 succs { 40 41 }
;; 40 succs { 43 }
;; 41 succs { 43 }
;; 42 succs { 43 }
;; 43 succs { 44 }
;; 44 succs { 45 46 }
;; 45 succs { 3 46 }
;; 46 succs { 1 }
void args_tree_RB_INSERT_COLOR (struct args_tree * head, struct args_entry * elm)
{
  struct args_entry * tmp;
  struct args_entry * gparent;
  struct args_entry * parent;

  <bb 2> :
  goto <bb 44>; [INV]

  <bb 3> :
  gparent = parent->entry.rbe_parent;
  _1 = gparent->entry.rbe_left;
  if (parent == _1)
    goto <bb 4>; [INV]
  else
    goto <bb 24>; [INV]

  <bb 4> :
  tmp = gparent->entry.rbe_right;
  if (tmp != 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 5> :
  _2 = tmp->entry.rbe_color;
  if (_2 == 1)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  tmp->entry.rbe_color = 0;
  parent->entry.rbe_color = 0;
  gparent->entry.rbe_color = 1;
  elm = gparent;
  // predicted unlikely by continue predictor.
  goto <bb 44>; [INV]

  <bb 7> :
  _3 = parent->entry.rbe_right;
  if (elm == _3)
    goto <bb 8>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 8> :
  tmp = parent->entry.rbe_right;
  _4 = tmp->entry.rbe_left;
  parent->entry.rbe_right = _4;
  _5 = parent->entry.rbe_right;
  if (_5 != 0B)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  _6 = tmp->entry.rbe_left;
  _6->entry.rbe_parent = parent;

  <bb 10> :
  _7 = parent->entry.rbe_parent;
  tmp->entry.rbe_parent = _7;
  _8 = tmp->entry.rbe_parent;
  if (_8 != 0B)
    goto <bb 11>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 11> :
  _9 = parent->entry.rbe_parent;
  _10 = _9->entry.rbe_left;
  if (parent == _10)
    goto <bb 12>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 12> :
  _11 = parent->entry.rbe_parent;
  _11->entry.rbe_left = tmp;
  goto <bb 15>; [INV]

  <bb 13> :
  _12 = parent->entry.rbe_parent;
  _12->entry.rbe_right = tmp;
  goto <bb 15>; [INV]

  <bb 14> :
  head->rbh_root = tmp;

  <bb 15> :
  tmp->entry.rbe_left = parent;
  parent->entry.rbe_parent = tmp;
  _13 = tmp->entry.rbe_parent;
  tmp = parent;
  parent = elm;
  elm = tmp;

  <bb 16> :
  parent->entry.rbe_color = 0;
  gparent->entry.rbe_color = 1;
  tmp = gparent->entry.rbe_left;
  _14 = tmp->entry.rbe_right;
  gparent->entry.rbe_left = _14;
  _15 = gparent->entry.rbe_left;
  if (_15 != 0B)
    goto <bb 17>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 17> :
  _16 = tmp->entry.rbe_right;
  _16->entry.rbe_parent = gparent;

  <bb 18> :
  _17 = gparent->entry.rbe_parent;
  tmp->entry.rbe_parent = _17;
  _18 = tmp->entry.rbe_parent;
  if (_18 != 0B)
    goto <bb 19>; [INV]
  else
    goto <bb 22>; [INV]

  <bb 19> :
  _19 = gparent->entry.rbe_parent;
  _20 = _19->entry.rbe_left;
  if (gparent == _20)
    goto <bb 20>; [INV]
  else
    goto <bb 21>; [INV]

  <bb 20> :
  _21 = gparent->entry.rbe_parent;
  _21->entry.rbe_left = tmp;
  goto <bb 23>; [INV]

  <bb 21> :
  _22 = gparent->entry.rbe_parent;
  _22->entry.rbe_right = tmp;
  goto <bb 23>; [INV]

  <bb 22> :
  head->rbh_root = tmp;

  <bb 23> :
  tmp->entry.rbe_right = gparent;
  gparent->entry.rbe_parent = tmp;
  _23 = tmp->entry.rbe_parent;
  goto <bb 44>; [INV]

  <bb 24> :
  tmp = gparent->entry.rbe_left;
  if (tmp != 0B)
    goto <bb 25>; [INV]
  else
    goto <bb 27>; [INV]

  <bb 25> :
  _24 = tmp->entry.rbe_color;
  if (_24 == 1)
    goto <bb 26>; [INV]
  else
    goto <bb 27>; [INV]

  <bb 26> :
  tmp->entry.rbe_color = 0;
  parent->entry.rbe_color = 0;
  gparent->entry.rbe_color = 1;
  elm = gparent;
  // predicted unlikely by continue predictor.
  goto <bb 44>; [INV]

  <bb 27> :
  _25 = parent->entry.rbe_left;
  if (elm == _25)
    goto <bb 28>; [INV]
  else
    goto <bb 36>; [INV]

  <bb 28> :
  tmp = parent->entry.rbe_left;
  _26 = tmp->entry.rbe_right;
  parent->entry.rbe_left = _26;
  _27 = parent->entry.rbe_left;
  if (_27 != 0B)
    goto <bb 29>; [INV]
  else
    goto <bb 30>; [INV]

  <bb 29> :
  _28 = tmp->entry.rbe_right;
  _28->entry.rbe_parent = parent;

  <bb 30> :
  _29 = parent->entry.rbe_parent;
  tmp->entry.rbe_parent = _29;
  _30 = tmp->entry.rbe_parent;
  if (_30 != 0B)
    goto <bb 31>; [INV]
  else
    goto <bb 34>; [INV]

  <bb 31> :
  _31 = parent->entry.rbe_parent;
  _32 = _31->entry.rbe_left;
  if (parent == _32)
    goto <bb 32>; [INV]
  else
    goto <bb 33>; [INV]

  <bb 32> :
  _33 = parent->entry.rbe_parent;
  _33->entry.rbe_left = tmp;
  goto <bb 35>; [INV]

  <bb 33> :
  _34 = parent->entry.rbe_parent;
  _34->entry.rbe_right = tmp;
  goto <bb 35>; [INV]

  <bb 34> :
  head->rbh_root = tmp;

  <bb 35> :
  tmp->entry.rbe_right = parent;
  parent->entry.rbe_parent = tmp;
  _35 = tmp->entry.rbe_parent;
  tmp = parent;
  parent = elm;
  elm = tmp;

  <bb 36> :
  parent->entry.rbe_color = 0;
  gparent->entry.rbe_color = 1;
  tmp = gparent->entry.rbe_right;
  _36 = tmp->entry.rbe_left;
  gparent->entry.rbe_right = _36;
  _37 = gparent->entry.rbe_right;
  if (_37 != 0B)
    goto <bb 37>; [INV]
  else
    goto <bb 38>; [INV]

  <bb 37> :
  _38 = tmp->entry.rbe_left;
  _38->entry.rbe_parent = gparent;

  <bb 38> :
  _39 = gparent->entry.rbe_parent;
  tmp->entry.rbe_parent = _39;
  _40 = tmp->entry.rbe_parent;
  if (_40 != 0B)
    goto <bb 39>; [INV]
  else
    goto <bb 42>; [INV]

  <bb 39> :
  _41 = gparent->entry.rbe_parent;
  _42 = _41->entry.rbe_left;
  if (gparent == _42)
    goto <bb 40>; [INV]
  else
    goto <bb 41>; [INV]

  <bb 40> :
  _43 = gparent->entry.rbe_parent;
  _43->entry.rbe_left = tmp;
  goto <bb 43>; [INV]

  <bb 41> :
  _44 = gparent->entry.rbe_parent;
  _44->entry.rbe_right = tmp;
  goto <bb 43>; [INV]

  <bb 42> :
  head->rbh_root = tmp;

  <bb 43> :
  tmp->entry.rbe_left = gparent;
  gparent->entry.rbe_parent = tmp;
  _45 = tmp->entry.rbe_parent;

  <bb 44> :
  parent = elm->entry.rbe_parent;
  if (parent != 0B)
    goto <bb 45>; [INV]
  else
    goto <bb 46>; [INV]

  <bb 45> :
  _46 = parent->entry.rbe_color;
  if (_46 == 1)
    goto <bb 3>; [INV]
  else
    goto <bb 46>; [INV]

  <bb 46> :
  _47 = head->rbh_root;
  _47->entry.rbe_color = 0;
  return;

}



;; Function args_tree_RB_REMOVE_COLOR (args_tree_RB_REMOVE_COLOR, funcdef_no=24, decl_uid=4157, cgraph_uid=25, symbol_order=32)

Removing basic block 11
Merging blocks 13 and 14
Merging blocks 19 and 46
Removing basic block 30
Merging blocks 32 and 33
Removing basic block 42
Merging blocks 44 and 45
Removing basic block 54
Merging blocks 56 and 57
Removing basic block 73
Merging blocks 75 and 76
Removing basic block 85
Merging blocks 87 and 88
;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81
;;
;; Loop 1
;;  header 76, multiple latches: 17 53
;;  depth 1, outer 0
;;  nodes: 76 17 53 51 52 49 50 40 48 46 47 45 44 43 41 42 3 78 77 15 16 13 14 4 12 10 11 9 8 7 5 6
;; 2 succs { 76 }
;; 3 succs { 4 40 }
;; 4 succs { 5 13 }
;; 5 succs { 6 7 }
;; 6 succs { 7 }
;; 7 succs { 8 11 }
;; 8 succs { 9 10 }
;; 9 succs { 12 }
;; 10 succs { 12 }
;; 11 succs { 12 }
;; 12 succs { 13 }
;; 13 succs { 15 14 }
;; 14 succs { 15 18 }
;; 15 succs { 17 16 }
;; 16 succs { 17 18 }
;; 17 succs { 76 }
;; 18 succs { 20 19 }
;; 19 succs { 20 30 }
;; 20 succs { 21 22 }
;; 21 succs { 22 }
;; 22 succs { 23 24 }
;; 23 succs { 24 }
;; 24 succs { 25 28 }
;; 25 succs { 26 27 }
;; 26 succs { 29 }
;; 27 succs { 29 }
;; 28 succs { 29 }
;; 29 succs { 30 }
;; 30 succs { 31 32 }
;; 31 succs { 32 }
;; 32 succs { 33 34 }
;; 33 succs { 34 }
;; 34 succs { 35 38 }
;; 35 succs { 36 37 }
;; 36 succs { 39 }
;; 37 succs { 39 }
;; 38 succs { 39 }
;; 39 succs { 79 }
;; 40 succs { 41 49 }
;; 41 succs { 42 43 }
;; 42 succs { 43 }
;; 43 succs { 44 47 }
;; 44 succs { 45 46 }
;; 45 succs { 48 }
;; 46 succs { 48 }
;; 47 succs { 48 }
;; 48 succs { 49 }
;; 49 succs { 51 50 }
;; 50 succs { 51 54 }
;; 51 succs { 53 52 }
;; 52 succs { 53 54 }
;; 53 succs { 76 }
;; 54 succs { 56 55 }
;; 55 succs { 56 66 }
;; 56 succs { 57 58 }
;; 57 succs { 58 }
;; 58 succs { 59 60 }
;; 59 succs { 60 }
;; 60 succs { 61 64 }
;; 61 succs { 62 63 }
;; 62 succs { 65 }
;; 63 succs { 65 }
;; 64 succs { 65 }
;; 65 succs { 66 }
;; 66 succs { 67 68 }
;; 67 succs { 68 }
;; 68 succs { 69 70 }
;; 69 succs { 70 }
;; 70 succs { 71 74 }
;; 71 succs { 72 73 }
;; 72 succs { 75 }
;; 73 succs { 75 }
;; 74 succs { 75 }
;; 75 succs { 79 }
;; 76 succs { 78 77 }
;; 77 succs { 78 79 }
;; 78 succs { 3 79 }
;; 79 succs { 80 81 }
;; 80 succs { 81 }
;; 81 succs { 1 }
void args_tree_RB_REMOVE_COLOR (struct args_tree * head, struct args_entry * parent, struct args_entry * elm)
{
  struct args_entry * oright;
  struct args_entry * oleft;
  struct args_entry * tmp;

  <bb 2> :
  goto <bb 76>; [INV]

  <bb 3> :
  _1 = parent->entry.rbe_left;
  if (elm == _1)
    goto <bb 4>; [INV]
  else
    goto <bb 40>; [INV]

  <bb 4> :
  tmp = parent->entry.rbe_right;
  _2 = tmp->entry.rbe_color;
  if (_2 == 1)
    goto <bb 5>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 5> :
  tmp->entry.rbe_color = 0;
  parent->entry.rbe_color = 1;
  tmp = parent->entry.rbe_right;
  _3 = tmp->entry.rbe_left;
  parent->entry.rbe_right = _3;
  _4 = parent->entry.rbe_right;
  if (_4 != 0B)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  _5 = tmp->entry.rbe_left;
  _5->entry.rbe_parent = parent;

  <bb 7> :
  _6 = parent->entry.rbe_parent;
  tmp->entry.rbe_parent = _6;
  _7 = tmp->entry.rbe_parent;
  if (_7 != 0B)
    goto <bb 8>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 8> :
  _8 = parent->entry.rbe_parent;
  _9 = _8->entry.rbe_left;
  if (parent == _9)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  _10 = parent->entry.rbe_parent;
  _10->entry.rbe_left = tmp;
  goto <bb 12>; [INV]

  <bb 10> :
  _11 = parent->entry.rbe_parent;
  _11->entry.rbe_right = tmp;
  goto <bb 12>; [INV]

  <bb 11> :
  head->rbh_root = tmp;

  <bb 12> :
  tmp->entry.rbe_left = parent;
  parent->entry.rbe_parent = tmp;
  _12 = tmp->entry.rbe_parent;
  tmp = parent->entry.rbe_right;

  <bb 13> :
  _13 = tmp->entry.rbe_left;
  if (_13 == 0B)
    goto <bb 15>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 14> :
  _14 = tmp->entry.rbe_left;
  _15 = _14->entry.rbe_color;
  if (_15 == 0)
    goto <bb 15>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 15> :
  _16 = tmp->entry.rbe_right;
  if (_16 == 0B)
    goto <bb 17>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 16> :
  _17 = tmp->entry.rbe_right;
  _18 = _17->entry.rbe_color;
  if (_18 == 0)
    goto <bb 17>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 17> :
  tmp->entry.rbe_color = 1;
  elm = parent;
  parent = elm->entry.rbe_parent;
  goto <bb 76>; [INV]

  <bb 18> :
  _19 = tmp->entry.rbe_right;
  if (_19 == 0B)
    goto <bb 20>; [INV]
  else
    goto <bb 19>; [INV]

  <bb 19> :
  _20 = tmp->entry.rbe_right;
  _21 = _20->entry.rbe_color;
  if (_21 == 0)
    goto <bb 20>; [INV]
  else
    goto <bb 30>; [INV]

  <bb 20> :
  oleft = tmp->entry.rbe_left;
  if (oleft != 0B)
    goto <bb 21>; [INV]
  else
    goto <bb 22>; [INV]

  <bb 21> :
  oleft->entry.rbe_color = 0;

  <bb 22> :
  tmp->entry.rbe_color = 1;
  oleft = tmp->entry.rbe_left;
  _22 = oleft->entry.rbe_right;
  tmp->entry.rbe_left = _22;
  _23 = tmp->entry.rbe_left;
  if (_23 != 0B)
    goto <bb 23>; [INV]
  else
    goto <bb 24>; [INV]

  <bb 23> :
  _24 = oleft->entry.rbe_right;
  _24->entry.rbe_parent = tmp;

  <bb 24> :
  _25 = tmp->entry.rbe_parent;
  oleft->entry.rbe_parent = _25;
  _26 = oleft->entry.rbe_parent;
  if (_26 != 0B)
    goto <bb 25>; [INV]
  else
    goto <bb 28>; [INV]

  <bb 25> :
  _27 = tmp->entry.rbe_parent;
  _28 = _27->entry.rbe_left;
  if (tmp == _28)
    goto <bb 26>; [INV]
  else
    goto <bb 27>; [INV]

  <bb 26> :
  _29 = tmp->entry.rbe_parent;
  _29->entry.rbe_left = oleft;
  goto <bb 29>; [INV]

  <bb 27> :
  _30 = tmp->entry.rbe_parent;
  _30->entry.rbe_right = oleft;
  goto <bb 29>; [INV]

  <bb 28> :
  head->rbh_root = oleft;

  <bb 29> :
  oleft->entry.rbe_right = tmp;
  tmp->entry.rbe_parent = oleft;
  _31 = oleft->entry.rbe_parent;
  tmp = parent->entry.rbe_right;

  <bb 30> :
  _32 = parent->entry.rbe_color;
  tmp->entry.rbe_color = _32;
  parent->entry.rbe_color = 0;
  _33 = tmp->entry.rbe_right;
  if (_33 != 0B)
    goto <bb 31>; [INV]
  else
    goto <bb 32>; [INV]

  <bb 31> :
  _34 = tmp->entry.rbe_right;
  _34->entry.rbe_color = 0;

  <bb 32> :
  tmp = parent->entry.rbe_right;
  _35 = tmp->entry.rbe_left;
  parent->entry.rbe_right = _35;
  _36 = parent->entry.rbe_right;
  if (_36 != 0B)
    goto <bb 33>; [INV]
  else
    goto <bb 34>; [INV]

  <bb 33> :
  _37 = tmp->entry.rbe_left;
  _37->entry.rbe_parent = parent;

  <bb 34> :
  _38 = parent->entry.rbe_parent;
  tmp->entry.rbe_parent = _38;
  _39 = tmp->entry.rbe_parent;
  if (_39 != 0B)
    goto <bb 35>; [INV]
  else
    goto <bb 38>; [INV]

  <bb 35> :
  _40 = parent->entry.rbe_parent;
  _41 = _40->entry.rbe_left;
  if (parent == _41)
    goto <bb 36>; [INV]
  else
    goto <bb 37>; [INV]

  <bb 36> :
  _42 = parent->entry.rbe_parent;
  _42->entry.rbe_left = tmp;
  goto <bb 39>; [INV]

  <bb 37> :
  _43 = parent->entry.rbe_parent;
  _43->entry.rbe_right = tmp;
  goto <bb 39>; [INV]

  <bb 38> :
  head->rbh_root = tmp;

  <bb 39> :
  tmp->entry.rbe_left = parent;
  parent->entry.rbe_parent = tmp;
  _44 = tmp->entry.rbe_parent;
  elm = head->rbh_root;
  goto <bb 79>; [INV]

  <bb 40> :
  tmp = parent->entry.rbe_left;
  _45 = tmp->entry.rbe_color;
  if (_45 == 1)
    goto <bb 41>; [INV]
  else
    goto <bb 49>; [INV]

  <bb 41> :
  tmp->entry.rbe_color = 0;
  parent->entry.rbe_color = 1;
  tmp = parent->entry.rbe_left;
  _46 = tmp->entry.rbe_right;
  parent->entry.rbe_left = _46;
  _47 = parent->entry.rbe_left;
  if (_47 != 0B)
    goto <bb 42>; [INV]
  else
    goto <bb 43>; [INV]

  <bb 42> :
  _48 = tmp->entry.rbe_right;
  _48->entry.rbe_parent = parent;

  <bb 43> :
  _49 = parent->entry.rbe_parent;
  tmp->entry.rbe_parent = _49;
  _50 = tmp->entry.rbe_parent;
  if (_50 != 0B)
    goto <bb 44>; [INV]
  else
    goto <bb 47>; [INV]

  <bb 44> :
  _51 = parent->entry.rbe_parent;
  _52 = _51->entry.rbe_left;
  if (parent == _52)
    goto <bb 45>; [INV]
  else
    goto <bb 46>; [INV]

  <bb 45> :
  _53 = parent->entry.rbe_parent;
  _53->entry.rbe_left = tmp;
  goto <bb 48>; [INV]

  <bb 46> :
  _54 = parent->entry.rbe_parent;
  _54->entry.rbe_right = tmp;
  goto <bb 48>; [INV]

  <bb 47> :
  head->rbh_root = tmp;

  <bb 48> :
  tmp->entry.rbe_right = parent;
  parent->entry.rbe_parent = tmp;
  _55 = tmp->entry.rbe_parent;
  tmp = parent->entry.rbe_left;

  <bb 49> :
  _56 = tmp->entry.rbe_left;
  if (_56 == 0B)
    goto <bb 51>; [INV]
  else
    goto <bb 50>; [INV]

  <bb 50> :
  _57 = tmp->entry.rbe_left;
  _58 = _57->entry.rbe_color;
  if (_58 == 0)
    goto <bb 51>; [INV]
  else
    goto <bb 54>; [INV]

  <bb 51> :
  _59 = tmp->entry.rbe_right;
  if (_59 == 0B)
    goto <bb 53>; [INV]
  else
    goto <bb 52>; [INV]

  <bb 52> :
  _60 = tmp->entry.rbe_right;
  _61 = _60->entry.rbe_color;
  if (_61 == 0)
    goto <bb 53>; [INV]
  else
    goto <bb 54>; [INV]

  <bb 53> :
  tmp->entry.rbe_color = 1;
  elm = parent;
  parent = elm->entry.rbe_parent;
  goto <bb 76>; [INV]

  <bb 54> :
  _62 = tmp->entry.rbe_left;
  if (_62 == 0B)
    goto <bb 56>; [INV]
  else
    goto <bb 55>; [INV]

  <bb 55> :
  _63 = tmp->entry.rbe_left;
  _64 = _63->entry.rbe_color;
  if (_64 == 0)
    goto <bb 56>; [INV]
  else
    goto <bb 66>; [INV]

  <bb 56> :
  oright = tmp->entry.rbe_right;
  if (oright != 0B)
    goto <bb 57>; [INV]
  else
    goto <bb 58>; [INV]

  <bb 57> :
  oright->entry.rbe_color = 0;

  <bb 58> :
  tmp->entry.rbe_color = 1;
  oright = tmp->entry.rbe_right;
  _65 = oright->entry.rbe_left;
  tmp->entry.rbe_right = _65;
  _66 = tmp->entry.rbe_right;
  if (_66 != 0B)
    goto <bb 59>; [INV]
  else
    goto <bb 60>; [INV]

  <bb 59> :
  _67 = oright->entry.rbe_left;
  _67->entry.rbe_parent = tmp;

  <bb 60> :
  _68 = tmp->entry.rbe_parent;
  oright->entry.rbe_parent = _68;
  _69 = oright->entry.rbe_parent;
  if (_69 != 0B)
    goto <bb 61>; [INV]
  else
    goto <bb 64>; [INV]

  <bb 61> :
  _70 = tmp->entry.rbe_parent;
  _71 = _70->entry.rbe_left;
  if (tmp == _71)
    goto <bb 62>; [INV]
  else
    goto <bb 63>; [INV]

  <bb 62> :
  _72 = tmp->entry.rbe_parent;
  _72->entry.rbe_left = oright;
  goto <bb 65>; [INV]

  <bb 63> :
  _73 = tmp->entry.rbe_parent;
  _73->entry.rbe_right = oright;
  goto <bb 65>; [INV]

  <bb 64> :
  head->rbh_root = oright;

  <bb 65> :
  oright->entry.rbe_left = tmp;
  tmp->entry.rbe_parent = oright;
  _74 = oright->entry.rbe_parent;
  tmp = parent->entry.rbe_left;

  <bb 66> :
  _75 = parent->entry.rbe_color;
  tmp->entry.rbe_color = _75;
  parent->entry.rbe_color = 0;
  _76 = tmp->entry.rbe_left;
  if (_76 != 0B)
    goto <bb 67>; [INV]
  else
    goto <bb 68>; [INV]

  <bb 67> :
  _77 = tmp->entry.rbe_left;
  _77->entry.rbe_color = 0;

  <bb 68> :
  tmp = parent->entry.rbe_left;
  _78 = tmp->entry.rbe_right;
  parent->entry.rbe_left = _78;
  _79 = parent->entry.rbe_left;
  if (_79 != 0B)
    goto <bb 69>; [INV]
  else
    goto <bb 70>; [INV]

  <bb 69> :
  _80 = tmp->entry.rbe_right;
  _80->entry.rbe_parent = parent;

  <bb 70> :
  _81 = parent->entry.rbe_parent;
  tmp->entry.rbe_parent = _81;
  _82 = tmp->entry.rbe_parent;
  if (_82 != 0B)
    goto <bb 71>; [INV]
  else
    goto <bb 74>; [INV]

  <bb 71> :
  _83 = parent->entry.rbe_parent;
  _84 = _83->entry.rbe_left;
  if (parent == _84)
    goto <bb 72>; [INV]
  else
    goto <bb 73>; [INV]

  <bb 72> :
  _85 = parent->entry.rbe_parent;
  _85->entry.rbe_left = tmp;
  goto <bb 75>; [INV]

  <bb 73> :
  _86 = parent->entry.rbe_parent;
  _86->entry.rbe_right = tmp;
  goto <bb 75>; [INV]

  <bb 74> :
  head->rbh_root = tmp;

  <bb 75> :
  tmp->entry.rbe_right = parent;
  parent->entry.rbe_parent = tmp;
  _87 = tmp->entry.rbe_parent;
  elm = head->rbh_root;
  goto <bb 79>; [INV]

  <bb 76> :
  if (elm == 0B)
    goto <bb 78>; [INV]
  else
    goto <bb 77>; [INV]

  <bb 77> :
  _88 = elm->entry.rbe_color;
  if (_88 == 0)
    goto <bb 78>; [INV]
  else
    goto <bb 79>; [INV]

  <bb 78> :
  _89 = head->rbh_root;
  if (elm != _89)
    goto <bb 3>; [INV]
  else
    goto <bb 79>; [INV]

  <bb 79> :
  if (elm != 0B)
    goto <bb 80>; [INV]
  else
    goto <bb 81>; [INV]

  <bb 80> :
  elm->entry.rbe_color = 0;

  <bb 81> :
  return;

}



;; Function args_tree_RB_INSERT (args_tree_RB_INSERT, funcdef_no=25, decl_uid=4219, cgraph_uid=26, symbol_order=33)

Removing basic block 13
;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
;;
;; Loop 1
;;  header 8, multiple latches: 4 6
;;  depth 1, outer 0
;;  nodes: 8 4 6 5 3
;; 2 succs { 8 }
;; 3 succs { 4 5 }
;; 4 succs { 8 }
;; 5 succs { 6 7 }
;; 6 succs { 8 }
;; 7 succs { 15 }
;; 8 succs { 3 9 }
;; 9 succs { 10 13 }
;; 10 succs { 11 12 }
;; 11 succs { 14 }
;; 12 succs { 14 }
;; 13 succs { 14 }
;; 14 succs { 15 }
;; 15 succs { 1 }
struct args_entry * args_tree_RB_INSERT (struct args_tree * head, struct args_entry * elm)
{
  int comp;
  struct args_entry * parent;
  struct args_entry * tmp;
  struct args_entry * D.4575;

  <bb 2> :
  parent = 0B;
  comp = 0;
  tmp = head->rbh_root;
  goto <bb 8>; [INV]

  <bb 3> :
  parent = tmp;
  comp = args_cmp (elm, parent);
  if (comp < 0)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  tmp = tmp->entry.rbe_left;
  goto <bb 8>; [INV]

  <bb 5> :
  if (comp > 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  tmp = tmp->entry.rbe_right;
  goto <bb 8>; [INV]

  <bb 7> :
  D.4575 = tmp;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 15>; [INV]

  <bb 8> :
  if (tmp != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 9> :
  elm->entry.rbe_parent = parent;
  elm->entry.rbe_right = 0B;
  _1 = elm->entry.rbe_right;
  elm->entry.rbe_left = _1;
  elm->entry.rbe_color = 1;
  if (parent != 0B)
    goto <bb 10>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 10> :
  if (comp < 0)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  parent->entry.rbe_left = elm;
  goto <bb 14>; [INV]

  <bb 12> :
  parent->entry.rbe_right = elm;
  goto <bb 14>; [INV]

  <bb 13> :
  head->rbh_root = elm;

  <bb 14> :
  args_tree_RB_INSERT_COLOR (head, elm);
  D.4575 = 0B;

  <bb 15> :
  return D.4575;

}



;; Function args_tree_RB_REMOVE (args_tree_RB_REMOVE, funcdef_no=26, decl_uid=4233, cgraph_uid=27, symbol_order=34)

Removing basic block 15
Removing basic block 23
Removing basic block 37
Merging blocks 41 and 42
;; 3 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38
;;
;; Loop 2
;;  header 27, latch 27
;;  depth 1, outer 0
;;  nodes: 27
;;
;; Loop 1
;;  header 8, latch 7
;;  depth 1, outer 0
;;  nodes: 8 7
;; 2 succs { 3 4 }
;; 3 succs { 29 }
;; 4 succs { 5 6 }
;; 5 succs { 29 }
;; 6 succs { 8 }
;; 7 succs { 8 }
;; 8 succs { 7 9 }
;; 9 succs { 10 11 }
;; 10 succs { 11 }
;; 11 succs { 12 15 }
;; 12 succs { 13 14 }
;; 13 succs { 16 }
;; 14 succs { 16 }
;; 15 succs { 16 }
;; 16 succs { 17 18 }
;; 17 succs { 18 }
;; 18 succs { 19 22 }
;; 19 succs { 20 21 }
;; 20 succs { 23 }
;; 21 succs { 23 }
;; 22 succs { 23 }
;; 23 succs { 24 25 }
;; 24 succs { 25 }
;; 25 succs { 26 28 }
;; 26 succs { 27 }
;; 27 succs { 27 28 }
;; 28 succs { 36 }
;; 29 succs { 30 31 }
;; 30 succs { 31 }
;; 31 succs { 32 35 }
;; 32 succs { 33 34 }
;; 33 succs { 36 }
;; 34 succs { 36 }
;; 35 succs { 36 }
;; 36 succs { 37 38 }
;; 37 succs { 38 }
;; 38 succs { 1 }
struct args_entry * args_tree_RB_REMOVE (struct args_tree * head, struct args_entry * elm)
{
  struct args_entry * left;
  int color;
  struct args_entry * old;
  struct args_entry * parent;
  struct args_entry * child;
  struct args_entry * D.4619;

  <bb 2> :
  old = elm;
  _1 = elm->entry.rbe_left;
  if (_1 == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  child = elm->entry.rbe_right;
  goto <bb 29>; [INV]

  <bb 4> :
  _2 = elm->entry.rbe_right;
  if (_2 == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  child = elm->entry.rbe_left;
  goto <bb 29>; [INV]

  <bb 6> :
  elm = elm->entry.rbe_right;
  goto <bb 8>; [INV]

  <bb 7> :
  elm = left;

  <bb 8> :
  left = elm->entry.rbe_left;
  if (left != 0B)
    goto <bb 7>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 9> :
  child = elm->entry.rbe_right;
  parent = elm->entry.rbe_parent;
  color = elm->entry.rbe_color;
  if (child != 0B)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  child->entry.rbe_parent = parent;

  <bb 11> :
  if (parent != 0B)
    goto <bb 12>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 12> :
  _3 = parent->entry.rbe_left;
  if (elm == _3)
    goto <bb 13>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 13> :
  parent->entry.rbe_left = child;
  goto <bb 16>; [INV]

  <bb 14> :
  parent->entry.rbe_right = child;
  goto <bb 16>; [INV]

  <bb 15> :
  head->rbh_root = child;

  <bb 16> :
  _4 = elm->entry.rbe_parent;
  if (old == _4)
    goto <bb 17>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 17> :
  parent = elm;

  <bb 18> :
  elm->entry = old->entry;
  _5 = old->entry.rbe_parent;
  if (_5 != 0B)
    goto <bb 19>; [INV]
  else
    goto <bb 22>; [INV]

  <bb 19> :
  _6 = old->entry.rbe_parent;
  _7 = _6->entry.rbe_left;
  if (old == _7)
    goto <bb 20>; [INV]
  else
    goto <bb 21>; [INV]

  <bb 20> :
  _8 = old->entry.rbe_parent;
  _8->entry.rbe_left = elm;
  goto <bb 23>; [INV]

  <bb 21> :
  _9 = old->entry.rbe_parent;
  _9->entry.rbe_right = elm;
  goto <bb 23>; [INV]

  <bb 22> :
  head->rbh_root = elm;

  <bb 23> :
  _10 = old->entry.rbe_left;
  _10->entry.rbe_parent = elm;
  _11 = old->entry.rbe_right;
  if (_11 != 0B)
    goto <bb 24>; [INV]
  else
    goto <bb 25>; [INV]

  <bb 24> :
  _12 = old->entry.rbe_right;
  _12->entry.rbe_parent = elm;

  <bb 25> :
  if (parent != 0B)
    goto <bb 26>; [INV]
  else
    goto <bb 28>; [INV]

  <bb 26> :
  left = parent;

  <bb 27> :
  left = left->entry.rbe_parent;
  if (left != 0B)
    goto <bb 27>; [INV]
  else
    goto <bb 28>; [INV]

  <bb 28> :
  // predicted unlikely by goto predictor.
  goto <bb 36>; [INV]

  <bb 29> :
  parent = elm->entry.rbe_parent;
  color = elm->entry.rbe_color;
  if (child != 0B)
    goto <bb 30>; [INV]
  else
    goto <bb 31>; [INV]

  <bb 30> :
  child->entry.rbe_parent = parent;

  <bb 31> :
  if (parent != 0B)
    goto <bb 32>; [INV]
  else
    goto <bb 35>; [INV]

  <bb 32> :
  _13 = parent->entry.rbe_left;
  if (elm == _13)
    goto <bb 33>; [INV]
  else
    goto <bb 34>; [INV]

  <bb 33> :
  parent->entry.rbe_left = child;
  goto <bb 36>; [INV]

  <bb 34> :
  parent->entry.rbe_right = child;
  goto <bb 36>; [INV]

  <bb 35> :
  head->rbh_root = child;

  <bb 36> :
color:
  if (color == 0)
    goto <bb 37>; [INV]
  else
    goto <bb 38>; [INV]

  <bb 37> :
  args_tree_RB_REMOVE_COLOR (head, parent, child);

  <bb 38> :
  D.4619 = old;
  return D.4619;

}



;; Function args_tree_RB_FIND (args_tree_RB_FIND, funcdef_no=27, decl_uid=4257, cgraph_uid=28, symbol_order=35)

;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10
;;
;; Loop 1
;;  header 8, multiple latches: 4 6
;;  depth 1, outer 0
;;  nodes: 8 4 6 5 3
;; 2 succs { 8 }
;; 3 succs { 4 5 }
;; 4 succs { 8 }
;; 5 succs { 6 7 }
;; 6 succs { 8 }
;; 7 succs { 10 }
;; 8 succs { 3 9 }
;; 9 succs { 10 }
;; 10 succs { 1 }
struct args_entry * args_tree_RB_FIND (struct args_tree * head, struct args_entry * elm)
{
  int comp;
  struct args_entry * tmp;
  struct args_entry * D.4627;

  <bb 2> :
  tmp = head->rbh_root;
  goto <bb 8>; [INV]

  <bb 3> :
  comp = args_cmp (elm, tmp);
  if (comp < 0)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  tmp = tmp->entry.rbe_left;
  goto <bb 8>; [INV]

  <bb 5> :
  if (comp > 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  tmp = tmp->entry.rbe_right;
  goto <bb 8>; [INV]

  <bb 7> :
  D.4627 = tmp;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 10>; [INV]

  <bb 8> :
  if (tmp != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 9> :
  D.4627 = 0B;

  <bb 10> :
  return D.4627;

}



;; Function args_tree_RB_NFIND (args_tree_RB_NFIND, funcdef_no=28, decl_uid=4266, cgraph_uid=29, symbol_order=36)

;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10
;;
;; Loop 1
;;  header 8, multiple latches: 4 6
;;  depth 1, outer 0
;;  nodes: 8 4 6 5 3
;; 2 succs { 8 }
;; 3 succs { 4 5 }
;; 4 succs { 8 }
;; 5 succs { 6 7 }
;; 6 succs { 8 }
;; 7 succs { 10 }
;; 8 succs { 3 9 }
;; 9 succs { 10 }
;; 10 succs { 1 }
struct args_entry * args_tree_RB_NFIND (struct args_tree * head, struct args_entry * elm)
{
  int comp;
  struct args_entry * res;
  struct args_entry * tmp;
  struct args_entry * D.4635;

  <bb 2> :
  tmp = head->rbh_root;
  res = 0B;
  goto <bb 8>; [INV]

  <bb 3> :
  comp = args_cmp (elm, tmp);
  if (comp < 0)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  res = tmp;
  tmp = tmp->entry.rbe_left;
  goto <bb 8>; [INV]

  <bb 5> :
  if (comp > 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  tmp = tmp->entry.rbe_right;
  goto <bb 8>; [INV]

  <bb 7> :
  D.4635 = tmp;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 10>; [INV]

  <bb 8> :
  if (tmp != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 9> :
  D.4635 = res;

  <bb 10> :
  return D.4635;

}



;; Function args_tree_RB_NEXT (args_tree_RB_NEXT, funcdef_no=29, decl_uid=4275, cgraph_uid=30, symbol_order=37)

Removing basic block 6
Removing basic block 10
Merging blocks 15 and 16
;; 3 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13
;;
;; Loop 2
;;  header 5, latch 4
;;  depth 1, outer 0
;;  nodes: 5 4
;;
;; Loop 1
;;  header 10, latch 9
;;  depth 1, outer 0
;;  nodes: 10 9 11
;; 2 succs { 3 6 }
;; 3 succs { 5 }
;; 4 succs { 5 }
;; 5 succs { 4 13 }
;; 6 succs { 7 10 }
;; 7 succs { 8 10 }
;; 8 succs { 13 }
;; 9 succs { 10 }
;; 10 succs { 11 12 }
;; 11 succs { 9 12 }
;; 12 succs { 13 }
;; 13 succs { 1 }
struct args_entry * args_tree_RB_NEXT (struct args_entry * elm)
{
  struct args_entry * D.4645;

  <bb 2> :
  _1 = elm->entry.rbe_right;
  if (_1 != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 3> :
  elm = elm->entry.rbe_right;
  goto <bb 5>; [INV]

  <bb 4> :
  elm = elm->entry.rbe_left;

  <bb 5> :
  _2 = elm->entry.rbe_left;
  if (_2 != 0B)
    goto <bb 4>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 6> :
  _3 = elm->entry.rbe_parent;
  if (_3 != 0B)
    goto <bb 7>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 7> :
  _4 = elm->entry.rbe_parent;
  _5 = _4->entry.rbe_left;
  if (elm == _5)
    goto <bb 8>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 8> :
  elm = elm->entry.rbe_parent;
  goto <bb 13>; [INV]

  <bb 9> :
  elm = elm->entry.rbe_parent;

  <bb 10> :
  _6 = elm->entry.rbe_parent;
  if (_6 != 0B)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  _7 = elm->entry.rbe_parent;
  _8 = _7->entry.rbe_right;
  if (elm == _8)
    goto <bb 9>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 12> :
  elm = elm->entry.rbe_parent;

  <bb 13> :
  D.4645 = elm;
  return D.4645;

}



;; Function args_tree_RB_PREV (args_tree_RB_PREV, funcdef_no=30, decl_uid=4284, cgraph_uid=31, symbol_order=38)

Removing basic block 6
Removing basic block 10
Merging blocks 15 and 16
;; 3 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13
;;
;; Loop 2
;;  header 5, latch 4
;;  depth 1, outer 0
;;  nodes: 5 4
;;
;; Loop 1
;;  header 10, latch 9
;;  depth 1, outer 0
;;  nodes: 10 9 11
;; 2 succs { 3 6 }
;; 3 succs { 5 }
;; 4 succs { 5 }
;; 5 succs { 4 13 }
;; 6 succs { 7 10 }
;; 7 succs { 8 10 }
;; 8 succs { 13 }
;; 9 succs { 10 }
;; 10 succs { 11 12 }
;; 11 succs { 9 12 }
;; 12 succs { 13 }
;; 13 succs { 1 }
struct args_entry * args_tree_RB_PREV (struct args_entry * elm)
{
  struct args_entry * D.4655;

  <bb 2> :
  _1 = elm->entry.rbe_left;
  if (_1 != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 3> :
  elm = elm->entry.rbe_left;
  goto <bb 5>; [INV]

  <bb 4> :
  elm = elm->entry.rbe_right;

  <bb 5> :
  _2 = elm->entry.rbe_right;
  if (_2 != 0B)
    goto <bb 4>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 6> :
  _3 = elm->entry.rbe_parent;
  if (_3 != 0B)
    goto <bb 7>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 7> :
  _4 = elm->entry.rbe_parent;
  _5 = _4->entry.rbe_right;
  if (elm == _5)
    goto <bb 8>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 8> :
  elm = elm->entry.rbe_parent;
  goto <bb 13>; [INV]

  <bb 9> :
  elm = elm->entry.rbe_parent;

  <bb 10> :
  _6 = elm->entry.rbe_parent;
  if (_6 != 0B)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  _7 = elm->entry.rbe_parent;
  _8 = _7->entry.rbe_left;
  if (elm == _8)
    goto <bb 9>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 12> :
  elm = elm->entry.rbe_parent;

  <bb 13> :
  D.4655 = elm;
  return D.4655;

}



;; Function args_tree_RB_MINMAX (args_tree_RB_MINMAX, funcdef_no=31, decl_uid=4294, cgraph_uid=32, symbol_order=39)

Merging blocks 7 and 8
;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7
;;
;; Loop 1
;;  header 6, multiple latches: 4 5
;;  depth 1, outer 0
;;  nodes: 6 4 5 3
;; 2 succs { 6 }
;; 3 succs { 4 5 }
;; 4 succs { 6 }
;; 5 succs { 6 }
;; 6 succs { 3 7 }
;; 7 succs { 1 }
struct args_entry * args_tree_RB_MINMAX (struct args_tree * head, int val)
{
  struct args_entry * parent;
  struct args_entry * tmp;
  struct args_entry * D.4660;

  <bb 2> :
  tmp = head->rbh_root;
  parent = 0B;
  goto <bb 6>; [INV]

  <bb 3> :
  parent = tmp;
  if (val < 0)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  tmp = tmp->entry.rbe_left;
  goto <bb 6>; [INV]

  <bb 5> :
  tmp = tmp->entry.rbe_right;

  <bb 6> :
  if (tmp != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  D.4660 = parent;
  return D.4660;

}



;; Function xrealloc (xrealloc, funcdef_no=32, decl_uid=4304, cgraph_uid=33, symbol_order=40)

Merging blocks 8 and 9
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8
;; 2 succs { 3 4 }
;; 3 succs { }
;; 4 succs { 5 6 }
;; 5 succs { }
;; 6 succs { 7 8 }
;; 7 succs { }
;; 8 succs { 1 }
void * xrealloc (void * oldptr, size_t nmemb, size_t size)
{
  void * newptr;
  size_t newsize;
  void * D.4668;

  <bb 2> :
  newsize = nmemb * size;
  if (newsize == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  printf ("zero size%s", "");
  exit (1);

  <bb 4> :
  _1 = 30 / nmemb;
  _2 = (unsigned int) _1;
  _3 = 1 << _2;
  _4 = (long unsigned int) _3;
  if (size > _4)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  printf ("nmemb * size > SIZE_MAX%s", "");
  exit (1);

  <bb 6> :
  newptr = realloc (oldptr, newsize);
  if (newptr == 0B)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  printf ("xrealloc failed%s", "");
  exit (1);

  <bb 8> :
  D.4668 = newptr;
  return D.4668;

}



;; Function paste_get_top (paste_get_top, funcdef_no=33, decl_uid=4309, cgraph_uid=34, symbol_order=41)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5
;; 2 succs { 3 4 }
;; 3 succs { 5 }
;; 4 succs { 5 }
;; 5 succs { 1 }
struct paste_buffer * paste_get_top (struct paste_stack * ps)
{
  struct paste_buffer * D.4672;

  <bb 2> :
  _1 = ps->num;
  if (_1 == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  D.4672 = 0B;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 5>; [INV]

  <bb 4> :
  _2 = ps->list;
  D.4672 = *_2;

  <bb 5> :
  return D.4672;

}



;; Function paste_get_index (paste_get_index, funcdef_no=34, decl_uid=4313, cgraph_uid=35, symbol_order=42)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5
;; 2 succs { 3 4 }
;; 3 succs { 5 }
;; 4 succs { 5 }
;; 5 succs { 1 }
struct paste_buffer * paste_get_index (struct paste_stack * ps, u_int idx)
{
  struct paste_buffer * D.4676;

  <bb 2> :
  _1 = ps->num;
  if (idx >= _1)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  D.4676 = 0B;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 5>; [INV]

  <bb 4> :
  _2 = ps->list;
  _3 = (long unsigned int) idx;
  _4 = _3 * 8;
  _5 = _2 + _4;
  D.4676 = *_5;

  <bb 5> :
  return D.4676;

}



;; Function paste_free_top (paste_free_top, funcdef_no=35, decl_uid=4316, cgraph_uid=36, symbol_order=43)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9
;; 2 succs { 3 4 }
;; 3 succs { 9 }
;; 4 succs { 5 6 }
;; 5 succs { 6 }
;; 6 succs { 7 8 }
;; 7 succs { 8 }
;; 8 succs { 9 }
;; 9 succs { 1 }
int paste_free_top (struct paste_stack * ps)
{
  struct paste_buffer * pb;
  int D.4680;

  <bb 2> :
  _1 = ps->num;
  if (_1 == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  D.4680 = -1;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 9>; [INV]

  <bb 4> :
  _2 = ps->list;
  pb = *_2;
  _3 = ps->num;
  if (_3 != 1)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  _4 = ps->num;
  _5 = _4 + 4294967295;
  _6 = (long unsigned int) _5;
  _7 = _6 * 8;
  _8 = ps->list;
  _9 = _8 + 8;
  _10 = ps->list;
  memmove (_10, _9, _7);

  <bb 6> :
  _11 = ps->num;
  _12 = _11 + 4294967295;
  ps->num = _12;
  _13 = ps->num;
  if (_13 == 0)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  _14 = ps->list;
  free (_14);
  ps->num = 0;
  ps->list = 0B;
  ps->space = 0;

  <bb 8> :
  _15 = pb->data;
  free (_15);
  free (pb);
  D.4680 = 0;

  <bb 9> :
  return D.4680;

}



;; Function paste_free_index (paste_free_index, funcdef_no=36, decl_uid=4328, cgraph_uid=37, symbol_order=44)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9
;; 2 succs { 3 4 }
;; 3 succs { 9 }
;; 4 succs { 5 6 }
;; 5 succs { 6 }
;; 6 succs { 7 8 }
;; 7 succs { 8 }
;; 8 succs { 9 }
;; 9 succs { 1 }
int paste_free_index (struct paste_stack * ps, u_int idx)
{
  struct paste_buffer * pb;
  int D.4688;

  <bb 2> :
  _1 = ps->num;
  if (idx >= _1)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  D.4688 = -1;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 9>; [INV]

  <bb 4> :
  _2 = ps->list;
  _3 = (long unsigned int) idx;
  _4 = _3 * 8;
  _5 = _2 + _4;
  pb = *_5;
  _6 = ps->num;
  _7 = _6 + 4294967295;
  if (idx < _7)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  _8 = ps->num;
  _9 = _8 - idx;
  _10 = _9 + 4294967295;
  _11 = (long unsigned int) _10;
  _12 = _11 * 8;
  _13 = ps->list;
  _14 = (sizetype) idx;
  _15 = _14 + 1;
  _16 = _15 * 8;
  _17 = _13 + _16;
  _18 = ps->list;
  _19 = (long unsigned int) idx;
  _20 = _19 * 8;
  _21 = _18 + _20;
  memmove (_21, _17, _12);

  <bb 6> :
  _22 = ps->num;
  _23 = _22 + 4294967295;
  ps->num = _23;
  _24 = ps->num;
  if (_24 == 0)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  _25 = ps->list;
  free (_25);
  ps->num = 0;
  ps->list = 0B;
  ps->space = 0;

  <bb 8> :
  _26 = pb->data;
  free (_26);
  free (pb);
  D.4688 = 0;

  <bb 9> :
  return D.4688;

}



;; Function paste_add (paste_add, funcdef_no=37, decl_uid=4342, cgraph_uid=38, symbol_order=45)

Removing basic block 4
Removing basic block 15
;; 3 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19
;;
;; Loop 2
;;  header 15, latch 14
;;  depth 1, outer 0
;;  nodes: 15 14
;;
;; Loop 1
;;  header 7, multiple latches: 5 6
;;  depth 1, outer 0
;;  nodes: 7 5 6 4
;; 2 succs { 3 7 }
;; 3 succs { 19 }
;; 4 succs { 5 6 }
;; 5 succs { 7 }
;; 6 succs { 7 }
;; 7 succs { 4 8 }
;; 8 succs { 9 10 }
;; 9 succs { }
;; 10 succs { 11 12 }
;; 11 succs { }
;; 12 succs { 13 15 }
;; 13 succs { 15 }
;; 14 succs { 15 }
;; 15 succs { 14 16 }
;; 16 succs { 17 18 }
;; 17 succs { 18 }
;; 18 succs { 19 }
;; 19 succs { 1 }
void paste_add (struct paste_stack * ps, char * data, size_t size, u_int limit)
{
  struct paste_buffer * pb;

  <bb 2> :
  if (size == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 3> :
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 19>; [INV]

  <bb 4> :
  _1 = ps->list;
  _2 = ps->num;
  _3 = _2 + 4294967295;
  _4 = (long unsigned int) _3;
  _5 = _4 * 8;
  _6 = _1 + _5;
  pb = *_6;
  _7 = pb->data;
  free (_7);
  free (pb);
  _8 = ps->num;
  if (_8 > 1)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  _9 = ps->num;
  _10 = _9 + 4294967295;
  ps->num = _10;
  goto <bb 7>; [INV]

  <bb 6> :
  _11 = ps->list;
  free (_11);
  ps->num = 0;
  ps->list = 0B;
  ps->space = 0;

  <bb 7> :
  _12 = ps->num;
  if (limit <= _12)
    goto <bb 4>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 8> :
  pb = malloc (96);
  _13 = ps->num;
  if (_13 > 1073741823)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  printf ("number too big%s", "");
  exit (1);

  <bb 10> :
  _14 = ps->num;
  _15 = _14 + 1;
  _16 = 1073741824 / _15;
  if (_16 <= 7)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  printf ("size too big%s", "");
  exit (1);

  <bb 12> :
  _17 = ps->space;
  if (_17 == 0)
    goto <bb 13>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 13> :
  ps->space = 80;
  _18 = ps->space;
  _19 = ps->list;
  _20 = xrealloc (_19, 1, _18);
  ps->list = _20;
  goto <bb 15>; [INV]

  <bb 14> :
  _21 = ps->space;
  _22 = ps->list;
  _23 = xrealloc (_22, 2, _21);
  ps->list = _23;
  _24 = ps->space;
  _25 = _24 * 2;
  ps->space = _25;

  <bb 15> :
  _26 = ps->space;
  _27 = ps->num;
  _28 = _27 + 1;
  _29 = (long unsigned int) _28;
  _30 = _29 * 8;
  if (_26 <= _30)
    goto <bb 14>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 16> :
  _31 = ps->num;
  if (_31 != 0)
    goto <bb 17>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 17> :
  _32 = ps->num;
  _33 = (long unsigned int) _32;
  _34 = _33 * 8;
  _35 = ps->list;
  _36 = ps->list;
  _37 = _36 + 8;
  memmove (_37, _35, _34);

  <bb 18> :
  _38 = ps->list;
  *_38 = pb;
  _39 = ps->num;
  _40 = _39 + 1;
  ps->num = _40;
  pb->data = data;
  pb->size = size;

  <bb 19> :
  return;

}



;; Function paste_replace (paste_replace, funcdef_no=38, decl_uid=4366, cgraph_uid=39, symbol_order=46)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7
;; 2 succs { 3 4 }
;; 3 succs { 7 }
;; 4 succs { 5 6 }
;; 5 succs { 7 }
;; 6 succs { 7 }
;; 7 succs { 1 }
int paste_replace (struct paste_stack * ps, u_int idx, char * data, size_t size)
{
  struct paste_buffer * pb;
  int D.4710;

  <bb 2> :
  if (size == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  D.4710 = 0;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 7>; [INV]

  <bb 4> :
  _1 = ps->num;
  if (idx >= _1)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  D.4710 = -1;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 7>; [INV]

  <bb 6> :
  _2 = ps->list;
  _3 = (long unsigned int) idx;
  _4 = _3 * 8;
  _5 = _2 + _4;
  pb = *_5;
  _6 = pb->data;
  free (_6);
  pb->data = data;
  pb->size = size;
  D.4710 = 0;

  <bb 7> :
  return D.4710;

}



;; Function cmd_load_buffer_callback (cmd_load_buffer_callback, funcdef_no=39, decl_uid=4372, cgraph_uid=40, symbol_order=47)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
;; 2 succs { 3 4 }
;; 3 succs { 15 }
;; 4 succs { 5 6 }
;; 5 succs { 15 }
;; 6 succs { 8 7 }
;; 7 succs { 8 9 }
;; 8 succs { 14 }
;; 9 succs { 10 11 }
;; 10 succs { 13 }
;; 11 succs { 12 13 }
;; 12 succs { 13 }
;; 13 succs { 14 }
;; 14 succs { 15 }
;; 15 succs { 1 }
void cmd_load_buffer_callback (struct client * c, int closed, void * data)
{
  u_int limit;
  size_t psize;
  char * pdata;
  int * buffer;

  <bb 2> :
  buffer = data;
  if (closed == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 15>; [INV]

  <bb 4> :
  c->stdin_callback = 0B;
  _1 = c->references;
  _2 = _1 + -1;
  c->references = _2;
  _3 = c->flags;
  _4 = _3 & 512;
  if (_4 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 15>; [INV]

  <bb 6> :
  if (psize == 0)
    goto <bb 8>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  _5 = psize + 1;
  pdata = malloc (_5);
  if (pdata == 0B)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  free (data);
  // predicted unlikely by goto predictor.
  goto <bb 14>; [INV]

  <bb 9> :
  _6 = pdata + psize;
  *_6 = 0;
  _7 = *buffer;
  if (_7 == -1)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  paste_add (&global_buffers, pdata, psize, limit);
  goto <bb 13>; [INV]

  <bb 11> :
  _8 = *buffer;
  _9 = (unsigned int) _8;
  _10 = paste_replace (&global_buffers, _9, pdata, psize);
  if (_10 != 0)
    goto <bb 12>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 12> :
  _11 = *buffer;
  printf ("no buffer %d\n", _11);

  <bb 13> :
  free (data);

  <bb 14> :
out:
  printf ("cmdq_continue");

  <bb 15> :
  return;

}



;; Function args_find (args_find, funcdef_no=40, decl_uid=4381, cgraph_uid=41, symbol_order=48)

Merging blocks 2 and 3
Merging blocks 2 and 4
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
struct args_entry * args_find (struct args * args, u_char ch)
{
  struct args_entry entry;
  struct args_entry * D.4727;

  <bb 2> :
  entry.flag = ch;
  _1 = &args->tree;
  D.4727 = args_tree_RB_FIND (_1, &entry);
  entry = {CLOBBER};
  return D.4727;

}



;; Function args_has (args_has, funcdef_no=41, decl_uid=4386, cgraph_uid=42, symbol_order=49)

Merging blocks 2 and 3
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
int args_has (struct args * args, u_char ch)
{
  int D.4730;

  <bb 2> :
  _1 = (int) ch;
  _2 = args_find (args, _1);
  _3 = _2 != 0B;
  D.4730 = (int) _3;
  return D.4730;

}



;; Function main (main, funcdef_no=42, decl_uid=4390, cgraph_uid=43, symbol_order=50)

Removing basic block 8
Merging blocks 22 and 23
;; 4 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21
;;
;; Loop 3
;;  header 20, multiple latches: 16 18 19
;;  depth 1, outer 0
;;  nodes: 20 16 18 19 17 14 15 12 13 11 9 10 8
;;
;; Loop 2
;;  header 7, latch 6
;;  depth 1, outer 0
;;  nodes: 7 6
;;
;; Loop 1
;;  header 4, latch 3
;;  depth 1, outer 0
;;  nodes: 4 3
;; 2 succs { 4 }
;; 3 succs { 4 }
;; 4 succs { 3 5 }
;; 5 succs { 7 }
;; 6 succs { 7 }
;; 7 succs { 6 20 }
;; 8 succs { 9 10 }
;; 9 succs { 11 }
;; 10 succs { 11 }
;; 11 succs { 12 13 }
;; 12 succs { 14 }
;; 13 succs { 14 }
;; 14 succs { 15 16 }
;; 15 succs { 16 }
;; 16 succs { 17 20 }
;; 17 succs { 18 19 }
;; 18 succs { 20 }
;; 19 succs { 20 }
;; 20 succs { 8 21 }
;; 21 succs { 1 }
int main (int argc, char * * argv)
{
  int i;
  struct args * args;
  int buffer;
  void * data;
  int closed;
  struct paste_buffer * pb;
  struct client c;
  int D.4745;

  <bb 2> :
  _1 = (long unsigned int) argc;
  args = calloc (_1, 24);
  i = 0;
  goto <bb 4>; [INV]

  <bb 3> :
  _2 = (long unsigned int) i;
  _3 = _2 * 8;
  _4 = argv + _3;
  _5 = args->argv;
  _6 = (long unsigned int) i;
  _7 = _6 * 8;
  _8 = _5 + _7;
  _9 = *_4;
  *_8 = _9;
  i = i + 1;

  <bb 4> :
  if (i < argc)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 5> :
  _10 = malloc (96);
  global_buffers.list = _10;
  goto <bb 7>; [INV]

  <bb 6> :
  cmd_load_buffer_callback (&c, closed, data);

  <bb 7> :
  _11 = getchar ();
  if (_11 != 0)
    goto <bb 6>; [INV]
  else
    goto <bb 20>; [INV]

  <bb 8> :
  _12 = args_has (args, 98);
  if (_12 == 0)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  buffer = -1;
  goto <bb 11>; [INV]

  <bb 10> :
  scanf ("%d", &buffer);

  <bb 11> :
  buffer.0_13 = buffer;
  if (buffer.0_13 == -1)
    goto <bb 12>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 12> :
  pb = paste_get_top (&global_buffers);
  goto <bb 14>; [INV]

  <bb 13> :
  buffer.1_14 = buffer;
  buffer.2_15 = (unsigned int) buffer.1_14;
  pb = paste_get_index (&global_buffers, buffer.2_15);

  <bb 14> :
  if (pb != 0B)
    goto <bb 15>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 15> :
  _16 = pb->data;
  printf ("buffer : %s\n", _16);

  <bb 16> :
  _17 = args_has (args, 100);
  if (_17 != 0)
    goto <bb 17>; [INV]
  else
    goto <bb 20>; [INV]

  <bb 17> :
  buffer.3_18 = buffer;
  if (buffer.3_18 == -1)
    goto <bb 18>; [INV]
  else
    goto <bb 19>; [INV]

  <bb 18> :
  paste_free_top (&global_buffers);
  goto <bb 20>; [INV]

  <bb 19> :
  buffer.4_19 = buffer;
  buffer.5_20 = (unsigned int) buffer.4_19;
  paste_get_index (&global_buffers, buffer.5_20);

  <bb 20> :
  _21 = getchar ();
  if (_21 != 0)
    goto <bb 8>; [INV]
  else
    goto <bb 21>; [INV]

  <bb 21> :
  _22 = global_buffers.list;
  free (_22);
  global_buffers.num = 0;
  global_buffers.list = 0B;
  global_buffers.space = 0;
  free (args);
  c = {CLOBBER};
  buffer = {CLOBBER};
  D.4745 = 0;
  return D.4745;

}



;; Function getchar (getchar, funcdef_no=1, decl_uid=2214, cgraph_uid=2, symbol_order=1)

Merging blocks 2 and 3
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
__attribute__((gnu_inline))
int getchar ()
{
  int D.4747;

  <bb 2> :
  stdin.6_1 = stdin;
  D.4747 = getc (stdin.6_1);
  return D.4747;

}


