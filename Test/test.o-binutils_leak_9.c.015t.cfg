
;; Function discard_cleanups (discard_cleanups, funcdef_no=22, decl_uid=3018, cgraph_uid=23, symbol_order=27)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
void discard_cleanups (struct cleanup * old_chain)
{
  <bb 2> :
  discard_my_cleanups (&cleanup_chain, old_chain);
  return;

}



;; Function discard_final_cleanups (discard_final_cleanups, funcdef_no=23, decl_uid=3023, cgraph_uid=24, symbol_order=28)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
void discard_final_cleanups (struct cleanup * old_chain)
{
  <bb 2> :
  discard_my_cleanups (&final_cleanup_chain, old_chain);
  return;

}



;; Function discard_my_cleanups (discard_my_cleanups, funcdef_no=24, decl_uid=3021, cgraph_uid=25, symbol_order=29)

;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7
;;
;; Loop 1
;;  header 6, latch 5
;;  depth 1, outer 0
;;  nodes: 6 5 3 4
;; 2 succs { 6 }
;; 3 succs { 4 5 }
;; 4 succs { 5 }
;; 5 succs { 6 }
;; 6 succs { 3 7 }
;; 7 succs { 1 }
void discard_my_cleanups (struct cleanup * * pmy_chain, struct cleanup * old_chain)
{
  struct cleanup * ptr;

  <bb 2> :
  goto <bb 6>; [INV]

  <bb 3> :
  _1 = ptr->next;
  *pmy_chain = _1;
  _2 = ptr->free_arg;
  if (_2 != 0B)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  _3 = ptr->free_arg;
  _4 = ptr->arg;
  _3 (_4);

  <bb 5> :
  free (ptr);

  <bb 6> :
  ptr = *pmy_chain;
  if (ptr != old_chain)
    goto <bb 3>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  _5 = ptr->arg;
  printf ("freearg: %x\n", _5);
  return;

}



;; Function do_cleanups (do_cleanups, funcdef_no=26, decl_uid=3028, cgraph_uid=27, symbol_order=31)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
void do_cleanups (struct cleanup * old_chain)
{
  <bb 2> :
  do_my_cleanups (&cleanup_chain, old_chain);
  return;

}



;; Function do_my_cleanups (do_my_cleanups, funcdef_no=25, decl_uid=3026, cgraph_uid=26, symbol_order=30)

;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7
;;
;; Loop 1
;;  header 6, latch 5
;;  depth 1, outer 0
;;  nodes: 6 5 3 4
;; 2 succs { 6 }
;; 3 succs { 4 5 }
;; 4 succs { 5 }
;; 5 succs { 6 }
;; 6 succs { 3 7 }
;; 7 succs { 1 }
void do_my_cleanups (struct cleanup * * pmy_chain, struct cleanup * old_chain)
{
  struct cleanup * ptr;

  <bb 2> :
  goto <bb 6>; [INV]

  <bb 3> :
  _1 = ptr->next;
  *pmy_chain = _1;
  _2 = ptr->function;
  _3 = ptr->arg;
  _2 (_3);
  __builtin_puts (&"cleanup!!!!! ========="[0]);
  _4 = ptr->arg;
  printf ("%x\n", _4);
  _5 = ptr->free_arg;
  if (_5 != 0B)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  _6 = ptr->free_arg;
  _7 = ptr->arg;
  _6 (_7);

  <bb 5> :
  free (ptr);

  <bb 6> :
  ptr = *pmy_chain;
  if (ptr != old_chain)
    goto <bb 3>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  return;

}



;; Function make_cleanup (make_cleanup, funcdef_no=29, decl_uid=3041, cgraph_uid=30, symbol_order=34)

Merging blocks 2 and 3
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
struct cleanup * make_cleanup (void (*<T59c>) (void *) function, void * arg)
{
  struct cleanup * D.3356;

  <bb 2> :
  D.3356 = make_my_cleanup (&cleanup_chain, function, arg);
  return D.3356;

}



;; Function make_my_cleanup (make_my_cleanup, funcdef_no=28, decl_uid=3038, cgraph_uid=29, symbol_order=33)

Merging blocks 2 and 3
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
struct cleanup * make_my_cleanup (struct cleanup * * pmy_chain, void (*<T59c>) (void *) function, void * arg)
{
  struct cleanup * D.3358;

  <bb 2> :
  D.3358 = make_my_cleanup2 (pmy_chain, function, arg, 0B);
  return D.3358;

}



;; Function make_my_cleanup2 (make_my_cleanup2, funcdef_no=27, decl_uid=3034, cgraph_uid=28, symbol_order=32)

Merging blocks 4 and 5
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4
;; 2 succs { 3 4 }
;; 3 succs { }
;; 4 succs { 1 }
struct cleanup * make_my_cleanup2 (struct cleanup * * pmy_chain, void (*<T59c>) (void *) function, void * arg, void (*<Tee>) (void *) free_arg)
{
  struct cleanup * old_chain;
  struct cleanup * new;
  struct cleanup * D.3362;

  <bb 2> :
  new = malloc (32);
  old_chain = *pmy_chain;
  _1 = *pmy_chain;
  new->next = _1;
  new->function = function;
  new->free_arg = free_arg;
  new->arg = arg;
  *pmy_chain = new;
  if (old_chain == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  exit (1);

  <bb 4> :
  D.3362 = old_chain;
  return D.3362;

}



;; Function ada_demangle (ada_demangle, funcdef_no=32, decl_uid=3264, cgraph_uid=33, symbol_order=37)

Removing basic block 26
Removing basic block 87
Removing basic block 89
Removing basic block 11
Removing basic block 20
Removing basic block 69
Removing basic block 80
Removing basic block 98
;; 10 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96
;;
;; Loop 9
;;  header 88, latch 87
;;  depth 1, outer 0
;;  nodes: 88 87
;;
;; Loop 8
;;  header 65, latch 64
;;  depth 1, outer 0
;;  nodes: 65 64
;;
;; Loop 7
;;  header 59, multiple latches: 59 61
;;  depth 1, outer 0
;;  nodes: 59 61 60
;;
;; Loop 6
;;  header 72, latch 71
;;  depth 1, outer 0
;;  nodes: 72 71 69
;;
;; Loop 5
;;  header 79, latch 78
;;  depth 1, outer 0
;;  nodes: 79 78
;;
;; Loop 1
;;  header 7, multiple latches: 75 26
;;  depth 1, outer 0
;;  nodes: 7 75 26 25 24 22 23 21 20 10 17 9 8 14 16 12 15 13 11 66 67 58 57 56 49 50 40 41 42 36 39 37 38 33 34 31 32 28 29 44 45 46 47 43
;;
;; Loop 4
;;  header 39, latch 38
;;  depth 2, outer 1
;;  nodes: 39 38
;;
;; Loop 3
;;  header 8, multiple latches: 8 10
;;  depth 2, outer 1
;;  nodes: 8 10 9
;;
;; Loop 2
;;  header 16, latch 15
;;  depth 2, outer 1
;;  nodes: 16 15 13
;; 2 succs { 3 4 }
;; 3 succs { 4 }
;; 4 succs { 5 6 }
;; 5 succs { 92 }
;; 6 succs { 7 }
;; 7 succs { 8 11 }
;; 8 succs { 8 9 }
;; 9 succs { 10 20 }
;; 10 succs { 8 20 }
;; 11 succs { 12 19 }
;; 12 succs { 16 }
;; 13 succs { 14 15 }
;; 14 succs { 17 }
;; 15 succs { 16 }
;; 16 succs { 13 17 }
;; 17 succs { 18 20 }
;; 18 succs { 92 }
;; 19 succs { 92 }
;; 20 succs { 21 28 }
;; 21 succs { 22 28 }
;; 22 succs { 23 24 }
;; 23 succs { 91 24 }
;; 24 succs { 25 27 }
;; 25 succs { 26 27 }
;; 26 succs { 7 }
;; 27 succs { 92 }
;; 28 succs { 29 31 }
;; 29 succs { 30 31 }
;; 30 succs { 92 }
;; 31 succs { 32 33 }
;; 32 succs { 91 33 }
;; 33 succs { 34 36 }
;; 34 succs { 35 36 }
;; 35 succs { 92 }
;; 36 succs { 37 40 }
;; 37 succs { 39 }
;; 38 succs { 39 }
;; 39 succs { 38 40 }
;; 40 succs { 41 50 }
;; 41 succs { 42 50 }
;; 42 succs { 43 50 }
;; 43 succs { 48 46 47 44 45 }
;; 44 succs { 49 }
;; 45 succs { 49 }
;; 46 succs { 49 }
;; 47 succs { 49 }
;; 48 succs { 92 }
;; 49 succs { 56 }
;; 50 succs { 51 56 }
;; 51 succs { 54 53 52 }
;; 52 succs { 55 }
;; 53 succs { 55 }
;; 54 succs { 92 }
;; 55 succs { 91 }
;; 56 succs { 57 84 }
;; 57 succs { 58 76 }
;; 58 succs { 59 66 }
;; 59 succs { 59 60 }
;; 60 succs { 61 62 }
;; 61 succs { 59 62 }
;; 62 succs { 63 84 }
;; 63 succs { 65 }
;; 64 succs { 65 }
;; 65 succs { 64 84 }
;; 66 succs { 67 75 }
;; 67 succs { 68 75 }
;; 68 succs { 72 }
;; 69 succs { 70 71 }
;; 70 succs { 73 }
;; 71 succs { 72 }
;; 72 succs { 69 73 }
;; 73 succs { 91 74 }
;; 74 succs { 92 }
;; 75 succs { 7 }
;; 76 succs { 77 83 }
;; 77 succs { 79 }
;; 78 succs { 79 }
;; 79 succs { 78 80 }
;; 80 succs { 81 82 }
;; 81 succs { 91 82 }
;; 82 succs { 92 }
;; 83 succs { 92 }
;; 84 succs { 85 89 }
;; 85 succs { 86 89 }
;; 86 succs { 88 }
;; 87 succs { 88 }
;; 88 succs { 87 89 }
;; 89 succs { 91 90 }
;; 90 succs { 92 }
;; 91 succs { 96 }
;; 92 succs { 93 94 }
;; 93 succs { 95 }
;; 94 succs { 95 }
;; 95 succs { 96 }
;; 96 succs { 1 }
char * ada_demangle (const char * mangled)
{
  size_t slen;
  int k;
  static const char * const special[6][2] = {{(const char *) "_elabb", (const char *) "\'Elab_Body"}, {(const char *) "_elabs", (const char *) "\'Elab_Spec"}, {(const char *) "_size", (const char *) "\'Size"}, {(const char *) "_alignment", (const char *) "\'Alignment"}, {(const char *) "_assign", (const char *) ".\":=\""}, {0B, 0B}};
  const char * name;
  const char * name;
  size_t slen;
  int k;
  static const char * const operators[20][2] = {{(const char *) "Oabs", (const char *) "abs"}, {(const char *) "Oand", (const char *) "and"}, {(const char *) "Omod", (const char *) "mod"}, {(const char *) "Onot", (const char *) "not"}, {(const char *) "Oor", (const char *) "or"}, {(const char *) "Orem", (const char *) "rem"}, {(const char *) "Oxor", (const char *) "xor"}, {(const char *) "Oeq", (const char *) "="}, {(const char *) "One", (const char *) "/="}, {(const char *) "Olt", (const char *) "<"}, {(const char *) "Ole", (const char *) "<="}, {(const char *) "Ogt", (const char *) ">"}, {(const char *) "Oge", (const char *) ">="}, {(const char *) "Oadd", (const char *) "+"}, {(const char *) "Osubtract", (const char *) "-"}, {(const char *) "Oconcat", (const char *) "&"}, {(const char *) "Omultiply", (const char *) "*"}, {(const char *) "Odivide", (const char *) "/"}, {(const char *) "Oexpon", (const char *) "**"}, {0B, 0B}};
  char * demangled;
  char * d;
  const char * p;
  int len0;
  char * D.3439;

  <bb 2> :
  _1 = strncmp (mangled, "_ada_", 5);
  if (_1 == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  mangled = mangled + 5;

  <bb 4> :
  _2 = *mangled;
  _3 = (unsigned char) _2;
  _4 = _3 + 159;
  if (_4 > 25)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  // predicted unlikely by goto predictor.
  goto <bb 92>; [INV]

  <bb 6> :
  _5 = strlen (mangled);
  _6 = (unsigned int) _5;
  _7 = _6 + 8;
  len0 = (int) _7;
  _8 = (long unsigned int) len0;
  demangled = malloc (_8);
  d = demangled;
  p = mangled;

  <bb 7> :
  _9 = *p;
  _10 = (unsigned char) _9;
  _11 = _10 + 159;
  if (_11 > 25)
    goto <bb 8>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 8> :
  p.0_12 = p;
  p = p.0_12 + 1;
  d.1_13 = d;
  d = d.1_13 + 1;
  _14 = *p.0_12;
  *d.1_13 = _14;
  _15 = *p;
  _16 = (unsigned char) _15;
  _17 = _16 + 159;
  _18 = _17 <= 25;
  _19 = *p;
  _20 = (unsigned char) _19;
  _21 = _20 + 208;
  _22 = _21 <= 9;
  _23 = _18 | _22;
  if (_23 != 0)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 9> :
  _24 = *p;
  if (_24 == 95)
    goto <bb 10>; [INV]
  else
    goto <bb 20>; [INV]

  <bb 10> :
  _25 = p + 1;
  _26 = *_25;
  _27 = (unsigned char) _26;
  _28 = _27 + 159;
  _29 = _28 <= 25;
  _30 = p + 1;
  _31 = *_30;
  _32 = (unsigned char) _31;
  _33 = _32 + 208;
  _34 = _33 <= 9;
  _35 = _29 | _34;
  if (_35 != 0)
    goto <bb 8>; [INV]
  else
    goto <bb 20>; [INV]

  <bb 11> :
  _36 = *p;
  if (_36 == 79)
    goto <bb 12>; [INV]
  else
    goto <bb 19>; [INV]

  <bb 12> :
  k = 0;
  goto <bb 16>; [INV]

  <bb 13> :
  _37 = operators[k][0];
  slen = strlen (_37);
  _38 = operators[k][0];
  _39 = strncmp (p, _38, slen);
  if (_39 == 0)
    goto <bb 14>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 14> :
  p = p + slen;
  _40 = operators[k][1];
  slen = strlen (_40);
  d.2_41 = d;
  d = d.2_41 + 1;
  *d.2_41 = 34;
  _42 = operators[k][1];
  memcpy (d, _42, slen);
  d = d + slen;
  d.3_43 = d;
  d = d.3_43 + 1;
  *d.3_43 = 34;
  goto <bb 17>; [INV]

  <bb 15> :
  k = k + 1;

  <bb 16> :
  _44 = operators[k][0];
  if (_44 != 0B)
    goto <bb 13>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 17> :
  _45 = operators[k][0];
  if (_45 == 0B)
    goto <bb 18>; [INV]
  else
    goto <bb 20>; [INV]

  <bb 18> :
  // predicted unlikely by goto predictor.
  goto <bb 92>; [INV]

  <bb 19> :
  // predicted unlikely by goto predictor.
  goto <bb 92>; [INV]

  <bb 20> :
  _46 = *p;
  if (_46 == 84)
    goto <bb 21>; [INV]
  else
    goto <bb 28>; [INV]

  <bb 21> :
  _47 = p + 1;
  _48 = *_47;
  if (_48 == 75)
    goto <bb 22>; [INV]
  else
    goto <bb 28>; [INV]

  <bb 22> :
  _49 = p + 2;
  _50 = *_49;
  if (_50 == 66)
    goto <bb 23>; [INV]
  else
    goto <bb 24>; [INV]

  <bb 23> :
  _51 = p + 3;
  _52 = *_51;
  if (_52 == 0)
    goto <bb 91>; [INV]
  else
    goto <bb 24>; [INV]

  <bb 24> :
  _53 = p + 2;
  _54 = *_53;
  if (_54 == 95)
    goto <bb 25>; [INV]
  else
    goto <bb 27>; [INV]

  <bb 25> :
  _55 = p + 3;
  _56 = *_55;
  if (_56 == 95)
    goto <bb 26>; [INV]
  else
    goto <bb 27>; [INV]

  <bb 26> :
  p = p + 4;
  d.4_57 = d;
  d = d.4_57 + 1;
  *d.4_57 = 46;
  // predicted unlikely by continue predictor.
  goto <bb 7>; [INV]

  <bb 27> :
  // predicted unlikely by goto predictor.
  goto <bb 92>; [INV]

  <bb 28> :
  _58 = *p;
  if (_58 == 69)
    goto <bb 29>; [INV]
  else
    goto <bb 31>; [INV]

  <bb 29> :
  _59 = p + 1;
  _60 = *_59;
  if (_60 == 0)
    goto <bb 30>; [INV]
  else
    goto <bb 31>; [INV]

  <bb 30> :
  // predicted unlikely by goto predictor.
  goto <bb 92>; [INV]

  <bb 31> :
  _61 = *p;
  _62 = _61 == 80;
  _63 = *p;
  _64 = _63 == 78;
  _65 = _62 | _64;
  if (_65 != 0)
    goto <bb 32>; [INV]
  else
    goto <bb 33>; [INV]

  <bb 32> :
  _66 = p + 1;
  _67 = *_66;
  if (_67 == 0)
    goto <bb 91>; [INV]
  else
    goto <bb 33>; [INV]

  <bb 33> :
  _68 = *p;
  _69 = _68 == 78;
  _70 = *p;
  _71 = _70 == 83;
  _72 = _69 | _71;
  if (_72 != 0)
    goto <bb 34>; [INV]
  else
    goto <bb 36>; [INV]

  <bb 34> :
  _73 = p + 1;
  _74 = *_73;
  if (_74 == 0)
    goto <bb 35>; [INV]
  else
    goto <bb 36>; [INV]

  <bb 35> :
  // predicted unlikely by goto predictor.
  goto <bb 92>; [INV]

  <bb 36> :
  _75 = *p;
  if (_75 == 88)
    goto <bb 37>; [INV]
  else
    goto <bb 40>; [INV]

  <bb 37> :
  p = p + 1;
  goto <bb 39>; [INV]

  <bb 38> :
  p = p + 1;

  <bb 39> :
  _76 = *p;
  _77 = _76 == 110;
  _78 = *p;
  _79 = _78 == 98;
  _80 = _77 | _79;
  if (_80 != 0)
    goto <bb 38>; [INV]
  else
    goto <bb 40>; [INV]

  <bb 40> :
  _81 = *p;
  if (_81 == 83)
    goto <bb 41>; [INV]
  else
    goto <bb 50>; [INV]

  <bb 41> :
  _82 = p + 1;
  _83 = *_82;
  if (_83 != 0)
    goto <bb 42>; [INV]
  else
    goto <bb 50>; [INV]

  <bb 42> :
  _84 = p + 2;
  _85 = *_84;
  _86 = _85 == 95;
  _87 = p + 2;
  _88 = *_87;
  _89 = _88 == 0;
  _90 = _86 | _89;
  if (_90 != 0)
    goto <bb 43>; [INV]
  else
    goto <bb 50>; [INV]

  <bb 43> :
  _91 = p + 1;
  _92 = *_91;
  _93 = (int) _92;
  switch (_93) <default: <L55> [INV], case 73: <L53> [INV], case 79: <L54> [INV], case 82: <L51> [INV], case 87: <L52> [INV]>

  <bb 44> :
<L51>:
  name = "\'Read";
  goto <bb 49>; [INV]

  <bb 45> :
<L52>:
  name = "\'Write";
  goto <bb 49>; [INV]

  <bb 46> :
<L53>:
  name = "\'Input";
  goto <bb 49>; [INV]

  <bb 47> :
<L54>:
  name = "\'Output";
  goto <bb 49>; [INV]

  <bb 48> :
<L55>:
  // predicted unlikely by goto predictor.
  goto <bb 92>; [INV]

  <bb 49> :
  p = p + 2;
  strcpy (d, name);
  _94 = strlen (name);
  d = d + _94;
  goto <bb 56>; [INV]

  <bb 50> :
  _95 = *p;
  if (_95 == 68)
    goto <bb 51>; [INV]
  else
    goto <bb 56>; [INV]

  <bb 51> :
  _96 = p + 1;
  _97 = *_96;
  _98 = (int) _97;
  switch (_98) <default: <L61> [INV], case 65: <L60> [INV], case 70: <L59> [INV]>

  <bb 52> :
<L59>:
  name = ".Finalize";
  goto <bb 55>; [INV]

  <bb 53> :
<L60>:
  name = ".Adjust";
  goto <bb 55>; [INV]

  <bb 54> :
<L61>:
  // predicted unlikely by goto predictor.
  goto <bb 92>; [INV]

  <bb 55> :
  strcpy (d, name);
  _99 = strlen (name);
  d = d + _99;
  goto <bb 91>; [INV]

  <bb 56> :
  _100 = *p;
  if (_100 == 95)
    goto <bb 57>; [INV]
  else
    goto <bb 84>; [INV]

  <bb 57> :
  _101 = p + 1;
  _102 = *_101;
  if (_102 == 95)
    goto <bb 58>; [INV]
  else
    goto <bb 76>; [INV]

  <bb 58> :
  p = p + 2;
  _103 = *p;
  _104 = (unsigned int) _103;
  _105 = _104 + 4294967248;
  if (_105 <= 9)
    goto <bb 59>; [INV]
  else
    goto <bb 66>; [INV]

  <bb 59> :
  p = p + 1;
  _106 = *p;
  _107 = (unsigned int) _106;
  _108 = _107 + 4294967248;
  if (_108 <= 9)
    goto <bb 59>; [INV]
  else
    goto <bb 60>; [INV]

  <bb 60> :
  _109 = *p;
  if (_109 == 95)
    goto <bb 61>; [INV]
  else
    goto <bb 62>; [INV]

  <bb 61> :
  _110 = p + 1;
  _111 = *_110;
  _112 = (unsigned int) _111;
  _113 = _112 + 4294967248;
  if (_113 <= 9)
    goto <bb 59>; [INV]
  else
    goto <bb 62>; [INV]

  <bb 62> :
  _114 = *p;
  if (_114 == 88)
    goto <bb 63>; [INV]
  else
    goto <bb 84>; [INV]

  <bb 63> :
  p = p + 1;
  goto <bb 65>; [INV]

  <bb 64> :
  p = p + 1;

  <bb 65> :
  _115 = *p;
  _116 = _115 == 110;
  _117 = *p;
  _118 = _117 == 98;
  _119 = _116 | _118;
  if (_119 != 0)
    goto <bb 64>; [INV]
  else
    goto <bb 84>; [INV]

  <bb 66> :
  _120 = *p;
  if (_120 == 95)
    goto <bb 67>; [INV]
  else
    goto <bb 75>; [INV]

  <bb 67> :
  _121 = p + 1;
  _122 = *_121;
  if (_122 != 95)
    goto <bb 68>; [INV]
  else
    goto <bb 75>; [INV]

  <bb 68> :
  k = 0;
  goto <bb 72>; [INV]

  <bb 69> :
  _123 = special[k][0];
  slen = strlen (_123);
  _124 = special[k][0];
  _125 = strncmp (p, _124, slen);
  if (_125 == 0)
    goto <bb 70>; [INV]
  else
    goto <bb 71>; [INV]

  <bb 70> :
  p = p + slen;
  _126 = special[k][1];
  slen = strlen (_126);
  _127 = special[k][1];
  memcpy (d, _127, slen);
  d = d + slen;
  goto <bb 73>; [INV]

  <bb 71> :
  k = k + 1;

  <bb 72> :
  _128 = special[k][0];
  if (_128 != 0B)
    goto <bb 69>; [INV]
  else
    goto <bb 73>; [INV]

  <bb 73> :
  _129 = special[k][0];
  if (_129 != 0B)
    goto <bb 91>; [INV]
  else
    goto <bb 74>; [INV]

  <bb 74> :
  // predicted unlikely by goto predictor.
  goto <bb 92>; [INV]

  <bb 75> :
  d.5_130 = d;
  d = d.5_130 + 1;
  *d.5_130 = 46;
  // predicted unlikely by continue predictor.
  goto <bb 7>; [INV]

  <bb 76> :
  _131 = p + 1;
  _132 = *_131;
  _133 = _132 == 66;
  _134 = p + 1;
  _135 = *_134;
  _136 = _135 == 69;
  _137 = _133 | _136;
  if (_137 != 0)
    goto <bb 77>; [INV]
  else
    goto <bb 83>; [INV]

  <bb 77> :
  p = p + 2;
  goto <bb 79>; [INV]

  <bb 78> :
  p = p + 1;

  <bb 79> :
  _138 = *p;
  _139 = (unsigned int) _138;
  _140 = _139 + 4294967248;
  if (_140 <= 9)
    goto <bb 78>; [INV]
  else
    goto <bb 80>; [INV]

  <bb 80> :
  _141 = *p;
  if (_141 == 115)
    goto <bb 81>; [INV]
  else
    goto <bb 82>; [INV]

  <bb 81> :
  _142 = p + 1;
  _143 = *_142;
  if (_143 == 0)
    goto <bb 91>; [INV]
  else
    goto <bb 82>; [INV]

  <bb 82> :
  // predicted unlikely by goto predictor.
  goto <bb 92>; [INV]

  <bb 83> :
  // predicted unlikely by goto predictor.
  goto <bb 92>; [INV]

  <bb 84> :
  _144 = *p;
  if (_144 == 46)
    goto <bb 85>; [INV]
  else
    goto <bb 89>; [INV]

  <bb 85> :
  _145 = p + 1;
  _146 = *_145;
  _147 = (unsigned int) _146;
  _148 = _147 + 4294967248;
  if (_148 <= 9)
    goto <bb 86>; [INV]
  else
    goto <bb 89>; [INV]

  <bb 86> :
  p = p + 2;
  goto <bb 88>; [INV]

  <bb 87> :
  p = p + 1;

  <bb 88> :
  _149 = *p;
  _150 = (unsigned int) _149;
  _151 = _150 + 4294967248;
  if (_151 <= 9)
    goto <bb 87>; [INV]
  else
    goto <bb 89>; [INV]

  <bb 89> :
  _152 = *p;
  if (_152 == 0)
    goto <bb 91>; [INV]
  else
    goto <bb 90>; [INV]

  <bb 90> :
  // predicted unlikely by goto predictor.
  goto <bb 92>; [INV]

  <bb 91> :
  *d = 0;
  D.3439 = demangled;
  goto <bb 96>; [INV]

  <bb 92> :
unknown:
  _153 = strlen (mangled);
  len0 = (int) _153;
  _154 = len0 + 3;
  _155 = (long unsigned int) _154;
  demangled = malloc (_155);
  _156 = *mangled;
  if (_156 == 60)
    goto <bb 93>; [INV]
  else
    goto <bb 94>; [INV]

  <bb 93> :
  strcpy (demangled, mangled);
  goto <bb 95>; [INV]

  <bb 94> :
  sprintf (demangled, "<%s>", mangled);

  <bb 95> :
  D.3439 = demangled;

  <bb 96> :
  return D.3439;

}



;; Function cplus_demangle (cplus_demangle, funcdef_no=33, decl_uid=3332, cgraph_uid=34, symbol_order=38)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7
;; 2 succs { 3 4 }
;; 3 succs { 7 }
;; 4 succs { 5 6 }
;; 5 succs { 7 }
;; 6 succs { 7 }
;; 7 succs { 1 }
char * cplus_demangle (const char * mangled)
{
  char * D.3446;

  <bb 2> :
  _1 = rand ();
  _2 = _1 % 2;
  if (_2 == 1)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  D.3446 = strdup (mangled);
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 7>; [INV]

  <bb 4> :
  _3 = rand ();
  _4 = _3 % 2;
  if (_4 == 1)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  D.3446 = ada_demangle (mangled);
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 7>; [INV]

  <bb 6> :
  D.3446 = 0B;

  <bb 7> :
  return D.3446;

}



;; Function demangle_template_value_parm (demangle_template_value_parm, funcdef_no=34, decl_uid=3337, cgraph_uid=35, symbol_order=39)

Merging blocks 6 and 7
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6
;; 2 succs { 3 6 }
;; 3 succs { 4 5 }
;; 4 succs { 6 }
;; 5 succs { 6 }
;; 6 succs { 1 }
void demangle_template_value_parm (const char * * mangled, struct string * s)
{
  char * q;
  char * p;
  int symbol_len;

  <bb 2> :
  symbol_len = 3;
  _1 = rand ();
  _2 = _1 % 2;
  if (_2 == 1)
    goto <bb 3>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 3> :
  _3 = symbol_len + 1;
  _4 = (long unsigned int) _3;
  p = malloc (_4);
  _5 = (long unsigned int) symbol_len;
  _6 = *mangled;
  strncpy (p, _6, _5);
  _7 = (sizetype) symbol_len;
  _8 = p + _7;
  *_8 = 0;
  q = cplus_demangle (p);
  if (q != 0B)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  string_append (s, q);
  free (q);
  goto <bb 6>; [INV]

  <bb 5> :
  string_append (s, p);
  free (p);

  <bb 6> :
  _9 = *mangled;
  _10 = (sizetype) symbol_len;
  _11 = _9 + _10;
  *mangled = _11;
  return;

}



;; Function string_append (string_append, funcdef_no=31, decl_uid=3261, cgraph_uid=32, symbol_order=36)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
void string_append (struct string * p, const char * s)
{
  <bb 2> :
  _1 = MEM[(int *)s];
  printf ("%d\n", _1);
  return;

}



;; Function main (main, funcdef_no=35, decl_uid=3343, cgraph_uid=36, symbol_order=40)

Merging blocks 2 and 3
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
int main ()
{
  const char * mangled;
  struct string s;
  char * p;
  time_t t;
  int D.3456;

  <bb 2> :
  mangled = "123456";
  _1 = time (&t);
  _2 = (unsigned int) _1;
  srand (_2);
  string_init (&s);
  demangle_template_value_parm (&mangled, &s);
  t = {CLOBBER};
  s = {CLOBBER};
  mangled = {CLOBBER};
  D.3456 = 0;
  return D.3456;

}



;; Function string_init (string_init, funcdef_no=30, decl_uid=3257, cgraph_uid=31, symbol_order=35)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
void string_init (struct string * s)
{
  <bb 2> :
  s->e = 0B;
  _1 = s->e;
  s->p = _1;
  _2 = s->p;
  s->b = _2;
  return;

}


