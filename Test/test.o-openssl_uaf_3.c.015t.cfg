
;; Function ssl3_release_read_buffer (ssl3_release_read_buffer, funcdef_no=24, decl_uid=3584, cgraph_uid=25, symbol_order=24)

Merging blocks 4 and 5
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4
;; 2 succs { 3 4 }
;; 3 succs { 4 }
;; 4 succs { 1 }
int ssl3_release_read_buffer (struct SSL * s)
{
  int D.3612;

  <bb 2> :
  _1 = s->s3;
  _2 = _1->rbuf.buf;
  if (_2 != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  _3 = s->s3;
  _4 = _3->rbuf.buf;
  _5 = s->s3;
  _6 = _5->rbuf.len;
  _7 = s->ctx;
  freelist_insert (_7, 1, _6, _4);
  _8 = s->s3;
  _8->rbuf.buf = 0B;

  <bb 4> :
  D.3612 = 1;
  return D.3612;

}



;; Function freelist_insert (freelist_insert, funcdef_no=23, decl_uid=3579, cgraph_uid=24, symbol_order=23)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12
;; 2 succs { 3 4 }
;; 3 succs { 5 }
;; 4 succs { 5 }
;; 5 succs { 6 10 }
;; 6 succs { 8 7 }
;; 7 succs { 8 10 }
;; 8 succs { 9 10 }
;; 9 succs { 10 }
;; 10 succs { 11 12 }
;; 11 succs { 12 }
;; 12 succs { 1 }
void freelist_insert (struct SSL_CTX * ctx, int for_read, size_t sz, void * mem)
{
  struct SSL3_BUF_FREELIST_ENTRY * ent;
  struct SSL3_BUF_FREELIST * list;
  struct ssl3_buf_freelist_st * iftmp.0;

  <bb 2> :
  if (for_read != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  iftmp.0 = ctx->rbuf_freelist;
  goto <bb 5>; [INV]

  <bb 4> :
  iftmp.0 = ctx->wbuf_freelist;

  <bb 5> :
  list = iftmp.0;
  if (list != 0B)
    goto <bb 6>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 6> :
  _1 = list->chunklen;
  if (sz == _1)
    goto <bb 8>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  _2 = list->chunklen;
  if (_2 == 0)
    goto <bb 8>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 8> :
  if (sz > 7)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  list->chunklen = sz;
  ent = mem;
  _3 = list->head;
  ent->next = _3;
  list->head = ent;
  _4 = list->len;
  _5 = _4 + 1;
  list->len = _5;
  mem = 0B;

  <bb 10> :
  if (mem != 0B)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  free (mem);

  <bb 12> :
  return;

}



;; Function ssl3_setup_read_buffer (ssl3_setup_read_buffer, funcdef_no=25, decl_uid=3587, cgraph_uid=26, symbol_order=25)

Merging blocks 4 and 7
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7
;; 2 succs { 3 6 }
;; 3 succs { 4 5 }
;; 4 succs { 7 }
;; 5 succs { 6 }
;; 6 succs { 7 }
;; 7 succs { 1 }
int ssl3_setup_read_buffer (struct SSL * s)
{
  size_t headerlen;
  size_t align;
  size_t len;
  unsigned char * p;
  int D.3631;

  <bb 2> :
  align = 0;
  _1 = s->s3;
  _2 = _1->rbuf.buf;
  if (_2 == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 3> :
  _3 = headerlen + align;
  len = _3 + 16704;
  _4 = (int) len;
  _5 = s->ctx;
  p = freelist_extract (_5, 1, _4);
  if (p == 0B)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  // predicted unlikely by goto predictor.
  D.3631 = 0;
  goto <bb 7>; [INV]

  <bb 5> :
  _6 = s->s3;
  _6->rbuf.buf = p;
  _7 = s->s3;
  _7->rbuf.len = len;

  <bb 6> :
  _8 = s->s3;
  _9 = _8->rbuf.buf;
  s->packet = _9;
  D.3631 = 1;

  <bb 7> :
  return D.3631;

}



;; Function freelist_extract (freelist_extract, funcdef_no=22, decl_uid=3570, cgraph_uid=23, symbol_order=22)

Merging blocks 13 and 14
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13
;; 2 succs { 3 4 }
;; 3 succs { 5 }
;; 4 succs { 5 }
;; 5 succs { 6 8 }
;; 6 succs { 7 8 }
;; 7 succs { 8 }
;; 8 succs { 9 11 }
;; 9 succs { 10 11 }
;; 10 succs { 11 }
;; 11 succs { 12 13 }
;; 12 succs { 13 }
;; 13 succs { 1 }
void * freelist_extract (struct SSL_CTX * ctx, int for_read, int sz)
{
  void * result;
  struct SSL3_BUF_FREELIST_ENTRY * ent;
  struct SSL3_BUF_FREELIST * list;
  void * D.3647;
  struct ssl3_buf_freelist_st * iftmp.1;

  <bb 2> :
  ent = 0B;
  result = 0B;
  if (for_read != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  iftmp.1 = ctx->rbuf_freelist;
  goto <bb 5>; [INV]

  <bb 4> :
  iftmp.1 = ctx->wbuf_freelist;

  <bb 5> :
  list = iftmp.1;
  if (list != 0B)
    goto <bb 6>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 6> :
  _1 = list->chunklen;
  _2 = (int) _1;
  if (sz == _2)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  ent = list->head;

  <bb 8> :
  if (ent != 0B)
    goto <bb 9>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 9> :
  _3 = ent->next;
  list->head = _3;
  result = ent;
  _4 = list->len;
  _5 = _4 + 4294967295;
  list->len = _5;
  _6 = list->len;
  if (_6 == 0)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  list->chunklen = 0;

  <bb 11> :
  if (result == 0B)
    goto <bb 12>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 12> :
  _7 = (long unsigned int) sz;
  result = malloc (_7);

  <bb 13> :
  D.3647 = result;
  return D.3647;

}



;; Function ssl3_read_bytes (ssl3_read_bytes, funcdef_no=26, decl_uid=3599, cgraph_uid=27, symbol_order=26)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13
;; 2 succs { 3 5 }
;; 3 succs { 4 5 }
;; 4 succs { 13 }
;; 5 succs { 6 7 }
;; 6 succs { 13 }
;; 7 succs { 8 9 }
;; 8 succs { 13 }
;; 9 succs { 10 12 }
;; 10 succs { 11 12 }
;; 11 succs { 12 }
;; 12 succs { 13 }
;; 13 succs { 1 }
int ssl3_read_bytes (struct SSL * s, int type, unsigned char * buf, int len, int peek)
{
  unsigned int n;
  int ret;
  int j;
  int i;
  int al;
  int D.3653;

  <bb 2> :
  _1 = s->s3;
  _2 = _1->rbuf.buf;
  if (_2 == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 3> :
  _3 = ssl3_setup_read_buffer (s);
  if (_3 == 0)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  D.3653 = -1;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 13>; [INV]

  <bb 5> :
  _4 = s->shutdown;
  _5 = _4 & 2;
  if (_5 != 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  s->rwstate = 1;
  D.3653 = 0;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 13>; [INV]

  <bb 7> :
  if (len <= 0)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  D.3653 = len;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 13>; [INV]

  <bb 9> :
  n = (unsigned int) len;
  if (peek == 0)
    goto <bb 10>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 10> :
  s->rstate = 240;
  _6 = s->mode;
  _7 = _6 & 16;
  if (_7 != 0)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  ssl3_release_read_buffer (s);

  <bb 12> :
  D.3653 = (int) n;

  <bb 13> :
  return D.3653;

}



;; Function main (main, funcdef_no=27, decl_uid=3606, cgraph_uid=28, symbol_order=27)

Removing basic block 5
Merging blocks 4 and 6
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4
;; 2 succs { 3 4 }
;; 3 succs { 4 }
;; 4 succs { 1 }
int main ()
{
  struct SSL * s;
  int D.3665;

  <bb 2> :
  s = malloc (48);
  _1 = malloc (24);
  s->s3 = _1;
  ssl3_read_bytes (s, 0, "buf", 1, 0);
  _2 = s->s3;
  _3 = _2->rbuf.left;
  if (_3 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  _4 = s->packet;
  printf ("%d\n", _4);

  <bb 4> :
  _5 = s->s3;
  _6 = _5->rbuf.buf;
  free (_6);
  _7 = s->s3;
  free (_7);
  free (s);
  D.3665 = 0;
  return D.3665;

}


