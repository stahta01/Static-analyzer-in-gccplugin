
;; Function discard_cleanups (discard_cleanups, funcdef_no=22, decl_uid=3018, cgraph_uid=23, symbol_order=27)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
void discard_cleanups (struct cleanup * old_chain)
{
  <bb 2> :
  discard_my_cleanups (&cleanup_chain, old_chain);
  return;

}



;; Function discard_final_cleanups (discard_final_cleanups, funcdef_no=23, decl_uid=3023, cgraph_uid=24, symbol_order=28)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
void discard_final_cleanups (struct cleanup * old_chain)
{
  <bb 2> :
  discard_my_cleanups (&final_cleanup_chain, old_chain);
  return;

}



;; Function discard_my_cleanups (discard_my_cleanups, funcdef_no=24, decl_uid=3021, cgraph_uid=25, symbol_order=29)

;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7
;;
;; Loop 1
;;  header 6, latch 5
;;  depth 1, outer 0
;;  nodes: 6 5 3 4
;; 2 succs { 6 }
;; 3 succs { 4 5 }
;; 4 succs { 5 }
;; 5 succs { 6 }
;; 6 succs { 3 7 }
;; 7 succs { 1 }
void discard_my_cleanups (struct cleanup * * pmy_chain, struct cleanup * old_chain)
{
  struct cleanup * ptr;

  <bb 2> :
  goto <bb 6>; [INV]

  <bb 3> :
  _1 = ptr->next;
  *pmy_chain = _1;
  _2 = ptr->free_arg;
  if (_2 != 0B)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  _3 = ptr->free_arg;
  _4 = ptr->arg;
  _3 (_4);

  <bb 5> :
  free (ptr);

  <bb 6> :
  ptr = *pmy_chain;
  if (ptr != old_chain)
    goto <bb 3>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  _5 = ptr->arg;
  printf ("freearg: %x\n", _5);
  return;

}



;; Function do_cleanups (do_cleanups, funcdef_no=26, decl_uid=3028, cgraph_uid=27, symbol_order=31)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
void do_cleanups (struct cleanup * old_chain)
{
  <bb 2> :
  do_my_cleanups (&cleanup_chain, old_chain);
  return;

}



;; Function do_my_cleanups (do_my_cleanups, funcdef_no=25, decl_uid=3026, cgraph_uid=26, symbol_order=30)

;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7
;;
;; Loop 1
;;  header 6, latch 5
;;  depth 1, outer 0
;;  nodes: 6 5 3 4
;; 2 succs { 6 }
;; 3 succs { 4 5 }
;; 4 succs { 5 }
;; 5 succs { 6 }
;; 6 succs { 3 7 }
;; 7 succs { 1 }
void do_my_cleanups (struct cleanup * * pmy_chain, struct cleanup * old_chain)
{
  struct cleanup * ptr;

  <bb 2> :
  goto <bb 6>; [INV]

  <bb 3> :
  _1 = ptr->next;
  *pmy_chain = _1;
  _2 = ptr->function;
  _3 = ptr->arg;
  _2 (_3);
  __builtin_puts (&"cleanup!!!!! ========="[0]);
  _4 = ptr->arg;
  printf ("%x\n", _4);
  _5 = ptr->free_arg;
  if (_5 != 0B)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  _6 = ptr->free_arg;
  _7 = ptr->arg;
  _6 (_7);

  <bb 5> :
  free (ptr);

  <bb 6> :
  ptr = *pmy_chain;
  if (ptr != old_chain)
    goto <bb 3>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  return;

}



;; Function make_cleanup (make_cleanup, funcdef_no=29, decl_uid=3041, cgraph_uid=30, symbol_order=34)

Merging blocks 2 and 3
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
struct cleanup * make_cleanup (void (*<T59c>) (void *) function, void * arg)
{
  struct cleanup * D.3368;

  <bb 2> :
  D.3368 = make_my_cleanup (&cleanup_chain, function, arg);
  return D.3368;

}



;; Function make_my_cleanup (make_my_cleanup, funcdef_no=28, decl_uid=3038, cgraph_uid=29, symbol_order=33)

Merging blocks 2 and 3
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
struct cleanup * make_my_cleanup (struct cleanup * * pmy_chain, void (*<T59c>) (void *) function, void * arg)
{
  struct cleanup * D.3370;

  <bb 2> :
  D.3370 = make_my_cleanup2 (pmy_chain, function, arg, 0B);
  return D.3370;

}



;; Function make_my_cleanup2 (make_my_cleanup2, funcdef_no=27, decl_uid=3034, cgraph_uid=28, symbol_order=32)

Merging blocks 4 and 5
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4
;; 2 succs { 3 4 }
;; 3 succs { }
;; 4 succs { 1 }
struct cleanup * make_my_cleanup2 (struct cleanup * * pmy_chain, void (*<T59c>) (void *) function, void * arg, void (*<Tee>) (void *) free_arg)
{
  struct cleanup * old_chain;
  struct cleanup * new;
  struct cleanup * D.3374;

  <bb 2> :
  new = malloc (32);
  old_chain = *pmy_chain;
  _1 = *pmy_chain;
  new->next = _1;
  new->function = function;
  new->free_arg = free_arg;
  new->arg = arg;
  *pmy_chain = new;
  if (old_chain == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  exit (1);

  <bb 4> :
  D.3374 = old_chain;
  return D.3374;

}



;; Function bfd_generic_archive_p (bfd_generic_archive_p, funcdef_no=30, decl_uid=3275, cgraph_uid=31, symbol_order=35)

Merging blocks 11 and 12
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11
;; 2 succs { 3 6 }
;; 3 succs { 4 5 }
;; 4 succs { 5 }
;; 5 succs { 11 }
;; 6 succs { 7 10 }
;; 7 succs { 8 10 }
;; 8 succs { 9 10 }
;; 9 succs { 11 }
;; 10 succs { 11 }
;; 11 succs { 1 }
const struct bfd_target * bfd_generic_archive_p (struct bfd * abfd)
{
  bfd_size_type amt;
  char armag[9];
  struct artdata * tdata_hold;
  const struct bfd_target * D.3380;

  <bb 2> :
  _1 = bfd_bread (&armag, 8, abfd);
  if (_1 != 8)
    goto <bb 3>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 3> :
  _2 = bfd_get_error ();
  if (_2 != 1)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  bfd_set_error (3);

  <bb 5> :
  D.3380 = 0B;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 11>; [INV]

  <bb 6> :
  _3 = strncmp (&armag, "!<thin>\n", 8);
  _4 = _3 == 0;
  abfd->is_thin_archive = _4;
  _5 = strncmp (&armag, "!<arch>\n", 8);
  if (_5 != 0)
    goto <bb 7>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 7> :
  _6 = strncmp (&armag, "!<bout>\n", 8);
  if (_6 != 0)
    goto <bb 8>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 8> :
  _7 = BIT_FIELD_REF <*abfd, 8, 224>;
  _8 = _7 & 2;
  if (_8 == 0)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  D.3380 = 0B;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 11>; [INV]

  <bb 10> :
  D.3380 = abfd->xvec;

  <bb 11> :
  armag = {CLOBBER};
  return D.3380;

}



;; Function bfd_fopen (bfd_fopen, funcdef_no=31, decl_uid=3292, cgraph_uid=32, symbol_order=36)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9
;; 2 succs { 3 4 }
;; 3 succs { 9 }
;; 4 succs { 5 8 }
;; 5 succs { 6 7 }
;; 6 succs { 7 }
;; 7 succs { 9 }
;; 8 succs { 9 }
;; 9 succs { 1 }
struct bfd * bfd_fopen (const char * filename, const char * target, const char * mode, int fd)
{
  const struct bfd_target * target_vec;
  struct bfd * nbfd;
  struct bfd * D.3391;

  <bb 2> :
  _1 = _bfd_new_bfd ();
  _2 = (long int) _1;
  nbfd = (struct bfd *) _2;
  if (nbfd == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  D.3391 = 0B;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 9>; [INV]

  <bb 4> :
  _3 = bfd_find_target (target, nbfd);
  _4 = (long int) _3;
  target_vec = (const struct bfd_target *) _4;
  if (target_vec == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 5> :
  if (fd != -1)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  close (fd);

  <bb 7> :
  _bfd_delete_bfd (nbfd);
  D.3391 = 0B;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 9>; [INV]

  <bb 8> :
  _5 = strdup (filename);
  nbfd->filename = _5;
  D.3391 = nbfd;

  <bb 9> :
  return D.3391;

}



;; Function bfd_openr (bfd_openr, funcdef_no=32, decl_uid=3307, cgraph_uid=33, symbol_order=37)

Merging blocks 2 and 3
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
struct bfd * bfd_openr (const char * filename, const char * target)
{
  struct bfd * D.3397;

  <bb 2> :
  D.3397 = bfd_fopen (filename, target, "r", -1);
  return D.3397;

}



;; Function _bfd_archive_close_and_cleanup (_bfd_archive_close_and_cleanup, funcdef_no=33, decl_uid=3310, cgraph_uid=34, symbol_order=38)

Merging blocks 7 and 8
;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7
;;
;; Loop 1
;;  header 6, latch 5
;;  depth 1, outer 0
;;  nodes: 6 5
;; 2 succs { 3 7 }
;; 3 succs { 4 7 }
;; 4 succs { 6 }
;; 5 succs { 6 }
;; 6 succs { 5 7 }
;; 7 succs { 1 }
bfd_boolean _bfd_archive_close_and_cleanup (struct bfd * abfd)
{
  struct bfd * next;
  struct bfd * nbfd;
  bfd_boolean D.3403;

  <bb 2> :
  _1 = bfd_read_p (abfd);
  if (_1 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 3> :
  _2 = abfd->format;
  if (_2 == 2)
    goto <bb 4>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 4> :
  nbfd = abfd->nested_archives;
  goto <bb 6>; [INV]

  <bb 5> :
  next = nbfd->archive_next;
  bfd_close (nbfd);
  nbfd = next;

  <bb 6> :
  if (nbfd != 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  D.3403 = 1;
  return D.3403;

}



;; Function main (main, funcdef_no=36, decl_uid=3343, cgraph_uid=37, symbol_order=41)

Removing basic block 18
Merging blocks 17 and 19
;; 3 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17
;;
;; Loop 2
;;  header 14, latch 13
;;  depth 1, outer 0
;;  nodes: 14 13
;;
;; Loop 1
;;  header 8, latch 7
;;  depth 1, outer 0
;;  nodes: 8 7
;; 2 succs { 3 4 }
;; 3 succs { }
;; 4 succs { 5 6 }
;; 5 succs { }
;; 6 succs { 8 }
;; 7 succs { 8 }
;; 8 succs { 7 9 }
;; 9 succs { 10 11 }
;; 10 succs { }
;; 11 succs { 12 15 }
;; 12 succs { 14 }
;; 13 succs { 14 }
;; 14 succs { 13 15 }
;; 15 succs { 16 17 }
;; 16 succs { }
;; 17 succs { 1 }
int main (int argc, char * * argv)
{
  struct bfd * next;
  int i;
  struct bfd * next;
  struct bfd * last;
  struct bfd * nbfd;
  struct bfd * archive;
  int D.3415;

  <bb 2> :
  if (argc != 2)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  printf ("usage: bfdtest1 <archive>%s", "");
  exit (1);

  <bb 4> :
  _1 = *argv;
  archive = bfd_openr (_1, 0B);
  if (archive == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  printf ("no such archive%s", "");
  exit (1);

  <bb 6> :
  i = 1;
  goto <bb 8>; [INV]

  <bb 7> :
  _2 = (long unsigned int) i;
  _3 = _2 * 8;
  _4 = argv + _3;
  _5 = *_4;
  nbfd = find_nested_archive (_5, archive);
  _6 = MEM[(int *)nbfd];
  printf ("%d\n", _6);
  i = i + 1;

  <bb 8> :
  if (i < argc)
    goto <bb 7>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 9> :
  _7 = bfd_check_format (archive, 2);
  if (_7 == 0)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  bfd_close (archive);
  printf ("bfd_check_format%s", "");
  exit (1);

  <bb 11> :
  _bfd_archive_close_and_cleanup (archive);
  bfd_generic_archive_p (archive);
  _8 = archive->format;
  if (_8 != 0)
    goto <bb 12>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 12> :
  nbfd = archive->nested_archives;
  goto <bb 14>; [INV]

  <bb 13> :
  _9 = MEM[(int *)nbfd];
  printf ("%d\n", _9);
  nbfd = nbfd->archive_next;

  <bb 14> :
  if (nbfd != 0B)
    goto <bb 13>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 15> :
  _10 = bfd_close (archive);
  if (_10 == 0)
    goto <bb 16>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 16> :
  printf ("bfd_close%s", "");
  exit (1);

  <bb 17> :
  D.3415 = 0;
  return D.3415;

}



;; Function find_nested_archive (find_nested_archive, funcdef_no=35, decl_uid=3330, cgraph_uid=36, symbol_order=40)

;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12
;;
;; Loop 1
;;  header 8, latch 7
;;  depth 1, outer 0
;;  nodes: 8 7 5
;; 2 succs { 3 4 }
;; 3 succs { 12 }
;; 4 succs { 8 }
;; 5 succs { 6 7 }
;; 6 succs { 12 }
;; 7 succs { 8 }
;; 8 succs { 5 9 }
;; 9 succs { 10 11 }
;; 10 succs { 11 }
;; 11 succs { 12 }
;; 12 succs { 1 }
struct bfd * find_nested_archive (const char * filename, struct bfd * arch_bfd)
{
  struct bfd * abfd;
  struct bfd * D.3419;

  <bb 2> :
  _1 = arch_bfd->filename;
  _2 = filename_cmp (filename, _1);
  if (_2 == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  bfd_set_error (10);
  D.3419 = 0B;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 12>; [INV]

  <bb 4> :
  abfd = arch_bfd->nested_archives;
  goto <bb 8>; [INV]

  <bb 5> :
  _3 = abfd->filename;
  _4 = filename_cmp (filename, _3);
  if (_4 == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  D.3419 = abfd;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 12>; [INV]

  <bb 7> :
  abfd = abfd->archive_next;

  <bb 8> :
  if (abfd != 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 9> :
  abfd = open_nested_file (filename, arch_bfd);
  if (abfd != 0B)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  _5 = arch_bfd->nested_archives;
  abfd->archive_next = _5;
  arch_bfd->nested_archives = abfd;

  <bb 11> :
  D.3419 = abfd;

  <bb 12> :
  return D.3419;

}



;; Function open_nested_file (open_nested_file, funcdef_no=34, decl_uid=3324, cgraph_uid=35, symbol_order=39)

Merging blocks 6 and 7
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6
;; 2 succs { 3 4 }
;; 3 succs { 4 }
;; 4 succs { 5 6 }
;; 5 succs { 6 }
;; 6 succs { 1 }
struct bfd * open_nested_file (const char * filename, struct bfd * archive)
{
  struct bfd * n_bfd;
  const char * target;
  struct bfd * D.3429;

  <bb 2> :
  target = 0B;
  _1 = BIT_FIELD_REF <*archive, 8, 512>;
  _2 = _1 & 1;
  if (_2 == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  _3 = archive->xvec;
  target = _3->name;

  <bb 4> :
  n_bfd = bfd_openr (filename, target);
  if (n_bfd != 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  n_bfd->my_archive = archive;

  <bb 6> :
  D.3429 = n_bfd;
  return D.3429;

}


