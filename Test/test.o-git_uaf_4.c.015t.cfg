
;; Function xrealloc (xrealloc, funcdef_no=26, decl_uid=3272, cgraph_uid=27, symbol_order=27)

Merging blocks 9 and 10
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9
;; 2 succs { 3 4 }
;; 3 succs { 4 }
;; 4 succs { 5 9 }
;; 5 succs { 6 7 }
;; 6 succs { 7 }
;; 7 succs { 8 9 }
;; 8 succs { }
;; 9 succs { 1 }
void * xrealloc (void * ptr, size_t size)
{
  void * ret;
  void * D.3470;

  <bb 2> :
  ret = realloc (ptr, size);
  _1 = ret == 0B;
  _2 = size == 0;
  _3 = _1 & _2;
  if (_3 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  ret = realloc (ptr, 1);

  <bb 4> :
  if (ret == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 5> :
  ret = realloc (ptr, size);
  _4 = ret == 0B;
  _5 = size == 0;
  _6 = _4 & _5;
  if (_6 != 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  ret = realloc (ptr, 1);

  <bb 7> :
  if (ret == 0B)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  printf ("Out of memory, realloc failed%s", "");
  exit (1);

  <bb 9> :
  D.3470 = ret;
  return D.3470;

}



;; Function hashmap_free (hashmap_free, funcdef_no=27, decl_uid=3299, cgraph_uid=28, symbol_order=28)

;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11
;;
;; Loop 1
;;  header 8, latch 7
;;  depth 1, outer 0
;;  nodes: 8 7
;; 2 succs { 4 3 }
;; 3 succs { 4 5 }
;; 4 succs { 11 }
;; 5 succs { 6 10 }
;; 6 succs { 8 }
;; 7 succs { 8 }
;; 8 succs { 7 9 }
;; 9 succs { 10 }
;; 10 succs { 11 }
;; 11 succs { 1 }
void hashmap_free (struct hashmap * map, int free_entries)
{
  struct hashmap_entry * e;
  struct hashmap_iter iter;

  <bb 2> :
  if (map == 0B)
    goto <bb 4>; [INV]
  else
    goto <bb 3>; [INV]

  <bb 3> :
  _1 = map->table;
  if (_1 == 0B)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 11>; [INV]

  <bb 5> :
  if (free_entries != 0)
    goto <bb 6>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 6> :
  hashmap_iter_init (map, &iter);
  goto <bb 8>; [INV]

  <bb 7> :
  free (e);

  <bb 8> :
  _2 = hashmap_iter_next (&iter);
  _3 = (long int) _2;
  e = (struct hashmap_entry *) _3;
  if (e != 0B)
    goto <bb 7>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 9> :
  iter = {CLOBBER};

  <bb 10> :
  _4 = map->table;
  free (_4);
  memset (map, 0, 32);

  <bb 11> :
  return;

}



;; Function free_name_hash (free_name_hash, funcdef_no=28, decl_uid=3312, cgraph_uid=29, symbol_order=29)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5
;; 2 succs { 3 4 }
;; 3 succs { 5 }
;; 4 succs { 5 }
;; 5 succs { 1 }
void free_name_hash (struct index_state * istate)
{
  <bb 2> :
  _1 = BIT_FIELD_REF <*istate, 8, 384>;
  _2 = _1 & 1;
  if (_2 == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 5>; [INV]

  <bb 4> :
  istate->name_hash_initialized = 0;
  _3 = &istate->name_hash;
  hashmap_free (_3, 0);
  _4 = &istate->dir_hash;
  hashmap_free (_4, 1);

  <bb 5> :
  return;

}



;; Function index_dir_exists (index_dir_exists, funcdef_no=32, decl_uid=3350, cgraph_uid=33, symbol_order=33)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6
;; 2 succs { 3 5 }
;; 3 succs { 4 5 }
;; 4 succs { 6 }
;; 5 succs { 6 }
;; 6 succs { 1 }
struct cache_entry * index_dir_exists (struct index_state * istate, const char * name, int namelen)
{
  struct dir_entry * dir;
  struct cache_entry * ce;
  struct cache_entry * D.3485;

  <bb 2> :
  lazy_init_name_hash (istate);
  namelen.0_1 = (unsigned int) namelen;
  dir = find_dir_entry (istate, name, namelen.0_1);
  if (dir != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 3> :
  _2 = dir->nr;
  if (_2 != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  D.3485 = dir->ce;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 6>; [INV]

  <bb 5> :
  D.3485 = 0B;

  <bb 6> :
  return D.3485;

}



;; Function find_dir_entry (find_dir_entry, funcdef_no=30, decl_uid=3323, cgraph_uid=31, symbol_order=31)

Merging blocks 2 and 3
Merging blocks 2 and 4
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
struct dir_entry * find_dir_entry (struct index_state * istate, const char * name, unsigned int namelen)
{
  struct dir_entry key;
  struct dir_entry * D.3487;

  <bb 2> :
  _1 = memihash (name, namelen);
  hashmap_entry_init (&key, _1);
  key.namelen = namelen;
  _2 = &istate->dir_hash;
  _3 = hashmap_get (_2, &key, name);
  _4 = (long int) _3;
  D.3487 = (struct dir_entry *) _4;
  key = {CLOBBER};
  return D.3487;

}



;; Function add_name_hash (add_name_hash, funcdef_no=36, decl_uid=3381, cgraph_uid=37, symbol_order=37)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4
;; 2 succs { 3 4 }
;; 3 succs { 4 }
;; 4 succs { 1 }
void add_name_hash (struct index_state * istate, struct cache_entry * ce)
{
  <bb 2> :
  _1 = BIT_FIELD_REF <*istate, 8, 384>;
  _2 = _1 & 1;
  if (_2 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  hash_index_entry (istate, ce);

  <bb 4> :
  return;

}



;; Function hash_index_entry (hash_index_entry, funcdef_no=34, decl_uid=3368, cgraph_uid=35, symbol_order=35)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6
;; 2 succs { 3 4 }
;; 3 succs { 6 }
;; 4 succs { 5 6 }
;; 5 succs { 6 }
;; 6 succs { 1 }
void hash_index_entry (struct index_state * istate, struct cache_entry * ce)
{
  <bb 2> :
  _1 = ce->ce_flags;
  _2 = _1 & 1048576;
  if (_2 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 6>; [INV]

  <bb 4> :
  _3 = ce->ce_flags;
  _4 = _3 | 1048576;
  ce->ce_flags = _4;
  _5 = ce_namelen (ce);
  _6 = &ce->name;
  _7 = memihash (_6, _5);
  hashmap_entry_init (ce, _7);
  _8 = &istate->name_hash;
  hashmap_add (_8, ce);
  ignore_case.1_9 = ignore_case;
  if (ignore_case.1_9 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  add_dir_entry (istate, ce);

  <bb 6> :
  return;

}



;; Function add_dir_entry (add_dir_entry, funcdef_no=33, decl_uid=3358, cgraph_uid=34, symbol_order=34)

;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6
;;
;; Loop 1
;;  header 4, latch 3
;;  depth 1, outer 0
;;  nodes: 4 3 5
;; 2 succs { 4 }
;; 3 succs { 4 }
;; 4 succs { 5 6 }
;; 5 succs { 3 6 }
;; 6 succs { 1 }
void add_dir_entry (struct index_state * istate, struct cache_entry * ce)
{
  struct dir_entry * dir;

  <bb 2> :
  _1 = ce_namelen (ce);
  dir = hash_dir_entry (istate, ce, _1);
  goto <bb 4>; [INV]

  <bb 3> :
  dir = dir->parent;

  <bb 4> :
  if (dir != 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  _2 = dir->nr;
  _3 = _2;
  _4 = _3 + 1;
  dir->nr = _4;
  if (_3 == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 6> :
  return;

}



;; Function hash_dir_entry (hash_dir_entry, funcdef_no=31, decl_uid=3335, cgraph_uid=32, symbol_order=32)

;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11
;;
;; Loop 1
;;  header 4, latch 3
;;  depth 1, outer 0
;;  nodes: 4 3 5
;; 2 succs { 4 }
;; 3 succs { 4 }
;; 4 succs { 5 6 }
;; 5 succs { 3 6 }
;; 6 succs { 7 8 }
;; 7 succs { 11 }
;; 8 succs { 9 10 }
;; 9 succs { 10 }
;; 10 succs { 11 }
;; 11 succs { 1 }
struct dir_entry * hash_dir_entry (struct index_state * istate, struct cache_entry * ce, int namelen)
{
  struct dir_entry * dir;
  struct dir_entry * D.3501;

  <bb 2> :
  goto <bb 4>; [INV]

  <bb 3> :
  namelen = namelen + -1;

  <bb 4> :
  if (namelen > 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  _1 = namelen + -1;
  _2 = ce->name[_1];
  _3 = (int) _2;
  _4 = is_dir_sep (_3);
  if (_4 == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 6> :
  if (namelen <= 0)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  D.3501 = 0B;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 11>; [INV]

  <bb 8> :
  namelen = namelen + -1;
  namelen.2_5 = (unsigned int) namelen;
  _6 = &ce->name;
  dir = find_dir_entry (istate, _6, namelen.2_5);
  if (dir == 0B)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  dir = calloc (1, 24);
  _7 = &ce->name;
  _8 = memihash (_7, namelen);
  hashmap_entry_init (dir, _8);
  namelen.3_9 = (unsigned int) namelen;
  dir->namelen = namelen.3_9;
  dir->ce = ce;
  _10 = &istate->dir_hash;
  hashmap_add (_10, dir);
  _11 = hash_dir_entry (istate, ce, namelen);
  dir->parent = _11;

  <bb 10> :
  D.3501 = dir;

  <bb 11> :
  return D.3501;

}



;; Function add_to_index (add_to_index, funcdef_no=37, decl_uid=3387, cgraph_uid=38, symbol_order=38)

Removing basic block 9
Removing basic block 18
Removing basic block 36
;; 4 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39
;;
;; Loop 2
;;  header 22, multiple latches: 19 20 21
;;  depth 1, outer 0
;;  nodes: 22 19 20 21 18 17
;;
;; Loop 3
;;  header 18, latch 17
;;  depth 2, outer 2
;;  nodes: 18 17
;;
;; Loop 1
;;  header 10, latch 9
;;  depth 1, outer 0
;;  nodes: 10 9 11
;; 2 succs { 3 4 }
;; 3 succs { 5 }
;; 4 succs { 5 }
;; 5 succs { 6 8 }
;; 6 succs { 7 8 }
;; 7 succs { 39 }
;; 8 succs { 10 12 }
;; 9 succs { 10 }
;; 10 succs { 11 12 }
;; 11 succs { 9 12 }
;; 12 succs { 13 14 }
;; 13 succs { 15 }
;; 14 succs { 15 }
;; 15 succs { 16 23 }
;; 16 succs { 22 }
;; 17 succs { 18 }
;; 18 succs { 17 19 }
;; 19 succs { 20 22 }
;; 20 succs { 21 22 }
;; 21 succs { 22 }
;; 22 succs { 18 23 }
;; 23 succs { 24 29 }
;; 24 succs { 25 29 }
;; 25 succs { 26 29 }
;; 26 succs { 27 28 }
;; 27 succs { 28 }
;; 28 succs { 39 }
;; 29 succs { 30 33 }
;; 30 succs { 31 33 }
;; 31 succs { 32 33 }
;; 32 succs { 33 }
;; 33 succs { 36 34 }
;; 34 succs { 35 36 }
;; 35 succs { 39 }
;; 36 succs { 37 38 }
;; 37 succs { 38 }
;; 38 succs { 39 }
;; 39 succs { 1 }
int add_to_index (struct index_state * istate, const char * path, struct stat * st, int flags)
{
  struct cache_entry * foundce;
  const char * ptr;
  const char * startPtr;
  int add_option;
  int intent_only;
  int pretend;
  int verbose;
  unsigned int ce_option;
  struct cache_entry * alias;
  struct cache_entry * ce;
  mode_t st_mode;
  int was_same;
  int namelen;
  int size;
  int D.3514;
  unsigned int D.3509;
  int iftmp.4;

  <bb 2> :
  st_mode = st->st_mode;
  ce_option = 7;
  verbose = flags & 3;
  pretend = flags & 2;
  intent_only = flags & 16;
  if (intent_only != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  iftmp.4 = 19;
  goto <bb 5>; [INV]

  <bb 4> :
  iftmp.4 = 3;

  <bb 5> :
  add_option = iftmp.4;
  D.3509 = st_mode & 61440;
  _1 = D.3509 != 32768;
  _2 = D.3509 != 40960;
  _3 = _1 & _2;
  if (_3 != 0)
    goto <bb 6>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 6> :
  _4 = st_mode & 61440;
  if (_4 != 16384)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  D.3514 = error ("%s: can only add regular files, symbolic links or git-directories", path);
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 39>; [INV]

  <bb 8> :
  _5 = strlen (path);
  namelen = (int) _5;
  _6 = st_mode & 61440;
  if (_6 == 16384)
    goto <bb 10>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 9> :
  namelen = namelen + -1;

  <bb 10> :
  if (namelen != 0)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  _7 = (sizetype) namelen;
  _8 = _7 + 18446744073709551615;
  _9 = path + _8;
  _10 = *_9;
  if (_10 == 47)
    goto <bb 9>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 12> :
  size = cache_entry_size (namelen);
  _11 = (long unsigned int) size;
  ce = calloc (1, _11);
  _12 = (long unsigned int) namelen;
  _13 = &ce->name;
  memcpy (_13, path, _12);
  namelen.5_14 = (unsigned int) namelen;
  ce->ce_namelen = namelen.5_14;
  if (intent_only == 0)
    goto <bb 13>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 13> :
  fill_stat_cache_info (ce, st);
  goto <bb 15>; [INV]

  <bb 14> :
  _15 = ce->ce_flags;
  _16 = _15 | 536870912;
  ce->ce_flags = _16;

  <bb 15> :
  ignore_case.6_17 = ignore_case;
  if (ignore_case.6_17 != 0)
    goto <bb 16>; [INV]
  else
    goto <bb 23>; [INV]

  <bb 16> :
  startPtr = &ce->name;
  ptr = startPtr;
  goto <bb 22>; [INV]

  <bb 17> :
  ptr = ptr + 1;

  <bb 18> :
  _18 = *ptr;
  _19 = _18 != 0;
  _20 = *ptr;
  _21 = _20 != 47;
  _22 = _19 & _21;
  if (_22 != 0)
    goto <bb 17>; [INV]
  else
    goto <bb 19>; [INV]

  <bb 19> :
  _23 = *ptr;
  if (_23 == 47)
    goto <bb 20>; [INV]
  else
    goto <bb 22>; [INV]

  <bb 20> :
  ptr = ptr + 1;
  _24 = &ce->name;
  _25 = ptr - _24;
  _26 = (unsigned int) _25;
  _27 = _26 + 4294967295;
  _28 = (int) _27;
  _29 = &ce->name;
  foundce = index_dir_exists (istate, _29, _28);
  if (foundce != 0B)
    goto <bb 21>; [INV]
  else
    goto <bb 22>; [INV]

  <bb 21> :
  _30 = ptr - startPtr;
  _31 = (long unsigned int) _30;
  _32 = &foundce->name;
  _33 = &ce->name;
  _34 = startPtr - _33;
  _35 = (sizetype) _34;
  _36 = _32 + _35;
  memcpy (startPtr, _36, _31);
  startPtr = ptr;

  <bb 22> :
  _37 = *ptr;
  if (_37 != 0)
    goto <bb 18>; [INV]
  else
    goto <bb 23>; [INV]

  <bb 23> :
  ignore_case.7_38 = ignore_case;
  _39 = ce_namelen (ce);
  _40 = &ce->name;
  _41 = index_file_exists (istate, _40, _39, ignore_case.7_38);
  _42 = (long int) _41;
  alias = (struct cache_entry *) _42;
  if (alias != 0B)
    goto <bb 24>; [INV]
  else
    goto <bb 29>; [INV]

  <bb 24> :
  _43 = ce_stage (alias);
  if (_43 == 0)
    goto <bb 25>; [INV]
  else
    goto <bb 29>; [INV]

  <bb 25> :
  _44 = ie_match_stat (istate, alias, st, ce_option);
  if (_44 == 0)
    goto <bb 26>; [INV]
  else
    goto <bb 29>; [INV]

  <bb 26> :
  free (ce);
  _45 = alias->ce_mode;
  _46 = S_ISGITLINK (_45);
  if (_46 == 0)
    goto <bb 27>; [INV]
  else
    goto <bb 28>; [INV]

  <bb 27> :
  ce_mark_uptodate (alias);

  <bb 28> :
  _47 = alias->ce_flags;
  _48 = _47 | 524288;
  alias->ce_flags = _48;
  D.3514 = 0;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 39>; [INV]

  <bb 29> :
  ignore_case.8_49 = ignore_case;
  if (ignore_case.8_49 != 0)
    goto <bb 30>; [INV]
  else
    goto <bb 33>; [INV]

  <bb 30> :
  if (alias != 0B)
    goto <bb 31>; [INV]
  else
    goto <bb 33>; [INV]

  <bb 31> :
  _50 = different_name (ce, alias);
  if (_50 != 0)
    goto <bb 32>; [INV]
  else
    goto <bb 33>; [INV]

  <bb 32> :
  _51 = create_alias_ce (istate, ce, alias);
  _52 = (long int) _51;
  ce = (struct cache_entry *) _52;

  <bb 33> :
  _53 = ce->ce_flags;
  _54 = _53 | 524288;
  ce->ce_flags = _54;
  if (pretend != 0)
    goto <bb 36>; [INV]
  else
    goto <bb 34>; [INV]

  <bb 34> :
  _55 = add_index_entry (istate, ce, add_option);
  if (_55 != 0)
    goto <bb 35>; [INV]
  else
    goto <bb 36>; [INV]

  <bb 35> :
  D.3514 = error ("unable to add %s to index", path);
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 39>; [INV]

  <bb 36> :
  _56 = verbose != 0;
  _57 = was_same == 0;
  _58 = _56 & _57;
  if (_58 != 0)
    goto <bb 37>; [INV]
  else
    goto <bb 38>; [INV]

  <bb 37> :
  printf ("add \'%s\'\n", path);

  <bb 38> :
  D.3514 = 0;

  <bb 39> :
  return D.3514;

}



;; Function main (main, funcdef_no=39, decl_uid=3445, cgraph_uid=40, symbol_order=40)

Merging blocks 8 and 9
;; 3 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8
;;
;; Loop 2
;;  header 7, latch 6
;;  depth 1, outer 0
;;  nodes: 7 6
;;
;; Loop 1
;;  header 4, latch 3
;;  depth 1, outer 0
;;  nodes: 4 3
;; 2 succs { 4 }
;; 3 succs { 4 }
;; 4 succs { 3 5 }
;; 5 succs { 7 }
;; 6 succs { 7 }
;; 7 succs { 6 8 }
;; 8 succs { 1 }
int main (int argc, char * * argv)
{
  int i;
  int i;
  int flag;
  struct stat st;
  struct cache_entry * ce;
  struct index_state istate;
  int D.3549;

  <bb 2> :
  _1 = (long unsigned int) argc;
  _2 = calloc (_1, 8);
  istate.cache = _2;
  i = 0;
  goto <bb 4>; [INV]

  <bb 3> :
  ce = malloc (36);
  set_index_entry (&istate, i, ce);
  i = i + 1;

  <bb 4> :
  if (i < argc)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 5> :
  i = 0;
  goto <bb 7>; [INV]

  <bb 6> :
  _3 = istate.cache;
  _4 = (long unsigned int) i;
  _5 = _4 * 8;
  _6 = _3 + _5;
  _7 = *_6;
  free (_7);
  i = i + 1;

  <bb 7> :
  if (i < argc)
    goto <bb 6>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 8> :
  _8 = istate.cache;
  free (_8);
  add_to_index (&istate, "path", &st, flag);
  free_name_hash (&istate);
  istate = {CLOBBER};
  st = {CLOBBER};
  D.3549 = 0;
  return D.3549;

}



;; Function set_index_entry (set_index_entry, funcdef_no=38, decl_uid=3441, cgraph_uid=39, symbol_order=39)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
void set_index_entry (struct index_state * istate, int nr, struct cache_entry * ce)
{
  <bb 2> :
  _1 = istate->cache;
  _2 = (long unsigned int) nr;
  _3 = _2 * 8;
  _4 = _1 + _3;
  *_4 = ce;
  add_name_hash (istate, ce);
  return;

}


