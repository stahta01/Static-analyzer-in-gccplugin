
;; Function xrealloc (xrealloc, funcdef_no=26, decl_uid=3195, cgraph_uid=27, symbol_order=27)

Merging blocks 9 and 10
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9
;; 2 succs { 3 4 }
;; 3 succs { 4 }
;; 4 succs { 5 9 }
;; 5 succs { 6 7 }
;; 6 succs { 7 }
;; 7 succs { 8 9 }
;; 8 succs { }
;; 9 succs { 1 }
void * xrealloc (void * ptr, size_t size)
{
  void * ret;
  void * D.3358;

  <bb 2> :
  ret = realloc (ptr, size);
  _1 = ret == 0B;
  _2 = size == 0;
  _3 = _1 & _2;
  if (_3 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  ret = realloc (ptr, 1);

  <bb 4> :
  if (ret == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 5> :
  ret = realloc (ptr, size);
  _4 = ret == 0B;
  _5 = size == 0;
  _6 = _4 & _5;
  if (_6 != 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  ret = realloc (ptr, 1);

  <bb 7> :
  if (ret == 0B)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  printf ("Out of memory, realloc failed%s", "");
  exit (1);

  <bb 9> :
  D.3358 = ret;
  return D.3358;

}



;; Function pop_commit (pop_commit, funcdef_no=27, decl_uid=3199, cgraph_uid=28, symbol_order=28)

Merging blocks 7 and 8
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7
;; 2 succs { 3 4 }
;; 3 succs { 5 }
;; 4 succs { 5 }
;; 5 succs { 6 7 }
;; 6 succs { 7 }
;; 7 succs { 1 }
struct commit * pop_commit (struct commit_list * * stack)
{
  struct commit * item;
  struct commit_list * top;
  struct commit * D.3366;
  struct commit * iftmp.0;

  <bb 2> :
  top = *stack;
  if (top != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  iftmp.0 = top->item;
  goto <bb 5>; [INV]

  <bb 4> :
  iftmp.0 = 0B;

  <bb 5> :
  item = iftmp.0;
  if (top != 0B)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  _1 = top->next;
  *stack = _1;
  free (top);

  <bb 7> :
  D.3366 = item;
  return D.3366;

}



;; Function free_commit_list (free_commit_list, funcdef_no=28, decl_uid=3204, cgraph_uid=29, symbol_order=29)

;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5
;;
;; Loop 1
;;  header 4, latch 3
;;  depth 1, outer 0
;;  nodes: 4 3
;; 2 succs { 4 }
;; 3 succs { 4 }
;; 4 succs { 3 5 }
;; 5 succs { 1 }
void free_commit_list (struct commit_list * list)
{
  <bb 2> :
  goto <bb 4>; [INV]

  <bb 3> :
  pop_commit (&list);

  <bb 4> :
  list.1_1 = list;
  if (list.1_1 != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 5> :
  return;

}



;; Function commit_list_insert (commit_list_insert, funcdef_no=29, decl_uid=3211, cgraph_uid=30, symbol_order=30)

Merging blocks 2 and 3
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
struct commit_list * commit_list_insert (struct commit * item, struct commit_list * * list_p)
{
  struct commit_list * new_list;
  struct commit_list * D.3368;

  <bb 2> :
  new_list = malloc (16);
  new_list->item = item;
  _1 = *list_p;
  new_list->next = _1;
  *list_p = new_list;
  D.3368 = new_list;
  return D.3368;

}



;; Function find_bisection (find_bisection, funcdef_no=33, decl_uid=3321, cgraph_uid=34, symbol_order=34)

;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14
;;
;; Loop 1
;;  header 9, latch 8
;;  depth 1, outer 0
;;  nodes: 9 8 4 7 5 6 3
;; 2 succs { 9 }
;; 3 succs { 4 5 }
;; 4 succs { 8 }
;; 5 succs { 6 7 }
;; 6 succs { 7 }
;; 7 succs { 8 }
;; 8 succs { 9 }
;; 9 succs { 3 10 }
;; 10 succs { 11 14 }
;; 11 succs { 12 13 }
;; 12 succs { 13 }
;; 13 succs { 14 }
;; 14 succs { 1 }
void find_bisection (struct commit_list * * commit_list, int * reaches, int * all, int find_all)
{
  unsigned int flags;
  int * weights;
  struct commit_list * last;
  struct commit_list * next;
  struct commit_list * best;
  struct commit_list * p;
  struct commit_list * list;
  int on_list;
  int nr;

  <bb 2> :
  _1 = *commit_list;
  show_list ("bisection 2 entry", 0, 0, _1);
  on_list = 0;
  nr = on_list;
  last = 0B;
  p = *commit_list;
  goto <bb 9>; [INV]

  <bb 3> :
  _2 = p->item;
  _3 = _2->object.flags;
  flags = (unsigned int) _3;
  next = p->next;
  _4 = flags & 2;
  if (_4 != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  free (p);
  // predicted unlikely by continue predictor.
  goto <bb 8>; [INV]

  <bb 5> :
  p->next = last;
  last = p;
  _5 = flags & 4;
  if (_5 == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  nr = nr + 1;

  <bb 7> :
  on_list = on_list + 1;

  <bb 8> :
  p = next;

  <bb 9> :
  if (p != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 10> :
  list = last;
  show_list ("bisection 2 sorted", 0, nr, list);
  *all = nr;
  _6 = (long unsigned int) on_list;
  weights = calloc (_6, 4);
  best = do_find_bisection (list, nr, weights, find_all);
  if (best != 0B)
    goto <bb 11>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 11> :
  if (find_all == 0)
    goto <bb 12>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 12> :
  best->next = 0B;

  <bb 13> :
  _7 = weight (best);
  *reaches = _7;

  <bb 14> :
  free (weights);
  *commit_list = best;
  return;

}



;; Function do_find_bisection (do_find_bisection, funcdef_no=32, decl_uid=3262, cgraph_uid=33, symbol_order=33)

Removing basic block 6
;; 6 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45
;;
;; Loop 3
;;  header 41, latch 40
;;  depth 1, outer 0
;;  nodes: 41 40 22 39 24 32 36 37 34 35 33 31 28 30 25 29 27 26 23
;;
;; Loop 4
;;  header 40, latch 39
;;  depth 2, outer 3
;;  nodes: 40 39 24 32 36 37 34 35 33 31 28 30 25 29 27 26 23
;;
;; Loop 5
;;  header 30, latch 29
;;  depth 3, outer 4
;;  nodes: 30 29 27 28 26
;;
;; Loop 2
;;  header 20, latch 19
;;  depth 1, outer 0
;;  nodes: 20 19 12 14 18 15 16 13 11
;;
;; Loop 1
;;  header 9, latch 8
;;  depth 1, outer 0
;;  nodes: 9 8 5 6 7 4 3
;; 2 succs { 9 }
;; 3 succs { 7 4 6 }
;; 4 succs { 5 8 }
;; 5 succs { 8 }
;; 6 succs { 8 }
;; 7 succs { 8 }
;; 8 succs { 9 }
;; 9 succs { 3 10 }
;; 10 succs { 20 }
;; 11 succs { 12 13 }
;; 12 succs { 19 }
;; 13 succs { 14 15 }
;; 14 succs { 19 }
;; 15 succs { 16 18 }
;; 16 succs { 17 18 }
;; 17 succs { 45 }
;; 18 succs { 19 }
;; 19 succs { 20 }
;; 20 succs { 11 21 }
;; 21 succs { 41 }
;; 22 succs { 40 }
;; 23 succs { 24 25 }
;; 24 succs { 39 }
;; 25 succs { 30 }
;; 26 succs { 27 28 }
;; 27 succs { 29 }
;; 28 succs { 31 29 }
;; 29 succs { 30 }
;; 30 succs { 26 31 }
;; 31 succs { 32 33 }
;; 32 succs { 39 }
;; 33 succs { 34 35 }
;; 34 succs { 36 }
;; 35 succs { 36 }
;; 36 succs { 37 39 }
;; 37 succs { 38 39 }
;; 38 succs { 45 }
;; 39 succs { 40 }
;; 40 succs { 23 41 }
;; 41 succs { 22 42 }
;; 42 succs { 43 44 }
;; 43 succs { 45 }
;; 44 succs { 45 }
;; 45 succs { 1 }
struct commit_list * do_find_bisection (struct commit_list * list, int nr, int * weights, int find_all)
{
  unsigned int flags;
  struct commit_list * q;
  unsigned int flags;
  struct commit * commit;
  struct commit_list * p;
  int counted;
  int n;
  struct commit_list * D.3388;

  <bb 2> :
  counted = 0;
  n = 0;
  p = list;
  goto <bb 9>; [INV]

  <bb 3> :
  commit = p->item;
  _1 = commit->object.flags;
  flags = (unsigned int) _1;
  n.2_2 = n;
  n = n.2_2 + 1;
  _3 = (long unsigned int) n.2_2;
  _4 = _3 * 4;
  _5 = p->item;
  _6 = weights + _4;
  _5->util = _6;
  _7 = count_interesting_parents (commit);
  switch (_7) <default: <L5> [INV], case 0: <L1> [INV], case 1: <L4> [INV]>

  <bb 4> :
<L1>:
  _8 = flags & 4;
  if (_8 == 0)
    goto <bb 5>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 5> :
  weight_set (p, 1);
  counted = counted + 1;
  show_list ("bisection 2 count one", counted, nr, list);
  goto <bb 8>; [INV]

  <bb 6> :
<L4>:
  weight_set (p, -1);
  goto <bb 8>; [INV]

  <bb 7> :
<L5>:
  weight_set (p, -2);

  <bb 8> :
  p = p->next;

  <bb 9> :
  if (p != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 10> :
  show_list ("bisection 2 initialize", counted, nr, list);
  p = list;
  goto <bb 20>; [INV]

  <bb 11> :
  _9 = p->item;
  _10 = _9->object.flags;
  _11 = (unsigned int) _10;
  _12 = _11 & 2;
  if (_12 != 0)
    goto <bb 12>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 12> :
  // predicted unlikely by continue predictor.
  goto <bb 19>; [INV]

  <bb 13> :
  _13 = weight (p);
  if (_13 != -2)
    goto <bb 14>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 14> :
  // predicted unlikely by continue predictor.
  goto <bb 19>; [INV]

  <bb 15> :
  _14 = count_distance (p);
  weight_set (p, _14);
  clear_distance (list);
  if (find_all == 0)
    goto <bb 16>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 16> :
  _15 = halfway (p, nr);
  if (_15 != 0)
    goto <bb 17>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 17> :
  D.3388 = p;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 45>; [INV]

  <bb 18> :
  counted = counted + 1;

  <bb 19> :
  p = p->next;

  <bb 20> :
  if (p != 0B)
    goto <bb 11>; [INV]
  else
    goto <bb 21>; [INV]

  <bb 21> :
  show_list ("bisection 2 count_distance", counted, nr, list);
  goto <bb 41>; [INV]

  <bb 22> :
  p = list;
  goto <bb 40>; [INV]

  <bb 23> :
  _16 = p->item;
  _17 = _16->object.flags;
  flags = (unsigned int) _17;
  _18 = weight (p);
  if (_18 >= 0)
    goto <bb 24>; [INV]
  else
    goto <bb 25>; [INV]

  <bb 24> :
  // predicted unlikely by continue predictor.
  goto <bb 39>; [INV]

  <bb 25> :
  _19 = p->item;
  q = _19->parents;
  goto <bb 30>; [INV]

  <bb 26> :
  _20 = q->item;
  _21 = _20->object.flags;
  _22 = (unsigned int) _21;
  _23 = _22 & 2;
  if (_23 != 0)
    goto <bb 27>; [INV]
  else
    goto <bb 28>; [INV]

  <bb 27> :
  // predicted unlikely by continue predictor.
  goto <bb 29>; [INV]

  <bb 28> :
  _24 = weight (q);
  if (_24 >= 0)
    goto <bb 31>; [INV]
  else
    goto <bb 29>; [INV]

  <bb 29> :
  q = q->next;

  <bb 30> :
  if (q != 0B)
    goto <bb 26>; [INV]
  else
    goto <bb 31>; [INV]

  <bb 31> :
  if (q == 0B)
    goto <bb 32>; [INV]
  else
    goto <bb 33>; [INV]

  <bb 32> :
  // predicted unlikely by continue predictor.
  goto <bb 39>; [INV]

  <bb 33> :
  _25 = flags & 4;
  if (_25 == 0)
    goto <bb 34>; [INV]
  else
    goto <bb 35>; [INV]

  <bb 34> :
  _26 = weight (q);
  _27 = _26 + 1;
  weight_set (p, _27);
  counted = counted + 1;
  show_list ("bisection 2 count one", counted, nr, list);
  goto <bb 36>; [INV]

  <bb 35> :
  _28 = weight (q);
  weight_set (p, _28);

  <bb 36> :
  if (find_all == 0)
    goto <bb 37>; [INV]
  else
    goto <bb 39>; [INV]

  <bb 37> :
  _29 = halfway (p, nr);
  if (_29 != 0)
    goto <bb 38>; [INV]
  else
    goto <bb 39>; [INV]

  <bb 38> :
  D.3388 = p;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 45>; [INV]

  <bb 39> :
  p = p->next;

  <bb 40> :
  if (p != 0B)
    goto <bb 23>; [INV]
  else
    goto <bb 41>; [INV]

  <bb 41> :
  if (counted < nr)
    goto <bb 22>; [INV]
  else
    goto <bb 42>; [INV]

  <bb 42> :
  show_list ("bisection 2 counted all", counted, nr, list);
  if (find_all == 0)
    goto <bb 43>; [INV]
  else
    goto <bb 44>; [INV]

  <bb 43> :
  D.3388 = best_bisection (list, nr);
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 45>; [INV]

  <bb 44> :
  D.3388 = best_bisection_sorted (list, nr);
  // predicted unlikely by early return (on trees) predictor.

  <bb 45> :
  return D.3388;

}



;; Function best_bisection (best_bisection, funcdef_no=30, decl_uid=3216, cgraph_uid=31, symbol_order=31)

Merging blocks 11 and 12
;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11
;;
;; Loop 1
;;  header 10, latch 9
;;  depth 1, outer 0
;;  nodes: 10 9 4 7 8 5 6 3
;; 2 succs { 10 }
;; 3 succs { 4 5 }
;; 4 succs { 9 }
;; 5 succs { 6 7 }
;; 6 succs { 7 }
;; 7 succs { 8 9 }
;; 8 succs { 9 }
;; 9 succs { 10 }
;; 10 succs { 3 11 }
;; 11 succs { 1 }
struct commit_list * best_bisection (struct commit_list * list, int nr)
{
  unsigned int flags;
  int distance;
  int best_distance;
  struct commit_list * best;
  struct commit_list * p;
  struct commit_list * D.3412;

  <bb 2> :
  best_distance = -1;
  best = list;
  p = list;
  goto <bb 10>; [INV]

  <bb 3> :
  _1 = p->item;
  _2 = _1->object.flags;
  flags = (unsigned int) _2;
  _3 = flags & 4;
  if (_3 != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  // predicted unlikely by continue predictor.
  goto <bb 9>; [INV]

  <bb 5> :
  distance = weight (p);
  _4 = nr - distance;
  if (distance > _4)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  distance = nr - distance;

  <bb 7> :
  if (distance > best_distance)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  best = p;
  best_distance = distance;

  <bb 9> :
  p = p->next;

  <bb 10> :
  if (p != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 11> :
  D.3412 = best;
  return D.3412;

}



;; Function best_bisection_sorted (best_bisection_sorted, funcdef_no=31, decl_uid=3231, cgraph_uid=32, symbol_order=32)

Merging blocks 15 and 16
Merging blocks 15 and 17
;; 3 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
;;
;; Loop 2
;;  header 14, latch 13
;;  depth 1, outer 0
;;  nodes: 14 13 11 12
;;
;; Loop 1
;;  header 9, latch 8
;;  depth 1, outer 0
;;  nodes: 9 8 4 7 5 6 3
;; 2 succs { 9 }
;; 3 succs { 4 5 }
;; 4 succs { 8 }
;; 5 succs { 6 7 }
;; 6 succs { 7 }
;; 7 succs { 8 }
;; 8 succs { 9 }
;; 9 succs { 3 10 }
;; 10 succs { 14 }
;; 11 succs { 12 13 }
;; 12 succs { 13 }
;; 13 succs { 14 }
;; 14 succs { 11 15 }
;; 15 succs { 1 }
struct commit_list * best_bisection_sorted (struct commit_list * list, int nr)
{
  struct object * obj;
  unsigned int flags;
  int distance;
  int i;
  int cnt;
  struct strbuf buf;
  struct commit_dist * array;
  struct commit_list * p;
  struct commit_list * D.3420;

  <bb 2> :
  _1 = (long unsigned int) nr;
  array = calloc (_1, 16);
  buf.alloc = 0;
  buf.len = 0;
  buf.buf = &strbuf_slopbuf;
  p = list;
  cnt = 0;
  goto <bb 9>; [INV]

  <bb 3> :
  _2 = p->item;
  _3 = _2->object.flags;
  flags = (unsigned int) _3;
  _4 = flags & 4;
  if (_4 != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  // predicted unlikely by continue predictor.
  goto <bb 8>; [INV]

  <bb 5> :
  distance = weight (p);
  _5 = nr - distance;
  if (distance > _5)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  distance = nr - distance;

  <bb 7> :
  _6 = (long unsigned int) cnt;
  _7 = _6 * 16;
  _8 = array + _7;
  _9 = p->item;
  _8->commit = _9;
  _10 = (long unsigned int) cnt;
  _11 = _10 * 16;
  _12 = array + _11;
  _12->distance = distance;
  cnt = cnt + 1;

  <bb 8> :
  p = p->next;

  <bb 9> :
  if (p != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 10> :
  p = list;
  i = 0;
  goto <bb 14>; [INV]

  <bb 11> :
  _13 = (long unsigned int) i;
  _14 = _13 * 16;
  _15 = array + _14;
  _16 = _15->commit;
  obj = &_16->object;
  strbuf_reset (&buf);
  _17 = (long unsigned int) i;
  _18 = _17 * 16;
  _19 = array + _18;
  _20 = _19->distance;
  strbuf_addf (&buf, "dist=%d", _20);
  _21 = buf.buf;
  add_name_decoration (0, _21, obj);
  _22 = (long unsigned int) i;
  _23 = _22 * 16;
  _24 = array + _23;
  _25 = _24->commit;
  p->item = _25;
  _26 = cnt + -1;
  if (i < _26)
    goto <bb 12>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 12> :
  p = p->next;

  <bb 13> :
  i = i + 1;

  <bb 14> :
  if (i < cnt)
    goto <bb 11>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 15> :
  _27 = p->next;
  free_commit_list (_27);
  p->next = 0B;
  strbuf_release (&buf);
  free (array);
  D.3420 = list;
  buf = {CLOBBER};
  return D.3420;

}



;; Function main (main, funcdef_no=34, decl_uid=3338, cgraph_uid=35, symbol_order=35)

Removing basic block 7
Merging blocks 5 and 6
Merging blocks 5 and 8
;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5
;;
;; Loop 1
;;  header 4, latch 3
;;  depth 1, outer 0
;;  nodes: 4 3
;; 2 succs { 4 }
;; 3 succs { 4 }
;; 4 succs { 3 5 }
;; 5 succs { 1 }
int main ()
{
  int i;
  int find_all;
  int all;
  int reaches;
  struct commit_list * list;
  int D.3423;

  <bb 2> :
  i = 0;
  goto <bb 4>; [INV]

  <bb 3> :
  commit_list_insert (0B, &list);
  i = i + 1;

  <bb 4> :
  if (i <= 9)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 5> :
  find_bisection (&list, &reaches, &all, find_all);
  list.3_1 = list;
  free_commit_list (list.3_1);
  D.3423 = 0;
  list = {CLOBBER};
  reaches = {CLOBBER};
  all = {CLOBBER};
  return D.3423;

}


