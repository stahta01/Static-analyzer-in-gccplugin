
;; Function do_init (do_init, funcdef_no=22, decl_uid=3558, cgraph_uid=23, symbol_order=25)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7
;; 2 succs { 3 4 }
;; 3 succs { 7 }
;; 4 succs { 5 6 }
;; 5 succs { 6 }
;; 6 succs { 7 }
;; 7 succs { 1 }
struct sftp_conn * do_init (int fd_in, int fd_out, u_int transfer_buflen, u_int num_requests, u_int64_t limit_kbps)
{
  int r;
  struct sftp_conn * ret;
  u_char type;
  struct sftp_conn * D.3657;

  <bb 2> :
  ret = calloc (1, 168);
  ret->msg_id = 1;
  ret->fd_in = fd_in;
  ret->fd_out = fd_out;
  ret->transfer_buflen = transfer_buflen;
  ret->num_requests = num_requests;
  ret->exts = 0;
  ret->limit_kbps = 0;
  if (type != 2)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  _1 = (int) type;
  printf ("Invalid packet back from SSH2_FXP_INIT (type %u)\n", _1);
  D.3657 = 0B;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 7>; [INV]

  <bb 4> :
  _2 = ret->version;
  printf ("Remote version: %u", _2);
  _3 = ret->version;
  if (_3 == 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  _4 = ret->transfer_buflen;
  _5 = MIN_EXPR <_4, 20480>;
  ret->transfer_buflen = _5;

  <bb 6> :
  ret->limit_kbps = limit_kbps;
  D.3657 = ret;

  <bb 7> :
  return D.3657;

}



;; Function do_realpath (do_realpath, funcdef_no=23, decl_uid=3565, cgraph_uid=24, symbol_order=26)

Merging blocks 5 and 6
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5
;; 2 succs { 3 4 }
;; 3 succs { 5 }
;; 4 succs { 5 }
;; 5 succs { 1 }
char * do_realpath (struct sftp_conn * conn, const char * path)
{
  u_int status;
  int r;
  u_char type;
  struct Attrib a;
  char * longname;
  char * filename;
  u_int id;
  u_int count;
  u_int expected_id;
  char * D.3663;

  <bb 2> :
  _1 = conn->msg_id;
  _2 = _1;
  _3 = _2 + 1;
  conn->msg_id = _3;
  id = _2;
  expected_id = id;
  if (type == 101)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  D.3663 = 0B;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 5>; [INV]

  <bb 4> :
  D.3663 = strdup (path);

  <bb 5> :
  a = {CLOBBER};
  return D.3663;

}



;; Function interactive_loop (interactive_loop, funcdef_no=25, decl_uid=3613, cgraph_uid=26, symbol_order=28)

Removing basic block 10
Removing basic block 23
Merging blocks 28 and 29
;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26
;;
;; Loop 1
;;  header 19, latch 21
;;  depth 1, outer 0
;;  nodes: 19 21 20
;; 2 succs { 3 4 }
;; 3 succs { }
;; 4 succs { 5 18 }
;; 5 succs { 6 10 }
;; 6 succs { 7 8 }
;; 7 succs { 8 }
;; 8 succs { 9 17 }
;; 9 succs { 26 }
;; 10 succs { 11 12 }
;; 11 succs { 13 }
;; 12 succs { 13 }
;; 13 succs { 14 15 }
;; 14 succs { 16 }
;; 15 succs { 16 }
;; 16 succs { 26 }
;; 17 succs { 18 }
;; 18 succs { 19 }
;; 19 succs { 20 21 }
;; 20 succs { 22 21 }
;; 21 succs { 22 19 }
;; 22 succs { 23 24 }
;; 23 succs { 25 }
;; 24 succs { 25 }
;; 25 succs { 26 }
;; 26 succs { 1 }
int interactive_loop (struct sftp_conn * conn, char * file1, char * file2)
{
  char * cp;
  EditLine * el;
  int interactive;
  int err;
  char cmd[2048];
  char * dir;
  char * remote_path;
  int iftmp.9;
  char * iftmp.4;
  char * iftmp.3;
  int D.3676;

  <bb 2> :
  dir = 0B;
  el = 0B;
  _1 = do_realpath (conn, ".");
  remote_path = _1;
  remote_path.0_2 = remote_path;
  if (remote_path.0_2 == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  printf ("Need cwd%s", "");
  exit (1);

  <bb 4> :
  if (file1 != 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 5> :
  dir = strdup (file1);
  if (file2 == 0B)
    goto <bb 6>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 6> :
  quiet.1_3 = quiet;
  if (quiet.1_3 == 0)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  printf ("Changing to: %s\n", dir);

  <bb 8> :
  snprintf (&cmd, 2048, "cd \"%s\"", dir);
  _4 = parse_dispatch_command (conn, &cmd, &remote_path, 1);
  if (_4 != 0)
    goto <bb 9>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 9> :
  free (dir);
  remote_path.2_5 = remote_path;
  free (remote_path.2_5);
  free (conn);
  D.3676 = -1;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 26>; [INV]

  <bb 10> :
  if (file2 != 0B)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  iftmp.3 = file2;
  goto <bb 13>; [INV]

  <bb 12> :
  iftmp.3 = "";

  <bb 13> :
  if (file2 == 0B)
    goto <bb 14>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 14> :
  iftmp.4 = "";
  goto <bb 16>; [INV]

  <bb 15> :
  iftmp.4 = " ";

  <bb 16> :
  snprintf (&cmd, 2048, "get %s%s%s", dir, iftmp.4, iftmp.3);
  err = parse_dispatch_command (conn, &cmd, &remote_path, 1);
  free (dir);
  remote_path.5_6 = remote_path;
  free (remote_path.5_6);
  free (conn);
  D.3676 = err;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 26>; [INV]

  <bb 17> :
  free (dir);

  <bb 18> :
  err = 0;

  <bb 19> :
  if (el == 0B)
    goto <bb 20>; [INV]
  else
    goto <bb 21>; [INV]

  <bb 20> :
  infile.6_7 = infile;
  _8 = fgets (&cmd, 2048, infile.6_7);
  if (_8 == 0B)
    goto <bb 22>; [INV]
  else
    goto <bb 21>; [INV]

  <bb 21> :
  batchmode.7_9 = batchmode;
  err = parse_dispatch_command (conn, &cmd, &remote_path, batchmode.7_9);
  if (err != 0)
    goto <bb 22>; [INV]
  else
    goto <bb 19>; [INV]

  <bb 22> :
  remote_path.8_10 = remote_path;
  free (remote_path.8_10);
  free (conn);
  if (err >= 0)
    goto <bb 23>; [INV]
  else
    goto <bb 24>; [INV]

  <bb 23> :
  iftmp.9 = 0;
  goto <bb 25>; [INV]

  <bb 24> :
  iftmp.9 = -1;

  <bb 25> :
  D.3676 = iftmp.9;

  <bb 26> :
  remote_path = {CLOBBER};
  cmd = {CLOBBER};
  return D.3676;

}



;; Function parse_dispatch_command (parse_dispatch_command, funcdef_no=24, decl_uid=3581, cgraph_uid=25, symbol_order=27)

Removing basic block 5
Merging blocks 19 and 20
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18
;; 2 succs { 3 4 }
;; 3 succs { 4 }
;; 4 succs { 12 5 13 7 6 }
;; 5 succs { 13 }
;; 6 succs { 7 }
;; 7 succs { 8 9 }
;; 8 succs { 13 }
;; 9 succs { 10 11 }
;; 10 succs { 13 }
;; 11 succs { 13 }
;; 12 succs { 13 }
;; 13 succs { 14 15 }
;; 14 succs { 18 }
;; 15 succs { 16 17 }
;; 16 succs { 18 }
;; 17 succs { 18 }
;; 18 succs { 1 }
int parse_dispatch_command (struct sftp_conn * conn, const char * cmd, char * * pwd, int err_abort)
{
  int err;
  char path_buf[4096];
  struct Attrib * aa;
  struct Attrib a;
  long unsigned int n_arg;
  int i;
  int cmdnum;
  int sflag;
  int rflag;
  int pflag;
  int lflag;
  int iflag;
  int hflag;
  int fflag;
  int aflag;
  int ignore_errors;
  char * tmp;
  char * path2;
  char * path1;
  int D.3704;

  <bb 2> :
  ignore_errors = 0;
  aflag = 0;
  fflag = 0;
  hflag = 0;
  iflag = 0;
  lflag = 0;
  pflag = 0;
  rflag = 0;
  sflag = 0;
  n_arg = 0;
  err = 0;
  path2 = 0B;
  path1 = path2;
  if (ignore_errors != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  err_abort = 0;

  <bb 4> :
  switch (cmdnum) <default: <L10> [INV], case -1: <L3> [INV], case 0: <L18> [INV], case 1: <L5> [INV], case 19: <L4> [INV]>

  <bb 5> :
<L3>:
  err = -1;
  goto <bb 13>; [INV]

  <bb 6> :
<L4>:
  aflag = 1;

  <bb 7> :
<L5>:
  tmp = do_realpath (conn, path1);
  if (tmp == 0B)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  err = 1;
  goto <bb 13>; [INV]

  <bb 9> :
  _1 = aa->flags;
  _2 = _1 & 4;
  if (_2 == 0)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  error ("Can\'t change directory: Can\'t check target");
  free (tmp);
  err = 1;
  goto <bb 13>; [INV]

  <bb 11> :
  _3 = *pwd;
  free (_3);
  *pwd = tmp;
  goto <bb 13>; [INV]

  <bb 12> :
<L10>:
  printf ("%d is not implemented", cmdnum);

  <bb 13> :
<L18>:
  _4 = err_abort != 0;
  _5 = err != 0;
  _6 = _4 & _5;
  if (_6 != 0)
    goto <bb 14>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 14> :
  D.3704 = -1;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 18>; [INV]

  <bb 15> :
  if (cmdnum == 18)
    goto <bb 16>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 16> :
  D.3704 = 1;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 18>; [INV]

  <bb 17> :
  D.3704 = 0;

  <bb 18> :
  a = {CLOBBER};
  path_buf = {CLOBBER};
  return D.3704;

}



;; Function main (main, funcdef_no=26, decl_uid=3628, cgraph_uid=27, symbol_order=29)

Removing basic block 5
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5
;; 2 succs { 3 4 }
;; 3 succs { 5 }
;; 4 succs { 5 }
;; 5 succs { 1 }
int main (int argc, char * * argv)
{
  long long int limit_kbps;
  size_t num_requests;
  size_t copy_buffer_len;
  struct sftp_conn * conn;
  LogLevel ll;
  const char * errstr;
  char * sftp_direct;
  char * ssh_program;
  char * sftp_server;
  char * file1;
  int sshver;
  int debug_level;
  char * file2;
  char * cp;
  char * userhost;
  char * host;
  int err;
  int ch;
  int out;
  int in;
  int D.3712;

  <bb 2> :
  host = 0B;
  file2 = 0B;
  debug_level = 0;
  sshver = 2;
  file1 = 0B;
  sftp_server = 0B;
  ssh_program = "/usr/bin/ssh";
  sftp_direct = 0B;
  ll = 3;
  copy_buffer_len = 32768;
  num_requests = 64;
  limit_kbps = 0;
  limit_kbps.10_1 = (long unsigned int) limit_kbps;
  _2 = (unsigned int) num_requests;
  _3 = (unsigned int) copy_buffer_len;
  conn = do_init (in, out, _3, _2, limit_kbps.10_1);
  if (conn == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  __builtin_puts (&"Couldn\'t initialise connection to server"[0]);
  D.3712 = 1;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 5>; [INV]

  <bb 4> :
  err = interactive_loop (conn, file1, file2);
  D.3712 = 0;

  <bb 5> :
  return D.3712;

}


