
;; Function xrealloc (xrealloc, funcdef_no=26, decl_uid=3195, cgraph_uid=27, symbol_order=27)

Merging blocks 9 and 10
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9
;; 2 succs { 3 4 }
;; 3 succs { 4 }
;; 4 succs { 5 9 }
;; 5 succs { 6 7 }
;; 6 succs { 7 }
;; 7 succs { 8 9 }
;; 8 succs { }
;; 9 succs { 1 }
void * xrealloc (void * ptr, size_t size)
{
  void * ret;
  void * D.3308;

  <bb 2> :
  ret = realloc (ptr, size);
  _1 = ret == 0B;
  _2 = size == 0;
  _3 = _1 & _2;
  if (_3 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  ret = realloc (ptr, 1);

  <bb 4> :
  if (ret == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 5> :
  ret = realloc (ptr, size);
  _4 = ret == 0B;
  _5 = size == 0;
  _6 = _4 & _5;
  if (_6 != 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  ret = realloc (ptr, 1);

  <bb 7> :
  if (ret == 0B)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  printf ("Out of memory, realloc failed%s", "");
  exit (1);

  <bb 9> :
  D.3308 = ret;
  return D.3308;

}



;; Function main (main, funcdef_no=28, decl_uid=3297, cgraph_uid=29, symbol_order=41)

Removing basic block 3
Merging blocks 2 and 4
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
int main ()
{
  int D.3310;

  <bb 2> :
  remote_exists ("path");
  D.3310 = 0;
  return D.3310;

}



;; Function remote_exists (remote_exists, funcdef_no=27, decl_uid=3282, cgraph_uid=28, symbol_order=40)

Removing basic block 8
Merging blocks 10 and 11
Merging blocks 10 and 12
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9
;; 2 succs { 3 8 }
;; 3 succs { 4 5 }
;; 4 succs { 9 }
;; 5 succs { 6 7 }
;; 6 succs { 9 }
;; 7 succs { 9 }
;; 8 succs { 9 }
;; 9 succs { 1 }
int remote_exists (const char * path)
{
  int ret;
  struct slot_results results;
  struct active_request_slot * slot;
  char * url;
  int D.3321;

  <bb 2> :
  remote.0_1 = remote;
  _2 = remote.0_1->url;
  _3 = strlen (_2);
  _4 = strlen (path);
  _5 = _3 + _4;
  _6 = _5 + 1;
  url = malloc (_6);
  ret = -1;
  remote.1_7 = remote;
  _8 = remote.1_7->url;
  sprintf (url, "%s%s", _8, path);
  _9 = get_active_slot ();
  _10 = (long int) _9;
  slot = (struct active_request_slot *) _10;
  slot->results = &results;
  _11 = slot->curl;
  curl_easy_setopt (_11, 0, url);
  _12 = slot->curl;
  curl_easy_setopt (_12, 0, 1);
  _13 = start_active_slot (slot);
  if (_13 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 3> :
  run_active_slot (slot);
  free (url);
  _14 = results.http_code;
  if (_14 == 404)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  ret = 0;
  goto <bb 9>; [INV]

  <bb 5> :
  _15 = results.curl_result;
  if (_15 == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  ret = 1;
  goto <bb 9>; [INV]

  <bb 7> :
  _16 = results.http_code;
  stderr.2_17 = stderr;
  fprintf (stderr.2_17, "HEAD HTTP error %ld\n", _16);
  goto <bb 9>; [INV]

  <bb 8> :
  free (url);
  stderr.3_18 = stderr;
  __builtin_fwrite ("Unable to start HEAD request\n", 1, 29, stderr.3_18);

  <bb 9> :
  free (url);
  D.3321 = ret;
  results = {CLOBBER};
  return D.3321;

}


