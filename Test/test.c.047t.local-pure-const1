
;; Function printf (printf, funcdef_no=15, decl_uid=798, cgraph_uid=15, symbol_order=15)



 local analysis of printf
   scanning: _4 = __printf_chk (1, __fmt_2(D), __builtin_va_arg_pack ());
  scanning: return _4;
Function is locally looping.
Function can locally free.
__attribute__((__artificial__, __gnu_inline__, __always_inline__))
printf (const char * restrict __fmt)
{
  int _4;

  <bb 2> [100.00%]:
  _4 = __printf_chk (1, __fmt_2(D), __builtin_va_arg_pack ());
  return _4;

}



;; Function memcpy (memcpy, funcdef_no=41, decl_uid=728, cgraph_uid=41, symbol_order=41)



 local analysis of memcpy
   scanning: _1 = __builtin_object_size (__dest_3(D), 0);
  scanning: _7 = __memcpy_chk (__dest_3(D), __src_4(D), __len_5(D), _1);
  scanning: return _7;
Function is locally looping.
__attribute__((__artificial__, __gnu_inline__, __always_inline__, __nothrow__, __leaf__))
memcpy (void * restrict __dest, const void * restrict __src, size_t __len)
{
  long unsigned int _1;
  void * _7;

  <bb 2> [100.00%]:
  _1 = __builtin_object_size (__dest_3(D), 0);
  _7 = __memcpy_chk (__dest_3(D), __src_4(D), __len_5(D), _1);
  return _7;

}



;; Function winlink_cmp (winlink_cmp, funcdef_no=50, decl_uid=4298, cgraph_uid=50, symbol_order=53)



 local analysis of winlink_cmp
   scanning: _1 = wl1_4(D)->idx;
    Indirect ref read is not const
  scanning: _2 = wl2_5(D)->idx;
    Indirect ref read is not const
  scanning: _6 = _1 - _2;
  scanning: return _6;
Function is locally pure.
Function found to be pure: winlink_cmp
Declaration updated to be pure: winlink_cmp
winlink_cmp (struct winlink * wl1, struct winlink * wl2)
{
  int _1;
  int _2;
  int _6;

  <bb 2> [100.00%]:
  _1 = wl1_4(D)->idx;
  _2 = wl2_5(D)->idx;
  _6 = _1 - _2;
  return _6;

}



;; Function winlinks_RB_INSERT_COLOR (winlinks_RB_INSERT_COLOR, funcdef_no=51, decl_uid=4302, cgraph_uid=51, symbol_order=54)



 local analysis of winlinks_RB_INSERT_COLOR
   scanning: gparent_67 = parent_66->entry.rbe_parent;
    Indirect ref read is not const
  scanning: _1 = gparent_67->entry.rbe_left;
    Indirect ref read is not const
  scanning: if (_1 == parent_66)
  scanning: tmp_97 = gparent_67->entry.rbe_right;
    Indirect ref read is not const
  scanning: if (tmp_97 != 0B)
  scanning: _2 = tmp_97->entry.rbe_color;
    Indirect ref read is not const
  scanning: if (_2 == 1)
  scanning: tmp_97->entry.rbe_color = 0;
    Indirect ref write is not const/pure
  scanning: parent_66->entry.rbe_color = 0;
    Indirect ref write is not const/pure
  scanning: gparent_67->entry.rbe_color = 1;
    Indirect ref write is not const/pure
  scanning: // predicted unlikely by continue predictor.
  scanning: _3 = parent_66->entry.rbe_right;
    Indirect ref read is not const
  scanning: if (_3 == elm_50)
  scanning: tmp_102 = parent_66->entry.rbe_right;
    Indirect ref read is not const
  scanning: _4 = tmp_102->entry.rbe_left;
    Indirect ref read is not const
  scanning: parent_66->entry.rbe_right = _4;
    Indirect ref write is not const/pure
  scanning: _5 = parent_66->entry.rbe_right;
    Indirect ref read is not const
  scanning: if (_5 != 0B)
  scanning: _6 = tmp_102->entry.rbe_left;
    Indirect ref read is not const
  scanning: _6->entry.rbe_parent = parent_66;
    Indirect ref write is not const/pure
  scanning: _7 = parent_66->entry.rbe_parent;
    Indirect ref read is not const
  scanning: tmp_102->entry.rbe_parent = _7;
    Indirect ref write is not const/pure
  scanning: _8 = tmp_102->entry.rbe_parent;
    Indirect ref read is not const
  scanning: if (_8 != 0B)
  scanning: _9 = parent_66->entry.rbe_parent;
    Indirect ref read is not const
  scanning: _10 = _9->entry.rbe_left;
    Indirect ref read is not const
  scanning: if (_10 == parent_66)
  scanning: _11 = parent_66->entry.rbe_parent;
    Indirect ref read is not const
  scanning: _11->entry.rbe_left = tmp_102;
    Indirect ref write is not const/pure
  scanning: _12 = parent_66->entry.rbe_parent;
    Indirect ref read is not const
  scanning: _12->entry.rbe_right = tmp_102;
    Indirect ref write is not const/pure
  scanning: head_77(D)->rbh_root = tmp_102;
    Indirect ref write is not const/pure
  scanning: tmp_102->entry.rbe_left = parent_66;
    Indirect ref write is not const/pure
  scanning: parent_66->entry.rbe_parent = tmp_102;
    Indirect ref write is not const/pure
  scanning: _13 = tmp_102->entry.rbe_parent;
    Indirect ref read is not const
  scanning: parent_51->entry.rbe_color = 0;
    Indirect ref write is not const/pure
  scanning: gparent_67->entry.rbe_color = 1;
    Indirect ref write is not const/pure
  scanning: tmp_116 = gparent_67->entry.rbe_left;
    Indirect ref read is not const
  scanning: _14 = tmp_116->entry.rbe_right;
    Indirect ref read is not const
  scanning: gparent_67->entry.rbe_left = _14;
    Indirect ref write is not const/pure
  scanning: _15 = gparent_67->entry.rbe_left;
    Indirect ref read is not const
  scanning: if (_15 != 0B)
  scanning: _16 = tmp_116->entry.rbe_right;
    Indirect ref read is not const
  scanning: _16->entry.rbe_parent = gparent_67;
    Indirect ref write is not const/pure
  scanning: _17 = gparent_67->entry.rbe_parent;
    Indirect ref read is not const
  scanning: tmp_116->entry.rbe_parent = _17;
    Indirect ref write is not const/pure
  scanning: _18 = tmp_116->entry.rbe_parent;
    Indirect ref read is not const
  scanning: if (_18 != 0B)
  scanning: _19 = gparent_67->entry.rbe_parent;
    Indirect ref read is not const
  scanning: _20 = _19->entry.rbe_left;
    Indirect ref read is not const
  scanning: if (_20 == gparent_67)
  scanning: _21 = gparent_67->entry.rbe_parent;
    Indirect ref read is not const
  scanning: _21->entry.rbe_left = tmp_116;
    Indirect ref write is not const/pure
  scanning: _22 = gparent_67->entry.rbe_parent;
    Indirect ref read is not const
  scanning: _22->entry.rbe_right = tmp_116;
    Indirect ref write is not const/pure
  scanning: head_77(D)->rbh_root = tmp_116;
    Indirect ref write is not const/pure
  scanning: tmp_116->entry.rbe_right = gparent_67;
    Indirect ref write is not const/pure
  scanning: gparent_67->entry.rbe_parent = tmp_116;
    Indirect ref write is not const/pure
  scanning: _23 = tmp_116->entry.rbe_parent;
    Indirect ref read is not const
  scanning: tmp_68 = gparent_67->entry.rbe_left;
    Indirect ref read is not const
  scanning: if (tmp_68 != 0B)
  scanning: _24 = tmp_68->entry.rbe_color;
    Indirect ref read is not const
  scanning: if (_24 == 1)
  scanning: tmp_68->entry.rbe_color = 0;
    Indirect ref write is not const/pure
  scanning: parent_66->entry.rbe_color = 0;
    Indirect ref write is not const/pure
  scanning: gparent_67->entry.rbe_color = 1;
    Indirect ref write is not const/pure
  scanning: // predicted unlikely by continue predictor.
  scanning: _25 = parent_66->entry.rbe_left;
    Indirect ref read is not const
  scanning: if (_25 == elm_50)
  scanning: tmp_73 = parent_66->entry.rbe_left;
    Indirect ref read is not const
  scanning: _26 = tmp_73->entry.rbe_right;
    Indirect ref read is not const
  scanning: parent_66->entry.rbe_left = _26;
    Indirect ref write is not const/pure
  scanning: _27 = parent_66->entry.rbe_left;
    Indirect ref read is not const
  scanning: if (_27 != 0B)
  scanning: _28 = tmp_73->entry.rbe_right;
    Indirect ref read is not const
  scanning: _28->entry.rbe_parent = parent_66;
    Indirect ref write is not const/pure
  scanning: _29 = parent_66->entry.rbe_parent;
    Indirect ref read is not const
  scanning: tmp_73->entry.rbe_parent = _29;
    Indirect ref write is not const/pure
  scanning: _30 = tmp_73->entry.rbe_parent;
    Indirect ref read is not const
  scanning: if (_30 != 0B)
  scanning: _31 = parent_66->entry.rbe_parent;
    Indirect ref read is not const
  scanning: _32 = _31->entry.rbe_left;
    Indirect ref read is not const
  scanning: if (_32 == parent_66)
  scanning: _33 = parent_66->entry.rbe_parent;
    Indirect ref read is not const
  scanning: _33->entry.rbe_left = tmp_73;
    Indirect ref write is not const/pure
  scanning: _34 = parent_66->entry.rbe_parent;
    Indirect ref read is not const
  scanning: _34->entry.rbe_right = tmp_73;
    Indirect ref write is not const/pure
  scanning: head_77(D)->rbh_root = tmp_73;
    Indirect ref write is not const/pure
  scanning: tmp_73->entry.rbe_right = parent_66;
    Indirect ref write is not const/pure
  scanning: parent_66->entry.rbe_parent = tmp_73;
    Indirect ref write is not const/pure
  scanning: _35 = tmp_73->entry.rbe_parent;
    Indirect ref read is not const
  scanning: parent_84 = elm_50;
  scanning: parent_52->entry.rbe_color = 0;
    Indirect ref write is not const/pure
  scanning: gparent_67->entry.rbe_color = 1;
    Indirect ref write is not const/pure
  scanning: tmp_88 = gparent_67->entry.rbe_right;
    Indirect ref read is not const
  scanning: _36 = tmp_88->entry.rbe_left;
    Indirect ref read is not const
  scanning: gparent_67->entry.rbe_right = _36;
    Indirect ref write is not const/pure
  scanning: _37 = gparent_67->entry.rbe_right;
    Indirect ref read is not const
  scanning: if (_37 != 0B)
  scanning: _38 = tmp_88->entry.rbe_left;
    Indirect ref read is not const
  scanning: _38->entry.rbe_parent = gparent_67;
    Indirect ref write is not const/pure
  scanning: _39 = gparent_67->entry.rbe_parent;
    Indirect ref read is not const
  scanning: tmp_88->entry.rbe_parent = _39;
    Indirect ref write is not const/pure
  scanning: _40 = tmp_88->entry.rbe_parent;
    Indirect ref read is not const
  scanning: if (_40 != 0B)
  scanning: _41 = gparent_67->entry.rbe_parent;
    Indirect ref read is not const
  scanning: _42 = _41->entry.rbe_left;
    Indirect ref read is not const
  scanning: if (_42 == gparent_67)
  scanning: _43 = gparent_67->entry.rbe_parent;
    Indirect ref read is not const
  scanning: _43->entry.rbe_left = tmp_88;
    Indirect ref write is not const/pure
  scanning: _44 = gparent_67->entry.rbe_parent;
    Indirect ref read is not const
  scanning: _44->entry.rbe_right = tmp_88;
    Indirect ref write is not const/pure
  scanning: head_77(D)->rbh_root = tmp_88;
    Indirect ref write is not const/pure
  scanning: tmp_88->entry.rbe_left = gparent_67;
    Indirect ref write is not const/pure
  scanning: gparent_67->entry.rbe_parent = tmp_88;
    Indirect ref write is not const/pure
  scanning: _45 = tmp_88->entry.rbe_parent;
    Indirect ref read is not const
  scanning: parent_66 = elm_50->entry.rbe_parent;
    Indirect ref read is not const
  scanning: if (parent_66 != 0B)
  scanning: _46 = parent_66->entry.rbe_color;
    Indirect ref read is not const
  scanning: if (_46 == 1)
  scanning: _47 = head_77(D)->rbh_root;
    Indirect ref read is not const
  scanning: _47->entry.rbe_color = 0;
    Indirect ref write is not const/pure
  scanning: return;
winlinks_RB_INSERT_COLOR (struct winlinks * head, struct winlink * elm)
{
  struct winlink * tmp;
  struct winlink * gparent;
  struct winlink * parent;
  struct winlink * _1;
  int _2;
  struct winlink * _3;
  struct winlink * _4;
  struct winlink * _5;
  struct winlink * _6;
  struct winlink * _7;
  struct winlink * _8;
  struct winlink * _9;
  struct winlink * _10;
  struct winlink * _11;
  struct winlink * _12;
  struct winlink * _13;
  struct winlink * _14;
  struct winlink * _15;
  struct winlink * _16;
  struct winlink * _17;
  struct winlink * _18;
  struct winlink * _19;
  struct winlink * _20;
  struct winlink * _21;
  struct winlink * _22;
  struct winlink * _23;
  int _24;
  struct winlink * _25;
  struct winlink * _26;
  struct winlink * _27;
  struct winlink * _28;
  struct winlink * _29;
  struct winlink * _30;
  struct winlink * _31;
  struct winlink * _32;
  struct winlink * _33;
  struct winlink * _34;
  struct winlink * _35;
  struct winlink * _36;
  struct winlink * _37;
  struct winlink * _38;
  struct winlink * _39;
  struct winlink * _40;
  struct winlink * _41;
  struct winlink * _42;
  struct winlink * _43;
  struct winlink * _44;
  struct winlink * _45;
  int _46;
  struct winlink * _47;

  <bb 2> [14.44%]:
  goto <bb 47>; [100.00%]

  <bb 3> [85.56%]:
  gparent_67 = parent_66->entry.rbe_parent;
  _1 = gparent_67->entry.rbe_left;
  if (_1 == parent_66)
    goto <bb 4>; [30.00%]
  else
    goto <bb 24>; [70.00%]

  <bb 4> [25.67%]:
  tmp_97 = gparent_67->entry.rbe_right;
  if (tmp_97 != 0B)
    goto <bb 5>; [70.00%]
  else
    goto <bb 7>; [30.00%]

  <bb 5> [17.97%]:
  _2 = tmp_97->entry.rbe_color;
  if (_2 == 1)
    goto <bb 6>; [20.24%]
  else
    goto <bb 7>; [79.76%]

  <bb 6> [3.64%]:
  tmp_97->entry.rbe_color = 0;
  parent_66->entry.rbe_color = 0;
  gparent_67->entry.rbe_color = 1;
  // predicted unlikely by continue predictor.
  goto <bb 44>; [100.00%]

  <bb 7> [22.03%]:
  _3 = parent_66->entry.rbe_right;
  if (_3 == elm_50)
    goto <bb 8>; [30.00%]
  else
    goto <bb 16>; [70.00%]

  <bb 8> [6.61%]:
  tmp_102 = parent_66->entry.rbe_right;
  _4 = tmp_102->entry.rbe_left;
  parent_66->entry.rbe_right = _4;
  _5 = parent_66->entry.rbe_right;
  if (_5 != 0B)
    goto <bb 9>; [70.00%]
  else
    goto <bb 10>; [30.00%]

  <bb 9> [4.63%]:
  _6 = tmp_102->entry.rbe_left;
  _6->entry.rbe_parent = parent_66;

  <bb 10> [6.61%]:
  _7 = parent_66->entry.rbe_parent;
  tmp_102->entry.rbe_parent = _7;
  _8 = tmp_102->entry.rbe_parent;
  if (_8 != 0B)
    goto <bb 11>; [70.00%]
  else
    goto <bb 14>; [30.00%]

  <bb 11> [4.63%]:
  _9 = parent_66->entry.rbe_parent;
  _10 = _9->entry.rbe_left;
  if (_10 == parent_66)
    goto <bb 12>; [30.00%]
  else
    goto <bb 13>; [70.00%]

  <bb 12> [1.39%]:
  _11 = parent_66->entry.rbe_parent;
  _11->entry.rbe_left = tmp_102;
  goto <bb 15>; [100.00%]

  <bb 13> [3.24%]:
  _12 = parent_66->entry.rbe_parent;
  _12->entry.rbe_right = tmp_102;
  goto <bb 15>; [100.00%]

  <bb 14> [1.98%]:
  head_77(D)->rbh_root = tmp_102;

  <bb 15> [6.61%]:
  tmp_102->entry.rbe_left = parent_66;
  parent_66->entry.rbe_parent = tmp_102;
  _13 = tmp_102->entry.rbe_parent;

  <bb 16> [22.03%]:
  # elm_48 = PHI <elm_50(7), parent_66(15)>
  # parent_51 = PHI <parent_66(7), elm_50(15)>
  parent_51->entry.rbe_color = 0;
  gparent_67->entry.rbe_color = 1;
  tmp_116 = gparent_67->entry.rbe_left;
  _14 = tmp_116->entry.rbe_right;
  gparent_67->entry.rbe_left = _14;
  _15 = gparent_67->entry.rbe_left;
  if (_15 != 0B)
    goto <bb 17>; [70.00%]
  else
    goto <bb 18>; [30.00%]

  <bb 17> [15.42%]:
  _16 = tmp_116->entry.rbe_right;
  _16->entry.rbe_parent = gparent_67;

  <bb 18> [22.03%]:
  _17 = gparent_67->entry.rbe_parent;
  tmp_116->entry.rbe_parent = _17;
  _18 = tmp_116->entry.rbe_parent;
  if (_18 != 0B)
    goto <bb 19>; [70.00%]
  else
    goto <bb 22>; [30.00%]

  <bb 19> [15.42%]:
  _19 = gparent_67->entry.rbe_parent;
  _20 = _19->entry.rbe_left;
  if (_20 == gparent_67)
    goto <bb 20>; [30.00%]
  else
    goto <bb 21>; [70.00%]

  <bb 20> [4.63%]:
  _21 = gparent_67->entry.rbe_parent;
  _21->entry.rbe_left = tmp_116;
  goto <bb 23>; [100.00%]

  <bb 21> [10.80%]:
  _22 = gparent_67->entry.rbe_parent;
  _22->entry.rbe_right = tmp_116;
  goto <bb 23>; [100.00%]

  <bb 22> [6.61%]:
  head_77(D)->rbh_root = tmp_116;

  <bb 23> [22.03%]:
  tmp_116->entry.rbe_right = gparent_67;
  gparent_67->entry.rbe_parent = tmp_116;
  _23 = tmp_116->entry.rbe_parent;
  goto <bb 44>; [100.00%]

  <bb 24> [59.89%]:
  tmp_68 = gparent_67->entry.rbe_left;
  if (tmp_68 != 0B)
    goto <bb 25>; [70.00%]
  else
    goto <bb 27>; [30.00%]

  <bb 25> [41.93%]:
  _24 = tmp_68->entry.rbe_color;
  if (_24 == 1)
    goto <bb 26>; [20.24%]
  else
    goto <bb 27>; [79.76%]

  <bb 26> [8.49%]:
  tmp_68->entry.rbe_color = 0;
  parent_66->entry.rbe_color = 0;
  gparent_67->entry.rbe_color = 1;
  // predicted unlikely by continue predictor.
  goto <bb 44>; [100.00%]

  <bb 27> [51.41%]:
  _25 = parent_66->entry.rbe_left;
  if (_25 == elm_50)
    goto <bb 28>; [30.00%]
  else
    goto <bb 36>; [70.00%]

  <bb 28> [15.42%]:
  tmp_73 = parent_66->entry.rbe_left;
  _26 = tmp_73->entry.rbe_right;
  parent_66->entry.rbe_left = _26;
  _27 = parent_66->entry.rbe_left;
  if (_27 != 0B)
    goto <bb 29>; [70.00%]
  else
    goto <bb 30>; [30.00%]

  <bb 29> [10.80%]:
  _28 = tmp_73->entry.rbe_right;
  _28->entry.rbe_parent = parent_66;

  <bb 30> [15.42%]:
  _29 = parent_66->entry.rbe_parent;
  tmp_73->entry.rbe_parent = _29;
  _30 = tmp_73->entry.rbe_parent;
  if (_30 != 0B)
    goto <bb 31>; [70.00%]
  else
    goto <bb 34>; [30.00%]

  <bb 31> [10.80%]:
  _31 = parent_66->entry.rbe_parent;
  _32 = _31->entry.rbe_left;
  if (_32 == parent_66)
    goto <bb 32>; [30.00%]
  else
    goto <bb 33>; [70.00%]

  <bb 32> [3.24%]:
  _33 = parent_66->entry.rbe_parent;
  _33->entry.rbe_left = tmp_73;
  goto <bb 35>; [100.00%]

  <bb 33> [7.56%]:
  _34 = parent_66->entry.rbe_parent;
  _34->entry.rbe_right = tmp_73;
  goto <bb 35>; [100.00%]

  <bb 34> [4.63%]:
  head_77(D)->rbh_root = tmp_73;

  <bb 35> [15.42%]:
  tmp_73->entry.rbe_right = parent_66;
  parent_66->entry.rbe_parent = tmp_73;
  _35 = tmp_73->entry.rbe_parent;
  parent_84 = elm_50;

  <bb 36> [51.41%]:
  # elm_49 = PHI <elm_50(27), parent_66(35)>
  # parent_52 = PHI <parent_66(27), elm_50(35)>
  parent_52->entry.rbe_color = 0;
  gparent_67->entry.rbe_color = 1;
  tmp_88 = gparent_67->entry.rbe_right;
  _36 = tmp_88->entry.rbe_left;
  gparent_67->entry.rbe_right = _36;
  _37 = gparent_67->entry.rbe_right;
  if (_37 != 0B)
    goto <bb 37>; [70.00%]
  else
    goto <bb 38>; [30.00%]

  <bb 37> [35.99%]:
  _38 = tmp_88->entry.rbe_left;
  _38->entry.rbe_parent = gparent_67;

  <bb 38> [51.41%]:
  _39 = gparent_67->entry.rbe_parent;
  tmp_88->entry.rbe_parent = _39;
  _40 = tmp_88->entry.rbe_parent;
  if (_40 != 0B)
    goto <bb 39>; [70.00%]
  else
    goto <bb 42>; [30.00%]

  <bb 39> [35.99%]:
  _41 = gparent_67->entry.rbe_parent;
  _42 = _41->entry.rbe_left;
  if (_42 == gparent_67)
    goto <bb 40>; [30.00%]
  else
    goto <bb 41>; [70.00%]

  <bb 40> [10.80%]:
  _43 = gparent_67->entry.rbe_parent;
  _43->entry.rbe_left = tmp_88;
  goto <bb 43>; [100.00%]

  <bb 41> [25.19%]:
  _44 = gparent_67->entry.rbe_parent;
  _44->entry.rbe_right = tmp_88;
  goto <bb 43>; [100.00%]

  <bb 42> [15.42%]:
  head_77(D)->rbh_root = tmp_88;

  <bb 43> [51.41%]:
  tmp_88->entry.rbe_left = gparent_67;
  gparent_67->entry.rbe_parent = tmp_88;
  _45 = tmp_88->entry.rbe_parent;

  <bb 44> [85.56%]:
  # elm_72 = PHI <elm_49(43), gparent_67(6), elm_48(23), gparent_67(26)>

  <bb 47> [100.00%]:
  # elm_50 = PHI <elm_72(44), elm_64(D)(2)>
  parent_66 = elm_50->entry.rbe_parent;
  if (parent_66 != 0B)
    goto <bb 45>; [92.50%]
  else
    goto <bb 46>; [7.50%]

  <bb 45> [92.50%]:
  _46 = parent_66->entry.rbe_color;
  if (_46 == 1)
    goto <bb 3>; [92.50%]
  else
    goto <bb 46>; [7.50%]

  <bb 46> [14.44%]:
  _47 = head_77(D)->rbh_root;
  _47->entry.rbe_color = 0;
  return;

}



;; Function winlinks_RB_REMOVE_COLOR (winlinks_RB_REMOVE_COLOR, funcdef_no=52, decl_uid=4313, cgraph_uid=52, symbol_order=55)



 local analysis of winlinks_RB_REMOVE_COLOR
   scanning: _1 = parent_90->entry.rbe_left;
    Indirect ref read is not const
  scanning: if (_1 == elm_91)
  scanning: tmp_166 = parent_90->entry.rbe_right;
    Indirect ref read is not const
  scanning: _2 = tmp_166->entry.rbe_color;
    Indirect ref read is not const
  scanning: if (_2 == 1)
  scanning: tmp_166->entry.rbe_color = 0;
    Indirect ref write is not const/pure
  scanning: parent_90->entry.rbe_color = 1;
    Indirect ref write is not const/pure
  scanning: tmp_169 = parent_90->entry.rbe_right;
    Indirect ref read is not const
  scanning: _3 = tmp_169->entry.rbe_left;
    Indirect ref read is not const
  scanning: parent_90->entry.rbe_right = _3;
    Indirect ref write is not const/pure
  scanning: _4 = parent_90->entry.rbe_right;
    Indirect ref read is not const
  scanning: if (_4 != 0B)
  scanning: _5 = tmp_169->entry.rbe_left;
    Indirect ref read is not const
  scanning: _5->entry.rbe_parent = parent_90;
    Indirect ref write is not const/pure
  scanning: _6 = parent_90->entry.rbe_parent;
    Indirect ref read is not const
  scanning: tmp_169->entry.rbe_parent = _6;
    Indirect ref write is not const/pure
  scanning: _7 = tmp_169->entry.rbe_parent;
    Indirect ref read is not const
  scanning: if (_7 != 0B)
  scanning: _8 = parent_90->entry.rbe_parent;
    Indirect ref read is not const
  scanning: _9 = _8->entry.rbe_left;
    Indirect ref read is not const
  scanning: if (_9 == parent_90)
  scanning: _10 = parent_90->entry.rbe_parent;
    Indirect ref read is not const
  scanning: _10->entry.rbe_left = tmp_169;
    Indirect ref write is not const/pure
  scanning: _11 = parent_90->entry.rbe_parent;
    Indirect ref read is not const
  scanning: _11->entry.rbe_right = tmp_169;
    Indirect ref write is not const/pure
  scanning: head_123(D)->rbh_root = tmp_169;
    Indirect ref write is not const/pure
  scanning: tmp_169->entry.rbe_left = parent_90;
    Indirect ref write is not const/pure
  scanning: parent_90->entry.rbe_parent = tmp_169;
    Indirect ref write is not const/pure
  scanning: _12 = tmp_169->entry.rbe_parent;
    Indirect ref read is not const
  scanning: tmp_178 = parent_90->entry.rbe_right;
    Indirect ref read is not const
  scanning: _13 = tmp_93->entry.rbe_left;
    Indirect ref read is not const
  scanning: if (_13 == 0B)
  scanning: _14 = tmp_93->entry.rbe_left;
    Indirect ref read is not const
  scanning: _15 = _14->entry.rbe_color;
    Indirect ref read is not const
  scanning: if (_15 == 0)
  scanning: _16 = tmp_93->entry.rbe_right;
    Indirect ref read is not const
  scanning: if (_16 == 0B)
  scanning: _17 = tmp_93->entry.rbe_right;
    Indirect ref read is not const
  scanning: _18 = _17->entry.rbe_color;
    Indirect ref read is not const
  scanning: if (_18 == 0)
  scanning: tmp_93->entry.rbe_color = 1;
    Indirect ref write is not const/pure
  scanning: parent_181 = parent_90->entry.rbe_parent;
    Indirect ref read is not const
  scanning: _19 = tmp_93->entry.rbe_right;
    Indirect ref read is not const
  scanning: if (_19 == 0B)
  scanning: _20 = tmp_93->entry.rbe_right;
    Indirect ref read is not const
  scanning: _21 = _20->entry.rbe_color;
    Indirect ref read is not const
  scanning: if (_21 == 0)
  scanning: oleft_182 = tmp_93->entry.rbe_left;
    Indirect ref read is not const
  scanning: if (oleft_182 != 0B)
  scanning: oleft_182->entry.rbe_color = 0;
    Indirect ref write is not const/pure
  scanning: tmp_93->entry.rbe_color = 1;
    Indirect ref write is not const/pure
  scanning: oleft_185 = tmp_93->entry.rbe_left;
    Indirect ref read is not const
  scanning: _22 = oleft_185->entry.rbe_right;
    Indirect ref read is not const
  scanning: tmp_93->entry.rbe_left = _22;
    Indirect ref write is not const/pure
  scanning: _23 = tmp_93->entry.rbe_left;
    Indirect ref read is not const
  scanning: if (_23 != 0B)
  scanning: _24 = oleft_185->entry.rbe_right;
    Indirect ref read is not const
  scanning: _24->entry.rbe_parent = tmp_93;
    Indirect ref write is not const/pure
  scanning: _25 = tmp_93->entry.rbe_parent;
    Indirect ref read is not const
  scanning: oleft_185->entry.rbe_parent = _25;
    Indirect ref write is not const/pure
  scanning: _26 = oleft_185->entry.rbe_parent;
    Indirect ref read is not const
  scanning: if (_26 != 0B)
  scanning: _27 = tmp_93->entry.rbe_parent;
    Indirect ref read is not const
  scanning: _28 = _27->entry.rbe_left;
    Indirect ref read is not const
  scanning: if (_28 == tmp_93)
  scanning: _29 = tmp_93->entry.rbe_parent;
    Indirect ref read is not const
  scanning: _29->entry.rbe_left = oleft_185;
    Indirect ref write is not const/pure
  scanning: _30 = tmp_93->entry.rbe_parent;
    Indirect ref read is not const
  scanning: _30->entry.rbe_right = oleft_185;
    Indirect ref write is not const/pure
  scanning: head_123(D)->rbh_root = oleft_185;
    Indirect ref write is not const/pure
  scanning: oleft_185->entry.rbe_right = tmp_93;
    Indirect ref write is not const/pure
  scanning: tmp_93->entry.rbe_parent = oleft_185;
    Indirect ref write is not const/pure
  scanning: _31 = oleft_185->entry.rbe_parent;
    Indirect ref read is not const
  scanning: tmp_194 = parent_90->entry.rbe_right;
    Indirect ref read is not const
  scanning: _32 = parent_90->entry.rbe_color;
    Indirect ref read is not const
  scanning: tmp_94->entry.rbe_color = _32;
    Indirect ref write is not const/pure
  scanning: parent_90->entry.rbe_color = 0;
    Indirect ref write is not const/pure
  scanning: _33 = tmp_94->entry.rbe_right;
    Indirect ref read is not const
  scanning: if (_33 != 0B)
  scanning: _34 = tmp_94->entry.rbe_right;
    Indirect ref read is not const
  scanning: _34->entry.rbe_color = 0;
    Indirect ref write is not const/pure
  scanning: tmp_198 = parent_90->entry.rbe_right;
    Indirect ref read is not const
  scanning: _35 = tmp_198->entry.rbe_left;
    Indirect ref read is not const
  scanning: parent_90->entry.rbe_right = _35;
    Indirect ref write is not const/pure
  scanning: _36 = parent_90->entry.rbe_right;
    Indirect ref read is not const
  scanning: if (_36 != 0B)
  scanning: _37 = tmp_198->entry.rbe_left;
    Indirect ref read is not const
  scanning: _37->entry.rbe_parent = parent_90;
    Indirect ref write is not const/pure
  scanning: _38 = parent_90->entry.rbe_parent;
    Indirect ref read is not const
  scanning: tmp_198->entry.rbe_parent = _38;
    Indirect ref write is not const/pure
  scanning: _39 = tmp_198->entry.rbe_parent;
    Indirect ref read is not const
  scanning: if (_39 != 0B)
  scanning: _40 = parent_90->entry.rbe_parent;
    Indirect ref read is not const
  scanning: _41 = _40->entry.rbe_left;
    Indirect ref read is not const
  scanning: if (_41 == parent_90)
  scanning: _42 = parent_90->entry.rbe_parent;
    Indirect ref read is not const
  scanning: _42->entry.rbe_left = tmp_198;
    Indirect ref write is not const/pure
  scanning: _43 = parent_90->entry.rbe_parent;
    Indirect ref read is not const
  scanning: _43->entry.rbe_right = tmp_198;
    Indirect ref write is not const/pure
  scanning: head_123(D)->rbh_root = tmp_198;
    Indirect ref write is not const/pure
  scanning: tmp_198->entry.rbe_left = parent_90;
    Indirect ref write is not const/pure
  scanning: parent_90->entry.rbe_parent = tmp_198;
    Indirect ref write is not const/pure
  scanning: _44 = tmp_198->entry.rbe_parent;
    Indirect ref read is not const
  scanning: elm_207 = head_123(D)->rbh_root;
    Indirect ref read is not const
  scanning: tmp_124 = parent_90->entry.rbe_left;
    Indirect ref read is not const
  scanning: _45 = tmp_124->entry.rbe_color;
    Indirect ref read is not const
  scanning: if (_45 == 1)
  scanning: tmp_124->entry.rbe_color = 0;
    Indirect ref write is not const/pure
  scanning: parent_90->entry.rbe_color = 1;
    Indirect ref write is not const/pure
  scanning: tmp_127 = parent_90->entry.rbe_left;
    Indirect ref read is not const
  scanning: _46 = tmp_127->entry.rbe_right;
    Indirect ref read is not const
  scanning: parent_90->entry.rbe_left = _46;
    Indirect ref write is not const/pure
  scanning: _47 = parent_90->entry.rbe_left;
    Indirect ref read is not const
  scanning: if (_47 != 0B)
  scanning: _48 = tmp_127->entry.rbe_right;
    Indirect ref read is not const
  scanning: _48->entry.rbe_parent = parent_90;
    Indirect ref write is not const/pure
  scanning: _49 = parent_90->entry.rbe_parent;
    Indirect ref read is not const
  scanning: tmp_127->entry.rbe_parent = _49;
    Indirect ref write is not const/pure
  scanning: _50 = tmp_127->entry.rbe_parent;
    Indirect ref read is not const
  scanning: if (_50 != 0B)
  scanning: _51 = parent_90->entry.rbe_parent;
    Indirect ref read is not const
  scanning: _52 = _51->entry.rbe_left;
    Indirect ref read is not const
  scanning: if (_52 == parent_90)
  scanning: _53 = parent_90->entry.rbe_parent;
    Indirect ref read is not const
  scanning: _53->entry.rbe_left = tmp_127;
    Indirect ref write is not const/pure
  scanning: _54 = parent_90->entry.rbe_parent;
    Indirect ref read is not const
  scanning: _54->entry.rbe_right = tmp_127;
    Indirect ref write is not const/pure
  scanning: head_123(D)->rbh_root = tmp_127;
    Indirect ref write is not const/pure
  scanning: tmp_127->entry.rbe_right = parent_90;
    Indirect ref write is not const/pure
  scanning: parent_90->entry.rbe_parent = tmp_127;
    Indirect ref write is not const/pure
  scanning: _55 = tmp_127->entry.rbe_parent;
    Indirect ref read is not const
  scanning: tmp_136 = parent_90->entry.rbe_left;
    Indirect ref read is not const
  scanning: _56 = tmp_95->entry.rbe_left;
    Indirect ref read is not const
  scanning: if (_56 == 0B)
  scanning: _57 = tmp_95->entry.rbe_left;
    Indirect ref read is not const
  scanning: _58 = _57->entry.rbe_color;
    Indirect ref read is not const
  scanning: if (_58 == 0)
  scanning: _59 = tmp_95->entry.rbe_right;
    Indirect ref read is not const
  scanning: if (_59 == 0B)
  scanning: _60 = tmp_95->entry.rbe_right;
    Indirect ref read is not const
  scanning: _61 = _60->entry.rbe_color;
    Indirect ref read is not const
  scanning: if (_61 == 0)
  scanning: tmp_95->entry.rbe_color = 1;
    Indirect ref write is not const/pure
  scanning: elm_138 = parent_90;
  scanning: parent_139 = elm_138->entry.rbe_parent;
    Indirect ref read is not const
  scanning: _62 = tmp_95->entry.rbe_left;
    Indirect ref read is not const
  scanning: if (_62 == 0B)
  scanning: _63 = tmp_95->entry.rbe_left;
    Indirect ref read is not const
  scanning: _64 = _63->entry.rbe_color;
    Indirect ref read is not const
  scanning: if (_64 == 0)
  scanning: oright_140 = tmp_95->entry.rbe_right;
    Indirect ref read is not const
  scanning: if (oright_140 != 0B)
  scanning: oright_140->entry.rbe_color = 0;
    Indirect ref write is not const/pure
  scanning: tmp_95->entry.rbe_color = 1;
    Indirect ref write is not const/pure
  scanning: oright_143 = tmp_95->entry.rbe_right;
    Indirect ref read is not const
  scanning: _65 = oright_143->entry.rbe_left;
    Indirect ref read is not const
  scanning: tmp_95->entry.rbe_right = _65;
    Indirect ref write is not const/pure
  scanning: _66 = tmp_95->entry.rbe_right;
    Indirect ref read is not const
  scanning: if (_66 != 0B)
  scanning: _67 = oright_143->entry.rbe_left;
    Indirect ref read is not const
  scanning: _67->entry.rbe_parent = tmp_95;
    Indirect ref write is not const/pure
  scanning: _68 = tmp_95->entry.rbe_parent;
    Indirect ref read is not const
  scanning: oright_143->entry.rbe_parent = _68;
    Indirect ref write is not const/pure
  scanning: _69 = oright_143->entry.rbe_parent;
    Indirect ref read is not const
  scanning: if (_69 != 0B)
  scanning: _70 = tmp_95->entry.rbe_parent;
    Indirect ref read is not const
  scanning: _71 = _70->entry.rbe_left;
    Indirect ref read is not const
  scanning: if (_71 == tmp_95)
  scanning: _72 = tmp_95->entry.rbe_parent;
    Indirect ref read is not const
  scanning: _72->entry.rbe_left = oright_143;
    Indirect ref write is not const/pure
  scanning: _73 = tmp_95->entry.rbe_parent;
    Indirect ref read is not const
  scanning: _73->entry.rbe_right = oright_143;
    Indirect ref write is not const/pure
  scanning: head_123(D)->rbh_root = oright_143;
    Indirect ref write is not const/pure
  scanning: oright_143->entry.rbe_left = tmp_95;
    Indirect ref write is not const/pure
  scanning: tmp_95->entry.rbe_parent = oright_143;
    Indirect ref write is not const/pure
  scanning: _74 = oright_143->entry.rbe_parent;
    Indirect ref read is not const
  scanning: tmp_152 = parent_90->entry.rbe_left;
    Indirect ref read is not const
  scanning: _75 = parent_90->entry.rbe_color;
    Indirect ref read is not const
  scanning: tmp_96->entry.rbe_color = _75;
    Indirect ref write is not const/pure
  scanning: parent_90->entry.rbe_color = 0;
    Indirect ref write is not const/pure
  scanning: _76 = tmp_96->entry.rbe_left;
    Indirect ref read is not const
  scanning: if (_76 != 0B)
  scanning: _77 = tmp_96->entry.rbe_left;
    Indirect ref read is not const
  scanning: _77->entry.rbe_color = 0;
    Indirect ref write is not const/pure
  scanning: tmp_156 = parent_90->entry.rbe_left;
    Indirect ref read is not const
  scanning: _78 = tmp_156->entry.rbe_right;
    Indirect ref read is not const
  scanning: parent_90->entry.rbe_left = _78;
    Indirect ref write is not const/pure
  scanning: _79 = parent_90->entry.rbe_left;
    Indirect ref read is not const
  scanning: if (_79 != 0B)
  scanning: _80 = tmp_156->entry.rbe_right;
    Indirect ref read is not const
  scanning: _80->entry.rbe_parent = parent_90;
    Indirect ref write is not const/pure
  scanning: _81 = parent_90->entry.rbe_parent;
    Indirect ref read is not const
  scanning: tmp_156->entry.rbe_parent = _81;
    Indirect ref write is not const/pure
  scanning: _82 = tmp_156->entry.rbe_parent;
    Indirect ref read is not const
  scanning: if (_82 != 0B)
  scanning: _83 = parent_90->entry.rbe_parent;
    Indirect ref read is not const
  scanning: _84 = _83->entry.rbe_left;
    Indirect ref read is not const
  scanning: if (_84 == parent_90)
  scanning: _85 = parent_90->entry.rbe_parent;
    Indirect ref read is not const
  scanning: _85->entry.rbe_left = tmp_156;
    Indirect ref write is not const/pure
  scanning: _86 = parent_90->entry.rbe_parent;
    Indirect ref read is not const
  scanning: _86->entry.rbe_right = tmp_156;
    Indirect ref write is not const/pure
  scanning: head_123(D)->rbh_root = tmp_156;
    Indirect ref write is not const/pure
  scanning: tmp_156->entry.rbe_right = parent_90;
    Indirect ref write is not const/pure
  scanning: parent_90->entry.rbe_parent = tmp_156;
    Indirect ref write is not const/pure
  scanning: _87 = tmp_156->entry.rbe_parent;
    Indirect ref read is not const
  scanning: elm_165 = head_123(D)->rbh_root;
    Indirect ref read is not const
  scanning: if (elm_91 == 0B)
  scanning: _88 = elm_91->entry.rbe_color;
    Indirect ref read is not const
  scanning: if (_88 == 0)
  scanning: _89 = head_123(D)->rbh_root;
    Indirect ref read is not const
  scanning: if (_89 != elm_91)
  scanning: if (elm_92 != 0B)
  scanning: elm_92->entry.rbe_color = 0;
    Indirect ref write is not const/pure
  scanning: return;
winlinks_RB_REMOVE_COLOR (struct winlinks * head, struct winlink * parent, struct winlink * elm)
{
  struct winlink * oright;
  struct winlink * oleft;
  struct winlink * tmp;
  struct winlink * _1;
  int _2;
  struct winlink * _3;
  struct winlink * _4;
  struct winlink * _5;
  struct winlink * _6;
  struct winlink * _7;
  struct winlink * _8;
  struct winlink * _9;
  struct winlink * _10;
  struct winlink * _11;
  struct winlink * _12;
  struct winlink * _13;
  struct winlink * _14;
  int _15;
  struct winlink * _16;
  struct winlink * _17;
  int _18;
  struct winlink * _19;
  struct winlink * _20;
  int _21;
  struct winlink * _22;
  struct winlink * _23;
  struct winlink * _24;
  struct winlink * _25;
  struct winlink * _26;
  struct winlink * _27;
  struct winlink * _28;
  struct winlink * _29;
  struct winlink * _30;
  struct winlink * _31;
  int _32;
  struct winlink * _33;
  struct winlink * _34;
  struct winlink * _35;
  struct winlink * _36;
  struct winlink * _37;
  struct winlink * _38;
  struct winlink * _39;
  struct winlink * _40;
  struct winlink * _41;
  struct winlink * _42;
  struct winlink * _43;
  struct winlink * _44;
  int _45;
  struct winlink * _46;
  struct winlink * _47;
  struct winlink * _48;
  struct winlink * _49;
  struct winlink * _50;
  struct winlink * _51;
  struct winlink * _52;
  struct winlink * _53;
  struct winlink * _54;
  struct winlink * _55;
  struct winlink * _56;
  struct winlink * _57;
  int _58;
  struct winlink * _59;
  struct winlink * _60;
  int _61;
  struct winlink * _62;
  struct winlink * _63;
  int _64;
  struct winlink * _65;
  struct winlink * _66;
  struct winlink * _67;
  struct winlink * _68;
  struct winlink * _69;
  struct winlink * _70;
  struct winlink * _71;
  struct winlink * _72;
  struct winlink * _73;
  struct winlink * _74;
  int _75;
  struct winlink * _76;
  struct winlink * _77;
  struct winlink * _78;
  struct winlink * _79;
  struct winlink * _80;
  struct winlink * _81;
  struct winlink * _82;
  struct winlink * _83;
  struct winlink * _84;
  struct winlink * _85;
  struct winlink * _86;
  struct winlink * _87;
  int _88;
  struct winlink * _89;

  <bb 2> [7.53%]:
  goto <bb 82>; [100.00%]

  <bb 3> [95.79%]:
  _1 = parent_90->entry.rbe_left;
  if (_1 == elm_91)
    goto <bb 4>; [30.00%]
  else
    goto <bb 40>; [70.00%]

  <bb 4> [28.74%]:
  tmp_166 = parent_90->entry.rbe_right;
  _2 = tmp_166->entry.rbe_color;
  if (_2 == 1)
    goto <bb 5>; [34.00%]
  else
    goto <bb 13>; [66.00%]

  <bb 5> [9.77%]:
  tmp_166->entry.rbe_color = 0;
  parent_90->entry.rbe_color = 1;
  tmp_169 = parent_90->entry.rbe_right;
  _3 = tmp_169->entry.rbe_left;
  parent_90->entry.rbe_right = _3;
  _4 = parent_90->entry.rbe_right;
  if (_4 != 0B)
    goto <bb 6>; [70.00%]
  else
    goto <bb 7>; [30.00%]

  <bb 6> [6.84%]:
  _5 = tmp_169->entry.rbe_left;
  _5->entry.rbe_parent = parent_90;

  <bb 7> [9.77%]:
  _6 = parent_90->entry.rbe_parent;
  tmp_169->entry.rbe_parent = _6;
  _7 = tmp_169->entry.rbe_parent;
  if (_7 != 0B)
    goto <bb 8>; [70.00%]
  else
    goto <bb 11>; [30.00%]

  <bb 8> [6.84%]:
  _8 = parent_90->entry.rbe_parent;
  _9 = _8->entry.rbe_left;
  if (_9 == parent_90)
    goto <bb 9>; [30.00%]
  else
    goto <bb 10>; [70.00%]

  <bb 9> [2.05%]:
  _10 = parent_90->entry.rbe_parent;
  _10->entry.rbe_left = tmp_169;
  goto <bb 12>; [100.00%]

  <bb 10> [4.79%]:
  _11 = parent_90->entry.rbe_parent;
  _11->entry.rbe_right = tmp_169;
  goto <bb 12>; [100.00%]

  <bb 11> [2.93%]:
  head_123(D)->rbh_root = tmp_169;

  <bb 12> [9.77%]:
  tmp_169->entry.rbe_left = parent_90;
  parent_90->entry.rbe_parent = tmp_169;
  _12 = tmp_169->entry.rbe_parent;
  tmp_178 = parent_90->entry.rbe_right;

  <bb 13> [28.74%]:
  # tmp_93 = PHI <tmp_166(4), tmp_178(12)>
  _13 = tmp_93->entry.rbe_left;
  if (_13 == 0B)
    goto <bb 15>; [30.00%]
  else
    goto <bb 14>; [70.00%]

  <bb 14> [20.12%]:
  _14 = tmp_93->entry.rbe_left;
  _15 = _14->entry.rbe_color;
  if (_15 == 0)
    goto <bb 15>; [97.50%]
  else
    goto <bb 18>; [2.50%]

  <bb 15> [28.24%]:
  _16 = tmp_93->entry.rbe_right;
  if (_16 == 0B)
    goto <bb 17>; [30.00%]
  else
    goto <bb 16>; [70.00%]

  <bb 16> [19.76%]:
  _17 = tmp_93->entry.rbe_right;
  _18 = _17->entry.rbe_color;
  if (_18 == 0)
    goto <bb 17>; [97.50%]
  else
    goto <bb 18>; [2.50%]

  <bb 17> [27.74%]:
  tmp_93->entry.rbe_color = 1;
  parent_181 = parent_90->entry.rbe_parent;
  goto <bb 76>; [100.00%]

  <bb 18> [1.00%]:
  _19 = tmp_93->entry.rbe_right;
  if (_19 == 0B)
    goto <bb 20>; [30.00%]
  else
    goto <bb 19>; [70.00%]

  <bb 19> [0.70%]:
  _20 = tmp_93->entry.rbe_right;
  _21 = _20->entry.rbe_color;
  if (_21 == 0)
    goto <bb 20>; [50.00%]
  else
    goto <bb 30>; [50.00%]

  <bb 20> [0.65%]:
  oleft_182 = tmp_93->entry.rbe_left;
  if (oleft_182 != 0B)
    goto <bb 21>; [70.00%]
  else
    goto <bb 22>; [30.00%]

  <bb 21> [0.45%]:
  oleft_182->entry.rbe_color = 0;

  <bb 22> [0.65%]:
  tmp_93->entry.rbe_color = 1;
  oleft_185 = tmp_93->entry.rbe_left;
  _22 = oleft_185->entry.rbe_right;
  tmp_93->entry.rbe_left = _22;
  _23 = tmp_93->entry.rbe_left;
  if (_23 != 0B)
    goto <bb 23>; [70.00%]
  else
    goto <bb 24>; [30.00%]

  <bb 23> [0.45%]:
  _24 = oleft_185->entry.rbe_right;
  _24->entry.rbe_parent = tmp_93;

  <bb 24> [0.65%]:
  _25 = tmp_93->entry.rbe_parent;
  oleft_185->entry.rbe_parent = _25;
  _26 = oleft_185->entry.rbe_parent;
  if (_26 != 0B)
    goto <bb 25>; [70.00%]
  else
    goto <bb 28>; [30.00%]

  <bb 25> [0.45%]:
  _27 = tmp_93->entry.rbe_parent;
  _28 = _27->entry.rbe_left;
  if (_28 == tmp_93)
    goto <bb 26>; [30.00%]
  else
    goto <bb 27>; [70.00%]

  <bb 26> [0.14%]:
  _29 = tmp_93->entry.rbe_parent;
  _29->entry.rbe_left = oleft_185;
  goto <bb 29>; [100.00%]

  <bb 27> [0.32%]:
  _30 = tmp_93->entry.rbe_parent;
  _30->entry.rbe_right = oleft_185;
  goto <bb 29>; [100.00%]

  <bb 28> [0.19%]:
  head_123(D)->rbh_root = oleft_185;

  <bb 29> [0.65%]:
  oleft_185->entry.rbe_right = tmp_93;
  tmp_93->entry.rbe_parent = oleft_185;
  _31 = oleft_185->entry.rbe_parent;
  tmp_194 = parent_90->entry.rbe_right;

  <bb 30> [1.00%]:
  # tmp_94 = PHI <tmp_93(19), tmp_194(29)>
  _32 = parent_90->entry.rbe_color;
  tmp_94->entry.rbe_color = _32;
  parent_90->entry.rbe_color = 0;
  _33 = tmp_94->entry.rbe_right;
  if (_33 != 0B)
    goto <bb 31>; [70.00%]
  else
    goto <bb 32>; [30.00%]

  <bb 31> [0.70%]:
  _34 = tmp_94->entry.rbe_right;
  _34->entry.rbe_color = 0;

  <bb 32> [1.00%]:
  tmp_198 = parent_90->entry.rbe_right;
  _35 = tmp_198->entry.rbe_left;
  parent_90->entry.rbe_right = _35;
  _36 = parent_90->entry.rbe_right;
  if (_36 != 0B)
    goto <bb 33>; [70.00%]
  else
    goto <bb 34>; [30.00%]

  <bb 33> [0.70%]:
  _37 = tmp_198->entry.rbe_left;
  _37->entry.rbe_parent = parent_90;

  <bb 34> [1.00%]:
  _38 = parent_90->entry.rbe_parent;
  tmp_198->entry.rbe_parent = _38;
  _39 = tmp_198->entry.rbe_parent;
  if (_39 != 0B)
    goto <bb 35>; [70.00%]
  else
    goto <bb 38>; [30.00%]

  <bb 35> [0.70%]:
  _40 = parent_90->entry.rbe_parent;
  _41 = _40->entry.rbe_left;
  if (_41 == parent_90)
    goto <bb 36>; [30.00%]
  else
    goto <bb 37>; [70.00%]

  <bb 36> [0.21%]:
  _42 = parent_90->entry.rbe_parent;
  _42->entry.rbe_left = tmp_198;
  goto <bb 39>; [100.00%]

  <bb 37> [0.49%]:
  _43 = parent_90->entry.rbe_parent;
  _43->entry.rbe_right = tmp_198;
  goto <bb 39>; [100.00%]

  <bb 38> [0.30%]:
  head_123(D)->rbh_root = tmp_198;

  <bb 39> [1.00%]:
  tmp_198->entry.rbe_left = parent_90;
  parent_90->entry.rbe_parent = tmp_198;
  _44 = tmp_198->entry.rbe_parent;
  elm_207 = head_123(D)->rbh_root;
  goto <bb 79>; [100.00%]

  <bb 40> [67.06%]:
  tmp_124 = parent_90->entry.rbe_left;
  _45 = tmp_124->entry.rbe_color;
  if (_45 == 1)
    goto <bb 41>; [34.00%]
  else
    goto <bb 49>; [66.00%]

  <bb 41> [22.80%]:
  tmp_124->entry.rbe_color = 0;
  parent_90->entry.rbe_color = 1;
  tmp_127 = parent_90->entry.rbe_left;
  _46 = tmp_127->entry.rbe_right;
  parent_90->entry.rbe_left = _46;
  _47 = parent_90->entry.rbe_left;
  if (_47 != 0B)
    goto <bb 42>; [70.00%]
  else
    goto <bb 43>; [30.00%]

  <bb 42> [15.96%]:
  _48 = tmp_127->entry.rbe_right;
  _48->entry.rbe_parent = parent_90;

  <bb 43> [22.80%]:
  _49 = parent_90->entry.rbe_parent;
  tmp_127->entry.rbe_parent = _49;
  _50 = tmp_127->entry.rbe_parent;
  if (_50 != 0B)
    goto <bb 44>; [70.00%]
  else
    goto <bb 47>; [30.00%]

  <bb 44> [15.96%]:
  _51 = parent_90->entry.rbe_parent;
  _52 = _51->entry.rbe_left;
  if (_52 == parent_90)
    goto <bb 45>; [30.00%]
  else
    goto <bb 46>; [70.00%]

  <bb 45> [4.79%]:
  _53 = parent_90->entry.rbe_parent;
  _53->entry.rbe_left = tmp_127;
  goto <bb 48>; [100.00%]

  <bb 46> [11.17%]:
  _54 = parent_90->entry.rbe_parent;
  _54->entry.rbe_right = tmp_127;
  goto <bb 48>; [100.00%]

  <bb 47> [6.84%]:
  head_123(D)->rbh_root = tmp_127;

  <bb 48> [22.80%]:
  tmp_127->entry.rbe_right = parent_90;
  parent_90->entry.rbe_parent = tmp_127;
  _55 = tmp_127->entry.rbe_parent;
  tmp_136 = parent_90->entry.rbe_left;

  <bb 49> [67.06%]:
  # tmp_95 = PHI <tmp_124(40), tmp_136(48)>
  _56 = tmp_95->entry.rbe_left;
  if (_56 == 0B)
    goto <bb 51>; [30.00%]
  else
    goto <bb 50>; [70.00%]

  <bb 50> [46.94%]:
  _57 = tmp_95->entry.rbe_left;
  _58 = _57->entry.rbe_color;
  if (_58 == 0)
    goto <bb 51>; [97.50%]
  else
    goto <bb 54>; [2.50%]

  <bb 51> [65.88%]:
  _59 = tmp_95->entry.rbe_right;
  if (_59 == 0B)
    goto <bb 53>; [30.00%]
  else
    goto <bb 52>; [70.00%]

  <bb 52> [46.12%]:
  _60 = tmp_95->entry.rbe_right;
  _61 = _60->entry.rbe_color;
  if (_61 == 0)
    goto <bb 53>; [97.50%]
  else
    goto <bb 54>; [2.50%]

  <bb 53> [64.73%]:
  tmp_95->entry.rbe_color = 1;
  elm_138 = parent_90;
  parent_139 = elm_138->entry.rbe_parent;
  goto <bb 76>; [100.00%]

  <bb 54> [2.33%]:
  _62 = tmp_95->entry.rbe_left;
  if (_62 == 0B)
    goto <bb 56>; [30.00%]
  else
    goto <bb 55>; [70.00%]

  <bb 55> [1.63%]:
  _63 = tmp_95->entry.rbe_left;
  _64 = _63->entry.rbe_color;
  if (_64 == 0)
    goto <bb 56>; [50.00%]
  else
    goto <bb 66>; [50.00%]

  <bb 56> [1.51%]:
  oright_140 = tmp_95->entry.rbe_right;
  if (oright_140 != 0B)
    goto <bb 57>; [70.00%]
  else
    goto <bb 58>; [30.00%]

  <bb 57> [1.06%]:
  oright_140->entry.rbe_color = 0;

  <bb 58> [1.51%]:
  tmp_95->entry.rbe_color = 1;
  oright_143 = tmp_95->entry.rbe_right;
  _65 = oright_143->entry.rbe_left;
  tmp_95->entry.rbe_right = _65;
  _66 = tmp_95->entry.rbe_right;
  if (_66 != 0B)
    goto <bb 59>; [70.00%]
  else
    goto <bb 60>; [30.00%]

  <bb 59> [1.06%]:
  _67 = oright_143->entry.rbe_left;
  _67->entry.rbe_parent = tmp_95;

  <bb 60> [1.51%]:
  _68 = tmp_95->entry.rbe_parent;
  oright_143->entry.rbe_parent = _68;
  _69 = oright_143->entry.rbe_parent;
  if (_69 != 0B)
    goto <bb 61>; [70.00%]
  else
    goto <bb 64>; [30.00%]

  <bb 61> [1.06%]:
  _70 = tmp_95->entry.rbe_parent;
  _71 = _70->entry.rbe_left;
  if (_71 == tmp_95)
    goto <bb 62>; [30.00%]
  else
    goto <bb 63>; [70.00%]

  <bb 62> [0.32%]:
  _72 = tmp_95->entry.rbe_parent;
  _72->entry.rbe_left = oright_143;
  goto <bb 65>; [100.00%]

  <bb 63> [0.74%]:
  _73 = tmp_95->entry.rbe_parent;
  _73->entry.rbe_right = oright_143;
  goto <bb 65>; [100.00%]

  <bb 64> [0.45%]:
  head_123(D)->rbh_root = oright_143;

  <bb 65> [1.51%]:
  oright_143->entry.rbe_left = tmp_95;
  tmp_95->entry.rbe_parent = oright_143;
  _74 = oright_143->entry.rbe_parent;
  tmp_152 = parent_90->entry.rbe_left;

  <bb 66> [2.33%]:
  # tmp_96 = PHI <tmp_95(55), tmp_152(65)>
  _75 = parent_90->entry.rbe_color;
  tmp_96->entry.rbe_color = _75;
  parent_90->entry.rbe_color = 0;
  _76 = tmp_96->entry.rbe_left;
  if (_76 != 0B)
    goto <bb 67>; [70.00%]
  else
    goto <bb 68>; [30.00%]

  <bb 67> [1.63%]:
  _77 = tmp_96->entry.rbe_left;
  _77->entry.rbe_color = 0;

  <bb 68> [2.33%]:
  tmp_156 = parent_90->entry.rbe_left;
  _78 = tmp_156->entry.rbe_right;
  parent_90->entry.rbe_left = _78;
  _79 = parent_90->entry.rbe_left;
  if (_79 != 0B)
    goto <bb 69>; [70.00%]
  else
    goto <bb 70>; [30.00%]

  <bb 69> [1.63%]:
  _80 = tmp_156->entry.rbe_right;
  _80->entry.rbe_parent = parent_90;

  <bb 70> [2.33%]:
  _81 = parent_90->entry.rbe_parent;
  tmp_156->entry.rbe_parent = _81;
  _82 = tmp_156->entry.rbe_parent;
  if (_82 != 0B)
    goto <bb 71>; [70.00%]
  else
    goto <bb 74>; [30.00%]

  <bb 71> [1.63%]:
  _83 = parent_90->entry.rbe_parent;
  _84 = _83->entry.rbe_left;
  if (_84 == parent_90)
    goto <bb 72>; [30.00%]
  else
    goto <bb 73>; [70.00%]

  <bb 72> [0.49%]:
  _85 = parent_90->entry.rbe_parent;
  _85->entry.rbe_left = tmp_156;
  goto <bb 75>; [100.00%]

  <bb 73> [1.14%]:
  _86 = parent_90->entry.rbe_parent;
  _86->entry.rbe_right = tmp_156;
  goto <bb 75>; [100.00%]

  <bb 74> [0.70%]:
  head_123(D)->rbh_root = tmp_156;

  <bb 75> [2.33%]:
  tmp_156->entry.rbe_right = parent_90;
  parent_90->entry.rbe_parent = tmp_156;
  _87 = tmp_156->entry.rbe_parent;
  elm_165 = head_123(D)->rbh_root;
  goto <bb 79>; [100.00%]

  <bb 76> [92.47%]:
  # parent_180 = PHI <parent_139(53), parent_181(17)>
  # elm_209 = PHI <elm_138(53), parent_90(17)>

  <bb 82> [100.00%]:
  # parent_90 = PHI <parent_180(76), parent_120(D)(2)>
  # elm_91 = PHI <elm_209(76), elm_121(D)(2)>
  if (elm_91 == 0B)
    goto <bb 78>; [30.00%]
  else
    goto <bb 77>; [70.00%]

  <bb 77> [70.00%]:
  _88 = elm_91->entry.rbe_color;
  if (_88 == 0)
    goto <bb 78>; [97.50%]
  else
    goto <bb 79>; [2.50%]

  <bb 78> [98.25%]:
  _89 = head_123(D)->rbh_root;
  if (_89 != elm_91)
    goto <bb 3>; [97.50%]
  else
    goto <bb 79>; [2.50%]

  <bb 79> [7.53%]:
  # elm_92 = PHI <elm_207(39), elm_165(75), elm_91(77), elm_91(78)>
  if (elm_92 != 0B)
    goto <bb 80>; [73.26%]
  else
    goto <bb 81>; [26.74%]

  <bb 80> [5.52%]:
  elm_92->entry.rbe_color = 0;

  <bb 81> [7.53%]:
  return;

}



;; Function winlinks_RB_INSERT (winlinks_RB_INSERT, funcdef_no=53, decl_uid=4323, cgraph_uid=53, symbol_order=56)



 local analysis of winlinks_RB_INSERT
   scanning: tmp_13 = head_12(D)->rbh_root;
    Indirect ref read is not const
  scanning: parent_24 = tmp_2;
  scanning: comp_26 = winlink_cmp (elm_14(D), parent_24);
  scanning: if (comp_26 < 0)
  scanning: tmp_29 = tmp_2->entry.rbe_left;
    Indirect ref read is not const
  scanning: if (comp_26 > 0)
  scanning: tmp_28 = tmp_2->entry.rbe_right;
    Indirect ref read is not const
  scanning: _27 = tmp_2;
  scanning: if (tmp_2 != 0B)
  scanning: elm_14(D)->entry.rbe_parent = parent_3;
    Indirect ref write is not const/pure
  scanning: elm_14(D)->entry.rbe_right = 0B;
    Indirect ref write is not const/pure
  scanning: _1 = elm_14(D)->entry.rbe_right;
    Indirect ref read is not const
  scanning: elm_14(D)->entry.rbe_left = _1;
    Indirect ref write is not const/pure
  scanning: elm_14(D)->entry.rbe_color = 1;
    Indirect ref write is not const/pure
  scanning: if (parent_3 != 0B)
  scanning: if (comp_4 < 0)
  scanning: parent_3->entry.rbe_left = elm_14(D);
    Indirect ref write is not const/pure
  scanning: parent_3->entry.rbe_right = elm_14(D);
    Indirect ref write is not const/pure
  scanning: head_12(D)->rbh_root = elm_14(D);
    Indirect ref write is not const/pure
  scanning: winlinks_RB_INSERT_COLOR (head_12(D), elm_14(D));
  scanning: return _5;
Function is locally looping.
winlinks_RB_INSERT (struct winlinks * head, struct winlink * elm)
{
  int comp;
  struct winlink * parent;
  struct winlink * tmp;
  struct winlink * _1;
  struct winlink * _5;
  struct winlink * _27;

  <bb 2> [11.94%]:
  tmp_13 = head_12(D)->rbh_root;
  goto <bb 16>; [100.00%]

  <bb 3> [92.50%]:
  parent_24 = tmp_2;
  comp_26 = winlink_cmp (elm_14(D), parent_24);
  if (comp_26 < 0)
    goto <bb 4>; [36.00%]
  else
    goto <bb 5>; [64.00%]

  <bb 4> [33.30%]:
  tmp_29 = tmp_2->entry.rbe_left;
  goto <bb 8>; [100.00%]

  <bb 5> [59.20%]:
  if (comp_26 > 0)
    goto <bb 6>; [92.50%]
  else
    goto <bb 7>; [7.50%]

  <bb 6> [54.76%]:
  tmp_28 = tmp_2->entry.rbe_right;
  goto <bb 8>; [100.00%]

  <bb 7> [4.44%]:
  _27 = tmp_2;
  goto <bb 15>; [100.00%]

  <bb 8> [88.06%]:
  # tmp_9 = PHI <tmp_28(6), tmp_29(4)>
  # parent_10 = PHI <parent_24(6), parent_24(4)>
  # comp_23 = PHI <comp_26(6), comp_26(4)>

  <bb 16> [100.00%]:
  # tmp_2 = PHI <tmp_9(8), tmp_13(2)>
  # parent_3 = PHI <parent_10(8), 0B(2)>
  # comp_4 = PHI <comp_23(8), 0(2)>
  if (tmp_2 != 0B)
    goto <bb 3>; [92.50%]
  else
    goto <bb 9>; [7.50%]

  <bb 9> [7.50%]:
  elm_14(D)->entry.rbe_parent = parent_3;
  elm_14(D)->entry.rbe_right = 0B;
  _1 = elm_14(D)->entry.rbe_right;
  elm_14(D)->entry.rbe_left = _1;
  elm_14(D)->entry.rbe_color = 1;
  if (parent_3 != 0B)
    goto <bb 10>; [70.00%]
  else
    goto <bb 13>; [30.00%]

  <bb 10> [5.25%]:
  if (comp_4 < 0)
    goto <bb 11>; [36.00%]
  else
    goto <bb 12>; [64.00%]

  <bb 11> [1.89%]:
  parent_3->entry.rbe_left = elm_14(D);
  goto <bb 14>; [100.00%]

  <bb 12> [3.36%]:
  parent_3->entry.rbe_right = elm_14(D);
  goto <bb 14>; [100.00%]

  <bb 13> [2.25%]:
  head_12(D)->rbh_root = elm_14(D);

  <bb 14> [7.50%]:
  winlinks_RB_INSERT_COLOR (head_12(D), elm_14(D));

  <bb 15> [11.94%]:
  # _5 = PHI <tmp_2(7), 0B(14)>
  return _5;

}



;; Function winlinks_RB_REMOVE (winlinks_RB_REMOVE, funcdef_no=54, decl_uid=4333, cgraph_uid=54, symbol_order=57)



 local analysis of winlinks_RB_REMOVE
   scanning: _1 = elm_28(D)->entry.rbe_left;
    Indirect ref read is not const
  scanning: if (_1 == 0B)
  scanning: child_52 = elm_28(D)->entry.rbe_right;
    Indirect ref read is not const
  scanning: _2 = elm_28(D)->entry.rbe_right;
    Indirect ref read is not const
  scanning: if (_2 == 0B)
  scanning: child_51 = elm_28(D)->entry.rbe_left;
    Indirect ref read is not const
  scanning: elm_31 = elm_28(D)->entry.rbe_right;
    Indirect ref read is not const
  scanning: left_32 = elm_14->entry.rbe_left;
    Indirect ref read is not const
  scanning: if (left_32 != 0B)
  scanning: child_33 = elm_14->entry.rbe_right;
    Indirect ref read is not const
  scanning: parent_34 = elm_14->entry.rbe_parent;
    Indirect ref read is not const
  scanning: color_35 = elm_14->entry.rbe_color;
    Indirect ref read is not const
  scanning: if (child_33 != 0B)
  scanning: child_33->entry.rbe_parent = parent_34;
    Indirect ref write is not const/pure
  scanning: if (parent_34 != 0B)
  scanning: _3 = parent_34->entry.rbe_left;
    Indirect ref read is not const
  scanning: if (_3 == elm_14)
  scanning: parent_34->entry.rbe_left = child_33;
    Indirect ref write is not const/pure
  scanning: parent_34->entry.rbe_right = child_33;
    Indirect ref write is not const/pure
  scanning: head_37(D)->rbh_root = child_33;
    Indirect ref write is not const/pure
  scanning: _4 = elm_14->entry.rbe_parent;
    Indirect ref read is not const
  scanning: if (_4 == elm_28(D))
  scanning: parent_41 = elm_14;
  scanning: elm_14->entry = elm_28(D)->entry;
    Indirect ref write is not const/pure
    Indirect ref read is not const
  scanning: _5 = elm_28(D)->entry.rbe_parent;
    Indirect ref read is not const
  scanning: if (_5 != 0B)
  scanning: _6 = elm_28(D)->entry.rbe_parent;
    Indirect ref read is not const
  scanning: _7 = _6->entry.rbe_left;
    Indirect ref read is not const
  scanning: if (_7 == elm_28(D))
  scanning: _8 = elm_28(D)->entry.rbe_parent;
    Indirect ref read is not const
  scanning: _8->entry.rbe_left = elm_14;
    Indirect ref write is not const/pure
  scanning: _9 = elm_28(D)->entry.rbe_parent;
    Indirect ref read is not const
  scanning: _9->entry.rbe_right = elm_14;
    Indirect ref write is not const/pure
  scanning: head_37(D)->rbh_root = elm_14;
    Indirect ref write is not const/pure
  scanning: _10 = elm_28(D)->entry.rbe_left;
    Indirect ref read is not const
  scanning: _10->entry.rbe_parent = elm_14;
    Indirect ref write is not const/pure
  scanning: _11 = elm_28(D)->entry.rbe_right;
    Indirect ref read is not const
  scanning: if (_11 != 0B)
  scanning: _12 = elm_28(D)->entry.rbe_right;
    Indirect ref read is not const
  scanning: _12->entry.rbe_parent = elm_14;
    Indirect ref write is not const/pure
  scanning: if (parent_17 != 0B)
  scanning: left_49 = left_20->entry.rbe_parent;
    Indirect ref read is not const
  scanning: if (left_49 != 0B)
  scanning: parent_53 = elm_28(D)->entry.rbe_parent;
    Indirect ref read is not const
  scanning: color_54 = elm_28(D)->entry.rbe_color;
    Indirect ref read is not const
  scanning: if (child_15 != 0B)
  scanning: child_15->entry.rbe_parent = parent_53;
    Indirect ref write is not const/pure
  scanning: if (parent_53 != 0B)
  scanning: _13 = parent_53->entry.rbe_left;
    Indirect ref read is not const
  scanning: if (_13 == elm_28(D))
  scanning: parent_53->entry.rbe_left = child_15;
    Indirect ref write is not const/pure
  scanning: parent_53->entry.rbe_right = child_15;
    Indirect ref write is not const/pure
  scanning: head_37(D)->rbh_root = child_15;
    Indirect ref write is not const/pure
  scanning: color [30.61%]:
  scanning: if (color_19 == 0)
  scanning: winlinks_RB_REMOVE_COLOR (head_37(D), parent_18, child_16);
  scanning: return elm_28(D);
Function is locally looping.
winlinks_RB_REMOVE (struct winlinks * head, struct winlink * elm)
{
  struct winlink * left;
  int color;
  struct winlink * old;
  struct winlink * parent;
  struct winlink * child;
  struct winlink * _1;
  struct winlink * _2;
  struct winlink * _3;
  struct winlink * _4;
  struct winlink * _5;
  struct winlink * _6;
  struct winlink * _7;
  struct winlink * _8;
  struct winlink * _9;
  struct winlink * _10;
  struct winlink * _11;
  struct winlink * _12;
  struct winlink * _13;

  <bb 2> [30.61%]:
  _1 = elm_28(D)->entry.rbe_left;
  if (_1 == 0B)
    goto <bb 3>; [30.00%]
  else
    goto <bb 4>; [70.00%]

  <bb 3> [9.18%]:
  child_52 = elm_28(D)->entry.rbe_right;
  goto <bb 26>; [100.00%]

  <bb 4> [21.43%]:
  _2 = elm_28(D)->entry.rbe_right;
  if (_2 == 0B)
    goto <bb 5>; [30.00%]
  else
    goto <bb 6>; [70.00%]

  <bb 5> [6.43%]:
  child_51 = elm_28(D)->entry.rbe_left;
  goto <bb 26>; [100.00%]

  <bb 6> [15.00%]:
  elm_31 = elm_28(D)->entry.rbe_right;

  <bb 7> [100.00%]:
  # elm_14 = PHI <elm_31(6), left_32(38)>
  left_32 = elm_14->entry.rbe_left;
  if (left_32 != 0B)
    goto <bb 38>; [85.00%]
  else
    goto <bb 8>; [15.00%]

  <bb 38> [85.00%]:
  goto <bb 7>; [100.00%]

  <bb 8> [15.00%]:
  child_33 = elm_14->entry.rbe_right;
  parent_34 = elm_14->entry.rbe_parent;
  color_35 = elm_14->entry.rbe_color;
  if (child_33 != 0B)
    goto <bb 9>; [70.00%]
  else
    goto <bb 10>; [30.00%]

  <bb 9> [10.50%]:
  child_33->entry.rbe_parent = parent_34;

  <bb 10> [15.00%]:
  if (parent_34 != 0B)
    goto <bb 11>; [70.00%]
  else
    goto <bb 14>; [30.00%]

  <bb 11> [10.50%]:
  _3 = parent_34->entry.rbe_left;
  if (_3 == elm_14)
    goto <bb 12>; [30.00%]
  else
    goto <bb 13>; [70.00%]

  <bb 12> [3.15%]:
  parent_34->entry.rbe_left = child_33;
  goto <bb 15>; [100.00%]

  <bb 13> [7.35%]:
  parent_34->entry.rbe_right = child_33;
  goto <bb 15>; [100.00%]

  <bb 14> [4.50%]:
  head_37(D)->rbh_root = child_33;

  <bb 15> [15.00%]:
  _4 = elm_14->entry.rbe_parent;
  if (_4 == elm_28(D))
    goto <bb 16>; [30.00%]
  else
    goto <bb 17>; [70.00%]

  <bb 16> [4.50%]:
  parent_41 = elm_14;

  <bb 17> [15.00%]:
  # parent_17 = PHI <parent_34(15), elm_14(16)>
  elm_14->entry = elm_28(D)->entry;
  _5 = elm_28(D)->entry.rbe_parent;
  if (_5 != 0B)
    goto <bb 18>; [70.00%]
  else
    goto <bb 21>; [30.00%]

  <bb 18> [10.50%]:
  _6 = elm_28(D)->entry.rbe_parent;
  _7 = _6->entry.rbe_left;
  if (_7 == elm_28(D))
    goto <bb 19>; [30.00%]
  else
    goto <bb 20>; [70.00%]

  <bb 19> [3.15%]:
  _8 = elm_28(D)->entry.rbe_parent;
  _8->entry.rbe_left = elm_14;
  goto <bb 22>; [100.00%]

  <bb 20> [7.35%]:
  _9 = elm_28(D)->entry.rbe_parent;
  _9->entry.rbe_right = elm_14;
  goto <bb 22>; [100.00%]

  <bb 21> [4.50%]:
  head_37(D)->rbh_root = elm_14;

  <bb 22> [15.00%]:
  _10 = elm_28(D)->entry.rbe_left;
  _10->entry.rbe_parent = elm_14;
  _11 = elm_28(D)->entry.rbe_right;
  if (_11 != 0B)
    goto <bb 23>; [70.00%]
  else
    goto <bb 24>; [30.00%]

  <bb 23> [10.50%]:
  _12 = elm_28(D)->entry.rbe_right;
  _12->entry.rbe_parent = elm_14;

  <bb 24> [15.00%]:
  if (parent_17 != 0B)
    goto <bb 36>; [70.00%]
  else
    goto <bb 33> (color); [30.00%]

  <bb 36> [10.50%]:

  <bb 25> [70.00%]:
  # left_20 = PHI <parent_17(36), left_49(37)>
  left_49 = left_20->entry.rbe_parent;
  if (left_49 != 0B)
    goto <bb 37>; [85.00%]
  else
    goto <bb 33> (color); [15.00%]

  <bb 37> [59.50%]:
  goto <bb 25>; [100.00%]

  <bb 26> [15.61%]:
  # child_15 = PHI <child_52(3), child_51(5)>
  parent_53 = elm_28(D)->entry.rbe_parent;
  color_54 = elm_28(D)->entry.rbe_color;
  if (child_15 != 0B)
    goto <bb 27>; [70.00%]
  else
    goto <bb 28>; [30.00%]

  <bb 27> [10.93%]:
  child_15->entry.rbe_parent = parent_53;

  <bb 28> [15.61%]:
  if (parent_53 != 0B)
    goto <bb 29>; [70.00%]
  else
    goto <bb 32>; [30.00%]

  <bb 29> [10.93%]:
  _13 = parent_53->entry.rbe_left;
  if (_13 == elm_28(D))
    goto <bb 30>; [30.00%]
  else
    goto <bb 31>; [70.00%]

  <bb 30> [3.28%]:
  parent_53->entry.rbe_left = child_15;
  goto <bb 33> (color); [100.00%]

  <bb 31> [7.65%]:
  parent_53->entry.rbe_right = child_15;
  goto <bb 33> (color); [100.00%]

  <bb 32> [4.68%]:
  head_37(D)->rbh_root = child_15;

  # child_16 = PHI <child_33(25), child_15(31), child_15(32), child_33(24), child_15(30)>
  # parent_18 = PHI <parent_17(25), parent_53(31), parent_53(32), parent_17(24), parent_53(30)>
  # color_19 = PHI <color_35(25), color_54(31), color_54(32), color_35(24), color_54(30)>
color [30.61%]:
  if (color_19 == 0)
    goto <bb 34>; [36.64%]
  else
    goto <bb 35>; [63.36%]

  <bb 34> [11.22%]:
  winlinks_RB_REMOVE_COLOR (head_37(D), parent_18, child_16);

  <bb 35> [30.61%]:
  return elm_28(D);

}



;; Function winlinks_RB_FIND (winlinks_RB_FIND, funcdef_no=55, decl_uid=4348, cgraph_uid=55, symbol_order=58)



 local analysis of winlinks_RB_FIND
   scanning: tmp_7 = head_6(D)->rbh_root;
    Indirect ref read is not const
  scanning: comp_11 = winlink_cmp (elm_9(D), tmp_1);
  scanning: if (comp_11 < 0)
  scanning: tmp_14 = tmp_1->entry.rbe_left;
    Indirect ref read is not const
  scanning: if (comp_11 > 0)
  scanning: tmp_13 = tmp_1->entry.rbe_right;
    Indirect ref read is not const
  scanning: _12 = tmp_1;
  scanning: if (tmp_1 != 0B)
  scanning: return _2;
;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 10 9
;;
;; Loop 1
;;  header 10, latch 8
;;  depth 1, outer 0
;;  nodes: 10 8 6 4 3 5
;; 2 succs { 10 }
;; 3 succs { 4 5 }
;; 4 succs { 8 }
;; 5 succs { 6 7 }
;; 6 succs { 8 }
;; 7 succs { 9 }
;; 8 succs { 10 }
;; 10 succs { 3 9 }
;; 9 succs { 1 }
    can not prove finiteness of loop 1
Function is locally looping.
Function is locally pure.
Function found to be looping pure: winlinks_RB_FIND
Declaration updated to be looping pure: winlinks_RB_FIND
winlinks_RB_FIND (struct winlinks * head, struct winlink * elm)
{
  int comp;
  struct winlink * tmp;
  struct winlink * _2;
  struct winlink * _12;

  <bb 2> [11.94%]:
  tmp_7 = head_6(D)->rbh_root;
  goto <bb 9>; [100.00%]

  <bb 3> [92.50%]:
  comp_11 = winlink_cmp (elm_9(D), tmp_1);
  if (comp_11 < 0)
    goto <bb 4>; [36.00%]
  else
    goto <bb 5>; [64.00%]

  <bb 4> [33.30%]:
  tmp_14 = tmp_1->entry.rbe_left;
  goto <bb 8>; [100.00%]

  <bb 5> [59.20%]:
  if (comp_11 > 0)
    goto <bb 6>; [92.50%]
  else
    goto <bb 7>; [7.50%]

  <bb 6> [54.76%]:
  tmp_13 = tmp_1->entry.rbe_right;
  goto <bb 8>; [100.00%]

  <bb 7> [4.44%]:
  _12 = tmp_1;
  goto <bb 10>; [100.00%]

  <bb 8> [88.06%]:
  # tmp_8 = PHI <tmp_13(6), tmp_14(4)>

  <bb 9> [100.00%]:
  # tmp_1 = PHI <tmp_8(8), tmp_7(2)>
  if (tmp_1 != 0B)
    goto <bb 3>; [92.50%]
  else
    goto <bb 10>; [7.50%]

  <bb 10> [11.94%]:
  # _2 = PHI <tmp_1(7), 0B(9)>
  return _2;

}



;; Function winlinks_RB_NFIND (winlinks_RB_NFIND, funcdef_no=56, decl_uid=4357, cgraph_uid=56, symbol_order=59)



 local analysis of winlinks_RB_NFIND
   scanning: tmp_8 = head_7(D)->rbh_root;
    Indirect ref read is not const
  scanning: comp_13 = winlink_cmp (elm_11(D), tmp_1);
  scanning: if (comp_13 < 0)
  scanning: tmp_17 = tmp_1->entry.rbe_left;
    Indirect ref read is not const
  scanning: if (comp_13 > 0)
  scanning: tmp_15 = tmp_1->entry.rbe_right;
    Indirect ref read is not const
  scanning: _14 = tmp_1;
  scanning: if (tmp_1 != 0B)
  scanning: _10 = res_2;
  scanning: return _3;
;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 11 9 10
;;
;; Loop 1
;;  header 11, latch 8
;;  depth 1, outer 0
;;  nodes: 11 8 6 4 3 5
;; 2 succs { 11 }
;; 3 succs { 4 5 }
;; 4 succs { 8 }
;; 5 succs { 6 7 }
;; 6 succs { 8 }
;; 7 succs { 10 }
;; 8 succs { 11 }
;; 11 succs { 3 9 }
;; 9 succs { 10 }
;; 10 succs { 1 }
    can not prove finiteness of loop 1
Function is locally looping.
Function is locally pure.
Function found to be looping pure: winlinks_RB_NFIND
Declaration updated to be looping pure: winlinks_RB_NFIND
winlinks_RB_NFIND (struct winlinks * head, struct winlink * elm)
{
  int comp;
  struct winlink * res;
  struct winlink * tmp;
  struct winlink * _3;
  struct winlink * _10;
  struct winlink * _14;

  <bb 2> [11.94%]:
  tmp_8 = head_7(D)->rbh_root;
  goto <bb 9>; [100.00%]

  <bb 3> [92.50%]:
  comp_13 = winlink_cmp (elm_11(D), tmp_1);
  if (comp_13 < 0)
    goto <bb 4>; [36.00%]
  else
    goto <bb 5>; [64.00%]

  <bb 4> [33.30%]:
  tmp_17 = tmp_1->entry.rbe_left;
  goto <bb 8>; [100.00%]

  <bb 5> [59.20%]:
  if (comp_13 > 0)
    goto <bb 6>; [92.50%]
  else
    goto <bb 7>; [7.50%]

  <bb 6> [54.76%]:
  tmp_15 = tmp_1->entry.rbe_right;
  goto <bb 8>; [100.00%]

  <bb 7> [4.44%]:
  _14 = tmp_1;
  goto <bb 11>; [100.00%]

  <bb 8> [88.06%]:
  # tmp_9 = PHI <tmp_15(6), tmp_17(4)>
  # res_16 = PHI <res_2(6), tmp_1(4)>

  <bb 9> [100.00%]:
  # tmp_1 = PHI <tmp_9(8), tmp_8(2)>
  # res_2 = PHI <res_16(8), 0B(2)>
  if (tmp_1 != 0B)
    goto <bb 3>; [92.50%]
  else
    goto <bb 10>; [7.50%]

  <bb 10> [7.50%]:
  _10 = res_2;

  <bb 11> [11.94%]:
  # _3 = PHI <tmp_1(7), res_2(10)>
  return _3;

}



;; Function winlinks_RB_NEXT (winlinks_RB_NEXT, funcdef_no=57, decl_uid=4366, cgraph_uid=57, symbol_order=60)



 local analysis of winlinks_RB_NEXT
   scanning: _1 = elm_13(D)->entry.rbe_right;
    Indirect ref read is not const
  scanning: if (_1 != 0B)
  scanning: elm_17 = elm_13(D)->entry.rbe_right;
    Indirect ref read is not const
  scanning: elm_18 = elm_9->entry.rbe_left;
    Indirect ref read is not const
  scanning: _2 = elm_9->entry.rbe_left;
    Indirect ref read is not const
  scanning: if (_2 != 0B)
  scanning: _3 = elm_13(D)->entry.rbe_parent;
    Indirect ref read is not const
  scanning: if (_3 != 0B)
  scanning: _4 = elm_13(D)->entry.rbe_parent;
    Indirect ref read is not const
  scanning: _5 = _4->entry.rbe_left;
    Indirect ref read is not const
  scanning: if (_5 == elm_13(D))
  scanning: elm_14 = elm_13(D)->entry.rbe_parent;
    Indirect ref read is not const
  scanning: elm_15 = elm_10->entry.rbe_parent;
    Indirect ref read is not const
  scanning: _6 = elm_10->entry.rbe_parent;
    Indirect ref read is not const
  scanning: if (_6 != 0B)
  scanning: _7 = elm_10->entry.rbe_parent;
    Indirect ref read is not const
  scanning: _8 = _7->entry.rbe_right;
    Indirect ref read is not const
  scanning: if (_8 == elm_10)
  scanning: elm_16 = elm_10->entry.rbe_parent;
    Indirect ref read is not const
  scanning: return elm_11;
;; 3 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 11 7 8 9 15 12 13 14
;;
;; Loop 2
;;  header 5, latch 4
;;  depth 1, outer 0
;;  nodes: 5 4
;;
;; Loop 1
;;  header 15, latch 9
;;  depth 1, outer 0
;;  nodes: 15 9 12
;; 2 succs { 3 6 }
;; 3 succs { 5 }
;; 4 succs { 5 }
;; 5 succs { 4 14 }
;; 6 succs { 7 11 }
;; 11 succs { 15 }
;; 7 succs { 8 11 }
;; 8 succs { 14 }
;; 9 succs { 15 }
;; 15 succs { 12 13 }
;; 12 succs { 9 13 }
;; 13 succs { 14 }
;; 14 succs { 1 }
    can not prove finiteness of loop 2
Function is locally looping.
Function is locally pure.
Function found to be looping pure: winlinks_RB_NEXT
Declaration updated to be looping pure: winlinks_RB_NEXT
winlinks_RB_NEXT (struct winlink * elm)
{
  struct winlink * _1;
  struct winlink * _2;
  struct winlink * _3;
  struct winlink * _4;
  struct winlink * _5;
  struct winlink * _6;
  struct winlink * _7;
  struct winlink * _8;

  <bb 2> [21.43%]:
  _1 = elm_13(D)->entry.rbe_right;
  if (_1 != 0B)
    goto <bb 3>; [70.00%]
  else
    goto <bb 6>; [30.00%]

  <bb 3> [15.00%]:
  elm_17 = elm_13(D)->entry.rbe_right;
  goto <bb 5>; [100.00%]

  <bb 4> [85.00%]:
  elm_18 = elm_9->entry.rbe_left;

  <bb 5> [100.00%]:
  # elm_9 = PHI <elm_17(3), elm_18(4)>
  _2 = elm_9->entry.rbe_left;
  if (_2 != 0B)
    goto <bb 4>; [85.00%]
  else
    goto <bb 14>; [15.00%]

  <bb 6> [6.43%]:
  _3 = elm_13(D)->entry.rbe_parent;
  if (_3 != 0B)
    goto <bb 7>; [70.00%]
  else
    goto <bb 11>; [30.00%]

  <bb 11> [5.23%]:
  # elm_20 = PHI <elm_13(D)(6), elm_13(D)(7)>
  goto <bb 15>; [100.00%]

  <bb 7> [4.50%]:
  _4 = elm_13(D)->entry.rbe_parent;
  _5 = _4->entry.rbe_left;
  if (_5 == elm_13(D))
    goto <bb 8>; [26.74%]
  else
    goto <bb 11>; [73.26%]

  <bb 8> [1.20%]:
  elm_14 = elm_13(D)->entry.rbe_parent;
  goto <bb 14>; [100.00%]

  <bb 9> [30.97%]:
  elm_15 = elm_10->entry.rbe_parent;

  <bb 15> [36.19%]:
  # elm_10 = PHI <elm_20(11), elm_15(9)>
  _6 = elm_10->entry.rbe_parent;
  if (_6 != 0B)
    goto <bb 12>; [92.50%]
  else
    goto <bb 13>; [7.50%]

  <bb 12> [33.48%]:
  _7 = elm_10->entry.rbe_parent;
  _8 = _7->entry.rbe_right;
  if (_8 == elm_10)
    goto <bb 9>; [92.50%]
  else
    goto <bb 13>; [7.50%]

  <bb 13> [5.23%]:
  elm_16 = elm_10->entry.rbe_parent;

  <bb 14> [21.43%]:
  # elm_11 = PHI <elm_9(5), elm_14(8), elm_16(13)>
  return elm_11;

}



;; Function winlinks_RB_PREV (winlinks_RB_PREV, funcdef_no=58, decl_uid=4375, cgraph_uid=58, symbol_order=61)



 local analysis of winlinks_RB_PREV
   scanning: _1 = elm_13(D)->entry.rbe_left;
    Indirect ref read is not const
  scanning: if (_1 != 0B)
  scanning: elm_17 = elm_13(D)->entry.rbe_left;
    Indirect ref read is not const
  scanning: elm_18 = elm_9->entry.rbe_right;
    Indirect ref read is not const
  scanning: _2 = elm_9->entry.rbe_right;
    Indirect ref read is not const
  scanning: if (_2 != 0B)
  scanning: _3 = elm_13(D)->entry.rbe_parent;
    Indirect ref read is not const
  scanning: if (_3 != 0B)
  scanning: _4 = elm_13(D)->entry.rbe_parent;
    Indirect ref read is not const
  scanning: _5 = _4->entry.rbe_right;
    Indirect ref read is not const
  scanning: if (_5 == elm_13(D))
  scanning: elm_14 = elm_13(D)->entry.rbe_parent;
    Indirect ref read is not const
  scanning: elm_15 = elm_10->entry.rbe_parent;
    Indirect ref read is not const
  scanning: _6 = elm_10->entry.rbe_parent;
    Indirect ref read is not const
  scanning: if (_6 != 0B)
  scanning: _7 = elm_10->entry.rbe_parent;
    Indirect ref read is not const
  scanning: _8 = _7->entry.rbe_left;
    Indirect ref read is not const
  scanning: if (_8 == elm_10)
  scanning: elm_16 = elm_10->entry.rbe_parent;
    Indirect ref read is not const
  scanning: return elm_11;
;; 3 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 11 7 8 9 15 12 13 14
;;
;; Loop 2
;;  header 5, latch 4
;;  depth 1, outer 0
;;  nodes: 5 4
;;
;; Loop 1
;;  header 15, latch 9
;;  depth 1, outer 0
;;  nodes: 15 9 12
;; 2 succs { 3 6 }
;; 3 succs { 5 }
;; 4 succs { 5 }
;; 5 succs { 4 14 }
;; 6 succs { 7 11 }
;; 11 succs { 15 }
;; 7 succs { 8 11 }
;; 8 succs { 14 }
;; 9 succs { 15 }
;; 15 succs { 12 13 }
;; 12 succs { 9 13 }
;; 13 succs { 14 }
;; 14 succs { 1 }
    can not prove finiteness of loop 2
Function is locally looping.
Function is locally pure.
Function found to be looping pure: winlinks_RB_PREV
Declaration updated to be looping pure: winlinks_RB_PREV
winlinks_RB_PREV (struct winlink * elm)
{
  struct winlink * _1;
  struct winlink * _2;
  struct winlink * _3;
  struct winlink * _4;
  struct winlink * _5;
  struct winlink * _6;
  struct winlink * _7;
  struct winlink * _8;

  <bb 2> [21.43%]:
  _1 = elm_13(D)->entry.rbe_left;
  if (_1 != 0B)
    goto <bb 3>; [70.00%]
  else
    goto <bb 6>; [30.00%]

  <bb 3> [15.00%]:
  elm_17 = elm_13(D)->entry.rbe_left;
  goto <bb 5>; [100.00%]

  <bb 4> [85.00%]:
  elm_18 = elm_9->entry.rbe_right;

  <bb 5> [100.00%]:
  # elm_9 = PHI <elm_17(3), elm_18(4)>
  _2 = elm_9->entry.rbe_right;
  if (_2 != 0B)
    goto <bb 4>; [85.00%]
  else
    goto <bb 14>; [15.00%]

  <bb 6> [6.43%]:
  _3 = elm_13(D)->entry.rbe_parent;
  if (_3 != 0B)
    goto <bb 7>; [70.00%]
  else
    goto <bb 11>; [30.00%]

  <bb 11> [5.23%]:
  # elm_20 = PHI <elm_13(D)(6), elm_13(D)(7)>
  goto <bb 15>; [100.00%]

  <bb 7> [4.50%]:
  _4 = elm_13(D)->entry.rbe_parent;
  _5 = _4->entry.rbe_right;
  if (_5 == elm_13(D))
    goto <bb 8>; [26.74%]
  else
    goto <bb 11>; [73.26%]

  <bb 8> [1.20%]:
  elm_14 = elm_13(D)->entry.rbe_parent;
  goto <bb 14>; [100.00%]

  <bb 9> [30.97%]:
  elm_15 = elm_10->entry.rbe_parent;

  <bb 15> [36.19%]:
  # elm_10 = PHI <elm_20(11), elm_15(9)>
  _6 = elm_10->entry.rbe_parent;
  if (_6 != 0B)
    goto <bb 12>; [92.50%]
  else
    goto <bb 13>; [7.50%]

  <bb 12> [33.48%]:
  _7 = elm_10->entry.rbe_parent;
  _8 = _7->entry.rbe_left;
  if (_8 == elm_10)
    goto <bb 9>; [92.50%]
  else
    goto <bb 13>; [7.50%]

  <bb 13> [5.23%]:
  elm_16 = elm_10->entry.rbe_parent;

  <bb 14> [21.43%]:
  # elm_11 = PHI <elm_9(5), elm_14(8), elm_16(13)>
  return elm_11;

}



;; Function winlinks_RB_MINMAX (winlinks_RB_MINMAX, funcdef_no=59, decl_uid=4385, cgraph_uid=59, symbol_order=62)



 local analysis of winlinks_RB_MINMAX
   scanning: tmp_5 = head_4(D)->rbh_root;
    Indirect ref read is not const
  scanning: parent_8 = tmp_1;
  scanning: if (val_9(D) < 0)
  scanning: tmp_11 = tmp_1->entry.rbe_left;
    Indirect ref read is not const
  scanning: tmp_10 = tmp_1->entry.rbe_right;
    Indirect ref read is not const
  scanning: if (tmp_1 != 0B)
  scanning: _7 = parent_2;
  scanning: return parent_2;
;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 8 7
;;
;; Loop 1
;;  header 8, latch 6
;;  depth 1, outer 0
;;  nodes: 8 6 5 4 3
;; 2 succs { 8 }
;; 3 succs { 4 5 }
;; 4 succs { 6 }
;; 5 succs { 6 }
;; 6 succs { 8 }
;; 8 succs { 3 7 }
;; 7 succs { 1 }
    can not prove finiteness of loop 1
Function is locally looping.
Function is locally pure.
Function found to be looping pure: winlinks_RB_MINMAX
Declaration updated to be looping pure: winlinks_RB_MINMAX
winlinks_RB_MINMAX (struct winlinks * head, int val)
{
  struct winlink * parent;
  struct winlink * tmp;
  struct winlink * _7;

  <bb 2> [15.00%]:
  tmp_5 = head_4(D)->rbh_root;
  goto <bb 8>; [100.00%]

  <bb 3> [85.00%]:
  parent_8 = tmp_1;
  if (val_9(D) < 0)
    goto <bb 4>; [36.00%]
  else
    goto <bb 5>; [64.00%]

  <bb 4> [30.60%]:
  tmp_11 = tmp_1->entry.rbe_left;
  goto <bb 6>; [100.00%]

  <bb 5> [54.40%]:
  tmp_10 = tmp_1->entry.rbe_right;

  <bb 6> [85.00%]:
  # tmp_6 = PHI <tmp_10(5), tmp_11(4)>
  # parent_12 = PHI <parent_8(5), parent_8(4)>

  <bb 8> [100.00%]:
  # tmp_1 = PHI <tmp_6(6), tmp_5(2)>
  # parent_2 = PHI <parent_12(6), 0B(2)>
  if (tmp_1 != 0B)
    goto <bb 3>; [85.00%]
  else
    goto <bb 7>; [15.00%]

  <bb 7> [15.00%]:
  _7 = parent_2;
  return parent_2;

}



;; Function xrealloc (xrealloc, funcdef_no=60, decl_uid=4395, cgraph_uid=60, symbol_order=63)



 local analysis of xrealloc
   scanning: newsize_4 = nmemb_2(D) * size_3(D);
  scanning: if (newsize_4 == 0)
  scanning: _16 = __printf_chk (1, "zero size%s", "");
  scanning: exit (1);
  scanning: _1 = 1073741824 / nmemb_2(D);
  scanning: if (_1 < size_3(D))
  scanning: _17 = __printf_chk (1, "nmemb * size > SIZE_MAX%s", "");
  scanning: exit (1);
  scanning: newptr_8 = realloc (oldptr_6(D), newsize_4);
  scanning: if (newptr_8 == 0B)
  scanning: _18 = __printf_chk (1, "xrealloc failed%s", "");
  scanning: exit (1);
  scanning: _9 = newptr_8;
  scanning: return newptr_8;
Function is locally looping.
Function can locally free.
xrealloc (void * oldptr, size_t nmemb, size_t size)
{
  int D.5185;
  int D.5183;
  int D.5181;
  void * newptr;
  size_t newsize;
  long unsigned int _1;
  void * _9;
  int _16;
  int _17;
  int _18;

  <bb 2> [100.00%]:
  newsize_4 = nmemb_2(D) * size_3(D);
  if (newsize_4 == 0)
    goto <bb 3>; [0.04%]
  else
    goto <bb 4>; [99.96%]

  <bb 3> [0.04%]:
  _16 = __printf_chk (1, "zero size%s", "");
  exit (1);

  <bb 4> [99.96%]:
  _1 = 1073741824 / nmemb_2(D);
  if (_1 < size_3(D))
    goto <bb 5>; [0.04%]
  else
    goto <bb 6>; [99.96%]

  <bb 5> [0.04%]:
  _17 = __printf_chk (1, "nmemb * size > SIZE_MAX%s", "");
  exit (1);

  <bb 6> [99.92%]:
  newptr_8 = realloc (oldptr_6(D), newsize_4);
  if (newptr_8 == 0B)
    goto <bb 7>; [0.04%]
  else
    goto <bb 8>; [99.96%]

  <bb 7> [0.04%]:
  _18 = __printf_chk (1, "xrealloc failed%s", "");
  exit (1);

  <bb 8> [99.88%]:
  _9 = newptr_8;
  return newptr_8;

}



;; Function winlink_find_by_index (winlink_find_by_index, funcdef_no=61, decl_uid=4401, cgraph_uid=61, symbol_order=64)



 local analysis of winlink_find_by_index
   scanning: if (idx_1(D) < 0)
  scanning: _5 = __printf_chk (1, "bad index%s", "");
  scanning: exit (1);
  scanning: wl.idx = idx_1(D);
  scanning: _6 = winlinks_RB_FIND (wwl_4(D), &wl);
  scanning: wl ={v} {CLOBBER};
  scanning: return _6;
Function is locally looping.
Function can locally free.
winlink_find_by_index (struct winlinks * wwl, int idx)
{
  int D.5188;
  struct winlink wl;
  int _5;
  struct winlink * _6;

  <bb 2> [100.00%]:
  if (idx_1(D) < 0)
    goto <bb 3>; [0.04%]
  else
    goto <bb 4>; [99.96%]

  <bb 3> [0.04%]:
  _5 = __printf_chk (1, "bad index%s", "");
  exit (1);

  <bb 4> [99.96%]:
  wl.idx = idx_1(D);
  _6 = winlinks_RB_FIND (wwl_4(D), &wl);
  wl ={v} {CLOBBER};
  return _6;

}



;; Function winlink_count (winlink_count, funcdef_no=62, decl_uid=4405, cgraph_uid=62, symbol_order=65)



 local analysis of winlink_count
   scanning: wl_8 = winlinks_RB_MINMAX (wwl_6(D), -1);
  scanning: n_10 = n_2 + 1;
  scanning: wl_12 = winlinks_RB_NEXT (wl_1);
  scanning: if (wl_1 != 0B)
  scanning: _9 = n_2;
  scanning: return n_2;
;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5
;;
;; Loop 1
;;  header 4, latch 3
;;  depth 1, outer 0
;;  nodes: 4 3
;; 2 succs { 4 }
;; 3 succs { 4 }
;; 4 succs { 3 5 }
;; 5 succs { 1 }
    can not prove finiteness of loop 1
Function is locally looping.
Function is locally pure.
Function found to be looping pure: winlink_count
Declaration updated to be looping pure: winlink_count
winlink_count (struct winlinks * wwl)
{
  u_int n;
  struct winlink * wl;
  u_int _9;

  <bb 2> [15.00%]:
  wl_8 = winlinks_RB_MINMAX (wwl_6(D), -1);
  goto <bb 4>; [100.00%]

  <bb 3> [85.00%]:
  n_10 = n_2 + 1;
  wl_12 = winlinks_RB_NEXT (wl_1);

  <bb 4> [100.00%]:
  # wl_1 = PHI <wl_8(2), wl_12(3)>
  # n_2 = PHI <0(2), n_10(3)>
  if (wl_1 != 0B)
    goto <bb 3>; [85.00%]
  else
    goto <bb 5>; [15.00%]

  <bb 5> [15.00%]:
  _9 = n_2;
  return n_2;

}



;; Function winlink_next_index (winlink_next_index, funcdef_no=63, decl_uid=4414, cgraph_uid=63, symbol_order=66)



 local analysis of winlink_next_index
   scanning: _1 = winlink_find_by_index (wwl_9(D), i_2);
  scanning: if (_1 == 0B)
  scanning: if (i_2 == 10000)
  scanning: i_11 = i_2 + 1;
  scanning: if (i_3 != idx_6(D))
  scanning: return _4;
Function is locally looping.
winlink_next_index (struct winlinks * wwl, int idx)
{
  int i;
  struct winlink * _1;
  int _4;

  <bb 2> [14.44%]:

  <bb 3> [100.00%]:
  # i_2 = PHI <idx_6(D)(2), i_3(8)>
  _1 = winlink_find_by_index (wwl_9(D), i_2);
  if (_1 == 0B)
    goto <bb 7>; [7.50%]
  else
    goto <bb 4>; [92.50%]

  <bb 4> [92.50%]:
  if (i_2 == 10000)
    goto <bb 6>; [34.00%]
  else
    goto <bb 5>; [66.00%]

  <bb 5> [61.05%]:
  i_11 = i_2 + 1;

  <bb 6> [92.50%]:
  # i_3 = PHI <0(4), i_11(5)>
  if (i_3 != idx_6(D))
    goto <bb 8>; [92.50%]
  else
    goto <bb 7>; [7.50%]

  <bb 8> [85.56%]:
  goto <bb 3>; [100.00%]

  <bb 7> [14.44%]:
  # _4 = PHI <i_2(3), -1(6)>
  return _4;

}



;; Function winlink_find_by_window (winlink_find_by_window, funcdef_no=64, decl_uid=4421, cgraph_uid=64, symbol_order=67)



 local analysis of winlink_find_by_window
   scanning: wl_8 = winlinks_RB_MINMAX (wwl_6(D), -1);
  scanning: _1 = wl_2->window;
    Indirect ref read is not const
  scanning: if (_1 == w_10(D))
  scanning: wl_12 = winlinks_RB_NEXT (wl_2);
  scanning: if (wl_2 != 0B)
  scanning: return _3;
;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6
;;
;; Loop 1
;;  header 5, latch 4
;;  depth 1, outer 0
;;  nodes: 5 4 3
;; 2 succs { 5 }
;; 3 succs { 6 4 }
;; 4 succs { 5 }
;; 5 succs { 3 6 }
;; 6 succs { 1 }
    can not prove finiteness of loop 1
Function is locally looping.
Function is locally pure.
Function found to be looping pure: winlink_find_by_window
Declaration updated to be looping pure: winlink_find_by_window
winlink_find_by_window (struct winlinks * wwl, struct window * w)
{
  struct winlink * wl;
  struct window * _1;
  struct winlink * _3;

  <bb 2> [14.44%]:
  wl_8 = winlinks_RB_MINMAX (wwl_6(D), -1);
  goto <bb 5>; [100.00%]

  <bb 3> [92.50%]:
  _1 = wl_2->window;
  if (_1 == w_10(D))
    goto <bb 6>; [7.50%]
  else
    goto <bb 4>; [92.50%]

  <bb 4> [85.56%]:
  wl_12 = winlinks_RB_NEXT (wl_2);

  <bb 5> [100.00%]:
  # wl_2 = PHI <wl_8(2), wl_12(4)>
  if (wl_2 != 0B)
    goto <bb 3>; [92.50%]
  else
    goto <bb 6>; [7.50%]

  <bb 6> [14.44%]:
  # _3 = PHI <wl_2(3), 0B(5)>
  return _3;

}



;; Function cmd_find_pane (cmd_find_pane, funcdef_no=65, decl_uid=4429, cgraph_uid=65, symbol_order=68)



 local analysis of cmd_find_pane
   scanning: _1 = sessions.num;
    global memory read is not const
  scanning: if (_1 == 0)
  scanning: _12 = __printf_chk (1, "can\'t establish current session\n");
  scanning: _2 = sessions.list;
    global memory read is not const
  scanning: s_8 = MEM[(struct session * *)_2 + 8B];
    Indirect ref read is not const
  scanning: if (sp_9(D) != 0B)
  scanning: *sp_9(D) = s_8;
    Indirect ref write is not const/pure
  scanning: if (arg_11(D) != 0)
  scanning: _14 = s_8->curw;
    Indirect ref read is not const
  scanning: _3 = s_8->curw;
    Indirect ref read is not const
  scanning: _13 = winlinks_RB_NEXT (_3);
  scanning: return _4;
Function is locally looping.
Function can locally free.
cmd_find_pane (int arg, struct session * * sp)
{
  int D.5190;
  struct session * s;
  unsigned int _1;
  struct session * * _2;
  struct winlink * _3;
  struct winlink * _4;
  int _12;
  struct winlink * _13;
  struct winlink * _14;

  <bb 2> [100.00%]:
  _1 = sessions.num;
  if (_1 == 0)
    goto <bb 3>; [4.64%]
  else
    goto <bb 4>; [95.36%]

  <bb 3> [4.64%]:
  _12 = __printf_chk (1, "can\'t establish current session\n");
  goto <bb 9>; [100.00%]

  <bb 4> [95.36%]:
  _2 = sessions.list;
  s_8 = MEM[(struct session * *)_2 + 8B];
  if (sp_9(D) != 0B)
    goto <bb 5>; [70.00%]
  else
    goto <bb 6>; [30.00%]

  <bb 5> [66.75%]:
  *sp_9(D) = s_8;

  <bb 6> [95.36%]:
  if (arg_11(D) != 0)
    goto <bb 7>; [63.36%]
  else
    goto <bb 8>; [36.64%]

  <bb 7> [60.42%]:
  _14 = s_8->curw;
  goto <bb 9>; [100.00%]

  <bb 8> [34.94%]:
  _3 = s_8->curw;
  _13 = winlinks_RB_NEXT (_3);

  <bb 9> [100.00%]:
  # _4 = PHI <0B(3), _14(7), _13(8)>
  return _4;

}



;; Function session_has (session_has, funcdef_no=66, decl_uid=4436, cgraph_uid=66, symbol_order=69)



 local analysis of session_has
   scanning: _1 = &s_6(D)->windows;
  scanning: wl_9 = winlinks_RB_MINMAX (_1, -1);
  scanning: _2 = wl_3->window;
    Indirect ref read is not const
  scanning: if (_2 == w_11(D))
  scanning: wl_13 = winlinks_RB_NEXT (wl_3);
  scanning: if (wl_3 != 0B)
  scanning: return _4;
;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6
;;
;; Loop 1
;;  header 5, latch 4
;;  depth 1, outer 0
;;  nodes: 5 4 3
;; 2 succs { 5 }
;; 3 succs { 6 4 }
;; 4 succs { 5 }
;; 5 succs { 3 6 }
;; 6 succs { 1 }
    can not prove finiteness of loop 1
Function is locally looping.
Function is locally pure.
Function found to be looping pure: session_has
Declaration updated to be looping pure: session_has
session_has (struct session * s, struct window * w)
{
  struct winlink * wl;
  struct winlinks * _1;
  struct window * _2;
  int _4;

  <bb 2> [14.44%]:
  _1 = &s_6(D)->windows;
  wl_9 = winlinks_RB_MINMAX (_1, -1);
  goto <bb 5>; [100.00%]

  <bb 3> [92.50%]:
  _2 = wl_3->window;
  if (_2 == w_11(D))
    goto <bb 6>; [7.50%]
  else
    goto <bb 4>; [92.50%]

  <bb 4> [85.56%]:
  wl_13 = winlinks_RB_NEXT (wl_3);

  <bb 5> [100.00%]:
  # wl_3 = PHI <wl_9(2), wl_13(4)>
  if (wl_3 != 0B)
    goto <bb 3>; [92.50%]
  else
    goto <bb 6>; [7.50%]

  <bb 6> [14.44%]:
  # _4 = PHI <1(3), 0(5)>
  return _4;

}



;; Function session_group_find (session_group_find, funcdef_no=67, decl_uid=4443, cgraph_uid=67, symbol_order=70)



 local analysis of session_group_find
   scanning: sg_5 = session_groups.tqh_first;
    global memory read is not const
  scanning: s_7 = sg_1->sessions.tqh_first;
    Indirect ref read is not const
  scanning: if (s_2 == target_9(D))
  scanning: s_10 = s_2->gentry.tqe_next;
    Indirect ref read is not const
  scanning: if (s_2 != 0B)
  scanning: sg_8 = sg_1->entry.tqe_next;
    Indirect ref read is not const
  scanning: if (sg_1 != 0B)
  scanning: return _3;
;; 3 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9
;;
;; Loop 1
;;  header 8, latch 7
;;  depth 1, outer 0
;;  nodes: 8 7 6 3 5 4
;;
;; Loop 2
;;  header 6, latch 5
;;  depth 2, outer 1
;;  nodes: 6 5 4
;; 2 succs { 8 }
;; 3 succs { 6 }
;; 4 succs { 9 5 }
;; 5 succs { 6 }
;; 6 succs { 4 7 }
;; 7 succs { 8 }
;; 8 succs { 3 9 }
;; 9 succs { 1 }
    can not prove finiteness of loop 1
Function is locally looping.
Function is locally pure.
Function found to be looping pure: session_group_find
Declaration updated to be looping pure: session_group_find
session_group_find (struct session * target)
{
  struct session * s;
  struct session_group * sg;
  struct session_group * _3;

  <bb 2> [8.11%]:
  sg_5 = session_groups.tqh_first;
  goto <bb 8>; [100.00%]

  <bb 3> [14.44%]:
  s_7 = sg_1->sessions.tqh_first;
  goto <bb 6>; [100.00%]

  <bb 4> [92.50%]:
  if (s_2 == target_9(D))
    goto <bb 9>; [7.50%]
  else
    goto <bb 5>; [92.50%]

  <bb 5> [85.56%]:
  s_10 = s_2->gentry.tqe_next;

  <bb 6> [100.00%]:
  # s_2 = PHI <s_7(3), s_10(5)>
  if (s_2 != 0B)
    goto <bb 4>; [92.50%]
  else
    goto <bb 7>; [7.50%]

  <bb 7> [7.50%]:
  sg_8 = sg_1->entry.tqe_next;

  <bb 8> [15.61%]:
  # sg_1 = PHI <sg_5(2), sg_8(7)>
  if (sg_1 != 0B)
    goto <bb 3>; [92.50%]
  else
    goto <bb 9>; [7.50%]

  <bb 9> [8.11%]:
  # _3 = PHI <sg_1(4), 0B(8)>
  return _3;

}



;; Function session_group_add (session_group_add, funcdef_no=68, decl_uid=4455, cgraph_uid=68, symbol_order=71)



 local analysis of session_group_add
   scanning: sg_16 = session_group_find (target_14(D));
  scanning: if (sg_16 == 0B)
  scanning: sg_18 = malloc (32);
  scanning: sg_18->entry.tqe_next = 0B;
    Indirect ref write is not const/pure
  scanning: _1 = session_groups.tqh_last;
    global memory read is not const
  scanning: sg_18->entry.tqe_prev = _1;
    Indirect ref write is not const/pure
  scanning: _2 = session_groups.tqh_last;
    global memory read is not const
  scanning: *_2 = sg_18;
    Indirect ref write is not const/pure
  scanning: _3 = &sg_18->entry.tqe_next;
  scanning: session_groups.tqh_last = _3;
    static/global memory write is not const/pure
  scanning: sg_18->sessions.tqh_first = 0B;
    Indirect ref write is not const/pure
  scanning: _4 = &sg_18->sessions.tqh_first;
  scanning: sg_18->sessions.tqh_last = _4;
    Indirect ref write is not const/pure
  scanning: target_14(D)->gentry.tqe_next = 0B;
    Indirect ref write is not const/pure
  scanning: _5 = sg_18->sessions.tqh_last;
    Indirect ref read is not const
  scanning: target_14(D)->gentry.tqe_prev = _5;
    Indirect ref write is not const/pure
  scanning: _6 = sg_18->sessions.tqh_last;
    Indirect ref read is not const
  scanning: *_6 = target_14(D);
    Indirect ref write is not const/pure
  scanning: _7 = &target_14(D)->gentry.tqe_next;
  scanning: sg_18->sessions.tqh_last = _7;
    Indirect ref write is not const/pure
  scanning: s_29(D)->gentry.tqe_next = 0B;
    Indirect ref write is not const/pure
  scanning: _8 = sg_11->sessions.tqh_last;
    Indirect ref read is not const
  scanning: s_29(D)->gentry.tqe_prev = _8;
    Indirect ref write is not const/pure
  scanning: _9 = sg_11->sessions.tqh_last;
    Indirect ref read is not const
  scanning: *_9 = s_29(D);
    Indirect ref write is not const/pure
  scanning: _10 = &s_29(D)->gentry.tqe_next;
  scanning: sg_11->sessions.tqh_last = _10;
    Indirect ref write is not const/pure
  scanning: return;
Function is locally looping.
session_group_add (struct session * target, struct session * s)
{
  struct session_group * sg;
  struct session_group * * _1;
  struct session_group * * _2;
  struct session_group * * _3;
  struct session * * _4;
  struct session * * _5;
  struct session * * _6;
  struct session * * _7;
  struct session * * _8;
  struct session * * _9;
  struct session * * _10;

  <bb 2> [100.00%]:
  sg_16 = session_group_find (target_14(D));
  if (sg_16 == 0B)
    goto <bb 3>; [19.86%]
  else
    goto <bb 4>; [80.14%]

  <bb 3> [19.86%]:
  sg_18 = malloc (32);
  sg_18->entry.tqe_next = 0B;
  _1 = session_groups.tqh_last;
  sg_18->entry.tqe_prev = _1;
  _2 = session_groups.tqh_last;
  *_2 = sg_18;
  _3 = &sg_18->entry.tqe_next;
  session_groups.tqh_last = _3;
  sg_18->sessions.tqh_first = 0B;
  _4 = &sg_18->sessions.tqh_first;
  sg_18->sessions.tqh_last = _4;
  target_14(D)->gentry.tqe_next = 0B;
  _5 = sg_18->sessions.tqh_last;
  target_14(D)->gentry.tqe_prev = _5;
  _6 = sg_18->sessions.tqh_last;
  *_6 = target_14(D);
  _7 = &target_14(D)->gentry.tqe_next;
  sg_18->sessions.tqh_last = _7;

  <bb 4> [100.00%]:
  # sg_11 = PHI <sg_16(2), sg_18(3)>
  s_29(D)->gentry.tqe_next = 0B;
  _8 = sg_11->sessions.tqh_last;
  s_29(D)->gentry.tqe_prev = _8;
  _9 = sg_11->sessions.tqh_last;
  *_9 = s_29(D);
  _10 = &s_29(D)->gentry.tqe_next;
  sg_11->sessions.tqh_last = _10;
  return;

}



;; Function winlink_add (winlink_add, funcdef_no=69, decl_uid=4461, cgraph_uid=69, symbol_order=72)



 local analysis of winlink_add
   scanning: if (idx_9(D) < 0)
  scanning: _1 = ~idx_9(D);
  scanning: idx_15 = winlink_next_index (wwl_11(D), _1);
  scanning: if (idx_15 == -1)
  scanning: _2 = winlink_find_by_index (wwl_11(D), idx_9(D));
  scanning: if (_2 != 0B)
  scanning: wl_18 = calloc (1, 136);
  scanning: wl_18->idx = idx_5;
    Indirect ref write is not const/pure
  scanning: wl_18->window = w_20(D);
    Indirect ref write is not const/pure
  scanning: winlinks_RB_INSERT (wwl_11(D), wl_18);
  scanning: _3 = w_20(D)->references;
    Indirect ref read is not const
  scanning: _4 = _3 + 1;
  scanning: w_20(D)->references = _4;
    Indirect ref write is not const/pure
  scanning: _24 = wl_18;
  scanning: return _6;
Function is locally looping.
winlink_add (struct winlinks * wwl, struct window * w, int idx)
{
  struct winlink * wl;
  int _1;
  struct winlink * _2;
  unsigned int _3;
  unsigned int _4;
  struct winlink * _6;
  struct winlink * _24;

  <bb 2> [100.00%]:
  if (idx_9(D) < 0)
    goto <bb 3>; [36.00%]
  else
    goto <bb 4>; [64.00%]

  <bb 3> [36.00%]:
  _1 = ~idx_9(D);
  idx_15 = winlink_next_index (wwl_11(D), _1);
  if (idx_15 == -1)
    goto <bb 6>; [4.85%]
  else
    goto <bb 5>; [95.15%]

  <bb 4> [64.00%]:
  _2 = winlink_find_by_index (wwl_11(D), idx_9(D));
  if (_2 != 0B)
    goto <bb 6>; [18.75%]
  else
    goto <bb 5>; [81.25%]

  <bb 5> [86.25%]:
  # idx_5 = PHI <idx_15(3), idx_9(D)(4)>
  wl_18 = calloc (1, 136);
  wl_18->idx = idx_5;
  wl_18->window = w_20(D);
  winlinks_RB_INSERT (wwl_11(D), wl_18);
  _3 = w_20(D)->references;
  _4 = _3 + 1;
  w_20(D)->references = _4;
  _24 = wl_18;

  <bb 6> [100.00%]:
  # _6 = PHI <0B(3), 0B(4), wl_18(5)>
  return _6;

}



;; Function window_index (window_index, funcdef_no=70, decl_uid=4466, cgraph_uid=70, symbol_order=73)



 local analysis of window_index
   scanning: *i_14(D) = 0;
    Indirect ref write is not const/pure
  scanning: _1 = windows.list;
    global memory read is not const
  scanning: _2 = *i_14(D);
    Indirect ref read is not const
  scanning: _3 = (long unsigned int) _2;
  scanning: _4 = _3 * 8;
  scanning: _5 = _1 + _4;
  scanning: _6 = *_5;
    Indirect ref read is not const
  scanning: if (_6 == s_17(D))
  scanning: _7 = *i_14(D);
    Indirect ref read is not const
  scanning: _8 = _7 + 1;
  scanning: *i_14(D) = _8;
    Indirect ref write is not const/pure
  scanning: _9 = *i_14(D);
    Indirect ref read is not const
  scanning: _10 = windows.num;
    global memory read is not const
  scanning: if (_9 < _10)
  scanning: return _11;
window_index (struct window * s, u_int * i)
{
  struct window * * _1;
  unsigned int _2;
  long unsigned int _3;
  long unsigned int _4;
  struct window * * _5;
  struct window * _6;
  unsigned int _7;
  unsigned int _8;
  unsigned int _9;
  unsigned int _10;
  int _11;

  <bb 2> [14.44%]:
  *i_14(D) = 0;
  goto <bb 5>; [100.00%]

  <bb 3> [92.50%]:
  _1 = windows.list;
  _2 = *i_14(D);
  _3 = (long unsigned int) _2;
  _4 = _3 * 8;
  _5 = _1 + _4;
  _6 = *_5;
  if (_6 == s_17(D))
    goto <bb 6>; [7.50%]
  else
    goto <bb 4>; [92.50%]

  <bb 4> [85.56%]:
  _7 = *i_14(D);
  _8 = _7 + 1;
  *i_14(D) = _8;

  <bb 5> [100.00%]:
  _9 = *i_14(D);
  _10 = windows.num;
  if (_9 < _10)
    goto <bb 3>; [92.50%]
  else
    goto <bb 6>; [7.50%]

  <bb 6> [14.44%]:
  # _11 = PHI <0(3), -1(5)>
  return _11;

}



;; Function session_group_remove (session_group_remove, funcdef_no=71, decl_uid=4472, cgraph_uid=71, symbol_order=74)



 local analysis of session_group_remove
   scanning: sg_36 = session_group_find (s_34(D));
  scanning: if (sg_36 == 0B)
  scanning: _1 = s_34(D)->gentry.tqe_next;
    Indirect ref read is not const
  scanning: if (_1 != 0B)
  scanning: _2 = s_34(D)->gentry.tqe_next;
    Indirect ref read is not const
  scanning: _3 = s_34(D)->gentry.tqe_prev;
    Indirect ref read is not const
  scanning: _2->gentry.tqe_prev = _3;
    Indirect ref write is not const/pure
  scanning: _4 = s_34(D)->gentry.tqe_prev;
    Indirect ref read is not const
  scanning: sg_36->sessions.tqh_last = _4;
    Indirect ref write is not const/pure
  scanning: _5 = s_34(D)->gentry.tqe_prev;
    Indirect ref read is not const
  scanning: _6 = s_34(D)->gentry.tqe_next;
    Indirect ref read is not const
  scanning: *_5 = _6;
    Indirect ref write is not const/pure
  scanning: _7 = sg_36->sessions.tqh_first;
    Indirect ref read is not const
  scanning: _8 = _7->gentry.tqe_next;
    Indirect ref read is not const
  scanning: if (_8 == 0B)
  scanning: _9 = sg_36->sessions.tqh_first;
    Indirect ref read is not const
  scanning: _10 = _9->gentry.tqe_next;
    Indirect ref read is not const
  scanning: if (_10 != 0B)
  scanning: _11 = sg_36->sessions.tqh_first;
    Indirect ref read is not const
  scanning: _12 = sg_36->sessions.tqh_first;
    Indirect ref read is not const
  scanning: _13 = _12->gentry.tqe_next;
    Indirect ref read is not const
  scanning: _14 = _11->gentry.tqe_prev;
    Indirect ref read is not const
  scanning: _13->gentry.tqe_prev = _14;
    Indirect ref write is not const/pure
  scanning: _15 = sg_36->sessions.tqh_first;
    Indirect ref read is not const
  scanning: _16 = _15->gentry.tqe_prev;
    Indirect ref read is not const
  scanning: sg_36->sessions.tqh_last = _16;
    Indirect ref write is not const/pure
  scanning: _17 = sg_36->sessions.tqh_first;
    Indirect ref read is not const
  scanning: _18 = sg_36->sessions.tqh_first;
    Indirect ref read is not const
  scanning: _19 = _18->gentry.tqe_prev;
    Indirect ref read is not const
  scanning: _20 = _17->gentry.tqe_next;
    Indirect ref read is not const
  scanning: *_19 = _20;
    Indirect ref write is not const/pure
  scanning: _21 = sg_36->sessions.tqh_first;
    Indirect ref read is not const
  scanning: if (_21 == 0B)
  scanning: _22 = sg_36->entry.tqe_next;
    Indirect ref read is not const
  scanning: if (_22 != 0B)
  scanning: _23 = sg_36->entry.tqe_next;
    Indirect ref read is not const
  scanning: _24 = sg_36->entry.tqe_prev;
    Indirect ref read is not const
  scanning: _23->entry.tqe_prev = _24;
    Indirect ref write is not const/pure
  scanning: _25 = sg_36->entry.tqe_prev;
    Indirect ref read is not const
  scanning: session_groups.tqh_last = _25;
    static/global memory write is not const/pure
  scanning: _26 = sg_36->entry.tqe_prev;
    Indirect ref read is not const
  scanning: _27 = sg_36->entry.tqe_next;
    Indirect ref read is not const
  scanning: *_26 = _27;
    Indirect ref write is not const/pure
  scanning: free (sg_36);
  scanning: return;
Function is locally looping.
Function can locally free.
session_group_remove (struct session * s)
{
  struct session_group * sg;
  struct session * _1;
  struct session * _2;
  struct session * * _3;
  struct session * * _4;
  struct session * * _5;
  struct session * _6;
  struct session * _7;
  struct session * _8;
  struct session * _9;
  struct session * _10;
  struct session * _11;
  struct session * _12;
  struct session * _13;
  struct session * * _14;
  struct session * _15;
  struct session * * _16;
  struct session * _17;
  struct session * _18;
  struct session * * _19;
  struct session * _20;
  struct session * _21;
  struct session_group * _22;
  struct session_group * _23;
  struct session_group * * _24;
  struct session_group * * _25;
  struct session_group * * _26;
  struct session_group * _27;

  <bb 2> [100.00%]:
  sg_36 = session_group_find (s_34(D));
  if (sg_36 == 0B)
    goto <bb 16>; [26.74%]
  else
    goto <bb 3>; [73.26%]

  <bb 3> [73.26%]:
  _1 = s_34(D)->gentry.tqe_next;
  if (_1 != 0B)
    goto <bb 4>; [70.00%]
  else
    goto <bb 5>; [30.00%]

  <bb 4> [51.28%]:
  _2 = s_34(D)->gentry.tqe_next;
  _3 = s_34(D)->gentry.tqe_prev;
  _2->gentry.tqe_prev = _3;
  goto <bb 6>; [100.00%]

  <bb 5> [21.98%]:
  _4 = s_34(D)->gentry.tqe_prev;
  sg_36->sessions.tqh_last = _4;

  <bb 6> [73.26%]:
  _5 = s_34(D)->gentry.tqe_prev;
  _6 = s_34(D)->gentry.tqe_next;
  *_5 = _6;
  _7 = sg_36->sessions.tqh_first;
  _8 = _7->gentry.tqe_next;
  if (_8 == 0B)
    goto <bb 7>; [30.00%]
  else
    goto <bb 11>; [70.00%]

  <bb 7> [21.98%]:
  _9 = sg_36->sessions.tqh_first;
  _10 = _9->gentry.tqe_next;
  if (_10 != 0B)
    goto <bb 8>; [70.00%]
  else
    goto <bb 9>; [30.00%]

  <bb 8> [15.38%]:
  _11 = sg_36->sessions.tqh_first;
  _12 = sg_36->sessions.tqh_first;
  _13 = _12->gentry.tqe_next;
  _14 = _11->gentry.tqe_prev;
  _13->gentry.tqe_prev = _14;
  goto <bb 10>; [100.00%]

  <bb 9> [6.59%]:
  _15 = sg_36->sessions.tqh_first;
  _16 = _15->gentry.tqe_prev;
  sg_36->sessions.tqh_last = _16;

  <bb 10> [21.98%]:
  _17 = sg_36->sessions.tqh_first;
  _18 = sg_36->sessions.tqh_first;
  _19 = _18->gentry.tqe_prev;
  _20 = _17->gentry.tqe_next;
  *_19 = _20;

  <bb 11> [73.26%]:
  _21 = sg_36->sessions.tqh_first;
  if (_21 == 0B)
    goto <bb 12>; [33.47%]
  else
    goto <bb 16>; [66.53%]

  <bb 12> [24.52%]:
  _22 = sg_36->entry.tqe_next;
  if (_22 != 0B)
    goto <bb 13>; [70.00%]
  else
    goto <bb 14>; [30.00%]

  <bb 13> [17.16%]:
  _23 = sg_36->entry.tqe_next;
  _24 = sg_36->entry.tqe_prev;
  _23->entry.tqe_prev = _24;
  goto <bb 15>; [100.00%]

  <bb 14> [7.36%]:
  _25 = sg_36->entry.tqe_prev;
  session_groups.tqh_last = _25;

  <bb 15> [24.52%]:
  _26 = sg_36->entry.tqe_prev;
  _27 = sg_36->entry.tqe_next;
  *_26 = _27;
  free (sg_36);

  <bb 16> [100.00%]:
  return;

}



;; Function session_find (session_find, funcdef_no=72, decl_uid=4476, cgraph_uid=72, symbol_order=75)



 local analysis of session_find
   scanning: _1 = sessions.list;
    global memory read is not const
  scanning: _2 = (long unsigned int) i_8;
  scanning: _3 = _2 * 8;
  scanning: _4 = _1 + _3;
  scanning: s_13 = *_4;
    Indirect ref read is not const
  scanning: if (s_13 != 0B)
  scanning: _5 = s_13->name;
    Indirect ref read is not const
  scanning: _6 = strcmp (_5, name_14(D));
  scanning: if (_6 == 0)
  scanning: i_16 = i_8 + 1;
  scanning: _7 = sessions.num;
    global memory read is not const
  scanning: if (_7 > i_8)
  scanning: return _9;
;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7
;;
;; Loop 1
;;  header 6, latch 5
;;  depth 1, outer 0
;;  nodes: 6 5 3 4
;; 2 succs { 6 }
;; 3 succs { 4 5 }
;; 4 succs { 7 5 }
;; 5 succs { 6 }
;; 6 succs { 3 7 }
;; 7 succs { 1 }
    can not prove finiteness of loop 1
Function is locally looping.
Function is locally pure.
Function found to be looping pure: session_find
Declaration updated to be looping pure: session_find
session_find (const char * name)
{
  u_int i;
  struct session * s;
  struct session * * _1;
  long unsigned int _2;
  long unsigned int _3;
  struct session * * _4;
  char * _5;
  int _6;
  unsigned int _7;
  struct session * _9;

  <bb 2> [12.36%]:
  goto <bb 6>; [100.00%]

  <bb 3> [92.50%]:
  _1 = sessions.list;
  _2 = (long unsigned int) i_8;
  _3 = _2 * 8;
  _4 = _1 + _3;
  s_13 = *_4;
  if (s_13 != 0B)
    goto <bb 4>; [70.00%]
  else
    goto <bb 5>; [30.00%]

  <bb 4> [64.75%]:
  _5 = s_13->name;
  _6 = strcmp (_5, name_14(D));
  if (_6 == 0)
    goto <bb 7>; [7.50%]
  else
    goto <bb 5>; [92.50%]

  <bb 5> [87.64%]:
  i_16 = i_8 + 1;

  <bb 6> [100.00%]:
  # i_8 = PHI <0(2), i_16(5)>
  _7 = sessions.num;
  if (_7 > i_8)
    goto <bb 3>; [92.50%]
  else
    goto <bb 7>; [7.50%]

  <bb 7> [12.36%]:
  # _9 = PHI <s_13(4), 0B(6)>
  return _9;

}



;; Function session_index (session_index, funcdef_no=73, decl_uid=4485, cgraph_uid=73, symbol_order=76)



 local analysis of session_index
   scanning: *i_14(D) = 0;
    Indirect ref write is not const/pure
  scanning: _1 = sessions.list;
    global memory read is not const
  scanning: _2 = *i_14(D);
    Indirect ref read is not const
  scanning: _3 = (long unsigned int) _2;
  scanning: _4 = _3 * 8;
  scanning: _5 = _1 + _4;
  scanning: _6 = *_5;
    Indirect ref read is not const
  scanning: if (_6 == s_17(D))
  scanning: _7 = *i_14(D);
    Indirect ref read is not const
  scanning: _8 = _7 + 1;
  scanning: *i_14(D) = _8;
    Indirect ref write is not const/pure
  scanning: _9 = *i_14(D);
    Indirect ref read is not const
  scanning: _10 = sessions.num;
    global memory read is not const
  scanning: if (_9 < _10)
  scanning: return _11;
session_index (struct session * s, u_int * i)
{
  struct session * * _1;
  unsigned int _2;
  long unsigned int _3;
  long unsigned int _4;
  struct session * * _5;
  struct session * _6;
  unsigned int _7;
  unsigned int _8;
  unsigned int _9;
  unsigned int _10;
  int _11;

  <bb 2> [14.44%]:
  *i_14(D) = 0;
  goto <bb 5>; [100.00%]

  <bb 3> [92.50%]:
  _1 = sessions.list;
  _2 = *i_14(D);
  _3 = (long unsigned int) _2;
  _4 = _3 * 8;
  _5 = _1 + _4;
  _6 = *_5;
  if (_6 == s_17(D))
    goto <bb 6>; [7.50%]
  else
    goto <bb 4>; [92.50%]

  <bb 4> [85.56%]:
  _7 = *i_14(D);
  _8 = _7 + 1;
  *i_14(D) = _8;

  <bb 5> [100.00%]:
  _9 = *i_14(D);
  _10 = sessions.num;
  if (_9 < _10)
    goto <bb 3>; [92.50%]
  else
    goto <bb 6>; [7.50%]

  <bb 6> [14.44%]:
  # _11 = PHI <0(3), -1(5)>
  return _11;

}



;; Function winlink_stack_remove (winlink_stack_remove, funcdef_no=74, decl_uid=4492, cgraph_uid=74, symbol_order=77)



 local analysis of winlink_stack_remove
   scanning: if (wl_10(D) == 0B)
  scanning: wl2_13 = stack_12(D)->tqh_first;
    Indirect ref read is not const
  scanning: if (wl2_7 == wl_10(D))
  scanning: _1 = wl_10(D)->sentry.tqe_next;
    Indirect ref read is not const
  scanning: if (_1 != 0B)
  scanning: _2 = wl_10(D)->sentry.tqe_next;
    Indirect ref read is not const
  scanning: _3 = wl_10(D)->sentry.tqe_prev;
    Indirect ref read is not const
  scanning: _2->sentry.tqe_prev = _3;
    Indirect ref write is not const/pure
  scanning: _4 = wl_10(D)->sentry.tqe_prev;
    Indirect ref read is not const
  scanning: stack_12(D)->tqh_last = _4;
    Indirect ref write is not const/pure
  scanning: _5 = wl_10(D)->sentry.tqe_prev;
    Indirect ref read is not const
  scanning: _6 = wl_10(D)->sentry.tqe_next;
    Indirect ref read is not const
  scanning: *_5 = _6;
    Indirect ref write is not const/pure
  scanning: wl2_14 = wl2_7->sentry.tqe_next;
    Indirect ref read is not const
  scanning: if (wl2_7 != 0B)
  scanning: return;
winlink_stack_remove (struct winlink_stack * stack, struct winlink * wl)
{
  struct winlink * wl2;
  struct winlink * _1;
  struct winlink * _2;
  struct winlink * * _3;
  struct winlink * * _4;
  struct winlink * * _5;
  struct winlink * _6;

  <bb 2> [19.71%]:
  if (wl_10(D) == 0B)
    goto <bb 11>; [26.74%]
  else
    goto <bb 3>; [73.26%]

  <bb 3> [14.44%]:
  wl2_13 = stack_12(D)->tqh_first;
  goto <bb 10>; [100.00%]

  <bb 4> [92.50%]:
  if (wl2_7 == wl_10(D))
    goto <bb 5>; [7.50%]
  else
    goto <bb 9>; [92.50%]

  <bb 5> [6.94%]:
  _1 = wl_10(D)->sentry.tqe_next;
  if (_1 != 0B)
    goto <bb 6>; [70.00%]
  else
    goto <bb 7>; [30.00%]

  <bb 6> [4.86%]:
  _2 = wl_10(D)->sentry.tqe_next;
  _3 = wl_10(D)->sentry.tqe_prev;
  _2->sentry.tqe_prev = _3;
  goto <bb 8>; [100.00%]

  <bb 7> [2.08%]:
  _4 = wl_10(D)->sentry.tqe_prev;
  stack_12(D)->tqh_last = _4;

  <bb 8> [6.94%]:
  _5 = wl_10(D)->sentry.tqe_prev;
  _6 = wl_10(D)->sentry.tqe_next;
  *_5 = _6;
  goto <bb 11>; [100.00%]

  <bb 9> [85.56%]:
  wl2_14 = wl2_7->sentry.tqe_next;

  <bb 10> [100.00%]:
  # wl2_7 = PHI <wl2_13(3), wl2_14(9)>
  if (wl2_7 != 0B)
    goto <bb 4>; [92.50%]
  else
    goto <bb 11>; [7.50%]

  <bb 11> [19.71%]:
  return;

}



;; Function winlink_stack_push (winlink_stack_push, funcdef_no=75, decl_uid=4500, cgraph_uid=75, symbol_order=78)



 local analysis of winlink_stack_push
   scanning: if (wl_9(D) == 0B)
  scanning: winlink_stack_remove (stack_11(D), wl_9(D));
  scanning: _1 = stack_11(D)->tqh_first;
    Indirect ref read is not const
  scanning: wl_9(D)->sentry.tqe_next = _1;
    Indirect ref write is not const/pure
  scanning: _2 = wl_9(D)->sentry.tqe_next;
    Indirect ref read is not const
  scanning: if (_2 != 0B)
  scanning: _3 = stack_11(D)->tqh_first;
    Indirect ref read is not const
  scanning: _4 = &wl_9(D)->sentry.tqe_next;
  scanning: _3->sentry.tqe_prev = _4;
    Indirect ref write is not const/pure
  scanning: _5 = &wl_9(D)->sentry.tqe_next;
  scanning: stack_11(D)->tqh_last = _5;
    Indirect ref write is not const/pure
  scanning: stack_11(D)->tqh_first = wl_9(D);
    Indirect ref write is not const/pure
  scanning: _6 = &stack_11(D)->tqh_first;
  scanning: wl_9(D)->sentry.tqe_prev = _6;
    Indirect ref write is not const/pure
  scanning: return;
Function is locally looping.
winlink_stack_push (struct winlink_stack * stack, struct winlink * wl)
{
  struct winlink * _1;
  struct winlink * _2;
  struct winlink * _3;
  struct winlink * * _4;
  struct winlink * * _5;
  struct winlink * * _6;

  <bb 2> [100.00%]:
  if (wl_9(D) == 0B)
    goto <bb 7>; [42.57%]
  else
    goto <bb 3>; [57.43%]

  <bb 3> [57.43%]:
  winlink_stack_remove (stack_11(D), wl_9(D));
  _1 = stack_11(D)->tqh_first;
  wl_9(D)->sentry.tqe_next = _1;
  _2 = wl_9(D)->sentry.tqe_next;
  if (_2 != 0B)
    goto <bb 4>; [70.00%]
  else
    goto <bb 5>; [30.00%]

  <bb 4> [40.20%]:
  _3 = stack_11(D)->tqh_first;
  _4 = &wl_9(D)->sentry.tqe_next;
  _3->sentry.tqe_prev = _4;
  goto <bb 6>; [100.00%]

  <bb 5> [17.23%]:
  _5 = &wl_9(D)->sentry.tqe_next;
  stack_11(D)->tqh_last = _5;

  <bb 6> [57.43%]:
  stack_11(D)->tqh_first = wl_9(D);
  _6 = &stack_11(D)->tqh_first;
  wl_9(D)->sentry.tqe_prev = _6;

  <bb 7> [100.00%]:
  return;

}



;; Function window_destroy (window_destroy, funcdef_no=76, decl_uid=4503, cgraph_uid=76, symbol_order=79)



 local analysis of window_destroy
   scanning: _1 = window_index (w_24(D), &i);
  scanning: if (_1 != 0)
  scanning: _37 = __printf_chk (1, "index not found%s\n", "");
  scanning: exit (1);
  scanning: _2 = windows.list;
    global memory read is not const
  scanning: i.0_3 = i;
  scanning: _4 = (long unsigned int) i.0_3;
  scanning: _5 = _4 * 8;
  scanning: _6 = _2 + _5;
  scanning: *_6 = 0B;
    Indirect ref write is not const/pure
  scanning: _7 = windows.num;
    global memory read is not const
  scanning: if (_7 > 1)
  scanning: _8 = windows.num;
    global memory read is not const
  scanning: _9 = _8 + 4294967295;
  scanning: windows.num = _9;
    static/global memory write is not const/pure
  scanning: _10 = windows.list;
    global memory read is not const
  scanning: free (_10);
  scanning: windows.num = 0;
    static/global memory write is not const/pure
  scanning: windows.list = 0B;
    static/global memory write is not const/pure
  scanning: windows.space = 0;
    static/global memory write is not const/pure
  scanning: _11 = windows.num;
    global memory read is not const
  scanning: if (_11 != 0)
  scanning: _12 = windows.list;
    global memory read is not const
  scanning: _13 = windows.num;
    global memory read is not const
  scanning: _14 = _13 + 4294967295;
  scanning: _15 = (long unsigned int) _14;
  scanning: _16 = _15 * 8;
  scanning: _17 = _12 + _16;
  scanning: _18 = *_17;
    Indirect ref read is not const
  scanning: if (_18 == 0B)
  scanning: _19 = w_24(D)->name;
    Indirect ref read is not const
  scanning: if (_19 != 0B)
  scanning: _20 = w_24(D)->name;
    Indirect ref read is not const
  scanning: free (_20);
  scanning: free (w_24(D));
  scanning: i ={v} {CLOBBER};
  scanning: return;
Function is locally looping.
Function can locally free.
window_destroy (struct window * w)
{
  int D.5194;
  u_int i;
  int _1;
  struct window * * _2;
  unsigned int i.0_3;
  long unsigned int _4;
  long unsigned int _5;
  struct window * * _6;
  unsigned int _7;
  unsigned int _8;
  unsigned int _9;
  struct window * * _10;
  unsigned int _11;
  struct window * * _12;
  unsigned int _13;
  unsigned int _14;
  long unsigned int _15;
  long unsigned int _16;
  struct window * * _17;
  struct window * _18;
  char * _19;
  char * _20;
  int _37;

  <bb 2> [14.44%]:
  _1 = window_index (w_24(D), &i);
  if (_1 != 0)
    goto <bb 3>; [0.04%]
  else
    goto <bb 4>; [99.96%]

  <bb 3> [0.01%]:
  _37 = __printf_chk (1, "index not found%s\n", "");
  exit (1);

  <bb 4> [14.44%]:
  _2 = windows.list;
  i.0_3 = i;
  _4 = (long unsigned int) i.0_3;
  _5 = _4 * 8;
  _6 = _2 + _5;
  *_6 = 0B;
  goto <bb 13>; [100.00%]

  <bb 5> [85.56%]:
  _7 = windows.num;
  if (_7 > 1)
    goto <bb 6>; [78.31%]
  else
    goto <bb 7>; [21.69%]

  <bb 6> [67.00%]:
  _8 = windows.num;
  _9 = _8 + 4294967295;
  windows.num = _9;
  goto <bb 8>; [100.00%]

  <bb 7> [18.56%]:
  _10 = windows.list;
  free (_10);
  windows.num = 0;
  windows.list = 0B;
  windows.space = 0;

  <bb 8> [85.56%]:

  <bb 13> [100.00%]:
  _11 = windows.num;
  if (_11 != 0)
    goto <bb 9>; [92.50%]
  else
    goto <bb 10>; [7.50%]

  <bb 9> [92.50%]:
  _12 = windows.list;
  _13 = windows.num;
  _14 = _13 + 4294967295;
  _15 = (long unsigned int) _14;
  _16 = _15 * 8;
  _17 = _12 + _16;
  _18 = *_17;
  if (_18 == 0B)
    goto <bb 5>; [92.50%]
  else
    goto <bb 10>; [7.50%]

  <bb 10> [14.44%]:
  _19 = w_24(D)->name;
  if (_19 != 0B)
    goto <bb 11>; [57.44%]
  else
    goto <bb 12>; [42.56%]

  <bb 11> [8.29%]:
  _20 = w_24(D)->name;
  free (_20);

  <bb 12> [14.44%]:
  free (w_24(D));
  i ={v} {CLOBBER};
  return;

}



;; Function winlink_remove (winlink_remove, funcdef_no=77, decl_uid=4511, cgraph_uid=77, symbol_order=80)



 local analysis of winlink_remove
   scanning: w_11 = wl_10(D)->window;
    Indirect ref read is not const
  scanning: winlinks_RB_REMOVE (wwl_12(D), wl_10(D));
  scanning: _1 = wl_10(D)->status_text;
    Indirect ref read is not const
  scanning: if (_1 != 0B)
  scanning: _2 = wl_10(D)->status_text;
    Indirect ref read is not const
  scanning: free (_2);
  scanning: free (wl_10(D));
  scanning: _3 = w_11->references;
    Indirect ref read is not const
  scanning: if (_3 == 0)
  scanning: _20 = __printf_chk (1, "bad reference count%s\n", "");
  scanning: exit (1);
  scanning: _4 = w_11->references;
    Indirect ref read is not const
  scanning: _5 = _4 + 4294967295;
  scanning: w_11->references = _5;
    Indirect ref write is not const/pure
  scanning: _6 = w_11->references;
    Indirect ref read is not const
  scanning: if (_6 == 0)
  scanning: window_destroy (w_11);
  scanning: return;
Function is locally looping.
Function can locally free.
winlink_remove (struct winlinks * wwl, struct winlink * wl)
{
  int D.5196;
  struct window * w;
  char * _1;
  char * _2;
  unsigned int _3;
  unsigned int _4;
  unsigned int _5;
  unsigned int _6;
  int _20;

  <bb 2> [100.00%]:
  w_11 = wl_10(D)->window;
  winlinks_RB_REMOVE (wwl_12(D), wl_10(D));
  _1 = wl_10(D)->status_text;
  if (_1 != 0B)
    goto <bb 3>; [53.47%]
  else
    goto <bb 4>; [46.53%]

  <bb 3> [53.47%]:
  _2 = wl_10(D)->status_text;
  free (_2);

  <bb 4> [100.00%]:
  free (wl_10(D));
  _3 = w_11->references;
  if (_3 == 0)
    goto <bb 5>; [0.04%]
  else
    goto <bb 6>; [99.96%]

  <bb 5> [0.04%]:
  _20 = __printf_chk (1, "bad reference count%s\n", "");
  exit (1);

  <bb 6> [99.96%]:
  _4 = w_11->references;
  _5 = _4 + 4294967295;
  w_11->references = _5;
  _6 = w_11->references;
  if (_6 == 0)
    goto <bb 7>; [36.64%]
  else
    goto <bb 8>; [63.36%]

  <bb 7> [36.63%]:
  window_destroy (w_11);

  <bb 8> [99.96%]:
  return;

}



;; Function session_group_synchronize1 (session_group_synchronize1, funcdef_no=78, decl_uid=4516, cgraph_uid=78, symbol_order=81)



 local analysis of session_group_synchronize1
   scanning: ww_23 = &target_22(D)->windows;
  scanning: _1 = MEM[(struct winlinks *)target_22(D) + 40B].rbh_root;
    Indirect ref read is not const
  scanning: if (_1 == 0B)
  scanning: _30 = MEM[(char * {ref-all})s_25(D) + 40B];
    Indirect ref read is not const
  scanning: MEM[(char * {ref-all})&old_windows] = _30;
    Indirect ref write is not const/pure
  scanning: s_25(D)->windows.rbh_root = 0B;
    Indirect ref write is not const/pure
  scanning: wl_29 = winlinks_RB_MINMAX (ww_23, -1);
  scanning: _3 = wl_15->idx;
    Indirect ref read is not const
  scanning: _4 = wl_15->window;
    Indirect ref read is not const
  scanning: _5 = &s_25(D)->windows;
  scanning: winlink_add (_5, _4, _3);
  scanning: wl_48 = winlinks_RB_NEXT (wl_15);
  scanning: if (wl_15 != 0B)
  scanning: _26 = MEM[(char * {ref-all})s_25(D) + 24B];
    Indirect ref read is not const
  scanning: MEM[(char * {ref-all})&old_lastw] = _26;
    Indirect ref write is not const/pure
  scanning: s_25(D)->lastw.tqh_first = 0B;
    Indirect ref write is not const/pure
  scanning: _7 = &s_25(D)->lastw.tqh_first;
  scanning: s_25(D)->lastw.tqh_last = _7;
    Indirect ref write is not const/pure
  scanning: wl_33 = old_lastw.tqh_first;
  scanning: _8 = wl_16->idx;
    Indirect ref read is not const
  scanning: _9 = &s_25(D)->windows;
  scanning: wl2_40 = winlink_find_by_index (_9, _8);
  scanning: if (wl2_40 != 0B)
  scanning: wl2_40->sentry.tqe_next = 0B;
    Indirect ref write is not const/pure
  scanning: _10 = s_25(D)->lastw.tqh_last;
    Indirect ref read is not const
  scanning: wl2_40->sentry.tqe_prev = _10;
    Indirect ref write is not const/pure
  scanning: _11 = s_25(D)->lastw.tqh_last;
    Indirect ref read is not const
  scanning: *_11 = wl2_40;
    Indirect ref write is not const/pure
  scanning: _12 = &wl2_40->sentry.tqe_next;
  scanning: s_25(D)->lastw.tqh_last = _12;
    Indirect ref write is not const/pure
  scanning: wl_45 = wl_16->sentry.tqe_next;
    Indirect ref read is not const
  scanning: if (wl_16 != 0B)
  scanning: _13 = s_25(D)->lastw.tqh_first;
    Indirect ref read is not const
  scanning: s_25(D)->curw = _13;
    Indirect ref write is not const/pure
  scanning: wl_37 = old_windows.rbh_root;
  scanning: winlink_remove (&old_windows, wl_37);
  scanning: _14 = old_windows.rbh_root;
  scanning: if (_14 != 0B)
  scanning: old_windows ={v} {CLOBBER};
  scanning: old_lastw ={v} {CLOBBER};
  scanning: old_windows ={v} {CLOBBER};
  scanning: old_lastw ={v} {CLOBBER};
  scanning: return;
Function is locally looping.
session_group_synchronize1 (struct session * target, struct session * s)
{
  void * D.5204;
  void * D.5200;
  struct winlink * wl2;
  struct winlink * wl;
  struct winlink_stack old_lastw;
  struct winlinks * ww;
  struct winlinks old_windows;
  struct winlink * _1;
  int _3;
  struct window * _4;
  struct winlinks * _5;
  struct winlink * * _7;
  int _8;
  struct winlinks * _9;
  struct winlink * * _10;
  struct winlink * * _11;
  struct winlink * * _12;
  struct winlink * _13;
  struct winlink * _14;
  __int128 unsigned _26;
  long unsigned int _30;

  <bb 2> [28.05%]:
  ww_23 = &target_22(D)->windows;
  _1 = MEM[(struct winlinks *)target_22(D) + 40B].rbh_root;
  if (_1 == 0B)
    goto <bb 15>; [46.53%]
  else
    goto <bb 3>; [53.47%]

  <bb 3> [15.00%]:
  _30 = MEM[(char * {ref-all})s_25(D) + 40B];
  MEM[(char * {ref-all})&old_windows] = _30;
  s_25(D)->windows.rbh_root = 0B;
  wl_29 = winlinks_RB_MINMAX (ww_23, -1);
  goto <bb 5>; [100.00%]

  <bb 4> [85.00%]:
  _3 = wl_15->idx;
  _4 = wl_15->window;
  _5 = &s_25(D)->windows;
  winlink_add (_5, _4, _3);
  wl_48 = winlinks_RB_NEXT (wl_15);

  <bb 5> [100.00%]:
  # wl_15 = PHI <wl_29(3), wl_48(4)>
  if (wl_15 != 0B)
    goto <bb 4>; [85.00%]
  else
    goto <bb 6>; [15.00%]

  <bb 6> [15.00%]:
  _26 = MEM[(char * {ref-all})s_25(D) + 24B];
  MEM[(char * {ref-all})&old_lastw] = _26;
  s_25(D)->lastw.tqh_first = 0B;
  _7 = &s_25(D)->lastw.tqh_first;
  s_25(D)->lastw.tqh_last = _7;
  wl_33 = old_lastw.tqh_first;
  goto <bb 10>; [100.00%]

  <bb 7> [85.00%]:
  _8 = wl_16->idx;
  _9 = &s_25(D)->windows;
  wl2_40 = winlink_find_by_index (_9, _8);
  if (wl2_40 != 0B)
    goto <bb 8>; [70.00%]
  else
    goto <bb 9>; [30.00%]

  <bb 8> [59.50%]:
  wl2_40->sentry.tqe_next = 0B;
  _10 = s_25(D)->lastw.tqh_last;
  wl2_40->sentry.tqe_prev = _10;
  _11 = s_25(D)->lastw.tqh_last;
  *_11 = wl2_40;
  _12 = &wl2_40->sentry.tqe_next;
  s_25(D)->lastw.tqh_last = _12;

  <bb 9> [85.00%]:
  wl_45 = wl_16->sentry.tqe_next;

  <bb 10> [100.00%]:
  # wl_16 = PHI <wl_33(6), wl_45(9)>
  if (wl_16 != 0B)
    goto <bb 7>; [85.00%]
  else
    goto <bb 11>; [15.00%]

  <bb 11> [15.00%]:
  _13 = s_25(D)->lastw.tqh_first;
  s_25(D)->curw = _13;
  goto <bb 13>; [100.00%]

  <bb 12> [85.00%]:
  wl_37 = old_windows.rbh_root;
  winlink_remove (&old_windows, wl_37);

  <bb 13> [100.00%]:
  _14 = old_windows.rbh_root;
  if (_14 != 0B)
    goto <bb 12>; [85.00%]
  else
    goto <bb 14>; [15.00%]

  <bb 14> [15.00%]:
  old_windows ={v} {CLOBBER};
  old_lastw ={v} {CLOBBER};
  goto <bb 16>; [100.00%]

  <bb 15> [13.05%]:
  old_windows ={v} {CLOBBER};
  old_lastw ={v} {CLOBBER};

  <bb 16> [28.05%]:
  return;

}



;; Function session_group_synchronize_to (session_group_synchronize_to, funcdef_no=79, decl_uid=4535, cgraph_uid=79, symbol_order=82)



 local analysis of session_group_synchronize_to
   scanning: sg_6 = session_group_find (s_4(D));
  scanning: if (sg_6 == 0B)
  scanning: target_8 = sg_6->sessions.tqh_first;
    Indirect ref read is not const
  scanning: if (target_1 != s_4(D))
  scanning: target_9 = target_1->gentry.tqe_next;
    Indirect ref read is not const
  scanning: if (target_1 != 0B)
  scanning: session_group_synchronize1 (target_1, s_4(D));
  scanning: return;
Function is locally looping.
session_group_synchronize_to (struct session * s)
{
  struct session * target;
  struct session_group * sg;

  <bb 2> [19.71%]:
  sg_6 = session_group_find (s_4(D));
  if (sg_6 == 0B)
    goto <bb 8>; [26.74%]
  else
    goto <bb 3>; [73.26%]

  <bb 3> [14.44%]:
  target_8 = sg_6->sessions.tqh_first;
  goto <bb 6>; [100.00%]

  <bb 4> [92.50%]:
  if (target_1 != s_4(D))
    goto <bb 7>; [7.50%]
  else
    goto <bb 5>; [92.50%]

  <bb 5> [85.56%]:
  target_9 = target_1->gentry.tqe_next;

  <bb 6> [100.00%]:
  # target_1 = PHI <target_8(3), target_9(5)>
  if (target_1 != 0B)
    goto <bb 4>; [92.50%]
  else
    goto <bb 7>; [7.50%]

  <bb 7> [14.44%]:
  session_group_synchronize1 (target_1, s_4(D));

  <bb 8> [19.71%]:
  return;

}



;; Function session_group_synchronize_from (session_group_synchronize_from, funcdef_no=80, decl_uid=4543, cgraph_uid=80, symbol_order=83)



 local analysis of session_group_synchronize_from
   scanning: sg_8 = session_group_find (target_6(D));
  scanning: if (sg_8 == 0B)
  scanning: s_9 = sg_8->sessions.tqh_first;
    Indirect ref read is not const
  scanning: if (s_1 != target_6(D))
  scanning: session_group_synchronize1 (target_6(D), s_1);
  scanning: s_11 = s_1->gentry.tqe_next;
    Indirect ref read is not const
  scanning: if (s_1 != 0B)
  scanning: return;
Function is locally looping.
session_group_synchronize_from (struct session * target)
{
  struct session * s;
  struct session_group * sg;

  <bb 2> [20.48%]:
  sg_8 = session_group_find (target_6(D));
  if (sg_8 == 0B)
    goto <bb 8>; [26.74%]
  else
    goto <bb 3>; [73.26%]

  <bb 3> [15.00%]:
  s_9 = sg_8->sessions.tqh_first;
  goto <bb 7>; [100.00%]

  <bb 4> [85.00%]:
  if (s_1 != target_6(D))
    goto <bb 5>; [53.47%]
  else
    goto <bb 6>; [46.53%]

  <bb 5> [45.45%]:
  session_group_synchronize1 (target_6(D), s_1);

  <bb 6> [85.00%]:
  s_11 = s_1->gentry.tqe_next;

  <bb 7> [100.00%]:
  # s_1 = PHI <s_9(3), s_11(6)>
  if (s_1 != 0B)
    goto <bb 4>; [85.00%]
  else
    goto <bb 8>; [15.00%]

  <bb 8> [20.48%]:
  return;

}



;; Function session_destroy (session_destroy, funcdef_no=81, decl_uid=4551, cgraph_uid=81, symbol_order=84)



 local analysis of session_destroy
   scanning: _1 = s_31(D)->name;
    Indirect ref read is not const
  scanning: _48 = __printf_chk (1, "session %s destroyed\n", _1);
  scanning: _2 = session_index (s_31(D), &i);
  scanning: if (_2 != 0)
  scanning: _49 = __printf_chk (1, "session not found%s\n", "");
  scanning: exit (1);
  scanning: _3 = sessions.list;
    global memory read is not const
  scanning: i.1_4 = i;
  scanning: _5 = (long unsigned int) i.1_4;
  scanning: _6 = _5 * 8;
  scanning: _7 = _3 + _6;
  scanning: *_7 = 0B;
    Indirect ref write is not const/pure
  scanning: _8 = sessions.num;
    global memory read is not const
  scanning: if (_8 > 1)
  scanning: _9 = sessions.num;
    global memory read is not const
  scanning: _10 = _9 + 4294967295;
  scanning: sessions.num = _10;
    static/global memory write is not const/pure
  scanning: _11 = sessions.list;
    global memory read is not const
  scanning: free (_11);
  scanning: sessions.num = 0;
    static/global memory write is not const/pure
  scanning: sessions.list = 0B;
    static/global memory write is not const/pure
  scanning: sessions.space = 0;
    static/global memory write is not const/pure
  scanning: _12 = sessions.num;
    global memory read is not const
  scanning: if (_12 != 0)
  scanning: _13 = sessions.list;
    global memory read is not const
  scanning: _14 = sessions.num;
    global memory read is not const
  scanning: _15 = _14 + 4294967295;
  scanning: _16 = (long unsigned int) _15;
  scanning: _17 = _16 * 8;
  scanning: _18 = _13 + _17;
  scanning: _19 = *_18;
    Indirect ref read is not const
  scanning: if (_19 == 0B)
  scanning: session_group_remove (s_31(D));
  scanning: _20 = s_31(D)->lastw.tqh_first;
    Indirect ref read is not const
  scanning: _21 = &s_31(D)->lastw;
  scanning: winlink_stack_remove (_21, _20);
  scanning: _22 = s_31(D)->lastw.tqh_first;
    Indirect ref read is not const
  scanning: if (_22 != 0B)
  scanning: _23 = s_31(D)->windows.rbh_root;
    Indirect ref read is not const
  scanning: _24 = &s_31(D)->windows;
  scanning: winlink_remove (_24, _23);
  scanning: _25 = s_31(D)->windows.rbh_root;
    Indirect ref read is not const
  scanning: if (_25 != 0B)
  scanning: _26 = s_31(D)->name;
    Indirect ref read is not const
  scanning: free (_26);
  scanning: free (s_31(D));
  scanning: i ={v} {CLOBBER};
  scanning: return;
Function is locally looping.
Function can locally free.
session_destroy (struct session * s)
{
  int D.5208;
  int D.5206;
  u_int i;
  char * _1;
  int _2;
  struct session * * _3;
  unsigned int i.1_4;
  long unsigned int _5;
  long unsigned int _6;
  struct session * * _7;
  unsigned int _8;
  unsigned int _9;
  unsigned int _10;
  struct session * * _11;
  unsigned int _12;
  struct session * * _13;
  unsigned int _14;
  unsigned int _15;
  long unsigned int _16;
  long unsigned int _17;
  struct session * * _18;
  struct session * _19;
  struct winlink * _20;
  struct winlink_stack * _21;
  struct winlink * _22;
  struct winlink * _23;
  struct winlinks * _24;
  struct winlink * _25;
  char * _26;
  int _48;
  int _49;

  <bb 2> [14.44%]:
  _1 = s_31(D)->name;
  _48 = __printf_chk (1, "session %s destroyed\n", _1);
  _2 = session_index (s_31(D), &i);
  if (_2 != 0)
    goto <bb 3>; [0.04%]
  else
    goto <bb 4>; [99.96%]

  <bb 3> [0.01%]:
  _49 = __printf_chk (1, "session not found%s\n", "");
  exit (1);

  <bb 4> [14.44%]:
  _3 = sessions.list;
  i.1_4 = i;
  _5 = (long unsigned int) i.1_4;
  _6 = _5 * 8;
  _7 = _3 + _6;
  *_7 = 0B;
  goto <bb 16>; [100.00%]

  <bb 5> [85.56%]:
  _8 = sessions.num;
  if (_8 > 1)
    goto <bb 6>; [78.31%]
  else
    goto <bb 7>; [21.69%]

  <bb 6> [67.00%]:
  _9 = sessions.num;
  _10 = _9 + 4294967295;
  sessions.num = _10;
  goto <bb 8>; [100.00%]

  <bb 7> [18.56%]:
  _11 = sessions.list;
  free (_11);
  sessions.num = 0;
  sessions.list = 0B;
  sessions.space = 0;

  <bb 8> [85.56%]:

  <bb 16> [100.00%]:
  _12 = sessions.num;
  if (_12 != 0)
    goto <bb 9>; [92.50%]
  else
    goto <bb 10>; [7.50%]

  <bb 9> [92.50%]:
  _13 = sessions.list;
  _14 = sessions.num;
  _15 = _14 + 4294967295;
  _16 = (long unsigned int) _15;
  _17 = _16 * 8;
  _18 = _13 + _17;
  _19 = *_18;
  if (_19 == 0B)
    goto <bb 5>; [92.50%]
  else
    goto <bb 10>; [7.50%]

  <bb 10> [14.44%]:
  session_group_remove (s_31(D));
  goto <bb 12>; [100.00%]

  <bb 11> [81.81%]:
  _20 = s_31(D)->lastw.tqh_first;
  _21 = &s_31(D)->lastw;
  winlink_stack_remove (_21, _20);

  <bb 12> [96.25%]:
  _22 = s_31(D)->lastw.tqh_first;
  if (_22 != 0B)
    goto <bb 11>; [85.00%]
  else
    goto <bb 17>; [15.00%]

  <bb 17> [14.44%]:
  goto <bb 14>; [100.00%]

  <bb 13> [81.81%]:
  _23 = s_31(D)->windows.rbh_root;
  _24 = &s_31(D)->windows;
  winlink_remove (_24, _23);

  <bb 14> [96.25%]:
  _25 = s_31(D)->windows.rbh_root;
  if (_25 != 0B)
    goto <bb 13>; [85.00%]
  else
    goto <bb 15>; [15.00%]

  <bb 15> [14.44%]:
  _26 = s_31(D)->name;
  free (_26);
  free (s_31(D));
  i ={v} {CLOBBER};
  return;

}



;; Function session_detach (session_detach, funcdef_no=82, decl_uid=4565, cgraph_uid=82, symbol_order=85)



 local analysis of session_detach
   scanning: _1 = &s_6(D)->lastw;
  scanning: winlink_stack_remove (_1, wl_8(D));
  scanning: _2 = &s_6(D)->windows;
  scanning: winlink_remove (_2, wl_8(D));
  scanning: session_group_synchronize_from (s_6(D));
  scanning: _3 = s_6(D)->windows.rbh_root;
    Indirect ref read is not const
  scanning: if (_3 == 0B)
  scanning: session_destroy (s_6(D));
  scanning: return _4;
Function is locally looping.
session_detach (struct session * s, struct winlink * wl)
{
  struct winlink_stack * _1;
  struct winlinks * _2;
  struct winlink * _3;
  int _4;

  <bb 2> [100.00%]:
  _1 = &s_6(D)->lastw;
  winlink_stack_remove (_1, wl_8(D));
  _2 = &s_6(D)->windows;
  winlink_remove (_2, wl_8(D));
  session_group_synchronize_from (s_6(D));
  _3 = s_6(D)->windows.rbh_root;
  if (_3 == 0B)
    goto <bb 3>; [19.86%]
  else
    goto <bb 4>; [80.14%]

  <bb 3> [19.86%]:
  session_destroy (s_6(D));

  <bb 4> [100.00%]:
  # _4 = PHI <1(3), 0(2)>
  return _4;

}



;; Function server_destroy_session_group (server_destroy_session_group, funcdef_no=83, decl_uid=4568, cgraph_uid=83, symbol_order=86)



 local analysis of server_destroy_session_group
   scanning: sg_12 = session_group_find (s_10(D));
  scanning: if (sg_12 == 0B)
  scanning: _1 = sg_12->entry.tqe_next;
    Indirect ref read is not const
  scanning: if (_1 != 0B)
  scanning: _2 = sg_12->entry.tqe_next;
    Indirect ref read is not const
  scanning: _3 = sg_12->entry.tqe_prev;
    Indirect ref read is not const
  scanning: _2->entry.tqe_prev = _3;
    Indirect ref write is not const/pure
  scanning: _4 = sg_12->entry.tqe_prev;
    Indirect ref read is not const
  scanning: session_groups.tqh_last = _4;
    static/global memory write is not const/pure
  scanning: _5 = sg_12->entry.tqe_prev;
    Indirect ref read is not const
  scanning: _6 = sg_12->entry.tqe_next;
    Indirect ref read is not const
  scanning: *_5 = _6;
    Indirect ref write is not const/pure
  scanning: free (sg_12);
  scanning: return;
Function is locally looping.
Function can locally free.
server_destroy_session_group (struct session * s)
{
  struct session_group * sg;
  struct session_group * _1;
  struct session_group * _2;
  struct session_group * * _3;
  struct session_group * * _4;
  struct session_group * * _5;
  struct session_group * _6;

  <bb 2> [100.00%]:
  sg_12 = session_group_find (s_10(D));
  if (sg_12 == 0B)
    goto <bb 7>; [26.74%]
  else
    goto <bb 3>; [73.26%]

  <bb 3> [73.26%]:
  _1 = sg_12->entry.tqe_next;
  if (_1 != 0B)
    goto <bb 4>; [70.00%]
  else
    goto <bb 5>; [30.00%]

  <bb 4> [51.28%]:
  _2 = sg_12->entry.tqe_next;
  _3 = sg_12->entry.tqe_prev;
  _2->entry.tqe_prev = _3;
  goto <bb 6>; [100.00%]

  <bb 5> [21.98%]:
  _4 = sg_12->entry.tqe_prev;
  session_groups.tqh_last = _4;

  <bb 6> [73.26%]:
  _5 = sg_12->entry.tqe_prev;
  _6 = sg_12->entry.tqe_next;
  *_5 = _6;
  free (sg_12);

  <bb 7> [100.00%]:
  return;

}



;; Function server_kill_window (server_kill_window, funcdef_no=84, decl_uid=4572, cgraph_uid=84, symbol_order=87)



 local analysis of server_kill_window
   scanning: _1 = sessions.list;
    global memory read is not const
  scanning: _2 = (long unsigned int) i_9;
  scanning: _3 = _2 * 8;
  scanning: _4 = _1 + _3;
  scanning: s_16 = *_4;
    Indirect ref read is not const
  scanning: if (s_16 == 0B)
  scanning: _5 = session_has (s_16, w_17(D));
  scanning: if (_5 == 0)
  scanning: // predicted unlikely by continue predictor.
  scanning: _6 = session_detach (s_16, wl_20);
  scanning: if (_6 != 0)
  scanning: server_destroy_session_group (s_16);
  scanning: _7 = &s_16->windows;
  scanning: wl_20 = winlink_find_by_window (_7, w_17(D));
  scanning: if (wl_20 != 0B)
  scanning: i_23 = i_9 + 1;
  scanning: _8 = sessions.num;
    global memory read is not const
  scanning: if (_8 > i_9)
  scanning: return;
Function is locally looping.
server_kill_window (struct window * w)
{
  u_int i;
  struct winlink * wl;
  struct session * s;
  struct session * * _1;
  long unsigned int _2;
  long unsigned int _3;
  struct session * * _4;
  int _5;
  int _6;
  struct winlinks * _7;
  unsigned int _8;

  <bb 2> [7.12%]:
  goto <bb 10>; [100.00%]

  <bb 3> [40.35%]:
  _1 = sessions.list;
  _2 = (long unsigned int) i_9;
  _3 = _2 * 8;
  _4 = _1 + _3;
  s_16 = *_4;
  if (s_16 == 0B)
    goto <bb 5>; [30.00%]
  else
    goto <bb 4>; [70.00%]

  <bb 4> [28.24%]:
  _5 = session_has (s_16, w_17(D));
  if (_5 == 0)
    goto <bb 5>; [48.88%]
  else
    goto <bb 12>; [51.12%]

  <bb 5> [25.91%]:
  // predicted unlikely by continue predictor.
  goto <bb 9>; [100.00%]

  <bb 6> [92.50%]:
  _6 = session_detach (s_16, wl_20);
  if (_6 != 0)
    goto <bb 7>; [7.50%]
  else
    goto <bb 13>; [92.50%]

  <bb 13> [85.56%]:
  goto <bb 8>; [100.00%]

  <bb 7> [6.94%]:
  server_destroy_session_group (s_16);
  goto <bb 9>; [100.00%]

  <bb 12> [14.44%]:

  <bb 8> [100.00%]:
  _7 = &s_16->windows;
  wl_20 = winlink_find_by_window (_7, w_17(D));
  if (wl_20 != 0B)
    goto <bb 6>; [92.50%]
  else
    goto <bb 9>; [7.50%]

  <bb 9> [40.35%]:
  i_23 = i_9 + 1;

  <bb 10> [47.47%]:
  # i_9 = PHI <0(2), i_23(9)>
  _8 = sessions.num;
  if (_8 > i_9)
    goto <bb 3>; [85.00%]
  else
    goto <bb 11>; [15.00%]

  <bb 11> [7.12%]:
  return;

}



;; Function session_select (session_select, funcdef_no=85, decl_uid=4586, cgraph_uid=85, symbol_order=88)



 local analysis of session_select
   scanning: _1 = &s_8(D)->windows;
  scanning: wl_12 = winlink_find_by_index (_1, idx_10(D));
  scanning: if (wl_12 == 0B)
  scanning: _2 = s_8(D)->curw;
    Indirect ref read is not const
  scanning: if (_2 == wl_12)
  scanning: _3 = &s_8(D)->lastw;
  scanning: winlink_stack_remove (_3, wl_12);
  scanning: _4 = s_8(D)->curw;
    Indirect ref read is not const
  scanning: _5 = &s_8(D)->lastw;
  scanning: winlink_stack_push (_5, _4);
  scanning: s_8(D)->curw = wl_12;
    Indirect ref write is not const/pure
  scanning: return _6;
Function is locally looping.
session_select (struct session * s, int idx)
{
  struct winlink * wl;
  struct winlinks * _1;
  struct winlink * _2;
  struct winlink_stack * _3;
  struct winlink * _4;
  struct winlink_stack * _5;
  int _6;

  <bb 2> [100.00%]:
  _1 = &s_8(D)->windows;
  wl_12 = winlink_find_by_index (_1, idx_10(D));
  if (wl_12 == 0B)
    goto <bb 5>; [0.87%]
  else
    goto <bb 3>; [99.13%]

  <bb 3> [99.13%]:
  _2 = s_8(D)->curw;
  if (_2 == wl_12)
    goto <bb 5>; [42.57%]
  else
    goto <bb 4>; [57.43%]

  <bb 4> [56.93%]:
  _3 = &s_8(D)->lastw;
  winlink_stack_remove (_3, wl_12);
  _4 = s_8(D)->curw;
  _5 = &s_8(D)->lastw;
  winlink_stack_push (_5, _4);
  s_8(D)->curw = wl_12;

  <bb 5> [100.00%]:
  # _6 = PHI <-1(2), 1(3), 0(4)>
  return _6;

}



;; Function join_pane_exec (join_pane_exec, funcdef_no=86, decl_uid=4590, cgraph_uid=86, symbol_order=89)



 local analysis of join_pane_exec
   scanning: dst_wl_7 = cmd_find_pane (0, &dst_s);
  scanning: if (dst_wl_7 == 0B)
  scanning: dst_w_8 = dst_wl_7->window;
    Indirect ref read is not const
  scanning: src_wl_10 = cmd_find_pane (1, 0B);
  scanning: if (src_wl_10 == 0B)
  scanning: src_w_11 = src_wl_10->window;
    Indirect ref read is not const
  scanning: if (dst_w_8 == src_w_11)
  scanning: _20 = __printf_chk (1, "can\'t join a pane to its own window\n");
  scanning: server_kill_window (src_w_11);
  scanning: _1 = dst_wl_7->idx;
    Indirect ref read is not const
  scanning: dst_s.2_2 = dst_s;
  scanning: session_select (dst_s.2_2, _1);
  scanning: dst_s ={v} {CLOBBER};
  scanning: return _3;
Function is locally looping.
Function can locally free.
join_pane_exec ()
{
  int D.5210;
  struct window * dst_w;
  struct window * src_w;
  struct winlink * dst_wl;
  struct winlink * src_wl;
  struct session * dst_s;
  int _1;
  struct session * dst_s.2_2;
  int _3;
  int _20;

  <bb 2> [100.00%]:
  dst_wl_7 = cmd_find_pane (0, &dst_s);
  if (dst_wl_7 == 0B)
    goto <bb 7>; [1.74%]
  else
    goto <bb 3>; [98.26%]

  <bb 3> [98.26%]:
  dst_w_8 = dst_wl_7->window;
  src_wl_10 = cmd_find_pane (1, 0B);
  if (src_wl_10 == 0B)
    goto <bb 7>; [0.87%]
  else
    goto <bb 4>; [99.13%]

  <bb 4> [97.41%]:
  src_w_11 = src_wl_10->window;
  if (dst_w_8 == src_w_11)
    goto <bb 5>; [0.87%]
  else
    goto <bb 6>; [99.13%]

  <bb 5> [0.85%]:
  _20 = __printf_chk (1, "can\'t join a pane to its own window\n");
  goto <bb 7>; [100.00%]

  <bb 6> [96.56%]:
  server_kill_window (src_w_11);
  _1 = dst_wl_7->idx;
  dst_s.2_2 = dst_s;
  session_select (dst_s.2_2, _1);

  <bb 7> [100.00%]:
  # _3 = PHI <-1(2), -1(3), -1(5), 0(6)>
  dst_s ={v} {CLOBBER};
  return _3;

}



;; Function window_create1 (window_create1, funcdef_no=87, decl_uid=4599, cgraph_uid=87, symbol_order=90)



 local analysis of window_create1
   scanning: w_43 = malloc (88);
  scanning: w_43->name = 0B;
    Indirect ref write is not const/pure
  scanning: w_43->flags = 0;
    Indirect ref write is not const/pure
  scanning: w_43->active = 0B;
    Indirect ref write is not const/pure
  scanning: w_43->lastlayout = -1;
    Indirect ref write is not const/pure
  scanning: w_43->layout_root = 0B;
    Indirect ref write is not const/pure
  scanning: w_43->sx = sx_49(D);
    Indirect ref write is not const/pure
  scanning: w_43->sy = sy_51(D);
    Indirect ref write is not const/pure
  scanning: _1 = windows.list;
    global memory read is not const
  scanning: _2 = (long unsigned int) i_37;
  scanning: _3 = _2 * 8;
  scanning: _4 = _1 + _3;
  scanning: _5 = *_4;
    Indirect ref read is not const
  scanning: if (_5 == 0B)
  scanning: _6 = windows.list;
    global memory read is not const
  scanning: _7 = (long unsigned int) i_37;
  scanning: _8 = _7 * 8;
  scanning: _9 = _6 + _8;
  scanning: *_9 = w_43;
    Indirect ref write is not const/pure
  scanning: i_54 = i_37 + 1;
  scanning: _10 = windows.num;
    global memory read is not const
  scanning: if (_10 > i_37)
  scanning: _11 = windows.num;
    global memory read is not const
  scanning: if (_11 == i_37)
  scanning: _12 = windows.num;
    global memory read is not const
  scanning: if (_12 > 1073741823)
  scanning: _71 = __printf_chk (1, "number too big%s", "");
  scanning: exit (1);
  scanning: _13 = windows.num;
    global memory read is not const
  scanning: _14 = _13 + 1;
  scanning: _15 = 1073741824 / _14;
  scanning: if (_15 <= 7)
  scanning: _72 = __printf_chk (1, "size too big%s", "");
  scanning: exit (1);
  scanning: _16 = windows.space;
    global memory read is not const
  scanning: if (_16 == 0)
  scanning: windows.space = 80;
    static/global memory write is not const/pure
  scanning: _17 = windows.space;
    global memory read is not const
  scanning: _18 = windows.list;
    global memory read is not const
  scanning: _19 = xrealloc (_18, 1, _17);
  scanning: windows.list = _19;
    static/global memory write is not const/pure
  scanning: _20 = windows.space;
    global memory read is not const
  scanning: _21 = windows.list;
    global memory read is not const
  scanning: _22 = xrealloc (_21, 2, _20);
  scanning: windows.list = _22;
    static/global memory write is not const/pure
  scanning: _23 = windows.space;
    global memory read is not const
  scanning: _24 = _23 * 2;
  scanning: windows.space = _24;
    static/global memory write is not const/pure
  scanning: _25 = windows.space;
    global memory read is not const
  scanning: _26 = windows.num;
    global memory read is not const
  scanning: _27 = _26 + 1;
  scanning: _28 = (long unsigned int) _27;
  scanning: _29 = _28 * 8;
  scanning: if (_25 <= _29)
  scanning: _30 = windows.list;
    global memory read is not const
  scanning: _31 = windows.num;
    global memory read is not const
  scanning: _32 = (long unsigned int) _31;
  scanning: _33 = _32 * 8;
  scanning: _34 = _30 + _33;
  scanning: *_34 = w_43;
    Indirect ref write is not const/pure
  scanning: _35 = windows.num;
    global memory read is not const
  scanning: _36 = _35 + 1;
  scanning: windows.num = _36;
    static/global memory write is not const/pure
  scanning: w_43->references = 0;
    Indirect ref write is not const/pure
  scanning: _69 = w_43;
  scanning: return w_43;
Function is locally looping.
Function can locally free.
window_create1 (u_int sx, u_int sy)
{
  int D.5214;
  int D.5212;
  u_int i;
  struct window * w;
  struct window * * _1;
  long unsigned int _2;
  long unsigned int _3;
  struct window * * _4;
  struct window * _5;
  struct window * * _6;
  long unsigned int _7;
  long unsigned int _8;
  struct window * * _9;
  unsigned int _10;
  unsigned int _11;
  unsigned int _12;
  unsigned int _13;
  unsigned int _14;
  unsigned int _15;
  long unsigned int _16;
  long unsigned int _17;
  struct window * * _18;
  void * _19;
  long unsigned int _20;
  struct window * * _21;
  void * _22;
  long unsigned int _23;
  long unsigned int _24;
  long unsigned int _25;
  unsigned int _26;
  unsigned int _27;
  long unsigned int _28;
  long unsigned int _29;
  struct window * * _30;
  unsigned int _31;
  long unsigned int _32;
  long unsigned int _33;
  struct window * * _34;
  unsigned int _35;
  unsigned int _36;
  struct window * _69;
  int _71;
  int _72;

  <bb 2> [14.44%]:
  w_43 = malloc (88);
  w_43->name = 0B;
  w_43->flags = 0;
  w_43->active = 0B;
  w_43->lastlayout = -1;
  w_43->layout_root = 0B;
  w_43->sx = sx_49(D);
  w_43->sy = sy_51(D);
  goto <bb 6>; [100.00%]

  <bb 3> [92.50%]:
  _1 = windows.list;
  _2 = (long unsigned int) i_37;
  _3 = _2 * 8;
  _4 = _1 + _3;
  _5 = *_4;
  if (_5 == 0B)
    goto <bb 4>; [7.50%]
  else
    goto <bb 5>; [92.50%]

  <bb 4> [6.94%]:
  _6 = windows.list;
  _7 = (long unsigned int) i_37;
  _8 = _7 * 8;
  _9 = _6 + _8;
  *_9 = w_43;
  goto <bb 7>; [100.00%]

  <bb 5> [85.56%]:
  i_54 = i_37 + 1;

  <bb 6> [100.00%]:
  # i_37 = PHI <0(2), i_54(5)>
  _10 = windows.num;
  if (_10 > i_37)
    goto <bb 3>; [92.50%]
  else
    goto <bb 7>; [7.50%]

  <bb 7> [14.44%]:
  _11 = windows.num;
  if (_11 == i_37)
    goto <bb 8>; [37.68%]
  else
    goto <bb 18>; [62.32%]

  <bb 8> [5.44%]:
  _12 = windows.num;
  if (_12 > 1073741823)
    goto <bb 9>; [0.04%]
  else
    goto <bb 10>; [99.96%]

  <bb 9> [0.00%]:
  _71 = __printf_chk (1, "number too big%s", "");
  exit (1);

  <bb 10> [5.44%]:
  _13 = windows.num;
  _14 = _13 + 1;
  _15 = 1073741824 / _14;
  if (_15 <= 7)
    goto <bb 11>; [0.04%]
  else
    goto <bb 12>; [99.96%]

  <bb 11> [0.00%]:
  _72 = __printf_chk (1, "size too big%s", "");
  exit (1);

  <bb 12> [5.44%]:
  _16 = windows.space;
  if (_16 == 0)
    goto <bb 13>; [33.00%]
  else
    goto <bb 16>; [67.00%]

  <bb 13> [1.79%]:
  windows.space = 80;
  _17 = windows.space;
  _18 = windows.list;
  _19 = xrealloc (_18, 1, _17);
  windows.list = _19;

  <bb 16> [5.44%]:
  goto <bb 19>; [100.00%]

  <bb 14> [30.80%]:
  _20 = windows.space;
  _21 = windows.list;
  _22 = xrealloc (_21, 2, _20);
  windows.list = _22;
  _23 = windows.space;
  _24 = _23 * 2;
  windows.space = _24;

  <bb 19> [36.24%]:
  _25 = windows.space;
  _26 = windows.num;
  _27 = _26 + 1;
  _28 = (long unsigned int) _27;
  _29 = _28 * 8;
  if (_25 <= _29)
    goto <bb 14>; [85.00%]
  else
    goto <bb 17>; [15.00%]

  <bb 17> [5.44%]:
  _30 = windows.list;
  _31 = windows.num;
  _32 = (long unsigned int) _31;
  _33 = _32 * 8;
  _34 = _30 + _33;
  *_34 = w_43;
  _35 = windows.num;
  _36 = _35 + 1;
  windows.num = _36;

  <bb 18> [14.43%]:
  w_43->references = 0;
  _69 = w_43;
  return w_43;

}



;; Function session_attach (session_attach, funcdef_no=88, decl_uid=4613, cgraph_uid=88, symbol_order=91)



 local analysis of session_attach
   scanning: _1 = &s_3(D)->windows;
  scanning: wl_8 = winlink_add (_1, w_5(D), idx_6(D));
  scanning: if (wl_8 == 0B)
  scanning: _12 = __printf_chk (1, "index in use: %d\n", idx_6(D));
  scanning: session_group_synchronize_from (s_3(D));
  scanning: return wl_8;
Function is locally looping.
Function can locally free.
session_attach (struct session * s, struct window * w, int idx, char * * cause)
{
  int D.5217;
  struct winlink * wl;
  struct winlinks * _1;
  int _12;

  <bb 2> [100.00%]:
  _1 = &s_3(D)->windows;
  wl_8 = winlink_add (_1, w_5(D), idx_6(D));
  if (wl_8 == 0B)
    goto <bb 3>; [19.86%]
  else
    goto <bb 4>; [80.14%]

  <bb 3> [19.86%]:
  _12 = __printf_chk (1, "index in use: %d\n", idx_6(D));

  <bb 4> [100.00%]:
  session_group_synchronize_from (s_3(D));
  return wl_8;

}



;; Function session_new (session_new, funcdef_no=89, decl_uid=4622, cgraph_uid=89, symbol_order=92)



 local analysis of session_new
   scanning: _1 = s_6(D)->sy;
    Indirect ref read is not const
  scanning: _2 = s_6(D)->sx;
    Indirect ref read is not const
  scanning: w_8 = window_create1 (_2, _1);
  scanning: if (w_8 == 0B)
  scanning: _12 = session_attach (s_6(D), w_8, idx_9(D), cause_10(D));
  scanning: return _3;
Function is locally looping.
session_new (struct session * s, const char * name, const char * cmd, const char * cwd, int idx, char * * cause)
{
  struct window * w;
  unsigned int _1;
  unsigned int _2;
  struct winlink * _3;
  struct winlink * _12;

  <bb 2> [100.00%]:
  _1 = s_6(D)->sy;
  _2 = s_6(D)->sx;
  w_8 = window_create1 (_2, _1);
  if (w_8 == 0B)
    goto <bb 4>; [7.92%]
  else
    goto <bb 3>; [92.08%]

  <bb 3> [92.08%]:
  _12 = session_attach (s_6(D), w_8, idx_9(D), cause_10(D));

  <bb 4> [100.00%]:
  # _3 = PHI <0B(2), _12(3)>
  return _3;

}



;; Function session_create (session_create, funcdef_no=90, decl_uid=4636, cgraph_uid=90, symbol_order=93)



 local analysis of session_create
   scanning: s_52 = malloc (112);
  scanning: s_52->references = 0;
    Indirect ref write is not const/pure
  scanning: s_52->flags = 0;
    Indirect ref write is not const/pure
  scanning: s_52->curw = 0B;
    Indirect ref write is not const/pure
  scanning: s_52->lastw.tqh_first = 0B;
    Indirect ref write is not const/pure
  scanning: _1 = &s_52->lastw.tqh_first;
  scanning: s_52->lastw.tqh_last = _1;
    Indirect ref write is not const/pure
  scanning: s_52->windows.rbh_root = 0B;
    Indirect ref write is not const/pure
  scanning: s_52->tio = 0B;
    Indirect ref write is not const/pure
  scanning: s_52->sx = sx_60(D);
    Indirect ref write is not const/pure
  scanning: s_52->sy = sy_62(D);
    Indirect ref write is not const/pure
  scanning: _2 = sessions.list;
    global memory read is not const
  scanning: _3 = (long unsigned int) i_43;
  scanning: _4 = _3 * 8;
  scanning: _5 = _2 + _4;
  scanning: _6 = *_5;
    Indirect ref read is not const
  scanning: if (_6 == 0B)
  scanning: _7 = sessions.list;
    global memory read is not const
  scanning: _8 = (long unsigned int) i_43;
  scanning: _9 = _8 * 8;
  scanning: _10 = _7 + _9;
  scanning: *_10 = s_52;
    Indirect ref write is not const/pure
  scanning: i_65 = i_43 + 1;
  scanning: _11 = sessions.num;
    global memory read is not const
  scanning: if (_11 > i_43)
  scanning: _12 = sessions.num;
    global memory read is not const
  scanning: if (_12 == i_43)
  scanning: _13 = sessions.num;
    global memory read is not const
  scanning: if (_13 > 1073741823)
  scanning: _95 = __printf_chk (1, "number too big%s", "");
  scanning: exit (1);
  scanning: _14 = sessions.num;
    global memory read is not const
  scanning: _15 = _14 + 1;
  scanning: _16 = 1073741824 / _15;
  scanning: if (_16 <= 7)
  scanning: _96 = __printf_chk (1, "size too big%s", "");
  scanning: exit (1);
  scanning: _17 = sessions.space;
    global memory read is not const
  scanning: if (_17 == 0)
  scanning: sessions.space = 80;
    static/global memory write is not const/pure
  scanning: _18 = sessions.space;
    global memory read is not const
  scanning: _19 = sessions.list;
    global memory read is not const
  scanning: _20 = xrealloc (_19, 1, _18);
  scanning: sessions.list = _20;
    static/global memory write is not const/pure
  scanning: _21 = sessions.space;
    global memory read is not const
  scanning: _22 = sessions.list;
    global memory read is not const
  scanning: _23 = xrealloc (_22, 2, _21);
  scanning: sessions.list = _23;
    static/global memory write is not const/pure
  scanning: _24 = sessions.space;
    global memory read is not const
  scanning: _25 = _24 * 2;
  scanning: sessions.space = _25;
    static/global memory write is not const/pure
  scanning: _26 = sessions.space;
    global memory read is not const
  scanning: _27 = sessions.num;
    global memory read is not const
  scanning: _28 = _27 + 1;
  scanning: _29 = (long unsigned int) _28;
  scanning: _30 = _29 * 8;
  scanning: if (_26 <= _30)
  scanning: _31 = sessions.list;
    global memory read is not const
  scanning: _32 = sessions.num;
    global memory read is not const
  scanning: _33 = (long unsigned int) _32;
  scanning: _34 = _33 * 8;
  scanning: _35 = _31 + _34;
  scanning: *_35 = s_52;
    Indirect ref write is not const/pure
  scanning: _36 = sessions.num;
    global memory read is not const
  scanning: _37 = _36 + 1;
  scanning: sessions.num = _37;
    static/global memory write is not const/pure
  scanning: if (name_79(D) == 0B)
  scanning: _97 = __printf_chk (1, "no name%s\n", "");
  scanning: exit (1);
  scanning: _38 = strdup (name_79(D));
  scanning: s_52->name = _38;
    Indirect ref write is not const/pure
  scanning: if (cmd_82(D) != 0B)
  scanning: _39 = session_new (s_52, 0B, cmd_82(D), cwd_83(D), idx_84(D), cause_85(D));
  scanning: if (_39 == 0B)
  scanning: session_destroy (s_52);
  scanning: _40 = s_52->windows.rbh_root;
    Indirect ref read is not const
  scanning: _41 = _40->idx;
    Indirect ref read is not const
  scanning: session_select (s_52, _41);
  scanning: _42 = s_52->name;
    Indirect ref read is not const
  scanning: _98 = __printf_chk (1, "session %s created\n", _42);
  scanning: _91 = s_52;
  scanning: return _44;
Function is locally looping.
Function can locally free.
session_create (const char * name, const char * cmd, const char * cwd, struct environ * env, struct termios * tio, int idx, u_int sx, u_int sy, char * * cause)
{
  int D.5225;
  int D.5223;
  int D.5221;
  int D.5219;
  u_int i;
  struct session * s;
  struct winlink * * _1;
  struct session * * _2;
  long unsigned int _3;
  long unsigned int _4;
  struct session * * _5;
  struct session * _6;
  struct session * * _7;
  long unsigned int _8;
  long unsigned int _9;
  struct session * * _10;
  unsigned int _11;
  unsigned int _12;
  unsigned int _13;
  unsigned int _14;
  unsigned int _15;
  unsigned int _16;
  long unsigned int _17;
  long unsigned int _18;
  struct session * * _19;
  void * _20;
  long unsigned int _21;
  struct session * * _22;
  void * _23;
  long unsigned int _24;
  long unsigned int _25;
  long unsigned int _26;
  unsigned int _27;
  unsigned int _28;
  long unsigned int _29;
  long unsigned int _30;
  struct session * * _31;
  unsigned int _32;
  long unsigned int _33;
  long unsigned int _34;
  struct session * * _35;
  unsigned int _36;
  unsigned int _37;
  char * _38;
  struct winlink * _39;
  struct winlink * _40;
  int _41;
  char * _42;
  struct session * _44;
  struct session * _91;
  int _95;
  int _96;
  int _97;
  int _98;

  <bb 2> [14.44%]:
  s_52 = malloc (112);
  s_52->references = 0;
  s_52->flags = 0;
  s_52->curw = 0B;
  s_52->lastw.tqh_first = 0B;
  _1 = &s_52->lastw.tqh_first;
  s_52->lastw.tqh_last = _1;
  s_52->windows.rbh_root = 0B;
  s_52->tio = 0B;
  s_52->sx = sx_60(D);
  s_52->sy = sy_62(D);
  goto <bb 6>; [100.00%]

  <bb 3> [92.50%]:
  _2 = sessions.list;
  _3 = (long unsigned int) i_43;
  _4 = _3 * 8;
  _5 = _2 + _4;
  _6 = *_5;
  if (_6 == 0B)
    goto <bb 4>; [7.50%]
  else
    goto <bb 5>; [92.50%]

  <bb 4> [6.94%]:
  _7 = sessions.list;
  _8 = (long unsigned int) i_43;
  _9 = _8 * 8;
  _10 = _7 + _9;
  *_10 = s_52;
  goto <bb 7>; [100.00%]

  <bb 5> [85.56%]:
  i_65 = i_43 + 1;

  <bb 6> [100.00%]:
  # i_43 = PHI <0(2), i_65(5)>
  _11 = sessions.num;
  if (_11 > i_43)
    goto <bb 3>; [92.50%]
  else
    goto <bb 7>; [7.50%]

  <bb 7> [14.44%]:
  _12 = sessions.num;
  if (_12 == i_43)
    goto <bb 8>; [34.00%]
  else
    goto <bb 18>; [66.00%]

  <bb 8> [4.91%]:
  _13 = sessions.num;
  if (_13 > 1073741823)
    goto <bb 9>; [0.04%]
  else
    goto <bb 10>; [99.96%]

  <bb 9> [0.00%]:
  _95 = __printf_chk (1, "number too big%s", "");
  exit (1);

  <bb 10> [4.91%]:
  _14 = sessions.num;
  _15 = _14 + 1;
  _16 = 1073741824 / _15;
  if (_16 <= 7)
    goto <bb 11>; [0.04%]
  else
    goto <bb 12>; [99.96%]

  <bb 11> [0.00%]:
  _96 = __printf_chk (1, "size too big%s", "");
  exit (1);

  <bb 12> [4.90%]:
  _17 = sessions.space;
  if (_17 == 0)
    goto <bb 13>; [33.00%]
  else
    goto <bb 16>; [67.00%]

  <bb 13> [1.62%]:
  sessions.space = 80;
  _18 = sessions.space;
  _19 = sessions.list;
  _20 = xrealloc (_19, 1, _18);
  sessions.list = _20;

  <bb 16> [4.90%]:
  goto <bb 26>; [100.00%]

  <bb 14> [27.79%]:
  _21 = sessions.space;
  _22 = sessions.list;
  _23 = xrealloc (_22, 2, _21);
  sessions.list = _23;
  _24 = sessions.space;
  _25 = _24 * 2;
  sessions.space = _25;

  <bb 26> [32.70%]:
  _26 = sessions.space;
  _27 = sessions.num;
  _28 = _27 + 1;
  _29 = (long unsigned int) _28;
  _30 = _29 * 8;
  if (_26 <= _30)
    goto <bb 14>; [85.00%]
  else
    goto <bb 17>; [15.00%]

  <bb 17> [4.90%]:
  _31 = sessions.list;
  _32 = sessions.num;
  _33 = (long unsigned int) _32;
  _34 = _33 * 8;
  _35 = _31 + _34;
  *_35 = s_52;
  _36 = sessions.num;
  _37 = _36 + 1;
  sessions.num = _37;

  <bb 18> [14.43%]:
  if (name_79(D) == 0B)
    goto <bb 19>; [0.04%]
  else
    goto <bb 20>; [99.96%]

  <bb 19> [0.01%]:
  _97 = __printf_chk (1, "no name%s\n", "");
  exit (1);

  <bb 20> [14.43%]:
  _38 = strdup (name_79(D));
  s_52->name = _38;
  if (cmd_82(D) != 0B)
    goto <bb 21>; [70.00%]
  else
    goto <bb 24>; [30.00%]

  <bb 21> [10.10%]:
  _39 = session_new (s_52, 0B, cmd_82(D), cwd_83(D), idx_84(D), cause_85(D));
  if (_39 == 0B)
    goto <bb 22>; [4.07%]
  else
    goto <bb 23>; [95.93%]

  <bb 22> [0.41%]:
  session_destroy (s_52);
  goto <bb 25>; [100.00%]

  <bb 23> [9.69%]:
  _40 = s_52->windows.rbh_root;
  _41 = _40->idx;
  session_select (s_52, _41);

  <bb 24> [14.02%]:
  _42 = s_52->name;
  _98 = __printf_chk (1, "session %s created\n", _42);
  _91 = s_52;

  <bb 25> [14.43%]:
  # _44 = PHI <0B(22), s_52(24)>
  return _44;

}



;; Function main (main, funcdef_no=91, decl_uid=4648, cgraph_uid=91, symbol_order=94) (executed once)



 local analysis of main
   scanning: windows.num = 0;
    static/global memory write is not const/pure
  scanning: windows.list = 0B;
    static/global memory write is not const/pure
  scanning: windows.space = 0;
    static/global memory write is not const/pure
  scanning: sessions.num = 0;
    static/global memory write is not const/pure
  scanning: sessions.list = 0B;
    static/global memory write is not const/pure
  scanning: sessions.space = 0;
    static/global memory write is not const/pure
  scanning: session_groups.tqh_first = 0B;
    static/global memory write is not const/pure
  scanning: session_groups.tqh_last = &session_groups.tqh_first;
    static/global memory write is not const/pure
  scanning: _1 = (long unsigned int) i_29;
  scanning: _2 = _1 * 8;
  scanning: _3 = argv_51(D) + _2;
  scanning: _4 = *_3;
    Indirect ref read is not const
  scanning: _5 = *_4;
    Indirect ref read is not const
  scanning: if (_5 == 116)
  scanning: if (i_29 > 0)
  scanning: _6 = (long unsigned int) i_29;
  scanning: _7 = _6 * 8;
  scanning: _8 = _7 + 18446744073709551608;
  scanning: _9 = argv_51(D) + _8;
  scanning: _10 = *_9;
    Indirect ref read is not const
  scanning: target_53 = strdup (_10);
  scanning: groupwith_56 = session_find (target_26);
  scanning: if (target_26 == 0B)
  scanning: cmd_59 = strdup ("cmd");
  scanning: free (target_26);
  scanning: _11 = (long unsigned int) i_29;
  scanning: _12 = _11 * 8;
  scanning: _13 = argv_51(D) + _12;
  scanning: _14 = *_13;
    Indirect ref read is not const
  scanning: name_62 = strdup (_14);
  scanning: sy.3_15 = (unsigned int) sy_63(D);
  scanning: sx.4_16 = (unsigned int) sx_64(D);
  scanning: idx.5_17 = idx_28;
  scanning: idx_65 = idx_28 + 1;
  scanning: s_67 = session_create (name_62, cmd_27, "cwd", 0B, 0B, idx.5_17, sx.4_16, sy.3_15, &cause);
  scanning: sy.6_18 = (unsigned int) sy_63(D);
  scanning: sx.7_19 = (unsigned int) sx_64(D);
  scanning: w_69 = window_create1 (sx.7_19, sy.6_18);
  scanning: idx.8_20 = idx_65;
  scanning: idx_70 = idx_28 + 2;
  scanning: session_attach (s_67, w_69, idx.8_20, &cause);
  scanning: free (cmd_27);
  scanning: if (groupwith_56 != 0B)
  scanning: session_group_add (groupwith_56, s_67);
  scanning: session_group_synchronize_to (s_67);
  scanning: _21 = s_67->windows.rbh_root;
    Indirect ref read is not const
  scanning: _22 = _21->idx;
    Indirect ref read is not const
  scanning: session_select (s_67, _22);
  scanning: i_76 = i_29 + 1;
  scanning: if (i_29 < argc_46(D))
  scanning: join_pane_exec ();
  scanning: _23 = sessions.list;
    global memory read is not const
  scanning: _24 = *_23;
    Indirect ref read is not const
  scanning: session_destroy (_24);
  scanning: _25 = sessions.num;
    global memory read is not const
  scanning: if (_25 != 0)
  scanning: cause ={v} {CLOBBER};
  scanning: return 0;
Function is locally looping.
Function can locally free.
main (int argc, char * * argv)
{
  int i;
  int sy;
  int sx;
  int idx;
  char * cause;
  char * name;
  char * cmd;
  char * target;
  struct window * w;
  struct session * groupwith;
  struct session * s;
  long unsigned int _1;
  long unsigned int _2;
  char * * _3;
  char * _4;
  char _5;
  long unsigned int _6;
  long unsigned int _7;
  sizetype _8;
  char * * _9;
  char * _10;
  long unsigned int _11;
  long unsigned int _12;
  char * * _13;
  char * _14;
  unsigned int sy.3_15;
  unsigned int sx.4_16;
  int idx.5_17;
  unsigned int sy.6_18;
  unsigned int sx.7_19;
  int idx.8_20;
  struct winlink * _21;
  int _22;
  struct session * * _23;
  struct session * _24;
  unsigned int _25;

  <bb 2> [15.00%]:
  windows.num = 0;
  windows.list = 0B;
  windows.space = 0;
  sessions.num = 0;
  sessions.list = 0B;
  sessions.space = 0;
  session_groups.tqh_first = 0B;
  session_groups.tqh_last = &session_groups.tqh_first;
  goto <bb 11>; [100.00%]

  <bb 3> [85.00%]:
  _1 = (long unsigned int) i_29;
  _2 = _1 * 8;
  _3 = argv_51(D) + _2;
  _4 = *_3;
  _5 = *_4;
  if (_5 == 116)
    goto <bb 4>; [34.00%]
  else
    goto <bb 6>; [66.00%]

  <bb 4> [28.90%]:
  if (i_29 > 0)
    goto <bb 5>; [97.72%]
  else
    goto <bb 6>; [2.28%]

  <bb 5> [28.24%]:
  _6 = (long unsigned int) i_29;
  _7 = _6 * 8;
  _8 = _7 + 18446744073709551608;
  _9 = argv_51(D) + _8;
  _10 = *_9;
  target_53 = strdup (_10);

  <bb 6> [85.00%]:
  # target_26 = PHI <target_53(5), 0B(4), 0B(3)>
  groupwith_56 = session_find (target_26);
  if (target_26 == 0B)
    goto <bb 7>; [17.43%]
  else
    goto <bb 8>; [82.57%]

  <bb 7> [14.82%]:
  cmd_59 = strdup ("cmd");

  <bb 8> [85.00%]:
  # cmd_27 = PHI <cmd_59(7), 0B(6)>
  free (target_26);
  _11 = (long unsigned int) i_29;
  _12 = _11 * 8;
  _13 = argv_51(D) + _12;
  _14 = *_13;
  name_62 = strdup (_14);
  sy.3_15 = (unsigned int) sy_63(D);
  sx.4_16 = (unsigned int) sx_64(D);
  idx.5_17 = idx_28;
  idx_65 = idx_28 + 1;
  s_67 = session_create (name_62, cmd_27, "cwd", 0B, 0B, idx.5_17, sx.4_16, sy.3_15, &cause);
  sy.6_18 = (unsigned int) sy_63(D);
  sx.7_19 = (unsigned int) sx_64(D);
  w_69 = window_create1 (sx.7_19, sy.6_18);
  idx.8_20 = idx_65;
  idx_70 = idx_28 + 2;
  session_attach (s_67, w_69, idx.8_20, &cause);
  free (cmd_27);
  if (groupwith_56 != 0B)
    goto <bb 9>; [53.47%]
  else
    goto <bb 10>; [46.53%]

  <bb 9> [45.45%]:
  session_group_add (groupwith_56, s_67);
  session_group_synchronize_to (s_67);
  _21 = s_67->windows.rbh_root;
  _22 = _21->idx;
  session_select (s_67, _22);

  <bb 10> [85.00%]:
  i_76 = i_29 + 1;

  <bb 11> [100.00%]:
  # idx_28 = PHI <0(2), idx_70(10)>
  # i_29 = PHI <0(2), i_76(10)>
  if (i_29 < argc_46(D))
    goto <bb 3>; [85.00%]
  else
    goto <bb 12>; [15.00%]

  <bb 12> [15.00%]:
  join_pane_exec ();
  goto <bb 14>; [100.00%]

  <bb 13> [85.00%]:
  _23 = sessions.list;
  _24 = *_23;
  session_destroy (_24);

  <bb 14> [100.00%]:
  _25 = sessions.num;
  if (_25 != 0)
    goto <bb 13>; [85.00%]
  else
    goto <bb 15>; [15.00%]

  <bb 15> [15.00%]:
  cause ={v} {CLOBBER};
  return 0;

}


