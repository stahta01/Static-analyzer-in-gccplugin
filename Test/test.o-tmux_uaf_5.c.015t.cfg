
;; Function poll_items_RB_INSERT_COLOR (poll_items_RB_INSERT_COLOR, funcdef_no=22, decl_uid=3796, cgraph_uid=23, symbol_order=26)

Removing basic block 14
Merging blocks 16 and 17
Removing basic block 24
Merging blocks 26 and 27
Removing basic block 38
Merging blocks 40 and 41
Removing basic block 48
;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46
;;
;; Loop 1
;;  header 44, multiple latches: 6 23 26 43
;;  depth 1, outer 0
;;  nodes: 44 6 23 26 43 41 42 40 39 38 36 37 27 35 33 34 32 31 30 28 29 24 25 3 45 21 22 20 19 18 16 17 7 15 13 14 12 11 10 8 9 4 5
;; 2 succs { 44 }
;; 3 succs { 4 24 }
;; 4 succs { 5 7 }
;; 5 succs { 6 7 }
;; 6 succs { 44 }
;; 7 succs { 8 16 }
;; 8 succs { 9 10 }
;; 9 succs { 10 }
;; 10 succs { 11 14 }
;; 11 succs { 12 13 }
;; 12 succs { 15 }
;; 13 succs { 15 }
;; 14 succs { 15 }
;; 15 succs { 16 }
;; 16 succs { 17 18 }
;; 17 succs { 18 }
;; 18 succs { 19 22 }
;; 19 succs { 20 21 }
;; 20 succs { 23 }
;; 21 succs { 23 }
;; 22 succs { 23 }
;; 23 succs { 44 }
;; 24 succs { 25 27 }
;; 25 succs { 26 27 }
;; 26 succs { 44 }
;; 27 succs { 28 36 }
;; 28 succs { 29 30 }
;; 29 succs { 30 }
;; 30 succs { 31 34 }
;; 31 succs { 32 33 }
;; 32 succs { 35 }
;; 33 succs { 35 }
;; 34 succs { 35 }
;; 35 succs { 36 }
;; 36 succs { 37 38 }
;; 37 succs { 38 }
;; 38 succs { 39 42 }
;; 39 succs { 40 41 }
;; 40 succs { 43 }
;; 41 succs { 43 }
;; 42 succs { 43 }
;; 43 succs { 44 }
;; 44 succs { 45 46 }
;; 45 succs { 3 46 }
;; 46 succs { 1 }
void poll_items_RB_INSERT_COLOR (struct poll_items * head, struct poll_item * elm)
{
  struct poll_item * tmp;
  struct poll_item * gparent;
  struct poll_item * parent;

  <bb 2> :
  goto <bb 44>; [INV]

  <bb 3> :
  gparent = parent->entry.rbe_parent;
  _1 = gparent->entry.rbe_left;
  if (parent == _1)
    goto <bb 4>; [INV]
  else
    goto <bb 24>; [INV]

  <bb 4> :
  tmp = gparent->entry.rbe_right;
  if (tmp != 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 5> :
  _2 = tmp->entry.rbe_color;
  if (_2 == 1)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  tmp->entry.rbe_color = 0;
  parent->entry.rbe_color = 0;
  gparent->entry.rbe_color = 1;
  elm = gparent;
  // predicted unlikely by continue predictor.
  goto <bb 44>; [INV]

  <bb 7> :
  _3 = parent->entry.rbe_right;
  if (elm == _3)
    goto <bb 8>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 8> :
  tmp = parent->entry.rbe_right;
  _4 = tmp->entry.rbe_left;
  parent->entry.rbe_right = _4;
  _5 = parent->entry.rbe_right;
  if (_5 != 0B)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  _6 = tmp->entry.rbe_left;
  _6->entry.rbe_parent = parent;

  <bb 10> :
  _7 = parent->entry.rbe_parent;
  tmp->entry.rbe_parent = _7;
  _8 = tmp->entry.rbe_parent;
  if (_8 != 0B)
    goto <bb 11>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 11> :
  _9 = parent->entry.rbe_parent;
  _10 = _9->entry.rbe_left;
  if (parent == _10)
    goto <bb 12>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 12> :
  _11 = parent->entry.rbe_parent;
  _11->entry.rbe_left = tmp;
  goto <bb 15>; [INV]

  <bb 13> :
  _12 = parent->entry.rbe_parent;
  _12->entry.rbe_right = tmp;
  goto <bb 15>; [INV]

  <bb 14> :
  head->rbh_root = tmp;

  <bb 15> :
  tmp->entry.rbe_left = parent;
  parent->entry.rbe_parent = tmp;
  _13 = tmp->entry.rbe_parent;
  tmp = parent;
  parent = elm;
  elm = tmp;

  <bb 16> :
  parent->entry.rbe_color = 0;
  gparent->entry.rbe_color = 1;
  tmp = gparent->entry.rbe_left;
  _14 = tmp->entry.rbe_right;
  gparent->entry.rbe_left = _14;
  _15 = gparent->entry.rbe_left;
  if (_15 != 0B)
    goto <bb 17>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 17> :
  _16 = tmp->entry.rbe_right;
  _16->entry.rbe_parent = gparent;

  <bb 18> :
  _17 = gparent->entry.rbe_parent;
  tmp->entry.rbe_parent = _17;
  _18 = tmp->entry.rbe_parent;
  if (_18 != 0B)
    goto <bb 19>; [INV]
  else
    goto <bb 22>; [INV]

  <bb 19> :
  _19 = gparent->entry.rbe_parent;
  _20 = _19->entry.rbe_left;
  if (gparent == _20)
    goto <bb 20>; [INV]
  else
    goto <bb 21>; [INV]

  <bb 20> :
  _21 = gparent->entry.rbe_parent;
  _21->entry.rbe_left = tmp;
  goto <bb 23>; [INV]

  <bb 21> :
  _22 = gparent->entry.rbe_parent;
  _22->entry.rbe_right = tmp;
  goto <bb 23>; [INV]

  <bb 22> :
  head->rbh_root = tmp;

  <bb 23> :
  tmp->entry.rbe_right = gparent;
  gparent->entry.rbe_parent = tmp;
  _23 = tmp->entry.rbe_parent;
  goto <bb 44>; [INV]

  <bb 24> :
  tmp = gparent->entry.rbe_left;
  if (tmp != 0B)
    goto <bb 25>; [INV]
  else
    goto <bb 27>; [INV]

  <bb 25> :
  _24 = tmp->entry.rbe_color;
  if (_24 == 1)
    goto <bb 26>; [INV]
  else
    goto <bb 27>; [INV]

  <bb 26> :
  tmp->entry.rbe_color = 0;
  parent->entry.rbe_color = 0;
  gparent->entry.rbe_color = 1;
  elm = gparent;
  // predicted unlikely by continue predictor.
  goto <bb 44>; [INV]

  <bb 27> :
  _25 = parent->entry.rbe_left;
  if (elm == _25)
    goto <bb 28>; [INV]
  else
    goto <bb 36>; [INV]

  <bb 28> :
  tmp = parent->entry.rbe_left;
  _26 = tmp->entry.rbe_right;
  parent->entry.rbe_left = _26;
  _27 = parent->entry.rbe_left;
  if (_27 != 0B)
    goto <bb 29>; [INV]
  else
    goto <bb 30>; [INV]

  <bb 29> :
  _28 = tmp->entry.rbe_right;
  _28->entry.rbe_parent = parent;

  <bb 30> :
  _29 = parent->entry.rbe_parent;
  tmp->entry.rbe_parent = _29;
  _30 = tmp->entry.rbe_parent;
  if (_30 != 0B)
    goto <bb 31>; [INV]
  else
    goto <bb 34>; [INV]

  <bb 31> :
  _31 = parent->entry.rbe_parent;
  _32 = _31->entry.rbe_left;
  if (parent == _32)
    goto <bb 32>; [INV]
  else
    goto <bb 33>; [INV]

  <bb 32> :
  _33 = parent->entry.rbe_parent;
  _33->entry.rbe_left = tmp;
  goto <bb 35>; [INV]

  <bb 33> :
  _34 = parent->entry.rbe_parent;
  _34->entry.rbe_right = tmp;
  goto <bb 35>; [INV]

  <bb 34> :
  head->rbh_root = tmp;

  <bb 35> :
  tmp->entry.rbe_right = parent;
  parent->entry.rbe_parent = tmp;
  _35 = tmp->entry.rbe_parent;
  tmp = parent;
  parent = elm;
  elm = tmp;

  <bb 36> :
  parent->entry.rbe_color = 0;
  gparent->entry.rbe_color = 1;
  tmp = gparent->entry.rbe_right;
  _36 = tmp->entry.rbe_left;
  gparent->entry.rbe_right = _36;
  _37 = gparent->entry.rbe_right;
  if (_37 != 0B)
    goto <bb 37>; [INV]
  else
    goto <bb 38>; [INV]

  <bb 37> :
  _38 = tmp->entry.rbe_left;
  _38->entry.rbe_parent = gparent;

  <bb 38> :
  _39 = gparent->entry.rbe_parent;
  tmp->entry.rbe_parent = _39;
  _40 = tmp->entry.rbe_parent;
  if (_40 != 0B)
    goto <bb 39>; [INV]
  else
    goto <bb 42>; [INV]

  <bb 39> :
  _41 = gparent->entry.rbe_parent;
  _42 = _41->entry.rbe_left;
  if (gparent == _42)
    goto <bb 40>; [INV]
  else
    goto <bb 41>; [INV]

  <bb 40> :
  _43 = gparent->entry.rbe_parent;
  _43->entry.rbe_left = tmp;
  goto <bb 43>; [INV]

  <bb 41> :
  _44 = gparent->entry.rbe_parent;
  _44->entry.rbe_right = tmp;
  goto <bb 43>; [INV]

  <bb 42> :
  head->rbh_root = tmp;

  <bb 43> :
  tmp->entry.rbe_left = gparent;
  gparent->entry.rbe_parent = tmp;
  _45 = tmp->entry.rbe_parent;

  <bb 44> :
  parent = elm->entry.rbe_parent;
  if (parent != 0B)
    goto <bb 45>; [INV]
  else
    goto <bb 46>; [INV]

  <bb 45> :
  _46 = parent->entry.rbe_color;
  if (_46 == 1)
    goto <bb 3>; [INV]
  else
    goto <bb 46>; [INV]

  <bb 46> :
  _47 = head->rbh_root;
  _47->entry.rbe_color = 0;
  return;

}



;; Function poll_items_RB_REMOVE_COLOR (poll_items_RB_REMOVE_COLOR, funcdef_no=23, decl_uid=3800, cgraph_uid=24, symbol_order=27)

Removing basic block 11
Merging blocks 13 and 14
Merging blocks 19 and 46
Removing basic block 30
Merging blocks 32 and 33
Removing basic block 42
Merging blocks 44 and 45
Removing basic block 54
Merging blocks 56 and 57
Removing basic block 73
Merging blocks 75 and 76
Removing basic block 85
Merging blocks 87 and 88
;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81
;;
;; Loop 1
;;  header 76, multiple latches: 17 53
;;  depth 1, outer 0
;;  nodes: 76 17 53 51 52 49 50 40 48 46 47 45 44 43 41 42 3 78 77 15 16 13 14 4 12 10 11 9 8 7 5 6
;; 2 succs { 76 }
;; 3 succs { 4 40 }
;; 4 succs { 5 13 }
;; 5 succs { 6 7 }
;; 6 succs { 7 }
;; 7 succs { 8 11 }
;; 8 succs { 9 10 }
;; 9 succs { 12 }
;; 10 succs { 12 }
;; 11 succs { 12 }
;; 12 succs { 13 }
;; 13 succs { 15 14 }
;; 14 succs { 15 18 }
;; 15 succs { 17 16 }
;; 16 succs { 17 18 }
;; 17 succs { 76 }
;; 18 succs { 20 19 }
;; 19 succs { 20 30 }
;; 20 succs { 21 22 }
;; 21 succs { 22 }
;; 22 succs { 23 24 }
;; 23 succs { 24 }
;; 24 succs { 25 28 }
;; 25 succs { 26 27 }
;; 26 succs { 29 }
;; 27 succs { 29 }
;; 28 succs { 29 }
;; 29 succs { 30 }
;; 30 succs { 31 32 }
;; 31 succs { 32 }
;; 32 succs { 33 34 }
;; 33 succs { 34 }
;; 34 succs { 35 38 }
;; 35 succs { 36 37 }
;; 36 succs { 39 }
;; 37 succs { 39 }
;; 38 succs { 39 }
;; 39 succs { 79 }
;; 40 succs { 41 49 }
;; 41 succs { 42 43 }
;; 42 succs { 43 }
;; 43 succs { 44 47 }
;; 44 succs { 45 46 }
;; 45 succs { 48 }
;; 46 succs { 48 }
;; 47 succs { 48 }
;; 48 succs { 49 }
;; 49 succs { 51 50 }
;; 50 succs { 51 54 }
;; 51 succs { 53 52 }
;; 52 succs { 53 54 }
;; 53 succs { 76 }
;; 54 succs { 56 55 }
;; 55 succs { 56 66 }
;; 56 succs { 57 58 }
;; 57 succs { 58 }
;; 58 succs { 59 60 }
;; 59 succs { 60 }
;; 60 succs { 61 64 }
;; 61 succs { 62 63 }
;; 62 succs { 65 }
;; 63 succs { 65 }
;; 64 succs { 65 }
;; 65 succs { 66 }
;; 66 succs { 67 68 }
;; 67 succs { 68 }
;; 68 succs { 69 70 }
;; 69 succs { 70 }
;; 70 succs { 71 74 }
;; 71 succs { 72 73 }
;; 72 succs { 75 }
;; 73 succs { 75 }
;; 74 succs { 75 }
;; 75 succs { 79 }
;; 76 succs { 78 77 }
;; 77 succs { 78 79 }
;; 78 succs { 3 79 }
;; 79 succs { 80 81 }
;; 80 succs { 81 }
;; 81 succs { 1 }
void poll_items_RB_REMOVE_COLOR (struct poll_items * head, struct poll_item * parent, struct poll_item * elm)
{
  struct poll_item * oright;
  struct poll_item * oleft;
  struct poll_item * tmp;

  <bb 2> :
  goto <bb 76>; [INV]

  <bb 3> :
  _1 = parent->entry.rbe_left;
  if (elm == _1)
    goto <bb 4>; [INV]
  else
    goto <bb 40>; [INV]

  <bb 4> :
  tmp = parent->entry.rbe_right;
  _2 = tmp->entry.rbe_color;
  if (_2 == 1)
    goto <bb 5>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 5> :
  tmp->entry.rbe_color = 0;
  parent->entry.rbe_color = 1;
  tmp = parent->entry.rbe_right;
  _3 = tmp->entry.rbe_left;
  parent->entry.rbe_right = _3;
  _4 = parent->entry.rbe_right;
  if (_4 != 0B)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  _5 = tmp->entry.rbe_left;
  _5->entry.rbe_parent = parent;

  <bb 7> :
  _6 = parent->entry.rbe_parent;
  tmp->entry.rbe_parent = _6;
  _7 = tmp->entry.rbe_parent;
  if (_7 != 0B)
    goto <bb 8>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 8> :
  _8 = parent->entry.rbe_parent;
  _9 = _8->entry.rbe_left;
  if (parent == _9)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  _10 = parent->entry.rbe_parent;
  _10->entry.rbe_left = tmp;
  goto <bb 12>; [INV]

  <bb 10> :
  _11 = parent->entry.rbe_parent;
  _11->entry.rbe_right = tmp;
  goto <bb 12>; [INV]

  <bb 11> :
  head->rbh_root = tmp;

  <bb 12> :
  tmp->entry.rbe_left = parent;
  parent->entry.rbe_parent = tmp;
  _12 = tmp->entry.rbe_parent;
  tmp = parent->entry.rbe_right;

  <bb 13> :
  _13 = tmp->entry.rbe_left;
  if (_13 == 0B)
    goto <bb 15>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 14> :
  _14 = tmp->entry.rbe_left;
  _15 = _14->entry.rbe_color;
  if (_15 == 0)
    goto <bb 15>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 15> :
  _16 = tmp->entry.rbe_right;
  if (_16 == 0B)
    goto <bb 17>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 16> :
  _17 = tmp->entry.rbe_right;
  _18 = _17->entry.rbe_color;
  if (_18 == 0)
    goto <bb 17>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 17> :
  tmp->entry.rbe_color = 1;
  elm = parent;
  parent = elm->entry.rbe_parent;
  goto <bb 76>; [INV]

  <bb 18> :
  _19 = tmp->entry.rbe_right;
  if (_19 == 0B)
    goto <bb 20>; [INV]
  else
    goto <bb 19>; [INV]

  <bb 19> :
  _20 = tmp->entry.rbe_right;
  _21 = _20->entry.rbe_color;
  if (_21 == 0)
    goto <bb 20>; [INV]
  else
    goto <bb 30>; [INV]

  <bb 20> :
  oleft = tmp->entry.rbe_left;
  if (oleft != 0B)
    goto <bb 21>; [INV]
  else
    goto <bb 22>; [INV]

  <bb 21> :
  oleft->entry.rbe_color = 0;

  <bb 22> :
  tmp->entry.rbe_color = 1;
  oleft = tmp->entry.rbe_left;
  _22 = oleft->entry.rbe_right;
  tmp->entry.rbe_left = _22;
  _23 = tmp->entry.rbe_left;
  if (_23 != 0B)
    goto <bb 23>; [INV]
  else
    goto <bb 24>; [INV]

  <bb 23> :
  _24 = oleft->entry.rbe_right;
  _24->entry.rbe_parent = tmp;

  <bb 24> :
  _25 = tmp->entry.rbe_parent;
  oleft->entry.rbe_parent = _25;
  _26 = oleft->entry.rbe_parent;
  if (_26 != 0B)
    goto <bb 25>; [INV]
  else
    goto <bb 28>; [INV]

  <bb 25> :
  _27 = tmp->entry.rbe_parent;
  _28 = _27->entry.rbe_left;
  if (tmp == _28)
    goto <bb 26>; [INV]
  else
    goto <bb 27>; [INV]

  <bb 26> :
  _29 = tmp->entry.rbe_parent;
  _29->entry.rbe_left = oleft;
  goto <bb 29>; [INV]

  <bb 27> :
  _30 = tmp->entry.rbe_parent;
  _30->entry.rbe_right = oleft;
  goto <bb 29>; [INV]

  <bb 28> :
  head->rbh_root = oleft;

  <bb 29> :
  oleft->entry.rbe_right = tmp;
  tmp->entry.rbe_parent = oleft;
  _31 = oleft->entry.rbe_parent;
  tmp = parent->entry.rbe_right;

  <bb 30> :
  _32 = parent->entry.rbe_color;
  tmp->entry.rbe_color = _32;
  parent->entry.rbe_color = 0;
  _33 = tmp->entry.rbe_right;
  if (_33 != 0B)
    goto <bb 31>; [INV]
  else
    goto <bb 32>; [INV]

  <bb 31> :
  _34 = tmp->entry.rbe_right;
  _34->entry.rbe_color = 0;

  <bb 32> :
  tmp = parent->entry.rbe_right;
  _35 = tmp->entry.rbe_left;
  parent->entry.rbe_right = _35;
  _36 = parent->entry.rbe_right;
  if (_36 != 0B)
    goto <bb 33>; [INV]
  else
    goto <bb 34>; [INV]

  <bb 33> :
  _37 = tmp->entry.rbe_left;
  _37->entry.rbe_parent = parent;

  <bb 34> :
  _38 = parent->entry.rbe_parent;
  tmp->entry.rbe_parent = _38;
  _39 = tmp->entry.rbe_parent;
  if (_39 != 0B)
    goto <bb 35>; [INV]
  else
    goto <bb 38>; [INV]

  <bb 35> :
  _40 = parent->entry.rbe_parent;
  _41 = _40->entry.rbe_left;
  if (parent == _41)
    goto <bb 36>; [INV]
  else
    goto <bb 37>; [INV]

  <bb 36> :
  _42 = parent->entry.rbe_parent;
  _42->entry.rbe_left = tmp;
  goto <bb 39>; [INV]

  <bb 37> :
  _43 = parent->entry.rbe_parent;
  _43->entry.rbe_right = tmp;
  goto <bb 39>; [INV]

  <bb 38> :
  head->rbh_root = tmp;

  <bb 39> :
  tmp->entry.rbe_left = parent;
  parent->entry.rbe_parent = tmp;
  _44 = tmp->entry.rbe_parent;
  elm = head->rbh_root;
  goto <bb 79>; [INV]

  <bb 40> :
  tmp = parent->entry.rbe_left;
  _45 = tmp->entry.rbe_color;
  if (_45 == 1)
    goto <bb 41>; [INV]
  else
    goto <bb 49>; [INV]

  <bb 41> :
  tmp->entry.rbe_color = 0;
  parent->entry.rbe_color = 1;
  tmp = parent->entry.rbe_left;
  _46 = tmp->entry.rbe_right;
  parent->entry.rbe_left = _46;
  _47 = parent->entry.rbe_left;
  if (_47 != 0B)
    goto <bb 42>; [INV]
  else
    goto <bb 43>; [INV]

  <bb 42> :
  _48 = tmp->entry.rbe_right;
  _48->entry.rbe_parent = parent;

  <bb 43> :
  _49 = parent->entry.rbe_parent;
  tmp->entry.rbe_parent = _49;
  _50 = tmp->entry.rbe_parent;
  if (_50 != 0B)
    goto <bb 44>; [INV]
  else
    goto <bb 47>; [INV]

  <bb 44> :
  _51 = parent->entry.rbe_parent;
  _52 = _51->entry.rbe_left;
  if (parent == _52)
    goto <bb 45>; [INV]
  else
    goto <bb 46>; [INV]

  <bb 45> :
  _53 = parent->entry.rbe_parent;
  _53->entry.rbe_left = tmp;
  goto <bb 48>; [INV]

  <bb 46> :
  _54 = parent->entry.rbe_parent;
  _54->entry.rbe_right = tmp;
  goto <bb 48>; [INV]

  <bb 47> :
  head->rbh_root = tmp;

  <bb 48> :
  tmp->entry.rbe_right = parent;
  parent->entry.rbe_parent = tmp;
  _55 = tmp->entry.rbe_parent;
  tmp = parent->entry.rbe_left;

  <bb 49> :
  _56 = tmp->entry.rbe_left;
  if (_56 == 0B)
    goto <bb 51>; [INV]
  else
    goto <bb 50>; [INV]

  <bb 50> :
  _57 = tmp->entry.rbe_left;
  _58 = _57->entry.rbe_color;
  if (_58 == 0)
    goto <bb 51>; [INV]
  else
    goto <bb 54>; [INV]

  <bb 51> :
  _59 = tmp->entry.rbe_right;
  if (_59 == 0B)
    goto <bb 53>; [INV]
  else
    goto <bb 52>; [INV]

  <bb 52> :
  _60 = tmp->entry.rbe_right;
  _61 = _60->entry.rbe_color;
  if (_61 == 0)
    goto <bb 53>; [INV]
  else
    goto <bb 54>; [INV]

  <bb 53> :
  tmp->entry.rbe_color = 1;
  elm = parent;
  parent = elm->entry.rbe_parent;
  goto <bb 76>; [INV]

  <bb 54> :
  _62 = tmp->entry.rbe_left;
  if (_62 == 0B)
    goto <bb 56>; [INV]
  else
    goto <bb 55>; [INV]

  <bb 55> :
  _63 = tmp->entry.rbe_left;
  _64 = _63->entry.rbe_color;
  if (_64 == 0)
    goto <bb 56>; [INV]
  else
    goto <bb 66>; [INV]

  <bb 56> :
  oright = tmp->entry.rbe_right;
  if (oright != 0B)
    goto <bb 57>; [INV]
  else
    goto <bb 58>; [INV]

  <bb 57> :
  oright->entry.rbe_color = 0;

  <bb 58> :
  tmp->entry.rbe_color = 1;
  oright = tmp->entry.rbe_right;
  _65 = oright->entry.rbe_left;
  tmp->entry.rbe_right = _65;
  _66 = tmp->entry.rbe_right;
  if (_66 != 0B)
    goto <bb 59>; [INV]
  else
    goto <bb 60>; [INV]

  <bb 59> :
  _67 = oright->entry.rbe_left;
  _67->entry.rbe_parent = tmp;

  <bb 60> :
  _68 = tmp->entry.rbe_parent;
  oright->entry.rbe_parent = _68;
  _69 = oright->entry.rbe_parent;
  if (_69 != 0B)
    goto <bb 61>; [INV]
  else
    goto <bb 64>; [INV]

  <bb 61> :
  _70 = tmp->entry.rbe_parent;
  _71 = _70->entry.rbe_left;
  if (tmp == _71)
    goto <bb 62>; [INV]
  else
    goto <bb 63>; [INV]

  <bb 62> :
  _72 = tmp->entry.rbe_parent;
  _72->entry.rbe_left = oright;
  goto <bb 65>; [INV]

  <bb 63> :
  _73 = tmp->entry.rbe_parent;
  _73->entry.rbe_right = oright;
  goto <bb 65>; [INV]

  <bb 64> :
  head->rbh_root = oright;

  <bb 65> :
  oright->entry.rbe_left = tmp;
  tmp->entry.rbe_parent = oright;
  _74 = oright->entry.rbe_parent;
  tmp = parent->entry.rbe_left;

  <bb 66> :
  _75 = parent->entry.rbe_color;
  tmp->entry.rbe_color = _75;
  parent->entry.rbe_color = 0;
  _76 = tmp->entry.rbe_left;
  if (_76 != 0B)
    goto <bb 67>; [INV]
  else
    goto <bb 68>; [INV]

  <bb 67> :
  _77 = tmp->entry.rbe_left;
  _77->entry.rbe_color = 0;

  <bb 68> :
  tmp = parent->entry.rbe_left;
  _78 = tmp->entry.rbe_right;
  parent->entry.rbe_left = _78;
  _79 = parent->entry.rbe_left;
  if (_79 != 0B)
    goto <bb 69>; [INV]
  else
    goto <bb 70>; [INV]

  <bb 69> :
  _80 = tmp->entry.rbe_right;
  _80->entry.rbe_parent = parent;

  <bb 70> :
  _81 = parent->entry.rbe_parent;
  tmp->entry.rbe_parent = _81;
  _82 = tmp->entry.rbe_parent;
  if (_82 != 0B)
    goto <bb 71>; [INV]
  else
    goto <bb 74>; [INV]

  <bb 71> :
  _83 = parent->entry.rbe_parent;
  _84 = _83->entry.rbe_left;
  if (parent == _84)
    goto <bb 72>; [INV]
  else
    goto <bb 73>; [INV]

  <bb 72> :
  _85 = parent->entry.rbe_parent;
  _85->entry.rbe_left = tmp;
  goto <bb 75>; [INV]

  <bb 73> :
  _86 = parent->entry.rbe_parent;
  _86->entry.rbe_right = tmp;
  goto <bb 75>; [INV]

  <bb 74> :
  head->rbh_root = tmp;

  <bb 75> :
  tmp->entry.rbe_right = parent;
  parent->entry.rbe_parent = tmp;
  _87 = tmp->entry.rbe_parent;
  elm = head->rbh_root;
  goto <bb 79>; [INV]

  <bb 76> :
  if (elm == 0B)
    goto <bb 78>; [INV]
  else
    goto <bb 77>; [INV]

  <bb 77> :
  _88 = elm->entry.rbe_color;
  if (_88 == 0)
    goto <bb 78>; [INV]
  else
    goto <bb 79>; [INV]

  <bb 78> :
  _89 = head->rbh_root;
  if (elm != _89)
    goto <bb 3>; [INV]
  else
    goto <bb 79>; [INV]

  <bb 79> :
  if (elm != 0B)
    goto <bb 80>; [INV]
  else
    goto <bb 81>; [INV]

  <bb 80> :
  elm->entry.rbe_color = 0;

  <bb 81> :
  return;

}



;; Function poll_items_RB_INSERT (poll_items_RB_INSERT, funcdef_no=24, decl_uid=3803, cgraph_uid=25, symbol_order=28)

Removing basic block 13
;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
;;
;; Loop 1
;;  header 8, multiple latches: 4 6
;;  depth 1, outer 0
;;  nodes: 8 4 6 5 3
;; 2 succs { 8 }
;; 3 succs { 4 5 }
;; 4 succs { 8 }
;; 5 succs { 6 7 }
;; 6 succs { 8 }
;; 7 succs { 15 }
;; 8 succs { 3 9 }
;; 9 succs { 10 13 }
;; 10 succs { 11 12 }
;; 11 succs { 14 }
;; 12 succs { 14 }
;; 13 succs { 14 }
;; 14 succs { 15 }
;; 15 succs { 1 }
struct poll_item * poll_items_RB_INSERT (struct poll_items * head, struct poll_item * elm)
{
  int comp;
  struct poll_item * parent;
  struct poll_item * tmp;
  struct poll_item * D.4385;

  <bb 2> :
  parent = 0B;
  comp = 0;
  tmp = head->rbh_root;
  goto <bb 8>; [INV]

  <bb 3> :
  parent = tmp;
  comp = server_poll_cmp (elm, parent);
  if (comp < 0)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  tmp = tmp->entry.rbe_left;
  goto <bb 8>; [INV]

  <bb 5> :
  if (comp > 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  tmp = tmp->entry.rbe_right;
  goto <bb 8>; [INV]

  <bb 7> :
  D.4385 = tmp;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 15>; [INV]

  <bb 8> :
  if (tmp != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 9> :
  elm->entry.rbe_parent = parent;
  elm->entry.rbe_right = 0B;
  _1 = elm->entry.rbe_right;
  elm->entry.rbe_left = _1;
  elm->entry.rbe_color = 1;
  if (parent != 0B)
    goto <bb 10>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 10> :
  if (comp < 0)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  parent->entry.rbe_left = elm;
  goto <bb 14>; [INV]

  <bb 12> :
  parent->entry.rbe_right = elm;
  goto <bb 14>; [INV]

  <bb 13> :
  head->rbh_root = elm;

  <bb 14> :
  poll_items_RB_INSERT_COLOR (head, elm);
  D.4385 = 0B;

  <bb 15> :
  return D.4385;

}



;; Function poll_items_RB_REMOVE (poll_items_RB_REMOVE, funcdef_no=25, decl_uid=3806, cgraph_uid=26, symbol_order=29)

Removing basic block 15
Removing basic block 23
Removing basic block 37
Merging blocks 41 and 42
;; 3 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38
;;
;; Loop 2
;;  header 27, latch 27
;;  depth 1, outer 0
;;  nodes: 27
;;
;; Loop 1
;;  header 8, latch 7
;;  depth 1, outer 0
;;  nodes: 8 7
;; 2 succs { 3 4 }
;; 3 succs { 29 }
;; 4 succs { 5 6 }
;; 5 succs { 29 }
;; 6 succs { 8 }
;; 7 succs { 8 }
;; 8 succs { 7 9 }
;; 9 succs { 10 11 }
;; 10 succs { 11 }
;; 11 succs { 12 15 }
;; 12 succs { 13 14 }
;; 13 succs { 16 }
;; 14 succs { 16 }
;; 15 succs { 16 }
;; 16 succs { 17 18 }
;; 17 succs { 18 }
;; 18 succs { 19 22 }
;; 19 succs { 20 21 }
;; 20 succs { 23 }
;; 21 succs { 23 }
;; 22 succs { 23 }
;; 23 succs { 24 25 }
;; 24 succs { 25 }
;; 25 succs { 26 28 }
;; 26 succs { 27 }
;; 27 succs { 27 28 }
;; 28 succs { 36 }
;; 29 succs { 30 31 }
;; 30 succs { 31 }
;; 31 succs { 32 35 }
;; 32 succs { 33 34 }
;; 33 succs { 36 }
;; 34 succs { 36 }
;; 35 succs { 36 }
;; 36 succs { 37 38 }
;; 37 succs { 38 }
;; 38 succs { 1 }
struct poll_item * poll_items_RB_REMOVE (struct poll_items * head, struct poll_item * elm)
{
  struct poll_item * left;
  int color;
  struct poll_item * old;
  struct poll_item * parent;
  struct poll_item * child;
  struct poll_item * D.4429;

  <bb 2> :
  old = elm;
  _1 = elm->entry.rbe_left;
  if (_1 == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  child = elm->entry.rbe_right;
  goto <bb 29>; [INV]

  <bb 4> :
  _2 = elm->entry.rbe_right;
  if (_2 == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  child = elm->entry.rbe_left;
  goto <bb 29>; [INV]

  <bb 6> :
  elm = elm->entry.rbe_right;
  goto <bb 8>; [INV]

  <bb 7> :
  elm = left;

  <bb 8> :
  left = elm->entry.rbe_left;
  if (left != 0B)
    goto <bb 7>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 9> :
  child = elm->entry.rbe_right;
  parent = elm->entry.rbe_parent;
  color = elm->entry.rbe_color;
  if (child != 0B)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  child->entry.rbe_parent = parent;

  <bb 11> :
  if (parent != 0B)
    goto <bb 12>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 12> :
  _3 = parent->entry.rbe_left;
  if (elm == _3)
    goto <bb 13>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 13> :
  parent->entry.rbe_left = child;
  goto <bb 16>; [INV]

  <bb 14> :
  parent->entry.rbe_right = child;
  goto <bb 16>; [INV]

  <bb 15> :
  head->rbh_root = child;

  <bb 16> :
  _4 = elm->entry.rbe_parent;
  if (old == _4)
    goto <bb 17>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 17> :
  parent = elm;

  <bb 18> :
  elm->entry = old->entry;
  _5 = old->entry.rbe_parent;
  if (_5 != 0B)
    goto <bb 19>; [INV]
  else
    goto <bb 22>; [INV]

  <bb 19> :
  _6 = old->entry.rbe_parent;
  _7 = _6->entry.rbe_left;
  if (old == _7)
    goto <bb 20>; [INV]
  else
    goto <bb 21>; [INV]

  <bb 20> :
  _8 = old->entry.rbe_parent;
  _8->entry.rbe_left = elm;
  goto <bb 23>; [INV]

  <bb 21> :
  _9 = old->entry.rbe_parent;
  _9->entry.rbe_right = elm;
  goto <bb 23>; [INV]

  <bb 22> :
  head->rbh_root = elm;

  <bb 23> :
  _10 = old->entry.rbe_left;
  _10->entry.rbe_parent = elm;
  _11 = old->entry.rbe_right;
  if (_11 != 0B)
    goto <bb 24>; [INV]
  else
    goto <bb 25>; [INV]

  <bb 24> :
  _12 = old->entry.rbe_right;
  _12->entry.rbe_parent = elm;

  <bb 25> :
  if (parent != 0B)
    goto <bb 26>; [INV]
  else
    goto <bb 28>; [INV]

  <bb 26> :
  left = parent;

  <bb 27> :
  left = left->entry.rbe_parent;
  if (left != 0B)
    goto <bb 27>; [INV]
  else
    goto <bb 28>; [INV]

  <bb 28> :
  // predicted unlikely by goto predictor.
  goto <bb 36>; [INV]

  <bb 29> :
  parent = elm->entry.rbe_parent;
  color = elm->entry.rbe_color;
  if (child != 0B)
    goto <bb 30>; [INV]
  else
    goto <bb 31>; [INV]

  <bb 30> :
  child->entry.rbe_parent = parent;

  <bb 31> :
  if (parent != 0B)
    goto <bb 32>; [INV]
  else
    goto <bb 35>; [INV]

  <bb 32> :
  _13 = parent->entry.rbe_left;
  if (elm == _13)
    goto <bb 33>; [INV]
  else
    goto <bb 34>; [INV]

  <bb 33> :
  parent->entry.rbe_left = child;
  goto <bb 36>; [INV]

  <bb 34> :
  parent->entry.rbe_right = child;
  goto <bb 36>; [INV]

  <bb 35> :
  head->rbh_root = child;

  <bb 36> :
color:
  if (color == 0)
    goto <bb 37>; [INV]
  else
    goto <bb 38>; [INV]

  <bb 37> :
  poll_items_RB_REMOVE_COLOR (head, parent, child);

  <bb 38> :
  D.4429 = old;
  return D.4429;

}



;; Function poll_items_RB_FIND (poll_items_RB_FIND, funcdef_no=26, decl_uid=3809, cgraph_uid=27, symbol_order=30)

;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10
;;
;; Loop 1
;;  header 8, multiple latches: 4 6
;;  depth 1, outer 0
;;  nodes: 8 4 6 5 3
;; 2 succs { 8 }
;; 3 succs { 4 5 }
;; 4 succs { 8 }
;; 5 succs { 6 7 }
;; 6 succs { 8 }
;; 7 succs { 10 }
;; 8 succs { 3 9 }
;; 9 succs { 10 }
;; 10 succs { 1 }
struct poll_item * poll_items_RB_FIND (struct poll_items * head, struct poll_item * elm)
{
  int comp;
  struct poll_item * tmp;
  struct poll_item * D.4437;

  <bb 2> :
  tmp = head->rbh_root;
  goto <bb 8>; [INV]

  <bb 3> :
  comp = server_poll_cmp (elm, tmp);
  if (comp < 0)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  tmp = tmp->entry.rbe_left;
  goto <bb 8>; [INV]

  <bb 5> :
  if (comp > 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  tmp = tmp->entry.rbe_right;
  goto <bb 8>; [INV]

  <bb 7> :
  D.4437 = tmp;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 10>; [INV]

  <bb 8> :
  if (tmp != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 9> :
  D.4437 = 0B;

  <bb 10> :
  return D.4437;

}



;; Function poll_items_RB_NFIND (poll_items_RB_NFIND, funcdef_no=27, decl_uid=3812, cgraph_uid=28, symbol_order=31)

;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10
;;
;; Loop 1
;;  header 8, multiple latches: 4 6
;;  depth 1, outer 0
;;  nodes: 8 4 6 5 3
;; 2 succs { 8 }
;; 3 succs { 4 5 }
;; 4 succs { 8 }
;; 5 succs { 6 7 }
;; 6 succs { 8 }
;; 7 succs { 10 }
;; 8 succs { 3 9 }
;; 9 succs { 10 }
;; 10 succs { 1 }
struct poll_item * poll_items_RB_NFIND (struct poll_items * head, struct poll_item * elm)
{
  int comp;
  struct poll_item * res;
  struct poll_item * tmp;
  struct poll_item * D.4445;

  <bb 2> :
  tmp = head->rbh_root;
  res = 0B;
  goto <bb 8>; [INV]

  <bb 3> :
  comp = server_poll_cmp (elm, tmp);
  if (comp < 0)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  res = tmp;
  tmp = tmp->entry.rbe_left;
  goto <bb 8>; [INV]

  <bb 5> :
  if (comp > 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  tmp = tmp->entry.rbe_right;
  goto <bb 8>; [INV]

  <bb 7> :
  D.4445 = tmp;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 10>; [INV]

  <bb 8> :
  if (tmp != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 9> :
  D.4445 = res;

  <bb 10> :
  return D.4445;

}



;; Function poll_items_RB_NEXT (poll_items_RB_NEXT, funcdef_no=28, decl_uid=3814, cgraph_uid=29, symbol_order=32)

Removing basic block 6
Removing basic block 10
Merging blocks 15 and 16
;; 3 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13
;;
;; Loop 2
;;  header 5, latch 4
;;  depth 1, outer 0
;;  nodes: 5 4
;;
;; Loop 1
;;  header 10, latch 9
;;  depth 1, outer 0
;;  nodes: 10 9 11
;; 2 succs { 3 6 }
;; 3 succs { 5 }
;; 4 succs { 5 }
;; 5 succs { 4 13 }
;; 6 succs { 7 10 }
;; 7 succs { 8 10 }
;; 8 succs { 13 }
;; 9 succs { 10 }
;; 10 succs { 11 12 }
;; 11 succs { 9 12 }
;; 12 succs { 13 }
;; 13 succs { 1 }
struct poll_item * poll_items_RB_NEXT (struct poll_item * elm)
{
  struct poll_item * D.4455;

  <bb 2> :
  _1 = elm->entry.rbe_right;
  if (_1 != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 3> :
  elm = elm->entry.rbe_right;
  goto <bb 5>; [INV]

  <bb 4> :
  elm = elm->entry.rbe_left;

  <bb 5> :
  _2 = elm->entry.rbe_left;
  if (_2 != 0B)
    goto <bb 4>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 6> :
  _3 = elm->entry.rbe_parent;
  if (_3 != 0B)
    goto <bb 7>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 7> :
  _4 = elm->entry.rbe_parent;
  _5 = _4->entry.rbe_left;
  if (elm == _5)
    goto <bb 8>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 8> :
  elm = elm->entry.rbe_parent;
  goto <bb 13>; [INV]

  <bb 9> :
  elm = elm->entry.rbe_parent;

  <bb 10> :
  _6 = elm->entry.rbe_parent;
  if (_6 != 0B)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  _7 = elm->entry.rbe_parent;
  _8 = _7->entry.rbe_right;
  if (elm == _8)
    goto <bb 9>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 12> :
  elm = elm->entry.rbe_parent;

  <bb 13> :
  D.4455 = elm;
  return D.4455;

}



;; Function poll_items_RB_PREV (poll_items_RB_PREV, funcdef_no=29, decl_uid=3816, cgraph_uid=30, symbol_order=33)

Removing basic block 6
Removing basic block 10
Merging blocks 15 and 16
;; 3 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13
;;
;; Loop 2
;;  header 5, latch 4
;;  depth 1, outer 0
;;  nodes: 5 4
;;
;; Loop 1
;;  header 10, latch 9
;;  depth 1, outer 0
;;  nodes: 10 9 11
;; 2 succs { 3 6 }
;; 3 succs { 5 }
;; 4 succs { 5 }
;; 5 succs { 4 13 }
;; 6 succs { 7 10 }
;; 7 succs { 8 10 }
;; 8 succs { 13 }
;; 9 succs { 10 }
;; 10 succs { 11 12 }
;; 11 succs { 9 12 }
;; 12 succs { 13 }
;; 13 succs { 1 }
struct poll_item * poll_items_RB_PREV (struct poll_item * elm)
{
  struct poll_item * D.4465;

  <bb 2> :
  _1 = elm->entry.rbe_left;
  if (_1 != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 3> :
  elm = elm->entry.rbe_left;
  goto <bb 5>; [INV]

  <bb 4> :
  elm = elm->entry.rbe_right;

  <bb 5> :
  _2 = elm->entry.rbe_right;
  if (_2 != 0B)
    goto <bb 4>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 6> :
  _3 = elm->entry.rbe_parent;
  if (_3 != 0B)
    goto <bb 7>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 7> :
  _4 = elm->entry.rbe_parent;
  _5 = _4->entry.rbe_right;
  if (elm == _5)
    goto <bb 8>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 8> :
  elm = elm->entry.rbe_parent;
  goto <bb 13>; [INV]

  <bb 9> :
  elm = elm->entry.rbe_parent;

  <bb 10> :
  _6 = elm->entry.rbe_parent;
  if (_6 != 0B)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  _7 = elm->entry.rbe_parent;
  _8 = _7->entry.rbe_left;
  if (elm == _8)
    goto <bb 9>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 12> :
  elm = elm->entry.rbe_parent;

  <bb 13> :
  D.4465 = elm;
  return D.4465;

}



;; Function poll_items_RB_MINMAX (poll_items_RB_MINMAX, funcdef_no=30, decl_uid=3819, cgraph_uid=31, symbol_order=34)

Merging blocks 7 and 8
;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7
;;
;; Loop 1
;;  header 6, multiple latches: 4 5
;;  depth 1, outer 0
;;  nodes: 6 4 5 3
;; 2 succs { 6 }
;; 3 succs { 4 5 }
;; 4 succs { 6 }
;; 5 succs { 6 }
;; 6 succs { 3 7 }
;; 7 succs { 1 }
struct poll_item * poll_items_RB_MINMAX (struct poll_items * head, int val)
{
  struct poll_item * parent;
  struct poll_item * tmp;
  struct poll_item * D.4470;

  <bb 2> :
  tmp = head->rbh_root;
  parent = 0B;
  goto <bb 6>; [INV]

  <bb 3> :
  parent = tmp;
  if (val < 0)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  tmp = tmp->entry.rbe_left;
  goto <bb 6>; [INV]

  <bb 5> :
  tmp = tmp->entry.rbe_right;

  <bb 6> :
  if (tmp != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  D.4470 = parent;
  return D.4470;

}



;; Function xrealloc (xrealloc, funcdef_no=31, decl_uid=4020, cgraph_uid=32, symbol_order=35)

Merging blocks 8 and 9
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8
;; 2 succs { 3 4 }
;; 3 succs { }
;; 4 succs { 5 6 }
;; 5 succs { }
;; 6 succs { 7 8 }
;; 7 succs { }
;; 8 succs { 1 }
void * xrealloc (void * oldptr, size_t nmemb, size_t size)
{
  void * newptr;
  size_t newsize;
  void * D.4478;

  <bb 2> :
  newsize = nmemb * size;
  if (newsize == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  printf ("zero size%s\n", "");
  exit (1);

  <bb 4> :
  _1 = 1073741824 / nmemb;
  if (size > _1)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  printf ("nmemb * size > SIZE_MAX%s\n", "");
  exit (1);

  <bb 6> :
  newptr = realloc (oldptr, newsize);
  if (newptr == 0B)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  printf ("xrealloc failed%s\n", "");
  exit (1);

  <bb 8> :
  D.4478 = newptr;
  return D.4478;

}



;; Function buffer_create (buffer_create, funcdef_no=32, decl_uid=4025, cgraph_uid=33, symbol_order=36)

Merging blocks 4 and 5
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4
;; 2 succs { 3 4 }
;; 3 succs { }
;; 4 succs { 1 }
struct buffer * buffer_create (size_t size)
{
  struct buffer * b;
  struct buffer * D.4482;

  <bb 2> :
  if (size == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  printf ("zero size%s\n", "");
  exit (1);

  <bb 4> :
  b = malloc (32);
  b->space = size;
  D.4482 = b;
  return D.4482;

}



;; Function buffer_destroy (buffer_destroy, funcdef_no=33, decl_uid=4029, cgraph_uid=34, symbol_order=37)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
void buffer_destroy (struct buffer * b)
{
  <bb 2> :
  free (b);
  return;

}



;; Function buffer_add (buffer_add, funcdef_no=34, decl_uid=4033, cgraph_uid=35, symbol_order=38)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6
;; 2 succs { 3 4 }
;; 3 succs { }
;; 4 succs { 5 6 }
;; 5 succs { }
;; 6 succs { 1 }
void buffer_add (struct buffer * b, size_t size)
{
  <bb 2> :
  if (size == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  printf ("zero size%s\n", "");
  exit (1);

  <bb 4> :
  _1 = b->space;
  _2 = b->size;
  _3 = _1 - _2;
  if (size > _3)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  printf ("overflow%s\n", "");
  exit (1);

  <bb 6> :
  _4 = b->size;
  _5 = size + _4;
  b->size = _5;
  return;

}



;; Function buffer_ensure (buffer_ensure, funcdef_no=35, decl_uid=4037, cgraph_uid=36, symbol_order=39)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6
;; 2 succs { 3 4 }
;; 3 succs { }
;; 4 succs { 5 6 }
;; 5 succs { }
;; 6 succs { 1 }
void buffer_ensure (struct buffer * b, size_t size)
{
  <bb 2> :
  if (size == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  printf ("zero size%s\n", "");
  exit (1);

  <bb 4> :
  _1 = b->size;
  _2 = 1073741824 - _1;
  if (size > _2)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  printf ("size too big%s\n", "");
  exit (1);

  <bb 6> :
  return;

}



;; Function buffer_write (buffer_write, funcdef_no=36, decl_uid=4042, cgraph_uid=37, symbol_order=40)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
void buffer_write (struct buffer * b, const void * data, size_t size)
{
  <bb 2> :
  buffer_ensure (b, size);
  buffer_add (b, size);
  return;

}



;; Function buffer_poll (buffer_poll, funcdef_no=37, decl_uid=4048, cgraph_uid=38, symbol_order=41)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7
;; 2 succs { 3 4 }
;; 3 succs { 4 }
;; 4 succs { 5 6 }
;; 5 succs { 7 }
;; 6 succs { 7 }
;; 7 succs { 1 }
int buffer_poll (int fd, int events, struct buffer * in, struct buffer * out)
{
  ssize_t n;
  int D.4496;

  <bb 2> :
  _1 = rand ();
  _2 = _1 % 2;
  _3 = _2 + 1;
  n = (ssize_t) _3;
  if (in != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  buffer_ensure (in, 8192);
  n.0_4 = (long unsigned int) n;
  buffer_add (in, n.0_4);

  <bb 4> :
  _5 = rand ();
  _6 = _5 % 2;
  if (_6 == 1)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  D.4496 = -1;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 7>; [INV]

  <bb 6> :
  D.4496 = 0;

  <bb 7> :
  return D.4496;

}



;; Function server_poll_cmp (server_poll_cmp, funcdef_no=38, decl_uid=3776, cgraph_uid=39, symbol_order=42)

Merging blocks 2 and 3
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
int server_poll_cmp (struct poll_item * pitem1, struct poll_item * pitem2)
{
  int D.4498;

  <bb 2> :
  _1 = pitem1->fd;
  _2 = pitem2->fd;
  D.4498 = _1 - _2;
  return D.4498;

}



;; Function tty_close (tty_close, funcdef_no=39, decl_uid=4056, cgraph_uid=40, symbol_order=43)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4
;; 2 succs { 3 4 }
;; 3 succs { 4 }
;; 4 succs { 1 }
void tty_close (struct tty * tty)
{
  <bb 2> :
  _1 = tty->flags;
  _2 = _1 & 32;
  if (_2 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  _3 = tty->in;
  buffer_destroy (_3);
  _4 = tty->out;
  buffer_destroy (_4);
  _5 = tty->flags;
  _6 = _5 & -33;
  tty->flags = _6;

  <bb 4> :
  return;

}



;; Function tty_free (tty_free, funcdef_no=40, decl_uid=4059, cgraph_uid=41, symbol_order=44)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
void tty_free (struct tty * tty)
{
  <bb 2> :
  tty_close (tty);
  return;

}



;; Function server_should_shutdown (server_should_shutdown, funcdef_no=41, decl_uid=4062, cgraph_uid=42, symbol_order=45)

;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8
;;
;; Loop 1
;;  header 6, latch 5
;;  depth 1, outer 0
;;  nodes: 6 5 3
;; 2 succs { 6 }
;; 3 succs { 4 5 }
;; 4 succs { 8 }
;; 5 succs { 6 }
;; 6 succs { 3 7 }
;; 7 succs { 8 }
;; 8 succs { 1 }
int server_should_shutdown ()
{
  u_int i;
  int D.4504;

  <bb 2> :
  i = 0;
  goto <bb 6>; [INV]

  <bb 3> :
  _1 = clients.list;
  _2 = (long unsigned int) i;
  _3 = _2 * 8;
  _4 = _1 + _3;
  _5 = *_4;
  if (_5 != 0B)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  D.4504 = 0;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 8>; [INV]

  <bb 5> :
  i = i + 1;

  <bb 6> :
  _6 = clients.num;
  if (i < _6)
    goto <bb 3>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  D.4504 = 1;

  <bb 8> :
  return D.4504;

}



;; Function server_clean_dead (server_clean_dead, funcdef_no=42, decl_uid=4070, cgraph_uid=43, symbol_order=46)

;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9
;;
;; Loop 1
;;  header 8, latch 7
;;  depth 1, outer 0
;;  nodes: 8 7 5 6 4 3
;; 2 succs { 8 }
;; 3 succs { 5 4 }
;; 4 succs { 5 6 }
;; 5 succs { 7 }
;; 6 succs { 7 }
;; 7 succs { 8 }
;; 8 succs { 3 9 }
;; 9 succs { 1 }
void server_clean_dead ()
{
  u_int i;
  struct client * c;

  <bb 2> :
  i = 0;
  goto <bb 8>; [INV]

  <bb 3> :
  _1 = dead_clients.list;
  _2 = (long unsigned int) i;
  _3 = _2 * 8;
  _4 = _1 + _3;
  c = *_4;
  if (c == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 4> :
  _5 = c->references;
  if (_5 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  // predicted unlikely by continue predictor.
  goto <bb 7>; [INV]

  <bb 6> :
  _6 = dead_clients.list;
  _7 = (long unsigned int) i;
  _8 = _7 * 8;
  _9 = _6 + _8;
  *_9 = 0B;
  free (c);

  <bb 7> :
  i = i + 1;

  <bb 8> :
  _10 = dead_clients.num;
  if (i < _10)
    goto <bb 3>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 9> :
  return;

}



;; Function server_client_create (server_client_create, funcdef_no=43, decl_uid=4081, cgraph_uid=44, symbol_order=47)

Removing basic block 16
;; 3 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19
;;
;; Loop 2
;;  header 17, latch 16
;;  depth 1, outer 0
;;  nodes: 17 16
;;
;; Loop 1
;;  header 9, latch 8
;;  depth 1, outer 0
;;  nodes: 9 8 6
;; 2 succs { 3 4 }
;; 3 succs { 5 }
;; 4 succs { 5 }
;; 5 succs { 9 }
;; 6 succs { 7 8 }
;; 7 succs { 19 }
;; 8 succs { 9 }
;; 9 succs { 6 10 }
;; 10 succs { 11 12 }
;; 11 succs { }
;; 12 succs { 13 14 }
;; 13 succs { }
;; 14 succs { 15 17 }
;; 15 succs { 17 }
;; 16 succs { 17 }
;; 17 succs { 16 18 }
;; 18 succs { 19 }
;; 19 succs { 1 }
void server_client_create (int fd)
{
  u_int i;
  int mode;
  struct client * c;
  int iftmp.1;

  <bb 2> :
  c = malloc (512);
  c->references = 0;
  c->ibuf.fd = fd;
  _1 = rand ();
  _2 = _1 % 2;
  if (_2 == 1)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  iftmp.1 = 0;
  goto <bb 5>; [INV]

  <bb 4> :
  iftmp.1 = -1;

  <bb 5> :
  c->tty.fd = iftmp.1;
  c->title = 0B;
  c->session = 0B;
  c->tty.sx = 80;
  c->tty.sy = 24;
  _3 = buffer_create (8192);
  c->tty.in = _3;
  _4 = buffer_create (8192);
  c->tty.out = _4;
  c->tty.flags = 32;
  _5 = c->flags;
  _6 = _5 | 1;
  c->flags = _6;
  c->message_string = 0B;
  c->prompt_string = 0B;
  c->prompt_buffer = 0B;
  c->prompt_index = 0;
  printf ("new client %d\n", fd);
  i = 0;
  goto <bb 9>; [INV]

  <bb 6> :
  _7 = clients.list;
  _8 = (long unsigned int) i;
  _9 = _8 * 8;
  _10 = _7 + _9;
  _11 = *_10;
  if (_11 == 0B)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  _12 = clients.list;
  _13 = (long unsigned int) i;
  _14 = _13 * 8;
  _15 = _12 + _14;
  *_15 = c;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 19>; [INV]

  <bb 8> :
  i = i + 1;

  <bb 9> :
  _16 = clients.num;
  if (i < _16)
    goto <bb 6>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 10> :
  _17 = clients.num;
  if (_17 > 1073741823)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  printf ("number too big%s", "");
  exit (1);

  <bb 12> :
  _18 = clients.num;
  _19 = _18 + 1;
  _20 = 1073741824 / _19;
  if (_20 <= 7)
    goto <bb 13>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 13> :
  printf ("size too big%s", "");
  exit (1);

  <bb 14> :
  _21 = clients.space;
  if (_21 == 0)
    goto <bb 15>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 15> :
  clients.space = 80;
  _22 = clients.space;
  _23 = clients.list;
  _24 = xrealloc (_23, 1, _22);
  clients.list = _24;
  goto <bb 17>; [INV]

  <bb 16> :
  _25 = clients.space;
  _26 = clients.list;
  _27 = xrealloc (_26, 2, _25);
  clients.list = _27;
  _28 = clients.space;
  _29 = _28 * 2;
  clients.space = _29;

  <bb 17> :
  _30 = clients.space;
  _31 = clients.num;
  _32 = _31 + 1;
  _33 = (long unsigned int) _32;
  _34 = _33 * 8;
  if (_30 <= _34)
    goto <bb 16>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 18> :
  _35 = clients.list;
  _36 = clients.num;
  _37 = (long unsigned int) _36;
  _38 = _37 * 8;
  _39 = _35 + _38;
  *_39 = c;
  _40 = clients.num;
  _41 = _40 + 1;
  clients.num = _41;

  <bb 19> :
  return;

}



;; Function server_client_lost (server_client_lost, funcdef_no=44, decl_uid=4100, cgraph_uid=45, symbol_order=48)

Removing basic block 21
;; 4 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24
;;
;; Loop 3
;;  header 22, latch 21
;;  depth 1, outer 0
;;  nodes: 22 21
;;
;; Loop 2
;;  header 13, latch 12
;;  depth 1, outer 0
;;  nodes: 13 12 10
;;
;; Loop 1
;;  header 6, latch 5
;;  depth 1, outer 0
;;  nodes: 6 5 3 4
;; 2 succs { 6 }
;; 3 succs { 4 5 }
;; 4 succs { 5 }
;; 5 succs { 6 }
;; 6 succs { 3 7 }
;; 7 succs { 8 9 }
;; 8 succs { 9 }
;; 9 succs { 13 }
;; 10 succs { 11 12 }
;; 11 succs { 14 }
;; 12 succs { 13 }
;; 13 succs { 10 14 }
;; 14 succs { 15 24 }
;; 15 succs { 16 17 }
;; 16 succs { }
;; 17 succs { 18 19 }
;; 18 succs { }
;; 19 succs { 20 22 }
;; 20 succs { 22 }
;; 21 succs { 22 }
;; 22 succs { 21 23 }
;; 23 succs { 24 }
;; 24 succs { 1 }
void server_client_lost (struct client * c)
{
  u_int i;

  <bb 2> :
  i = 0;
  goto <bb 6>; [INV]

  <bb 3> :
  _1 = clients.list;
  _2 = (long unsigned int) i;
  _3 = _2 * 8;
  _4 = _1 + _3;
  _5 = *_4;
  if (c == _5)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  _6 = clients.list;
  _7 = (long unsigned int) i;
  _8 = _7 * 8;
  _9 = _6 + _8;
  *_9 = 0B;

  <bb 5> :
  i = i + 1;

  <bb 6> :
  _10 = clients.num;
  if (i < _10)
    goto <bb 3>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  _11 = c->flags;
  _12 = _11 & 1;
  if (_12 != 0)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  _13 = &c->tty;
  tty_free (_13);

  <bb 9> :
  i = 0;
  goto <bb 13>; [INV]

  <bb 10> :
  _14 = dead_clients.list;
  _15 = (long unsigned int) i;
  _16 = _15 * 8;
  _17 = _14 + _16;
  _18 = *_17;
  if (_18 == 0B)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  _19 = dead_clients.list;
  _20 = (long unsigned int) i;
  _21 = _20 * 8;
  _22 = _19 + _21;
  *_22 = c;
  goto <bb 14>; [INV]

  <bb 12> :
  i = i + 1;

  <bb 13> :
  _23 = dead_clients.num;
  if (i < _23)
    goto <bb 10>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 14> :
  _24 = dead_clients.num;
  if (i == _24)
    goto <bb 15>; [INV]
  else
    goto <bb 24>; [INV]

  <bb 15> :
  _25 = dead_clients.num;
  if (_25 > 1073741823)
    goto <bb 16>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 16> :
  printf ("number too big%s", "");
  exit (1);

  <bb 17> :
  _26 = dead_clients.num;
  _27 = _26 + 1;
  _28 = 1073741824 / _27;
  if (_28 <= 7)
    goto <bb 18>; [INV]
  else
    goto <bb 19>; [INV]

  <bb 18> :
  printf ("size too big%s", "");
  exit (1);

  <bb 19> :
  _29 = dead_clients.space;
  if (_29 == 0)
    goto <bb 20>; [INV]
  else
    goto <bb 22>; [INV]

  <bb 20> :
  dead_clients.space = 80;
  _30 = dead_clients.space;
  _31 = dead_clients.list;
  _32 = xrealloc (_31, 1, _30);
  dead_clients.list = _32;
  goto <bb 22>; [INV]

  <bb 21> :
  _33 = dead_clients.space;
  _34 = dead_clients.list;
  _35 = xrealloc (_34, 2, _33);
  dead_clients.list = _35;
  _36 = dead_clients.space;
  _37 = _36 * 2;
  dead_clients.space = _37;

  <bb 22> :
  _38 = dead_clients.space;
  _39 = dead_clients.num;
  _40 = _39 + 1;
  _41 = (long unsigned int) _40;
  _42 = _41 * 8;
  if (_38 <= _42)
    goto <bb 21>; [INV]
  else
    goto <bb 23>; [INV]

  <bb 23> :
  _43 = dead_clients.list;
  _44 = dead_clients.num;
  _45 = (long unsigned int) _44;
  _46 = _45 * 8;
  _47 = _43 + _46;
  *_47 = c;
  _48 = dead_clients.num;
  _49 = _48 + 1;
  dead_clients.num = _49;

  <bb 24> :
  _50 = c->flags;
  _51 = _50 | 512;
  c->flags = _51;
  return;

}



;; Function server_poll_reset (server_poll_reset, funcdef_no=45, decl_uid=3793, cgraph_uid=46, symbol_order=49)

;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5
;;
;; Loop 1
;;  header 4, latch 3
;;  depth 1, outer 0
;;  nodes: 4 3
;; 2 succs { 4 }
;; 3 succs { 4 }
;; 4 succs { 3 5 }
;; 5 succs { 1 }
void server_poll_reset ()
{
  struct poll_item * pitem;

  <bb 2> :
  goto <bb 4>; [INV]

  <bb 3> :
  pitem = poll_items.rbh_root;
  poll_items_RB_REMOVE (&poll_items, pitem);
  free (pitem);

  <bb 4> :
  _1 = poll_items.rbh_root;
  if (_1 != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 5> :
  return;

}



;; Function server_poll_lookup (server_poll_lookup, funcdef_no=46, decl_uid=3778, cgraph_uid=47, symbol_order=50)

Merging blocks 2 and 3
Merging blocks 2 and 4
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
struct poll_item * server_poll_lookup (int fd)
{
  struct poll_item pitem;
  struct poll_item * D.4536;

  <bb 2> :
  pitem.fd = fd;
  D.4536 = poll_items_RB_FIND (&poll_items, &pitem);
  pitem = {CLOBBER};
  return D.4536;

}



;; Function server_poll_flatten (server_poll_flatten, funcdef_no=47, decl_uid=3788, cgraph_uid=48, symbol_order=51)

Merging blocks 5 and 6
;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5
;;
;; Loop 1
;;  header 4, latch 3
;;  depth 1, outer 0
;;  nodes: 4 3
;; 2 succs { 4 }
;; 3 succs { 4 }
;; 4 succs { 3 5 }
;; 5 succs { 1 }
struct pollfd * server_poll_flatten (int * nfds)
{
  struct pollfd * pfds;
  struct poll_item * pitem;
  struct pollfd * D.4539;

  <bb 2> :
  pfds = 0B;
  *nfds = 0;
  pitem = poll_items_RB_MINMAX (&poll_items, -1);
  goto <bb 4>; [INV]

  <bb 3> :
  _1 = *nfds;
  _2 = _1 + 1;
  _3 = (long unsigned int) _2;
  pfds = xrealloc (pfds, _3, 8);
  _4 = *nfds;
  _5 = (long unsigned int) _4;
  _6 = _5 * 8;
  _7 = pfds + _6;
  _8 = pitem->fd;
  _7->fd = _8;
  _9 = *nfds;
  _10 = (long unsigned int) _9;
  _11 = _10 * 8;
  _12 = pfds + _11;
  _13 = pitem->events;
  _12->events = _13;
  _14 = *nfds;
  _15 = _14 + 1;
  *nfds = _15;
  pitem = poll_items_RB_NEXT (pitem);

  <bb 4> :
  if (pitem != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 5> :
  D.4539 = pfds;
  return D.4539;

}



;; Function server_callback (server_callback, funcdef_no=48, decl_uid=4145, cgraph_uid=49, symbol_order=52)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
void server_callback (int fd, int events, void * data)
{
  <bb 2> :
  srv_fd.2_1 = srv_fd;
  _2 = srv_fd.2_1 + 1;
  srv_fd = _2;
  srv_fd.3_3 = srv_fd;
  server_client_create (srv_fd.3_3);
  return;

}



;; Function server_poll_dispatch (server_poll_dispatch, funcdef_no=49, decl_uid=3791, cgraph_uid=50, symbol_order=53)

;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5
;;
;; Loop 1
;;  header 4, latch 3
;;  depth 1, outer 0
;;  nodes: 4 3
;; 2 succs { 4 }
;; 3 succs { 4 }
;; 4 succs { 3 5 }
;; 5 succs { 1 }
void server_poll_dispatch (struct pollfd * pfds, int nfds)
{
  struct pollfd * pfd;
  struct poll_item * pitem;

  <bb 2> :
  goto <bb 4>; [INV]

  <bb 3> :
  nfds = nfds + -1;
  _1 = (long unsigned int) nfds;
  _2 = _1 * 8;
  pfd = pfds + _2;
  _3 = pfd->fd;
  pitem = server_poll_lookup (_3);
  _4 = pitem->fn;
  _5 = pitem->data;
  _6 = pfd->events;
  _7 = pitem->fd;
  _4 (_7, _6, _5);

  <bb 4> :
  if (nfds > 0)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 5> :
  free (pfds);
  return;

}



;; Function server_poll_add (server_poll_add, funcdef_no=50, decl_uid=3786, cgraph_uid=51, symbol_order=54)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
void server_poll_add (int fd, int events, void (*<T650>) (int, int, void *) fn, void * data)
{
  struct poll_item * pitem;

  <bb 2> :
  pitem = malloc (56);
  pitem->fd = fd;
  pitem->events = events;
  pitem->fn = fn;
  pitem->data = data;
  poll_items_RB_INSERT (&poll_items, pitem);
  return;

}



;; Function server_client_callback (server_client_callback, funcdef_no=51, decl_uid=4169, cgraph_uid=52, symbol_order=55)

Removing basic block 8
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9
;; 2 succs { 3 4 }
;; 3 succs { 8 }
;; 4 succs { 5 6 }
;; 5 succs { 9 }
;; 6 succs { 7 9 }
;; 7 succs { 8 }
;; 8 succs { 9 }
;; 9 succs { 1 }
void server_client_callback (int fd, int events, void * data)
{
  struct client * c;

  <bb 2> :
  c = data;
  _1 = c->flags;
  _2 = _1 & 128;
  if (_2 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  // predicted unlikely by goto predictor.
  goto <bb 8>; [INV]

  <bb 4> :
  _3 = c->flags;
  _4 = _3 & 64;
  if (_4 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 9>; [INV]

  <bb 6> :
  _5 = c->ibuf.fd;
  printf ("client : %d is used\n", _5);
  _6 = c->tty.out;
  _7 = c->tty.in;
  _8 = buffer_poll (fd, events, _7, _6);
  if (_8 != 0)
    goto <bb 7>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 7> :
  // predicted unlikely by goto predictor.

  <bb 8> :
client_lost:
  _9 = c->ibuf.fd;
  printf ("client : %d is lost\n", _9);
  server_client_lost (c);

  <bb 9> :
  return;

}



;; Function server_fill_clients (server_fill_clients, funcdef_no=52, decl_uid=4174, cgraph_uid=53, symbol_order=56)

;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17
;;
;; Loop 1
;;  header 16, latch 15
;;  depth 1, outer 0
;;  nodes: 16 15 9 10 11 14 12 13 3 8 6 7 4 5
;; 2 succs { 16 }
;; 3 succs { 4 9 }
;; 4 succs { 5 6 }
;; 5 succs { 6 }
;; 6 succs { 7 8 }
;; 7 succs { 8 }
;; 8 succs { 9 }
;; 9 succs { 10 15 }
;; 10 succs { 11 15 }
;; 11 succs { 12 15 }
;; 12 succs { 13 14 }
;; 13 succs { 14 }
;; 14 succs { 15 }
;; 15 succs { 16 }
;; 16 succs { 3 17 }
;; 17 succs { 1 }
void server_fill_clients ()
{
  int events;
  u_int i;
  struct client * c;

  <bb 2> :
  i = 0;
  goto <bb 16>; [INV]

  <bb 3> :
  _1 = clients.list;
  _2 = (long unsigned int) i;
  _3 = _2 * 8;
  _4 = _1 + _3;
  c = *_4;
  if (c != 0B)
    goto <bb 4>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 4> :
  events = 0;
  _5 = c->flags;
  _6 = _5 & 128;
  if (_6 == 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  events = events | 1;

  <bb 6> :
  _7 = c->ibuf.fd;
  if (_7 < 0)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  events = events | 2;

  <bb 8> :
  _8 = c->ibuf.fd;
  server_poll_add (_8, events, server_client_callback, c);

  <bb 9> :
  if (c != 0B)
    goto <bb 10>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 10> :
  _9 = c->flags;
  _10 = _9 & 64;
  if (_10 == 0)
    goto <bb 11>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 11> :
  _11 = c->tty.fd;
  if (_11 != -1)
    goto <bb 12>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 12> :
  events = 1;
  _12 = c->tty.out;
  _13 = _12->size;
  if (_13 != 0)
    goto <bb 13>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 13> :
  events = events | 2;

  <bb 14> :
  _14 = c->tty.fd;
  server_poll_add (_14, events, server_client_callback, c);

  <bb 15> :
  i = i + 1;

  <bb 16> :
  _15 = clients.num;
  if (i < _15)
    goto <bb 3>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 17> :
  return;

}



;; Function server_client_handle_data (server_client_handle_data, funcdef_no=53, decl_uid=4184, cgraph_uid=54, symbol_order=57)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4
;; 2 succs { 3 4 }
;; 3 succs { 4 }
;; 4 succs { 1 }
void server_client_handle_data (struct client * c)
{
  const char * s;

  <bb 2> :
  s = "handling data";
  _1 = strlen (s);
  _2 = c->tty.out;
  buffer_write (_2, s, _1);
  _3 = rand ();
  _4 = _3 % 2;
  if (_4 == 1)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  _5 = c->flags;
  _6 = _5 | 128;
  c->flags = _6;

  <bb 4> :
  return;

}



;; Function server_client_loop (server_client_loop, funcdef_no=54, decl_uid=4189, cgraph_uid=55, symbol_order=58)

;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8
;;
;; Loop 1
;;  header 7, latch 6
;;  depth 1, outer 0
;;  nodes: 7 6 4 5 3
;; 2 succs { 7 }
;; 3 succs { 4 5 }
;; 4 succs { 6 }
;; 5 succs { 6 }
;; 6 succs { 7 }
;; 7 succs { 3 8 }
;; 8 succs { 1 }
void server_client_loop ()
{
  u_int i;
  struct client * c;

  <bb 2> :
  i = 0;
  goto <bb 7>; [INV]

  <bb 3> :
  _1 = clients.list;
  _2 = (long unsigned int) i;
  _3 = _2 * 8;
  _4 = _1 + _3;
  c = *_4;
  if (c == 0B)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  // predicted unlikely by continue predictor.
  goto <bb 6>; [INV]

  <bb 5> :
  server_client_handle_data (c);

  <bb 6> :
  i = i + 1;

  <bb 7> :
  _5 = clients.num;
  if (i < _5)
    goto <bb 3>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 8> :
  return;

}



;; Function main (main, funcdef_no=55, decl_uid=4199, cgraph_uid=56, symbol_order=59)

Removing basic block 5
Merging blocks 11 and 12
;; 3 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10
;;
;; Loop 2
;;  header 9, latch 8
;;  depth 1, outer 0
;;  nodes: 9 8 6 7
;;
;; Loop 1
;;  header 3, latch 4
;;  depth 1, outer 0
;;  nodes: 3 4
;; 2 succs { 3 }
;; 3 succs { 5 4 }
;; 4 succs { 5 3 }
;; 5 succs { 9 }
;; 6 succs { 7 8 }
;; 7 succs { 8 }
;; 8 succs { 9 }
;; 9 succs { 6 10 }
;; 10 succs { 1 }
int main (int argc, char * * argv)
{
  char * cause;
  u_int i;
  int nfds;
  int srv_fd;
  int pair[2];
  struct pollfd * pfds;
  struct client * c;
  int D.4570;

  <bb 2> :
  _1 = time (0B);
  _2 = (unsigned int) _1;
  srand (_2);
  srv_fd = 0;
  clients.num = 0;
  clients.list = 0B;
  clients.space = 0;
  dead_clients.num = 0;
  dead_clients.list = 0B;
  dead_clients.space = 0;
  server_client_create (srv_fd);
  pfds = 0B;

  <bb 3> :
  _3 = server_should_shutdown ();
  if (_3 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 4> :
  srv_fd = srv_fd + 1;
  server_poll_reset ();
  server_poll_add (srv_fd, 1, server_callback, 0B);
  server_fill_clients ();
  pfds = server_poll_flatten (&nfds);
  nfds.4_4 = nfds;
  server_poll_dispatch (pfds, nfds.4_4);
  server_client_loop ();
  server_clean_dead ();
  _5 = rand ();
  _6 = _5 % 2;
  if (_6 == 1)
    goto <bb 5>; [INV]
  else
    goto <bb 3>; [INV]

  <bb 5> :
  server_poll_reset ();
  i = 0;
  goto <bb 9>; [INV]

  <bb 6> :
  _7 = clients.list;
  _8 = (long unsigned int) i;
  _9 = _8 * 8;
  _10 = _7 + _9;
  _11 = *_10;
  if (_11 != 0B)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  _12 = clients.list;
  _13 = (long unsigned int) i;
  _14 = _13 * 8;
  _15 = _12 + _14;
  _16 = *_15;
  server_client_lost (_16);

  <bb 8> :
  i = i + 1;

  <bb 9> :
  _17 = clients.num;
  if (i < _17)
    goto <bb 6>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 10> :
  _18 = clients.list;
  free (_18);
  clients.num = 0;
  clients.list = 0B;
  clients.space = 0;
  server_clean_dead ();
  pair = {CLOBBER};
  nfds = {CLOBBER};
  D.4570 = 0;
  return D.4570;

}


