
;; Function printf (printf, funcdef_no=15, decl_uid=798, cgraph_uid=15, symbol_order=15)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
__fmt = &PARM_NOALIAS(9)
PARM_NOALIAS(9) = &NONLOCAL
ESCAPED = &NONLOCAL
ESCAPED = __fmt
_4 = NONLOCAL
ESCAPED = _4

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { ESCAPED NONLOCAL PARM_NOALIAS(9) }
NONLOCAL = { ESCAPED NONLOCAL } same as _4
STOREDANYTHING = { }
INTEGER = { ANYTHING }
__fmt = { PARM_NOALIAS(9) }
PARM_NOALIAS(9) = { ESCAPED NONLOCAL }
__printf_chk = { }
_4 = { ESCAPED NONLOCAL }


Alias information for printf

Aliased symbols


Call clobber information

ESCAPED, points-to non-local, points-to vars: { D.5177 } (nonlocal, escaped, restrict)

Flow-insensitive points-to information

__fmt_2(D), points-to NULL, points-to vars: { D.5177 } (nonlocal, escaped, restrict)

__attribute__((__artificial__, __gnu_inline__, __always_inline__))
printf (const char * restrict __fmt)
{
  int _4;

  <bb 2> [0.00%]:
  _4 = __printf_chk (1, __fmt_2(D), __builtin_va_arg_pack ());
  return _4;

}



;; Function memcpy (memcpy, funcdef_no=41, decl_uid=728, cgraph_uid=41, symbol_order=41)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
__dest = &PARM_NOALIAS(9)
PARM_NOALIAS(9) = &NONLOCAL
__src = &PARM_NOALIAS(11)
PARM_NOALIAS(11) = &NONLOCAL
__len = &NONLOCAL
CALLUSED(14) = CALLUSED(14) + UNKNOWN
CALLUSED(14) = *CALLUSED(14) + UNKNOWN
CALLUSED(14) = __dest
CALLUSED(14) = &NULL
_1 = CALLUSED(14)
_1 = NONLOCAL
_7 = __dest
doubledereftmp(18) = *__src
*__dest = doubledereftmp(18)
ESCAPED = _7

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { ESCAPED NONLOCAL PARM_NOALIAS(9) }
NONLOCAL = { ESCAPED NONLOCAL }
STOREDANYTHING = { }
INTEGER = { ANYTHING }
__dest = { PARM_NOALIAS(9) }
PARM_NOALIAS(9) = { ESCAPED NONLOCAL }
__src = { PARM_NOALIAS(11) }
PARM_NOALIAS(11) = { NONLOCAL }
__len = { NONLOCAL }
__builtin_object_size = { }
CALLUSED(14) = { NULL ESCAPED NONLOCAL PARM_NOALIAS(9) }
CALLCLOBBERED(15) = { }
_1 = { NULL ESCAPED NONLOCAL PARM_NOALIAS(9) }
_7 = { PARM_NOALIAS(9) } same as __dest
doubledereftmp(18) = { NONLOCAL }


Alias information for memcpy

Aliased symbols


Call clobber information

ESCAPED, points-to non-local, points-to vars: { D.5178 } (nonlocal, escaped, restrict)

Flow-insensitive points-to information

__dest_3(D), points-to NULL, points-to vars: { D.5178 } (nonlocal, escaped, restrict)
__src_4(D), points-to NULL, points-to vars: { D.5179 } (nonlocal, restrict)
_7, points-to NULL, points-to vars: { D.5178 } (nonlocal, escaped, restrict)

__attribute__((__artificial__, __gnu_inline__, __always_inline__, __nothrow__, __leaf__))
memcpy (void * restrict __dest, const void * restrict __src, size_t __len)
{
  long unsigned int _1;
  void * _7;

  <bb 2> [0.00%]:
  _1 = __builtin_object_size (__dest_3(D), 0);
  _7 = __memcpy_chk (__dest_3(D), __src_4(D), __len_5(D), _1);
  return _7;

}



;; Function winlink_cmp (winlink_cmp, funcdef_no=50, decl_uid=4298, cgraph_uid=50, symbol_order=53)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
wl1 = &NONLOCAL
wl2 = &NONLOCAL
_1 = *wl1
_2 = *wl2
_6 = _1
_6 = _2
ESCAPED = _6

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { ESCAPED NONLOCAL }
NONLOCAL = { ESCAPED NONLOCAL }
STOREDANYTHING = { }
INTEGER = { ANYTHING }
wl1 = { NONLOCAL }
wl2 = { NONLOCAL } same as wl1
_1 = { ESCAPED NONLOCAL }
_2 = { ESCAPED NONLOCAL }
_6 = { ESCAPED NONLOCAL }


Alias information for winlink_cmp

Aliased symbols


Call clobber information

ESCAPED, points-to non-local, points-to vars: { }

Flow-insensitive points-to information

wl1_4(D), points-to non-local, points-to NULL, points-to vars: { }
wl2_5(D), points-to non-local, points-to NULL, points-to vars: { }

winlink_cmp (struct winlink * wl1, struct winlink * wl2)
{
  int _1;
  int _2;
  int _6;

  <bb 2> [0.00%]:
  _1 = wl1_4(D)->idx;
  _2 = wl2_5(D)->idx;
  _6 = _1 - _2;
  return _6;

}



;; Function winlinks_RB_INSERT_COLOR (winlinks_RB_INSERT_COLOR, funcdef_no=51, decl_uid=4302, cgraph_uid=51, symbol_order=54)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
head = &NONLOCAL
elm = &NONLOCAL
gparent_67 = *parent_66 + 704
_1 = *gparent_67 + 576
tmp_97 = *gparent_67 + 640
_2 = *tmp_97 + 768
derefaddrtmp(15) = &NULL
*tmp_97 + 768 = derefaddrtmp(15)
derefaddrtmp(16) = &NULL
*parent_66 + 768 = derefaddrtmp(16)
derefaddrtmp(17) = &NONLOCAL
*gparent_67 + 768 = derefaddrtmp(17)
_3 = *parent_66 + 640
tmp_102 = *parent_66 + 640
_4 = *tmp_102 + 576
*parent_66 + 640 = _4
_5 = *parent_66 + 640
_6 = *tmp_102 + 576
*_6 + 704 = parent_66
_7 = *parent_66 + 704
*tmp_102 + 704 = _7
_8 = *tmp_102 + 704
_9 = *parent_66 + 704
_10 = *_9 + 576
_11 = *parent_66 + 704
*_11 + 576 = tmp_102
_12 = *parent_66 + 704
*_12 + 640 = tmp_102
*head = tmp_102
*tmp_102 + 576 = parent_66
*parent_66 + 704 = tmp_102
_13 = *tmp_102 + 704
elm_48 = elm_50
elm_48 = parent_66
parent_51 = parent_66
parent_51 = elm_50
derefaddrtmp(33) = &NULL
*parent_51 + 768 = derefaddrtmp(33)
derefaddrtmp(34) = &NONLOCAL
*gparent_67 + 768 = derefaddrtmp(34)
tmp_116 = *gparent_67 + 576
_14 = *tmp_116 + 640
*gparent_67 + 576 = _14
_15 = *gparent_67 + 576
_16 = *tmp_116 + 640
*_16 + 704 = gparent_67
_17 = *gparent_67 + 704
*tmp_116 + 704 = _17
_18 = *tmp_116 + 704
_19 = *gparent_67 + 704
_20 = *_19 + 576
_21 = *gparent_67 + 704
*_21 + 576 = tmp_116
_22 = *gparent_67 + 704
*_22 + 640 = tmp_116
*head = tmp_116
*tmp_116 + 640 = gparent_67
*gparent_67 + 704 = tmp_116
_23 = *tmp_116 + 704
tmp_68 = *gparent_67 + 576
_24 = *tmp_68 + 768
derefaddrtmp(48) = &NULL
*tmp_68 + 768 = derefaddrtmp(48)
derefaddrtmp(49) = &NULL
*parent_66 + 768 = derefaddrtmp(49)
derefaddrtmp(50) = &NONLOCAL
*gparent_67 + 768 = derefaddrtmp(50)
_25 = *parent_66 + 576
tmp_73 = *parent_66 + 576
_26 = *tmp_73 + 640
*parent_66 + 576 = _26
_27 = *parent_66 + 576
_28 = *tmp_73 + 640
*_28 + 704 = parent_66
_29 = *parent_66 + 704
*tmp_73 + 704 = _29
_30 = *tmp_73 + 704
_31 = *parent_66 + 704
_32 = *_31 + 576
_33 = *parent_66 + 704
*_33 + 576 = tmp_73
_34 = *parent_66 + 704
*_34 + 640 = tmp_73
*head = tmp_73
*tmp_73 + 640 = parent_66
*parent_66 + 704 = tmp_73
_35 = *tmp_73 + 704
parent_84 = elm_50
elm_49 = elm_50
elm_49 = parent_66
parent_52 = parent_66
parent_52 = elm_50
derefaddrtmp(66) = &NULL
*parent_52 + 768 = derefaddrtmp(66)
derefaddrtmp(67) = &NONLOCAL
*gparent_67 + 768 = derefaddrtmp(67)
tmp_88 = *gparent_67 + 640
_36 = *tmp_88 + 576
*gparent_67 + 640 = _36
_37 = *gparent_67 + 640
_38 = *tmp_88 + 576
*_38 + 704 = gparent_67
_39 = *gparent_67 + 704
*tmp_88 + 704 = _39
_40 = *tmp_88 + 704
_41 = *gparent_67 + 704
_42 = *_41 + 576
_43 = *gparent_67 + 704
*_43 + 576 = tmp_88
_44 = *gparent_67 + 704
*_44 + 640 = tmp_88
*head = tmp_88
*tmp_88 + 576 = gparent_67
*gparent_67 + 704 = tmp_88
_45 = *tmp_88 + 704
elm_50 = elm
elm_50 = gparent_67
elm_50 = elm_48
elm_50 = gparent_67
elm_50 = elm_49
parent_66 = *elm_50 + 704
_46 = *parent_66 + 768
_47 = *head
derefaddrtmp(81) = &NULL
*_47 + 768 = derefaddrtmp(81)

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { NULL ESCAPED NONLOCAL }
NONLOCAL = { ESCAPED NONLOCAL }
STOREDANYTHING = { }
INTEGER = { ANYTHING }
head = { NONLOCAL }
elm = { NONLOCAL } same as head
gparent_67 = { ESCAPED NONLOCAL }
parent_66 = { ESCAPED NONLOCAL }
_1 = { ESCAPED NONLOCAL }
tmp_97 = { ESCAPED NONLOCAL }
_2 = { ESCAPED NONLOCAL }
derefaddrtmp(15) = { NULL }
derefaddrtmp(16) = { NULL } same as derefaddrtmp(15)
derefaddrtmp(17) = { NONLOCAL } same as head
_3 = { ESCAPED NONLOCAL }
tmp_102 = { ESCAPED NONLOCAL }
_4 = { ESCAPED NONLOCAL }
_5 = { ESCAPED NONLOCAL }
_6 = { ESCAPED NONLOCAL }
_7 = { ESCAPED NONLOCAL }
_8 = { ESCAPED NONLOCAL }
_9 = { ESCAPED NONLOCAL }
_10 = { ESCAPED NONLOCAL }
_11 = { ESCAPED NONLOCAL }
_12 = { ESCAPED NONLOCAL }
_13 = { ESCAPED NONLOCAL }
elm_48 = { ESCAPED NONLOCAL }
elm_50 = { ESCAPED NONLOCAL } same as elm_48
parent_51 = { ESCAPED NONLOCAL } same as elm_48
derefaddrtmp(33) = { NULL } same as derefaddrtmp(15)
derefaddrtmp(34) = { NONLOCAL } same as head
tmp_116 = { ESCAPED NONLOCAL }
_14 = { ESCAPED NONLOCAL }
_15 = { ESCAPED NONLOCAL }
_16 = { ESCAPED NONLOCAL }
_17 = { ESCAPED NONLOCAL }
_18 = { ESCAPED NONLOCAL }
_19 = { ESCAPED NONLOCAL }
_20 = { ESCAPED NONLOCAL }
_21 = { ESCAPED NONLOCAL }
_22 = { ESCAPED NONLOCAL }
_23 = { ESCAPED NONLOCAL }
tmp_68 = { ESCAPED NONLOCAL }
_24 = { ESCAPED NONLOCAL }
derefaddrtmp(48) = { NULL } same as derefaddrtmp(15)
derefaddrtmp(49) = { NULL } same as derefaddrtmp(15)
derefaddrtmp(50) = { NONLOCAL } same as head
_25 = { ESCAPED NONLOCAL }
tmp_73 = { ESCAPED NONLOCAL }
_26 = { ESCAPED NONLOCAL }
_27 = { ESCAPED NONLOCAL }
_28 = { ESCAPED NONLOCAL }
_29 = { ESCAPED NONLOCAL }
_30 = { ESCAPED NONLOCAL }
_31 = { ESCAPED NONLOCAL }
_32 = { ESCAPED NONLOCAL }
_33 = { ESCAPED NONLOCAL }
_34 = { ESCAPED NONLOCAL }
_35 = { ESCAPED NONLOCAL }
parent_84 = { ESCAPED NONLOCAL } same as elm_48
elm_49 = { ESCAPED NONLOCAL } same as elm_48
parent_52 = { ESCAPED NONLOCAL } same as elm_48
derefaddrtmp(66) = { NULL } same as derefaddrtmp(15)
derefaddrtmp(67) = { NONLOCAL } same as head
tmp_88 = { ESCAPED NONLOCAL }
_36 = { ESCAPED NONLOCAL }
_37 = { ESCAPED NONLOCAL }
_38 = { ESCAPED NONLOCAL }
_39 = { ESCAPED NONLOCAL }
_40 = { ESCAPED NONLOCAL }
_41 = { ESCAPED NONLOCAL }
_42 = { ESCAPED NONLOCAL }
_43 = { ESCAPED NONLOCAL }
_44 = { ESCAPED NONLOCAL }
_45 = { ESCAPED NONLOCAL }
_46 = { ESCAPED NONLOCAL }
_47 = { ESCAPED NONLOCAL }
derefaddrtmp(81) = { NULL } same as derefaddrtmp(15)


Alias information for winlinks_RB_INSERT_COLOR

Aliased symbols


Call clobber information

ESCAPED, points-to non-local, points-to NULL, points-to vars: { }

Flow-insensitive points-to information

_1, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_3, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_4, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_5, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_6, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_7, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_8, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_9, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_10, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_11, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_12, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_13, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_14, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_15, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_16, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_17, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_18, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_19, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_20, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_21, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_22, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_23, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_25, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_26, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_27, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_28, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_29, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_30, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_31, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_32, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_33, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_34, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_35, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_36, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_37, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_38, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_39, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_40, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_41, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_42, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_43, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_44, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_45, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_47, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
elm_48, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
elm_49, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
elm_50, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
parent_51, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
parent_52, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
elm_64(D), points-to non-local, points-to NULL, points-to vars: { }
parent_66, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
gparent_67, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
tmp_68, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
tmp_73, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
head_77(D), points-to non-local, points-to NULL, points-to vars: { }
parent_84, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
tmp_88, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
tmp_97, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
tmp_102, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
tmp_116, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }

winlinks_RB_INSERT_COLOR (struct winlinks * head, struct winlink * elm)
{
  struct winlink * tmp;
  struct winlink * gparent;
  struct winlink * parent;
  struct winlink * _1;
  int _2;
  struct winlink * _3;
  struct winlink * _4;
  struct winlink * _5;
  struct winlink * _6;
  struct winlink * _7;
  struct winlink * _8;
  struct winlink * _9;
  struct winlink * _10;
  struct winlink * _11;
  struct winlink * _12;
  struct winlink * _13;
  struct winlink * _14;
  struct winlink * _15;
  struct winlink * _16;
  struct winlink * _17;
  struct winlink * _18;
  struct winlink * _19;
  struct winlink * _20;
  struct winlink * _21;
  struct winlink * _22;
  struct winlink * _23;
  int _24;
  struct winlink * _25;
  struct winlink * _26;
  struct winlink * _27;
  struct winlink * _28;
  struct winlink * _29;
  struct winlink * _30;
  struct winlink * _31;
  struct winlink * _32;
  struct winlink * _33;
  struct winlink * _34;
  struct winlink * _35;
  struct winlink * _36;
  struct winlink * _37;
  struct winlink * _38;
  struct winlink * _39;
  struct winlink * _40;
  struct winlink * _41;
  struct winlink * _42;
  struct winlink * _43;
  struct winlink * _44;
  struct winlink * _45;
  int _46;
  struct winlink * _47;

  <bb 2> [0.00%]:
  goto <bb 44>; [0.00%]

  <bb 3> [0.00%]:
  gparent_67 = parent_66->entry.rbe_parent;
  _1 = gparent_67->entry.rbe_left;
  if (_1 == parent_66)
    goto <bb 4>; [0.00%]
  else
    goto <bb 24>; [0.00%]

  <bb 4> [0.00%]:
  tmp_97 = gparent_67->entry.rbe_right;
  if (tmp_97 != 0B)
    goto <bb 5>; [0.00%]
  else
    goto <bb 7>; [0.00%]

  <bb 5> [0.00%]:
  _2 = tmp_97->entry.rbe_color;
  if (_2 == 1)
    goto <bb 6>; [0.00%]
  else
    goto <bb 7>; [0.00%]

  <bb 6> [0.00%]:
  tmp_97->entry.rbe_color = 0;
  parent_66->entry.rbe_color = 0;
  gparent_67->entry.rbe_color = 1;
  // predicted unlikely by continue predictor.
  goto <bb 44>; [0.00%]

  <bb 7> [0.00%]:
  _3 = parent_66->entry.rbe_right;
  if (_3 == elm_50)
    goto <bb 8>; [0.00%]
  else
    goto <bb 16>; [0.00%]

  <bb 8> [0.00%]:
  tmp_102 = parent_66->entry.rbe_right;
  _4 = tmp_102->entry.rbe_left;
  parent_66->entry.rbe_right = _4;
  _5 = parent_66->entry.rbe_right;
  if (_5 != 0B)
    goto <bb 9>; [0.00%]
  else
    goto <bb 10>; [0.00%]

  <bb 9> [0.00%]:
  _6 = tmp_102->entry.rbe_left;
  _6->entry.rbe_parent = parent_66;

  <bb 10> [0.00%]:
  _7 = parent_66->entry.rbe_parent;
  tmp_102->entry.rbe_parent = _7;
  _8 = tmp_102->entry.rbe_parent;
  if (_8 != 0B)
    goto <bb 11>; [0.00%]
  else
    goto <bb 14>; [0.00%]

  <bb 11> [0.00%]:
  _9 = parent_66->entry.rbe_parent;
  _10 = _9->entry.rbe_left;
  if (_10 == parent_66)
    goto <bb 12>; [0.00%]
  else
    goto <bb 13>; [0.00%]

  <bb 12> [0.00%]:
  _11 = parent_66->entry.rbe_parent;
  _11->entry.rbe_left = tmp_102;
  goto <bb 15>; [0.00%]

  <bb 13> [0.00%]:
  _12 = parent_66->entry.rbe_parent;
  _12->entry.rbe_right = tmp_102;
  goto <bb 15>; [0.00%]

  <bb 14> [0.00%]:
  head_77(D)->rbh_root = tmp_102;

  <bb 15> [0.00%]:
  tmp_102->entry.rbe_left = parent_66;
  parent_66->entry.rbe_parent = tmp_102;
  _13 = tmp_102->entry.rbe_parent;

  <bb 16> [0.00%]:
  # elm_48 = PHI <elm_50(7), parent_66(15)>
  # parent_51 = PHI <parent_66(7), elm_50(15)>
  parent_51->entry.rbe_color = 0;
  gparent_67->entry.rbe_color = 1;
  tmp_116 = gparent_67->entry.rbe_left;
  _14 = tmp_116->entry.rbe_right;
  gparent_67->entry.rbe_left = _14;
  _15 = gparent_67->entry.rbe_left;
  if (_15 != 0B)
    goto <bb 17>; [0.00%]
  else
    goto <bb 18>; [0.00%]

  <bb 17> [0.00%]:
  _16 = tmp_116->entry.rbe_right;
  _16->entry.rbe_parent = gparent_67;

  <bb 18> [0.00%]:
  _17 = gparent_67->entry.rbe_parent;
  tmp_116->entry.rbe_parent = _17;
  _18 = tmp_116->entry.rbe_parent;
  if (_18 != 0B)
    goto <bb 19>; [0.00%]
  else
    goto <bb 22>; [0.00%]

  <bb 19> [0.00%]:
  _19 = gparent_67->entry.rbe_parent;
  _20 = _19->entry.rbe_left;
  if (_20 == gparent_67)
    goto <bb 20>; [0.00%]
  else
    goto <bb 21>; [0.00%]

  <bb 20> [0.00%]:
  _21 = gparent_67->entry.rbe_parent;
  _21->entry.rbe_left = tmp_116;
  goto <bb 23>; [0.00%]

  <bb 21> [0.00%]:
  _22 = gparent_67->entry.rbe_parent;
  _22->entry.rbe_right = tmp_116;
  goto <bb 23>; [0.00%]

  <bb 22> [0.00%]:
  head_77(D)->rbh_root = tmp_116;

  <bb 23> [0.00%]:
  tmp_116->entry.rbe_right = gparent_67;
  gparent_67->entry.rbe_parent = tmp_116;
  _23 = tmp_116->entry.rbe_parent;
  goto <bb 44>; [0.00%]

  <bb 24> [0.00%]:
  tmp_68 = gparent_67->entry.rbe_left;
  if (tmp_68 != 0B)
    goto <bb 25>; [0.00%]
  else
    goto <bb 27>; [0.00%]

  <bb 25> [0.00%]:
  _24 = tmp_68->entry.rbe_color;
  if (_24 == 1)
    goto <bb 26>; [0.00%]
  else
    goto <bb 27>; [0.00%]

  <bb 26> [0.00%]:
  tmp_68->entry.rbe_color = 0;
  parent_66->entry.rbe_color = 0;
  gparent_67->entry.rbe_color = 1;
  // predicted unlikely by continue predictor.
  goto <bb 44>; [0.00%]

  <bb 27> [0.00%]:
  _25 = parent_66->entry.rbe_left;
  if (_25 == elm_50)
    goto <bb 28>; [0.00%]
  else
    goto <bb 36>; [0.00%]

  <bb 28> [0.00%]:
  tmp_73 = parent_66->entry.rbe_left;
  _26 = tmp_73->entry.rbe_right;
  parent_66->entry.rbe_left = _26;
  _27 = parent_66->entry.rbe_left;
  if (_27 != 0B)
    goto <bb 29>; [0.00%]
  else
    goto <bb 30>; [0.00%]

  <bb 29> [0.00%]:
  _28 = tmp_73->entry.rbe_right;
  _28->entry.rbe_parent = parent_66;

  <bb 30> [0.00%]:
  _29 = parent_66->entry.rbe_parent;
  tmp_73->entry.rbe_parent = _29;
  _30 = tmp_73->entry.rbe_parent;
  if (_30 != 0B)
    goto <bb 31>; [0.00%]
  else
    goto <bb 34>; [0.00%]

  <bb 31> [0.00%]:
  _31 = parent_66->entry.rbe_parent;
  _32 = _31->entry.rbe_left;
  if (_32 == parent_66)
    goto <bb 32>; [0.00%]
  else
    goto <bb 33>; [0.00%]

  <bb 32> [0.00%]:
  _33 = parent_66->entry.rbe_parent;
  _33->entry.rbe_left = tmp_73;
  goto <bb 35>; [0.00%]

  <bb 33> [0.00%]:
  _34 = parent_66->entry.rbe_parent;
  _34->entry.rbe_right = tmp_73;
  goto <bb 35>; [0.00%]

  <bb 34> [0.00%]:
  head_77(D)->rbh_root = tmp_73;

  <bb 35> [0.00%]:
  tmp_73->entry.rbe_right = parent_66;
  parent_66->entry.rbe_parent = tmp_73;
  _35 = tmp_73->entry.rbe_parent;
  parent_84 = elm_50;

  <bb 36> [0.00%]:
  # elm_49 = PHI <elm_50(27), parent_66(35)>
  # parent_52 = PHI <parent_66(27), elm_50(35)>
  parent_52->entry.rbe_color = 0;
  gparent_67->entry.rbe_color = 1;
  tmp_88 = gparent_67->entry.rbe_right;
  _36 = tmp_88->entry.rbe_left;
  gparent_67->entry.rbe_right = _36;
  _37 = gparent_67->entry.rbe_right;
  if (_37 != 0B)
    goto <bb 37>; [0.00%]
  else
    goto <bb 38>; [0.00%]

  <bb 37> [0.00%]:
  _38 = tmp_88->entry.rbe_left;
  _38->entry.rbe_parent = gparent_67;

  <bb 38> [0.00%]:
  _39 = gparent_67->entry.rbe_parent;
  tmp_88->entry.rbe_parent = _39;
  _40 = tmp_88->entry.rbe_parent;
  if (_40 != 0B)
    goto <bb 39>; [0.00%]
  else
    goto <bb 42>; [0.00%]

  <bb 39> [0.00%]:
  _41 = gparent_67->entry.rbe_parent;
  _42 = _41->entry.rbe_left;
  if (_42 == gparent_67)
    goto <bb 40>; [0.00%]
  else
    goto <bb 41>; [0.00%]

  <bb 40> [0.00%]:
  _43 = gparent_67->entry.rbe_parent;
  _43->entry.rbe_left = tmp_88;
  goto <bb 43>; [0.00%]

  <bb 41> [0.00%]:
  _44 = gparent_67->entry.rbe_parent;
  _44->entry.rbe_right = tmp_88;
  goto <bb 43>; [0.00%]

  <bb 42> [0.00%]:
  head_77(D)->rbh_root = tmp_88;

  <bb 43> [0.00%]:
  tmp_88->entry.rbe_left = gparent_67;
  gparent_67->entry.rbe_parent = tmp_88;
  _45 = tmp_88->entry.rbe_parent;

  <bb 44> [0.00%]:
  # elm_50 = PHI <elm_64(D)(2), gparent_67(6), elm_48(23), gparent_67(26), elm_49(43)>
  parent_66 = elm_50->entry.rbe_parent;
  if (parent_66 != 0B)
    goto <bb 45>; [0.00%]
  else
    goto <bb 46>; [0.00%]

  <bb 45> [0.00%]:
  _46 = parent_66->entry.rbe_color;
  if (_46 == 1)
    goto <bb 3>; [0.00%]
  else
    goto <bb 46>; [0.00%]

  <bb 46> [0.00%]:
  _47 = head_77(D)->rbh_root;
  _47->entry.rbe_color = 0;
  return;

}



;; Function winlinks_RB_REMOVE_COLOR (winlinks_RB_REMOVE_COLOR, funcdef_no=52, decl_uid=4313, cgraph_uid=52, symbol_order=55)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
head = &NONLOCAL
parent = &NONLOCAL
elm = &NONLOCAL
_1 = *parent_90 + 576
tmp_166 = *parent_90 + 640
_2 = *tmp_166 + 768
derefaddrtmp(15) = &NULL
*tmp_166 + 768 = derefaddrtmp(15)
derefaddrtmp(16) = &NONLOCAL
*parent_90 + 768 = derefaddrtmp(16)
tmp_169 = *parent_90 + 640
_3 = *tmp_169 + 576
*parent_90 + 640 = _3
_4 = *parent_90 + 640
_5 = *tmp_169 + 576
*_5 + 704 = parent_90
_6 = *parent_90 + 704
*tmp_169 + 704 = _6
_7 = *tmp_169 + 704
_8 = *parent_90 + 704
_9 = *_8 + 576
_10 = *parent_90 + 704
*_10 + 576 = tmp_169
_11 = *parent_90 + 704
*_11 + 640 = tmp_169
*head = tmp_169
*tmp_169 + 576 = parent_90
*parent_90 + 704 = tmp_169
_12 = *tmp_169 + 704
tmp_178 = *parent_90 + 640
tmp_93 = tmp_166
tmp_93 = tmp_178
_13 = *tmp_93 + 576
_14 = *tmp_93 + 576
_15 = *_14 + 768
_16 = *tmp_93 + 640
_17 = *tmp_93 + 640
_18 = *_17 + 768
derefaddrtmp(36) = &NONLOCAL
*tmp_93 + 768 = derefaddrtmp(36)
parent_181 = *parent_90 + 704
_19 = *tmp_93 + 640
_20 = *tmp_93 + 640
_21 = *_20 + 768
oleft_182 = *tmp_93 + 576
derefaddrtmp(42) = &NULL
*oleft_182 + 768 = derefaddrtmp(42)
derefaddrtmp(43) = &NONLOCAL
*tmp_93 + 768 = derefaddrtmp(43)
oleft_185 = *tmp_93 + 576
_22 = *oleft_185 + 640
*tmp_93 + 576 = _22
_23 = *tmp_93 + 576
_24 = *oleft_185 + 640
*_24 + 704 = tmp_93
_25 = *tmp_93 + 704
*oleft_185 + 704 = _25
_26 = *oleft_185 + 704
_27 = *tmp_93 + 704
_28 = *_27 + 576
_29 = *tmp_93 + 704
*_29 + 576 = oleft_185
_30 = *tmp_93 + 704
*_30 + 640 = oleft_185
*head = oleft_185
*oleft_185 + 640 = tmp_93
*tmp_93 + 704 = oleft_185
_31 = *oleft_185 + 704
tmp_194 = *parent_90 + 640
tmp_94 = tmp_93
tmp_94 = tmp_194
_32 = *parent_90 + 768
*tmp_94 + 768 = _32
derefaddrtmp(58) = &NULL
*parent_90 + 768 = derefaddrtmp(58)
_33 = *tmp_94 + 640
_34 = *tmp_94 + 640
derefaddrtmp(61) = &NULL
*_34 + 768 = derefaddrtmp(61)
tmp_198 = *parent_90 + 640
_35 = *tmp_198 + 576
*parent_90 + 640 = _35
_36 = *parent_90 + 640
_37 = *tmp_198 + 576
*_37 + 704 = parent_90
_38 = *parent_90 + 704
*tmp_198 + 704 = _38
_39 = *tmp_198 + 704
_40 = *parent_90 + 704
_41 = *_40 + 576
_42 = *parent_90 + 704
*_42 + 576 = tmp_198
_43 = *parent_90 + 704
*_43 + 640 = tmp_198
*head = tmp_198
*tmp_198 + 576 = parent_90
*parent_90 + 704 = tmp_198
_44 = *tmp_198 + 704
elm_207 = *head
tmp_124 = *parent_90 + 576
_45 = *tmp_124 + 768
derefaddrtmp(76) = &NULL
*tmp_124 + 768 = derefaddrtmp(76)
derefaddrtmp(77) = &NONLOCAL
*parent_90 + 768 = derefaddrtmp(77)
tmp_127 = *parent_90 + 576
_46 = *tmp_127 + 640
*parent_90 + 576 = _46
_47 = *parent_90 + 576
_48 = *tmp_127 + 640
*_48 + 704 = parent_90
_49 = *parent_90 + 704
*tmp_127 + 704 = _49
_50 = *tmp_127 + 704
_51 = *parent_90 + 704
_52 = *_51 + 576
_53 = *parent_90 + 704
*_53 + 576 = tmp_127
_54 = *parent_90 + 704
*_54 + 640 = tmp_127
*head = tmp_127
*tmp_127 + 640 = parent_90
*parent_90 + 704 = tmp_127
_55 = *tmp_127 + 704
tmp_136 = *parent_90 + 576
tmp_95 = tmp_124
tmp_95 = tmp_136
_56 = *tmp_95 + 576
_57 = *tmp_95 + 576
_58 = *_57 + 768
_59 = *tmp_95 + 640
_60 = *tmp_95 + 640
_61 = *_60 + 768
derefaddrtmp(97) = &NONLOCAL
*tmp_95 + 768 = derefaddrtmp(97)
elm_138 = parent_90
parent_139 = *elm_138 + 704
_62 = *tmp_95 + 576
_63 = *tmp_95 + 576
_64 = *_63 + 768
oright_140 = *tmp_95 + 640
derefaddrtmp(104) = &NULL
*oright_140 + 768 = derefaddrtmp(104)
derefaddrtmp(105) = &NONLOCAL
*tmp_95 + 768 = derefaddrtmp(105)
oright_143 = *tmp_95 + 640
_65 = *oright_143 + 576
*tmp_95 + 640 = _65
_66 = *tmp_95 + 640
_67 = *oright_143 + 576
*_67 + 704 = tmp_95
_68 = *tmp_95 + 704
*oright_143 + 704 = _68
_69 = *oright_143 + 704
_70 = *tmp_95 + 704
_71 = *_70 + 576
_72 = *tmp_95 + 704
*_72 + 576 = oright_143
_73 = *tmp_95 + 704
*_73 + 640 = oright_143
*head = oright_143
*oright_143 + 576 = tmp_95
*tmp_95 + 704 = oright_143
_74 = *oright_143 + 704
tmp_152 = *parent_90 + 576
tmp_96 = tmp_95
tmp_96 = tmp_152
_75 = *parent_90 + 768
*tmp_96 + 768 = _75
derefaddrtmp(120) = &NULL
*parent_90 + 768 = derefaddrtmp(120)
_76 = *tmp_96 + 576
_77 = *tmp_96 + 576
derefaddrtmp(123) = &NULL
*_77 + 768 = derefaddrtmp(123)
tmp_156 = *parent_90 + 576
_78 = *tmp_156 + 640
*parent_90 + 576 = _78
_79 = *parent_90 + 576
_80 = *tmp_156 + 640
*_80 + 704 = parent_90
_81 = *parent_90 + 704
*tmp_156 + 704 = _81
_82 = *tmp_156 + 704
_83 = *parent_90 + 704
_84 = *_83 + 576
_85 = *parent_90 + 704
*_85 + 576 = tmp_156
_86 = *parent_90 + 704
*_86 + 640 = tmp_156
*head = tmp_156
*tmp_156 + 640 = parent_90
*parent_90 + 704 = tmp_156
_87 = *tmp_156 + 704
elm_165 = *head
parent_90 = parent
parent_90 = parent_181
parent_90 = parent_139
elm_91 = elm
elm_91 = parent_90
elm_91 = elm_138
_88 = *elm_91 + 768
_89 = *head
elm_92 = elm_207
elm_92 = elm_165
elm_92 = elm_91
elm_92 = elm_91
derefaddrtmp(140) = &NULL
*elm_92 + 768 = derefaddrtmp(140)

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { NULL ESCAPED NONLOCAL }
NONLOCAL = { ESCAPED NONLOCAL }
STOREDANYTHING = { }
INTEGER = { ANYTHING }
head = { NONLOCAL }
parent = { NONLOCAL } same as head
elm = { NONLOCAL } same as head
_1 = { ESCAPED NONLOCAL }
parent_90 = { ESCAPED NONLOCAL }
tmp_166 = { ESCAPED NONLOCAL }
_2 = { ESCAPED NONLOCAL }
derefaddrtmp(15) = { NULL }
derefaddrtmp(16) = { NONLOCAL } same as head
tmp_169 = { ESCAPED NONLOCAL }
_3 = { ESCAPED NONLOCAL }
_4 = { ESCAPED NONLOCAL }
_5 = { ESCAPED NONLOCAL }
_6 = { ESCAPED NONLOCAL }
_7 = { ESCAPED NONLOCAL }
_8 = { ESCAPED NONLOCAL }
_9 = { ESCAPED NONLOCAL }
_10 = { ESCAPED NONLOCAL }
_11 = { ESCAPED NONLOCAL }
_12 = { ESCAPED NONLOCAL }
tmp_178 = { ESCAPED NONLOCAL }
tmp_93 = { ESCAPED NONLOCAL }
_13 = { ESCAPED NONLOCAL }
_14 = { ESCAPED NONLOCAL }
_15 = { ESCAPED NONLOCAL }
_16 = { ESCAPED NONLOCAL }
_17 = { ESCAPED NONLOCAL }
_18 = { ESCAPED NONLOCAL }
derefaddrtmp(36) = { NONLOCAL } same as head
parent_181 = { ESCAPED NONLOCAL }
_19 = { ESCAPED NONLOCAL }
_20 = { ESCAPED NONLOCAL }
_21 = { ESCAPED NONLOCAL }
oleft_182 = { ESCAPED NONLOCAL }
derefaddrtmp(42) = { NULL } same as derefaddrtmp(15)
derefaddrtmp(43) = { NONLOCAL } same as head
oleft_185 = { ESCAPED NONLOCAL }
_22 = { ESCAPED NONLOCAL }
_23 = { ESCAPED NONLOCAL }
_24 = { ESCAPED NONLOCAL }
_25 = { ESCAPED NONLOCAL }
_26 = { ESCAPED NONLOCAL }
_27 = { ESCAPED NONLOCAL }
_28 = { ESCAPED NONLOCAL }
_29 = { ESCAPED NONLOCAL }
_30 = { ESCAPED NONLOCAL }
_31 = { ESCAPED NONLOCAL }
tmp_194 = { ESCAPED NONLOCAL }
tmp_94 = { ESCAPED NONLOCAL }
_32 = { ESCAPED NONLOCAL }
derefaddrtmp(58) = { NULL } same as derefaddrtmp(15)
_33 = { ESCAPED NONLOCAL }
_34 = { ESCAPED NONLOCAL }
derefaddrtmp(61) = { NULL } same as derefaddrtmp(15)
tmp_198 = { ESCAPED NONLOCAL }
_35 = { ESCAPED NONLOCAL }
_36 = { ESCAPED NONLOCAL }
_37 = { ESCAPED NONLOCAL }
_38 = { ESCAPED NONLOCAL }
_39 = { ESCAPED NONLOCAL }
_40 = { ESCAPED NONLOCAL }
_41 = { ESCAPED NONLOCAL }
_42 = { ESCAPED NONLOCAL }
_43 = { ESCAPED NONLOCAL }
_44 = { ESCAPED NONLOCAL }
elm_207 = { ESCAPED NONLOCAL }
tmp_124 = { ESCAPED NONLOCAL }
_45 = { ESCAPED NONLOCAL }
derefaddrtmp(76) = { NULL } same as derefaddrtmp(15)
derefaddrtmp(77) = { NONLOCAL } same as head
tmp_127 = { ESCAPED NONLOCAL }
_46 = { ESCAPED NONLOCAL }
_47 = { ESCAPED NONLOCAL }
_48 = { ESCAPED NONLOCAL }
_49 = { ESCAPED NONLOCAL }
_50 = { ESCAPED NONLOCAL }
_51 = { ESCAPED NONLOCAL }
_52 = { ESCAPED NONLOCAL }
_53 = { ESCAPED NONLOCAL }
_54 = { ESCAPED NONLOCAL }
_55 = { ESCAPED NONLOCAL }
tmp_136 = { ESCAPED NONLOCAL }
tmp_95 = { ESCAPED NONLOCAL }
_56 = { ESCAPED NONLOCAL }
_57 = { ESCAPED NONLOCAL }
_58 = { ESCAPED NONLOCAL }
_59 = { ESCAPED NONLOCAL }
_60 = { ESCAPED NONLOCAL }
_61 = { ESCAPED NONLOCAL }
derefaddrtmp(97) = { NONLOCAL } same as head
elm_138 = { ESCAPED NONLOCAL } same as parent_90
parent_139 = { ESCAPED NONLOCAL }
_62 = { ESCAPED NONLOCAL }
_63 = { ESCAPED NONLOCAL }
_64 = { ESCAPED NONLOCAL }
oright_140 = { ESCAPED NONLOCAL }
derefaddrtmp(104) = { NULL } same as derefaddrtmp(15)
derefaddrtmp(105) = { NONLOCAL } same as head
oright_143 = { ESCAPED NONLOCAL }
_65 = { ESCAPED NONLOCAL }
_66 = { ESCAPED NONLOCAL }
_67 = { ESCAPED NONLOCAL }
_68 = { ESCAPED NONLOCAL }
_69 = { ESCAPED NONLOCAL }
_70 = { ESCAPED NONLOCAL }
_71 = { ESCAPED NONLOCAL }
_72 = { ESCAPED NONLOCAL }
_73 = { ESCAPED NONLOCAL }
_74 = { ESCAPED NONLOCAL }
tmp_152 = { ESCAPED NONLOCAL }
tmp_96 = { ESCAPED NONLOCAL }
_75 = { ESCAPED NONLOCAL }
derefaddrtmp(120) = { NULL } same as derefaddrtmp(15)
_76 = { ESCAPED NONLOCAL }
_77 = { ESCAPED NONLOCAL }
derefaddrtmp(123) = { NULL } same as derefaddrtmp(15)
tmp_156 = { ESCAPED NONLOCAL }
_78 = { ESCAPED NONLOCAL }
_79 = { ESCAPED NONLOCAL }
_80 = { ESCAPED NONLOCAL }
_81 = { ESCAPED NONLOCAL }
_82 = { ESCAPED NONLOCAL }
_83 = { ESCAPED NONLOCAL }
_84 = { ESCAPED NONLOCAL }
_85 = { ESCAPED NONLOCAL }
_86 = { ESCAPED NONLOCAL }
_87 = { ESCAPED NONLOCAL }
elm_165 = { ESCAPED NONLOCAL } same as elm_207
elm_91 = { ESCAPED NONLOCAL } same as parent_90
_88 = { ESCAPED NONLOCAL }
_89 = { ESCAPED NONLOCAL } same as elm_207
elm_92 = { ESCAPED NONLOCAL }
derefaddrtmp(140) = { NULL } same as derefaddrtmp(15)


Alias information for winlinks_RB_REMOVE_COLOR

Aliased symbols


Call clobber information

ESCAPED, points-to non-local, points-to NULL, points-to vars: { }

Flow-insensitive points-to information

_1, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_3, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_4, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_5, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_6, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_7, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_8, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_9, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_10, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_11, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_12, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_13, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_14, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_16, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_17, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_19, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_20, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_22, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_23, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_24, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_25, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_26, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_27, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_28, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_29, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_30, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_31, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_33, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_34, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_35, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_36, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_37, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_38, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_39, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_40, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_41, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_42, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_43, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_44, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_46, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_47, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_48, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_49, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_50, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_51, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_52, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_53, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_54, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_55, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_56, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_57, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_59, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_60, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_62, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_63, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_65, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_66, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_67, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_68, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_69, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_70, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_71, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_72, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_73, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_74, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_76, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_77, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_78, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_79, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_80, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_81, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_82, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_83, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_84, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_85, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_86, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_87, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_89, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
parent_90, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
elm_91, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
elm_92, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
tmp_93, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
tmp_94, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
tmp_95, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
tmp_96, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
parent_120(D), points-to non-local, points-to NULL, points-to vars: { }
elm_121(D), points-to non-local, points-to NULL, points-to vars: { }
head_123(D), points-to non-local, points-to NULL, points-to vars: { }
tmp_124, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
tmp_127, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
tmp_136, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
elm_138, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
parent_139, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
oright_140, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
oright_143, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
tmp_152, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
tmp_156, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
elm_165, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
tmp_166, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
tmp_169, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
tmp_178, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
parent_181, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
oleft_182, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
oleft_185, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
tmp_194, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
tmp_198, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
elm_207, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }

winlinks_RB_REMOVE_COLOR (struct winlinks * head, struct winlink * parent, struct winlink * elm)
{
  struct winlink * oright;
  struct winlink * oleft;
  struct winlink * tmp;
  struct winlink * _1;
  int _2;
  struct winlink * _3;
  struct winlink * _4;
  struct winlink * _5;
  struct winlink * _6;
  struct winlink * _7;
  struct winlink * _8;
  struct winlink * _9;
  struct winlink * _10;
  struct winlink * _11;
  struct winlink * _12;
  struct winlink * _13;
  struct winlink * _14;
  int _15;
  struct winlink * _16;
  struct winlink * _17;
  int _18;
  struct winlink * _19;
  struct winlink * _20;
  int _21;
  struct winlink * _22;
  struct winlink * _23;
  struct winlink * _24;
  struct winlink * _25;
  struct winlink * _26;
  struct winlink * _27;
  struct winlink * _28;
  struct winlink * _29;
  struct winlink * _30;
  struct winlink * _31;
  int _32;
  struct winlink * _33;
  struct winlink * _34;
  struct winlink * _35;
  struct winlink * _36;
  struct winlink * _37;
  struct winlink * _38;
  struct winlink * _39;
  struct winlink * _40;
  struct winlink * _41;
  struct winlink * _42;
  struct winlink * _43;
  struct winlink * _44;
  int _45;
  struct winlink * _46;
  struct winlink * _47;
  struct winlink * _48;
  struct winlink * _49;
  struct winlink * _50;
  struct winlink * _51;
  struct winlink * _52;
  struct winlink * _53;
  struct winlink * _54;
  struct winlink * _55;
  struct winlink * _56;
  struct winlink * _57;
  int _58;
  struct winlink * _59;
  struct winlink * _60;
  int _61;
  struct winlink * _62;
  struct winlink * _63;
  int _64;
  struct winlink * _65;
  struct winlink * _66;
  struct winlink * _67;
  struct winlink * _68;
  struct winlink * _69;
  struct winlink * _70;
  struct winlink * _71;
  struct winlink * _72;
  struct winlink * _73;
  struct winlink * _74;
  int _75;
  struct winlink * _76;
  struct winlink * _77;
  struct winlink * _78;
  struct winlink * _79;
  struct winlink * _80;
  struct winlink * _81;
  struct winlink * _82;
  struct winlink * _83;
  struct winlink * _84;
  struct winlink * _85;
  struct winlink * _86;
  struct winlink * _87;
  int _88;
  struct winlink * _89;

  <bb 2> [0.00%]:
  goto <bb 76>; [0.00%]

  <bb 3> [0.00%]:
  _1 = parent_90->entry.rbe_left;
  if (_1 == elm_91)
    goto <bb 4>; [0.00%]
  else
    goto <bb 40>; [0.00%]

  <bb 4> [0.00%]:
  tmp_166 = parent_90->entry.rbe_right;
  _2 = tmp_166->entry.rbe_color;
  if (_2 == 1)
    goto <bb 5>; [0.00%]
  else
    goto <bb 13>; [0.00%]

  <bb 5> [0.00%]:
  tmp_166->entry.rbe_color = 0;
  parent_90->entry.rbe_color = 1;
  tmp_169 = parent_90->entry.rbe_right;
  _3 = tmp_169->entry.rbe_left;
  parent_90->entry.rbe_right = _3;
  _4 = parent_90->entry.rbe_right;
  if (_4 != 0B)
    goto <bb 6>; [0.00%]
  else
    goto <bb 7>; [0.00%]

  <bb 6> [0.00%]:
  _5 = tmp_169->entry.rbe_left;
  _5->entry.rbe_parent = parent_90;

  <bb 7> [0.00%]:
  _6 = parent_90->entry.rbe_parent;
  tmp_169->entry.rbe_parent = _6;
  _7 = tmp_169->entry.rbe_parent;
  if (_7 != 0B)
    goto <bb 8>; [0.00%]
  else
    goto <bb 11>; [0.00%]

  <bb 8> [0.00%]:
  _8 = parent_90->entry.rbe_parent;
  _9 = _8->entry.rbe_left;
  if (_9 == parent_90)
    goto <bb 9>; [0.00%]
  else
    goto <bb 10>; [0.00%]

  <bb 9> [0.00%]:
  _10 = parent_90->entry.rbe_parent;
  _10->entry.rbe_left = tmp_169;
  goto <bb 12>; [0.00%]

  <bb 10> [0.00%]:
  _11 = parent_90->entry.rbe_parent;
  _11->entry.rbe_right = tmp_169;
  goto <bb 12>; [0.00%]

  <bb 11> [0.00%]:
  head_123(D)->rbh_root = tmp_169;

  <bb 12> [0.00%]:
  tmp_169->entry.rbe_left = parent_90;
  parent_90->entry.rbe_parent = tmp_169;
  _12 = tmp_169->entry.rbe_parent;
  tmp_178 = parent_90->entry.rbe_right;

  <bb 13> [0.00%]:
  # tmp_93 = PHI <tmp_166(4), tmp_178(12)>
  _13 = tmp_93->entry.rbe_left;
  if (_13 == 0B)
    goto <bb 15>; [0.00%]
  else
    goto <bb 14>; [0.00%]

  <bb 14> [0.00%]:
  _14 = tmp_93->entry.rbe_left;
  _15 = _14->entry.rbe_color;
  if (_15 == 0)
    goto <bb 15>; [0.00%]
  else
    goto <bb 18>; [0.00%]

  <bb 15> [0.00%]:
  _16 = tmp_93->entry.rbe_right;
  if (_16 == 0B)
    goto <bb 17>; [0.00%]
  else
    goto <bb 16>; [0.00%]

  <bb 16> [0.00%]:
  _17 = tmp_93->entry.rbe_right;
  _18 = _17->entry.rbe_color;
  if (_18 == 0)
    goto <bb 17>; [0.00%]
  else
    goto <bb 18>; [0.00%]

  <bb 17> [0.00%]:
  tmp_93->entry.rbe_color = 1;
  parent_181 = parent_90->entry.rbe_parent;
  goto <bb 76>; [0.00%]

  <bb 18> [0.00%]:
  _19 = tmp_93->entry.rbe_right;
  if (_19 == 0B)
    goto <bb 20>; [0.00%]
  else
    goto <bb 19>; [0.00%]

  <bb 19> [0.00%]:
  _20 = tmp_93->entry.rbe_right;
  _21 = _20->entry.rbe_color;
  if (_21 == 0)
    goto <bb 20>; [0.00%]
  else
    goto <bb 30>; [0.00%]

  <bb 20> [0.00%]:
  oleft_182 = tmp_93->entry.rbe_left;
  if (oleft_182 != 0B)
    goto <bb 21>; [0.00%]
  else
    goto <bb 22>; [0.00%]

  <bb 21> [0.00%]:
  oleft_182->entry.rbe_color = 0;

  <bb 22> [0.00%]:
  tmp_93->entry.rbe_color = 1;
  oleft_185 = tmp_93->entry.rbe_left;
  _22 = oleft_185->entry.rbe_right;
  tmp_93->entry.rbe_left = _22;
  _23 = tmp_93->entry.rbe_left;
  if (_23 != 0B)
    goto <bb 23>; [0.00%]
  else
    goto <bb 24>; [0.00%]

  <bb 23> [0.00%]:
  _24 = oleft_185->entry.rbe_right;
  _24->entry.rbe_parent = tmp_93;

  <bb 24> [0.00%]:
  _25 = tmp_93->entry.rbe_parent;
  oleft_185->entry.rbe_parent = _25;
  _26 = oleft_185->entry.rbe_parent;
  if (_26 != 0B)
    goto <bb 25>; [0.00%]
  else
    goto <bb 28>; [0.00%]

  <bb 25> [0.00%]:
  _27 = tmp_93->entry.rbe_parent;
  _28 = _27->entry.rbe_left;
  if (_28 == tmp_93)
    goto <bb 26>; [0.00%]
  else
    goto <bb 27>; [0.00%]

  <bb 26> [0.00%]:
  _29 = tmp_93->entry.rbe_parent;
  _29->entry.rbe_left = oleft_185;
  goto <bb 29>; [0.00%]

  <bb 27> [0.00%]:
  _30 = tmp_93->entry.rbe_parent;
  _30->entry.rbe_right = oleft_185;
  goto <bb 29>; [0.00%]

  <bb 28> [0.00%]:
  head_123(D)->rbh_root = oleft_185;

  <bb 29> [0.00%]:
  oleft_185->entry.rbe_right = tmp_93;
  tmp_93->entry.rbe_parent = oleft_185;
  _31 = oleft_185->entry.rbe_parent;
  tmp_194 = parent_90->entry.rbe_right;

  <bb 30> [0.00%]:
  # tmp_94 = PHI <tmp_93(19), tmp_194(29)>
  _32 = parent_90->entry.rbe_color;
  tmp_94->entry.rbe_color = _32;
  parent_90->entry.rbe_color = 0;
  _33 = tmp_94->entry.rbe_right;
  if (_33 != 0B)
    goto <bb 31>; [0.00%]
  else
    goto <bb 32>; [0.00%]

  <bb 31> [0.00%]:
  _34 = tmp_94->entry.rbe_right;
  _34->entry.rbe_color = 0;

  <bb 32> [0.00%]:
  tmp_198 = parent_90->entry.rbe_right;
  _35 = tmp_198->entry.rbe_left;
  parent_90->entry.rbe_right = _35;
  _36 = parent_90->entry.rbe_right;
  if (_36 != 0B)
    goto <bb 33>; [0.00%]
  else
    goto <bb 34>; [0.00%]

  <bb 33> [0.00%]:
  _37 = tmp_198->entry.rbe_left;
  _37->entry.rbe_parent = parent_90;

  <bb 34> [0.00%]:
  _38 = parent_90->entry.rbe_parent;
  tmp_198->entry.rbe_parent = _38;
  _39 = tmp_198->entry.rbe_parent;
  if (_39 != 0B)
    goto <bb 35>; [0.00%]
  else
    goto <bb 38>; [0.00%]

  <bb 35> [0.00%]:
  _40 = parent_90->entry.rbe_parent;
  _41 = _40->entry.rbe_left;
  if (_41 == parent_90)
    goto <bb 36>; [0.00%]
  else
    goto <bb 37>; [0.00%]

  <bb 36> [0.00%]:
  _42 = parent_90->entry.rbe_parent;
  _42->entry.rbe_left = tmp_198;
  goto <bb 39>; [0.00%]

  <bb 37> [0.00%]:
  _43 = parent_90->entry.rbe_parent;
  _43->entry.rbe_right = tmp_198;
  goto <bb 39>; [0.00%]

  <bb 38> [0.00%]:
  head_123(D)->rbh_root = tmp_198;

  <bb 39> [0.00%]:
  tmp_198->entry.rbe_left = parent_90;
  parent_90->entry.rbe_parent = tmp_198;
  _44 = tmp_198->entry.rbe_parent;
  elm_207 = head_123(D)->rbh_root;
  goto <bb 79>; [0.00%]

  <bb 40> [0.00%]:
  tmp_124 = parent_90->entry.rbe_left;
  _45 = tmp_124->entry.rbe_color;
  if (_45 == 1)
    goto <bb 41>; [0.00%]
  else
    goto <bb 49>; [0.00%]

  <bb 41> [0.00%]:
  tmp_124->entry.rbe_color = 0;
  parent_90->entry.rbe_color = 1;
  tmp_127 = parent_90->entry.rbe_left;
  _46 = tmp_127->entry.rbe_right;
  parent_90->entry.rbe_left = _46;
  _47 = parent_90->entry.rbe_left;
  if (_47 != 0B)
    goto <bb 42>; [0.00%]
  else
    goto <bb 43>; [0.00%]

  <bb 42> [0.00%]:
  _48 = tmp_127->entry.rbe_right;
  _48->entry.rbe_parent = parent_90;

  <bb 43> [0.00%]:
  _49 = parent_90->entry.rbe_parent;
  tmp_127->entry.rbe_parent = _49;
  _50 = tmp_127->entry.rbe_parent;
  if (_50 != 0B)
    goto <bb 44>; [0.00%]
  else
    goto <bb 47>; [0.00%]

  <bb 44> [0.00%]:
  _51 = parent_90->entry.rbe_parent;
  _52 = _51->entry.rbe_left;
  if (_52 == parent_90)
    goto <bb 45>; [0.00%]
  else
    goto <bb 46>; [0.00%]

  <bb 45> [0.00%]:
  _53 = parent_90->entry.rbe_parent;
  _53->entry.rbe_left = tmp_127;
  goto <bb 48>; [0.00%]

  <bb 46> [0.00%]:
  _54 = parent_90->entry.rbe_parent;
  _54->entry.rbe_right = tmp_127;
  goto <bb 48>; [0.00%]

  <bb 47> [0.00%]:
  head_123(D)->rbh_root = tmp_127;

  <bb 48> [0.00%]:
  tmp_127->entry.rbe_right = parent_90;
  parent_90->entry.rbe_parent = tmp_127;
  _55 = tmp_127->entry.rbe_parent;
  tmp_136 = parent_90->entry.rbe_left;

  <bb 49> [0.00%]:
  # tmp_95 = PHI <tmp_124(40), tmp_136(48)>
  _56 = tmp_95->entry.rbe_left;
  if (_56 == 0B)
    goto <bb 51>; [0.00%]
  else
    goto <bb 50>; [0.00%]

  <bb 50> [0.00%]:
  _57 = tmp_95->entry.rbe_left;
  _58 = _57->entry.rbe_color;
  if (_58 == 0)
    goto <bb 51>; [0.00%]
  else
    goto <bb 54>; [0.00%]

  <bb 51> [0.00%]:
  _59 = tmp_95->entry.rbe_right;
  if (_59 == 0B)
    goto <bb 53>; [0.00%]
  else
    goto <bb 52>; [0.00%]

  <bb 52> [0.00%]:
  _60 = tmp_95->entry.rbe_right;
  _61 = _60->entry.rbe_color;
  if (_61 == 0)
    goto <bb 53>; [0.00%]
  else
    goto <bb 54>; [0.00%]

  <bb 53> [0.00%]:
  tmp_95->entry.rbe_color = 1;
  elm_138 = parent_90;
  parent_139 = elm_138->entry.rbe_parent;
  goto <bb 76>; [0.00%]

  <bb 54> [0.00%]:
  _62 = tmp_95->entry.rbe_left;
  if (_62 == 0B)
    goto <bb 56>; [0.00%]
  else
    goto <bb 55>; [0.00%]

  <bb 55> [0.00%]:
  _63 = tmp_95->entry.rbe_left;
  _64 = _63->entry.rbe_color;
  if (_64 == 0)
    goto <bb 56>; [0.00%]
  else
    goto <bb 66>; [0.00%]

  <bb 56> [0.00%]:
  oright_140 = tmp_95->entry.rbe_right;
  if (oright_140 != 0B)
    goto <bb 57>; [0.00%]
  else
    goto <bb 58>; [0.00%]

  <bb 57> [0.00%]:
  oright_140->entry.rbe_color = 0;

  <bb 58> [0.00%]:
  tmp_95->entry.rbe_color = 1;
  oright_143 = tmp_95->entry.rbe_right;
  _65 = oright_143->entry.rbe_left;
  tmp_95->entry.rbe_right = _65;
  _66 = tmp_95->entry.rbe_right;
  if (_66 != 0B)
    goto <bb 59>; [0.00%]
  else
    goto <bb 60>; [0.00%]

  <bb 59> [0.00%]:
  _67 = oright_143->entry.rbe_left;
  _67->entry.rbe_parent = tmp_95;

  <bb 60> [0.00%]:
  _68 = tmp_95->entry.rbe_parent;
  oright_143->entry.rbe_parent = _68;
  _69 = oright_143->entry.rbe_parent;
  if (_69 != 0B)
    goto <bb 61>; [0.00%]
  else
    goto <bb 64>; [0.00%]

  <bb 61> [0.00%]:
  _70 = tmp_95->entry.rbe_parent;
  _71 = _70->entry.rbe_left;
  if (_71 == tmp_95)
    goto <bb 62>; [0.00%]
  else
    goto <bb 63>; [0.00%]

  <bb 62> [0.00%]:
  _72 = tmp_95->entry.rbe_parent;
  _72->entry.rbe_left = oright_143;
  goto <bb 65>; [0.00%]

  <bb 63> [0.00%]:
  _73 = tmp_95->entry.rbe_parent;
  _73->entry.rbe_right = oright_143;
  goto <bb 65>; [0.00%]

  <bb 64> [0.00%]:
  head_123(D)->rbh_root = oright_143;

  <bb 65> [0.00%]:
  oright_143->entry.rbe_left = tmp_95;
  tmp_95->entry.rbe_parent = oright_143;
  _74 = oright_143->entry.rbe_parent;
  tmp_152 = parent_90->entry.rbe_left;

  <bb 66> [0.00%]:
  # tmp_96 = PHI <tmp_95(55), tmp_152(65)>
  _75 = parent_90->entry.rbe_color;
  tmp_96->entry.rbe_color = _75;
  parent_90->entry.rbe_color = 0;
  _76 = tmp_96->entry.rbe_left;
  if (_76 != 0B)
    goto <bb 67>; [0.00%]
  else
    goto <bb 68>; [0.00%]

  <bb 67> [0.00%]:
  _77 = tmp_96->entry.rbe_left;
  _77->entry.rbe_color = 0;

  <bb 68> [0.00%]:
  tmp_156 = parent_90->entry.rbe_left;
  _78 = tmp_156->entry.rbe_right;
  parent_90->entry.rbe_left = _78;
  _79 = parent_90->entry.rbe_left;
  if (_79 != 0B)
    goto <bb 69>; [0.00%]
  else
    goto <bb 70>; [0.00%]

  <bb 69> [0.00%]:
  _80 = tmp_156->entry.rbe_right;
  _80->entry.rbe_parent = parent_90;

  <bb 70> [0.00%]:
  _81 = parent_90->entry.rbe_parent;
  tmp_156->entry.rbe_parent = _81;
  _82 = tmp_156->entry.rbe_parent;
  if (_82 != 0B)
    goto <bb 71>; [0.00%]
  else
    goto <bb 74>; [0.00%]

  <bb 71> [0.00%]:
  _83 = parent_90->entry.rbe_parent;
  _84 = _83->entry.rbe_left;
  if (_84 == parent_90)
    goto <bb 72>; [0.00%]
  else
    goto <bb 73>; [0.00%]

  <bb 72> [0.00%]:
  _85 = parent_90->entry.rbe_parent;
  _85->entry.rbe_left = tmp_156;
  goto <bb 75>; [0.00%]

  <bb 73> [0.00%]:
  _86 = parent_90->entry.rbe_parent;
  _86->entry.rbe_right = tmp_156;
  goto <bb 75>; [0.00%]

  <bb 74> [0.00%]:
  head_123(D)->rbh_root = tmp_156;

  <bb 75> [0.00%]:
  tmp_156->entry.rbe_right = parent_90;
  parent_90->entry.rbe_parent = tmp_156;
  _87 = tmp_156->entry.rbe_parent;
  elm_165 = head_123(D)->rbh_root;
  goto <bb 79>; [0.00%]

  <bb 76> [0.00%]:
  # parent_90 = PHI <parent_120(D)(2), parent_181(17), parent_139(53)>
  # elm_91 = PHI <elm_121(D)(2), parent_90(17), elm_138(53)>
  if (elm_91 == 0B)
    goto <bb 78>; [0.00%]
  else
    goto <bb 77>; [0.00%]

  <bb 77> [0.00%]:
  _88 = elm_91->entry.rbe_color;
  if (_88 == 0)
    goto <bb 78>; [0.00%]
  else
    goto <bb 79>; [0.00%]

  <bb 78> [0.00%]:
  _89 = head_123(D)->rbh_root;
  if (_89 != elm_91)
    goto <bb 3>; [0.00%]
  else
    goto <bb 79>; [0.00%]

  <bb 79> [0.00%]:
  # elm_92 = PHI <elm_207(39), elm_165(75), elm_91(77), elm_91(78)>
  if (elm_92 != 0B)
    goto <bb 80>; [0.00%]
  else
    goto <bb 81>; [0.00%]

  <bb 80> [0.00%]:
  elm_92->entry.rbe_color = 0;

  <bb 81> [0.00%]:
  return;

}



;; Function winlinks_RB_INSERT (winlinks_RB_INSERT, funcdef_no=53, decl_uid=4323, cgraph_uid=53, symbol_order=56)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
head = &NONLOCAL
elm = &NONLOCAL
tmp_13 = *head
parent_24 = tmp_2
CALLUSED(14) = CALLUSED(14) + UNKNOWN
CALLUSED(14) = *CALLUSED(14) + UNKNOWN
CALLUSED(14) = elm
CALLUSED(14) = parent_24
comp_26 = CALLUSED(14)
comp_26 = NONLOCAL
tmp_29 = *tmp_2 + 576
tmp_28 = *tmp_2 + 640
_27 = tmp_2
tmp_2 = tmp_13
tmp_2 = tmp_29
tmp_2 = tmp_28
parent_3 = &NULL
parent_3 = parent_24
parent_3 = parent_24
comp_4 = &NULL
comp_4 = comp_26
comp_4 = comp_26
*elm + 704 = parent_3
derefaddrtmp(22) = &NULL
*elm + 640 = derefaddrtmp(22)
_1 = *elm + 640
*elm + 576 = _1
derefaddrtmp(24) = &NONLOCAL
*elm + 768 = derefaddrtmp(24)
*parent_3 + 576 = elm
*parent_3 + 640 = elm
*head = elm
ESCAPED = head
ESCAPED = elm
_5 = tmp_2
_5 = &NULL
ESCAPED = _5

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { NULL ESCAPED NONLOCAL }
NONLOCAL = { ESCAPED NONLOCAL }
STOREDANYTHING = { }
INTEGER = { ANYTHING }
head = { NONLOCAL }
elm = { NONLOCAL } same as head
tmp_13 = { ESCAPED NONLOCAL }
parent_24 = { ESCAPED NONLOCAL }
tmp_2 = { ESCAPED NONLOCAL } same as parent_24
winlink_cmp = { }
CALLUSED(14) = { ESCAPED NONLOCAL }
CALLCLOBBERED(15) = { }
comp_26 = { ESCAPED NONLOCAL }
tmp_29 = { ESCAPED NONLOCAL }
tmp_28 = { ESCAPED NONLOCAL }
_27 = { ESCAPED NONLOCAL } same as parent_24
parent_3 = { NULL ESCAPED NONLOCAL }
comp_4 = { NULL ESCAPED NONLOCAL }
derefaddrtmp(22) = { NULL }
_1 = { ESCAPED NONLOCAL }
derefaddrtmp(24) = { NONLOCAL } same as head
winlinks_RB_INSERT_COLOR = { }
_5 = { NULL ESCAPED NONLOCAL } same as parent_3


Alias information for winlinks_RB_INSERT

Aliased symbols


Call clobber information

ESCAPED, points-to non-local, points-to NULL, points-to vars: { }

Flow-insensitive points-to information

_1, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
tmp_2, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
parent_3, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_5, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
head_12(D), points-to non-local, points-to NULL, points-to vars: { }
tmp_13, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
elm_14(D), points-to non-local, points-to NULL, points-to vars: { }
parent_24, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_27, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
tmp_28, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
tmp_29, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }

winlinks_RB_INSERT (struct winlinks * head, struct winlink * elm)
{
  int comp;
  struct winlink * parent;
  struct winlink * tmp;
  struct winlink * _1;
  struct winlink * _5;
  struct winlink * _27;

  <bb 2> [0.00%]:
  tmp_13 = head_12(D)->rbh_root;
  goto <bb 8>; [0.00%]

  <bb 3> [0.00%]:
  parent_24 = tmp_2;
  comp_26 = winlink_cmp (elm_14(D), parent_24);
  if (comp_26 < 0)
    goto <bb 4>; [0.00%]
  else
    goto <bb 5>; [0.00%]

  <bb 4> [0.00%]:
  tmp_29 = tmp_2->entry.rbe_left;
  goto <bb 8>; [0.00%]

  <bb 5> [0.00%]:
  if (comp_26 > 0)
    goto <bb 6>; [0.00%]
  else
    goto <bb 7>; [0.00%]

  <bb 6> [0.00%]:
  tmp_28 = tmp_2->entry.rbe_right;
  goto <bb 8>; [0.00%]

  <bb 7> [0.00%]:
  _27 = tmp_2;
  goto <bb 15>; [0.00%]

  <bb 8> [0.00%]:
  # tmp_2 = PHI <tmp_13(2), tmp_29(4), tmp_28(6)>
  # parent_3 = PHI <0B(2), parent_24(4), parent_24(6)>
  # comp_4 = PHI <0(2), comp_26(4), comp_26(6)>
  if (tmp_2 != 0B)
    goto <bb 3>; [0.00%]
  else
    goto <bb 9>; [0.00%]

  <bb 9> [0.00%]:
  elm_14(D)->entry.rbe_parent = parent_3;
  elm_14(D)->entry.rbe_right = 0B;
  _1 = elm_14(D)->entry.rbe_right;
  elm_14(D)->entry.rbe_left = _1;
  elm_14(D)->entry.rbe_color = 1;
  if (parent_3 != 0B)
    goto <bb 10>; [0.00%]
  else
    goto <bb 13>; [0.00%]

  <bb 10> [0.00%]:
  if (comp_4 < 0)
    goto <bb 11>; [0.00%]
  else
    goto <bb 12>; [0.00%]

  <bb 11> [0.00%]:
  parent_3->entry.rbe_left = elm_14(D);
  goto <bb 14>; [0.00%]

  <bb 12> [0.00%]:
  parent_3->entry.rbe_right = elm_14(D);
  goto <bb 14>; [0.00%]

  <bb 13> [0.00%]:
  head_12(D)->rbh_root = elm_14(D);

  <bb 14> [0.00%]:
  winlinks_RB_INSERT_COLOR (head_12(D), elm_14(D));

  <bb 15> [0.00%]:
  # _5 = PHI <tmp_2(7), 0B(14)>
  return _5;

}



;; Function winlinks_RB_REMOVE (winlinks_RB_REMOVE, funcdef_no=54, decl_uid=4333, cgraph_uid=54, symbol_order=57)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
head = &NONLOCAL
elm = &NONLOCAL
_1 = *elm + 576
child_52 = *elm + 640
_2 = *elm + 640
child_51 = *elm + 576
elm_31 = *elm + 640
elm_14 = elm_31
elm_14 = left_32
left_32 = *elm_14 + 576
child_33 = *elm_14 + 640
parent_34 = *elm_14 + 704
color_35 = *elm_14 + 768
*child_33 + 704 = parent_34
_3 = *parent_34 + 576
*parent_34 + 576 = child_33
*parent_34 + 640 = child_33
*head = child_33
_4 = *elm_14 + 704
parent_41 = elm_14
parent_17 = parent_34
parent_17 = elm_14
doubledereftmp(24) = *elm + UNKNOWN
*elm_14 + UNKNOWN = doubledereftmp(24)
_5 = *elm + 704
_6 = *elm + 704
_7 = *_6 + 576
_8 = *elm + 704
*_8 + 576 = elm_14
_9 = *elm + 704
*_9 + 640 = elm_14
*head = elm_14
_10 = *elm + 576
*_10 + 704 = elm_14
_11 = *elm + 640
_12 = *elm + 640
*_12 + 704 = elm_14
left_20 = parent_17
left_20 = left_49
left_49 = *left_20 + 704
child_15 = child_52
child_15 = child_51
parent_53 = *elm + 704
color_54 = *elm + 768
*child_15 + 704 = parent_53
_13 = *parent_53 + 576
*parent_53 + 576 = child_15
*parent_53 + 640 = child_15
*head = child_15
child_16 = child_33
child_16 = child_15
child_16 = child_15
child_16 = child_33
child_16 = child_15
parent_18 = parent_17
parent_18 = parent_53
parent_18 = parent_53
parent_18 = parent_17
parent_18 = parent_53
color_19 = color_35
color_19 = color_54
color_19 = color_54
color_19 = color_35
color_19 = color_54
ESCAPED = head
ESCAPED = parent_18
ESCAPED = child_16
ESCAPED = elm

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { ESCAPED NONLOCAL }
NONLOCAL = { ESCAPED NONLOCAL }
STOREDANYTHING = { }
INTEGER = { ANYTHING }
head = { NONLOCAL }
elm = { NONLOCAL } same as head
_1 = { ESCAPED NONLOCAL }
child_52 = { ESCAPED NONLOCAL }
_2 = { ESCAPED NONLOCAL }
child_51 = { ESCAPED NONLOCAL }
elm_31 = { ESCAPED NONLOCAL }
elm_14 = { ESCAPED NONLOCAL }
left_32 = { ESCAPED NONLOCAL }
child_33 = { ESCAPED NONLOCAL }
parent_34 = { ESCAPED NONLOCAL }
color_35 = { ESCAPED NONLOCAL }
_3 = { ESCAPED NONLOCAL }
_4 = { ESCAPED NONLOCAL }
parent_41 = { ESCAPED NONLOCAL } same as elm_14
parent_17 = { ESCAPED NONLOCAL }
doubledereftmp(24) = { ESCAPED NONLOCAL }
_5 = { ESCAPED NONLOCAL }
_6 = { ESCAPED NONLOCAL }
_7 = { ESCAPED NONLOCAL }
_8 = { ESCAPED NONLOCAL }
_9 = { ESCAPED NONLOCAL }
_10 = { ESCAPED NONLOCAL }
_11 = { ESCAPED NONLOCAL }
_12 = { ESCAPED NONLOCAL }
left_20 = { ESCAPED NONLOCAL }
left_49 = { ESCAPED NONLOCAL }
child_15 = { ESCAPED NONLOCAL }
parent_53 = { ESCAPED NONLOCAL }
color_54 = { ESCAPED NONLOCAL }
_13 = { ESCAPED NONLOCAL }
child_16 = { ESCAPED NONLOCAL }
parent_18 = { ESCAPED NONLOCAL }
color_19 = { ESCAPED NONLOCAL }
winlinks_RB_REMOVE_COLOR = { }


Alias information for winlinks_RB_REMOVE

Aliased symbols


Call clobber information

ESCAPED, points-to non-local, points-to vars: { }

Flow-insensitive points-to information

_1, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_2, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_3, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_4, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_5, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_6, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_7, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_8, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_9, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_10, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_11, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_12, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_13, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
elm_14, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
child_15, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
child_16, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
parent_17, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
parent_18, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
left_20, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
elm_28(D), points-to non-local, points-to NULL, points-to vars: { }
elm_31, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
left_32, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
child_33, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
parent_34, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
head_37(D), points-to non-local, points-to NULL, points-to vars: { }
parent_41, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
left_49, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
child_51, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
child_52, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
parent_53, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }

winlinks_RB_REMOVE (struct winlinks * head, struct winlink * elm)
{
  struct winlink * left;
  int color;
  struct winlink * old;
  struct winlink * parent;
  struct winlink * child;
  struct winlink * _1;
  struct winlink * _2;
  struct winlink * _3;
  struct winlink * _4;
  struct winlink * _5;
  struct winlink * _6;
  struct winlink * _7;
  struct winlink * _8;
  struct winlink * _9;
  struct winlink * _10;
  struct winlink * _11;
  struct winlink * _12;
  struct winlink * _13;

  <bb 2> [0.00%]:
  _1 = elm_28(D)->entry.rbe_left;
  if (_1 == 0B)
    goto <bb 3>; [0.00%]
  else
    goto <bb 4>; [0.00%]

  <bb 3> [0.00%]:
  child_52 = elm_28(D)->entry.rbe_right;
  goto <bb 26>; [0.00%]

  <bb 4> [0.00%]:
  _2 = elm_28(D)->entry.rbe_right;
  if (_2 == 0B)
    goto <bb 5>; [0.00%]
  else
    goto <bb 6>; [0.00%]

  <bb 5> [0.00%]:
  child_51 = elm_28(D)->entry.rbe_left;
  goto <bb 26>; [0.00%]

  <bb 6> [0.00%]:
  elm_31 = elm_28(D)->entry.rbe_right;

  <bb 7> [0.00%]:
  # elm_14 = PHI <elm_31(6), left_32(7)>
  left_32 = elm_14->entry.rbe_left;
  if (left_32 != 0B)
    goto <bb 7>; [0.00%]
  else
    goto <bb 8>; [0.00%]

  <bb 8> [0.00%]:
  child_33 = elm_14->entry.rbe_right;
  parent_34 = elm_14->entry.rbe_parent;
  color_35 = elm_14->entry.rbe_color;
  if (child_33 != 0B)
    goto <bb 9>; [0.00%]
  else
    goto <bb 10>; [0.00%]

  <bb 9> [0.00%]:
  child_33->entry.rbe_parent = parent_34;

  <bb 10> [0.00%]:
  if (parent_34 != 0B)
    goto <bb 11>; [0.00%]
  else
    goto <bb 14>; [0.00%]

  <bb 11> [0.00%]:
  _3 = parent_34->entry.rbe_left;
  if (_3 == elm_14)
    goto <bb 12>; [0.00%]
  else
    goto <bb 13>; [0.00%]

  <bb 12> [0.00%]:
  parent_34->entry.rbe_left = child_33;
  goto <bb 15>; [0.00%]

  <bb 13> [0.00%]:
  parent_34->entry.rbe_right = child_33;
  goto <bb 15>; [0.00%]

  <bb 14> [0.00%]:
  head_37(D)->rbh_root = child_33;

  <bb 15> [0.00%]:
  _4 = elm_14->entry.rbe_parent;
  if (_4 == elm_28(D))
    goto <bb 16>; [0.00%]
  else
    goto <bb 17>; [0.00%]

  <bb 16> [0.00%]:
  parent_41 = elm_14;

  <bb 17> [0.00%]:
  # parent_17 = PHI <parent_34(15), elm_14(16)>
  elm_14->entry = elm_28(D)->entry;
  _5 = elm_28(D)->entry.rbe_parent;
  if (_5 != 0B)
    goto <bb 18>; [0.00%]
  else
    goto <bb 21>; [0.00%]

  <bb 18> [0.00%]:
  _6 = elm_28(D)->entry.rbe_parent;
  _7 = _6->entry.rbe_left;
  if (_7 == elm_28(D))
    goto <bb 19>; [0.00%]
  else
    goto <bb 20>; [0.00%]

  <bb 19> [0.00%]:
  _8 = elm_28(D)->entry.rbe_parent;
  _8->entry.rbe_left = elm_14;
  goto <bb 22>; [0.00%]

  <bb 20> [0.00%]:
  _9 = elm_28(D)->entry.rbe_parent;
  _9->entry.rbe_right = elm_14;
  goto <bb 22>; [0.00%]

  <bb 21> [0.00%]:
  head_37(D)->rbh_root = elm_14;

  <bb 22> [0.00%]:
  _10 = elm_28(D)->entry.rbe_left;
  _10->entry.rbe_parent = elm_14;
  _11 = elm_28(D)->entry.rbe_right;
  if (_11 != 0B)
    goto <bb 23>; [0.00%]
  else
    goto <bb 24>; [0.00%]

  <bb 23> [0.00%]:
  _12 = elm_28(D)->entry.rbe_right;
  _12->entry.rbe_parent = elm_14;

  <bb 24> [0.00%]:
  if (parent_17 != 0B)
    goto <bb 25>; [0.00%]
  else
    goto <bb 33> (color); [0.00%]

  <bb 25> [0.00%]:
  # left_20 = PHI <parent_17(24), left_49(25)>
  left_49 = left_20->entry.rbe_parent;
  if (left_49 != 0B)
    goto <bb 25>; [0.00%]
  else
    goto <bb 33> (color); [0.00%]

  <bb 26> [0.00%]:
  # child_15 = PHI <child_52(3), child_51(5)>
  parent_53 = elm_28(D)->entry.rbe_parent;
  color_54 = elm_28(D)->entry.rbe_color;
  if (child_15 != 0B)
    goto <bb 27>; [0.00%]
  else
    goto <bb 28>; [0.00%]

  <bb 27> [0.00%]:
  child_15->entry.rbe_parent = parent_53;

  <bb 28> [0.00%]:
  if (parent_53 != 0B)
    goto <bb 29>; [0.00%]
  else
    goto <bb 32>; [0.00%]

  <bb 29> [0.00%]:
  _13 = parent_53->entry.rbe_left;
  if (_13 == elm_28(D))
    goto <bb 30>; [0.00%]
  else
    goto <bb 31>; [0.00%]

  <bb 30> [0.00%]:
  parent_53->entry.rbe_left = child_15;
  goto <bb 33> (color); [0.00%]

  <bb 31> [0.00%]:
  parent_53->entry.rbe_right = child_15;
  goto <bb 33> (color); [0.00%]

  <bb 32> [0.00%]:
  head_37(D)->rbh_root = child_15;

  # child_16 = PHI <child_33(25), child_15(31), child_15(32), child_33(24), child_15(30)>
  # parent_18 = PHI <parent_17(25), parent_53(31), parent_53(32), parent_17(24), parent_53(30)>
  # color_19 = PHI <color_35(25), color_54(31), color_54(32), color_35(24), color_54(30)>
color [0.00%]:
  if (color_19 == 0)
    goto <bb 34>; [0.00%]
  else
    goto <bb 35>; [0.00%]

  <bb 34> [0.00%]:
  winlinks_RB_REMOVE_COLOR (head_37(D), parent_18, child_16);

  <bb 35> [0.00%]:
  return elm_28(D);

}



;; Function winlinks_RB_FIND (winlinks_RB_FIND, funcdef_no=55, decl_uid=4348, cgraph_uid=55, symbol_order=58)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
head = &NONLOCAL
elm = &NONLOCAL
tmp_7 = *head
CALLUSED(12) = CALLUSED(12) + UNKNOWN
CALLUSED(12) = *CALLUSED(12) + UNKNOWN
CALLUSED(12) = elm
CALLUSED(12) = tmp_1
comp_11 = CALLUSED(12)
comp_11 = NONLOCAL
tmp_14 = *tmp_1 + 576
tmp_13 = *tmp_1 + 640
_12 = tmp_1
tmp_1 = tmp_7
tmp_1 = tmp_14
tmp_1 = tmp_13
_2 = tmp_1
_2 = &NULL
ESCAPED = _2

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { NULL ESCAPED NONLOCAL }
NONLOCAL = { ESCAPED NONLOCAL }
STOREDANYTHING = { }
INTEGER = { ANYTHING }
head = { NONLOCAL }
elm = { NONLOCAL } same as head
tmp_7 = { ESCAPED NONLOCAL }
winlink_cmp = { }
CALLUSED(12) = { ESCAPED NONLOCAL }
CALLCLOBBERED(13) = { }
tmp_1 = { ESCAPED NONLOCAL }
comp_11 = { ESCAPED NONLOCAL }
tmp_14 = { ESCAPED NONLOCAL }
tmp_13 = { ESCAPED NONLOCAL }
_12 = { ESCAPED NONLOCAL } same as tmp_1
_2 = { NULL ESCAPED NONLOCAL }


Alias information for winlinks_RB_FIND

Aliased symbols


Call clobber information

ESCAPED, points-to non-local, points-to NULL, points-to vars: { }

Flow-insensitive points-to information

tmp_1, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_2, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
head_6(D), points-to non-local, points-to NULL, points-to vars: { }
tmp_7, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
elm_9(D), points-to non-local, points-to NULL, points-to vars: { }
_12, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
tmp_13, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
tmp_14, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }

winlinks_RB_FIND (struct winlinks * head, struct winlink * elm)
{
  int comp;
  struct winlink * tmp;
  struct winlink * _2;
  struct winlink * _12;

  <bb 2> [0.00%]:
  tmp_7 = head_6(D)->rbh_root;
  goto <bb 8>; [0.00%]

  <bb 3> [0.00%]:
  comp_11 = winlink_cmp (elm_9(D), tmp_1);
  if (comp_11 < 0)
    goto <bb 4>; [0.00%]
  else
    goto <bb 5>; [0.00%]

  <bb 4> [0.00%]:
  tmp_14 = tmp_1->entry.rbe_left;
  goto <bb 8>; [0.00%]

  <bb 5> [0.00%]:
  if (comp_11 > 0)
    goto <bb 6>; [0.00%]
  else
    goto <bb 7>; [0.00%]

  <bb 6> [0.00%]:
  tmp_13 = tmp_1->entry.rbe_right;
  goto <bb 8>; [0.00%]

  <bb 7> [0.00%]:
  _12 = tmp_1;
  goto <bb 9>; [0.00%]

  <bb 8> [0.00%]:
  # tmp_1 = PHI <tmp_7(2), tmp_14(4), tmp_13(6)>
  if (tmp_1 != 0B)
    goto <bb 3>; [0.00%]
  else
    goto <bb 9>; [0.00%]

  <bb 9> [0.00%]:
  # _2 = PHI <tmp_1(7), 0B(8)>
  return _2;

}



;; Function winlinks_RB_NFIND (winlinks_RB_NFIND, funcdef_no=56, decl_uid=4357, cgraph_uid=56, symbol_order=59)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
head = &NONLOCAL
elm = &NONLOCAL
tmp_8 = *head
CALLUSED(12) = CALLUSED(12) + UNKNOWN
CALLUSED(12) = *CALLUSED(12) + UNKNOWN
CALLUSED(12) = elm
CALLUSED(12) = tmp_1
comp_13 = CALLUSED(12)
comp_13 = NONLOCAL
tmp_17 = *tmp_1 + 576
tmp_15 = *tmp_1 + 640
_14 = tmp_1
tmp_1 = tmp_8
tmp_1 = tmp_17
tmp_1 = tmp_15
res_2 = &NULL
res_2 = tmp_1
res_2 = res_2
_10 = res_2
_3 = tmp_1
_3 = res_2
ESCAPED = _3

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { NULL ESCAPED NONLOCAL }
NONLOCAL = { ESCAPED NONLOCAL }
STOREDANYTHING = { }
INTEGER = { ANYTHING }
head = { NONLOCAL }
elm = { NONLOCAL } same as head
tmp_8 = { ESCAPED NONLOCAL }
winlink_cmp = { }
CALLUSED(12) = { ESCAPED NONLOCAL }
CALLCLOBBERED(13) = { }
tmp_1 = { ESCAPED NONLOCAL }
comp_13 = { ESCAPED NONLOCAL }
tmp_17 = { ESCAPED NONLOCAL }
tmp_15 = { ESCAPED NONLOCAL }
_14 = { ESCAPED NONLOCAL } same as tmp_1
res_2 = { NULL ESCAPED NONLOCAL }
_10 = { NULL ESCAPED NONLOCAL } same as res_2
_3 = { NULL ESCAPED NONLOCAL } same as res_2


Alias information for winlinks_RB_NFIND

Aliased symbols


Call clobber information

ESCAPED, points-to non-local, points-to NULL, points-to vars: { }

Flow-insensitive points-to information

tmp_1, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
res_2, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_3, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
head_7(D), points-to non-local, points-to NULL, points-to vars: { }
tmp_8, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_10, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
elm_11(D), points-to non-local, points-to NULL, points-to vars: { }
_14, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
tmp_15, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
tmp_17, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }

winlinks_RB_NFIND (struct winlinks * head, struct winlink * elm)
{
  int comp;
  struct winlink * res;
  struct winlink * tmp;
  struct winlink * _3;
  struct winlink * _10;
  struct winlink * _14;

  <bb 2> [0.00%]:
  tmp_8 = head_7(D)->rbh_root;
  goto <bb 8>; [0.00%]

  <bb 3> [0.00%]:
  comp_13 = winlink_cmp (elm_11(D), tmp_1);
  if (comp_13 < 0)
    goto <bb 4>; [0.00%]
  else
    goto <bb 5>; [0.00%]

  <bb 4> [0.00%]:
  tmp_17 = tmp_1->entry.rbe_left;
  goto <bb 8>; [0.00%]

  <bb 5> [0.00%]:
  if (comp_13 > 0)
    goto <bb 6>; [0.00%]
  else
    goto <bb 7>; [0.00%]

  <bb 6> [0.00%]:
  tmp_15 = tmp_1->entry.rbe_right;
  goto <bb 8>; [0.00%]

  <bb 7> [0.00%]:
  _14 = tmp_1;
  goto <bb 10>; [0.00%]

  <bb 8> [0.00%]:
  # tmp_1 = PHI <tmp_8(2), tmp_17(4), tmp_15(6)>
  # res_2 = PHI <0B(2), tmp_1(4), res_2(6)>
  if (tmp_1 != 0B)
    goto <bb 3>; [0.00%]
  else
    goto <bb 9>; [0.00%]

  <bb 9> [0.00%]:
  _10 = res_2;

  <bb 10> [0.00%]:
  # _3 = PHI <tmp_1(7), res_2(9)>
  return _3;

}



;; Function winlinks_RB_NEXT (winlinks_RB_NEXT, funcdef_no=57, decl_uid=4366, cgraph_uid=57, symbol_order=60)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
elm = &NONLOCAL
_1 = *elm + 640
elm_17 = *elm + 640
elm_18 = *elm_9 + 576
elm_9 = elm_17
elm_9 = elm_18
_2 = *elm_9 + 576
_3 = *elm + 704
_4 = *elm + 704
_5 = *_4 + 576
elm_14 = *elm + 704
elm_15 = *elm_10 + 704
elm_20 = elm
elm_20 = elm
elm_10 = elm
elm_10 = elm_15
_6 = *elm_10 + 704
_7 = *elm_10 + 704
_8 = *_7 + 640
elm_16 = *elm_10 + 704
elm_11 = elm_9
elm_11 = elm_14
elm_11 = elm_16
ESCAPED = elm_11

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { ESCAPED NONLOCAL }
NONLOCAL = { ESCAPED NONLOCAL }
STOREDANYTHING = { }
INTEGER = { ANYTHING }
elm = { NONLOCAL }
_1 = { ESCAPED NONLOCAL }
elm_17 = { ESCAPED NONLOCAL }
elm_18 = { ESCAPED NONLOCAL }
elm_9 = { ESCAPED NONLOCAL }
_2 = { ESCAPED NONLOCAL }
_3 = { ESCAPED NONLOCAL }
_4 = { ESCAPED NONLOCAL }
_5 = { ESCAPED NONLOCAL }
elm_14 = { ESCAPED NONLOCAL }
elm_15 = { ESCAPED NONLOCAL }
elm_10 = { ESCAPED NONLOCAL }
elm_20 = { NONLOCAL } same as elm
_6 = { ESCAPED NONLOCAL }
_7 = { ESCAPED NONLOCAL }
_8 = { ESCAPED NONLOCAL }
elm_16 = { ESCAPED NONLOCAL }
elm_11 = { ESCAPED NONLOCAL }


Alias information for winlinks_RB_NEXT

Aliased symbols


Call clobber information

ESCAPED, points-to non-local, points-to vars: { }

Flow-insensitive points-to information

_1, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_2, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_3, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_4, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_5, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_6, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_7, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_8, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
elm_9, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
elm_10, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
elm_11, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
elm_13(D), points-to non-local, points-to NULL, points-to vars: { }
elm_14, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
elm_15, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
elm_16, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
elm_17, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
elm_18, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
elm_20, points-to non-local, points-to NULL, points-to vars: { }

winlinks_RB_NEXT (struct winlink * elm)
{
  struct winlink * _1;
  struct winlink * _2;
  struct winlink * _3;
  struct winlink * _4;
  struct winlink * _5;
  struct winlink * _6;
  struct winlink * _7;
  struct winlink * _8;

  <bb 2> [0.00%]:
  _1 = elm_13(D)->entry.rbe_right;
  if (_1 != 0B)
    goto <bb 3>; [0.00%]
  else
    goto <bb 6>; [0.00%]

  <bb 3> [0.00%]:
  elm_17 = elm_13(D)->entry.rbe_right;
  goto <bb 5>; [0.00%]

  <bb 4> [0.00%]:
  elm_18 = elm_9->entry.rbe_left;

  <bb 5> [0.00%]:
  # elm_9 = PHI <elm_17(3), elm_18(4)>
  _2 = elm_9->entry.rbe_left;
  if (_2 != 0B)
    goto <bb 4>; [0.00%]
  else
    goto <bb 14>; [0.00%]

  <bb 6> [0.00%]:
  _3 = elm_13(D)->entry.rbe_parent;
  if (_3 != 0B)
    goto <bb 7>; [0.00%]
  else
    goto <bb 10>; [0.00%]

  <bb 7> [0.00%]:
  _4 = elm_13(D)->entry.rbe_parent;
  _5 = _4->entry.rbe_left;
  if (_5 == elm_13(D))
    goto <bb 8>; [0.00%]
  else
    goto <bb 10>; [0.00%]

  <bb 8> [0.00%]:
  elm_14 = elm_13(D)->entry.rbe_parent;
  goto <bb 14>; [0.00%]

  <bb 9> [0.00%]:
  elm_15 = elm_10->entry.rbe_parent;
  goto <bb 11>; [0.00%]

  <bb 10> [0.00%]:
  # elm_20 = PHI <elm_13(D)(7), elm_13(D)(6)>

  <bb 11> [0.00%]:
  # elm_10 = PHI <elm_13(D)(10), elm_15(9)>
  _6 = elm_10->entry.rbe_parent;
  if (_6 != 0B)
    goto <bb 12>; [0.00%]
  else
    goto <bb 13>; [0.00%]

  <bb 12> [0.00%]:
  _7 = elm_10->entry.rbe_parent;
  _8 = _7->entry.rbe_right;
  if (_8 == elm_10)
    goto <bb 9>; [0.00%]
  else
    goto <bb 13>; [0.00%]

  <bb 13> [0.00%]:
  elm_16 = elm_10->entry.rbe_parent;

  <bb 14> [0.00%]:
  # elm_11 = PHI <elm_9(5), elm_14(8), elm_16(13)>
  return elm_11;

}



;; Function winlinks_RB_PREV (winlinks_RB_PREV, funcdef_no=58, decl_uid=4375, cgraph_uid=58, symbol_order=61)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
elm = &NONLOCAL
_1 = *elm + 576
elm_17 = *elm + 576
elm_18 = *elm_9 + 640
elm_9 = elm_17
elm_9 = elm_18
_2 = *elm_9 + 640
_3 = *elm + 704
_4 = *elm + 704
_5 = *_4 + 640
elm_14 = *elm + 704
elm_15 = *elm_10 + 704
elm_20 = elm
elm_20 = elm
elm_10 = elm
elm_10 = elm_15
_6 = *elm_10 + 704
_7 = *elm_10 + 704
_8 = *_7 + 576
elm_16 = *elm_10 + 704
elm_11 = elm_9
elm_11 = elm_14
elm_11 = elm_16
ESCAPED = elm_11

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { ESCAPED NONLOCAL }
NONLOCAL = { ESCAPED NONLOCAL }
STOREDANYTHING = { }
INTEGER = { ANYTHING }
elm = { NONLOCAL }
_1 = { ESCAPED NONLOCAL }
elm_17 = { ESCAPED NONLOCAL }
elm_18 = { ESCAPED NONLOCAL }
elm_9 = { ESCAPED NONLOCAL }
_2 = { ESCAPED NONLOCAL }
_3 = { ESCAPED NONLOCAL }
_4 = { ESCAPED NONLOCAL }
_5 = { ESCAPED NONLOCAL }
elm_14 = { ESCAPED NONLOCAL }
elm_15 = { ESCAPED NONLOCAL }
elm_10 = { ESCAPED NONLOCAL }
elm_20 = { NONLOCAL } same as elm
_6 = { ESCAPED NONLOCAL }
_7 = { ESCAPED NONLOCAL }
_8 = { ESCAPED NONLOCAL }
elm_16 = { ESCAPED NONLOCAL }
elm_11 = { ESCAPED NONLOCAL }


Alias information for winlinks_RB_PREV

Aliased symbols


Call clobber information

ESCAPED, points-to non-local, points-to vars: { }

Flow-insensitive points-to information

_1, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_2, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_3, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_4, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_5, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_6, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_7, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_8, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
elm_9, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
elm_10, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
elm_11, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
elm_13(D), points-to non-local, points-to NULL, points-to vars: { }
elm_14, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
elm_15, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
elm_16, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
elm_17, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
elm_18, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
elm_20, points-to non-local, points-to NULL, points-to vars: { }

winlinks_RB_PREV (struct winlink * elm)
{
  struct winlink * _1;
  struct winlink * _2;
  struct winlink * _3;
  struct winlink * _4;
  struct winlink * _5;
  struct winlink * _6;
  struct winlink * _7;
  struct winlink * _8;

  <bb 2> [0.00%]:
  _1 = elm_13(D)->entry.rbe_left;
  if (_1 != 0B)
    goto <bb 3>; [0.00%]
  else
    goto <bb 6>; [0.00%]

  <bb 3> [0.00%]:
  elm_17 = elm_13(D)->entry.rbe_left;
  goto <bb 5>; [0.00%]

  <bb 4> [0.00%]:
  elm_18 = elm_9->entry.rbe_right;

  <bb 5> [0.00%]:
  # elm_9 = PHI <elm_17(3), elm_18(4)>
  _2 = elm_9->entry.rbe_right;
  if (_2 != 0B)
    goto <bb 4>; [0.00%]
  else
    goto <bb 14>; [0.00%]

  <bb 6> [0.00%]:
  _3 = elm_13(D)->entry.rbe_parent;
  if (_3 != 0B)
    goto <bb 7>; [0.00%]
  else
    goto <bb 10>; [0.00%]

  <bb 7> [0.00%]:
  _4 = elm_13(D)->entry.rbe_parent;
  _5 = _4->entry.rbe_right;
  if (_5 == elm_13(D))
    goto <bb 8>; [0.00%]
  else
    goto <bb 10>; [0.00%]

  <bb 8> [0.00%]:
  elm_14 = elm_13(D)->entry.rbe_parent;
  goto <bb 14>; [0.00%]

  <bb 9> [0.00%]:
  elm_15 = elm_10->entry.rbe_parent;
  goto <bb 11>; [0.00%]

  <bb 10> [0.00%]:
  # elm_20 = PHI <elm_13(D)(7), elm_13(D)(6)>

  <bb 11> [0.00%]:
  # elm_10 = PHI <elm_13(D)(10), elm_15(9)>
  _6 = elm_10->entry.rbe_parent;
  if (_6 != 0B)
    goto <bb 12>; [0.00%]
  else
    goto <bb 13>; [0.00%]

  <bb 12> [0.00%]:
  _7 = elm_10->entry.rbe_parent;
  _8 = _7->entry.rbe_left;
  if (_8 == elm_10)
    goto <bb 9>; [0.00%]
  else
    goto <bb 13>; [0.00%]

  <bb 13> [0.00%]:
  elm_16 = elm_10->entry.rbe_parent;

  <bb 14> [0.00%]:
  # elm_11 = PHI <elm_9(5), elm_14(8), elm_16(13)>
  return elm_11;

}



;; Function winlinks_RB_MINMAX (winlinks_RB_MINMAX, funcdef_no=59, decl_uid=4385, cgraph_uid=59, symbol_order=62)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
head = &NONLOCAL
val = &NONLOCAL
tmp_5 = *head
parent_8 = tmp_1
tmp_11 = *tmp_1 + 576
tmp_10 = *tmp_1 + 640
tmp_1 = tmp_5
tmp_1 = tmp_11
tmp_1 = tmp_10
parent_2 = &NULL
parent_2 = parent_8
parent_2 = parent_8
_7 = parent_2
ESCAPED = parent_2

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { NULL ESCAPED NONLOCAL }
NONLOCAL = { ESCAPED NONLOCAL }
STOREDANYTHING = { }
INTEGER = { ANYTHING }
head = { NONLOCAL }
val = { NONLOCAL } same as head
tmp_5 = { ESCAPED NONLOCAL }
parent_8 = { ESCAPED NONLOCAL }
tmp_1 = { ESCAPED NONLOCAL } same as parent_8
tmp_11 = { ESCAPED NONLOCAL }
tmp_10 = { ESCAPED NONLOCAL }
parent_2 = { NULL ESCAPED NONLOCAL }
_7 = { NULL ESCAPED NONLOCAL } same as parent_2


Alias information for winlinks_RB_MINMAX

Aliased symbols


Call clobber information

ESCAPED, points-to non-local, points-to NULL, points-to vars: { }

Flow-insensitive points-to information

tmp_1, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
parent_2, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
head_4(D), points-to non-local, points-to NULL, points-to vars: { }
tmp_5, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_7, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
parent_8, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
tmp_10, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
tmp_11, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }

winlinks_RB_MINMAX (struct winlinks * head, int val)
{
  struct winlink * parent;
  struct winlink * tmp;
  struct winlink * _7;

  <bb 2> [0.00%]:
  tmp_5 = head_4(D)->rbh_root;
  goto <bb 6>; [0.00%]

  <bb 3> [0.00%]:
  parent_8 = tmp_1;
  if (val_9(D) < 0)
    goto <bb 4>; [0.00%]
  else
    goto <bb 5>; [0.00%]

  <bb 4> [0.00%]:
  tmp_11 = tmp_1->entry.rbe_left;
  goto <bb 6>; [0.00%]

  <bb 5> [0.00%]:
  tmp_10 = tmp_1->entry.rbe_right;

  <bb 6> [0.00%]:
  # tmp_1 = PHI <tmp_5(2), tmp_11(4), tmp_10(5)>
  # parent_2 = PHI <0B(2), parent_8(4), parent_8(5)>
  if (tmp_1 != 0B)
    goto <bb 3>; [0.00%]
  else
    goto <bb 7>; [0.00%]

  <bb 7> [0.00%]:
  _7 = parent_2;
  return parent_2;

}



;; Function xrealloc (xrealloc, funcdef_no=60, decl_uid=4395, cgraph_uid=60, symbol_order=63)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
oldptr = &NONLOCAL
nmemb = &NONLOCAL
size = &NONLOCAL
newsize_4 = nmemb
newsize_4 = size
ESCAPED = &NONLOCAL
ESCAPED = &STRING
ESCAPED = &STRING
_16 = NONLOCAL
ESCAPED = &NONLOCAL
_1 = &NONLOCAL
_1 = nmemb
ESCAPED = &NONLOCAL
ESCAPED = &STRING
ESCAPED = &STRING
_17 = NONLOCAL
ESCAPED = &NONLOCAL
newptr_8 = &HEAP(18)
doubledereftmp(19) = *oldptr
*newptr_8 = doubledereftmp(19)
newptr_8 = oldptr
ESCAPED = &NONLOCAL
ESCAPED = &STRING
ESCAPED = &STRING
_18 = NONLOCAL
ESCAPED = &NONLOCAL
_9 = newptr_8
ESCAPED = newptr_8

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { STRING ESCAPED NONLOCAL HEAP(18) }
NONLOCAL = { ESCAPED NONLOCAL } same as _16
STOREDANYTHING = { }
INTEGER = { ANYTHING }
oldptr = { NONLOCAL }
nmemb = { NONLOCAL } same as oldptr
size = { NONLOCAL } same as oldptr
newsize_4 = { NONLOCAL } same as oldptr
__printf_chk = { }
_16 = { ESCAPED NONLOCAL }
exit = { }
_1 = { NONLOCAL } same as oldptr
_17 = { ESCAPED NONLOCAL } same as _16
newptr_8 = { NONLOCAL HEAP(18) }
HEAP(18) = { ESCAPED NONLOCAL }
doubledereftmp(19) = { ESCAPED NONLOCAL }
_18 = { ESCAPED NONLOCAL } same as _16
_9 = { NONLOCAL HEAP(18) } same as newptr_8


Alias information for xrealloc

Aliased symbols


Call clobber information

ESCAPED, points-to non-local, points-to vars: { D.5186 } (escaped, escaped heap)

Flow-insensitive points-to information

oldptr_6(D), points-to non-local, points-to NULL, points-to vars: { }
newptr_8, points-to non-local, points-to NULL, points-to vars: { D.5186 } (escaped, escaped heap)
_9, points-to non-local, points-to NULL, points-to vars: { D.5186 } (escaped, escaped heap)

xrealloc (void * oldptr, size_t nmemb, size_t size)
{
  int D.5185;
  int D.5183;
  int D.5181;
  void * newptr;
  size_t newsize;
  long unsigned int _1;
  void * _9;
  int _16;
  int _17;
  int _18;

  <bb 2> [0.00%]:
  newsize_4 = nmemb_2(D) * size_3(D);
  if (newsize_4 == 0)
    goto <bb 3>; [0.00%]
  else
    goto <bb 4>; [0.00%]

  <bb 3> [100.00%]:
  _16 = __printf_chk (1, "zero size%s", "");
  exit (1);

  <bb 4> [0.00%]:
  _1 = 1073741824 / nmemb_2(D);
  if (_1 < size_3(D))
    goto <bb 5>; [0.00%]
  else
    goto <bb 6>; [0.00%]

  <bb 5> [100.00%]:
  _17 = __printf_chk (1, "nmemb * size > SIZE_MAX%s", "");
  exit (1);

  <bb 6> [0.00%]:
  newptr_8 = realloc (oldptr_6(D), newsize_4);
  if (newptr_8 == 0B)
    goto <bb 7>; [0.00%]
  else
    goto <bb 8>; [0.00%]

  <bb 7> [100.00%]:
  _18 = __printf_chk (1, "xrealloc failed%s", "");
  exit (1);

  <bb 8> [0.00%]:
  _9 = newptr_8;
  return newptr_8;

}



;; Function winlink_find_by_index (winlink_find_by_index, funcdef_no=61, decl_uid=4401, cgraph_uid=61, symbol_order=64)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
wwl = &NONLOCAL
idx = &NONLOCAL
ESCAPED = &NONLOCAL
ESCAPED = &STRING
ESCAPED = &STRING
_5 = NONLOCAL
ESCAPED = &NONLOCAL
wl = idx
CALLUSED(15) = CALLUSED(15) + UNKNOWN
CALLUSED(15) = *CALLUSED(15) + UNKNOWN
CALLUSED(15) = wwl
CALLUSED(15) = &wl
_6 = CALLUSED(15)
_6 = NONLOCAL
ESCAPED = _6

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { STRING ESCAPED NONLOCAL wl }
NONLOCAL = { ESCAPED NONLOCAL } same as _5
STOREDANYTHING = { }
INTEGER = { ANYTHING }
wwl = { NONLOCAL }
idx = { NONLOCAL } same as wwl
__printf_chk = { }
_5 = { ESCAPED NONLOCAL }
exit = { }
wl = { ESCAPED NONLOCAL }
winlinks_RB_FIND = { }
CALLUSED(15) = { ESCAPED NONLOCAL wl }
CALLCLOBBERED(16) = { }
_6 = { ESCAPED NONLOCAL wl }


Alias information for winlink_find_by_index

Aliased symbols

wl, UID D.4403, struct winlink, is addressable

Call clobber information

ESCAPED, points-to non-local, points-to vars: { D.4403 } (escaped)

Flow-insensitive points-to information

wwl_4(D), points-to non-local, points-to NULL, points-to vars: { }
_6, points-to non-local, points-to escaped, points-to NULL, points-to vars: { D.4403 } (escaped)

winlink_find_by_index (struct winlinks * wwl, int idx)
{
  int D.5188;
  struct winlink wl;
  int _5;
  struct winlink * _6;

  <bb 2> [0.00%]:
  if (idx_1(D) < 0)
    goto <bb 3>; [0.00%]
  else
    goto <bb 4>; [0.00%]

  <bb 3> [100.00%]:
  _5 = __printf_chk (1, "bad index%s", "");
  exit (1);

  <bb 4> [0.00%]:
  wl.idx = idx_1(D);
  _6 = winlinks_RB_FIND (wwl_4(D), &wl);
  wl ={v} {CLOBBER};
  return _6;

}



;; Function winlink_count (winlink_count, funcdef_no=62, decl_uid=4405, cgraph_uid=62, symbol_order=65)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
wwl = &NONLOCAL
CALLUSED(10) = CALLUSED(10) + UNKNOWN
CALLUSED(10) = *CALLUSED(10) + UNKNOWN
CALLUSED(10) = wwl
CALLUSED(10) = &NONLOCAL
wl_8 = CALLUSED(10)
wl_8 = NONLOCAL
n_10 = n_2
n_10 = &NONLOCAL
CALLUSED(16) = CALLUSED(16) + UNKNOWN
CALLUSED(16) = *CALLUSED(16) + UNKNOWN
CALLUSED(16) = wl_1
wl_12 = CALLUSED(16)
wl_12 = NONLOCAL
wl_1 = wl_8
wl_1 = wl_12
n_2 = &NULL
n_2 = n_10
_9 = n_2
ESCAPED = n_2

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { NULL ESCAPED NONLOCAL }
NONLOCAL = { ESCAPED NONLOCAL }
STOREDANYTHING = { }
INTEGER = { ANYTHING }
wwl = { NONLOCAL }
winlinks_RB_MINMAX = { }
CALLUSED(10) = { ESCAPED NONLOCAL }
CALLCLOBBERED(11) = { }
wl_8 = { ESCAPED NONLOCAL }
n_10 = { NULL NONLOCAL }
n_2 = { NULL NONLOCAL } same as n_10
winlinks_RB_NEXT = { }
CALLUSED(16) = { ESCAPED NONLOCAL }
CALLCLOBBERED(17) = { }
wl_1 = { ESCAPED NONLOCAL } same as CALLUSED(16)
wl_12 = { ESCAPED NONLOCAL } same as CALLUSED(16)
_9 = { NULL NONLOCAL } same as n_10


Alias information for winlink_count

Aliased symbols


Call clobber information

ESCAPED, points-to non-local, points-to NULL, points-to vars: { }

Flow-insensitive points-to information

wl_1, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
wwl_6(D), points-to non-local, points-to NULL, points-to vars: { }
wl_8, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
wl_12, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }

winlink_count (struct winlinks * wwl)
{
  u_int n;
  struct winlink * wl;
  u_int _9;

  <bb 2> [0.00%]:
  wl_8 = winlinks_RB_MINMAX (wwl_6(D), -1);
  goto <bb 4>; [0.00%]

  <bb 3> [0.00%]:
  n_10 = n_2 + 1;
  wl_12 = winlinks_RB_NEXT (wl_1);

  <bb 4> [0.00%]:
  # wl_1 = PHI <wl_8(2), wl_12(3)>
  # n_2 = PHI <0(2), n_10(3)>
  if (wl_1 != 0B)
    goto <bb 3>; [0.00%]
  else
    goto <bb 5>; [0.00%]

  <bb 5> [0.00%]:
  _9 = n_2;
  return n_2;

}



;; Function winlink_next_index (winlink_next_index, funcdef_no=63, decl_uid=4414, cgraph_uid=63, symbol_order=66)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
wwl = &NONLOCAL
idx = &NONLOCAL
i_2 = idx
i_2 = i_3
ESCAPED = wwl
ESCAPED = i_2
_1 = NONLOCAL
i_11 = i_2
i_11 = &NONLOCAL
i_3 = &NULL
i_3 = i_11
_4 = i_2
_4 = &NONLOCAL
ESCAPED = _4

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { NULL ESCAPED NONLOCAL }
NONLOCAL = { ESCAPED NONLOCAL } same as _1
STOREDANYTHING = { }
INTEGER = { ANYTHING }
wwl = { NONLOCAL }
idx = { NONLOCAL } same as wwl
i_2 = { NULL NONLOCAL }
i_3 = { NULL NONLOCAL } same as i_2
winlink_find_by_index = { }
_1 = { ESCAPED NONLOCAL }
i_11 = { NULL NONLOCAL } same as i_2
_4 = { NULL NONLOCAL } same as i_2


Alias information for winlink_next_index

Aliased symbols


Call clobber information

ESCAPED, points-to non-local, points-to NULL, points-to vars: { }

Flow-insensitive points-to information

_1, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
wwl_9(D), points-to non-local, points-to NULL, points-to vars: { }

winlink_next_index (struct winlinks * wwl, int idx)
{
  int i;
  struct winlink * _1;
  int _4;

  <bb 2> [0.00%]:

  <bb 3> [0.00%]:
  # i_2 = PHI <idx_6(D)(2), i_3(6)>
  _1 = winlink_find_by_index (wwl_9(D), i_2);
  if (_1 == 0B)
    goto <bb 7>; [0.00%]
  else
    goto <bb 4>; [0.00%]

  <bb 4> [0.00%]:
  if (i_2 == 10000)
    goto <bb 6>; [0.00%]
  else
    goto <bb 5>; [0.00%]

  <bb 5> [0.00%]:
  i_11 = i_2 + 1;

  <bb 6> [0.00%]:
  # i_3 = PHI <0(4), i_11(5)>
  if (i_3 != idx_6(D))
    goto <bb 3>; [0.00%]
  else
    goto <bb 7>; [0.00%]

  <bb 7> [0.00%]:
  # _4 = PHI <i_2(3), -1(6)>
  return _4;

}



;; Function winlink_find_by_window (winlink_find_by_window, funcdef_no=64, decl_uid=4421, cgraph_uid=64, symbol_order=67)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
wwl = &NONLOCAL
w = &NONLOCAL
CALLUSED(11) = CALLUSED(11) + UNKNOWN
CALLUSED(11) = *CALLUSED(11) + UNKNOWN
CALLUSED(11) = wwl
CALLUSED(11) = &NONLOCAL
wl_8 = CALLUSED(11)
wl_8 = NONLOCAL
_1 = *wl_2 + 128
CALLUSED(17) = CALLUSED(17) + UNKNOWN
CALLUSED(17) = *CALLUSED(17) + UNKNOWN
CALLUSED(17) = wl_2
wl_12 = CALLUSED(17)
wl_12 = NONLOCAL
wl_2 = wl_8
wl_2 = wl_12
_3 = wl_2
_3 = &NULL
ESCAPED = _3

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { NULL ESCAPED NONLOCAL }
NONLOCAL = { ESCAPED NONLOCAL }
STOREDANYTHING = { }
INTEGER = { ANYTHING }
wwl = { NONLOCAL }
w = { NONLOCAL } same as wwl
winlinks_RB_MINMAX = { }
CALLUSED(11) = { ESCAPED NONLOCAL }
CALLCLOBBERED(12) = { }
wl_8 = { ESCAPED NONLOCAL }
_1 = { ESCAPED NONLOCAL }
wl_2 = { ESCAPED NONLOCAL }
winlinks_RB_NEXT = { }
CALLUSED(17) = { ESCAPED NONLOCAL } same as wl_2
CALLCLOBBERED(18) = { }
wl_12 = { ESCAPED NONLOCAL } same as wl_2
_3 = { NULL ESCAPED NONLOCAL }


Alias information for winlink_find_by_window

Aliased symbols


Call clobber information

ESCAPED, points-to non-local, points-to NULL, points-to vars: { }

Flow-insensitive points-to information

_1, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
wl_2, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_3, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
wwl_6(D), points-to non-local, points-to NULL, points-to vars: { }
wl_8, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
w_10(D), points-to non-local, points-to NULL, points-to vars: { }
wl_12, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }

winlink_find_by_window (struct winlinks * wwl, struct window * w)
{
  struct winlink * wl;
  struct window * _1;
  struct winlink * _3;

  <bb 2> [0.00%]:
  wl_8 = winlinks_RB_MINMAX (wwl_6(D), -1);
  goto <bb 5>; [0.00%]

  <bb 3> [0.00%]:
  _1 = wl_2->window;
  if (_1 == w_10(D))
    goto <bb 6>; [0.00%]
  else
    goto <bb 4>; [0.00%]

  <bb 4> [0.00%]:
  wl_12 = winlinks_RB_NEXT (wl_2);

  <bb 5> [0.00%]:
  # wl_2 = PHI <wl_8(2), wl_12(4)>
  if (wl_2 != 0B)
    goto <bb 3>; [0.00%]
  else
    goto <bb 6>; [0.00%]

  <bb 6> [0.00%]:
  # _3 = PHI <wl_2(3), 0B(5)>
  return _3;

}



;; Function cmd_find_pane (cmd_find_pane, funcdef_no=65, decl_uid=4429, cgraph_uid=65, symbol_order=68)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
arg = &NONLOCAL
sp = &NONLOCAL
sessions = NONLOCAL
_1 = sessions
ESCAPED = &NONLOCAL
ESCAPED = &STRING
_12 = NONLOCAL
_2 = sessions
s_8 = *_2
*sp = s_8
_14 = *s_8 + 128
_3 = *s_8 + 128
CALLUSED(19) = CALLUSED(19) + UNKNOWN
CALLUSED(19) = *CALLUSED(19) + UNKNOWN
CALLUSED(19) = _3
_13 = CALLUSED(19)
_13 = NONLOCAL
_4 = &NULL
_4 = _14
_4 = _13
ESCAPED = _4

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { NULL STRING ESCAPED NONLOCAL }
NONLOCAL = { ESCAPED NONLOCAL } same as sessions
STOREDANYTHING = { }
INTEGER = { ANYTHING }
arg = { NONLOCAL }
sp = { NONLOCAL } same as arg
_1 = { ESCAPED NONLOCAL } same as sessions
sessions = { ESCAPED NONLOCAL }
__printf_chk = { }
_12 = { ESCAPED NONLOCAL } same as sessions
_2 = { ESCAPED NONLOCAL } same as sessions
s_8 = { ESCAPED NONLOCAL }
_14 = { ESCAPED NONLOCAL }
_3 = { ESCAPED NONLOCAL }
winlinks_RB_NEXT = { }
CALLUSED(19) = { ESCAPED NONLOCAL }
CALLCLOBBERED(20) = { }
_13 = { ESCAPED NONLOCAL }
_4 = { NULL ESCAPED NONLOCAL }


Alias information for cmd_find_pane

Aliased symbols


Call clobber information

ESCAPED, points-to non-local, points-to NULL, points-to vars: { }

Flow-insensitive points-to information

_2, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_3, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_4, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
s_8, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
sp_9(D), points-to non-local, points-to NULL, points-to vars: { }
_13, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_14, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }

cmd_find_pane (int arg, struct session * * sp)
{
  int D.5190;
  struct session * s;
  unsigned int _1;
  struct session * * _2;
  struct winlink * _3;
  struct winlink * _4;
  int _12;
  struct winlink * _13;
  struct winlink * _14;

  <bb 2> [0.00%]:
  _1 = sessions.num;
  if (_1 == 0)
    goto <bb 3>; [0.00%]
  else
    goto <bb 4>; [0.00%]

  <bb 3> [100.00%]:
  _12 = __printf_chk (1, "can\'t establish current session\n");
  goto <bb 9>; [0.00%]

  <bb 4> [0.00%]:
  _2 = sessions.list;
  s_8 = MEM[(struct session * *)_2 + 8B];
  if (sp_9(D) != 0B)
    goto <bb 5>; [0.00%]
  else
    goto <bb 6>; [0.00%]

  <bb 5> [0.00%]:
  *sp_9(D) = s_8;

  <bb 6> [0.00%]:
  if (arg_11(D) != 0)
    goto <bb 7>; [0.00%]
  else
    goto <bb 8>; [0.00%]

  <bb 7> [0.00%]:
  _14 = s_8->curw;
  goto <bb 9>; [0.00%]

  <bb 8> [0.00%]:
  _3 = s_8->curw;
  _13 = winlinks_RB_NEXT (_3);

  <bb 9> [0.00%]:
  # _4 = PHI <0B(3), _14(7), _13(8)>
  return _4;

}



;; Function session_has (session_has, funcdef_no=66, decl_uid=4436, cgraph_uid=66, symbol_order=69)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
s = &NONLOCAL
w = &NONLOCAL
_1 = s + UNKNOWN
CALLUSED(12) = CALLUSED(12) + UNKNOWN
CALLUSED(12) = *CALLUSED(12) + UNKNOWN
CALLUSED(12) = _1
CALLUSED(12) = &NONLOCAL
wl_9 = CALLUSED(12)
wl_9 = NONLOCAL
_2 = *wl_3 + 128
CALLUSED(18) = CALLUSED(18) + UNKNOWN
CALLUSED(18) = *CALLUSED(18) + UNKNOWN
CALLUSED(18) = wl_3
wl_13 = CALLUSED(18)
wl_13 = NONLOCAL
wl_3 = wl_9
wl_3 = wl_13
_4 = &NONLOCAL
_4 = &NULL
ESCAPED = _4

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { NULL ESCAPED NONLOCAL }
NONLOCAL = { ESCAPED NONLOCAL }
STOREDANYTHING = { }
INTEGER = { ANYTHING }
s = { NONLOCAL }
w = { NONLOCAL } same as s
_1 = { NONLOCAL }
winlinks_RB_MINMAX = { }
CALLUSED(12) = { ESCAPED NONLOCAL }
CALLCLOBBERED(13) = { }
wl_9 = { ESCAPED NONLOCAL }
_2 = { ESCAPED NONLOCAL }
wl_3 = { ESCAPED NONLOCAL }
winlinks_RB_NEXT = { }
CALLUSED(18) = { ESCAPED NONLOCAL } same as wl_3
CALLCLOBBERED(19) = { }
wl_13 = { ESCAPED NONLOCAL } same as wl_3
_4 = { NULL NONLOCAL }


Alias information for session_has

Aliased symbols


Call clobber information

ESCAPED, points-to non-local, points-to NULL, points-to vars: { }

Flow-insensitive points-to information

_1, points-to non-local, points-to NULL, points-to vars: { }
_2, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
wl_3, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
s_6(D), points-to non-local, points-to NULL, points-to vars: { }
wl_9, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
w_11(D), points-to non-local, points-to NULL, points-to vars: { }
wl_13, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }

session_has (struct session * s, struct window * w)
{
  struct winlink * wl;
  struct winlinks * _1;
  struct window * _2;
  int _4;

  <bb 2> [0.00%]:
  _1 = &s_6(D)->windows;
  wl_9 = winlinks_RB_MINMAX (_1, -1);
  goto <bb 5>; [0.00%]

  <bb 3> [0.00%]:
  _2 = wl_3->window;
  if (_2 == w_11(D))
    goto <bb 6>; [0.00%]
  else
    goto <bb 4>; [0.00%]

  <bb 4> [0.00%]:
  wl_13 = winlinks_RB_NEXT (wl_3);

  <bb 5> [0.00%]:
  # wl_3 = PHI <wl_9(2), wl_13(4)>
  if (wl_3 != 0B)
    goto <bb 3>; [0.00%]
  else
    goto <bb 6>; [0.00%]

  <bb 6> [0.00%]:
  # _4 = PHI <1(3), 0(5)>
  return _4;

}



;; Function session_group_find (session_group_find, funcdef_no=67, decl_uid=4443, cgraph_uid=67, symbol_order=70)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
target = &NONLOCAL
session_groups = NONLOCAL
sg_5 = session_groups
s_7 = *sg_1
s_10 = *s_2 + 768
s_2 = s_7
s_2 = s_10
sg_8 = *sg_1 + 128
sg_1 = sg_5
sg_1 = sg_8
_3 = sg_1
_3 = &NULL
ESCAPED = _3

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { NULL ESCAPED NONLOCAL } same as s_7
NONLOCAL = { ESCAPED NONLOCAL } same as session_groups
STOREDANYTHING = { }
INTEGER = { ANYTHING }
target = { NONLOCAL }
sg_5 = { ESCAPED NONLOCAL } same as session_groups
session_groups = { ESCAPED NONLOCAL }
s_7 = { NULL ESCAPED NONLOCAL }
sg_1 = { ESCAPED NONLOCAL }
s_10 = { ESCAPED }
s_2 = { ESCAPED }
sg_8 = { ESCAPED NONLOCAL }
_3 = { NULL ESCAPED NONLOCAL }


Alias information for session_group_find

Aliased symbols


Call clobber information

ESCAPED, points-to non-local, points-to NULL, points-to vars: { }

Flow-insensitive points-to information

sg_1, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
s_2, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_3, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
sg_5, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
s_7, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
sg_8, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
target_9(D), points-to non-local, points-to NULL, points-to vars: { }
s_10, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }

session_group_find (struct session * target)
{
  struct session * s;
  struct session_group * sg;
  struct session_group * _3;

  <bb 2> [0.00%]:
  sg_5 = session_groups.tqh_first;
  goto <bb 8>; [0.00%]

  <bb 3> [0.00%]:
  s_7 = sg_1->sessions.tqh_first;
  goto <bb 6>; [0.00%]

  <bb 4> [0.00%]:
  if (s_2 == target_9(D))
    goto <bb 9>; [0.00%]
  else
    goto <bb 5>; [0.00%]

  <bb 5> [0.00%]:
  s_10 = s_2->gentry.tqe_next;

  <bb 6> [0.00%]:
  # s_2 = PHI <s_7(3), s_10(5)>
  if (s_2 != 0B)
    goto <bb 4>; [0.00%]
  else
    goto <bb 7>; [0.00%]

  <bb 7> [0.00%]:
  sg_8 = sg_1->entry.tqe_next;

  <bb 8> [0.00%]:
  # sg_1 = PHI <sg_5(2), sg_8(7)>
  if (sg_1 != 0B)
    goto <bb 3>; [0.00%]
  else
    goto <bb 9>; [0.00%]

  <bb 9> [0.00%]:
  # _3 = PHI <sg_1(4), 0B(8)>
  return _3;

}



;; Function session_group_add (session_group_add, funcdef_no=68, decl_uid=4455, cgraph_uid=68, symbol_order=71)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
target = &NONLOCAL
s = &NONLOCAL
CALLUSED(11) = CALLUSED(11) + UNKNOWN
CALLUSED(11) = *CALLUSED(11) + UNKNOWN
CALLUSED(11) = target
sg_16 = CALLUSED(11)
sg_16 = NONLOCAL
ESCAPED = &NONLOCAL
sg_18 = &HEAP(16)
derefaddrtmp(17) = &NULL
*sg_18 + 128 = derefaddrtmp(17)
session_groups = NONLOCAL
_1 = session_groups
*sg_18 + 192 = _1
_2 = session_groups
*_2 = sg_18
_3 = sg_18 + 128
session_groups = _3
ESCAPED = _3
derefaddrtmp(22) = &NULL
*sg_18 = derefaddrtmp(22)
_4 = sg_18
*sg_18 + 64 = _4
derefaddrtmp(24) = &NULL
*target + 768 = derefaddrtmp(24)
_5 = *sg_18 + 64
*target + 832 = _5
_6 = *sg_18 + 64
*_6 = target
_7 = target + 768
*sg_18 + 64 = _7
sg_11 = sg_16
sg_11 = sg_18
derefaddrtmp(29) = &NULL
*s + 768 = derefaddrtmp(29)
_8 = *sg_11 + 64
*s + 832 = _8
_9 = *sg_11 + 64
*_9 = s
_10 = s + 768
*sg_11 + 64 = _10

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { NULL ESCAPED NONLOCAL HEAP(16) }
NONLOCAL = { ESCAPED NONLOCAL }
STOREDANYTHING = { }
INTEGER = { ANYTHING }
target = { NONLOCAL }
s = { NONLOCAL } same as target
session_group_find = { }
CALLUSED(11) = { ESCAPED NONLOCAL }
CALLCLOBBERED(12) = { }
sg_16 = { ESCAPED NONLOCAL }
malloc = { }
sg_18 = { HEAP(16) }
HEAP(16) = { NULL ESCAPED NONLOCAL HEAP(16) }
derefaddrtmp(17) = { NULL }
_1 = { ESCAPED NONLOCAL HEAP(16) } same as session_groups
session_groups = { ESCAPED NONLOCAL HEAP(16) }
_2 = { ESCAPED NONLOCAL HEAP(16) } same as session_groups
_3 = { HEAP(16) }
derefaddrtmp(22) = { NULL } same as derefaddrtmp(17)
_4 = { HEAP(16) } same as sg_18
derefaddrtmp(24) = { NULL } same as derefaddrtmp(17)
_5 = { NULL ESCAPED NONLOCAL HEAP(16) }
_6 = { NULL ESCAPED NONLOCAL HEAP(16) }
_7 = { NONLOCAL }
sg_11 = { ESCAPED NONLOCAL HEAP(16) }
derefaddrtmp(29) = { NULL } same as derefaddrtmp(17)
_8 = { NULL ESCAPED NONLOCAL HEAP(16) }
_9 = { NULL ESCAPED NONLOCAL HEAP(16) }
_10 = { NONLOCAL }


Alias information for session_group_add

Aliased symbols


Call clobber information

ESCAPED, points-to non-local, points-to NULL, points-to vars: { D.5191 } (escaped, escaped heap)

Flow-insensitive points-to information

_1, points-to non-local, points-to escaped, points-to NULL, points-to vars: { D.5191 } (escaped, escaped heap)
_2, points-to non-local, points-to escaped, points-to NULL, points-to vars: { D.5191 } (escaped, escaped heap)
_3, points-to NULL, points-to vars: { D.5191 } (escaped, escaped heap)
_4, points-to NULL, points-to vars: { D.5191 } (escaped, escaped heap)
_5, points-to non-local, points-to escaped, points-to NULL, points-to vars: { D.5191 } (escaped, escaped heap)
_6, points-to non-local, points-to escaped, points-to NULL, points-to vars: { D.5191 } (escaped, escaped heap)
_7, points-to non-local, points-to NULL, points-to vars: { }
_8, points-to non-local, points-to escaped, points-to NULL, points-to vars: { D.5191 } (escaped, escaped heap)
_9, points-to non-local, points-to escaped, points-to NULL, points-to vars: { D.5191 } (escaped, escaped heap)
_10, points-to non-local, points-to NULL, points-to vars: { }
sg_11, points-to non-local, points-to escaped, points-to NULL, points-to vars: { D.5191 } (escaped, escaped heap)
target_14(D), points-to non-local, points-to NULL, points-to vars: { }
sg_16, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
sg_18, points-to NULL, points-to vars: { D.5191 } (escaped, escaped heap)
s_29(D), points-to non-local, points-to NULL, points-to vars: { }

session_group_add (struct session * target, struct session * s)
{
  struct session_group * sg;
  struct session_group * * _1;
  struct session_group * * _2;
  struct session_group * * _3;
  struct session * * _4;
  struct session * * _5;
  struct session * * _6;
  struct session * * _7;
  struct session * * _8;
  struct session * * _9;
  struct session * * _10;

  <bb 2> [0.00%]:
  sg_16 = session_group_find (target_14(D));
  if (sg_16 == 0B)
    goto <bb 3>; [0.00%]
  else
    goto <bb 4>; [0.00%]

  <bb 3> [0.00%]:
  sg_18 = malloc (32);
  sg_18->entry.tqe_next = 0B;
  _1 = session_groups.tqh_last;
  sg_18->entry.tqe_prev = _1;
  _2 = session_groups.tqh_last;
  *_2 = sg_18;
  _3 = &sg_18->entry.tqe_next;
  session_groups.tqh_last = _3;
  sg_18->sessions.tqh_first = 0B;
  _4 = &sg_18->sessions.tqh_first;
  sg_18->sessions.tqh_last = _4;
  target_14(D)->gentry.tqe_next = 0B;
  _5 = sg_18->sessions.tqh_last;
  target_14(D)->gentry.tqe_prev = _5;
  _6 = sg_18->sessions.tqh_last;
  *_6 = target_14(D);
  _7 = &target_14(D)->gentry.tqe_next;
  sg_18->sessions.tqh_last = _7;

  <bb 4> [0.00%]:
  # sg_11 = PHI <sg_16(2), sg_18(3)>
  s_29(D)->gentry.tqe_next = 0B;
  _8 = sg_11->sessions.tqh_last;
  s_29(D)->gentry.tqe_prev = _8;
  _9 = sg_11->sessions.tqh_last;
  *_9 = s_29(D);
  _10 = &s_29(D)->gentry.tqe_next;
  sg_11->sessions.tqh_last = _10;
  return;

}



;; Function winlink_add (winlink_add, funcdef_no=69, decl_uid=4461, cgraph_uid=69, symbol_order=72)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
wwl = &NONLOCAL
w = &NONLOCAL
idx = &NONLOCAL
_1 = idx
ESCAPED = wwl
ESCAPED = _1
idx_15 = NONLOCAL
ESCAPED = wwl
ESCAPED = idx
_2 = NONLOCAL
idx_5 = idx_15
idx_5 = idx
ESCAPED = &NONLOCAL
ESCAPED = &NONLOCAL
wl_18 = &HEAP(19)
*wl_18 = idx_5
*wl_18 + 128 = w
ESCAPED = wwl
ESCAPED = wl_18
_3 = *w + 640
_4 = _3
_4 = &NONLOCAL
*w + 640 = _4
_24 = wl_18
_6 = &NULL
_6 = &NULL
_6 = wl_18
ESCAPED = _6

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { NULL ESCAPED NONLOCAL HEAP(19) }
NONLOCAL = { ESCAPED NONLOCAL } same as idx_15
STOREDANYTHING = { }
INTEGER = { ANYTHING }
wwl = { NONLOCAL }
w = { NONLOCAL } same as wwl
idx = { NONLOCAL } same as wwl
_1 = { NONLOCAL } same as wwl
winlink_next_index = { }
idx_15 = { ESCAPED NONLOCAL }
winlink_find_by_index = { }
_2 = { ESCAPED NONLOCAL } same as idx_15
idx_5 = { ESCAPED NONLOCAL } same as idx_15
calloc = { }
wl_18 = { HEAP(19) }
HEAP(19) = { ESCAPED NONLOCAL }
winlinks_RB_INSERT = { }
_3 = { ESCAPED NONLOCAL }
_4 = { ESCAPED NONLOCAL }
_24 = { HEAP(19) } same as wl_18
_6 = { NULL HEAP(19) }


Alias information for winlink_add

Aliased symbols


Call clobber information

ESCAPED, points-to non-local, points-to NULL, points-to vars: { D.5192 } (escaped, escaped heap)

Flow-insensitive points-to information

_2, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_6, points-to NULL, points-to vars: { D.5192 } (escaped, escaped heap)
wwl_11(D), points-to non-local, points-to NULL, points-to vars: { }
wl_18, points-to NULL, points-to vars: { D.5192 } (escaped, escaped heap)
w_20(D), points-to non-local, points-to NULL, points-to vars: { }
_24, points-to NULL, points-to vars: { D.5192 } (escaped, escaped heap)

winlink_add (struct winlinks * wwl, struct window * w, int idx)
{
  struct winlink * wl;
  int _1;
  struct winlink * _2;
  unsigned int _3;
  unsigned int _4;
  struct winlink * _6;
  struct winlink * _24;

  <bb 2> [0.00%]:
  if (idx_9(D) < 0)
    goto <bb 3>; [0.00%]
  else
    goto <bb 4>; [0.00%]

  <bb 3> [0.00%]:
  _1 = ~idx_9(D);
  idx_15 = winlink_next_index (wwl_11(D), _1);
  if (idx_15 == -1)
    goto <bb 6>; [0.00%]
  else
    goto <bb 5>; [0.00%]

  <bb 4> [0.00%]:
  _2 = winlink_find_by_index (wwl_11(D), idx_9(D));
  if (_2 != 0B)
    goto <bb 6>; [0.00%]
  else
    goto <bb 5>; [0.00%]

  <bb 5> [0.00%]:
  # idx_5 = PHI <idx_15(3), idx_9(D)(4)>
  wl_18 = calloc (1, 136);
  wl_18->idx = idx_5;
  wl_18->window = w_20(D);
  winlinks_RB_INSERT (wwl_11(D), wl_18);
  _3 = w_20(D)->references;
  _4 = _3 + 1;
  w_20(D)->references = _4;
  _24 = wl_18;

  <bb 6> [0.00%]:
  # _6 = PHI <0B(3), 0B(4), wl_18(5)>
  return _6;

}



;; Function window_index (window_index, funcdef_no=70, decl_uid=4466, cgraph_uid=70, symbol_order=73)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
s = &NONLOCAL
i = &NONLOCAL
derefaddrtmp(10) = &NULL
*i = derefaddrtmp(10)
windows = NONLOCAL
_1 = windows
_2 = *i
_3 = _2
_4 = _3
_4 = &NONLOCAL
_5 = _1
_6 = *_5
_7 = *i
_8 = _7
_8 = &NONLOCAL
*i = _8
_9 = *i
_10 = windows
_11 = &NULL
_11 = &NONLOCAL
ESCAPED = _11

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { NULL ESCAPED NONLOCAL }
NONLOCAL = { ESCAPED NONLOCAL } same as windows
STOREDANYTHING = { }
INTEGER = { ANYTHING }
s = { NONLOCAL }
i = { NONLOCAL } same as s
derefaddrtmp(10) = { NULL }
_1 = { ESCAPED NONLOCAL } same as windows
windows = { ESCAPED NONLOCAL }
_2 = { ESCAPED NONLOCAL }
_3 = { ESCAPED NONLOCAL } same as _2
_4 = { ESCAPED NONLOCAL } same as _2
_5 = { ESCAPED NONLOCAL } same as windows
_6 = { ESCAPED NONLOCAL }
_7 = { ESCAPED NONLOCAL } same as _2
_8 = { ESCAPED NONLOCAL } same as _2
_9 = { ESCAPED NONLOCAL } same as _2
_10 = { ESCAPED NONLOCAL } same as windows
_11 = { NULL NONLOCAL }


Alias information for window_index

Aliased symbols


Call clobber information

ESCAPED, points-to non-local, points-to NULL, points-to vars: { }

Flow-insensitive points-to information

_1, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_5, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_6, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
i_14(D), points-to non-local, points-to NULL, points-to vars: { }
s_17(D), points-to non-local, points-to NULL, points-to vars: { }

window_index (struct window * s, u_int * i)
{
  struct window * * _1;
  unsigned int _2;
  long unsigned int _3;
  long unsigned int _4;
  struct window * * _5;
  struct window * _6;
  unsigned int _7;
  unsigned int _8;
  unsigned int _9;
  unsigned int _10;
  int _11;

  <bb 2> [0.00%]:
  *i_14(D) = 0;
  goto <bb 5>; [0.00%]

  <bb 3> [0.00%]:
  _1 = windows.list;
  _2 = *i_14(D);
  _3 = (long unsigned int) _2;
  _4 = _3 * 8;
  _5 = _1 + _4;
  _6 = *_5;
  if (_6 == s_17(D))
    goto <bb 6>; [0.00%]
  else
    goto <bb 4>; [0.00%]

  <bb 4> [0.00%]:
  _7 = *i_14(D);
  _8 = _7 + 1;
  *i_14(D) = _8;

  <bb 5> [0.00%]:
  _9 = *i_14(D);
  _10 = windows.num;
  if (_9 < _10)
    goto <bb 3>; [0.00%]
  else
    goto <bb 6>; [0.00%]

  <bb 6> [0.00%]:
  # _11 = PHI <0(3), -1(5)>
  return _11;

}



;; Function session_group_remove (session_group_remove, funcdef_no=71, decl_uid=4472, cgraph_uid=71, symbol_order=74)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
s = &NONLOCAL
CALLUSED(10) = CALLUSED(10) + UNKNOWN
CALLUSED(10) = *CALLUSED(10) + UNKNOWN
CALLUSED(10) = s
sg_36 = CALLUSED(10)
sg_36 = NONLOCAL
_1 = *s + 768
_2 = *s + 768
_3 = *s + 832
*_2 + 832 = _3
_4 = *s + 832
*sg_36 + 64 = _4
_5 = *s + 832
_6 = *s + 768
*_5 = _6
_7 = *sg_36
_8 = *_7 + 768
_9 = *sg_36
_10 = *_9 + 768
_11 = *sg_36
_12 = *sg_36
_13 = *_12 + 768
_14 = *_11 + 832
*_13 + 832 = _14
_15 = *sg_36
_16 = *_15 + 832
*sg_36 + 64 = _16
_17 = *sg_36
_18 = *sg_36
_19 = *_18 + 832
_20 = *_17 + 768
*_19 = _20
_21 = *sg_36
_22 = *sg_36 + 128
_23 = *sg_36 + 128
_24 = *sg_36 + 192
*_23 + 192 = _24
_25 = *sg_36 + 192
session_groups = NONLOCAL
session_groups = _25
ESCAPED = _25
_26 = *sg_36 + 192
_27 = *sg_36 + 128
*_26 = _27

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { ESCAPED NONLOCAL }
NONLOCAL = { ESCAPED NONLOCAL }
STOREDANYTHING = { }
INTEGER = { ANYTHING }
s = { NONLOCAL }
session_group_find = { }
CALLUSED(10) = { ESCAPED NONLOCAL }
CALLCLOBBERED(11) = { }
sg_36 = { ESCAPED NONLOCAL }
_1 = { ESCAPED NONLOCAL }
_2 = { ESCAPED NONLOCAL }
_3 = { ESCAPED NONLOCAL }
_4 = { ESCAPED NONLOCAL }
_5 = { ESCAPED NONLOCAL }
_6 = { ESCAPED NONLOCAL }
_7 = { ESCAPED NONLOCAL }
_8 = { ESCAPED NONLOCAL }
_9 = { ESCAPED NONLOCAL } same as _7
_10 = { ESCAPED NONLOCAL }
_11 = { ESCAPED NONLOCAL } same as _7
_12 = { ESCAPED NONLOCAL } same as _7
_13 = { ESCAPED NONLOCAL }
_14 = { ESCAPED NONLOCAL }
_15 = { ESCAPED NONLOCAL } same as _7
_16 = { ESCAPED NONLOCAL }
_17 = { ESCAPED NONLOCAL } same as _7
_18 = { ESCAPED NONLOCAL } same as _7
_19 = { ESCAPED NONLOCAL }
_20 = { ESCAPED NONLOCAL }
_21 = { ESCAPED NONLOCAL } same as _7
_22 = { ESCAPED NONLOCAL }
_23 = { ESCAPED NONLOCAL }
_24 = { ESCAPED NONLOCAL }
_25 = { ESCAPED NONLOCAL }
session_groups = { ESCAPED NONLOCAL }
_26 = { ESCAPED NONLOCAL }
_27 = { ESCAPED NONLOCAL }


Alias information for session_group_remove

Aliased symbols


Call clobber information

ESCAPED, points-to non-local, points-to vars: { }

Flow-insensitive points-to information

_1, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_2, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_3, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_4, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_5, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_6, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_7, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_8, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_9, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_10, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_11, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_12, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_13, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_14, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_15, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_16, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_17, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_18, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_19, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_20, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_21, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_22, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_23, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_24, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_25, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_26, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_27, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
s_34(D), points-to non-local, points-to NULL, points-to vars: { }
sg_36, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }

session_group_remove (struct session * s)
{
  struct session_group * sg;
  struct session * _1;
  struct session * _2;
  struct session * * _3;
  struct session * * _4;
  struct session * * _5;
  struct session * _6;
  struct session * _7;
  struct session * _8;
  struct session * _9;
  struct session * _10;
  struct session * _11;
  struct session * _12;
  struct session * _13;
  struct session * * _14;
  struct session * _15;
  struct session * * _16;
  struct session * _17;
  struct session * _18;
  struct session * * _19;
  struct session * _20;
  struct session * _21;
  struct session_group * _22;
  struct session_group * _23;
  struct session_group * * _24;
  struct session_group * * _25;
  struct session_group * * _26;
  struct session_group * _27;

  <bb 2> [0.00%]:
  sg_36 = session_group_find (s_34(D));
  if (sg_36 == 0B)
    goto <bb 16>; [0.00%]
  else
    goto <bb 3>; [0.00%]

  <bb 3> [0.00%]:
  _1 = s_34(D)->gentry.tqe_next;
  if (_1 != 0B)
    goto <bb 4>; [0.00%]
  else
    goto <bb 5>; [0.00%]

  <bb 4> [0.00%]:
  _2 = s_34(D)->gentry.tqe_next;
  _3 = s_34(D)->gentry.tqe_prev;
  _2->gentry.tqe_prev = _3;
  goto <bb 6>; [0.00%]

  <bb 5> [0.00%]:
  _4 = s_34(D)->gentry.tqe_prev;
  sg_36->sessions.tqh_last = _4;

  <bb 6> [0.00%]:
  _5 = s_34(D)->gentry.tqe_prev;
  _6 = s_34(D)->gentry.tqe_next;
  *_5 = _6;
  _7 = sg_36->sessions.tqh_first;
  _8 = _7->gentry.tqe_next;
  if (_8 == 0B)
    goto <bb 7>; [0.00%]
  else
    goto <bb 11>; [0.00%]

  <bb 7> [0.00%]:
  _9 = sg_36->sessions.tqh_first;
  _10 = _9->gentry.tqe_next;
  if (_10 != 0B)
    goto <bb 8>; [0.00%]
  else
    goto <bb 9>; [0.00%]

  <bb 8> [0.00%]:
  _11 = sg_36->sessions.tqh_first;
  _12 = sg_36->sessions.tqh_first;
  _13 = _12->gentry.tqe_next;
  _14 = _11->gentry.tqe_prev;
  _13->gentry.tqe_prev = _14;
  goto <bb 10>; [0.00%]

  <bb 9> [0.00%]:
  _15 = sg_36->sessions.tqh_first;
  _16 = _15->gentry.tqe_prev;
  sg_36->sessions.tqh_last = _16;

  <bb 10> [0.00%]:
  _17 = sg_36->sessions.tqh_first;
  _18 = sg_36->sessions.tqh_first;
  _19 = _18->gentry.tqe_prev;
  _20 = _17->gentry.tqe_next;
  *_19 = _20;

  <bb 11> [0.00%]:
  _21 = sg_36->sessions.tqh_first;
  if (_21 == 0B)
    goto <bb 12>; [0.00%]
  else
    goto <bb 16>; [0.00%]

  <bb 12> [0.00%]:
  _22 = sg_36->entry.tqe_next;
  if (_22 != 0B)
    goto <bb 13>; [0.00%]
  else
    goto <bb 14>; [0.00%]

  <bb 13> [0.00%]:
  _23 = sg_36->entry.tqe_next;
  _24 = sg_36->entry.tqe_prev;
  _23->entry.tqe_prev = _24;
  goto <bb 15>; [0.00%]

  <bb 14> [0.00%]:
  _25 = sg_36->entry.tqe_prev;
  session_groups.tqh_last = _25;

  <bb 15> [0.00%]:
  _26 = sg_36->entry.tqe_prev;
  _27 = sg_36->entry.tqe_next;
  *_26 = _27;
  free (sg_36);

  <bb 16> [0.00%]:
  return;

}



;; Function session_find (session_find, funcdef_no=72, decl_uid=4476, cgraph_uid=72, symbol_order=75)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
name = &NONLOCAL
sessions = NONLOCAL
_1 = sessions
_2 = i_8
_3 = _2
_3 = &NONLOCAL
_4 = _1
s_13 = *_4
_5 = *s_13
CALLUSED(18) = CALLUSED(18) + UNKNOWN
CALLUSED(18) = *CALLUSED(18) + UNKNOWN
CALLUSED(18) = _5
CALLUSED(18) = name
_6 = CALLUSED(18)
_6 = NONLOCAL
i_16 = i_8
i_16 = &NONLOCAL
i_8 = &NULL
i_8 = i_16
_7 = sessions
_9 = s_13
_9 = &NULL
ESCAPED = _9

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { NULL ESCAPED NONLOCAL } same as s_13
NONLOCAL = { ESCAPED NONLOCAL } same as sessions
STOREDANYTHING = { }
INTEGER = { ANYTHING }
name = { NONLOCAL }
_1 = { ESCAPED NONLOCAL } same as sessions
sessions = { ESCAPED NONLOCAL }
_2 = { NULL NONLOCAL }
i_8 = { NULL NONLOCAL } same as _2
_3 = { NULL NONLOCAL } same as _2
_4 = { ESCAPED NONLOCAL } same as sessions
s_13 = { NULL ESCAPED NONLOCAL }
_5 = { ESCAPED NONLOCAL }
strcmp = { }
CALLUSED(18) = { ESCAPED NONLOCAL }
CALLCLOBBERED(19) = { }
_6 = { ESCAPED NONLOCAL }
i_16 = { NULL NONLOCAL } same as _2
_7 = { ESCAPED NONLOCAL } same as sessions
_9 = { NULL ESCAPED NONLOCAL } same as s_13


Alias information for session_find

Aliased symbols


Call clobber information

ESCAPED, points-to non-local, points-to NULL, points-to vars: { }

Flow-insensitive points-to information

_1, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_4, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_5, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_9, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
s_13, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
name_14(D), points-to non-local, points-to NULL, points-to vars: { }

session_find (const char * name)
{
  u_int i;
  struct session * s;
  struct session * * _1;
  long unsigned int _2;
  long unsigned int _3;
  struct session * * _4;
  char * _5;
  int _6;
  unsigned int _7;
  struct session * _9;

  <bb 2> [0.00%]:
  goto <bb 6>; [0.00%]

  <bb 3> [0.00%]:
  _1 = sessions.list;
  _2 = (long unsigned int) i_8;
  _3 = _2 * 8;
  _4 = _1 + _3;
  s_13 = *_4;
  if (s_13 != 0B)
    goto <bb 4>; [0.00%]
  else
    goto <bb 5>; [0.00%]

  <bb 4> [0.00%]:
  _5 = s_13->name;
  _6 = strcmp (_5, name_14(D));
  if (_6 == 0)
    goto <bb 7>; [0.00%]
  else
    goto <bb 5>; [0.00%]

  <bb 5> [0.00%]:
  i_16 = i_8 + 1;

  <bb 6> [0.00%]:
  # i_8 = PHI <0(2), i_16(5)>
  _7 = sessions.num;
  if (_7 > i_8)
    goto <bb 3>; [0.00%]
  else
    goto <bb 7>; [0.00%]

  <bb 7> [0.00%]:
  # _9 = PHI <s_13(4), 0B(6)>
  return _9;

}



;; Function session_index (session_index, funcdef_no=73, decl_uid=4485, cgraph_uid=73, symbol_order=76)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
s = &NONLOCAL
i = &NONLOCAL
derefaddrtmp(10) = &NULL
*i = derefaddrtmp(10)
sessions = NONLOCAL
_1 = sessions
_2 = *i
_3 = _2
_4 = _3
_4 = &NONLOCAL
_5 = _1
_6 = *_5
_7 = *i
_8 = _7
_8 = &NONLOCAL
*i = _8
_9 = *i
_10 = sessions
_11 = &NULL
_11 = &NONLOCAL
ESCAPED = _11

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { NULL ESCAPED NONLOCAL }
NONLOCAL = { ESCAPED NONLOCAL } same as sessions
STOREDANYTHING = { }
INTEGER = { ANYTHING }
s = { NONLOCAL }
i = { NONLOCAL } same as s
derefaddrtmp(10) = { NULL }
_1 = { ESCAPED NONLOCAL } same as sessions
sessions = { ESCAPED NONLOCAL }
_2 = { ESCAPED NONLOCAL }
_3 = { ESCAPED NONLOCAL } same as _2
_4 = { ESCAPED NONLOCAL } same as _2
_5 = { ESCAPED NONLOCAL } same as sessions
_6 = { ESCAPED NONLOCAL }
_7 = { ESCAPED NONLOCAL } same as _2
_8 = { ESCAPED NONLOCAL } same as _2
_9 = { ESCAPED NONLOCAL } same as _2
_10 = { ESCAPED NONLOCAL } same as sessions
_11 = { NULL NONLOCAL }


Alias information for session_index

Aliased symbols


Call clobber information

ESCAPED, points-to non-local, points-to NULL, points-to vars: { }

Flow-insensitive points-to information

_1, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_5, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_6, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
i_14(D), points-to non-local, points-to NULL, points-to vars: { }
s_17(D), points-to non-local, points-to NULL, points-to vars: { }

session_index (struct session * s, u_int * i)
{
  struct session * * _1;
  unsigned int _2;
  long unsigned int _3;
  long unsigned int _4;
  struct session * * _5;
  struct session * _6;
  unsigned int _7;
  unsigned int _8;
  unsigned int _9;
  unsigned int _10;
  int _11;

  <bb 2> [0.00%]:
  *i_14(D) = 0;
  goto <bb 5>; [0.00%]

  <bb 3> [0.00%]:
  _1 = sessions.list;
  _2 = *i_14(D);
  _3 = (long unsigned int) _2;
  _4 = _3 * 8;
  _5 = _1 + _4;
  _6 = *_5;
  if (_6 == s_17(D))
    goto <bb 6>; [0.00%]
  else
    goto <bb 4>; [0.00%]

  <bb 4> [0.00%]:
  _7 = *i_14(D);
  _8 = _7 + 1;
  *i_14(D) = _8;

  <bb 5> [0.00%]:
  _9 = *i_14(D);
  _10 = sessions.num;
  if (_9 < _10)
    goto <bb 3>; [0.00%]
  else
    goto <bb 6>; [0.00%]

  <bb 6> [0.00%]:
  # _11 = PHI <0(3), -1(5)>
  return _11;

}



;; Function winlink_stack_remove (winlink_stack_remove, funcdef_no=74, decl_uid=4492, cgraph_uid=74, symbol_order=77)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
stack = &NONLOCAL
wl = &NONLOCAL
wl2_13 = *stack
_1 = *wl + 960
_2 = *wl + 960
_3 = *wl + 1024
*_2 + 1024 = _3
_4 = *wl + 1024
*stack + 64 = _4
_5 = *wl + 1024
_6 = *wl + 960
*_5 = _6
wl2_14 = *wl2_7 + 960
wl2_7 = wl2_13
wl2_7 = wl2_14

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { ESCAPED NONLOCAL }
NONLOCAL = { ESCAPED NONLOCAL }
STOREDANYTHING = { }
INTEGER = { ANYTHING }
stack = { NONLOCAL }
wl = { NONLOCAL } same as stack
wl2_13 = { ESCAPED NONLOCAL }
_1 = { ESCAPED NONLOCAL }
_2 = { ESCAPED NONLOCAL }
_3 = { ESCAPED NONLOCAL }
_4 = { ESCAPED NONLOCAL }
_5 = { ESCAPED NONLOCAL }
_6 = { ESCAPED NONLOCAL }
wl2_14 = { ESCAPED NONLOCAL }
wl2_7 = { ESCAPED NONLOCAL }


Alias information for winlink_stack_remove

Aliased symbols


Call clobber information

ESCAPED, points-to non-local, points-to vars: { }

Flow-insensitive points-to information

_1, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_2, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_3, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_4, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_5, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_6, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
wl2_7, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
wl_10(D), points-to non-local, points-to NULL, points-to vars: { }
stack_12(D), points-to non-local, points-to NULL, points-to vars: { }
wl2_13, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
wl2_14, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }

winlink_stack_remove (struct winlink_stack * stack, struct winlink * wl)
{
  struct winlink * wl2;
  struct winlink * _1;
  struct winlink * _2;
  struct winlink * * _3;
  struct winlink * * _4;
  struct winlink * * _5;
  struct winlink * _6;

  <bb 2> [0.00%]:
  if (wl_10(D) == 0B)
    goto <bb 11>; [0.00%]
  else
    goto <bb 3>; [0.00%]

  <bb 3> [0.00%]:
  wl2_13 = stack_12(D)->tqh_first;
  goto <bb 10>; [0.00%]

  <bb 4> [0.00%]:
  if (wl2_7 == wl_10(D))
    goto <bb 5>; [0.00%]
  else
    goto <bb 9>; [0.00%]

  <bb 5> [0.00%]:
  _1 = wl_10(D)->sentry.tqe_next;
  if (_1 != 0B)
    goto <bb 6>; [0.00%]
  else
    goto <bb 7>; [0.00%]

  <bb 6> [0.00%]:
  _2 = wl_10(D)->sentry.tqe_next;
  _3 = wl_10(D)->sentry.tqe_prev;
  _2->sentry.tqe_prev = _3;
  goto <bb 8>; [0.00%]

  <bb 7> [0.00%]:
  _4 = wl_10(D)->sentry.tqe_prev;
  stack_12(D)->tqh_last = _4;

  <bb 8> [0.00%]:
  _5 = wl_10(D)->sentry.tqe_prev;
  _6 = wl_10(D)->sentry.tqe_next;
  *_5 = _6;
  goto <bb 11>; [0.00%]

  <bb 9> [0.00%]:
  wl2_14 = wl2_7->sentry.tqe_next;

  <bb 10> [0.00%]:
  # wl2_7 = PHI <wl2_13(3), wl2_14(9)>
  if (wl2_7 != 0B)
    goto <bb 4>; [0.00%]
  else
    goto <bb 11>; [0.00%]

  <bb 11> [0.00%]:
  return;

}



;; Function winlink_stack_push (winlink_stack_push, funcdef_no=75, decl_uid=4500, cgraph_uid=75, symbol_order=78)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
stack = &NONLOCAL
wl = &NONLOCAL
ESCAPED = stack
ESCAPED = wl
_1 = *stack
*wl + 960 = _1
_2 = *wl + 960
_3 = *stack
_4 = wl + 960
*_3 + 1024 = _4
_5 = wl + 960
*stack + 64 = _5
*stack = wl
_6 = stack
*wl + 1024 = _6

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { ESCAPED NONLOCAL }
NONLOCAL = { ESCAPED NONLOCAL }
STOREDANYTHING = { }
INTEGER = { ANYTHING }
stack = { NONLOCAL }
wl = { NONLOCAL } same as stack
winlink_stack_remove = { }
_1 = { ESCAPED NONLOCAL }
_2 = { ESCAPED NONLOCAL }
_3 = { ESCAPED NONLOCAL } same as _1
_4 = { NONLOCAL }
_5 = { NONLOCAL }
_6 = { NONLOCAL } same as stack


Alias information for winlink_stack_push

Aliased symbols


Call clobber information

ESCAPED, points-to non-local, points-to vars: { }

Flow-insensitive points-to information

_1, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_2, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_3, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_4, points-to non-local, points-to NULL, points-to vars: { }
_5, points-to non-local, points-to NULL, points-to vars: { }
_6, points-to non-local, points-to NULL, points-to vars: { }
wl_9(D), points-to non-local, points-to NULL, points-to vars: { }
stack_11(D), points-to non-local, points-to NULL, points-to vars: { }

winlink_stack_push (struct winlink_stack * stack, struct winlink * wl)
{
  struct winlink * _1;
  struct winlink * _2;
  struct winlink * _3;
  struct winlink * * _4;
  struct winlink * * _5;
  struct winlink * * _6;

  <bb 2> [0.00%]:
  if (wl_9(D) == 0B)
    goto <bb 7>; [0.00%]
  else
    goto <bb 3>; [0.00%]

  <bb 3> [0.00%]:
  winlink_stack_remove (stack_11(D), wl_9(D));
  _1 = stack_11(D)->tqh_first;
  wl_9(D)->sentry.tqe_next = _1;
  _2 = wl_9(D)->sentry.tqe_next;
  if (_2 != 0B)
    goto <bb 4>; [0.00%]
  else
    goto <bb 5>; [0.00%]

  <bb 4> [0.00%]:
  _3 = stack_11(D)->tqh_first;
  _4 = &wl_9(D)->sentry.tqe_next;
  _3->sentry.tqe_prev = _4;
  goto <bb 6>; [0.00%]

  <bb 5> [0.00%]:
  _5 = &wl_9(D)->sentry.tqe_next;
  stack_11(D)->tqh_last = _5;

  <bb 6> [0.00%]:
  stack_11(D)->tqh_first = wl_9(D);
  _6 = &stack_11(D)->tqh_first;
  wl_9(D)->sentry.tqe_prev = _6;

  <bb 7> [0.00%]:
  return;

}



;; Function window_destroy (window_destroy, funcdef_no=76, decl_uid=4503, cgraph_uid=76, symbol_order=79)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
w = &NONLOCAL
ESCAPED = w
ESCAPED = &i
_1 = NONLOCAL
ESCAPED = &NONLOCAL
ESCAPED = &STRING
ESCAPED = &STRING
_37 = NONLOCAL
ESCAPED = &NONLOCAL
windows = NONLOCAL
_2 = windows
i.0_3 = i
_4 = i.0_3
_5 = _4
_5 = &NONLOCAL
_6 = _2
derefaddrtmp(21) = &NULL
*_6 = derefaddrtmp(21)
_7 = windows
_8 = windows
_9 = _8
_9 = &NONLOCAL
windows = _9
ESCAPED = _9
_10 = windows
windows = &NULL
ESCAPED = &NULL
windows = &NULL
ESCAPED = &NULL
windows = &NULL
ESCAPED = &NULL
_11 = windows
_12 = windows
_13 = windows
_14 = _13
_14 = &NONLOCAL
_15 = _14
_16 = _15
_16 = &NONLOCAL
_17 = _12
_18 = *_17
_19 = *w
_20 = *w

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { NULL STRING ESCAPED NONLOCAL i }
NONLOCAL = { ESCAPED NONLOCAL } same as _1
STOREDANYTHING = { }
INTEGER = { ANYTHING }
w = { NONLOCAL }
window_index = { }
i = { ESCAPED NONLOCAL } same as i.0_3
_1 = { ESCAPED NONLOCAL }
__printf_chk = { }
_37 = { ESCAPED NONLOCAL } same as _1
exit = { }
_2 = { NULL ESCAPED NONLOCAL } same as windows
windows = { NULL ESCAPED NONLOCAL }
i.0_3 = { ESCAPED NONLOCAL }
_4 = { ESCAPED NONLOCAL } same as i.0_3
_5 = { ESCAPED NONLOCAL }
_6 = { NULL ESCAPED NONLOCAL } same as windows
derefaddrtmp(21) = { NULL }
_7 = { NULL ESCAPED NONLOCAL } same as windows
_8 = { NULL ESCAPED NONLOCAL } same as windows
_9 = { NULL ESCAPED NONLOCAL } same as windows
_10 = { NULL ESCAPED NONLOCAL } same as windows
_11 = { NULL ESCAPED NONLOCAL } same as windows
_12 = { NULL ESCAPED NONLOCAL } same as windows
_13 = { NULL ESCAPED NONLOCAL } same as windows
_14 = { NULL ESCAPED NONLOCAL } same as windows
_15 = { NULL ESCAPED NONLOCAL } same as windows
_16 = { NULL ESCAPED NONLOCAL } same as windows
_17 = { NULL ESCAPED NONLOCAL } same as windows
_18 = { ESCAPED NONLOCAL }
_19 = { ESCAPED NONLOCAL }
_20 = { ESCAPED NONLOCAL } same as _19


Alias information for window_destroy

Aliased symbols

i, UID D.4505, u_int, is addressable

Call clobber information

ESCAPED, points-to non-local, points-to NULL, points-to vars: { D.4505 } (escaped)

Flow-insensitive points-to information

_2, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_6, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_10, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_12, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_17, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_18, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_19, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_20, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
w_24(D), points-to non-local, points-to NULL, points-to vars: { }

window_destroy (struct window * w)
{
  int D.5194;
  u_int i;
  int _1;
  struct window * * _2;
  unsigned int i.0_3;
  long unsigned int _4;
  long unsigned int _5;
  struct window * * _6;
  unsigned int _7;
  unsigned int _8;
  unsigned int _9;
  struct window * * _10;
  unsigned int _11;
  struct window * * _12;
  unsigned int _13;
  unsigned int _14;
  long unsigned int _15;
  long unsigned int _16;
  struct window * * _17;
  struct window * _18;
  char * _19;
  char * _20;
  int _37;

  <bb 2> [0.00%]:
  _1 = window_index (w_24(D), &i);
  if (_1 != 0)
    goto <bb 3>; [0.00%]
  else
    goto <bb 4>; [0.00%]

  <bb 3> [100.00%]:
  _37 = __printf_chk (1, "index not found%s\n", "");
  exit (1);

  <bb 4> [0.00%]:
  _2 = windows.list;
  i.0_3 = i;
  _4 = (long unsigned int) i.0_3;
  _5 = _4 * 8;
  _6 = _2 + _5;
  *_6 = 0B;
  goto <bb 8>; [0.00%]

  <bb 5> [0.00%]:
  _7 = windows.num;
  if (_7 > 1)
    goto <bb 6>; [0.00%]
  else
    goto <bb 7>; [0.00%]

  <bb 6> [0.00%]:
  _8 = windows.num;
  _9 = _8 + 4294967295;
  windows.num = _9;
  goto <bb 8>; [0.00%]

  <bb 7> [0.00%]:
  _10 = windows.list;
  free (_10);
  windows.num = 0;
  windows.list = 0B;
  windows.space = 0;

  <bb 8> [0.00%]:
  _11 = windows.num;
  if (_11 != 0)
    goto <bb 9>; [0.00%]
  else
    goto <bb 10>; [0.00%]

  <bb 9> [0.00%]:
  _12 = windows.list;
  _13 = windows.num;
  _14 = _13 + 4294967295;
  _15 = (long unsigned int) _14;
  _16 = _15 * 8;
  _17 = _12 + _16;
  _18 = *_17;
  if (_18 == 0B)
    goto <bb 5>; [0.00%]
  else
    goto <bb 10>; [0.00%]

  <bb 10> [0.00%]:
  _19 = w_24(D)->name;
  if (_19 != 0B)
    goto <bb 11>; [0.00%]
  else
    goto <bb 12>; [0.00%]

  <bb 11> [0.00%]:
  _20 = w_24(D)->name;
  free (_20);

  <bb 12> [0.00%]:
  free (w_24(D));
  i ={v} {CLOBBER};
  return;

}



;; Function winlink_remove (winlink_remove, funcdef_no=77, decl_uid=4511, cgraph_uid=77, symbol_order=80)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
wwl = &NONLOCAL
wl = &NONLOCAL
w_11 = *wl + 128
ESCAPED = wwl
ESCAPED = wl
_1 = *wl + 448
_2 = *wl + 448
_3 = *w_11 + 640
ESCAPED = &NONLOCAL
ESCAPED = &STRING
ESCAPED = &STRING
_20 = NONLOCAL
ESCAPED = &NONLOCAL
_4 = *w_11 + 640
_5 = _4
_5 = &NONLOCAL
*w_11 + 640 = _5
_6 = *w_11 + 640
ESCAPED = w_11

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { STRING ESCAPED NONLOCAL }
NONLOCAL = { ESCAPED NONLOCAL } same as _20
STOREDANYTHING = { }
INTEGER = { ANYTHING }
wwl = { NONLOCAL }
wl = { NONLOCAL } same as wwl
w_11 = { ESCAPED NONLOCAL }
winlinks_RB_REMOVE = { }
_1 = { ESCAPED NONLOCAL }
_2 = { ESCAPED NONLOCAL }
_3 = { ESCAPED NONLOCAL }
__printf_chk = { }
_20 = { ESCAPED NONLOCAL }
exit = { }
_4 = { ESCAPED NONLOCAL }
_5 = { ESCAPED NONLOCAL }
_6 = { ESCAPED NONLOCAL }
window_destroy = { }


Alias information for winlink_remove

Aliased symbols


Call clobber information

ESCAPED, points-to non-local, points-to vars: { }

Flow-insensitive points-to information

_1, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_2, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
wl_10(D), points-to non-local, points-to NULL, points-to vars: { }
w_11, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
wwl_12(D), points-to non-local, points-to NULL, points-to vars: { }

winlink_remove (struct winlinks * wwl, struct winlink * wl)
{
  int D.5196;
  struct window * w;
  char * _1;
  char * _2;
  unsigned int _3;
  unsigned int _4;
  unsigned int _5;
  unsigned int _6;
  int _20;

  <bb 2> [0.00%]:
  w_11 = wl_10(D)->window;
  winlinks_RB_REMOVE (wwl_12(D), wl_10(D));
  _1 = wl_10(D)->status_text;
  if (_1 != 0B)
    goto <bb 3>; [0.00%]
  else
    goto <bb 4>; [0.00%]

  <bb 3> [0.00%]:
  _2 = wl_10(D)->status_text;
  free (_2);

  <bb 4> [0.00%]:
  free (wl_10(D));
  _3 = w_11->references;
  if (_3 == 0)
    goto <bb 5>; [0.00%]
  else
    goto <bb 6>; [0.00%]

  <bb 5> [100.00%]:
  _20 = __printf_chk (1, "bad reference count%s\n", "");
  exit (1);

  <bb 6> [0.00%]:
  _4 = w_11->references;
  _5 = _4 + 4294967295;
  w_11->references = _5;
  _6 = w_11->references;
  if (_6 == 0)
    goto <bb 7>; [0.00%]
  else
    goto <bb 8>; [0.00%]

  <bb 7> [0.00%]:
  window_destroy (w_11);

  <bb 8> [0.00%]:
  return;

}



;; Function session_group_synchronize1 (session_group_synchronize1, funcdef_no=78, decl_uid=4516, cgraph_uid=78, symbol_order=81)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
target = &NONLOCAL
s = &NONLOCAL
ww_23 = target + UNKNOWN
_1 = *target
_30 = *s
old_windows = _30
derefaddrtmp(14) = &NULL
*s + 320 = derefaddrtmp(14)
CALLUSED(16) = CALLUSED(16) + UNKNOWN
CALLUSED(16) = *CALLUSED(16) + UNKNOWN
CALLUSED(16) = ww_23
CALLUSED(16) = &NONLOCAL
wl_29 = CALLUSED(16)
wl_29 = NONLOCAL
_3 = *wl_15
_4 = *wl_15 + 128
_5 = s + UNKNOWN
ESCAPED = _5
ESCAPED = _4
ESCAPED = _3
CALLUSED(25) = CALLUSED(25) + UNKNOWN
CALLUSED(25) = *CALLUSED(25) + UNKNOWN
CALLUSED(25) = wl_15
wl_48 = CALLUSED(25)
wl_48 = NONLOCAL
wl_15 = wl_29
wl_15 = wl_48
_26 = *s
old_lastw = _26
derefaddrtmp(30) = &NULL
*s + 192 = derefaddrtmp(30)
_7 = s + 192
*s + 256 = _7
wl_33 = old_lastw
_8 = *wl_16
_9 = s + UNKNOWN
ESCAPED = _9
ESCAPED = _8
wl2_40 = NONLOCAL
derefaddrtmp(38) = &NULL
*wl2_40 + 960 = derefaddrtmp(38)
_10 = *s + 256
*wl2_40 + 1024 = _10
_11 = *s + 256
*_11 = wl2_40
_12 = wl2_40 + 960
*s + 256 = _12
wl_45 = *wl_16 + 960
wl_16 = wl_33
wl_16 = wl_45
_13 = *s + 192
*s + 128 = _13
wl_37 = old_windows
ESCAPED = &old_windows
ESCAPED = wl_37
_14 = old_windows

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { NULL ESCAPED NONLOCAL old_windows } same as _3
NONLOCAL = { ESCAPED NONLOCAL } same as wl2_40
STOREDANYTHING = { }
INTEGER = { ANYTHING }
target = { NONLOCAL }
s = { NONLOCAL } same as target
ww_23 = { NONLOCAL }
_1 = { ESCAPED NONLOCAL }
_30 = { ESCAPED NONLOCAL }
old_windows = { ESCAPED NONLOCAL } same as wl_37
derefaddrtmp(14) = { NULL }
winlinks_RB_MINMAX = { }
CALLUSED(16) = { ESCAPED NONLOCAL }
CALLCLOBBERED(17) = { }
wl_29 = { ESCAPED NONLOCAL }
_3 = { NULL ESCAPED NONLOCAL old_windows }
wl_15 = { ESCAPED NONLOCAL }
_4 = { ESCAPED NONLOCAL }
_5 = { NONLOCAL }
winlink_add = { }
winlinks_RB_NEXT = { }
CALLUSED(25) = { ESCAPED NONLOCAL } same as wl_15
CALLCLOBBERED(26) = { }
wl_48 = { ESCAPED NONLOCAL } same as wl_15
_26 = { ESCAPED NONLOCAL } same as _30
old_lastw = { ESCAPED NONLOCAL } same as _30
derefaddrtmp(30) = { NULL } same as derefaddrtmp(14)
_7 = { NONLOCAL }
wl_33 = { ESCAPED NONLOCAL } same as _30
_8 = { ESCAPED NONLOCAL }
wl_16 = { ESCAPED NONLOCAL }
_9 = { NONLOCAL }
winlink_find_by_index = { }
wl2_40 = { ESCAPED NONLOCAL }
derefaddrtmp(38) = { NULL } same as derefaddrtmp(14)
_10 = { ESCAPED NONLOCAL }
_11 = { ESCAPED NONLOCAL }
_12 = { ESCAPED NONLOCAL }
wl_45 = { ESCAPED NONLOCAL }
_13 = { ESCAPED NONLOCAL }
wl_37 = { ESCAPED NONLOCAL }
winlink_remove = { }
_14 = { ESCAPED NONLOCAL } same as wl_37


Alias information for session_group_synchronize1

Aliased symbols

old_lastw, UID D.4520, struct winlink_stack, is addressable
old_windows, UID D.4518, struct winlinks, is addressable

Call clobber information

ESCAPED, points-to non-local, points-to NULL, points-to vars: { D.4518 } (escaped)

Flow-insensitive points-to information

_1, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_4, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_5, points-to non-local, points-to NULL, points-to vars: { }
_7, points-to non-local, points-to NULL, points-to vars: { }
_9, points-to non-local, points-to NULL, points-to vars: { }
_10, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_11, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_12, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_13, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_14, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
wl_15, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
wl_16, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
target_22(D), points-to non-local, points-to NULL, points-to vars: { }
ww_23, points-to non-local, points-to NULL, points-to vars: { }
s_25(D), points-to non-local, points-to NULL, points-to vars: { }
wl_29, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
wl_33, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
wl_37, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
wl2_40, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
wl_45, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
wl_48, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }

session_group_synchronize1 (struct session * target, struct session * s)
{
  void * D.5204;
  void * D.5200;
  struct winlink * wl2;
  struct winlink * wl;
  struct winlink_stack old_lastw;
  struct winlinks * ww;
  struct winlinks old_windows;
  struct winlink * _1;
  int _3;
  struct window * _4;
  struct winlinks * _5;
  struct winlink * * _7;
  int _8;
  struct winlinks * _9;
  struct winlink * * _10;
  struct winlink * * _11;
  struct winlink * * _12;
  struct winlink * _13;
  struct winlink * _14;
  __int128 unsigned _26;
  long unsigned int _30;

  <bb 2> [0.00%]:
  ww_23 = &target_22(D)->windows;
  _1 = MEM[(struct winlinks *)target_22(D) + 40B].rbh_root;
  if (_1 == 0B)
    goto <bb 15>; [0.00%]
  else
    goto <bb 3>; [0.00%]

  <bb 3> [100.00%]:
  _30 = MEM[(char * {ref-all})s_25(D) + 40B];
  MEM[(char * {ref-all})&old_windows] = _30;
  s_25(D)->windows.rbh_root = 0B;
  wl_29 = winlinks_RB_MINMAX (ww_23, -1);
  goto <bb 5>; [0.00%]

  <bb 4> [0.00%]:
  _3 = wl_15->idx;
  _4 = wl_15->window;
  _5 = &s_25(D)->windows;
  winlink_add (_5, _4, _3);
  wl_48 = winlinks_RB_NEXT (wl_15);

  <bb 5> [0.00%]:
  # wl_15 = PHI <wl_29(3), wl_48(4)>
  if (wl_15 != 0B)
    goto <bb 4>; [0.00%]
  else
    goto <bb 6>; [0.00%]

  <bb 6> [100.00%]:
  _26 = MEM[(char * {ref-all})s_25(D) + 24B];
  MEM[(char * {ref-all})&old_lastw] = _26;
  s_25(D)->lastw.tqh_first = 0B;
  _7 = &s_25(D)->lastw.tqh_first;
  s_25(D)->lastw.tqh_last = _7;
  wl_33 = old_lastw.tqh_first;
  goto <bb 10>; [0.00%]

  <bb 7> [0.00%]:
  _8 = wl_16->idx;
  _9 = &s_25(D)->windows;
  wl2_40 = winlink_find_by_index (_9, _8);
  if (wl2_40 != 0B)
    goto <bb 8>; [0.00%]
  else
    goto <bb 9>; [0.00%]

  <bb 8> [0.00%]:
  wl2_40->sentry.tqe_next = 0B;
  _10 = s_25(D)->lastw.tqh_last;
  wl2_40->sentry.tqe_prev = _10;
  _11 = s_25(D)->lastw.tqh_last;
  *_11 = wl2_40;
  _12 = &wl2_40->sentry.tqe_next;
  s_25(D)->lastw.tqh_last = _12;

  <bb 9> [0.00%]:
  wl_45 = wl_16->sentry.tqe_next;

  <bb 10> [0.00%]:
  # wl_16 = PHI <wl_33(6), wl_45(9)>
  if (wl_16 != 0B)
    goto <bb 7>; [0.00%]
  else
    goto <bb 11>; [0.00%]

  <bb 11> [0.00%]:
  _13 = s_25(D)->lastw.tqh_first;
  s_25(D)->curw = _13;
  goto <bb 13>; [0.00%]

  <bb 12> [0.00%]:
  wl_37 = old_windows.rbh_root;
  winlink_remove (&old_windows, wl_37);

  <bb 13> [0.00%]:
  _14 = old_windows.rbh_root;
  if (_14 != 0B)
    goto <bb 12>; [0.00%]
  else
    goto <bb 14>; [0.00%]

  <bb 14> [0.00%]:
  old_windows ={v} {CLOBBER};
  old_lastw ={v} {CLOBBER};
  goto <bb 16>; [0.00%]

  <bb 15> [0.00%]:
  old_windows ={v} {CLOBBER};
  old_lastw ={v} {CLOBBER};

  <bb 16> [0.00%]:
  return;

}



;; Function session_group_synchronize_to (session_group_synchronize_to, funcdef_no=79, decl_uid=4535, cgraph_uid=79, symbol_order=82)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
s = &NONLOCAL
CALLUSED(10) = CALLUSED(10) + UNKNOWN
CALLUSED(10) = *CALLUSED(10) + UNKNOWN
CALLUSED(10) = s
sg_6 = CALLUSED(10)
sg_6 = NONLOCAL
target_8 = *sg_6
target_9 = *target_1 + 768
target_1 = target_8
target_1 = target_9
ESCAPED = target_1
ESCAPED = s

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { ESCAPED NONLOCAL } same as target_8
NONLOCAL = { ESCAPED NONLOCAL }
STOREDANYTHING = { }
INTEGER = { ANYTHING }
s = { NONLOCAL }
session_group_find = { }
CALLUSED(10) = { ESCAPED NONLOCAL }
CALLCLOBBERED(11) = { }
sg_6 = { ESCAPED NONLOCAL }
target_8 = { ESCAPED NONLOCAL }
target_9 = { ESCAPED NONLOCAL }
target_1 = { ESCAPED NONLOCAL } same as target_8
session_group_synchronize1 = { }


Alias information for session_group_synchronize_to

Aliased symbols


Call clobber information

ESCAPED, points-to non-local, points-to vars: { }

Flow-insensitive points-to information

target_1, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
s_4(D), points-to non-local, points-to NULL, points-to vars: { }
sg_6, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
target_8, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
target_9, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }

session_group_synchronize_to (struct session * s)
{
  struct session * target;
  struct session_group * sg;

  <bb 2> [0.00%]:
  sg_6 = session_group_find (s_4(D));
  if (sg_6 == 0B)
    goto <bb 8>; [0.00%]
  else
    goto <bb 3>; [0.00%]

  <bb 3> [0.00%]:
  target_8 = sg_6->sessions.tqh_first;
  goto <bb 6>; [0.00%]

  <bb 4> [0.00%]:
  if (target_1 != s_4(D))
    goto <bb 7>; [0.00%]
  else
    goto <bb 5>; [0.00%]

  <bb 5> [0.00%]:
  target_9 = target_1->gentry.tqe_next;

  <bb 6> [0.00%]:
  # target_1 = PHI <target_8(3), target_9(5)>
  if (target_1 != 0B)
    goto <bb 4>; [0.00%]
  else
    goto <bb 7>; [0.00%]

  <bb 7> [0.00%]:
  session_group_synchronize1 (target_1, s_4(D));

  <bb 8> [0.00%]:
  return;

}



;; Function session_group_synchronize_from (session_group_synchronize_from, funcdef_no=80, decl_uid=4543, cgraph_uid=80, symbol_order=83)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
target = &NONLOCAL
CALLUSED(10) = CALLUSED(10) + UNKNOWN
CALLUSED(10) = *CALLUSED(10) + UNKNOWN
CALLUSED(10) = target
sg_8 = CALLUSED(10)
sg_8 = NONLOCAL
s_9 = *sg_8
ESCAPED = target
ESCAPED = s_1
s_11 = *s_1 + 768
s_1 = s_9
s_1 = s_11

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { ESCAPED NONLOCAL } same as s_9
NONLOCAL = { ESCAPED NONLOCAL }
STOREDANYTHING = { }
INTEGER = { ANYTHING }
target = { NONLOCAL }
session_group_find = { }
CALLUSED(10) = { ESCAPED NONLOCAL }
CALLCLOBBERED(11) = { }
sg_8 = { ESCAPED NONLOCAL }
s_9 = { ESCAPED NONLOCAL }
session_group_synchronize1 = { }
s_1 = { ESCAPED NONLOCAL } same as s_9
s_11 = { ESCAPED NONLOCAL }


Alias information for session_group_synchronize_from

Aliased symbols


Call clobber information

ESCAPED, points-to non-local, points-to vars: { }

Flow-insensitive points-to information

s_1, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
target_6(D), points-to non-local, points-to NULL, points-to vars: { }
sg_8, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
s_9, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
s_11, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }

session_group_synchronize_from (struct session * target)
{
  struct session * s;
  struct session_group * sg;

  <bb 2> [0.00%]:
  sg_8 = session_group_find (target_6(D));
  if (sg_8 == 0B)
    goto <bb 8>; [0.00%]
  else
    goto <bb 3>; [0.00%]

  <bb 3> [0.00%]:
  s_9 = sg_8->sessions.tqh_first;
  goto <bb 7>; [0.00%]

  <bb 4> [0.00%]:
  if (s_1 != target_6(D))
    goto <bb 5>; [0.00%]
  else
    goto <bb 6>; [0.00%]

  <bb 5> [0.00%]:
  session_group_synchronize1 (target_6(D), s_1);

  <bb 6> [0.00%]:
  s_11 = s_1->gentry.tqe_next;

  <bb 7> [0.00%]:
  # s_1 = PHI <s_9(3), s_11(6)>
  if (s_1 != 0B)
    goto <bb 4>; [0.00%]
  else
    goto <bb 8>; [0.00%]

  <bb 8> [0.00%]:
  return;

}



;; Function session_destroy (session_destroy, funcdef_no=81, decl_uid=4551, cgraph_uid=81, symbol_order=84)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
s = &NONLOCAL
_1 = *s
ESCAPED = &NONLOCAL
ESCAPED = &STRING
ESCAPED = _1
_48 = NONLOCAL
ESCAPED = s
ESCAPED = &i
_2 = NONLOCAL
ESCAPED = &NONLOCAL
ESCAPED = &STRING
ESCAPED = &STRING
_49 = NONLOCAL
ESCAPED = &NONLOCAL
sessions = NONLOCAL
_3 = sessions
i.1_4 = i
_5 = i.1_4
_6 = _5
_6 = &NONLOCAL
_7 = _3
derefaddrtmp(23) = &NULL
*_7 = derefaddrtmp(23)
_8 = sessions
_9 = sessions
_10 = _9
_10 = &NONLOCAL
sessions = _10
ESCAPED = _10
_11 = sessions
sessions = &NULL
ESCAPED = &NULL
sessions = &NULL
ESCAPED = &NULL
sessions = &NULL
ESCAPED = &NULL
_12 = sessions
_13 = sessions
_14 = sessions
_15 = _14
_15 = &NONLOCAL
_16 = _15
_17 = _16
_17 = &NONLOCAL
_18 = _13
_19 = *_18
ESCAPED = s
_20 = *s + 192
_21 = s + UNKNOWN
ESCAPED = _21
ESCAPED = _20
_22 = *s + 192
_23 = *s + 320
_24 = s + UNKNOWN
ESCAPED = _24
ESCAPED = _23
_25 = *s + 320
_26 = *s

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { NULL STRING ESCAPED NONLOCAL i }
NONLOCAL = { ESCAPED NONLOCAL } same as _48
STOREDANYTHING = { }
INTEGER = { ANYTHING }
s = { NONLOCAL }
_1 = { ESCAPED NONLOCAL }
__printf_chk = { }
_48 = { ESCAPED NONLOCAL }
session_index = { }
i = { ESCAPED NONLOCAL } same as i.1_4
_2 = { ESCAPED NONLOCAL } same as _48
_49 = { ESCAPED NONLOCAL } same as _48
exit = { }
_3 = { NULL ESCAPED NONLOCAL } same as sessions
sessions = { NULL ESCAPED NONLOCAL }
i.1_4 = { ESCAPED NONLOCAL }
_5 = { ESCAPED NONLOCAL } same as i.1_4
_6 = { ESCAPED NONLOCAL }
_7 = { NULL ESCAPED NONLOCAL } same as sessions
derefaddrtmp(23) = { NULL }
_8 = { NULL ESCAPED NONLOCAL } same as sessions
_9 = { NULL ESCAPED NONLOCAL } same as sessions
_10 = { NULL ESCAPED NONLOCAL } same as sessions
_11 = { NULL ESCAPED NONLOCAL } same as sessions
_12 = { NULL ESCAPED NONLOCAL } same as sessions
_13 = { NULL ESCAPED NONLOCAL } same as sessions
_14 = { NULL ESCAPED NONLOCAL } same as sessions
_15 = { NULL ESCAPED NONLOCAL } same as sessions
_16 = { NULL ESCAPED NONLOCAL } same as sessions
_17 = { NULL ESCAPED NONLOCAL } same as sessions
_18 = { NULL ESCAPED NONLOCAL } same as sessions
_19 = { ESCAPED NONLOCAL }
session_group_remove = { }
_20 = { ESCAPED NONLOCAL }
_21 = { NONLOCAL }
winlink_stack_remove = { }
_22 = { ESCAPED NONLOCAL }
_23 = { ESCAPED NONLOCAL }
_24 = { NONLOCAL }
winlink_remove = { }
_25 = { ESCAPED NONLOCAL }
_26 = { ESCAPED NONLOCAL } same as _1


Alias information for session_destroy

Aliased symbols

i, UID D.4553, u_int, is addressable

Call clobber information

ESCAPED, points-to non-local, points-to NULL, points-to vars: { D.4553 } (escaped)

Flow-insensitive points-to information

_1, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_3, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_7, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_11, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_13, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_18, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_19, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_20, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_21, points-to non-local, points-to NULL, points-to vars: { }
_22, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_23, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_24, points-to non-local, points-to NULL, points-to vars: { }
_25, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_26, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
s_31(D), points-to non-local, points-to NULL, points-to vars: { }

session_destroy (struct session * s)
{
  int D.5208;
  int D.5206;
  u_int i;
  char * _1;
  int _2;
  struct session * * _3;
  unsigned int i.1_4;
  long unsigned int _5;
  long unsigned int _6;
  struct session * * _7;
  unsigned int _8;
  unsigned int _9;
  unsigned int _10;
  struct session * * _11;
  unsigned int _12;
  struct session * * _13;
  unsigned int _14;
  unsigned int _15;
  long unsigned int _16;
  long unsigned int _17;
  struct session * * _18;
  struct session * _19;
  struct winlink * _20;
  struct winlink_stack * _21;
  struct winlink * _22;
  struct winlink * _23;
  struct winlinks * _24;
  struct winlink * _25;
  char * _26;
  int _48;
  int _49;

  <bb 2> [100.00%]:
  _1 = s_31(D)->name;
  _48 = __printf_chk (1, "session %s destroyed\n", _1);
  _2 = session_index (s_31(D), &i);
  if (_2 != 0)
    goto <bb 3>; [0.00%]
  else
    goto <bb 4>; [0.00%]

  <bb 3> [100.00%]:
  _49 = __printf_chk (1, "session not found%s\n", "");
  exit (1);

  <bb 4> [0.00%]:
  _3 = sessions.list;
  i.1_4 = i;
  _5 = (long unsigned int) i.1_4;
  _6 = _5 * 8;
  _7 = _3 + _6;
  *_7 = 0B;
  goto <bb 8>; [0.00%]

  <bb 5> [0.00%]:
  _8 = sessions.num;
  if (_8 > 1)
    goto <bb 6>; [0.00%]
  else
    goto <bb 7>; [0.00%]

  <bb 6> [0.00%]:
  _9 = sessions.num;
  _10 = _9 + 4294967295;
  sessions.num = _10;
  goto <bb 8>; [0.00%]

  <bb 7> [0.00%]:
  _11 = sessions.list;
  free (_11);
  sessions.num = 0;
  sessions.list = 0B;
  sessions.space = 0;

  <bb 8> [0.00%]:
  _12 = sessions.num;
  if (_12 != 0)
    goto <bb 9>; [0.00%]
  else
    goto <bb 10>; [0.00%]

  <bb 9> [0.00%]:
  _13 = sessions.list;
  _14 = sessions.num;
  _15 = _14 + 4294967295;
  _16 = (long unsigned int) _15;
  _17 = _16 * 8;
  _18 = _13 + _17;
  _19 = *_18;
  if (_19 == 0B)
    goto <bb 5>; [0.00%]
  else
    goto <bb 10>; [0.00%]

  <bb 10> [0.00%]:
  session_group_remove (s_31(D));
  goto <bb 12>; [0.00%]

  <bb 11> [0.00%]:
  _20 = s_31(D)->lastw.tqh_first;
  _21 = &s_31(D)->lastw;
  winlink_stack_remove (_21, _20);

  <bb 12> [0.00%]:
  _22 = s_31(D)->lastw.tqh_first;
  if (_22 != 0B)
    goto <bb 11>; [0.00%]
  else
    goto <bb 14>; [0.00%]

  <bb 13> [0.00%]:
  _23 = s_31(D)->windows.rbh_root;
  _24 = &s_31(D)->windows;
  winlink_remove (_24, _23);

  <bb 14> [0.00%]:
  _25 = s_31(D)->windows.rbh_root;
  if (_25 != 0B)
    goto <bb 13>; [0.00%]
  else
    goto <bb 15>; [0.00%]

  <bb 15> [0.00%]:
  _26 = s_31(D)->name;
  free (_26);
  free (s_31(D));
  i ={v} {CLOBBER};
  return;

}



;; Function session_detach (session_detach, funcdef_no=82, decl_uid=4565, cgraph_uid=82, symbol_order=85)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
s = &NONLOCAL
wl = &NONLOCAL
_1 = s + UNKNOWN
ESCAPED = _1
ESCAPED = wl
_2 = s + UNKNOWN
ESCAPED = _2
ESCAPED = wl
ESCAPED = s
_3 = *s + 320
ESCAPED = s
_4 = &NONLOCAL
_4 = &NULL
ESCAPED = _4

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { NULL ESCAPED NONLOCAL }
NONLOCAL = { ESCAPED NONLOCAL }
STOREDANYTHING = { }
INTEGER = { ANYTHING }
s = { NONLOCAL }
wl = { NONLOCAL } same as s
_1 = { NONLOCAL }
winlink_stack_remove = { }
_2 = { NONLOCAL }
winlink_remove = { }
session_group_synchronize_from = { }
_3 = { ESCAPED NONLOCAL }
session_destroy = { }
_4 = { NULL NONLOCAL }


Alias information for session_detach

Aliased symbols


Call clobber information

ESCAPED, points-to non-local, points-to NULL, points-to vars: { }

Flow-insensitive points-to information

_1, points-to non-local, points-to NULL, points-to vars: { }
_2, points-to non-local, points-to NULL, points-to vars: { }
_3, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
s_6(D), points-to non-local, points-to NULL, points-to vars: { }
wl_8(D), points-to non-local, points-to NULL, points-to vars: { }

session_detach (struct session * s, struct winlink * wl)
{
  struct winlink_stack * _1;
  struct winlinks * _2;
  struct winlink * _3;
  int _4;

  <bb 2> [0.00%]:
  _1 = &s_6(D)->lastw;
  winlink_stack_remove (_1, wl_8(D));
  _2 = &s_6(D)->windows;
  winlink_remove (_2, wl_8(D));
  session_group_synchronize_from (s_6(D));
  _3 = s_6(D)->windows.rbh_root;
  if (_3 == 0B)
    goto <bb 3>; [0.00%]
  else
    goto <bb 4>; [0.00%]

  <bb 3> [0.00%]:
  session_destroy (s_6(D));

  <bb 4> [0.00%]:
  # _4 = PHI <1(3), 0(2)>
  return _4;

}



;; Function server_destroy_session_group (server_destroy_session_group, funcdef_no=83, decl_uid=4568, cgraph_uid=83, symbol_order=86)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
s = &NONLOCAL
CALLUSED(10) = CALLUSED(10) + UNKNOWN
CALLUSED(10) = *CALLUSED(10) + UNKNOWN
CALLUSED(10) = s
sg_12 = CALLUSED(10)
sg_12 = NONLOCAL
_1 = *sg_12 + 128
_2 = *sg_12 + 128
_3 = *sg_12 + 192
*_2 + 192 = _3
_4 = *sg_12 + 192
session_groups = NONLOCAL
session_groups = _4
ESCAPED = _4
_5 = *sg_12 + 192
_6 = *sg_12 + 128
*_5 = _6

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { ESCAPED NONLOCAL }
NONLOCAL = { ESCAPED NONLOCAL }
STOREDANYTHING = { }
INTEGER = { ANYTHING }
s = { NONLOCAL }
session_group_find = { }
CALLUSED(10) = { ESCAPED NONLOCAL }
CALLCLOBBERED(11) = { }
sg_12 = { ESCAPED NONLOCAL }
_1 = { ESCAPED NONLOCAL }
_2 = { ESCAPED NONLOCAL }
_3 = { ESCAPED NONLOCAL }
_4 = { ESCAPED NONLOCAL }
session_groups = { ESCAPED NONLOCAL }
_5 = { ESCAPED NONLOCAL }
_6 = { ESCAPED NONLOCAL }


Alias information for server_destroy_session_group

Aliased symbols


Call clobber information

ESCAPED, points-to non-local, points-to vars: { }

Flow-insensitive points-to information

_1, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_2, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_3, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_4, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_5, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_6, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
s_10(D), points-to non-local, points-to NULL, points-to vars: { }
sg_12, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }

server_destroy_session_group (struct session * s)
{
  struct session_group * sg;
  struct session_group * _1;
  struct session_group * _2;
  struct session_group * * _3;
  struct session_group * * _4;
  struct session_group * * _5;
  struct session_group * _6;

  <bb 2> [0.00%]:
  sg_12 = session_group_find (s_10(D));
  if (sg_12 == 0B)
    goto <bb 7>; [0.00%]
  else
    goto <bb 3>; [0.00%]

  <bb 3> [0.00%]:
  _1 = sg_12->entry.tqe_next;
  if (_1 != 0B)
    goto <bb 4>; [0.00%]
  else
    goto <bb 5>; [0.00%]

  <bb 4> [0.00%]:
  _2 = sg_12->entry.tqe_next;
  _3 = sg_12->entry.tqe_prev;
  _2->entry.tqe_prev = _3;
  goto <bb 6>; [0.00%]

  <bb 5> [0.00%]:
  _4 = sg_12->entry.tqe_prev;
  session_groups.tqh_last = _4;

  <bb 6> [0.00%]:
  _5 = sg_12->entry.tqe_prev;
  _6 = sg_12->entry.tqe_next;
  *_5 = _6;
  free (sg_12);

  <bb 7> [0.00%]:
  return;

}



;; Function server_kill_window (server_kill_window, funcdef_no=84, decl_uid=4572, cgraph_uid=84, symbol_order=87)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
w = &NONLOCAL
sessions = NONLOCAL
_1 = sessions
_2 = i_9
_3 = _2
_3 = &NONLOCAL
_4 = _1
s_16 = *_4
CALLUSED(17) = CALLUSED(17) + UNKNOWN
CALLUSED(17) = *CALLUSED(17) + UNKNOWN
CALLUSED(17) = s_16
CALLUSED(17) = w
_5 = CALLUSED(17)
_5 = NONLOCAL
ESCAPED = s_16
ESCAPED = wl_20
_6 = NONLOCAL
ESCAPED = s_16
_7 = s_16 + UNKNOWN
CALLUSED(26) = CALLUSED(26) + UNKNOWN
CALLUSED(26) = *CALLUSED(26) + UNKNOWN
CALLUSED(26) = _7
CALLUSED(26) = w
wl_20 = CALLUSED(26)
wl_20 = NONLOCAL
i_23 = i_9
i_23 = &NONLOCAL
i_9 = &NULL
i_9 = i_23
_8 = sessions

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { ESCAPED NONLOCAL } same as s_16
NONLOCAL = { ESCAPED NONLOCAL } same as sessions
STOREDANYTHING = { }
INTEGER = { ANYTHING }
w = { NONLOCAL }
_1 = { ESCAPED NONLOCAL } same as sessions
sessions = { ESCAPED NONLOCAL }
_2 = { NULL NONLOCAL }
i_9 = { NULL NONLOCAL } same as _2
_3 = { NULL NONLOCAL } same as _2
_4 = { ESCAPED NONLOCAL } same as sessions
s_16 = { ESCAPED NONLOCAL }
session_has = { }
CALLUSED(17) = { ESCAPED NONLOCAL }
CALLCLOBBERED(18) = { }
_5 = { ESCAPED NONLOCAL } same as CALLUSED(17)
session_detach = { }
wl_20 = { ESCAPED NONLOCAL }
_6 = { ESCAPED NONLOCAL } same as sessions
server_destroy_session_group = { }
_7 = { ESCAPED NONLOCAL }
winlink_find_by_window = { }
CALLUSED(26) = { ESCAPED NONLOCAL }
CALLCLOBBERED(27) = { }
i_23 = { NULL NONLOCAL } same as _2
_8 = { ESCAPED NONLOCAL } same as sessions


Alias information for server_kill_window

Aliased symbols


Call clobber information

ESCAPED, points-to non-local, points-to vars: { }

Flow-insensitive points-to information

_1, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_4, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_7, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
s_16, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
w_17(D), points-to non-local, points-to NULL, points-to vars: { }
wl_20, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }

server_kill_window (struct window * w)
{
  u_int i;
  struct winlink * wl;
  struct session * s;
  struct session * * _1;
  long unsigned int _2;
  long unsigned int _3;
  struct session * * _4;
  int _5;
  int _6;
  struct winlinks * _7;
  unsigned int _8;

  <bb 2> [0.00%]:
  goto <bb 10>; [0.00%]

  <bb 3> [0.00%]:
  _1 = sessions.list;
  _2 = (long unsigned int) i_9;
  _3 = _2 * 8;
  _4 = _1 + _3;
  s_16 = *_4;
  if (s_16 == 0B)
    goto <bb 5>; [0.00%]
  else
    goto <bb 4>; [0.00%]

  <bb 4> [0.00%]:
  _5 = session_has (s_16, w_17(D));
  if (_5 == 0)
    goto <bb 5>; [0.00%]
  else
    goto <bb 8>; [0.00%]

  <bb 5> [0.00%]:
  // predicted unlikely by continue predictor.
  goto <bb 9>; [0.00%]

  <bb 6> [0.00%]:
  _6 = session_detach (s_16, wl_20);
  if (_6 != 0)
    goto <bb 7>; [0.00%]
  else
    goto <bb 8>; [0.00%]

  <bb 7> [0.00%]:
  server_destroy_session_group (s_16);
  goto <bb 9>; [0.00%]

  <bb 8> [0.00%]:
  _7 = &s_16->windows;
  wl_20 = winlink_find_by_window (_7, w_17(D));
  if (wl_20 != 0B)
    goto <bb 6>; [0.00%]
  else
    goto <bb 9>; [0.00%]

  <bb 9> [0.00%]:
  i_23 = i_9 + 1;

  <bb 10> [0.00%]:
  # i_9 = PHI <0(2), i_23(9)>
  _8 = sessions.num;
  if (_8 > i_9)
    goto <bb 3>; [0.00%]
  else
    goto <bb 11>; [0.00%]

  <bb 11> [0.00%]:
  return;

}



;; Function session_select (session_select, funcdef_no=85, decl_uid=4586, cgraph_uid=85, symbol_order=88)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
s = &NONLOCAL
idx = &NONLOCAL
_1 = s + UNKNOWN
ESCAPED = _1
ESCAPED = idx
wl_12 = NONLOCAL
_2 = *s + 128
_3 = s + UNKNOWN
ESCAPED = _3
ESCAPED = wl_12
_4 = *s + 128
_5 = s + UNKNOWN
ESCAPED = _5
ESCAPED = _4
*s + 128 = wl_12
_6 = &NONLOCAL
_6 = &NONLOCAL
_6 = &NULL
ESCAPED = _6

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { NULL ESCAPED NONLOCAL }
NONLOCAL = { ESCAPED NONLOCAL } same as wl_12
STOREDANYTHING = { }
INTEGER = { ANYTHING }
s = { NONLOCAL }
idx = { NONLOCAL } same as s
_1 = { NONLOCAL }
winlink_find_by_index = { }
wl_12 = { ESCAPED NONLOCAL }
_2 = { ESCAPED NONLOCAL }
_3 = { NONLOCAL }
winlink_stack_remove = { }
_4 = { ESCAPED NONLOCAL }
_5 = { NONLOCAL }
winlink_stack_push = { }
_6 = { NULL NONLOCAL }


Alias information for session_select

Aliased symbols


Call clobber information

ESCAPED, points-to non-local, points-to NULL, points-to vars: { }

Flow-insensitive points-to information

_1, points-to non-local, points-to NULL, points-to vars: { }
_2, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_3, points-to non-local, points-to NULL, points-to vars: { }
_4, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_5, points-to non-local, points-to NULL, points-to vars: { }
s_8(D), points-to non-local, points-to NULL, points-to vars: { }
wl_12, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }

session_select (struct session * s, int idx)
{
  struct winlink * wl;
  struct winlinks * _1;
  struct winlink * _2;
  struct winlink_stack * _3;
  struct winlink * _4;
  struct winlink_stack * _5;
  int _6;

  <bb 2> [0.00%]:
  _1 = &s_8(D)->windows;
  wl_12 = winlink_find_by_index (_1, idx_10(D));
  if (wl_12 == 0B)
    goto <bb 5>; [0.00%]
  else
    goto <bb 3>; [0.00%]

  <bb 3> [0.00%]:
  _2 = s_8(D)->curw;
  if (_2 == wl_12)
    goto <bb 5>; [0.00%]
  else
    goto <bb 4>; [0.00%]

  <bb 4> [0.00%]:
  _3 = &s_8(D)->lastw;
  winlink_stack_remove (_3, wl_12);
  _4 = s_8(D)->curw;
  _5 = &s_8(D)->lastw;
  winlink_stack_push (_5, _4);
  s_8(D)->curw = wl_12;

  <bb 5> [0.00%]:
  # _6 = PHI <-1(2), 1(3), 0(4)>
  return _6;

}



;; Function join_pane_exec (join_pane_exec, funcdef_no=86, decl_uid=4590, cgraph_uid=86, symbol_order=89)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
ESCAPED = &NULL
ESCAPED = &dst_s
dst_wl_7 = NONLOCAL
dst_w_8 = *dst_wl_7 + 128
ESCAPED = &NONLOCAL
ESCAPED = &NULL
src_wl_10 = NONLOCAL
src_w_11 = *src_wl_10 + 128
ESCAPED = &NONLOCAL
ESCAPED = &STRING
_20 = NONLOCAL
ESCAPED = src_w_11
_1 = *dst_wl_7
dst_s.2_2 = dst_s
ESCAPED = dst_s.2_2
ESCAPED = _1
_3 = &NONLOCAL
_3 = &NONLOCAL
_3 = &NONLOCAL
_3 = &NULL
ESCAPED = _3

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { NULL STRING ESCAPED NONLOCAL dst_s } same as _1
NONLOCAL = { ESCAPED NONLOCAL } same as dst_wl_7
STOREDANYTHING = { }
INTEGER = { ANYTHING }
cmd_find_pane = { }
dst_s = { ESCAPED NONLOCAL } same as dst_s.2_2
dst_wl_7 = { ESCAPED NONLOCAL }
dst_w_8 = { ESCAPED NONLOCAL }
src_wl_10 = { ESCAPED NONLOCAL } same as dst_wl_7
src_w_11 = { ESCAPED NONLOCAL }
__printf_chk = { }
_20 = { ESCAPED NONLOCAL } same as dst_wl_7
server_kill_window = { }
_1 = { NULL STRING ESCAPED NONLOCAL dst_s }
dst_s.2_2 = { ESCAPED NONLOCAL }
session_select = { }
_3 = { NULL NONLOCAL }


Alias information for join_pane_exec

Aliased symbols

dst_s, UID D.4592, struct session *, is addressable

Call clobber information

ESCAPED, points-to non-local, points-to NULL, points-to vars: { D.4592 } (escaped)

Flow-insensitive points-to information

dst_s.2_2, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
dst_wl_7, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
dst_w_8, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
src_wl_10, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
src_w_11, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }

join_pane_exec ()
{
  int D.5210;
  struct window * dst_w;
  struct window * src_w;
  struct winlink * dst_wl;
  struct winlink * src_wl;
  struct session * dst_s;
  int _1;
  struct session * dst_s.2_2;
  int _3;
  int _20;

  <bb 2> [0.00%]:
  dst_wl_7 = cmd_find_pane (0, &dst_s);
  if (dst_wl_7 == 0B)
    goto <bb 7>; [0.00%]
  else
    goto <bb 3>; [0.00%]

  <bb 3> [0.00%]:
  dst_w_8 = dst_wl_7->window;
  src_wl_10 = cmd_find_pane (1, 0B);
  if (src_wl_10 == 0B)
    goto <bb 7>; [0.00%]
  else
    goto <bb 4>; [0.00%]

  <bb 4> [0.00%]:
  src_w_11 = src_wl_10->window;
  if (dst_w_8 == src_w_11)
    goto <bb 5>; [0.00%]
  else
    goto <bb 6>; [0.00%]

  <bb 5> [100.00%]:
  _20 = __printf_chk (1, "can\'t join a pane to its own window\n");
  goto <bb 7>; [0.00%]

  <bb 6> [0.00%]:
  server_kill_window (src_w_11);
  _1 = dst_wl_7->idx;
  dst_s.2_2 = dst_s;
  session_select (dst_s.2_2, _1);

  <bb 7> [0.00%]:
  # _3 = PHI <-1(2), -1(3), -1(5), 0(6)>
  dst_s ={v} {CLOBBER};
  return _3;

}



;; Function window_create1 (window_create1, funcdef_no=87, decl_uid=4599, cgraph_uid=87, symbol_order=90)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
sx = &NONLOCAL
sy = &NONLOCAL
ESCAPED = &NONLOCAL
w_43 = &HEAP(12)
derefaddrtmp(13) = &NULL
*w_43 = derefaddrtmp(13)
derefaddrtmp(14) = &NULL
*w_43 + 448 = derefaddrtmp(14)
derefaddrtmp(15) = &NULL
*w_43 + 64 = derefaddrtmp(15)
derefaddrtmp(16) = &NONLOCAL
*w_43 + 256 = derefaddrtmp(16)
derefaddrtmp(17) = &NULL
*w_43 + 320 = derefaddrtmp(17)
*w_43 + 384 = sx
*w_43 + 416 = sy
windows = NONLOCAL
_1 = windows
_2 = i_37
_3 = _2
_3 = &NONLOCAL
_4 = _1
_5 = *_4
_6 = windows
_7 = i_37
_8 = _7
_8 = &NONLOCAL
_9 = _6
*_9 = w_43
i_54 = i_37
i_54 = &NONLOCAL
i_37 = &NULL
i_37 = i_54
_10 = windows
_11 = windows
_12 = windows
ESCAPED = &NONLOCAL
ESCAPED = &STRING
ESCAPED = &STRING
_71 = NONLOCAL
ESCAPED = &NONLOCAL
_13 = windows
_14 = _13
_14 = &NONLOCAL
_15 = &NONLOCAL
_15 = _14
ESCAPED = &NONLOCAL
ESCAPED = &STRING
ESCAPED = &STRING
_72 = NONLOCAL
ESCAPED = &NONLOCAL
_16 = windows
windows = &NONLOCAL
ESCAPED = &NONLOCAL
_17 = windows
_18 = windows
ESCAPED = _18
ESCAPED = &NONLOCAL
ESCAPED = _17
_19 = NONLOCAL
windows = _19
ESCAPED = _19
_20 = windows
_21 = windows
ESCAPED = _21
ESCAPED = &NONLOCAL
ESCAPED = _20
_22 = NONLOCAL
windows = _22
ESCAPED = _22
_23 = windows
_24 = _23
_24 = &NONLOCAL
windows = _24
ESCAPED = _24
_25 = windows
_26 = windows
_27 = _26
_27 = &NONLOCAL
_28 = _27
_29 = _28
_29 = &NONLOCAL
_30 = windows
_31 = windows
_32 = _31
_33 = _32
_33 = &NONLOCAL
_34 = _30
*_34 = w_43
_35 = windows
_36 = _35
_36 = &NONLOCAL
windows = _36
ESCAPED = _36
derefaddrtmp(62) = &NULL
*w_43 + 640 = derefaddrtmp(62)
_69 = w_43
ESCAPED = w_43

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { NULL STRING ESCAPED NONLOCAL HEAP(12) }
NONLOCAL = { ESCAPED NONLOCAL } same as windows
STOREDANYTHING = { }
INTEGER = { ANYTHING }
sx = { NONLOCAL }
sy = { NONLOCAL } same as sx
malloc = { }
w_43 = { HEAP(12) }
HEAP(12) = { NULL ESCAPED NONLOCAL }
derefaddrtmp(13) = { NULL }
derefaddrtmp(14) = { NULL } same as derefaddrtmp(13)
derefaddrtmp(15) = { NULL } same as derefaddrtmp(13)
derefaddrtmp(16) = { NONLOCAL } same as sx
derefaddrtmp(17) = { NULL } same as derefaddrtmp(13)
_1 = { ESCAPED NONLOCAL } same as windows
windows = { ESCAPED NONLOCAL }
_2 = { NULL NONLOCAL }
i_37 = { NULL NONLOCAL } same as _2
_3 = { NULL NONLOCAL } same as _2
_4 = { ESCAPED NONLOCAL } same as windows
_5 = { ESCAPED NONLOCAL }
_6 = { ESCAPED NONLOCAL } same as windows
_7 = { NULL NONLOCAL } same as _2
_8 = { NULL NONLOCAL } same as _2
_9 = { ESCAPED NONLOCAL } same as windows
i_54 = { NULL NONLOCAL } same as _2
_10 = { ESCAPED NONLOCAL } same as windows
_11 = { ESCAPED NONLOCAL } same as windows
_12 = { ESCAPED NONLOCAL } same as windows
__printf_chk = { }
_71 = { ESCAPED NONLOCAL } same as windows
exit = { }
_13 = { ESCAPED NONLOCAL } same as windows
_14 = { ESCAPED NONLOCAL } same as windows
_15 = { ESCAPED NONLOCAL } same as windows
_72 = { ESCAPED NONLOCAL } same as windows
_16 = { ESCAPED NONLOCAL } same as windows
_17 = { ESCAPED NONLOCAL } same as windows
_18 = { ESCAPED NONLOCAL } same as windows
xrealloc = { }
_19 = { ESCAPED NONLOCAL } same as windows
_20 = { ESCAPED NONLOCAL } same as windows
_21 = { ESCAPED NONLOCAL } same as windows
_22 = { ESCAPED NONLOCAL } same as windows
_23 = { ESCAPED NONLOCAL } same as windows
_24 = { ESCAPED NONLOCAL } same as windows
_25 = { ESCAPED NONLOCAL } same as windows
_26 = { ESCAPED NONLOCAL } same as windows
_27 = { ESCAPED NONLOCAL } same as windows
_28 = { ESCAPED NONLOCAL } same as windows
_29 = { ESCAPED NONLOCAL } same as windows
_30 = { ESCAPED NONLOCAL } same as windows
_31 = { ESCAPED NONLOCAL } same as windows
_32 = { ESCAPED NONLOCAL } same as windows
_33 = { ESCAPED NONLOCAL } same as windows
_34 = { ESCAPED NONLOCAL } same as windows
_35 = { ESCAPED NONLOCAL } same as windows
_36 = { ESCAPED NONLOCAL } same as windows
derefaddrtmp(62) = { NULL } same as derefaddrtmp(13)
_69 = { HEAP(12) } same as w_43


Alias information for window_create1

Aliased symbols


Call clobber information

ESCAPED, points-to non-local, points-to NULL, points-to vars: { D.5215 } (escaped, escaped heap)

Flow-insensitive points-to information

_1, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_4, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_5, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_6, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_9, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_18, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_19, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_21, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_22, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_30, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_34, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
w_43, points-to NULL, points-to vars: { D.5215 } (escaped, escaped heap)
_69, points-to NULL, points-to vars: { D.5215 } (escaped, escaped heap)

window_create1 (u_int sx, u_int sy)
{
  int D.5214;
  int D.5212;
  u_int i;
  struct window * w;
  struct window * * _1;
  long unsigned int _2;
  long unsigned int _3;
  struct window * * _4;
  struct window * _5;
  struct window * * _6;
  long unsigned int _7;
  long unsigned int _8;
  struct window * * _9;
  unsigned int _10;
  unsigned int _11;
  unsigned int _12;
  unsigned int _13;
  unsigned int _14;
  unsigned int _15;
  long unsigned int _16;
  long unsigned int _17;
  struct window * * _18;
  void * _19;
  long unsigned int _20;
  struct window * * _21;
  void * _22;
  long unsigned int _23;
  long unsigned int _24;
  long unsigned int _25;
  unsigned int _26;
  unsigned int _27;
  long unsigned int _28;
  long unsigned int _29;
  struct window * * _30;
  unsigned int _31;
  long unsigned int _32;
  long unsigned int _33;
  struct window * * _34;
  unsigned int _35;
  unsigned int _36;
  struct window * _69;
  int _71;
  int _72;

  <bb 2> [0.00%]:
  w_43 = malloc (88);
  w_43->name = 0B;
  w_43->flags = 0;
  w_43->active = 0B;
  w_43->lastlayout = -1;
  w_43->layout_root = 0B;
  w_43->sx = sx_49(D);
  w_43->sy = sy_51(D);
  goto <bb 6>; [0.00%]

  <bb 3> [0.00%]:
  _1 = windows.list;
  _2 = (long unsigned int) i_37;
  _3 = _2 * 8;
  _4 = _1 + _3;
  _5 = *_4;
  if (_5 == 0B)
    goto <bb 4>; [0.00%]
  else
    goto <bb 5>; [0.00%]

  <bb 4> [0.00%]:
  _6 = windows.list;
  _7 = (long unsigned int) i_37;
  _8 = _7 * 8;
  _9 = _6 + _8;
  *_9 = w_43;
  goto <bb 7>; [0.00%]

  <bb 5> [0.00%]:
  i_54 = i_37 + 1;

  <bb 6> [0.00%]:
  # i_37 = PHI <0(2), i_54(5)>
  _10 = windows.num;
  if (_10 > i_37)
    goto <bb 3>; [0.00%]
  else
    goto <bb 7>; [0.00%]

  <bb 7> [0.00%]:
  _11 = windows.num;
  if (_11 == i_37)
    goto <bb 8>; [0.00%]
  else
    goto <bb 18>; [0.00%]

  <bb 8> [0.00%]:
  _12 = windows.num;
  if (_12 > 1073741823)
    goto <bb 9>; [0.00%]
  else
    goto <bb 10>; [0.00%]

  <bb 9> [100.00%]:
  _71 = __printf_chk (1, "number too big%s", "");
  exit (1);

  <bb 10> [0.00%]:
  _13 = windows.num;
  _14 = _13 + 1;
  _15 = 1073741824 / _14;
  if (_15 <= 7)
    goto <bb 11>; [0.00%]
  else
    goto <bb 12>; [0.00%]

  <bb 11> [100.00%]:
  _72 = __printf_chk (1, "size too big%s", "");
  exit (1);

  <bb 12> [0.00%]:
  _16 = windows.space;
  if (_16 == 0)
    goto <bb 13>; [0.00%]
  else
    goto <bb 15>; [0.00%]

  <bb 13> [0.00%]:
  windows.space = 80;
  _17 = windows.space;
  _18 = windows.list;
  _19 = xrealloc (_18, 1, _17);
  windows.list = _19;
  goto <bb 15>; [0.00%]

  <bb 14> [0.00%]:
  _20 = windows.space;
  _21 = windows.list;
  _22 = xrealloc (_21, 2, _20);
  windows.list = _22;
  _23 = windows.space;
  _24 = _23 * 2;
  windows.space = _24;
  goto <bb 16>; [0.00%]

  <bb 15> [0.00%]:

  <bb 16> [0.00%]:
  _25 = windows.space;
  _26 = windows.num;
  _27 = _26 + 1;
  _28 = (long unsigned int) _27;
  _29 = _28 * 8;
  if (_25 <= _29)
    goto <bb 14>; [0.00%]
  else
    goto <bb 17>; [0.00%]

  <bb 17> [0.00%]:
  _30 = windows.list;
  _31 = windows.num;
  _32 = (long unsigned int) _31;
  _33 = _32 * 8;
  _34 = _30 + _33;
  *_34 = w_43;
  _35 = windows.num;
  _36 = _35 + 1;
  windows.num = _36;

  <bb 18> [0.00%]:
  w_43->references = 0;
  _69 = w_43;
  return w_43;

}



;; Function session_attach (session_attach, funcdef_no=88, decl_uid=4613, cgraph_uid=88, symbol_order=91)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
s = &NONLOCAL
w = &NONLOCAL
idx = &NONLOCAL
cause = &NONLOCAL
_1 = s + UNKNOWN
ESCAPED = _1
ESCAPED = w
ESCAPED = idx
wl_8 = NONLOCAL
ESCAPED = &NONLOCAL
ESCAPED = &STRING
ESCAPED = idx
_12 = NONLOCAL
ESCAPED = s
ESCAPED = wl_8

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { STRING ESCAPED NONLOCAL }
NONLOCAL = { ESCAPED NONLOCAL } same as wl_8
STOREDANYTHING = { }
INTEGER = { ANYTHING }
s = { NONLOCAL }
w = { NONLOCAL } same as s
idx = { NONLOCAL } same as s
cause = { NONLOCAL } same as s
_1 = { NONLOCAL }
winlink_add = { }
wl_8 = { ESCAPED NONLOCAL }
__printf_chk = { }
_12 = { ESCAPED NONLOCAL } same as wl_8
session_group_synchronize_from = { }


Alias information for session_attach

Aliased symbols


Call clobber information

ESCAPED, points-to non-local, points-to vars: { }

Flow-insensitive points-to information

_1, points-to non-local, points-to NULL, points-to vars: { }
s_3(D), points-to non-local, points-to NULL, points-to vars: { }
w_5(D), points-to non-local, points-to NULL, points-to vars: { }
wl_8, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }

session_attach (struct session * s, struct window * w, int idx, char * * cause)
{
  int D.5217;
  struct winlink * wl;
  struct winlinks * _1;
  int _12;

  <bb 2> [0.00%]:
  _1 = &s_3(D)->windows;
  wl_8 = winlink_add (_1, w_5(D), idx_6(D));
  if (wl_8 == 0B)
    goto <bb 3>; [0.00%]
  else
    goto <bb 4>; [0.00%]

  <bb 3> [100.00%]:
  _12 = __printf_chk (1, "index in use: %d\n", idx_6(D));

  <bb 4> [0.00%]:
  session_group_synchronize_from (s_3(D));
  return wl_8;

}



;; Function session_new (session_new, funcdef_no=89, decl_uid=4622, cgraph_uid=89, symbol_order=92)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
s = &NONLOCAL
name = &NONLOCAL
cmd = &NONLOCAL
cwd = &NONLOCAL
idx = &NONLOCAL
cause = &NONLOCAL
_1 = *s + 96
_2 = *s + 64
ESCAPED = _2
ESCAPED = _1
w_8 = NONLOCAL
ESCAPED = s
ESCAPED = w_8
ESCAPED = idx
ESCAPED = cause
_12 = NONLOCAL
_3 = &NULL
_3 = _12
ESCAPED = _3

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { NULL ESCAPED NONLOCAL }
NONLOCAL = { ESCAPED NONLOCAL } same as w_8
STOREDANYTHING = { }
INTEGER = { ANYTHING }
s = { NONLOCAL }
name = { NONLOCAL } same as s
cmd = { NONLOCAL } same as s
cwd = { NONLOCAL } same as s
idx = { NONLOCAL } same as s
cause = { NONLOCAL } same as s
_1 = { ESCAPED NONLOCAL }
_2 = { ESCAPED NONLOCAL }
window_create1 = { }
w_8 = { ESCAPED NONLOCAL }
session_attach = { }
_12 = { ESCAPED NONLOCAL } same as w_8
_3 = { NULL ESCAPED NONLOCAL }


Alias information for session_new

Aliased symbols


Call clobber information

ESCAPED, points-to non-local, points-to NULL, points-to vars: { }

Flow-insensitive points-to information

_3, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
s_6(D), points-to non-local, points-to NULL, points-to vars: { }
w_8, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
cause_10(D), points-to non-local, points-to NULL, points-to vars: { }
_12, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }

session_new (struct session * s, const char * name, const char * cmd, const char * cwd, int idx, char * * cause)
{
  struct window * w;
  unsigned int _1;
  unsigned int _2;
  struct winlink * _3;
  struct winlink * _12;

  <bb 2> [0.00%]:
  _1 = s_6(D)->sy;
  _2 = s_6(D)->sx;
  w_8 = window_create1 (_2, _1);
  if (w_8 == 0B)
    goto <bb 4>; [0.00%]
  else
    goto <bb 3>; [0.00%]

  <bb 3> [0.00%]:
  _12 = session_attach (s_6(D), w_8, idx_9(D), cause_10(D));

  <bb 4> [0.00%]:
  # _3 = PHI <0B(2), _12(3)>
  return _3;

}



;; Function session_create (session_create, funcdef_no=90, decl_uid=4636, cgraph_uid=90, symbol_order=93)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
name = &NONLOCAL
cmd = &NONLOCAL
cwd = &NONLOCAL
env = &NONLOCAL
tio = &NONLOCAL
idx = &NONLOCAL
sx = &NONLOCAL
sy = &NONLOCAL
cause = &NONLOCAL
ESCAPED = &NONLOCAL
s_52 = &HEAP(19)
derefaddrtmp(20) = &NULL
*s_52 + 704 = derefaddrtmp(20)
derefaddrtmp(21) = &NULL
*s_52 + 576 = derefaddrtmp(21)
derefaddrtmp(22) = &NULL
*s_52 + 128 = derefaddrtmp(22)
derefaddrtmp(23) = &NULL
*s_52 + 192 = derefaddrtmp(23)
_1 = s_52 + 192
*s_52 + 256 = _1
derefaddrtmp(25) = &NULL
*s_52 + 320 = derefaddrtmp(25)
derefaddrtmp(26) = &NULL
*s_52 + 640 = derefaddrtmp(26)
*s_52 + 64 = sx
*s_52 + 96 = sy
sessions = NONLOCAL
_2 = sessions
_3 = i_43
_4 = _3
_4 = &NONLOCAL
_5 = _2
_6 = *_5
_7 = sessions
_8 = i_43
_9 = _8
_9 = &NONLOCAL
_10 = _7
*_10 = s_52
i_65 = i_43
i_65 = &NONLOCAL
i_43 = &NULL
i_43 = i_65
_11 = sessions
_12 = sessions
_13 = sessions
ESCAPED = &NONLOCAL
ESCAPED = &STRING
ESCAPED = &STRING
_95 = NONLOCAL
ESCAPED = &NONLOCAL
_14 = sessions
_15 = _14
_15 = &NONLOCAL
_16 = &NONLOCAL
_16 = _15
ESCAPED = &NONLOCAL
ESCAPED = &STRING
ESCAPED = &STRING
_96 = NONLOCAL
ESCAPED = &NONLOCAL
_17 = sessions
sessions = &NONLOCAL
ESCAPED = &NONLOCAL
_18 = sessions
_19 = sessions
ESCAPED = _19
ESCAPED = &NONLOCAL
ESCAPED = _18
_20 = NONLOCAL
sessions = _20
ESCAPED = _20
_21 = sessions
_22 = sessions
ESCAPED = _22
ESCAPED = &NONLOCAL
ESCAPED = _21
_23 = NONLOCAL
sessions = _23
ESCAPED = _23
_24 = sessions
_25 = _24
_25 = &NONLOCAL
sessions = _25
ESCAPED = _25
_26 = sessions
_27 = sessions
_28 = _27
_28 = &NONLOCAL
_29 = _28
_30 = _29
_30 = &NONLOCAL
_31 = sessions
_32 = sessions
_33 = _32
_34 = _33
_34 = &NONLOCAL
_35 = _31
*_35 = s_52
_36 = sessions
_37 = _36
_37 = &NONLOCAL
sessions = _37
ESCAPED = _37
ESCAPED = &NONLOCAL
ESCAPED = &STRING
ESCAPED = &STRING
_97 = NONLOCAL
ESCAPED = &NONLOCAL
_38 = &HEAP(73)
doubledereftmp(74) = *name
*_38 = doubledereftmp(74)
*s_52 = _38
ESCAPED = s_52
ESCAPED = &NULL
ESCAPED = cmd
ESCAPED = cwd
ESCAPED = idx
ESCAPED = cause
_39 = NONLOCAL
ESCAPED = s_52
_40 = *s_52 + 320
_41 = *_40
ESCAPED = s_52
ESCAPED = _41
_42 = *s_52
ESCAPED = &NONLOCAL
ESCAPED = &STRING
ESCAPED = _42
_98 = NONLOCAL
_91 = s_52
_44 = &NULL
_44 = s_52
ESCAPED = _44

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { NULL STRING ESCAPED NONLOCAL HEAP(19) HEAP(73) }
NONLOCAL = { ESCAPED NONLOCAL } same as sessions
STOREDANYTHING = { }
INTEGER = { ANYTHING }
name = { NONLOCAL }
cmd = { NONLOCAL } same as name
cwd = { NONLOCAL } same as name
env = { NONLOCAL } same as name
tio = { NONLOCAL } same as name
idx = { NONLOCAL } same as name
sx = { NONLOCAL } same as name
sy = { NONLOCAL } same as name
cause = { NONLOCAL } same as name
malloc = { }
s_52 = { HEAP(19) }
HEAP(19) = { NULL ESCAPED NONLOCAL HEAP(19) HEAP(73) }
derefaddrtmp(20) = { NULL }
derefaddrtmp(21) = { NULL } same as derefaddrtmp(20)
derefaddrtmp(22) = { NULL } same as derefaddrtmp(20)
derefaddrtmp(23) = { NULL } same as derefaddrtmp(20)
_1 = { HEAP(19) }
derefaddrtmp(25) = { NULL } same as derefaddrtmp(20)
derefaddrtmp(26) = { NULL } same as derefaddrtmp(20)
_2 = { ESCAPED NONLOCAL } same as sessions
sessions = { ESCAPED NONLOCAL }
_3 = { NULL NONLOCAL }
i_43 = { NULL NONLOCAL } same as _3
_4 = { NULL NONLOCAL } same as _3
_5 = { ESCAPED NONLOCAL } same as sessions
_6 = { ESCAPED NONLOCAL }
_7 = { ESCAPED NONLOCAL } same as sessions
_8 = { NULL NONLOCAL } same as _3
_9 = { NULL NONLOCAL } same as _3
_10 = { ESCAPED NONLOCAL } same as sessions
i_65 = { NULL NONLOCAL } same as _3
_11 = { ESCAPED NONLOCAL } same as sessions
_12 = { ESCAPED NONLOCAL } same as sessions
_13 = { ESCAPED NONLOCAL } same as sessions
__printf_chk = { }
_95 = { ESCAPED NONLOCAL } same as sessions
exit = { }
_14 = { ESCAPED NONLOCAL } same as sessions
_15 = { ESCAPED NONLOCAL } same as sessions
_16 = { ESCAPED NONLOCAL } same as sessions
_96 = { ESCAPED NONLOCAL } same as sessions
_17 = { ESCAPED NONLOCAL } same as sessions
_18 = { ESCAPED NONLOCAL } same as sessions
_19 = { ESCAPED NONLOCAL } same as sessions
xrealloc = { }
_20 = { ESCAPED NONLOCAL } same as sessions
_21 = { ESCAPED NONLOCAL } same as sessions
_22 = { ESCAPED NONLOCAL } same as sessions
_23 = { ESCAPED NONLOCAL } same as sessions
_24 = { ESCAPED NONLOCAL } same as sessions
_25 = { ESCAPED NONLOCAL } same as sessions
_26 = { ESCAPED NONLOCAL } same as sessions
_27 = { ESCAPED NONLOCAL } same as sessions
_28 = { ESCAPED NONLOCAL } same as sessions
_29 = { ESCAPED NONLOCAL } same as sessions
_30 = { ESCAPED NONLOCAL } same as sessions
_31 = { ESCAPED NONLOCAL } same as sessions
_32 = { ESCAPED NONLOCAL } same as sessions
_33 = { ESCAPED NONLOCAL } same as sessions
_34 = { ESCAPED NONLOCAL } same as sessions
_35 = { ESCAPED NONLOCAL } same as sessions
_36 = { ESCAPED NONLOCAL } same as sessions
_37 = { ESCAPED NONLOCAL } same as sessions
_97 = { ESCAPED NONLOCAL } same as sessions
_38 = { HEAP(73) }
HEAP(73) = { ESCAPED NONLOCAL }
doubledereftmp(74) = { ESCAPED NONLOCAL }
session_new = { }
_39 = { ESCAPED NONLOCAL } same as sessions
session_destroy = { }
_40 = { NULL ESCAPED NONLOCAL HEAP(19) HEAP(73) }
_41 = { NULL ESCAPED NONLOCAL HEAP(19) HEAP(73) }
session_select = { }
_42 = { NULL ESCAPED NONLOCAL HEAP(19) HEAP(73) }
_98 = { ESCAPED NONLOCAL } same as sessions
_91 = { HEAP(19) } same as s_52
_44 = { NULL HEAP(19) }


Alias information for session_create

Aliased symbols


Call clobber information

ESCAPED, points-to non-local, points-to NULL, points-to vars: { D.5226 D.5227 } (escaped, escaped heap)

Flow-insensitive points-to information

_1, points-to NULL, points-to vars: { D.5226 } (escaped, escaped heap)
_2, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_5, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_6, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_7, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_10, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_19, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_20, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_22, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_23, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_31, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_35, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_38, points-to NULL, points-to vars: { D.5227 } (escaped, escaped heap)
_39, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_40, points-to non-local, points-to escaped, points-to NULL, points-to vars: { D.5226 D.5227 } (escaped, escaped heap)
_42, points-to non-local, points-to escaped, points-to NULL, points-to vars: { D.5226 D.5227 } (escaped, escaped heap)
_44, points-to NULL, points-to vars: { D.5226 } (escaped, escaped heap)
s_52, points-to NULL, points-to vars: { D.5226 } (escaped, escaped heap)
name_79(D), points-to non-local, points-to NULL, points-to vars: { }
cmd_82(D), points-to non-local, points-to NULL, points-to vars: { }
cwd_83(D), points-to non-local, points-to NULL, points-to vars: { }
cause_85(D), points-to non-local, points-to NULL, points-to vars: { }
_91, points-to NULL, points-to vars: { D.5226 } (escaped, escaped heap)

session_create (const char * name, const char * cmd, const char * cwd, struct environ * env, struct termios * tio, int idx, u_int sx, u_int sy, char * * cause)
{
  int D.5225;
  int D.5223;
  int D.5221;
  int D.5219;
  u_int i;
  struct session * s;
  struct winlink * * _1;
  struct session * * _2;
  long unsigned int _3;
  long unsigned int _4;
  struct session * * _5;
  struct session * _6;
  struct session * * _7;
  long unsigned int _8;
  long unsigned int _9;
  struct session * * _10;
  unsigned int _11;
  unsigned int _12;
  unsigned int _13;
  unsigned int _14;
  unsigned int _15;
  unsigned int _16;
  long unsigned int _17;
  long unsigned int _18;
  struct session * * _19;
  void * _20;
  long unsigned int _21;
  struct session * * _22;
  void * _23;
  long unsigned int _24;
  long unsigned int _25;
  long unsigned int _26;
  unsigned int _27;
  unsigned int _28;
  long unsigned int _29;
  long unsigned int _30;
  struct session * * _31;
  unsigned int _32;
  long unsigned int _33;
  long unsigned int _34;
  struct session * * _35;
  unsigned int _36;
  unsigned int _37;
  char * _38;
  struct winlink * _39;
  struct winlink * _40;
  int _41;
  char * _42;
  struct session * _44;
  struct session * _91;
  int _95;
  int _96;
  int _97;
  int _98;

  <bb 2> [0.00%]:
  s_52 = malloc (112);
  s_52->references = 0;
  s_52->flags = 0;
  s_52->curw = 0B;
  s_52->lastw.tqh_first = 0B;
  _1 = &s_52->lastw.tqh_first;
  s_52->lastw.tqh_last = _1;
  s_52->windows.rbh_root = 0B;
  s_52->tio = 0B;
  s_52->sx = sx_60(D);
  s_52->sy = sy_62(D);
  goto <bb 6>; [0.00%]

  <bb 3> [0.00%]:
  _2 = sessions.list;
  _3 = (long unsigned int) i_43;
  _4 = _3 * 8;
  _5 = _2 + _4;
  _6 = *_5;
  if (_6 == 0B)
    goto <bb 4>; [0.00%]
  else
    goto <bb 5>; [0.00%]

  <bb 4> [0.00%]:
  _7 = sessions.list;
  _8 = (long unsigned int) i_43;
  _9 = _8 * 8;
  _10 = _7 + _9;
  *_10 = s_52;
  goto <bb 7>; [0.00%]

  <bb 5> [0.00%]:
  i_65 = i_43 + 1;

  <bb 6> [0.00%]:
  # i_43 = PHI <0(2), i_65(5)>
  _11 = sessions.num;
  if (_11 > i_43)
    goto <bb 3>; [0.00%]
  else
    goto <bb 7>; [0.00%]

  <bb 7> [0.00%]:
  _12 = sessions.num;
  if (_12 == i_43)
    goto <bb 8>; [0.00%]
  else
    goto <bb 18>; [0.00%]

  <bb 8> [0.00%]:
  _13 = sessions.num;
  if (_13 > 1073741823)
    goto <bb 9>; [0.00%]
  else
    goto <bb 10>; [0.00%]

  <bb 9> [100.00%]:
  _95 = __printf_chk (1, "number too big%s", "");
  exit (1);

  <bb 10> [0.00%]:
  _14 = sessions.num;
  _15 = _14 + 1;
  _16 = 1073741824 / _15;
  if (_16 <= 7)
    goto <bb 11>; [0.00%]
  else
    goto <bb 12>; [0.00%]

  <bb 11> [100.00%]:
  _96 = __printf_chk (1, "size too big%s", "");
  exit (1);

  <bb 12> [0.00%]:
  _17 = sessions.space;
  if (_17 == 0)
    goto <bb 13>; [0.00%]
  else
    goto <bb 15>; [0.00%]

  <bb 13> [0.00%]:
  sessions.space = 80;
  _18 = sessions.space;
  _19 = sessions.list;
  _20 = xrealloc (_19, 1, _18);
  sessions.list = _20;
  goto <bb 15>; [0.00%]

  <bb 14> [0.00%]:
  _21 = sessions.space;
  _22 = sessions.list;
  _23 = xrealloc (_22, 2, _21);
  sessions.list = _23;
  _24 = sessions.space;
  _25 = _24 * 2;
  sessions.space = _25;
  goto <bb 16>; [0.00%]

  <bb 15> [0.00%]:

  <bb 16> [0.00%]:
  _26 = sessions.space;
  _27 = sessions.num;
  _28 = _27 + 1;
  _29 = (long unsigned int) _28;
  _30 = _29 * 8;
  if (_26 <= _30)
    goto <bb 14>; [0.00%]
  else
    goto <bb 17>; [0.00%]

  <bb 17> [0.00%]:
  _31 = sessions.list;
  _32 = sessions.num;
  _33 = (long unsigned int) _32;
  _34 = _33 * 8;
  _35 = _31 + _34;
  *_35 = s_52;
  _36 = sessions.num;
  _37 = _36 + 1;
  sessions.num = _37;

  <bb 18> [0.00%]:
  if (name_79(D) == 0B)
    goto <bb 19>; [0.00%]
  else
    goto <bb 20>; [0.00%]

  <bb 19> [100.00%]:
  _97 = __printf_chk (1, "no name%s\n", "");
  exit (1);

  <bb 20> [0.00%]:
  _38 = strdup (name_79(D));
  s_52->name = _38;
  if (cmd_82(D) != 0B)
    goto <bb 21>; [0.00%]
  else
    goto <bb 24>; [0.00%]

  <bb 21> [0.00%]:
  _39 = session_new (s_52, 0B, cmd_82(D), cwd_83(D), idx_84(D), cause_85(D));
  if (_39 == 0B)
    goto <bb 22>; [0.00%]
  else
    goto <bb 23>; [0.00%]

  <bb 22> [0.00%]:
  session_destroy (s_52);
  goto <bb 25>; [0.00%]

  <bb 23> [0.00%]:
  _40 = s_52->windows.rbh_root;
  _41 = _40->idx;
  session_select (s_52, _41);

  <bb 24> [100.00%]:
  _42 = s_52->name;
  _98 = __printf_chk (1, "session %s created\n", _42);
  _91 = s_52;

  <bb 25> [0.00%]:
  # _44 = PHI <0B(22), s_52(24)>
  return _44;

}



;; Function main (main, funcdef_no=91, decl_uid=4648, cgraph_uid=91, symbol_order=94)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
argc = &NONLOCAL
argv = &NONLOCAL
windows = NONLOCAL
windows = &NULL
ESCAPED = &NULL
windows = &NULL
ESCAPED = &NULL
windows = &NULL
ESCAPED = &NULL
sessions = NONLOCAL
sessions = &NULL
ESCAPED = &NULL
sessions = &NULL
ESCAPED = &NULL
sessions = &NULL
ESCAPED = &NULL
session_groups = NONLOCAL
session_groups = &NULL
ESCAPED = &NULL
session_groups = &session_groups
ESCAPED = &session_groups
_1 = i_29
_2 = _1
_2 = &NONLOCAL
_3 = argv
_4 = *_3
_5 = *_4
_6 = i_29
_7 = _6
_7 = &NONLOCAL
_8 = _7
_8 = &NONLOCAL
_9 = argv
_10 = *_9
target_53 = &HEAP(25)
doubledereftmp(26) = *_10
*target_53 = doubledereftmp(26)
target_26 = target_53
target_26 = &NULL
target_26 = &NULL
CALLUSED(29) = CALLUSED(29) + UNKNOWN
CALLUSED(29) = *CALLUSED(29) + UNKNOWN
CALLUSED(29) = target_26
groupwith_56 = CALLUSED(29)
groupwith_56 = NONLOCAL
cmd_59 = &HEAP(33)
cmd_27 = cmd_59
cmd_27 = &NULL
_11 = i_29
_12 = _11
_12 = &NONLOCAL
_13 = argv
_14 = *_13
name_62 = &HEAP(40)
doubledereftmp(41) = *_14
*name_62 = doubledereftmp(41)
sy.3_15 = sy_63
sx.4_16 = sx_64
idx.5_17 = idx_28
idx_65 = idx_28
idx_65 = &NONLOCAL
ESCAPED = name_62
ESCAPED = cmd_27
ESCAPED = &STRING
ESCAPED = &NULL
ESCAPED = &NULL
ESCAPED = idx.5_17
ESCAPED = sx.4_16
ESCAPED = sy.3_15
ESCAPED = &cause
s_67 = NONLOCAL
sy.6_18 = sy_63
sx.7_19 = sx_64
ESCAPED = sx.7_19
ESCAPED = sy.6_18
w_69 = NONLOCAL
idx.8_20 = idx_65
idx_70 = idx_28
idx_70 = &NONLOCAL
ESCAPED = s_67
ESCAPED = w_69
ESCAPED = idx.8_20
ESCAPED = &cause
ESCAPED = groupwith_56
ESCAPED = s_67
ESCAPED = s_67
_21 = *s_67 + 320
_22 = *_21
ESCAPED = s_67
ESCAPED = _22
i_76 = i_29
i_76 = &NONLOCAL
idx_28 = &NULL
idx_28 = idx_70
i_29 = &NULL
i_29 = i_76
_23 = sessions
_24 = *_23
ESCAPED = _24
_25 = sessions
ESCAPED = &NULL

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { NULL STRING ESCAPED NONLOCAL session_groups HEAP(25) HEAP(33) HEAP(40) cause } same as _24
NONLOCAL = { ESCAPED NONLOCAL } same as s_67
STOREDANYTHING = { }
INTEGER = { ANYTHING }
argc = { NONLOCAL }
argv = { NONLOCAL } same as argc
windows = { NULL ESCAPED NONLOCAL }
sessions = { NULL ESCAPED NONLOCAL } same as windows
session_groups = { NULL ESCAPED NONLOCAL session_groups }
_1 = { NULL NONLOCAL }
i_29 = { NULL NONLOCAL } same as _1
_2 = { NULL NONLOCAL } same as _1
_3 = { NONLOCAL } same as argc
_4 = { ESCAPED NONLOCAL }
_5 = { ESCAPED NONLOCAL }
_6 = { NULL NONLOCAL } same as _1
_7 = { NULL NONLOCAL } same as _1
_8 = { NULL NONLOCAL } same as _1
_9 = { NONLOCAL } same as argc
_10 = { ESCAPED NONLOCAL }
target_53 = { HEAP(25) }
HEAP(25) = { ESCAPED NONLOCAL }
doubledereftmp(26) = { ESCAPED NONLOCAL }
target_26 = { NULL HEAP(25) }
session_find = { }
CALLUSED(29) = { NULL ESCAPED NONLOCAL HEAP(25) }
CALLCLOBBERED(30) = { }
groupwith_56 = { NULL ESCAPED NONLOCAL HEAP(25) }
cmd_59 = { HEAP(33) }
HEAP(33) = { ESCAPED NONLOCAL }
cmd_27 = { NULL HEAP(33) }
_11 = { NULL NONLOCAL } same as _1
_12 = { NULL NONLOCAL } same as _1
_13 = { NONLOCAL } same as argc
_14 = { ESCAPED NONLOCAL }
name_62 = { HEAP(40) }
HEAP(40) = { ESCAPED NONLOCAL }
doubledereftmp(41) = { ESCAPED NONLOCAL }
sy.3_15 = { }
sy_63 = { }
sx.4_16 = { }
sx_64 = { }
idx.5_17 = { NULL NONLOCAL } same as _1
idx_28 = { NULL NONLOCAL } same as _1
idx_65 = { NULL NONLOCAL } same as _1
session_create = { }
cause = { ESCAPED NONLOCAL }
s_67 = { ESCAPED NONLOCAL }
sy.6_18 = { }
sx.7_19 = { }
window_create1 = { }
w_69 = { ESCAPED NONLOCAL } same as s_67
idx.8_20 = { NULL NONLOCAL } same as _1
idx_70 = { NULL NONLOCAL } same as _1
session_attach = { }
session_group_add = { }
session_group_synchronize_to = { }
_21 = { ESCAPED NONLOCAL }
_22 = { ESCAPED NONLOCAL }
session_select = { }
i_76 = { NULL NONLOCAL } same as _1
join_pane_exec = { }
_23 = { NULL ESCAPED NONLOCAL } same as windows
_24 = { NULL STRING ESCAPED NONLOCAL session_groups HEAP(25) HEAP(33) HEAP(40) cause }
session_destroy = { }
_25 = { NULL ESCAPED NONLOCAL } same as windows


Alias information for main

Aliased symbols

cause, UID D.4656, char *, is addressable

Call clobber information

ESCAPED, points-to non-local, points-to NULL, points-to vars: { D.4293 D.4656 D.5228 D.5229 D.5230 } (nonlocal, escaped, escaped heap, interposable)

Flow-insensitive points-to information

_3, points-to non-local, points-to NULL, points-to vars: { }
_4, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_9, points-to non-local, points-to NULL, points-to vars: { }
_10, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_13, points-to non-local, points-to NULL, points-to vars: { }
_14, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_21, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_23, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_24, points-to non-local, points-to escaped, points-to NULL, points-to vars: { D.4293 D.4656 D.5228 D.5229 D.5230 } (nonlocal, escaped, escaped heap, interposable)
target_26, points-to NULL, points-to vars: { D.5228 } (escaped, escaped heap)
cmd_27, points-to NULL, points-to vars: { D.5229 } (escaped, escaped heap)
argv_51(D), points-to non-local, points-to NULL, points-to vars: { }
target_53, points-to NULL, points-to vars: { D.5228 } (escaped, escaped heap)
groupwith_56, points-to non-local, points-to escaped, points-to NULL, points-to vars: { D.5228 } (escaped, escaped heap)
cmd_59, points-to NULL, points-to vars: { D.5229 } (escaped, escaped heap)
name_62, points-to NULL, points-to vars: { D.5230 } (escaped, escaped heap)
s_67, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
w_69, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }

main (int argc, char * * argv)
{
  int i;
  int sy;
  int sx;
  int idx;
  char * cause;
  char * name;
  char * cmd;
  char * target;
  struct window * w;
  struct session * groupwith;
  struct session * s;
  long unsigned int _1;
  long unsigned int _2;
  char * * _3;
  char * _4;
  char _5;
  long unsigned int _6;
  long unsigned int _7;
  sizetype _8;
  char * * _9;
  char * _10;
  long unsigned int _11;
  long unsigned int _12;
  char * * _13;
  char * _14;
  unsigned int sy.3_15;
  unsigned int sx.4_16;
  int idx.5_17;
  unsigned int sy.6_18;
  unsigned int sx.7_19;
  int idx.8_20;
  struct winlink * _21;
  int _22;
  struct session * * _23;
  struct session * _24;
  unsigned int _25;

  <bb 2> [0.00%]:
  windows.num = 0;
  windows.list = 0B;
  windows.space = 0;
  sessions.num = 0;
  sessions.list = 0B;
  sessions.space = 0;
  session_groups.tqh_first = 0B;
  session_groups.tqh_last = &session_groups.tqh_first;
  goto <bb 11>; [0.00%]

  <bb 3> [0.00%]:
  _1 = (long unsigned int) i_29;
  _2 = _1 * 8;
  _3 = argv_51(D) + _2;
  _4 = *_3;
  _5 = *_4;
  if (_5 == 116)
    goto <bb 4>; [0.00%]
  else
    goto <bb 6>; [0.00%]

  <bb 4> [0.00%]:
  if (i_29 > 0)
    goto <bb 5>; [0.00%]
  else
    goto <bb 6>; [0.00%]

  <bb 5> [0.00%]:
  _6 = (long unsigned int) i_29;
  _7 = _6 * 8;
  _8 = _7 + 18446744073709551608;
  _9 = argv_51(D) + _8;
  _10 = *_9;
  target_53 = strdup (_10);

  <bb 6> [0.00%]:
  # target_26 = PHI <target_53(5), 0B(4), 0B(3)>
  groupwith_56 = session_find (target_26);
  if (target_26 == 0B)
    goto <bb 7>; [0.00%]
  else
    goto <bb 8>; [0.00%]

  <bb 7> [0.00%]:
  cmd_59 = strdup ("cmd");

  <bb 8> [0.00%]:
  # cmd_27 = PHI <cmd_59(7), 0B(6)>
  free (target_26);
  _11 = (long unsigned int) i_29;
  _12 = _11 * 8;
  _13 = argv_51(D) + _12;
  _14 = *_13;
  name_62 = strdup (_14);
  sy.3_15 = (unsigned int) sy_63(D);
  sx.4_16 = (unsigned int) sx_64(D);
  idx.5_17 = idx_28;
  idx_65 = idx_28 + 1;
  s_67 = session_create (name_62, cmd_27, "cwd", 0B, 0B, idx.5_17, sx.4_16, sy.3_15, &cause);
  sy.6_18 = (unsigned int) sy_63(D);
  sx.7_19 = (unsigned int) sx_64(D);
  w_69 = window_create1 (sx.7_19, sy.6_18);
  idx.8_20 = idx_65;
  idx_70 = idx_28 + 2;
  session_attach (s_67, w_69, idx.8_20, &cause);
  free (cmd_27);
  if (groupwith_56 != 0B)
    goto <bb 9>; [0.00%]
  else
    goto <bb 10>; [0.00%]

  <bb 9> [0.00%]:
  session_group_add (groupwith_56, s_67);
  session_group_synchronize_to (s_67);
  _21 = s_67->windows.rbh_root;
  _22 = _21->idx;
  session_select (s_67, _22);

  <bb 10> [0.00%]:
  i_76 = i_29 + 1;

  <bb 11> [0.00%]:
  # idx_28 = PHI <0(2), idx_70(10)>
  # i_29 = PHI <0(2), i_76(10)>
  if (i_29 < argc_46(D))
    goto <bb 3>; [0.00%]
  else
    goto <bb 12>; [0.00%]

  <bb 12> [0.00%]:
  join_pane_exec ();
  goto <bb 14>; [0.00%]

  <bb 13> [0.00%]:
  _23 = sessions.list;
  _24 = *_23;
  session_destroy (_24);

  <bb 14> [0.00%]:
  _25 = sessions.num;
  if (_25 != 0)
    goto <bb 13>; [0.00%]
  else
    goto <bb 15>; [0.00%]

  <bb 15> [0.00%]:
  cause ={v} {CLOBBER};
  return 0;

}


