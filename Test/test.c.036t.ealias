
;; Function printf (printf, funcdef_no=31, decl_uid=798, cgraph_uid=31, symbol_order=31)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
__fmt = &PARM_NOALIAS(9)
PARM_NOALIAS(9) = &NONLOCAL
ESCAPED = &NONLOCAL
ESCAPED = __fmt
_4 = NONLOCAL
ESCAPED = _4

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { ESCAPED NONLOCAL PARM_NOALIAS(9) }
NONLOCAL = { ESCAPED NONLOCAL } same as _4
STOREDANYTHING = { }
INTEGER = { ANYTHING }
__fmt = { PARM_NOALIAS(9) }
PARM_NOALIAS(9) = { ESCAPED NONLOCAL }
__printf_chk = { }
_4 = { ESCAPED NONLOCAL }


Alias information for printf

Aliased symbols


Call clobber information

ESCAPED, points-to non-local, points-to vars: { D.4397 } (nonlocal, escaped, restrict)

Flow-insensitive points-to information

__fmt_2(D), points-to NULL, points-to vars: { D.4397 } (nonlocal, escaped, restrict)

__attribute__((__artificial__, __gnu_inline__, __always_inline__))
printf (const char * restrict __fmt)
{
  int _4;

  <bb 2> [0.00%]:
  _4 = __printf_chk (1, __fmt_2(D), __builtin_va_arg_pack ());
  return _4;

}



;; Function foo3 (foo3, funcdef_no=51, decl_uid=4311, cgraph_uid=51, symbol_order=53)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
z = &NONLOCAL
ESCAPED = &NONLOCAL
_1 = &HEAP(11)
_2 = _1
_3 = _2
*z = _3

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { ESCAPED NONLOCAL HEAP(11) }
NONLOCAL = { ESCAPED NONLOCAL }
STOREDANYTHING = { }
INTEGER = { ANYTHING }
z = { NONLOCAL }
malloc = { }
_1 = { HEAP(11) }
HEAP(11) = { ESCAPED NONLOCAL }
_2 = { HEAP(11) } same as _1
_3 = { HEAP(11) } same as _1


Alias information for foo3

Aliased symbols


Call clobber information

ESCAPED, points-to non-local, points-to vars: { D.4398 } (escaped, escaped heap)

Flow-insensitive points-to information

_1, points-to NULL, points-to vars: { D.4398 } (escaped, escaped heap)
z_6(D), points-to non-local, points-to NULL, points-to vars: { }

__attribute__((noinline))
foo3 (int * z)
{
  void * _1;
  long int _2;
  int _3;

  <bb 2> [0.00%]:
  _1 = malloc (1);
  _2 = (long int) _1;
  _3 = (int) _2;
  *z_6(D) = _3;
  return;

}



;; Function foo2 (foo2, funcdef_no=52, decl_uid=4309, cgraph_uid=52, symbol_order=54)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
z = &NONLOCAL
_1 = z
ESCAPED = _1
a2_10 = &HEAP(12)
_2 = z
ESCAPED = _2
p3_12 = &HEAP(15)
_3 = z
ESCAPED = _3
p4_14 = &HEAP(18)
derefaddrtmp(19) = &NONLOCAL
*a2_10 = derefaddrtmp(19)
mLock = NONLOCAL
ESCAPED = &mLock
_4 = z
ESCAPED = _4
p3_22 = &HEAP(24)
_24 = p3_22
derefaddrtmp(26) = &NONLOCAL
*p3_12 = derefaddrtmp(26)
_19 = p4_14
_5 = p3_22
_5 = p4_14
ESCAPED = _5

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { ESCAPED NONLOCAL HEAP(18) mLock HEAP(24) }
NONLOCAL = { ESCAPED NONLOCAL }
STOREDANYTHING = { }
INTEGER = { ANYTHING }
z = { NONLOCAL }
_1 = { NONLOCAL } same as z
malloc = { }
a2_10 = { HEAP(12) }
HEAP(12) = { NONLOCAL }
_2 = { NONLOCAL } same as z
p3_12 = { HEAP(15) }
HEAP(15) = { NONLOCAL }
_3 = { NONLOCAL } same as z
p4_14 = { HEAP(18) }
HEAP(18) = { ESCAPED NONLOCAL }
derefaddrtmp(19) = { NONLOCAL } same as z
pthread_mutex_unlock = { }
mLock = { ESCAPED NONLOCAL }
_4 = { NONLOCAL } same as z
p3_22 = { HEAP(24) }
HEAP(24) = { ESCAPED NONLOCAL }
_24 = { HEAP(24) } same as p3_22
derefaddrtmp(26) = { NONLOCAL } same as z
_19 = { HEAP(18) } same as p4_14
_5 = { HEAP(18) HEAP(24) }


Alias information for foo2

Aliased symbols


Call clobber information

ESCAPED, points-to non-local, points-to vars: { D.4304 D.4401 D.4402 } (nonlocal, escaped, escaped heap, interposable)

Flow-insensitive points-to information

_5, points-to NULL, points-to vars: { D.4401 D.4402 } (escaped, escaped heap)
a2_10, points-to NULL, points-to vars: { D.4399 }
p3_12, points-to NULL, points-to vars: { D.4400 }
p4_14, points-to NULL, points-to vars: { D.4401 } (escaped, escaped heap)
_19, points-to NULL, points-to vars: { D.4401 } (escaped, escaped heap)
p3_22, points-to NULL, points-to vars: { D.4402 } (escaped, escaped heap)
_24, points-to NULL, points-to vars: { D.4402 } (escaped, escaped heap)

__attribute__((noinline))
foo2 (int z)
{
  int tmp;
  int * p4;
  int * p3;
  int * a2;
  long unsigned int _1;
  long unsigned int _2;
  long unsigned int _3;
  long unsigned int _4;
  int * _5;
  int * _19;
  int * _24;

  <bb 2> [0.00%]:
  _1 = (long unsigned int) z_7(D);
  a2_10 = malloc (_1);
  _2 = (long unsigned int) z_7(D);
  p3_12 = malloc (_2);
  _3 = (long unsigned int) z_7(D);
  p4_14 = malloc (_3);
  *a2_10 = 10;
  if (tmp_16(D) > 10)
    goto <bb 3>; [0.00%]
  else
    goto <bb 4>; [0.00%]

  <bb 3> [0.00%]:
  pthread_mutex_unlock (&mLock);
  _4 = (long unsigned int) z_7(D);
  p3_22 = malloc (_4);
  free (p3_22);
  _24 = p3_22;
  goto <bb 5>; [0.00%]

  <bb 4> [0.00%]:
  *p3_12 = 10;
  free (p4_14);
  _19 = p4_14;

  <bb 5> [0.00%]:
  # _5 = PHI <p3_22(3), p4_14(4)>
  return _5;

}



;; Function foo4 (foo4, funcdef_no=53, decl_uid=4319, cgraph_uid=53, symbol_order=55)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
z = &NONLOCAL
ESCAPED = &NONLOCAL
_1 = &HEAP(11)
b = _1
ESCAPED = &NONLOCAL
p2_7 = &HEAP(14)
b.0_2 = b
derefaddrtmp(16) = &NONLOCAL
*b.0_2 = derefaddrtmp(16)
derefaddrtmp(17) = &NONLOCAL
*p2_7 = derefaddrtmp(17)
ESCAPED = &b

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { ESCAPED NONLOCAL HEAP(11) b }
NONLOCAL = { ESCAPED NONLOCAL }
STOREDANYTHING = { }
INTEGER = { ANYTHING }
z = { NONLOCAL }
malloc = { }
_1 = { HEAP(11) }
HEAP(11) = { ESCAPED NONLOCAL }
b = { ESCAPED NONLOCAL HEAP(11) } same as b.0_2
p2_7 = { HEAP(14) }
HEAP(14) = { NONLOCAL }
b.0_2 = { ESCAPED NONLOCAL HEAP(11) }
derefaddrtmp(16) = { NONLOCAL } same as z
derefaddrtmp(17) = { NONLOCAL } same as z


Alias information for foo4

Aliased symbols

b, UID D.4333, int *, is addressable

Call clobber information

ESCAPED, points-to non-local, points-to vars: { D.4333 D.4403 } (escaped, escaped heap)

Flow-insensitive points-to information

_1, points-to NULL, points-to vars: { D.4403 } (escaped, escaped heap)
b.0_2, points-to non-local, points-to escaped, points-to NULL, points-to vars: { D.4403 } (escaped, escaped heap)
p2_7, points-to NULL, points-to vars: { D.4404 }

foo4 (int z)
{
  int * p2;
  int * b;
  void * _1;
  int * b.0_2;

  <bb 2> [0.00%]:
  _1 = malloc (1);
  b = _1;
  p2_7 = malloc (1);
  b.0_2 = b;
  *b.0_2 = 2;
  *p2_7 = 1;
  free (&b);
  b ={v} {CLOBBER};
  return &b;

}



;; Function foo (foo, funcdef_no=54, decl_uid=4307, cgraph_uid=54, symbol_order=56)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
z = &NONLOCAL
ESCAPED = &NONLOCAL
p2_3 = &HEAP(11)
derefaddrtmp(12) = &NONLOCAL
*p2_3 = derefaddrtmp(12)
ESCAPED = z
_7 = NONLOCAL
ESCAPED = _7

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { ESCAPED NONLOCAL }
NONLOCAL = { ESCAPED NONLOCAL } same as _7
STOREDANYTHING = { }
INTEGER = { ANYTHING }
z = { NONLOCAL }
malloc = { }
p2_3 = { HEAP(11) }
HEAP(11) = { NONLOCAL }
derefaddrtmp(12) = { NONLOCAL } same as z
foo2 = { }
_7 = { ESCAPED NONLOCAL }


Alias information for foo

Aliased symbols


Call clobber information

ESCAPED, points-to non-local, points-to vars: { }

Flow-insensitive points-to information

p2_3, points-to NULL, points-to vars: { D.4405 }
_7, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }

__attribute__((noinline))
foo (int z)
{
  int * p2;
  int * _7;

  <bb 2> [0.00%]:
  p2_3 = malloc (1);
  *p2_3 = 1;
  _7 = foo2 (z_5(D));
  return _7;

}



;; Function child (child, funcdef_no=55, decl_uid=4340, cgraph_uid=55, symbol_order=57)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
data = &NONLOCAL
ESCAPED = &mLock2
ESCAPED = &mLock2
mLock = NONLOCAL
ESCAPED = &mLock
ESCAPED = &mLock
ESCAPED = &NONLOCAL
ppData_15 = &HEAP(14)
ESCAPED = &NONLOCAL
_1 = &HEAP(16)
pData = _1
ESCAPED = &NONLOCAL
a_19 = NONLOCAL
data2 = &NULL
pData = &data2
_2 = pData
derefaddrtmp(22) = &NONLOCAL
*_2 = derefaddrtmp(22)
_4 = pData
derefaddrtmp(24) = &NONLOCAL
*_4 = derefaddrtmp(24)
_6 = pData
derefaddrtmp(26) = &NONLOCAL
*_6 = derefaddrtmp(26)
_7 = pData
derefaddrtmp(28) = &NONLOCAL
*_7 = derefaddrtmp(28)
pData.1_8 = pData
ESCAPED = &mLock

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { ESCAPED NONLOCAL mLock2 mLock }
NONLOCAL = { ESCAPED NONLOCAL } same as a_19
STOREDANYTHING = { }
INTEGER = { ANYTHING }
data = { NONLOCAL }
pthread_mutex_lock = { }
mLock2 = { ESCAPED NONLOCAL }
mLock = { ESCAPED NONLOCAL }
malloc = { }
ppData_15 = { HEAP(14) }
HEAP(14) = { }
_1 = { HEAP(16) }
HEAP(16) = { NONLOCAL }
pData = { HEAP(16) data2 }
foo = { }
a_19 = { ESCAPED NONLOCAL }
data2 = { NULL NONLOCAL }
_2 = { HEAP(16) data2 } same as pData
derefaddrtmp(22) = { NONLOCAL } same as data
_4 = { HEAP(16) data2 } same as pData
derefaddrtmp(24) = { NONLOCAL } same as data
_6 = { HEAP(16) data2 } same as pData
derefaddrtmp(26) = { NONLOCAL } same as data
_7 = { HEAP(16) data2 } same as pData
derefaddrtmp(28) = { NONLOCAL } same as data
pData.1_8 = { HEAP(16) data2 } same as pData
pthread_mutex_unlock = { }


Alias information for child

Aliased symbols

data2, UID D.4346, int, is addressable
pData, UID D.4344, int *, is addressable
mLock2, UID D.4342, union pthread_mutex_t, is addressable

Call clobber information

ESCAPED, points-to non-local, points-to vars: { D.4304 D.4342 } (nonlocal, escaped, interposable)

Flow-insensitive points-to information

_1, points-to NULL, points-to vars: { D.4407 }
_2, points-to NULL, points-to vars: { D.4346 D.4407 }
_4, points-to NULL, points-to vars: { D.4346 D.4407 }
_6, points-to NULL, points-to vars: { D.4346 D.4407 }
_7, points-to NULL, points-to vars: { D.4346 D.4407 }
pData.1_8, points-to NULL, points-to vars: { D.4346 D.4407 }
ppData_15, points-to NULL, points-to vars: { D.4406 }
a_19, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }

child (void * data)
{
  int data2;
  int * a;
  int * pData;
  int * * ppData;
  union pthread_mutex_t mLock2;
  void * _1;
  int * _2;
  int * _4;
  int * _6;
  int * _7;
  int * pData.1_8;

  <bb 2> [0.00%]:
  pthread_mutex_lock (&mLock2);
  pthread_mutex_lock (&mLock2);
  pthread_mutex_lock (&mLock);
  pthread_mutex_lock (&mLock);
  ppData_15 = malloc (10);
  _1 = malloc (20);
  pData = _1;
  a_19 = foo (1);
  data2 = 0;
  pData = &data2;
  _2 = pData;
  *_2 = 10;
  _4 = MEM[(int * *)&pData + 8B];
  *_4 = 10;
  _6 = MEM[(int * *)&pData + 16B];
  *_6 = 10;
  _7 = pData;
  *_7 = 12;
  pData.1_8 = pData;
  free (pData.1_8);
  pthread_mutex_unlock (&mLock);
  free (&pData);
  mLock2 ={v} {CLOBBER};
  pData ={v} {CLOBBER};
  data2 ={v} {CLOBBER};
  return;

}



;; Function boo (boo, funcdef_no=56, decl_uid=4351, cgraph_uid=56, symbol_order=58)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
b = &NONLOCAL
ESCAPED = &NONLOCAL
ESCAPED = &STRING
_5 = NONLOCAL

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { STRING ESCAPED NONLOCAL }
NONLOCAL = { ESCAPED NONLOCAL } same as _5
STOREDANYTHING = { }
INTEGER = { ANYTHING }
b = { NONLOCAL }
__printf_chk = { }
_5 = { ESCAPED NONLOCAL }


Alias information for boo

Aliased symbols


Call clobber information

ESCAPED, points-to non-local, points-to vars: { }

Flow-insensitive points-to information

b_2(D), points-to non-local, points-to NULL, points-to vars: { }

boo (int * b)
{
  int D.4409;
  int _5;

  <bb 2> [100.00%]:
  free (b_2(D));
  _5 = __printf_chk (1, "asdda\n");
  return;

}



;; Function test44 (test44, funcdef_no=57, decl_uid=4317, cgraph_uid=57, symbol_order=59)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
k = &NONLOCAL

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { }
NONLOCAL = { ESCAPED NONLOCAL }
STOREDANYTHING = { }
INTEGER = { ANYTHING }
k = { NONLOCAL }


Alias information for test44

Aliased symbols


Call clobber information

ESCAPED, points-to vars: { }

Flow-insensitive points-to information

k_2(D), points-to non-local, points-to NULL, points-to vars: { }

__attribute__((noinline))
test44 (int * k)
{
  <bb 2> [0.00%]:
  free (k_2(D));
  return;

}



;; Function test33 (test33, funcdef_no=58, decl_uid=4315, cgraph_uid=58, symbol_order=60)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
k = &NONLOCAL
ESCAPED = k

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { ESCAPED NONLOCAL }
NONLOCAL = { ESCAPED NONLOCAL }
STOREDANYTHING = { }
INTEGER = { ANYTHING }
k = { NONLOCAL }
test44 = { }


Alias information for test33

Aliased symbols


Call clobber information

ESCAPED, points-to non-local, points-to vars: { }

Flow-insensitive points-to information

k_2(D), points-to non-local, points-to NULL, points-to vars: { }

__attribute__((noinline))
test33 (int * k)
{
  <bb 2> [0.00%]:
  test44 (k_2(D));
  return;

}



;; Function test22 (test22, funcdef_no=59, decl_uid=4313, cgraph_uid=59, symbol_order=61)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
k = &NONLOCAL
ESCAPED = k

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { ESCAPED NONLOCAL }
NONLOCAL = { ESCAPED NONLOCAL }
STOREDANYTHING = { }
INTEGER = { ANYTHING }
k = { NONLOCAL }
test22 = { }


Alias information for test22

Aliased symbols


Call clobber information

ESCAPED, points-to non-local, points-to vars: { }

Flow-insensitive points-to information

k_2(D), points-to non-local, points-to NULL, points-to vars: { }

__attribute__((noinline))
test22 (int * k)
{
  <bb 2> [0.00%]:
  test22 (k_2(D));
  free (k_2(D));
  return;

}



;; Function main (main, funcdef_no=60, decl_uid=4362, cgraph_uid=60, symbol_order=62)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
ESCAPED = &NONLOCAL
p3_8 = NONLOCAL
derefaddrtmp(10) = &NONLOCAL
*p3_8 = derefaddrtmp(10)
ESCAPED = &NONLOCAL
p_12 = NONLOCAL
derefaddrtmp(13) = &NONLOCAL
*p_12 = derefaddrtmp(13)
ESCAPED = &NONLOCAL
p2_15 = NONLOCAL
derefaddrtmp(15) = &NONLOCAL
*p2_15 = derefaddrtmp(15)
ESCAPED = &NONLOCAL
q_20 = &HEAP(18)
derefaddrtmp(19) = &NONLOCAL
*q_20 = derefaddrtmp(19)
ESCAPED = q_20
q.2_1 = q_20
_2 = q.2_1
_3 = _2
_4 = _3
ESCAPED = _4
mLock = NONLOCAL
ESCAPED = &mLock
ESCAPED = &t
ESCAPED = &NULL
ESCAPED = &child
ESCAPED = &buff
t.3_5 = t
ESCAPED = t.3_5
ESCAPED = &NULL
ESCAPED = &mLock
ESCAPED = &NULL

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { NULL ESCAPED NONLOCAL HEAP(18) child mLock t buff }
NONLOCAL = { ESCAPED NONLOCAL } same as p3_8
STOREDANYTHING = { }
INTEGER = { ANYTHING }
foo = { }
p3_8 = { ESCAPED NONLOCAL }
derefaddrtmp(10) = { NONLOCAL }
foo2 = { }
p_12 = { ESCAPED NONLOCAL } same as p3_8
derefaddrtmp(13) = { NONLOCAL } same as derefaddrtmp(10)
p2_15 = { ESCAPED NONLOCAL } same as p3_8
derefaddrtmp(15) = { NONLOCAL } same as derefaddrtmp(10)
malloc = { }
q_20 = { HEAP(18) }
HEAP(18) = { ESCAPED NONLOCAL }
derefaddrtmp(19) = { NONLOCAL } same as derefaddrtmp(10)
test22 = { }
q.2_1 = { HEAP(18) } same as q_20
_2 = { HEAP(18) } same as q_20
_3 = { HEAP(18) } same as q_20
_4 = { HEAP(18) } same as q_20
child = { ESCAPED NONLOCAL }
pthread_mutex_destroy = { }
mLock = { ESCAPED NONLOCAL }
pthread_create = { }
t = { ESCAPED NONLOCAL } same as t.3_5
buff = { ESCAPED NONLOCAL }
t.3_5 = { ESCAPED NONLOCAL }
pthread_join = { }


Alias information for main

Aliased symbols

t, UID D.4370, pthread_t, is addressable
buff, UID D.4367, char[50], is addressable

Call clobber information

ESCAPED, points-to non-local, points-to NULL, points-to vars: { D.4304 D.4367 D.4370 D.4410 } (nonlocal, escaped, escaped heap, interposable)

Flow-insensitive points-to information

_4, points-to NULL, points-to vars: { D.4410 } (escaped, escaped heap)
p3_8, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
p_12, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
p2_15, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
q_20, points-to NULL, points-to vars: { D.4410 } (escaped, escaped heap)

main ()
{
  pthread_t t;
  int * q;
  char buff[50];
  int * p3;
  int * p2;
  int * p;
  long int q.2_1;
  int _2;
  long int _3;
  void * _4;
  long unsigned int t.3_5;

  <bb 2> [0.00%]:
  p3_8 = foo (2);
  *p3_8 = 1;
  free (p3_8);
  p_12 = foo2 (2);
  *p_12 = 2;
  p2_15 = foo2 (2);
  *p2_15 = 4;
  free (p_12);
  free (p2_15);
  q_20 = malloc (5);
  *q_20 = 10;
  test22 (q_20);
  q.2_1 = (long int) q_20;
  _2 = (int) q.2_1;
  _3 = (long int) _2;
  _4 = (void *) _3;
  child (_4);
  pthread_mutex_destroy (&mLock);
  pthread_create (&t, 0B, child, &buff);
  t.3_5 = t;
  pthread_join (t.3_5, 0B);
  pthread_mutex_destroy (&mLock);
  buff ={v} {CLOBBER};
  t ={v} {CLOBBER};
  return 0;

}


