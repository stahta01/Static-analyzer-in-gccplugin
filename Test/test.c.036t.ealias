
;; Function printf (printf, funcdef_no=15, decl_uid=798, cgraph_uid=15, symbol_order=15)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
__fmt = &PARM_NOALIAS(9)
PARM_NOALIAS(9) = &NONLOCAL
ESCAPED = &NONLOCAL
ESCAPED = __fmt
_4 = NONLOCAL
ESCAPED = _4

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { ESCAPED NONLOCAL PARM_NOALIAS(9) }
NONLOCAL = { ESCAPED NONLOCAL } same as _4
STOREDANYTHING = { }
INTEGER = { ANYTHING }
__fmt = { PARM_NOALIAS(9) }
PARM_NOALIAS(9) = { ESCAPED NONLOCAL }
__printf_chk = { }
_4 = { ESCAPED NONLOCAL }


Alias information for printf

Aliased symbols


Call clobber information

ESCAPED, points-to non-local, points-to vars: { D.3351 } (nonlocal, escaped, restrict)

Flow-insensitive points-to information

__fmt_2(D), points-to NULL, points-to vars: { D.3351 } (nonlocal, escaped, restrict)

__attribute__((__artificial__, __gnu_inline__, __always_inline__))
printf (const char * restrict __fmt)
{
  int _4;

  <bb 2> [0.00%]:
  _4 = __printf_chk (1, __fmt_2(D), __builtin_va_arg_pack ());
  return _4;

}



;; Function do_my_cleanups (do_my_cleanups, funcdef_no=48, decl_uid=3170, cgraph_uid=48, symbol_order=53)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
pmy_chain = &NONLOCAL
old_chain = &NONLOCAL
_1 = *ptr_12
*pmy_chain = _1
_2 = *ptr_12 + 64
_3 = *ptr_12 + 192
ESCAPED = _3
ESCAPED = &NONLOCAL
ESCAPED = &STRING
_21 = NONLOCAL
_4 = *ptr_12 + 192
ESCAPED = &NONLOCAL
ESCAPED = &STRING
ESCAPED = _4
_20 = NONLOCAL
_5 = *ptr_12 + 128
_6 = *ptr_12 + 128
_7 = *ptr_12 + 192
ESCAPED = _7
ptr_12 = *pmy_chain

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { STRING ESCAPED NONLOCAL }
NONLOCAL = { ESCAPED NONLOCAL } same as _21
STOREDANYTHING = { }
INTEGER = { ANYTHING }
pmy_chain = { NONLOCAL }
old_chain = { NONLOCAL } same as pmy_chain
_1 = { ESCAPED NONLOCAL }
ptr_12 = { ESCAPED NONLOCAL }
_2 = { ESCAPED NONLOCAL }
_3 = { ESCAPED NONLOCAL }
__printf_chk = { }
_21 = { ESCAPED NONLOCAL }
_4 = { ESCAPED NONLOCAL }
_20 = { ESCAPED NONLOCAL } same as _21
_5 = { ESCAPED NONLOCAL }
_6 = { ESCAPED NONLOCAL }
_7 = { ESCAPED NONLOCAL }


Alias information for do_my_cleanups

Aliased symbols


Call clobber information

ESCAPED, points-to non-local, points-to vars: { }

Flow-insensitive points-to information

_1, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_2, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_3, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_4, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_5, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_6, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_7, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
pmy_chain_11(D), points-to non-local, points-to NULL, points-to vars: { }
ptr_12, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
old_chain_13(D), points-to non-local, points-to NULL, points-to vars: { }

do_my_cleanups (struct cleanup * * pmy_chain, struct cleanup * old_chain)
{
  int D.3355;
  int D.3353;
  struct cleanup * ptr;
  struct cleanup * _1;
  void (*<Ted>) (void *) _2;
  void * _3;
  void * _4;
  void (*<Ted>) (void *) _5;
  void (*<Ted>) (void *) _6;
  void * _7;
  int _20;
  int _21;

  <bb 2> [0.00%]:
  goto <bb 6>; [0.00%]

  <bb 3> [100.00%]:
  _1 = ptr_12->next;
  *pmy_chain_11(D) = _1;
  _2 = ptr_12->function;
  _3 = ptr_12->arg;
  _2 (_3);
  _21 = __printf_chk (1, "cleanup!!!!! =========\n");
  _4 = ptr_12->arg;
  _20 = __printf_chk (1, "%x\n", _4);
  _5 = ptr_12->free_arg;
  if (_5 != 0B)
    goto <bb 4>; [0.00%]
  else
    goto <bb 5>; [0.00%]

  <bb 4> [0.00%]:
  _6 = ptr_12->free_arg;
  _7 = ptr_12->arg;
  _6 (_7);

  <bb 5> [0.00%]:
  free (ptr_12);

  <bb 6> [0.00%]:
  ptr_12 = *pmy_chain_11(D);
  if (ptr_12 != old_chain_13(D))
    goto <bb 3>; [0.00%]
  else
    goto <bb 7>; [0.00%]

  <bb 7> [0.00%]:
  return;

}



;; Function make_my_cleanup2 (make_my_cleanup2, funcdef_no=50, decl_uid=3178, cgraph_uid=50, symbol_order=55)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
pmy_chain = &NONLOCAL
function = &NONLOCAL
arg = &NONLOCAL
free_arg = &NONLOCAL
ESCAPED = &NONLOCAL
new_4 = &HEAP(14)
old_chain_6 = *pmy_chain
_1 = *pmy_chain
*new_4 = _1
*new_4 + 64 = function
*new_4 + 128 = free_arg
*new_4 + 192 = arg
*pmy_chain = new_4
ESCAPED = &NONLOCAL
ESCAPED = old_chain_6

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { ESCAPED NONLOCAL HEAP(14) }
NONLOCAL = { ESCAPED NONLOCAL }
STOREDANYTHING = { }
INTEGER = { ANYTHING }
pmy_chain = { NONLOCAL }
function = { NONLOCAL } same as pmy_chain
arg = { NONLOCAL } same as pmy_chain
free_arg = { NONLOCAL } same as pmy_chain
malloc = { }
new_4 = { HEAP(14) }
HEAP(14) = { ESCAPED NONLOCAL }
old_chain_6 = { ESCAPED NONLOCAL }
_1 = { ESCAPED NONLOCAL } same as old_chain_6
exit = { }


Alias information for make_my_cleanup2

Aliased symbols


Call clobber information

ESCAPED, points-to non-local, points-to vars: { D.3356 } (escaped, escaped heap)

Flow-insensitive points-to information

_1, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
new_4, points-to NULL, points-to vars: { D.3356 } (escaped, escaped heap)
pmy_chain_5(D), points-to non-local, points-to NULL, points-to vars: { }
old_chain_6, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
function_8(D), points-to non-local, points-to NULL, points-to vars: { }
free_arg_10(D), points-to non-local, points-to NULL, points-to vars: { }
arg_12(D), points-to non-local, points-to NULL, points-to vars: { }

make_my_cleanup2 (struct cleanup * * pmy_chain, void (*<Ta1d>) (void *) function, void * arg, void (*<Ted>) (void *) free_arg)
{
  struct cleanup * old_chain;
  struct cleanup * new;
  struct cleanup * _1;

  <bb 2> [0.00%]:
  new_4 = malloc (32);
  old_chain_6 = *pmy_chain_5(D);
  _1 = *pmy_chain_5(D);
  new_4->next = _1;
  new_4->function = function_8(D);
  new_4->free_arg = free_arg_10(D);
  new_4->arg = arg_12(D);
  *pmy_chain_5(D) = new_4;
  if (old_chain_6 == 0B)
    goto <bb 3>; [0.00%]
  else
    goto <bb 4>; [0.00%]

  <bb 3> [0.00%]:
  exit (1);

  <bb 4> [0.00%]:
  return old_chain_6;

}



;; Function make_my_cleanup (make_my_cleanup, funcdef_no=51, decl_uid=3182, cgraph_uid=51, symbol_order=56)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
pmy_chain = &NONLOCAL
function = &NONLOCAL
arg = &NONLOCAL
ESCAPED = pmy_chain
ESCAPED = function
ESCAPED = arg
ESCAPED = &NULL
_6 = NONLOCAL
ESCAPED = _6

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { NULL ESCAPED NONLOCAL }
NONLOCAL = { ESCAPED NONLOCAL } same as _6
STOREDANYTHING = { }
INTEGER = { ANYTHING }
pmy_chain = { NONLOCAL }
function = { NONLOCAL } same as pmy_chain
arg = { NONLOCAL } same as pmy_chain
make_my_cleanup2 = { }
_6 = { ESCAPED NONLOCAL }


Alias information for make_my_cleanup

Aliased symbols


Call clobber information

ESCAPED, points-to non-local, points-to NULL, points-to vars: { }

Flow-insensitive points-to information

pmy_chain_2(D), points-to non-local, points-to NULL, points-to vars: { }
function_3(D), points-to non-local, points-to NULL, points-to vars: { }
arg_4(D), points-to non-local, points-to NULL, points-to vars: { }
_6, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }

make_my_cleanup (struct cleanup * * pmy_chain, void (*<Ta1d>) (void *) function, void * arg)
{
  struct cleanup * _6;

  <bb 2> [0.00%]:
  _6 = make_my_cleanup2 (pmy_chain_2(D), function_3(D), arg_4(D), 0B);
  return _6;

}



;; Function rs6000_ptrace64 (rs6000_ptrace64, funcdef_no=55, decl_uid=3252, cgraph_uid=55, symbol_order=60)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
req = &NONLOCAL
id = &NONLOCAL
addr = &NONLOCAL
data = &NONLOCAL
buf = &NONLOCAL
addr.2_1 = addr
i_7 = *addr.2_1
_2 = NONLOCAL
_3 = _2
_3 = &NONLOCAL
iftmp.3_4 = &NONLOCAL
iftmp.3_4 = &NONLOCAL
ret_11 = iftmp.3_4
_12 = iftmp.3_4
ESCAPED = iftmp.3_4

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { ESCAPED NONLOCAL }
NONLOCAL = { ESCAPED NONLOCAL } same as _2
STOREDANYTHING = { }
INTEGER = { ANYTHING }
req = { NONLOCAL }
id = { NONLOCAL } same as req
addr = { NONLOCAL } same as req
data = { NONLOCAL } same as req
buf = { NONLOCAL } same as req
addr.2_1 = { NONLOCAL } same as req
i_7 = { ESCAPED NONLOCAL }
rand = { }
_2 = { ESCAPED NONLOCAL }
_3 = { ESCAPED NONLOCAL } same as _2
iftmp.3_4 = { NONLOCAL } same as req
ret_11 = { NONLOCAL } same as req
_12 = { NONLOCAL } same as req


Alias information for rs6000_ptrace64

Aliased symbols


Call clobber information

ESCAPED, points-to non-local, points-to vars: { }

Flow-insensitive points-to information

addr.2_1, points-to non-local, points-to NULL, points-to vars: { }

rs6000_ptrace64 (int req, int id, long long int addr, int data, void * buf)
{
  int ret;
  int i;
  int * addr.2_1;
  int _2;
  int _3;
  int iftmp.3_4;
  int _12;

  <bb 2> [0.00%]:
  addr.2_1 = (int *) addr_5(D);
  i_7 = *addr.2_1;
  _2 = rand ();
  _3 = _2 % 2;
  if (_3 == 1)
    goto <bb 4>; [0.00%]
  else
    goto <bb 3>; [0.00%]

  <bb 3> [0.00%]:

  <bb 4> [0.00%]:
  # iftmp.3_4 = PHI <1(2), -1(3)>
  ret_11 = iftmp.3_4;
  _12 = iftmp.3_4;
  return iftmp.3_4;

}



;; Function discard_my_cleanups (discard_my_cleanups, funcdef_no=47, decl_uid=3165, cgraph_uid=47, symbol_order=52)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
pmy_chain = &NONLOCAL
old_chain = &NONLOCAL
_1 = *ptr_10
*pmy_chain = _1
_2 = *ptr_10 + 128
_3 = *ptr_10 + 128
_4 = *ptr_10 + 192
ESCAPED = _4
ptr_10 = *pmy_chain
_5 = *ptr_10 + 192
ESCAPED = &NONLOCAL
ESCAPED = &STRING
ESCAPED = _5
_16 = NONLOCAL

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { STRING ESCAPED NONLOCAL }
NONLOCAL = { ESCAPED NONLOCAL } same as _16
STOREDANYTHING = { }
INTEGER = { ANYTHING }
pmy_chain = { NONLOCAL }
old_chain = { NONLOCAL } same as pmy_chain
_1 = { ESCAPED NONLOCAL }
ptr_10 = { ESCAPED NONLOCAL }
_2 = { ESCAPED NONLOCAL }
_3 = { ESCAPED NONLOCAL }
_4 = { ESCAPED NONLOCAL }
_5 = { ESCAPED NONLOCAL }
__printf_chk = { }
_16 = { ESCAPED NONLOCAL }


Alias information for discard_my_cleanups

Aliased symbols


Call clobber information

ESCAPED, points-to non-local, points-to vars: { }

Flow-insensitive points-to information

_1, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_2, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_3, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_4, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_5, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
pmy_chain_9(D), points-to non-local, points-to NULL, points-to vars: { }
ptr_10, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
old_chain_11(D), points-to non-local, points-to NULL, points-to vars: { }

discard_my_cleanups (struct cleanup * * pmy_chain, struct cleanup * old_chain)
{
  int D.3358;
  struct cleanup * ptr;
  struct cleanup * _1;
  void (*<Ted>) (void *) _2;
  void (*<Ted>) (void *) _3;
  void * _4;
  void * _5;
  int _16;

  <bb 2> [0.00%]:
  goto <bb 6>; [0.00%]

  <bb 3> [0.00%]:
  _1 = ptr_10->next;
  *pmy_chain_9(D) = _1;
  _2 = ptr_10->free_arg;
  if (_2 != 0B)
    goto <bb 4>; [0.00%]
  else
    goto <bb 5>; [0.00%]

  <bb 4> [0.00%]:
  _3 = ptr_10->free_arg;
  _4 = ptr_10->arg;
  _3 (_4);

  <bb 5> [0.00%]:
  free (ptr_10);

  <bb 6> [0.00%]:
  ptr_10 = *pmy_chain_9(D);
  if (ptr_10 != old_chain_11(D))
    goto <bb 3>; [0.00%]
  else
    goto <bb 7>; [0.00%]

  <bb 7> [100.00%]:
  _5 = ptr_10->arg;
  _16 = __printf_chk (1, "freearg: %x\n", _5);
  return;

}



;; Function discard_cleanups (discard_cleanups, funcdef_no=45, decl_uid=3162, cgraph_uid=45, symbol_order=50)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
old_chain = &NONLOCAL
cleanup_chain = NONLOCAL
ESCAPED = &cleanup_chain
ESCAPED = old_chain

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { ESCAPED NONLOCAL cleanup_chain }
NONLOCAL = { ESCAPED NONLOCAL }
STOREDANYTHING = { }
INTEGER = { ANYTHING }
old_chain = { NONLOCAL }
discard_my_cleanups = { }
cleanup_chain = { ESCAPED NONLOCAL }


Alias information for discard_cleanups

Aliased symbols


Call clobber information

ESCAPED, points-to non-local, points-to vars: { D.3159 } (nonlocal, escaped)

Flow-insensitive points-to information

old_chain_2(D), points-to non-local, points-to NULL, points-to vars: { }

discard_cleanups (struct cleanup * old_chain)
{
  <bb 2> [0.00%]:
  discard_my_cleanups (&cleanup_chain, old_chain_2(D));
  return;

}



;; Function discard_final_cleanups (discard_final_cleanups, funcdef_no=46, decl_uid=3167, cgraph_uid=46, symbol_order=51)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
old_chain = &NONLOCAL
final_cleanup_chain = NONLOCAL
ESCAPED = &final_cleanup_chain
ESCAPED = old_chain

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { ESCAPED NONLOCAL final_cleanup_chain }
NONLOCAL = { ESCAPED NONLOCAL }
STOREDANYTHING = { }
INTEGER = { ANYTHING }
old_chain = { NONLOCAL }
discard_my_cleanups = { }
final_cleanup_chain = { ESCAPED NONLOCAL }


Alias information for discard_final_cleanups

Aliased symbols


Call clobber information

ESCAPED, points-to non-local, points-to vars: { D.3160 } (nonlocal, escaped)

Flow-insensitive points-to information

old_chain_2(D), points-to non-local, points-to NULL, points-to vars: { }

discard_final_cleanups (struct cleanup * old_chain)
{
  <bb 2> [0.00%]:
  discard_my_cleanups (&final_cleanup_chain, old_chain_2(D));
  return;

}



;; Function do_cleanups (do_cleanups, funcdef_no=49, decl_uid=3172, cgraph_uid=49, symbol_order=54)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
old_chain = &NONLOCAL
cleanup_chain = NONLOCAL
ESCAPED = &cleanup_chain
ESCAPED = old_chain

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { ESCAPED NONLOCAL cleanup_chain }
NONLOCAL = { ESCAPED NONLOCAL }
STOREDANYTHING = { }
INTEGER = { ANYTHING }
old_chain = { NONLOCAL }
do_my_cleanups = { }
cleanup_chain = { ESCAPED NONLOCAL }


Alias information for do_cleanups

Aliased symbols


Call clobber information

ESCAPED, points-to non-local, points-to vars: { D.3159 } (nonlocal, escaped)

Flow-insensitive points-to information

old_chain_2(D), points-to non-local, points-to NULL, points-to vars: { }

do_cleanups (struct cleanup * old_chain)
{
  <bb 2> [0.00%]:
  do_my_cleanups (&cleanup_chain, old_chain_2(D));
  return;

}



;; Function make_cleanup (make_cleanup, funcdef_no=52, decl_uid=3185, cgraph_uid=52, symbol_order=57)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
function = &NONLOCAL
arg = &NONLOCAL
cleanup_chain = NONLOCAL
ESCAPED = &cleanup_chain
ESCAPED = function
ESCAPED = arg
_5 = NONLOCAL
ESCAPED = _5

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { ESCAPED NONLOCAL cleanup_chain }
NONLOCAL = { ESCAPED NONLOCAL } same as _5
STOREDANYTHING = { }
INTEGER = { ANYTHING }
function = { NONLOCAL }
arg = { NONLOCAL } same as function
make_my_cleanup = { }
cleanup_chain = { ESCAPED NONLOCAL }
_5 = { ESCAPED NONLOCAL }


Alias information for make_cleanup

Aliased symbols


Call clobber information

ESCAPED, points-to non-local, points-to vars: { D.3159 } (nonlocal, escaped)

Flow-insensitive points-to information

function_2(D), points-to non-local, points-to NULL, points-to vars: { }
arg_3(D), points-to non-local, points-to NULL, points-to vars: { }
_5, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }

make_cleanup (void (*<Ta1d>) (void *) function, void * arg)
{
  struct cleanup * _5;

  <bb 2> [0.00%]:
  _5 = make_my_cleanup (&cleanup_chain, function_2(D), arg_3(D));
  return _5;

}



;; Function xrealloc (xrealloc, funcdef_no=53, decl_uid=3240, cgraph_uid=53, symbol_order=58)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
oldmem = &NONLOCAL
size = &NONLOCAL
size_1 = size
size_1 = &NONLOCAL
ESCAPED = size_1
newmem_11 = &HEAP(13)
newmem_9 = &HEAP(15)
doubledereftmp(16) = *oldmem
*newmem_9 = doubledereftmp(16)
newmem_9 = oldmem
newmem_2 = newmem_11
newmem_2 = newmem_9
ESCAPED = &NONLOCAL
_12 = newmem_2
ESCAPED = newmem_2

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { ESCAPED NONLOCAL HEAP(13) HEAP(15) }
NONLOCAL = { ESCAPED NONLOCAL }
STOREDANYTHING = { }
INTEGER = { ANYTHING }
oldmem = { NONLOCAL }
size = { NONLOCAL } same as oldmem
size_1 = { NONLOCAL } same as oldmem
malloc = { }
newmem_11 = { HEAP(13) }
HEAP(13) = { ESCAPED NONLOCAL }
newmem_9 = { NONLOCAL HEAP(15) }
HEAP(15) = { ESCAPED NONLOCAL }
doubledereftmp(16) = { ESCAPED NONLOCAL }
newmem_2 = { NONLOCAL HEAP(13) HEAP(15) }
exit = { }
_12 = { NONLOCAL HEAP(13) HEAP(15) } same as newmem_2


Alias information for xrealloc

Aliased symbols


Call clobber information

ESCAPED, points-to non-local, points-to vars: { D.3359 D.3360 } (escaped, escaped heap)

Flow-insensitive points-to information

newmem_2, points-to non-local, points-to NULL, points-to vars: { D.3359 D.3360 } (escaped, escaped heap)
oldmem_6(D), points-to non-local, points-to NULL, points-to vars: { }
newmem_9, points-to non-local, points-to NULL, points-to vars: { D.3360 } (escaped, escaped heap)
newmem_11, points-to NULL, points-to vars: { D.3359 } (escaped, escaped heap)
_12, points-to non-local, points-to NULL, points-to vars: { D.3359 D.3360 } (escaped, escaped heap)

xrealloc (void * oldmem, size_t size)
{
  void * newmem;
  void * _12;

  <bb 2> [0.00%]:
  if (size_4(D) == 0)
    goto <bb 3>; [0.00%]
  else
    goto <bb 4>; [0.00%]

  <bb 3> [0.00%]:

  <bb 4> [0.00%]:
  # size_1 = PHI <size_4(D)(2), 1(3)>
  if (oldmem_6(D) == 0B)
    goto <bb 5>; [0.00%]
  else
    goto <bb 6>; [0.00%]

  <bb 5> [0.00%]:
  newmem_11 = malloc (size_1);
  goto <bb 7>; [0.00%]

  <bb 6> [0.00%]:
  newmem_9 = realloc (oldmem_6(D), size_1);

  <bb 7> [0.00%]:
  # newmem_2 = PHI <newmem_11(5), newmem_9(6)>
  if (newmem_2 == 0B)
    goto <bb 8>; [0.00%]
  else
    goto <bb 9>; [0.00%]

  <bb 8> [0.00%]:
  exit (1);

  <bb 9> [0.00%]:
  _12 = newmem_2;
  return newmem_2;

}



;; Function rs6000_ptrace_ldinfo (rs6000_ptrace_ldinfo, funcdef_no=56, decl_uid=3256, cgraph_uid=56, symbol_order=61)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
ESCAPED = &NONLOCAL
ldi_11 = &HEAP(10)
ldi_size_4 = &NONLOCAL
ldi_size_4 = ldi_size_15
ldi_5 = ldi_11
ldi_5 = ldi_17
ldi.1_2 = ldi_5
ESCAPED = &NONLOCAL
ESCAPED = &NONLOCAL
ESCAPED = ldi.1_2
ESCAPED = ldi_size_4
ESCAPED = &NULL
rc_14 = NONLOCAL
ldi_size_15 = ldi_size_4
ldi_size_15 = &NONLOCAL
_3 = ldi_size_15
ESCAPED = ldi_5
ESCAPED = _3
ldi_17 = NONLOCAL
ESCAPED = ldi_5

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { NULL ESCAPED NONLOCAL HEAP(10) }
NONLOCAL = { ESCAPED NONLOCAL } same as ldi_17
STOREDANYTHING = { }
INTEGER = { ANYTHING }
malloc = { }
ldi_11 = { HEAP(10) }
HEAP(10) = { ESCAPED NONLOCAL }
ldi_size_4 = { NONLOCAL }
ldi_size_15 = { NONLOCAL } same as ldi_size_4
ldi_5 = { ESCAPED NONLOCAL HEAP(10) }
ldi_17 = { ESCAPED NONLOCAL }
ldi.1_2 = { ESCAPED NONLOCAL HEAP(10) } same as ldi_5
rs6000_ptrace64 = { }
rc_14 = { ESCAPED NONLOCAL } same as ldi_17
_3 = { NONLOCAL } same as ldi_size_4
xrealloc = { }


Alias information for rs6000_ptrace_ldinfo

Aliased symbols


Call clobber information

ESCAPED, points-to non-local, points-to NULL, points-to vars: { D.3361 } (escaped, escaped heap)

Flow-insensitive points-to information

ldi_5, points-to non-local, points-to escaped, points-to NULL, points-to vars: { D.3361 } (escaped, escaped heap)
ldi_11, points-to NULL, points-to vars: { D.3361 } (escaped, escaped heap)
ldi_17, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }

rs6000_ptrace_ldinfo ()
{
  int rc;
  void * ldi;
  int ldi_size;
  const int pid;
  long long int ldi.1_2;
  long unsigned int _3;

  <bb 2> [0.00%]:
  ldi_11 = malloc (1024);

  <bb 3> [0.00%]:
  # ldi_size_4 = PHI <1024(2), ldi_size_15(4)>
  # ldi_5 = PHI <ldi_11(2), ldi_17(4)>
  ldi.1_2 = (long long int) ldi_5;
  rc_14 = rs6000_ptrace64 (1, 1, ldi.1_2, ldi_size_4, 0B);
  if (rc_14 != -1)
    goto <bb 5>; [0.00%]
  else
    goto <bb 4>; [0.00%]

  <bb 4> [0.00%]:
  ldi_size_15 = ldi_size_4 * 2;
  _3 = (long unsigned int) ldi_size_15;
  ldi_17 = xrealloc (ldi_5, _3);
  goto <bb 3>; [0.00%]

  <bb 5> [0.00%]:
  return ldi_5;

}



;; Function remote_filename_p (remote_filename_p, funcdef_no=54, decl_uid=3244, cgraph_uid=54, symbol_order=59)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
filename = &NONLOCAL
CALLUSED(10) = CALLUSED(10) + UNKNOWN
CALLUSED(10) = *CALLUSED(10) + UNKNOWN
CALLUSED(10) = filename
CALLUSED(10) = &STRING
CALLUSED(10) = &NONLOCAL
_1 = CALLUSED(10)
_1 = NONLOCAL
_5 = _2
ESCAPED = _5

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { }
NONLOCAL = { ESCAPED NONLOCAL }
STOREDANYTHING = { }
INTEGER = { ANYTHING }
filename = { NONLOCAL }
strncmp = { }
CALLUSED(10) = { STRING ESCAPED NONLOCAL }
CALLCLOBBERED(11) = { }
_1 = { STRING ESCAPED NONLOCAL }
_2 = { }
_5 = { }


Alias information for remote_filename_p

Aliased symbols


Call clobber information

ESCAPED, points-to vars: { }

Flow-insensitive points-to information

filename_4(D), points-to non-local, points-to NULL, points-to vars: { }

remote_filename_p (const char * filename)
{
  int _1;
  _Bool _2;
  int _5;

  <bb 2> [0.00%]:
  _1 = strncmp (filename_4(D), "remote:", 7);
  _2 = _1 == 0;
  _5 = (int) _2;
  return _5;

}



;; Function rs6000_aix_ld_info_to_xml (rs6000_aix_ld_info_to_xml, funcdef_no=57, decl_uid=3265, cgraph_uid=57, symbol_order=62)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
ldi_buf = &NONLOCAL
_1 = *ldi_buf
i_4 = _1
_5 = _1
ESCAPED = _5

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { ESCAPED NONLOCAL }
NONLOCAL = { ESCAPED NONLOCAL }
STOREDANYTHING = { }
INTEGER = { ANYTHING }
ldi_buf = { NONLOCAL }
_1 = { ESCAPED NONLOCAL }
i_4 = { ESCAPED NONLOCAL } same as _1
_5 = { ESCAPED NONLOCAL } same as _1


Alias information for rs6000_aix_ld_info_to_xml

Aliased symbols


Call clobber information

ESCAPED, points-to non-local, points-to vars: { }

Flow-insensitive points-to information

ldi_buf_3(D), points-to non-local, points-to NULL, points-to vars: { }

rs6000_aix_ld_info_to_xml (const gdb_byte * ldi_buf)
{
  int i;
  unsigned char _1;
  ULONGEST _5;

  <bb 2> [0.00%]:
  _1 = *ldi_buf_3(D);
  i_4 = (int) _1;
  _5 = (ULONGEST) _1;
  return _5;

}



;; Function rs6000_xfer_shared_libraries (rs6000_xfer_shared_libraries, funcdef_no=58, decl_uid=3270, cgraph_uid=58, symbol_order=63)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
writebuf = &NONLOCAL
xfered_len = &NONLOCAL
ldi_buf_6 = NONLOCAL
ESCAPED = &NONLOCAL
ESCAPED = &free
ESCAPED = ldi_buf_6
cleanup_8 = NONLOCAL
CALLUSED(17) = CALLUSED(17) + UNKNOWN
CALLUSED(17) = *CALLUSED(17) + UNKNOWN
CALLUSED(17) = ldi_buf_6
result_10 = CALLUSED(17)
result_10 = NONLOCAL
ESCAPED = cleanup_8
*xfered_len = result_10
_1 = &NONLOCAL
_1 = &NULL
_1 = &NONLOCAL
ESCAPED = _1

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { NULL ESCAPED NONLOCAL free }
NONLOCAL = { ESCAPED NONLOCAL } same as ldi_buf_6
STOREDANYTHING = { }
INTEGER = { ANYTHING }
writebuf = { NONLOCAL }
xfered_len = { NONLOCAL } same as writebuf
rs6000_ptrace_ldinfo = { }
ldi_buf_6 = { ESCAPED NONLOCAL }
exit = { }
make_cleanup = { }
free = { ESCAPED NONLOCAL }
cleanup_8 = { ESCAPED NONLOCAL } same as ldi_buf_6
rs6000_aix_ld_info_to_xml = { }
CALLUSED(17) = { ESCAPED NONLOCAL }
CALLCLOBBERED(18) = { }
result_10 = { ESCAPED NONLOCAL } same as CALLUSED(17)
do_cleanups = { }
_1 = { NULL NONLOCAL }


Alias information for rs6000_xfer_shared_libraries

Aliased symbols


Call clobber information

ESCAPED, points-to non-local, points-to NULL, points-to vars: { } (nonlocal, escaped)

Flow-insensitive points-to information

writebuf_3(D), points-to non-local, points-to NULL, points-to vars: { }
ldi_buf_6, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
cleanup_8, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
xfered_len_13(D), points-to non-local, points-to NULL, points-to vars: { }

rs6000_xfer_shared_libraries (const gdb_byte * writebuf, ULONGEST * xfered_len)
{
  struct cleanup * cleanup;
  ULONGEST result;
  gdb_byte * ldi_buf;
  target_xfer_status _1;

  <bb 2> [0.00%]:
  if (writebuf_3(D) != 0B)
    goto <bb 7>; [0.00%]
  else
    goto <bb 3>; [0.00%]

  <bb 3> [0.00%]:
  ldi_buf_6 = rs6000_ptrace_ldinfo ();
  if (ldi_buf_6 == 0B)
    goto <bb 4>; [0.00%]
  else
    goto <bb 5>; [0.00%]

  <bb 4> [0.00%]:
  exit (1);

  <bb 5> [0.00%]:
  cleanup_8 = make_cleanup (free, ldi_buf_6);
  result_10 = rs6000_aix_ld_info_to_xml (ldi_buf_6);
  free (ldi_buf_6);
  do_cleanups (cleanup_8);
  if (result_10 == 0)
    goto <bb 7>; [0.00%]
  else
    goto <bb 6>; [0.00%]

  <bb 6> [0.00%]:
  *xfered_len_13(D) = result_10;

  <bb 7> [0.00%]:
  # _1 = PHI <-1(2), 0(5), 1(6)>
  return _1;

}



;; Function main (main, funcdef_no=59, decl_uid=3275, cgraph_uid=59, symbol_order=64)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
ESCAPED = &t
_1 = NONLOCAL
_2 = _1
ESCAPED = _2
_3 = NONLOCAL
_4 = _3
_4 = &NONLOCAL
iftmp.0_5 = &buf
iftmp.0_5 = &NULL
ESCAPED = iftmp.0_5
ESCAPED = &len
ESCAPED = &NULL

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { NULL ESCAPED NONLOCAL t buf len }
NONLOCAL = { ESCAPED NONLOCAL } same as _1
STOREDANYTHING = { }
INTEGER = { ANYTHING }
time = { }
t = { ESCAPED NONLOCAL }
_1 = { ESCAPED NONLOCAL }
_2 = { ESCAPED NONLOCAL } same as _1
srand = { }
rand = { }
_3 = { ESCAPED NONLOCAL } same as _1
_4 = { ESCAPED NONLOCAL } same as _1
iftmp.0_5 = { NULL buf }
buf = { ESCAPED NONLOCAL }
rs6000_xfer_shared_libraries = { }
len = { ESCAPED NONLOCAL }


Alias information for main

Aliased symbols

len, UID D.3280, int, is addressable
buf, UID D.3279, char[10], is addressable
t, UID D.3277, time_t, is addressable

Call clobber information

ESCAPED, points-to non-local, points-to NULL, points-to vars: { D.3277 D.3279 D.3280 } (escaped)

Flow-insensitive points-to information

iftmp.0_5, points-to NULL, points-to vars: { D.3279 } (escaped)

main ()
{
  ULONGEST * xfered_len;
  gdb_byte * writebuf;
  int len;
  char buf[10];
  time_t t;
  int _1;
  unsigned int _2;
  int _3;
  int _4;
  gdb_byte * iftmp.0_5;

  <bb 2> [0.00%]:
  _1 = time (&t);
  _2 = (unsigned int) _1;
  srand (_2);
  _3 = rand ();
  _4 = _3 % 2;
  if (_4 == 1)
    goto <bb 4>; [0.00%]
  else
    goto <bb 3>; [0.00%]

  <bb 3> [0.00%]:

  <bb 4> [0.00%]:
  # iftmp.0_5 = PHI <&buf(2), 0B(3)>
  rs6000_xfer_shared_libraries (iftmp.0_5, &len);
  t ={v} {CLOBBER};
  buf ={v} {CLOBBER};
  len ={v} {CLOBBER};
  return 0;

}


