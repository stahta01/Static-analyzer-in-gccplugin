
;; Function printf (printf, funcdef_no=15, decl_uid=798, cgraph_uid=15, symbol_order=15)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
__fmt = &PARM_NOALIAS(9)
PARM_NOALIAS(9) = &NONLOCAL
ESCAPED = &NONLOCAL
ESCAPED = __fmt
_4 = NONLOCAL
ESCAPED = _4

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { ESCAPED NONLOCAL PARM_NOALIAS(9) }
NONLOCAL = { ESCAPED NONLOCAL } same as _4
STOREDANYTHING = { }
INTEGER = { ANYTHING }
__fmt = { PARM_NOALIAS(9) }
PARM_NOALIAS(9) = { ESCAPED NONLOCAL }
__printf_chk = { }
_4 = { ESCAPED NONLOCAL }


Alias information for printf

Aliased symbols


Call clobber information

ESCAPED, points-to non-local, points-to vars: { D.3555 } (nonlocal, escaped, restrict)

Flow-insensitive points-to information

__fmt_2(D), points-to NULL, points-to vars: { D.3555 } (nonlocal, escaped, restrict)

__attribute__((__artificial__, __gnu_inline__, __always_inline__))
printf (const char * restrict __fmt)
{
  int _4;

  <bb 2> [0.00%]:
  _4 = __printf_chk (1, __fmt_2(D), __builtin_va_arg_pack ());
  return _4;

}



;; Function do_my_cleanups (do_my_cleanups, funcdef_no=42, decl_uid=3111, cgraph_uid=42, symbol_order=47)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
pmy_chain = &NONLOCAL
old_chain = &NONLOCAL
_1 = *ptr_12
*pmy_chain = _1
_2 = *ptr_12 + 64
_3 = *ptr_12 + 192
ESCAPED = _3
ESCAPED = &NONLOCAL
ESCAPED = &STRING
_21 = NONLOCAL
_4 = *ptr_12 + 192
ESCAPED = &NONLOCAL
ESCAPED = &STRING
ESCAPED = _4
_20 = NONLOCAL
_5 = *ptr_12 + 128
_6 = *ptr_12 + 128
_7 = *ptr_12 + 192
ESCAPED = _7
ptr_12 = *pmy_chain

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { STRING ESCAPED NONLOCAL }
NONLOCAL = { ESCAPED NONLOCAL } same as _21
STOREDANYTHING = { }
INTEGER = { ANYTHING }
pmy_chain = { NONLOCAL }
old_chain = { NONLOCAL } same as pmy_chain
_1 = { ESCAPED NONLOCAL }
ptr_12 = { ESCAPED NONLOCAL }
_2 = { ESCAPED NONLOCAL }
_3 = { ESCAPED NONLOCAL }
__printf_chk = { }
_21 = { ESCAPED NONLOCAL }
_4 = { ESCAPED NONLOCAL }
_20 = { ESCAPED NONLOCAL } same as _21
_5 = { ESCAPED NONLOCAL }
_6 = { ESCAPED NONLOCAL }
_7 = { ESCAPED NONLOCAL }


Alias information for do_my_cleanups

Aliased symbols


Call clobber information

ESCAPED, points-to non-local, points-to vars: { }

Flow-insensitive points-to information

_1, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_2, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_3, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_4, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_5, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_6, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_7, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
pmy_chain_11(D), points-to non-local, points-to NULL, points-to vars: { }
ptr_12, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
old_chain_13(D), points-to non-local, points-to NULL, points-to vars: { }

do_my_cleanups (struct cleanup * * pmy_chain, struct cleanup * old_chain)
{
  int D.3559;
  int D.3557;
  struct cleanup * ptr;
  struct cleanup * _1;
  void (*<Ted>) (void *) _2;
  void * _3;
  void * _4;
  void (*<Ted>) (void *) _5;
  void (*<Ted>) (void *) _6;
  void * _7;
  int _20;
  int _21;

  <bb 2> [0.00%]:
  goto <bb 6>; [0.00%]

  <bb 3> [100.00%]:
  _1 = ptr_12->next;
  *pmy_chain_11(D) = _1;
  _2 = ptr_12->function;
  _3 = ptr_12->arg;
  _2 (_3);
  _21 = __printf_chk (1, "cleanup!!!!! =========\n");
  _4 = ptr_12->arg;
  _20 = __printf_chk (1, "%x\n", _4);
  _5 = ptr_12->free_arg;
  if (_5 != 0B)
    goto <bb 4>; [0.00%]
  else
    goto <bb 5>; [0.00%]

  <bb 4> [0.00%]:
  _6 = ptr_12->free_arg;
  _7 = ptr_12->arg;
  _6 (_7);

  <bb 5> [0.00%]:
  free (ptr_12);

  <bb 6> [0.00%]:
  ptr_12 = *pmy_chain_11(D);
  if (ptr_12 != old_chain_13(D))
    goto <bb 3>; [0.00%]
  else
    goto <bb 7>; [0.00%]

  <bb 7> [0.00%]:
  return;

}



;; Function make_my_cleanup2 (make_my_cleanup2, funcdef_no=44, decl_uid=3119, cgraph_uid=44, symbol_order=49)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
pmy_chain = &NONLOCAL
function = &NONLOCAL
arg = &NONLOCAL
free_arg = &NONLOCAL
ESCAPED = &NONLOCAL
new_4 = &HEAP(14)
old_chain_6 = *pmy_chain
_1 = *pmy_chain
*new_4 = _1
*new_4 + 64 = function
*new_4 + 128 = free_arg
*new_4 + 192 = arg
*pmy_chain = new_4
ESCAPED = &NONLOCAL
ESCAPED = old_chain_6

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { ESCAPED NONLOCAL HEAP(14) }
NONLOCAL = { ESCAPED NONLOCAL }
STOREDANYTHING = { }
INTEGER = { ANYTHING }
pmy_chain = { NONLOCAL }
function = { NONLOCAL } same as pmy_chain
arg = { NONLOCAL } same as pmy_chain
free_arg = { NONLOCAL } same as pmy_chain
malloc = { }
new_4 = { HEAP(14) }
HEAP(14) = { ESCAPED NONLOCAL }
old_chain_6 = { ESCAPED NONLOCAL }
_1 = { ESCAPED NONLOCAL } same as old_chain_6
exit = { }


Alias information for make_my_cleanup2

Aliased symbols


Call clobber information

ESCAPED, points-to non-local, points-to vars: { D.3560 } (escaped, escaped heap)

Flow-insensitive points-to information

_1, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
new_4, points-to NULL, points-to vars: { D.3560 } (escaped, escaped heap)
pmy_chain_5(D), points-to non-local, points-to NULL, points-to vars: { }
old_chain_6, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
function_8(D), points-to non-local, points-to NULL, points-to vars: { }
free_arg_10(D), points-to non-local, points-to NULL, points-to vars: { }
arg_12(D), points-to non-local, points-to NULL, points-to vars: { }

make_my_cleanup2 (struct cleanup * * pmy_chain, void (*<T9e0>) (void *) function, void * arg, void (*<Ted>) (void *) free_arg)
{
  struct cleanup * old_chain;
  struct cleanup * new;
  struct cleanup * _1;

  <bb 2> [0.00%]:
  new_4 = malloc (32);
  old_chain_6 = *pmy_chain_5(D);
  _1 = *pmy_chain_5(D);
  new_4->next = _1;
  new_4->function = function_8(D);
  new_4->free_arg = free_arg_10(D);
  new_4->arg = arg_12(D);
  *pmy_chain_5(D) = new_4;
  if (old_chain_6 == 0B)
    goto <bb 3>; [0.00%]
  else
    goto <bb 4>; [0.00%]

  <bb 3> [0.00%]:
  exit (1);

  <bb 4> [0.00%]:
  return old_chain_6;

}



;; Function make_my_cleanup (make_my_cleanup, funcdef_no=45, decl_uid=3123, cgraph_uid=45, symbol_order=50)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
pmy_chain = &NONLOCAL
function = &NONLOCAL
arg = &NONLOCAL
ESCAPED = pmy_chain
ESCAPED = function
ESCAPED = arg
ESCAPED = &NULL
_6 = NONLOCAL
ESCAPED = _6

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { NULL ESCAPED NONLOCAL }
NONLOCAL = { ESCAPED NONLOCAL } same as _6
STOREDANYTHING = { }
INTEGER = { ANYTHING }
pmy_chain = { NONLOCAL }
function = { NONLOCAL } same as pmy_chain
arg = { NONLOCAL } same as pmy_chain
make_my_cleanup2 = { }
_6 = { ESCAPED NONLOCAL }


Alias information for make_my_cleanup

Aliased symbols


Call clobber information

ESCAPED, points-to non-local, points-to NULL, points-to vars: { }

Flow-insensitive points-to information

pmy_chain_2(D), points-to non-local, points-to NULL, points-to vars: { }
function_3(D), points-to non-local, points-to NULL, points-to vars: { }
arg_4(D), points-to non-local, points-to NULL, points-to vars: { }
_6, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }

make_my_cleanup (struct cleanup * * pmy_chain, void (*<T9e0>) (void *) function, void * arg)
{
  struct cleanup * _6;

  <bb 2> [0.00%]:
  _6 = make_my_cleanup2 (pmy_chain_2(D), function_3(D), arg_4(D), 0B);
  return _6;

}



;; Function template_in_dir (template_in_dir, funcdef_no=48, decl_uid=3397, cgraph_uid=48, symbol_order=85)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
path = &NONLOCAL
slash_13 = path
slash_13 = &NULL
slash.0_1 = slash_13
path.1_2 = path
_3 = slash.0_1
_3 = path.1_2
len_17 = _3
_4 = len_17
_4 = &NONLOCAL
ESCAPED = _4
tmpname_19 = &HEAP(17)
doubledereftmp(18) = *path
*tmpname_19 = doubledereftmp(18)
len_21 = len_17
len_21 = &NONLOCAL
_6 = tmpname_19
derefaddrtmp(21) = &NONLOCAL
*_6 = derefaddrtmp(21)
ESCAPED = &NONLOCAL
tmpname_15 = &HEAP(23)
tmpname_8 = tmpname_19
tmpname_8 = tmpname_15
len_9 = len_21
len_9 = &NULL
_7 = tmpname_8
_24 = tmpname_8
ESCAPED = tmpname_8

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { NULL ESCAPED NONLOCAL HEAP(17) HEAP(23) }
NONLOCAL = { ESCAPED NONLOCAL }
STOREDANYTHING = { }
INTEGER = { ANYTHING }
path = { NONLOCAL }
slash_13 = { NULL NONLOCAL }
slash.0_1 = { NULL NONLOCAL } same as slash_13
path.1_2 = { NONLOCAL } same as path
_3 = { NULL NONLOCAL } same as slash_13
len_17 = { NULL NONLOCAL } same as slash_13
_4 = { NULL NONLOCAL } same as slash_13
malloc = { }
tmpname_19 = { HEAP(17) }
HEAP(17) = { ESCAPED NONLOCAL }
doubledereftmp(18) = { ESCAPED NONLOCAL }
len_21 = { NULL NONLOCAL } same as slash_13
_6 = { HEAP(17) } same as tmpname_19
derefaddrtmp(21) = { NONLOCAL } same as path
tmpname_15 = { HEAP(23) }
HEAP(23) = { ESCAPED NONLOCAL }
tmpname_8 = { HEAP(17) HEAP(23) }
len_9 = { NULL NONLOCAL } same as slash_13
_7 = { HEAP(17) HEAP(23) } same as tmpname_8
_24 = { HEAP(17) HEAP(23) } same as tmpname_8


Alias information for template_in_dir

Aliased symbols


Call clobber information

ESCAPED, points-to non-local, points-to NULL, points-to vars: { D.3561 D.3562 } (escaped, escaped heap)

Flow-insensitive points-to information

_6, points-to NULL, points-to vars: { D.3561 } (escaped, escaped heap)
_7, points-to NULL, points-to vars: { D.3561 D.3562 } (escaped, escaped heap)
tmpname_8, points-to NULL, points-to vars: { D.3561 D.3562 } (escaped, escaped heap)
path_12(D), points-to non-local, points-to NULL, points-to vars: { }
slash_13, points-to non-local, points-to NULL, points-to vars: { }
tmpname_15, points-to NULL, points-to vars: { D.3562 } (escaped, escaped heap)
tmpname_19, points-to NULL, points-to vars: { D.3561 } (escaped, escaped heap)
_24, points-to NULL, points-to vars: { D.3561 D.3562 } (escaped, escaped heap)

template_in_dir (const char * path)
{
  size_t len;
  char * tmpname;
  const char * slash;
  long int slash.0_1;
  long int path.1_2;
  long int _3;
  long unsigned int _4;
  char * _6;
  char * _7;
  char * _24;

  <bb 2> [0.00%]:
  slash_13 = strrchr (path_12(D), 47);
  if (slash_13 != 0B)
    goto <bb 3>; [0.00%]
  else
    goto <bb 4>; [0.00%]

  <bb 3> [0.00%]:
  slash.0_1 = (long int) slash_13;
  path.1_2 = (long int) path_12(D);
  _3 = slash.0_1 - path.1_2;
  len_17 = (size_t) _3;
  _4 = len_17 + 11;
  tmpname_19 = malloc (_4);
  memcpy (tmpname_19, path_12(D), len_17);
  len_21 = len_17 + 1;
  _6 = tmpname_19 + len_17;
  *_6 = 47;
  goto <bb 5>; [0.00%]

  <bb 4> [0.00%]:
  tmpname_15 = malloc (9);

  <bb 5> [0.00%]:
  # tmpname_8 = PHI <tmpname_19(3), tmpname_15(4)>
  # len_9 = PHI <len_21(3), 0(4)>
  _7 = tmpname_8 + len_9;
  memcpy (_7, "stXXXXXX", 9);
  _24 = tmpname_8;
  return tmpname_8;

}



;; Function copy_file (copy_file, funcdef_no=53, decl_uid=3441, cgraph_uid=53, symbol_order=90)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
input_filename = &NONLOCAL
output_filename = &NONLOCAL
input_target = &NONLOCAL
output_target = &NONLOCAL
input_arch = &NONLOCAL
_1 = NONLOCAL
_2 = _1
_2 = &NONLOCAL
size_8 = _3
ESCAPED = &NONLOCAL
ESCAPED = &STRING
ESCAPED = input_filename
_12 = NONLOCAL
status = NONLOCAL
status = &NONLOCAL
ESCAPED = &NONLOCAL

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { STRING ESCAPED NONLOCAL }
NONLOCAL = { ESCAPED NONLOCAL } same as _1
STOREDANYTHING = { }
INTEGER = { ANYTHING }
input_filename = { NONLOCAL }
output_filename = { NONLOCAL } same as input_filename
input_target = { NONLOCAL } same as input_filename
output_target = { NONLOCAL } same as input_filename
input_arch = { NONLOCAL } same as input_filename
rand = { }
_1 = { ESCAPED NONLOCAL }
_2 = { ESCAPED NONLOCAL } same as _1
_3 = { }
size_8 = { }
__printf_chk = { }
_12 = { ESCAPED NONLOCAL } same as _1
status = { ESCAPED NONLOCAL } same as _1


Alias information for copy_file

Aliased symbols


Call clobber information

ESCAPED, points-to non-local, points-to vars: { }

Flow-insensitive points-to information

input_filename_9(D), points-to non-local, points-to NULL, points-to vars: { }

copy_file (const char * input_filename, const char * output_filename, const char * input_target, const char * output_target, const struct bfd_arch_info_type * input_arch)
{
  int D.3564;
  off_t size;
  int _1;
  int _2;
  _Bool _3;
  int _12;

  <bb 2> [0.00%]:
  _1 = rand ();
  _2 = _1 % 2;
  _3 = _2 == 1;
  size_8 = (off_t) _3;
  if (_2 != 1)
    goto <bb 3>; [0.00%]
  else
    goto <bb 6>; [0.00%]

  <bb 3> [0.00%]:
  if (_2 != 1)
    goto <bb 4>; [0.00%]
  else
    goto <bb 5>; [0.00%]

  <bb 4> [100.00%]:
  _12 = __printf_chk (1, "error: the input file \'%s\' is empty", input_filename_9(D));

  <bb 5> [0.00%]:
  status = 1;

  <bb 6> [0.00%]:
  return;

}



;; Function discard_my_cleanups (discard_my_cleanups, funcdef_no=41, decl_uid=3106, cgraph_uid=41, symbol_order=46)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
pmy_chain = &NONLOCAL
old_chain = &NONLOCAL
_1 = *ptr_10
*pmy_chain = _1
_2 = *ptr_10 + 128
_3 = *ptr_10 + 128
_4 = *ptr_10 + 192
ESCAPED = _4
ptr_10 = *pmy_chain
_5 = *ptr_10 + 192
ESCAPED = &NONLOCAL
ESCAPED = &STRING
ESCAPED = _5
_16 = NONLOCAL

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { STRING ESCAPED NONLOCAL }
NONLOCAL = { ESCAPED NONLOCAL } same as _16
STOREDANYTHING = { }
INTEGER = { ANYTHING }
pmy_chain = { NONLOCAL }
old_chain = { NONLOCAL } same as pmy_chain
_1 = { ESCAPED NONLOCAL }
ptr_10 = { ESCAPED NONLOCAL }
_2 = { ESCAPED NONLOCAL }
_3 = { ESCAPED NONLOCAL }
_4 = { ESCAPED NONLOCAL }
_5 = { ESCAPED NONLOCAL }
__printf_chk = { }
_16 = { ESCAPED NONLOCAL }


Alias information for discard_my_cleanups

Aliased symbols


Call clobber information

ESCAPED, points-to non-local, points-to vars: { }

Flow-insensitive points-to information

_1, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_2, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_3, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_4, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_5, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
pmy_chain_9(D), points-to non-local, points-to NULL, points-to vars: { }
ptr_10, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
old_chain_11(D), points-to non-local, points-to NULL, points-to vars: { }

discard_my_cleanups (struct cleanup * * pmy_chain, struct cleanup * old_chain)
{
  int D.3566;
  struct cleanup * ptr;
  struct cleanup * _1;
  void (*<Ted>) (void *) _2;
  void (*<Ted>) (void *) _3;
  void * _4;
  void * _5;
  int _16;

  <bb 2> [0.00%]:
  goto <bb 6>; [0.00%]

  <bb 3> [0.00%]:
  _1 = ptr_10->next;
  *pmy_chain_9(D) = _1;
  _2 = ptr_10->free_arg;
  if (_2 != 0B)
    goto <bb 4>; [0.00%]
  else
    goto <bb 5>; [0.00%]

  <bb 4> [0.00%]:
  _3 = ptr_10->free_arg;
  _4 = ptr_10->arg;
  _3 (_4);

  <bb 5> [0.00%]:
  free (ptr_10);

  <bb 6> [0.00%]:
  ptr_10 = *pmy_chain_9(D);
  if (ptr_10 != old_chain_11(D))
    goto <bb 3>; [0.00%]
  else
    goto <bb 7>; [0.00%]

  <bb 7> [100.00%]:
  _5 = ptr_10->arg;
  _16 = __printf_chk (1, "freearg: %x\n", _5);
  return;

}



;; Function discard_cleanups (discard_cleanups, funcdef_no=39, decl_uid=3103, cgraph_uid=39, symbol_order=44)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
old_chain = &NONLOCAL
cleanup_chain = NONLOCAL
ESCAPED = &cleanup_chain
ESCAPED = old_chain

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { ESCAPED NONLOCAL cleanup_chain }
NONLOCAL = { ESCAPED NONLOCAL }
STOREDANYTHING = { }
INTEGER = { ANYTHING }
old_chain = { NONLOCAL }
discard_my_cleanups = { }
cleanup_chain = { ESCAPED NONLOCAL }


Alias information for discard_cleanups

Aliased symbols


Call clobber information

ESCAPED, points-to non-local, points-to vars: { D.3100 } (nonlocal, escaped)

Flow-insensitive points-to information

old_chain_2(D), points-to non-local, points-to NULL, points-to vars: { }

discard_cleanups (struct cleanup * old_chain)
{
  <bb 2> [0.00%]:
  discard_my_cleanups (&cleanup_chain, old_chain_2(D));
  return;

}



;; Function discard_final_cleanups (discard_final_cleanups, funcdef_no=40, decl_uid=3108, cgraph_uid=40, symbol_order=45)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
old_chain = &NONLOCAL
final_cleanup_chain = NONLOCAL
ESCAPED = &final_cleanup_chain
ESCAPED = old_chain

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { ESCAPED NONLOCAL final_cleanup_chain }
NONLOCAL = { ESCAPED NONLOCAL }
STOREDANYTHING = { }
INTEGER = { ANYTHING }
old_chain = { NONLOCAL }
discard_my_cleanups = { }
final_cleanup_chain = { ESCAPED NONLOCAL }


Alias information for discard_final_cleanups

Aliased symbols


Call clobber information

ESCAPED, points-to non-local, points-to vars: { D.3101 } (nonlocal, escaped)

Flow-insensitive points-to information

old_chain_2(D), points-to non-local, points-to NULL, points-to vars: { }

discard_final_cleanups (struct cleanup * old_chain)
{
  <bb 2> [0.00%]:
  discard_my_cleanups (&final_cleanup_chain, old_chain_2(D));
  return;

}



;; Function do_cleanups (do_cleanups, funcdef_no=43, decl_uid=3113, cgraph_uid=43, symbol_order=48)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
old_chain = &NONLOCAL
cleanup_chain = NONLOCAL
ESCAPED = &cleanup_chain
ESCAPED = old_chain

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { ESCAPED NONLOCAL cleanup_chain }
NONLOCAL = { ESCAPED NONLOCAL }
STOREDANYTHING = { }
INTEGER = { ANYTHING }
old_chain = { NONLOCAL }
do_my_cleanups = { }
cleanup_chain = { ESCAPED NONLOCAL }


Alias information for do_cleanups

Aliased symbols


Call clobber information

ESCAPED, points-to non-local, points-to vars: { D.3100 } (nonlocal, escaped)

Flow-insensitive points-to information

old_chain_2(D), points-to non-local, points-to NULL, points-to vars: { }

do_cleanups (struct cleanup * old_chain)
{
  <bb 2> [0.00%]:
  do_my_cleanups (&cleanup_chain, old_chain_2(D));
  return;

}



;; Function make_cleanup (make_cleanup, funcdef_no=46, decl_uid=3126, cgraph_uid=46, symbol_order=51)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
function = &NONLOCAL
arg = &NONLOCAL
cleanup_chain = NONLOCAL
ESCAPED = &cleanup_chain
ESCAPED = function
ESCAPED = arg
_5 = NONLOCAL
ESCAPED = _5

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { ESCAPED NONLOCAL cleanup_chain }
NONLOCAL = { ESCAPED NONLOCAL } same as _5
STOREDANYTHING = { }
INTEGER = { ANYTHING }
function = { NONLOCAL }
arg = { NONLOCAL } same as function
make_my_cleanup = { }
cleanup_chain = { ESCAPED NONLOCAL }
_5 = { ESCAPED NONLOCAL }


Alias information for make_cleanup

Aliased symbols


Call clobber information

ESCAPED, points-to non-local, points-to vars: { D.3100 } (nonlocal, escaped)

Flow-insensitive points-to information

function_2(D), points-to non-local, points-to NULL, points-to vars: { }
arg_3(D), points-to non-local, points-to NULL, points-to vars: { }
_5, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }

make_cleanup (void (*<T9e0>) (void *) function, void * arg)
{
  struct cleanup * _5;

  <bb 2> [0.00%]:
  _5 = make_my_cleanup (&cleanup_chain, function_2(D), arg_3(D));
  return _5;

}



;; Function filename_cmp (filename_cmp, funcdef_no=47, decl_uid=3393, cgraph_uid=47, symbol_order=84)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
s1 = &NONLOCAL
s2 = &NONLOCAL
CALLUSED(11) = CALLUSED(11) + UNKNOWN
CALLUSED(11) = *CALLUSED(11) + UNKNOWN
CALLUSED(11) = s1
CALLUSED(11) = s2
_4 = CALLUSED(11)
_4 = NONLOCAL
ESCAPED = _4

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { ESCAPED NONLOCAL }
NONLOCAL = { ESCAPED NONLOCAL }
STOREDANYTHING = { }
INTEGER = { ANYTHING }
s1 = { NONLOCAL }
s2 = { NONLOCAL } same as s1
strcmp = { }
CALLUSED(11) = { ESCAPED NONLOCAL }
CALLCLOBBERED(12) = { }
_4 = { ESCAPED NONLOCAL }


Alias information for filename_cmp

Aliased symbols


Call clobber information

ESCAPED, points-to non-local, points-to vars: { }

Flow-insensitive points-to information

s1_2(D), points-to non-local, points-to NULL, points-to vars: { }
s2_3(D), points-to non-local, points-to NULL, points-to vars: { }

filename_cmp (const char * s1, const char * s2)
{
  int _4;

  <bb 2> [0.00%]:
  _4 = strcmp (s1_2(D), s2_3(D));
  return _4;

}



;; Function make_tempname (make_tempname, funcdef_no=49, decl_uid=3406, cgraph_uid=49, symbol_order=86)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
filename = &NONLOCAL
ESCAPED = filename
tmpname_6 = NONLOCAL
ESCAPED = tmpname_6
fd_8 = NONLOCAL
ESCAPED = fd_8
_1 = &NULL
_1 = tmpname_6
ESCAPED = _1

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { NULL ESCAPED NONLOCAL }
NONLOCAL = { ESCAPED NONLOCAL } same as tmpname_6
STOREDANYTHING = { }
INTEGER = { ANYTHING }
filename = { NONLOCAL }
template_in_dir = { }
tmpname_6 = { ESCAPED NONLOCAL }
mkstemp = { }
fd_8 = { ESCAPED NONLOCAL } same as tmpname_6
close = { }
_1 = { NULL ESCAPED NONLOCAL }


Alias information for make_tempname

Aliased symbols


Call clobber information

ESCAPED, points-to non-local, points-to NULL, points-to vars: { }

Flow-insensitive points-to information

_1, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
filename_4(D), points-to non-local, points-to NULL, points-to vars: { }
tmpname_6, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }

make_tempname (char * filename)
{
  int fd;
  char * tmpname;
  char * _1;

  <bb 2> [0.00%]:
  tmpname_6 = template_in_dir (filename_4(D));
  fd_8 = mkstemp (tmpname_6);
  if (fd_8 == -1)
    goto <bb 3>; [0.00%]
  else
    goto <bb 4>; [0.00%]

  <bb 3> [0.00%]:
  free (tmpname_6);
  goto <bb 5>; [0.00%]

  <bb 4> [0.00%]:
  close (fd_8);

  <bb 5> [0.00%]:
  # _1 = PHI <0B(3), tmpname_6(4)>
  return _1;

}



;; Function set_times (set_times, funcdef_no=50, decl_uid=3414, cgraph_uid=50, symbol_order=87)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
destination = &NONLOCAL
statbuf = &NONLOCAL
_1 = *statbuf + 576
tb = _1
_2 = *statbuf + 704
tb = _2
ESCAPED = destination
ESCAPED = &tb
result_10 = NONLOCAL
ESCAPED = &NONLOCAL
ESCAPED = &STRING
ESCAPED = destination
_13 = NONLOCAL

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { STRING ESCAPED NONLOCAL tb }
NONLOCAL = { ESCAPED NONLOCAL } same as result_10
STOREDANYTHING = { }
INTEGER = { ANYTHING }
destination = { NONLOCAL }
statbuf = { NONLOCAL } same as destination
_1 = { ESCAPED NONLOCAL }
tb = { ESCAPED NONLOCAL }
_2 = { ESCAPED NONLOCAL }
utime = { }
result_10 = { ESCAPED NONLOCAL }
__printf_chk = { }
_13 = { ESCAPED NONLOCAL } same as result_10


Alias information for set_times

Aliased symbols

tb, UID D.3417, long int[2], is addressable

Call clobber information

ESCAPED, points-to non-local, points-to vars: { D.3417 } (escaped)

Flow-insensitive points-to information

statbuf_5(D), points-to non-local, points-to NULL, points-to vars: { }
destination_8(D), points-to non-local, points-to NULL, points-to vars: { }

set_times (const char * destination, const struct stat * statbuf)
{
  int D.3568;
  long int tb[2];
  int result;
  long int _1;
  long int _2;
  int _13;

  <bb 2> [0.00%]:
  _1 = statbuf_5(D)->st_atim.tv_sec;
  tb[0] = _1;
  _2 = statbuf_5(D)->st_mtim.tv_sec;
  tb[1] = _2;
  result_10 = utime (destination_8(D), &tb);
  tb ={v} {CLOBBER};
  if (result_10 != 0)
    goto <bb 3>; [0.00%]
  else
    goto <bb 4>; [0.00%]

  <bb 3> [100.00%]:
  _13 = __printf_chk (1, "%s: cannot set time:", destination_8(D));

  <bb 4> [0.00%]:
  return;

}



;; Function smart_rename (smart_rename, funcdef_no=51, decl_uid=3423, cgraph_uid=51, symbol_order=88)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
from = &NONLOCAL
to = &NONLOCAL
preserve_dates = &NONLOCAL
ESCAPED = to
ESCAPED = &s
_1 = NONLOCAL
exists_21 = _2
_3 = s
_4 = _3
_5 = s
ESCAPED = from
ESCAPED = to
ret_28 = NONLOCAL
_6 = s
_7 = _6
ESCAPED = to
ESCAPED = _7
_8 = s
_9 = s
ESCAPED = to
ESCAPED = _9
ESCAPED = _8
_10 = NONLOCAL
_11 = s
_12 = _11
ESCAPED = to
ESCAPED = _12
ESCAPED = &NONLOCAL
ESCAPED = &STRING
ESCAPED = to
_36 = NONLOCAL
ESCAPED = from
ESCAPED = to
ESCAPED = &s
ESCAPED = from
ret_13 = ret_28
ret_13 = &NULL
ret_13 = ret_28
ret_13 = ret_28
ret_13 = ret_28
ESCAPED = ret_13

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { NULL STRING ESCAPED NONLOCAL s }
NONLOCAL = { ESCAPED NONLOCAL } same as _1
STOREDANYTHING = { }
INTEGER = { ANYTHING }
from = { NONLOCAL }
to = { NONLOCAL } same as from
preserve_dates = { NONLOCAL } same as from
lstat = { }
s = { ESCAPED NONLOCAL } same as _3
_1 = { ESCAPED NONLOCAL }
_2 = { }
exists_21 = { }
_3 = { ESCAPED NONLOCAL }
_4 = { ESCAPED NONLOCAL } same as _3
_5 = { ESCAPED NONLOCAL } same as _3
rename = { }
ret_28 = { ESCAPED NONLOCAL } same as _1
_6 = { ESCAPED NONLOCAL } same as _3
_7 = { ESCAPED NONLOCAL } same as _3
chmod = { }
_8 = { ESCAPED NONLOCAL } same as _3
_9 = { ESCAPED NONLOCAL } same as _3
chown = { }
_10 = { ESCAPED NONLOCAL } same as _1
_11 = { ESCAPED NONLOCAL } same as _3
_12 = { ESCAPED NONLOCAL } same as _3
__printf_chk = { }
_36 = { ESCAPED NONLOCAL } same as _1
unlink = { }
set_times = { }
ret_13 = { NULL ESCAPED NONLOCAL }


Alias information for smart_rename

Aliased symbols

s, UID D.3426, struct stat, is addressable

Call clobber information

ESCAPED, points-to non-local, points-to NULL, points-to vars: { D.3426 } (escaped)

Flow-insensitive points-to information

to_19(D), points-to non-local, points-to NULL, points-to vars: { }
from_25(D), points-to non-local, points-to NULL, points-to vars: { }

smart_rename (const char * from, const char * to, int preserve_dates)
{
  int D.3572;
  int D.3570;
  int ret;
  struct stat s;
  bfd_boolean exists;
  int _1;
  _Bool _2;
  unsigned int _3;
  unsigned int _4;
  long unsigned int _5;
  unsigned int _6;
  unsigned int _7;
  unsigned int _8;
  unsigned int _9;
  int _10;
  unsigned int _11;
  unsigned int _12;
  int _36;

  <bb 2> [0.00%]:
  _1 = lstat (to_19(D), &s);
  _2 = _1 == 0;
  exists_21 = (bfd_boolean) _2;
  if (_1 != 0)
    goto <bb 5>; [0.00%]
  else
    goto <bb 3>; [0.00%]

  <bb 3> [0.00%]:
  _3 = BIT_FIELD_REF <s, 32, 192>;
  _4 = _3 & 61568;
  if (_4 == 32896)
    goto <bb 4>; [0.00%]
  else
    goto <bb 10>; [0.00%]

  <bb 4> [0.00%]:
  _5 = s.st_nlink;
  if (_5 == 1)
    goto <bb 5>; [0.00%]
  else
    goto <bb 10>; [0.00%]

  <bb 5> [0.00%]:
  ret_28 = rename (from_25(D), to_19(D));
  if (ret_28 == 0)
    goto <bb 6>; [0.00%]
  else
    goto <bb 9>; [0.00%]

  <bb 6> [0.00%]:
  if (_1 == 0)
    goto <bb 7>; [0.00%]
  else
    goto <bb 13>; [0.00%]

  <bb 7> [0.00%]:
  _6 = s.st_mode;
  _7 = _6 & 511;
  chmod (to_19(D), _7);
  _8 = s.st_gid;
  _9 = s.st_uid;
  _10 = chown (to_19(D), _9, _8);
  if (_10 >= 0)
    goto <bb 8>; [0.00%]
  else
    goto <bb 13>; [0.00%]

  <bb 8> [0.00%]:
  _11 = s.st_mode;
  _12 = _11 & 4095;
  chmod (to_19(D), _12);
  goto <bb 13>; [0.00%]

  <bb 9> [100.00%]:
  _36 = __printf_chk (1, "unable to rename \'%s\';", to_19(D));
  unlink (from_25(D));
  goto <bb 13>; [0.00%]

  <bb 10> [0.00%]:
  if (preserve_dates_23(D) != 0)
    goto <bb 11>; [0.00%]
  else
    goto <bb 12>; [0.00%]

  <bb 11> [0.00%]:
  set_times (to_19(D), &s);

  <bb 12> [0.00%]:
  unlink (from_25(D));

  <bb 13> [0.00%]:
  # ret_13 = PHI <ret_28(9), 0(12), ret_28(7), ret_28(8), ret_28(6)>
  s ={v} {CLOBBER};
  return ret_13;

}



;; Function unlink_if_ordinary (unlink_if_ordinary, funcdef_no=52, decl_uid=3434, cgraph_uid=52, symbol_order=89)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
name = &NONLOCAL
_1 = *name
ESCAPED = &NONLOCAL
ESCAPED = &STRING
ESCAPED = _1
_5 = NONLOCAL

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { STRING ESCAPED NONLOCAL }
NONLOCAL = { ESCAPED NONLOCAL } same as _5
STOREDANYTHING = { }
INTEGER = { ANYTHING }
name = { NONLOCAL }
_1 = { ESCAPED NONLOCAL }
__printf_chk = { }
_5 = { ESCAPED NONLOCAL }


Alias information for unlink_if_ordinary

Aliased symbols


Call clobber information

ESCAPED, points-to non-local, points-to vars: { }

Flow-insensitive points-to information

name_3(D), points-to non-local, points-to NULL, points-to vars: { }

unlink_if_ordinary (const char * name)
{
  int D.3574;
  int _1;
  int _5;

  <bb 2> [100.00%]:
  _1 = MEM[(int *)name_3(D)];
  _5 = __printf_chk (1, "%d\n", _1);
  return;

}



;; Function copy_main (copy_main, funcdef_no=54, decl_uid=3449, cgraph_uid=54, symbol_order=91)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
argc = &NONLOCAL
argv = &NONLOCAL
optind = NONLOCAL
optind.3_1 = optind
_2 = optind.3_1
_3 = _2
_3 = &NONLOCAL
_4 = argv
input_filename_33 = *_4
optind.4_5 = optind
_6 = optind.4_5
_6 = &NONLOCAL
output_filename_23 = &NULL
optind.5_7 = optind
_8 = optind.5_7
_9 = _8
_9 = &NONLOCAL
_10 = _9
_10 = &NONLOCAL
_11 = argv
output_filename_35 = *_11
output_filename_18 = output_filename_35
output_filename_24 = output_filename_18
output_filename_24 = output_filename_23
ESCAPED = input_filename_33
tmpname_38 = NONLOCAL
tmpname_19 = tmpname_38
tmpname_19 = output_filename_18
output_filename_25 = output_filename_24
output_filename_25 = output_filename_18
ESCAPED = &NONLOCAL
ESCAPED = &STRING
ESCAPED = input_filename_33
_48 = NONLOCAL
ESCAPED = &NONLOCAL
ESCAPED = input_filename_33
ESCAPED = tmpname_19
ESCAPED = &NULL
ESCAPED = &NULL
ESCAPED = &NULL
status = NONLOCAL
status.6_12 = status
preserve_dates = NONLOCAL
preserve_dates.7_13 = preserve_dates
ESCAPED = tmpname_19
ESCAPED = &statbuf
preserve_dates.8_14 = preserve_dates
ESCAPED = tmpname_19
ESCAPED = input_filename_33
ESCAPED = preserve_dates.8_14
_15 = NONLOCAL
_17 = _16
status = _17
ESCAPED = _17
ESCAPED = tmpname_19
ESCAPED = &NULL

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { NULL STRING ESCAPED NONLOCAL statbuf }
NONLOCAL = { ESCAPED NONLOCAL } same as optind
STOREDANYTHING = { }
INTEGER = { ANYTHING }
argc = { NONLOCAL }
argv = { NONLOCAL } same as argc
optind.3_1 = { ESCAPED NONLOCAL } same as optind
optind = { ESCAPED NONLOCAL }
_2 = { ESCAPED NONLOCAL } same as optind
_3 = { ESCAPED NONLOCAL } same as optind
_4 = { NONLOCAL } same as argc
input_filename_33 = { ESCAPED NONLOCAL }
optind.4_5 = { ESCAPED NONLOCAL } same as optind
_6 = { ESCAPED NONLOCAL } same as optind
output_filename_23 = { NULL }
optind.5_7 = { ESCAPED NONLOCAL } same as optind
_8 = { ESCAPED NONLOCAL } same as optind
_9 = { ESCAPED NONLOCAL } same as optind
_10 = { ESCAPED NONLOCAL } same as optind
_11 = { NONLOCAL } same as argc
output_filename_35 = { ESCAPED NONLOCAL }
output_filename_18 = { ESCAPED NONLOCAL } same as output_filename_35
output_filename_24 = { NULL ESCAPED NONLOCAL }
make_tempname = { }
tmpname_38 = { ESCAPED NONLOCAL } same as optind
tmpname_19 = { ESCAPED NONLOCAL }
output_filename_25 = { NULL ESCAPED NONLOCAL } same as output_filename_24
__printf_chk = { }
_48 = { ESCAPED NONLOCAL } same as optind
exit = { }
copy_file = { }
status.6_12 = { ESCAPED NONLOCAL } same as optind
status = { ESCAPED NONLOCAL } same as optind
preserve_dates.7_13 = { ESCAPED NONLOCAL } same as optind
preserve_dates = { ESCAPED NONLOCAL } same as optind
set_times = { }
statbuf = { ESCAPED NONLOCAL }
preserve_dates.8_14 = { ESCAPED NONLOCAL } same as optind
smart_rename = { }
_15 = { ESCAPED NONLOCAL } same as optind
_16 = { }
_17 = { }
unlink_if_ordinary = { }


Alias information for copy_main

Aliased symbols

statbuf, UID D.3460, int, is addressable

Call clobber information

ESCAPED, points-to non-local, points-to NULL, points-to vars: { D.3460 } (escaped)

Flow-insensitive points-to information

_4, points-to non-local, points-to NULL, points-to vars: { }
_11, points-to non-local, points-to NULL, points-to vars: { }
output_filename_18, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
tmpname_19, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
output_filename_23, points-to NULL, points-to vars: { }
output_filename_24, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
output_filename_25, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
argv_32(D), points-to non-local, points-to NULL, points-to vars: { }
input_filename_33, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
output_filename_35, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
tmpname_38, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }

copy_main (int argc, char * * argv)
{
  int D.3576;
  const struct bfd_arch_info_type * input_arch;
  int statbuf;
  bfd_boolean formats_info;
  bfd_boolean change_warn;
  bfd_boolean show_version;
  char * output_target;
  char * input_target;
  char * tmpname;
  char * output_filename;
  char * input_filename;
  int optind.3_1;
  long unsigned int _2;
  long unsigned int _3;
  char * * _4;
  int optind.4_5;
  int _6;
  int optind.5_7;
  sizetype _8;
  sizetype _9;
  sizetype _10;
  char * * _11;
  int status.6_12;
  int preserve_dates.7_13;
  int preserve_dates.8_14;
  int _15;
  _Bool _16;
  int _17;
  int _48;

  <bb 2> [0.00%]:
  optind.3_1 = optind;
  _2 = (long unsigned int) optind.3_1;
  _3 = _2 * 8;
  _4 = argv_32(D) + _3;
  input_filename_33 = *_4;
  optind.4_5 = optind;
  _6 = optind.4_5 + 1;
  if (_6 < argc_34(D))
    goto <bb 4>; [0.00%]
  else
    goto <bb 3>; [0.00%]

  <bb 3> [0.00%]:
  # output_filename_23 = PHI <0B(2)>
  goto <bb 6>; [100.00%]

  <bb 4> [0.00%]:
  optind.5_7 = optind;
  _8 = (sizetype) optind.5_7;
  _9 = _8 + 1;
  _10 = _9 * 8;
  _11 = argv_32(D) + _10;
  output_filename_35 = *_11;

  <bb 5> [0.00%]:
  # output_filename_18 = PHI <output_filename_35(4)>
  if (output_filename_18 == 0B)
    goto <bb 6>; [0.00%]
  else
    goto <bb 7>; [0.00%]

  <bb 6> [0.00%]:
  # output_filename_24 = PHI <output_filename_18(5), output_filename_23(3)>
  tmpname_38 = make_tempname (input_filename_33);

  <bb 7> [0.00%]:
  # tmpname_19 = PHI <tmpname_38(6), output_filename_18(5)>
  # output_filename_25 = PHI <output_filename_24(6), output_filename_18(5)>
  if (tmpname_19 == 0B)
    goto <bb 8>; [0.00%]
  else
    goto <bb 9>; [0.00%]

  <bb 8> [100.00%]:
  _48 = __printf_chk (1, "warning: could not create temporary file whilst copying \'%s\'", input_filename_33);
  exit (1);

  <bb 9> [0.00%]:
  copy_file (input_filename_33, tmpname_19, 0B, 0B, 0B);
  status.6_12 = status;
  if (status.6_12 == 0)
    goto <bb 10>; [0.00%]
  else
    goto <bb 14>; [0.00%]

  <bb 10> [0.00%]:
  preserve_dates.7_13 = preserve_dates;
  if (preserve_dates.7_13 != 0)
    goto <bb 11>; [0.00%]
  else
    goto <bb 12>; [0.00%]

  <bb 11> [0.00%]:
  set_times (tmpname_19, &statbuf);

  <bb 12> [0.00%]:
  if (output_filename_25 != tmpname_19)
    goto <bb 13>; [0.00%]
  else
    goto <bb 15>; [0.00%]

  <bb 13> [0.00%]:
  preserve_dates.8_14 = preserve_dates;
  _15 = smart_rename (tmpname_19, input_filename_33, preserve_dates.8_14);
  _16 = _15 != 0;
  _17 = (int) _16;
  status = _17;
  goto <bb 15>; [0.00%]

  <bb 14> [0.00%]:
  unlink_if_ordinary (tmpname_19);

  <bb 15> [0.00%]:
  statbuf ={v} {CLOBBER};
  return 0;

}



;; Function main (main, funcdef_no=55, decl_uid=3464, cgraph_uid=55, symbol_order=92)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
argc = &NONLOCAL
argv = &NONLOCAL
_1 = *argv
program_name = NONLOCAL
program_name = _1
ESCAPED = _1
ESCAPED = argc
ESCAPED = argv
status = NONLOCAL
_7 = status
ESCAPED = _7

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { ESCAPED NONLOCAL }
NONLOCAL = { ESCAPED NONLOCAL } same as status
STOREDANYTHING = { }
INTEGER = { ANYTHING }
argc = { NONLOCAL }
argv = { NONLOCAL } same as argc
_1 = { ESCAPED NONLOCAL }
program_name = { ESCAPED NONLOCAL }
copy_main = { }
_7 = { ESCAPED NONLOCAL } same as status
status = { ESCAPED NONLOCAL }


Alias information for main

Aliased symbols


Call clobber information

ESCAPED, points-to non-local, points-to vars: { }

Flow-insensitive points-to information

_1, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
argv_3(D), points-to non-local, points-to NULL, points-to vars: { }

main (int argc, char * * argv)
{
  char * _1;
  int _7;

  <bb 2> [0.00%]:
  _1 = *argv_3(D);
  program_name = _1;
  copy_main (argc_5(D), argv_3(D));
  _7 = status;
  return _7;

}


