
;; Function update_tree_entry_internal (update_tree_entry_internal, funcdef_no=1, decl_uid=1976, cgraph_uid=1, symbol_order=2)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
desc = &NONLOCAL
err = &NONLOCAL
buf_12 = *desc
_1 = *desc + 64
end_13 = _1
_3 = *desc + 256
size_14 = _3
end.0_4 = end_13
buf.1_5 = buf_12
_6 = end.0_4
_6 = buf.1_5
len_15 = _6
ESCAPED = &STRING
ESCAPED = buf_12
ESCAPED = &NONLOCAL
size_17 = size_14
size_17 = len_15
*desc = end_13
_7 = size_17
*desc + 256 = _7
ESCAPED = desc
ESCAPED = end_13
ESCAPED = size_17
ESCAPED = err
tmp_23 = NONLOCAL
_8 = tmp_23
_8 = &NULL
ESCAPED = _8

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { NULL STRING ESCAPED NONLOCAL }
NONLOCAL = { ESCAPED NONLOCAL } same as tmp_23
STOREDANYTHING = { }
INTEGER = { ANYTHING }
desc = { NONLOCAL }
err = { NONLOCAL } same as desc
buf_12 = { ESCAPED NONLOCAL }
_1 = { ESCAPED NONLOCAL }
end_13 = { ESCAPED NONLOCAL } same as _1
_3 = { ESCAPED NONLOCAL }
size_14 = { ESCAPED NONLOCAL } same as _3
end.0_4 = { ESCAPED NONLOCAL } same as _1
buf.1_5 = { ESCAPED NONLOCAL } same as buf_12
_6 = { ESCAPED NONLOCAL } same as buf_12
len_15 = { ESCAPED NONLOCAL } same as buf_12
printf = { }
exit = { }
size_17 = { ESCAPED NONLOCAL }
_7 = { ESCAPED NONLOCAL } same as size_17
decode_tree_entry = { }
tmp_23 = { ESCAPED NONLOCAL }
_8 = { NULL ESCAPED NONLOCAL }


Alias information for update_tree_entry_internal

Aliased symbols


Call clobber information

ESCAPED, points-to non-local, points-to NULL, points-to vars: { }

Flow-insensitive points-to information

_1, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
desc_11(D), points-to non-local, points-to NULL, points-to vars: { }
buf_12, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
end_13, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
err_21(D), points-to non-local, points-to NULL, points-to vars: { }

update_tree_entry_internal (struct tree_desc * desc, struct strbuf * err)
{
  int tmp;
  long unsigned int len;
  long unsigned int size;
  const unsigned char * end;
  const void * buf;
  const struct object_id * _1;
  unsigned int _3;
  long int end.0_4;
  long int buf.1_5;
  long int _6;
  unsigned int _7;
  int _8;

  <bb 2> [0.00%]:
  buf_12 = desc_11(D)->buffer;
  _1 = desc_11(D)->entry.oid;
  end_13 = &MEM[(void *)_1 + 20B];
  _3 = desc_11(D)->size;
  size_14 = (long unsigned int) _3;
  end.0_4 = (long int) end_13;
  buf.1_5 = (long int) buf_12;
  _6 = end.0_4 - buf.1_5;
  len_15 = (long unsigned int) _6;
  if (size_14 < len_15)
    goto <bb 3>; [0.00%]
  else
    goto <bb 4>; [0.00%]

  <bb 3> [0.00%]:
  printf ("too-short tree file%s", buf_12);
  exit (1);

  <bb 4> [0.00%]:
  size_17 = size_14 - len_15;
  desc_11(D)->buffer = end_13;
  _7 = (unsigned int) size_17;
  desc_11(D)->size = _7;
  if (size_17 != 0)
    goto <bb 5>; [0.00%]
  else
    goto <bb 6>; [0.00%]

  <bb 5> [0.00%]:
  tmp_23 = decode_tree_entry (desc_11(D), end_13, size_17, err_21(D));

  <bb 6> [0.00%]:
  # _8 = PHI <tmp_23(5), 0(4)>
  return _8;

}



;; Function init_tree_desc_internal (init_tree_desc_internal, funcdef_no=6, decl_uid=2030, cgraph_uid=6, symbol_order=7)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
desc = &NONLOCAL
buffer = &NONLOCAL
size = &NONLOCAL
err = &NONLOCAL
*desc = buffer
_1 = size
*desc + 256 = _1
ESCAPED = desc
ESCAPED = buffer
ESCAPED = size
ESCAPED = err
tmp_13 = NONLOCAL
_2 = tmp_13
_2 = &NULL
ESCAPED = _2

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { NULL ESCAPED NONLOCAL }
NONLOCAL = { ESCAPED NONLOCAL } same as tmp_13
STOREDANYTHING = { }
INTEGER = { ANYTHING }
desc = { NONLOCAL }
buffer = { NONLOCAL } same as desc
size = { NONLOCAL } same as desc
err = { NONLOCAL } same as desc
_1 = { NONLOCAL } same as desc
decode_tree_entry = { }
tmp_13 = { ESCAPED NONLOCAL }
_2 = { NULL ESCAPED NONLOCAL }


Alias information for init_tree_desc_internal

Aliased symbols


Call clobber information

ESCAPED, points-to non-local, points-to NULL, points-to vars: { }

Flow-insensitive points-to information

desc_5(D), points-to non-local, points-to NULL, points-to vars: { }
buffer_6(D), points-to non-local, points-to NULL, points-to vars: { }
err_11(D), points-to non-local, points-to NULL, points-to vars: { }

init_tree_desc_internal (struct tree_desc * desc, const void * buffer, long unsigned int size, struct strbuf * err)
{
  int tmp;
  unsigned int _1;
  int _2;

  <bb 2> [0.00%]:
  desc_5(D)->buffer = buffer_6(D);
  _1 = (unsigned int) size_8(D);
  desc_5(D)->size = _1;
  if (size_8(D) != 0)
    goto <bb 3>; [0.00%]
  else
    goto <bb 4>; [0.00%]

  <bb 3> [0.00%]:
  tmp_13 = decode_tree_entry (desc_5(D), buffer_6(D), size_8(D), err_11(D));

  <bb 4> [0.00%]:
  # _2 = PHI <tmp_13(3), 0(2)>
  return _2;

}



;; Function xrealloc (xrealloc, funcdef_no=0, decl_uid=1963, cgraph_uid=0, symbol_order=0)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
ptr = &NONLOCAL
size = &NONLOCAL
ret_11 = &HEAP(11)
doubledereftmp(12) = *ptr
*ret_11 = doubledereftmp(12)
ret_11 = ptr
ret_13 = &HEAP(14)
doubledereftmp(15) = *ptr
*ret_13 = doubledereftmp(15)
ret_13 = ptr
ret_1 = ret_11
ret_1 = ret_11
ret_1 = ret_13
ret_15 = &HEAP(18)
doubledereftmp(19) = *ptr
*ret_15 = doubledereftmp(19)
ret_15 = ptr
ret_17 = &HEAP(21)
doubledereftmp(22) = *ptr
*ret_17 = doubledereftmp(22)
ret_17 = ptr
ret_2 = ret_15
ret_2 = ret_15
ret_2 = ret_17
ESCAPED = &STRING
ESCAPED = &STRING
ESCAPED = &NONLOCAL
ret_3 = ret_1
ret_3 = ret_2
_20 = ret_3
ESCAPED = ret_3

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { STRING ESCAPED NONLOCAL HEAP(11) HEAP(14) HEAP(18) HEAP(21) }
NONLOCAL = { ESCAPED NONLOCAL }
STOREDANYTHING = { }
INTEGER = { ANYTHING }
ptr = { NONLOCAL }
size = { NONLOCAL } same as ptr
ret_11 = { NONLOCAL HEAP(11) }
HEAP(11) = { ESCAPED NONLOCAL }
doubledereftmp(12) = { ESCAPED NONLOCAL }
ret_13 = { NONLOCAL HEAP(14) }
HEAP(14) = { ESCAPED NONLOCAL }
doubledereftmp(15) = { ESCAPED NONLOCAL } same as doubledereftmp(12)
ret_1 = { NONLOCAL HEAP(11) HEAP(14) }
ret_15 = { NONLOCAL HEAP(18) }
HEAP(18) = { ESCAPED NONLOCAL }
doubledereftmp(19) = { ESCAPED NONLOCAL } same as doubledereftmp(12)
ret_17 = { NONLOCAL HEAP(21) }
HEAP(21) = { ESCAPED NONLOCAL }
doubledereftmp(22) = { ESCAPED NONLOCAL } same as doubledereftmp(12)
ret_2 = { NONLOCAL HEAP(18) HEAP(21) }
printf = { }
exit = { }
ret_3 = { NONLOCAL HEAP(11) HEAP(14) HEAP(18) HEAP(21) }
_20 = { NONLOCAL HEAP(11) HEAP(14) HEAP(18) HEAP(21) } same as ret_3


Alias information for xrealloc

Aliased symbols


Call clobber information

ESCAPED, points-to non-local, points-to vars: { D.2158 D.2159 D.2160 D.2161 } (escaped, escaped heap)

Flow-insensitive points-to information

ret_1, points-to non-local, points-to NULL, points-to vars: { D.2158 D.2159 } (escaped, escaped heap)
ret_2, points-to non-local, points-to NULL, points-to vars: { D.2160 D.2161 } (escaped, escaped heap)
ret_3, points-to non-local, points-to NULL, points-to vars: { D.2158 D.2159 D.2160 D.2161 } (escaped, escaped heap)
ptr_8(D), points-to non-local, points-to NULL, points-to vars: { }
ret_11, points-to non-local, points-to NULL, points-to vars: { D.2158 } (escaped, escaped heap)
ret_13, points-to non-local, points-to NULL, points-to vars: { D.2159 } (escaped, escaped heap)
ret_15, points-to non-local, points-to NULL, points-to vars: { D.2160 } (escaped, escaped heap)
ret_17, points-to non-local, points-to NULL, points-to vars: { D.2161 } (escaped, escaped heap)
_20, points-to non-local, points-to NULL, points-to vars: { D.2158 D.2159 D.2160 D.2161 } (escaped, escaped heap)

xrealloc (void * ptr, size_t size)
{
  void * ret;
  void * _20;

  <bb 2> [0.00%]:
  ret_11 = realloc (ptr_8(D), size_9(D));
  if (ret_11 == 0B)
    goto <bb 3>; [0.00%]
  else
    goto <bb 5>; [0.00%]

  <bb 3> [0.00%]:
  if (size_9(D) == 0)
    goto <bb 4>; [0.00%]
  else
    goto <bb 5>; [0.00%]

  <bb 4> [0.00%]:
  ret_13 = realloc (ptr_8(D), 1);

  <bb 5> [0.00%]:
  # ret_1 = PHI <ret_11(2), ret_11(3), ret_13(4)>
  if (ret_1 == 0B)
    goto <bb 6>; [0.00%]
  else
    goto <bb 11>; [0.00%]

  <bb 6> [0.00%]:
  ret_15 = realloc (ptr_8(D), size_9(D));
  if (ret_15 == 0B)
    goto <bb 7>; [0.00%]
  else
    goto <bb 9>; [0.00%]

  <bb 7> [0.00%]:
  if (size_9(D) == 0)
    goto <bb 8>; [0.00%]
  else
    goto <bb 9>; [0.00%]

  <bb 8> [0.00%]:
  ret_17 = realloc (ptr_8(D), 1);

  <bb 9> [0.00%]:
  # ret_2 = PHI <ret_15(6), ret_15(7), ret_17(8)>
  if (ret_2 == 0B)
    goto <bb 10>; [0.00%]
  else
    goto <bb 11>; [0.00%]

  <bb 10> [0.00%]:
  printf ("Out of memory, realloc failed%s", "");
  exit (1);

  <bb 11> [0.00%]:
  # ret_3 = PHI <ret_1(5), ret_2(9)>
  _20 = ret_3;
  return ret_3;

}



;; Function update_tree_entry (update_tree_entry, funcdef_no=2, decl_uid=1985, cgraph_uid=2, symbol_order=3)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
desc = &NONLOCAL
err = &NULL
err = &NULL
strbuf_slopbuf = NONLOCAL
err = &strbuf_slopbuf
ESCAPED = desc
ESCAPED = &err
tmp_8 = NONLOCAL
_1 = err
ESCAPED = &STRING
ESCAPED = _1
ESCAPED = &NONLOCAL
ESCAPED = &err

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { NULL STRING ESCAPED NONLOCAL err strbuf_slopbuf }
NONLOCAL = { ESCAPED NONLOCAL } same as tmp_8
STOREDANYTHING = { }
INTEGER = { ANYTHING }
desc = { NONLOCAL }
err = { NULL ESCAPED NONLOCAL strbuf_slopbuf } same as _1
strbuf_slopbuf = { ESCAPED NONLOCAL }
update_tree_entry_internal = { }
tmp_8 = { ESCAPED NONLOCAL }
_1 = { NULL ESCAPED NONLOCAL strbuf_slopbuf }
printf = { }
exit = { }
strbuf_release = { }


Alias information for update_tree_entry

Aliased symbols

err, UID D.1987, struct strbuf, is addressable

Call clobber information

ESCAPED, points-to non-local, points-to NULL, points-to vars: { D.1960 D.1987 } (nonlocal, escaped, interposable)

Flow-insensitive points-to information

_1, points-to non-local, points-to escaped, points-to NULL, points-to vars: { D.1960 } (nonlocal, escaped, interposable)
desc_6(D), points-to non-local, points-to NULL, points-to vars: { }

update_tree_entry (struct tree_desc * desc)
{
  int tmp;
  struct strbuf err;
  char * _1;

  <bb 2> [0.00%]:
  err.alloc = 0;
  err.len = 0;
  err.buf = &strbuf_slopbuf;
  tmp_8 = update_tree_entry_internal (desc_6(D), &err);
  if (tmp_8 != 0)
    goto <bb 3>; [0.00%]
  else
    goto <bb 4>; [0.00%]

  <bb 3> [0.00%]:
  _1 = err.buf;
  printf ("%s", _1);
  exit (1);

  <bb 4> [0.00%]:
  strbuf_release (&err);
  err ={v} {CLOBBER};
  return;

}



;; Function extended_entry_extract (extended_entry_extract, funcdef_no=3, decl_uid=1995, cgraph_uid=3, symbol_order=4)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
t = &NONLOCAL
a = &NONLOCAL
first = &NONLOCAL
first_len = &NONLOCAL
_1 = *t + 256
ESCAPED = a
_2 = t + UNKNOWN
ESCAPED = _2
ESCAPED = a
skip_15 = *t + 320
_3 = *a + 64
_4 = _3
_5 = *skip_8 + 64
_6 = _5
skip_16 = *skip_8
skip_8 = skip_15
skip_8 = skip_16
_7 = t + UNKNOWN
ESCAPED = _7

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { ESCAPED NONLOCAL }
NONLOCAL = { ESCAPED NONLOCAL }
STOREDANYTHING = { }
INTEGER = { ANYTHING }
t = { NONLOCAL }
a = { NONLOCAL } same as t
first = { NONLOCAL } same as t
first_len = { NONLOCAL } same as t
_1 = { ESCAPED NONLOCAL }
entry_clear = { }
_2 = { NONLOCAL }
entry_extract = { }
skip_15 = { ESCAPED NONLOCAL }
_3 = { ESCAPED NONLOCAL }
_4 = { ESCAPED NONLOCAL } same as _3
_5 = { ESCAPED NONLOCAL }
skip_8 = { ESCAPED NONLOCAL }
_6 = { ESCAPED NONLOCAL } same as _5
skip_16 = { ESCAPED NONLOCAL }
_7 = { NONLOCAL }
update_tree_entry = { }


Alias information for extended_entry_extract

Aliased symbols


Call clobber information

ESCAPED, points-to non-local, points-to vars: { }

Flow-insensitive points-to information

_2, points-to non-local, points-to NULL, points-to vars: { }
_3, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_5, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
_7, points-to non-local, points-to NULL, points-to vars: { }
skip_8, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
t_12(D), points-to non-local, points-to NULL, points-to vars: { }
a_13(D), points-to non-local, points-to NULL, points-to vars: { }
skip_15, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
skip_16, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }

extended_entry_extract (struct tree_desc_x * t, struct name_entry * a, const char * first, int first_len)
{
  struct tree_desc_skip * skip;
  unsigned int _1;
  struct tree_desc * _2;
  const char * _3;
  long unsigned int _4;
  const void * _5;
  long unsigned int _6;
  struct tree_desc * _7;

  <bb 2> [0.00%]:
  _1 = t_12(D)->d.size;
  if (_1 == 0)
    goto <bb 3>; [0.00%]
  else
    goto <bb 4>; [0.00%]

  <bb 3> [0.00%]:
  entry_clear (a_13(D));
  goto <bb 10>; [0.00%]

  <bb 4> [0.00%]:
  _2 = &t_12(D)->d;
  entry_extract (_2, a_13(D));
  skip_15 = t_12(D)->skip;
  goto <bb 7>; [0.00%]

  <bb 5> [0.00%]:
  _3 = a_13(D)->path;
  _4 = (long unsigned int) _3;
  _5 = skip_8->ptr;
  _6 = (long unsigned int) _5;
  if (_4 == _6)
    goto <bb 8>; [0.00%]
  else
    goto <bb 6>; [0.00%]

  <bb 6> [0.00%]:
  skip_16 = skip_8->prev;

  <bb 7> [0.00%]:
  # skip_8 = PHI <skip_15(4), skip_16(6)>
  if (skip_8 != 0B)
    goto <bb 5>; [0.00%]
  else
    goto <bb 8>; [0.00%]

  <bb 8> [0.00%]:
  if (skip_8 == 0B)
    goto <bb 10>; [0.00%]
  else
    goto <bb 9>; [0.00%]

  <bb 9> [0.00%]:
  _7 = &t_12(D)->d;
  update_tree_entry (_7);
  goto <bb 2>; [0.00%]

  <bb 10> [0.00%]:
  return;

}



;; Function traverse_trees (traverse_trees, funcdef_no=4, decl_uid=2006, cgraph_uid=4, symbol_order=5)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
n = &NONLOCAL
t = &NONLOCAL
info = &NONLOCAL
_1 = n___0_19
ESCAPED = _1
ESCAPED = &NONLOCAL
tmp_22 = &HEAP(15)
tx_23 = tmp_22
_2 = n___0_19
_3 = _2
_3 = &NONLOCAL
ESCAPED = _3
tmp___0_25 = &HEAP(21)
entry_26 = tmp___0_25
_4 = i_15
_5 = _4
_5 = &NONLOCAL
_6 = t
_7 = i_15
_8 = _7
_8 = &NONLOCAL
_9 = tmp_22
doubledereftmp(30) = *_6 + UNKNOWN
*_9 + UNKNOWN = doubledereftmp(30)
i_37 = i_15
i_37 = &NONLOCAL
i_15 = &NULL
i_15 = i_37
_10 = i_16
_11 = _10
_11 = &NONLOCAL
e_32 = tmp___0_25
_12 = i_16
_13 = _12
_13 = &NONLOCAL
_14 = tmp_22
ESCAPED = _14
ESCAPED = e_32
ESCAPED = &NULL
ESCAPED = &NULL
i_34 = i_16
i_34 = &NONLOCAL
i_16 = &NULL
i_16 = i_34
ESCAPED = &NONLOCAL

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { NULL ESCAPED NONLOCAL HEAP(15) HEAP(21) }
NONLOCAL = { ESCAPED NONLOCAL }
STOREDANYTHING = { }
INTEGER = { ANYTHING }
n = { NONLOCAL }
t = { NONLOCAL } same as n
info = { NONLOCAL } same as n
_1 = { }
n___0_19 = { }
calloc = { }
tmp_22 = { HEAP(15) }
HEAP(15) = { ESCAPED NONLOCAL }
tx_23 = { HEAP(15) } same as tmp_22
_2 = { }
_3 = { NONLOCAL } same as n
malloc = { }
tmp___0_25 = { HEAP(21) }
HEAP(21) = { ESCAPED NONLOCAL }
entry_26 = { HEAP(21) } same as tmp___0_25
_4 = { NULL NONLOCAL }
i_15 = { NULL NONLOCAL } same as _4
_5 = { NULL NONLOCAL } same as _4
_6 = { NONLOCAL } same as n
_7 = { NULL NONLOCAL } same as _4
_8 = { NULL NONLOCAL } same as _4
_9 = { HEAP(15) } same as tmp_22
doubledereftmp(30) = { ESCAPED NONLOCAL }
i_37 = { NULL NONLOCAL } same as _4
_10 = { NULL NONLOCAL } same as _4
i_16 = { NULL NONLOCAL } same as _4
_11 = { NULL NONLOCAL } same as _4
e_32 = { HEAP(21) } same as tmp___0_25
_12 = { NULL NONLOCAL } same as _4
_13 = { NULL NONLOCAL } same as _4
_14 = { HEAP(15) } same as tmp_22
extended_entry_extract = { }
i_34 = { NULL NONLOCAL } same as _4


Alias information for traverse_trees

Aliased symbols


Call clobber information

ESCAPED, points-to non-local, points-to NULL, points-to vars: { D.2162 D.2163 } (escaped, escaped heap)

Flow-insensitive points-to information

_6, points-to non-local, points-to NULL, points-to vars: { }
_9, points-to NULL, points-to vars: { D.2162 } (escaped, escaped heap)
_14, points-to NULL, points-to vars: { D.2162 } (escaped, escaped heap)
tmp_22, points-to NULL, points-to vars: { D.2162 } (escaped, escaped heap)
tx_23, points-to NULL, points-to vars: { D.2162 } (escaped, escaped heap)
tmp___0_25, points-to NULL, points-to vars: { D.2163 } (escaped, escaped heap)
entry_26, points-to NULL, points-to vars: { D.2163 } (escaped, escaped heap)
e_32, points-to NULL, points-to vars: { D.2163 } (escaped, escaped heap)
t_35(D), points-to non-local, points-to NULL, points-to vars: { }

traverse_trees (int n, struct tree_desc * t, struct traverse_info * info)
{
  struct name_entry * e;
  void * tmp___0;
  struct name_entry * entry;
  void * tmp;
  struct tree_desc_x * tx;
  int n___0;
  int i;
  long unsigned int _1;
  long unsigned int _2;
  long unsigned int _3;
  long unsigned int _4;
  long unsigned int _5;
  struct tree_desc * _6;
  long unsigned int _7;
  long unsigned int _8;
  struct tree_desc_x * _9;
  long unsigned int _10;
  long unsigned int _11;
  long unsigned int _12;
  long unsigned int _13;
  struct tree_desc_x * _14;

  <bb 2> [0.00%]:
  _1 = (long unsigned int) n___0_19(D);
  tmp_22 = calloc (_1, 48);
  tx_23 = tmp_22;
  _2 = (long unsigned int) n___0_19(D);
  _3 = _2 * 24;
  tmp___0_25 = malloc (_3);
  entry_26 = tmp___0_25;
  goto <bb 4>; [0.00%]

  <bb 3> [0.00%]:
  _4 = (long unsigned int) i_15;
  _5 = _4 * 40;
  _6 = t_35(D) + _5;
  _7 = (long unsigned int) i_15;
  _8 = _7 * 48;
  _9 = tmp_22 + _8;
  _9->d = *_6;
  i_37 = i_15 + 1;

  <bb 4> [0.00%]:
  # i_15 = PHI <0(2), i_37(3)>
  if (i_15 < n___0_19(D))
    goto <bb 3>; [0.00%]
  else
    goto <bb 6>; [0.00%]

  <bb 5> [0.00%]:
  _10 = (long unsigned int) i_16;
  _11 = _10 * 24;
  e_32 = tmp___0_25 + _11;
  _12 = (long unsigned int) i_16;
  _13 = _12 * 48;
  _14 = tmp_22 + _13;
  extended_entry_extract (_14, e_32, 0B, 0);
  i_34 = i_16 + 1;

  <bb 6> [0.00%]:
  # i_16 = PHI <0(4), i_34(5)>
  if (i_16 < n___0_19(D))
    goto <bb 5>; [0.00%]
  else
    goto <bb 7>; [0.00%]

  <bb 7> [0.00%]:
  free (tx_23);
  return 1;

}



;; Function unpack_trees (unpack_trees, funcdef_no=5, decl_uid=2024, cgraph_uid=5, symbol_order=6)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
len = &NONLOCAL
t = &NONLOCAL
o = &NONLOCAL
len.2_1 = len
ESCAPED = len.2_1
ESCAPED = t
ESCAPED = &NULL
ESCAPED = &NULL

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { NULL ESCAPED NONLOCAL }
NONLOCAL = { ESCAPED NONLOCAL }
STOREDANYTHING = { }
INTEGER = { ANYTHING }
len = { NONLOCAL }
t = { NONLOCAL } same as len
o = { NONLOCAL } same as len
len.2_1 = { NONLOCAL } same as len
traverse_trees = { }


Alias information for unpack_trees

Aliased symbols


Call clobber information

ESCAPED, points-to non-local, points-to NULL, points-to vars: { }

Flow-insensitive points-to information

t_4(D), points-to non-local, points-to NULL, points-to vars: { }

unpack_trees (unsigned int len, struct tree_desc * t, struct unpack_trees_options * o)
{
  int len.2_1;

  <bb 2> [0.00%]:
  len.2_1 = (int) len_2(D);
  traverse_trees (len.2_1, t_4(D), 0B);
  return 0;

}



;; Function init_tree_desc (init_tree_desc, funcdef_no=7, decl_uid=2036, cgraph_uid=7, symbol_order=8)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
desc = &NONLOCAL
buffer = &NONLOCAL
size = &NONLOCAL
err = &NULL
err = &NULL
strbuf_slopbuf = NONLOCAL
err = &strbuf_slopbuf
ESCAPED = desc
ESCAPED = buffer
ESCAPED = size
ESCAPED = &err
tmp_10 = NONLOCAL
_1 = err
ESCAPED = &STRING
ESCAPED = _1
ESCAPED = &NONLOCAL
ESCAPED = &err

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { NULL STRING ESCAPED NONLOCAL err strbuf_slopbuf }
NONLOCAL = { ESCAPED NONLOCAL } same as tmp_10
STOREDANYTHING = { }
INTEGER = { ANYTHING }
desc = { NONLOCAL }
buffer = { NONLOCAL } same as desc
size = { NONLOCAL } same as desc
err = { NULL ESCAPED NONLOCAL strbuf_slopbuf } same as _1
strbuf_slopbuf = { ESCAPED NONLOCAL }
init_tree_desc_internal = { }
tmp_10 = { ESCAPED NONLOCAL }
_1 = { NULL ESCAPED NONLOCAL strbuf_slopbuf }
printf = { }
exit = { }
strbuf_release = { }


Alias information for init_tree_desc

Aliased symbols

err, UID D.2038, struct strbuf, is addressable

Call clobber information

ESCAPED, points-to non-local, points-to NULL, points-to vars: { D.1960 D.2038 } (nonlocal, escaped, interposable)

Flow-insensitive points-to information

_1, points-to non-local, points-to escaped, points-to NULL, points-to vars: { D.1960 } (nonlocal, escaped, interposable)
desc_6(D), points-to non-local, points-to NULL, points-to vars: { }
buffer_7(D), points-to non-local, points-to NULL, points-to vars: { }

init_tree_desc (struct tree_desc * desc, const void * buffer, long unsigned int size)
{
  int tmp;
  struct strbuf err;
  char * _1;

  <bb 2> [0.00%]:
  err.alloc = 0;
  err.len = 0;
  err.buf = &strbuf_slopbuf;
  tmp_10 = init_tree_desc_internal (desc_6(D), buffer_7(D), size_8(D), &err);
  if (tmp_10 != 0)
    goto <bb 3>; [0.00%]
  else
    goto <bb 4>; [0.00%]

  <bb 3> [0.00%]:
  _1 = err.buf;
  printf ("%s", _1);
  exit (1);

  <bb 4> [0.00%]:
  strbuf_release (&err);
  err ={v} {CLOBBER};
  return;

}



;; Function fill_tree_descriptor (fill_tree_descriptor, funcdef_no=8, decl_uid=2043, cgraph_uid=8, symbol_order=9)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
desc = &NONLOCAL
oid = &NONLOCAL
ESCAPED = &NONLOCAL
buf_8 = &HEAP(12)
ESCAPED = oid
tmp_10 = NONLOCAL
ESCAPED = &STRING
ESCAPED = tmp_10
ESCAPED = &NONLOCAL
buf_1 = &NULL
buf_1 = buf_8
ESCAPED = desc
ESCAPED = buf_1
ESCAPED = &NULL

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { NULL STRING ESCAPED NONLOCAL HEAP(12) }
NONLOCAL = { ESCAPED NONLOCAL } same as tmp_10
STOREDANYTHING = { }
INTEGER = { ANYTHING }
desc = { NONLOCAL }
oid = { NONLOCAL } same as desc
malloc = { }
buf_8 = { HEAP(12) }
HEAP(12) = { ESCAPED NONLOCAL }
oid_to_hex = { }
tmp_10 = { ESCAPED NONLOCAL }
printf = { }
exit = { }
buf_1 = { NULL HEAP(12) }
init_tree_desc = { }


Alias information for fill_tree_descriptor

Aliased symbols


Call clobber information

ESCAPED, points-to non-local, points-to NULL, points-to vars: { D.2164 } (escaped, escaped heap)

Flow-insensitive points-to information

buf_1, points-to NULL, points-to vars: { D.2164 } (escaped, escaped heap)
oid_5(D), points-to non-local, points-to NULL, points-to vars: { }
buf_8, points-to NULL, points-to vars: { D.2164 } (escaped, escaped heap)
desc_13(D), points-to non-local, points-to NULL, points-to vars: { }

fill_tree_descriptor (struct tree_desc * desc, const struct object_id * oid)
{
  int tmp;
  void * buf;
  long unsigned int size;

  <bb 2> [0.00%]:
  if (oid_5(D) != 0B)
    goto <bb 3>; [0.00%]
  else
    goto <bb 5>; [0.00%]

  <bb 3> [0.00%]:
  buf_8 = malloc (100);
  if (buf_8 == 0B)
    goto <bb 4>; [0.00%]
  else
    goto <bb 5>; [0.00%]

  <bb 4> [0.00%]:
  tmp_10 = oid_to_hex (oid_5(D));
  printf ("unable to read tree %s", tmp_10);
  exit (1);

  <bb 5> [0.00%]:
  # buf_1 = PHI <0B(2), buf_8(3)>
  init_tree_desc (desc_13(D), buf_1, 0);
  return;

}



;; Function reset_index (reset_index, funcdef_no=9, decl_uid=2058, cgraph_uid=9, symbol_order=10)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
oid = &NONLOCAL
reset_type = &NONLOCAL
quiet = &NONLOCAL
ESCAPED = &opts
ESCAPED = &NULL
ESCAPED = &NONLOCAL
opts = &NONLOCAL
the_index = NONLOCAL
opts = &the_index
opts = &the_index
opts = &oneway_merge
opts = &NONLOCAL
opts = &NONLOCAL
opts = &NONLOCAL
opts = &NONLOCAL
opts = &NONLOCAL
ESCAPED = &STRING
ESCAPED = &head_oid
tmp___1_35 = NONLOCAL
ESCAPED = &STRING
tmp_40 = NONLOCAL
ESCAPED = tmp_40
tmp___0_42 = NONLOCAL
ESCAPED = &desc
ESCAPED = &head_oid
opts = &twoway_merge
nr_11 = &NULL
nr_11 = &NONLOCAL
_4 = nr_11
_5 = _4
_5 = &NONLOCAL
_6 = &desc
ESCAPED = _6
ESCAPED = oid
nr_46 = nr_11
nr_46 = &NONLOCAL
_7 = desc
ESCAPED = &STRING
ESCAPED = _7
nr.3_8 = nr_46
ESCAPED = nr.3_8
ESCAPED = &desc
ESCAPED = &opts
tmp___2_49 = NONLOCAL
ESCAPED = oid
tmp___3_55 = NONLOCAL
_9 = tmp___3_55
tree_56 = _9
ESCAPED = &the_index
ESCAPED = tree_56
ESCAPED = oid
tmp___3_51 = NONLOCAL
_10 = tmp___3_51
tree_52 = _10
ESCAPED = &the_index
ESCAPED = tree_52
_12 = tmp___0_42
_12 = &NONLOCAL
_12 = &NULL
ESCAPED = _12

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { NULL STRING ESCAPED NONLOCAL opts the_index oneway_merge head_oid desc twoway_merge }
NONLOCAL = { ESCAPED NONLOCAL } same as tmp___1_35
STOREDANYTHING = { }
INTEGER = { ANYTHING }
oid = { NONLOCAL }
reset_type = { NONLOCAL } same as oid
quiet = { NONLOCAL } same as oid
memset = { }
opts = { ESCAPED NONLOCAL the_index oneway_merge twoway_merge }
the_index = { ESCAPED NONLOCAL }
oneway_merge = { ESCAPED NONLOCAL }
read_cache_unmerged = { }
get_oid = { }
head_oid = { ESCAPED NONLOCAL }
tmp___1_35 = { ESCAPED NONLOCAL }
_ = { }
tmp_40 = { ESCAPED NONLOCAL } same as tmp___1_35
error = { }
tmp___0_42 = { ESCAPED NONLOCAL } same as tmp___1_35
fill_tree_descriptor = { }
desc = { ESCAPED NONLOCAL } same as _7
twoway_merge = { ESCAPED NONLOCAL }
nr_11 = { NULL NONLOCAL }
_4 = { NULL NONLOCAL } same as nr_11
_5 = { NULL NONLOCAL } same as nr_11
_6 = { desc }
nr_46 = { NULL NONLOCAL } same as nr_11
_7 = { ESCAPED NONLOCAL }
printf = { }
nr.3_8 = { NULL NONLOCAL } same as nr_11
unpack_trees = { }
tmp___2_49 = { ESCAPED NONLOCAL } same as tmp___1_35
parse_tree_indirect = { }
tmp___3_55 = { ESCAPED NONLOCAL } same as tmp___1_35
_9 = { ESCAPED NONLOCAL } same as tmp___1_35
tree_56 = { ESCAPED NONLOCAL } same as tmp___1_35
prime_cache_tree = { }
tmp___3_51 = { ESCAPED NONLOCAL } same as tmp___1_35
_10 = { ESCAPED NONLOCAL } same as tmp___1_35
tree_52 = { ESCAPED NONLOCAL } same as tmp___1_35
_12 = { NULL ESCAPED NONLOCAL }


Alias information for reset_index

Aliased symbols

head_oid, UID D.2064, struct object_id, is addressable
opts, UID D.2063, struct unpack_trees_options, is addressable
desc, UID D.2061, struct tree_desc[2], is addressable

Call clobber information

ESCAPED, points-to non-local, points-to NULL, points-to vars: { D.1959 D.2061 D.2063 D.2064 } (nonlocal, escaped, interposable)

Flow-insensitive points-to information

_6, points-to NULL, points-to vars: { D.2061 } (escaped)
_7, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
oid_44(D), points-to non-local, points-to NULL, points-to vars: { }
tree_52, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }
tree_56, points-to non-local, points-to escaped, points-to NULL, points-to vars: { }

reset_index (const struct object_id * oid, int reset_type, int quiet)
{
  int tmp___3;
  int tmp___2;
  int tmp___1;
  int tmp___0;
  int tmp;
  struct object_id head_oid;
  struct unpack_trees_options opts;
  struct tree * tree;
  struct tree_desc desc[2];
  int nr;
  long unsigned int _4;
  long unsigned int _5;
  struct tree_desc * _6;
  const void * _7;
  unsigned int nr.3_8;
  long int _9;
  long int _10;
  int _12;

  <bb 2> [0.00%]:
  memset (&opts, 0, 640);
  opts.head_idx = 1;
  opts.src_index = &the_index;
  opts.dst_index = &the_index;
  opts.fn = oneway_merge;
  opts.merge = 1;
  if (quiet_27(D) == 0)
    goto <bb 3>; [0.00%]
  else
    goto <bb 4>; [0.00%]

  <bb 3> [0.00%]:
  opts.verbose_update = 1;

  <bb 4> [0.00%]:
  switch (reset_type_29(D)) <default: <L5> [0.00%], case 2: <L4> [0.00%], case 3 ... 4: <L2> [0.00%]>

<L2> [0.00%]:
  opts.update = 1;
  goto <bb 8>; [0.00%]

<L4> [0.00%]:
  opts.update = 1;

<L5> [0.00%]:
  opts.reset = 1;

  <bb 8> [0.00%]:
  read_cache_unmerged ();
  if (reset_type_29(D) == 4)
    goto <bb 9>; [0.00%]
  else
    goto <bb 12>; [0.00%]

  <bb 9> [0.00%]:
  tmp___1_35 = get_oid ("HEAD", &head_oid);
  if (tmp___1_35 != 0)
    goto <bb 10>; [0.00%]
  else
    goto <bb 11>; [0.00%]

  <bb 10> [0.00%]:
  tmp_40 = _ ("You do not have a valid HEAD.");
  tmp___0_42 = error (tmp_40);
  goto <bb 18>; [0.00%]

  <bb 11> [0.00%]:
  fill_tree_descriptor (&desc, &head_oid);
  opts.fn = twoway_merge;

  <bb 12> [0.00%]:
  # nr_11 = PHI <0(8), 1(11)>
  _4 = (long unsigned int) nr_11;
  _5 = _4 * 40;
  _6 = &desc + _5;
  fill_tree_descriptor (_6, oid_44(D));
  nr_46 = nr_11 + 1;
  _7 = desc[nr_46].buffer;
  printf ("%d\n", _7);
  nr.3_8 = (unsigned int) nr_46;
  tmp___2_49 = unpack_trees (nr.3_8, &desc, &opts);
  if (tmp___2_49 != 0)
    goto <bb 18>; [0.00%]
  else
    goto <bb 13>; [0.00%]

  <bb 13> [0.00%]:
  if (reset_type_29(D) == 0)
    goto <bb 14>; [0.00%]
  else
    goto <bb 15>; [0.00%]

  <bb 14> [0.00%]:
  tmp___3_55 = parse_tree_indirect (oid_44(D));
  _9 = (long int) tmp___3_55;
  tree_56 = (struct tree *) _9;
  prime_cache_tree (&the_index, tree_56);
  goto <bb 17>; [0.00%]

  <bb 15> [0.00%]:
  if (reset_type_29(D) == 2)
    goto <bb 16>; [0.00%]
  else
    goto <bb 17>; [0.00%]

  <bb 16> [0.00%]:
  tmp___3_51 = parse_tree_indirect (oid_44(D));
  _10 = (long int) tmp___3_51;
  tree_52 = (struct tree *) _10;
  prime_cache_tree (&the_index, tree_52);

  <bb 17> [0.00%]:

  <bb 18> [0.00%]:
  # _12 = PHI <tmp___0_42(10), -1(12), 0(17)>
  desc ={v} {CLOBBER};
  opts ={v} {CLOBBER};
  head_oid ={v} {CLOBBER};
  return _12;

}



;; Function main (main, funcdef_no=10, decl_uid=2076, cgraph_uid=10, symbol_order=11)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
ESCAPED = &oid
ESCAPED = type_2
ESCAPED = quiet_3
ESCAPED = &NULL

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { NULL ESCAPED NONLOCAL oid }
NONLOCAL = { ESCAPED NONLOCAL }
STOREDANYTHING = { }
INTEGER = { ANYTHING }
reset_index = { }
oid = { ESCAPED NONLOCAL }
type_2 = { }
quiet_3 = { }


Alias information for main

Aliased symbols

oid, UID D.2078, struct object_id, is addressable

Call clobber information

ESCAPED, points-to non-local, points-to NULL, points-to vars: { D.2078 } (escaped)

Flow-insensitive points-to information


main ()
{
  int quiet;
  int type;
  struct object_id oid;

  <bb 2> [0.00%]:
  reset_index (&oid, type_2(D), quiet_3(D));
  oid ={v} {CLOBBER};
  return 0;

}


