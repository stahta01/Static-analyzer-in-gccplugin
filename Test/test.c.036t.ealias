
;; Function foo (foo, funcdef_no=51, decl_uid=4307, cgraph_uid=51, symbol_order=51)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
z = &NONLOCAL
ESCAPED = &NONLOCAL
_1 = &HEAP(11)
_2 = _1
_3 = _2
*z = _3

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { ESCAPED NONLOCAL HEAP(11) }
NONLOCAL = { ESCAPED NONLOCAL }
STOREDANYTHING = { }
INTEGER = { ANYTHING }
z = { NONLOCAL }
malloc = { }
_1 = { HEAP(11) }
HEAP(11) = { ESCAPED NONLOCAL }
_2 = { HEAP(11) } same as _1
_3 = { HEAP(11) } same as _1


Alias information for foo

Aliased symbols


Call clobber information

ESCAPED, points-to non-local, points-to vars: { D.4359 } (escaped, escaped heap)

Flow-insensitive points-to information

_1, points-to NULL, points-to vars: { D.4359 } (escaped, escaped heap)
z_6(D), points-to non-local, points-to NULL, points-to vars: { }

__attribute__((noinline))
foo (int * z)
{
  void * _1;
  long int _2;
  int _3;

  <bb 2> [0.00%]:
  _1 = malloc (10);
  _2 = (long int) _1;
  _3 = (int) _2;
  *z_6(D) = _3;
  return;

}



;; Function main (main, funcdef_no=52, decl_uid=4313, cgraph_uid=52, symbol_order=52)

Points-to analysis

Constraints:

ANYTHING = &ANYTHING
ESCAPED = *ESCAPED
ESCAPED = ESCAPED + UNKNOWN
*ESCAPED = NONLOCAL
NONLOCAL = &NONLOCAL
NONLOCAL = &ESCAPED
INTEGER = &ANYTHING
ESCAPED = p5_12
ESCAPED = p5_12
_1 = test5_15
_1 = &NONLOCAL
ESCAPED = p5_12
ESCAPED = p5_12
ESCAPED = p5_12
ESCAPED = p_23
ESCAPED = p_23
ESCAPED = p_23
ESCAPED = p_23
ESCAPED = p3_27
ESCAPED = p5_12
ESCAPED = p_23
ESCAPED = p_23
ESCAPED = p4_21
ESCAPED = &NULL

Collapsing static cycles and doing variable substitution
Building predecessor graph
Detecting pointer and location equivalences
Rewriting constraints and unifying variables
Uniting pointer but not location equivalent variables
Finding indirect cycles
Solving graph

Points-to sets

ANYTHING = { ANYTHING }
ESCAPED = { NULL }
NONLOCAL = { ESCAPED NONLOCAL }
STOREDANYTHING = { }
INTEGER = { ANYTHING }
foo = { }
p5_12 = { }
_1 = { NONLOCAL }
test5_15 = { }
p_23 = { }
p3_27 = { }
p4_21 = { }


Alias information for main

Aliased symbols


Call clobber information

ESCAPED, points-to NULL, points-to vars: { }

Flow-insensitive points-to information

p5_12(D), points-to NULL, points-to vars: { }
p4_21(D), points-to NULL, points-to vars: { }
p_23(D), points-to NULL, points-to vars: { }
p3_27(D), points-to NULL, points-to vars: { }

main ()
{
  int d;
  int c;
  int b;
  int a;
  int test5;
  int test3;
  int test2;
  int test;
  int * p5;
  int * p4;
  int * p3;
  int * p;
  int _1;

  <bb 2> [0.00%]:

label2 [0.00%]:
  foo (p5_12(D));

label3 [0.00%]:
  foo (p5_12(D));
  _1 = test5_15(D) / 10;
  switch (_1) <default: <L4> [0.00%], case 5: <L2> [0.00%], case 10: <L3> [0.00%]>

<L2> [0.00%]:
  foo (p5_12(D));
  goto <bb 8>; [0.00%]

<L3> [0.00%]:
  foo (p5_12(D));
  goto <bb 8>; [0.00%]

<L4> [0.00%]:
  foo (p5_12(D));

  <bb 8> [0.00%]:
  if (test_19(D) != 0)
    goto <bb 9>; [0.00%]
  else
    goto <bb 18>; [0.00%]

  <bb 9> [0.00%]:
  if (test_19(D) > test2_20(D))
    goto <bb 10>; [0.00%]
  else
    goto <bb 13>; [0.00%]

  <bb 10> [0.00%]:
  foo (p_23(D));
  if (test_19(D) < test2_20(D))
    goto <bb 11>; [0.00%]
  else
    goto <bb 12>; [0.00%]

  <bb 11> [0.00%]:
  foo (p_23(D));
  goto <bb 16>; [0.00%]

  <bb 12> [0.00%]:
  foo (p_23(D));
  goto <bb 16>; [0.00%]

  <bb 13> [0.00%]:
  foo (p_23(D));
  if (test_19(D) < test2_20(D))
    goto <bb 14>; [0.00%]
  else
    goto <bb 15>; [0.00%]

  <bb 14> [0.00%]:
  foo (p3_27(D));
  goto <bb 4> (label3); [0.00%]

  <bb 15> [0.00%]:
  foo (p5_12(D));
  goto <bb 4> (label3); [0.00%]

  <bb 16> [0.00%]:
  if (test3_32(D) != 0)
    goto <bb 17>; [0.00%]
  else
    goto <bb 22>; [0.00%]

  <bb 17> [0.00%]:
  foo (p_23(D));
  goto <bb 3> (label2); [0.00%]

  <bb 18> [0.00%]:
  if (test_19(D) == test2_20(D))
    goto <bb 19>; [0.00%]
  else
    goto <bb 20>; [0.00%]

  <bb 19> [0.00%]:
  foo (p_23(D));
  goto <bb 22>; [0.00%]

  <bb 20> [0.00%]:
  if (test_19(D) > test2_20(D))
    goto <bb 21>; [0.00%]
  else
    goto <bb 22>; [0.00%]

  <bb 21> [0.00%]:
  foo (p4_21(D));

  <bb 22> [0.00%]:
  return 0;

}


