
;; Function xrealloc (xrealloc, funcdef_no=26, decl_uid=3195, cgraph_uid=27, symbol_order=27)

Merging blocks 9 and 10
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9
;; 2 succs { 3 4 }
;; 3 succs { 4 }
;; 4 succs { 5 9 }
;; 5 succs { 6 7 }
;; 6 succs { 7 }
;; 7 succs { 8 9 }
;; 8 succs { }
;; 9 succs { 1 }
void * xrealloc (void * ptr, size_t size)
{
  void * ret;
  void * D.3389;

  <bb 2> :
  ret = realloc (ptr, size);
  _1 = ret == 0B;
  _2 = size == 0;
  _3 = _1 & _2;
  if (_3 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  ret = realloc (ptr, 1);

  <bb 4> :
  if (ret == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 5> :
  ret = realloc (ptr, size);
  _4 = ret == 0B;
  _5 = size == 0;
  _6 = _4 & _5;
  if (_6 != 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  ret = realloc (ptr, 1);

  <bb 7> :
  if (ret == 0B)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  printf ("Out of memory, realloc failed%s", "");
  exit (1);

  <bb 9> :
  D.3389 = ret;
  return D.3389;

}



;; Function strbuf_init (strbuf_init, funcdef_no=27, decl_uid=3210, cgraph_uid=28, symbol_order=29)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4
;; 2 succs { 3 4 }
;; 3 succs { 4 }
;; 4 succs { 1 }
void strbuf_init (struct strbuf * sb, size_t hint)
{
  <bb 2> :
  sb->len = 0;
  _1 = sb->len;
  sb->alloc = _1;
  sb->buf = &strbuf_slopbuf;
  if (hint != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  strbuf_grow (sb, hint);

  <bb 4> :
  return;

}



;; Function strbuf_release (strbuf_release, funcdef_no=28, decl_uid=3215, cgraph_uid=29, symbol_order=30)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4
;; 2 succs { 3 4 }
;; 3 succs { 4 }
;; 4 succs { 1 }
void strbuf_release (struct strbuf * sb)
{
  <bb 2> :
  _1 = sb->alloc;
  if (_1 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  _2 = sb->buf;
  free (_2);
  strbuf_init (sb, 0);

  <bb 4> :
  return;

}



;; Function strbuf_detach (strbuf_detach, funcdef_no=30, decl_uid=3223, cgraph_uid=31, symbol_order=32)

Merging blocks 4 and 5
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4
;; 2 succs { 3 4 }
;; 3 succs { 4 }
;; 4 succs { 1 }
char * strbuf_detach (struct strbuf * sb, size_t * sz)
{
  char * res;
  char * D.3397;

  <bb 2> :
  strbuf_grow (sb, 0);
  res = sb->buf;
  if (sz != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  _1 = sb->len;
  *sz = _1;

  <bb 4> :
  strbuf_init (sb, 0);
  D.3397 = res;
  return D.3397;

}



;; Function strbuf_attach (strbuf_attach, funcdef_no=31, decl_uid=3231, cgraph_uid=32, symbol_order=33)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
void strbuf_attach (struct strbuf * sb, void * buf, size_t len, size_t alloc)
{
  <bb 2> :
  strbuf_release (sb);
  sb->buf = buf;
  sb->len = len;
  sb->alloc = alloc;
  strbuf_grow (sb, 0);
  _1 = sb->buf;
  _2 = sb->len;
  _3 = _1 + _2;
  *_3 = 0;
  return;

}



;; Function strbuf_grow (strbuf_grow, funcdef_no=32, decl_uid=3212, cgraph_uid=33, symbol_order=34)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14
;; 2 succs { 4 3 }
;; 3 succs { 4 5 }
;; 4 succs { }
;; 5 succs { 6 7 }
;; 6 succs { 7 }
;; 7 succs { 8 12 }
;; 8 succs { 9 10 }
;; 9 succs { 11 }
;; 10 succs { 11 }
;; 11 succs { 12 }
;; 12 succs { 13 14 }
;; 13 succs { 14 }
;; 14 succs { 1 }
void strbuf_grow (struct strbuf * sb, size_t extra)
{
  int new_buf;

  <bb 2> :
  _1 = sb->alloc;
  _2 = _1 == 0;
  new_buf = (int) _2;
  _3 = unsigned_add_overflows (extra, 1);
  if (_3 != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 3>; [INV]

  <bb 3> :
  _4 = extra + 1;
  _5 = sb->len;
  _6 = unsigned_add_overflows (_5, _4);
  if (_6 != 0)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  printf ("you want to use way too much memory%s", "");
  exit (1);

  <bb 5> :
  if (new_buf != 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  sb->buf = 0B;

  <bb 7> :
  _7 = sb->len;
  _8 = extra + _7;
  _9 = _8 + 1;
  _10 = sb->alloc;
  if (_9 > _10)
    goto <bb 8>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 8> :
  _11 = sb->alloc;
  _12 = alloc_nr (_11);
  _13 = (long unsigned int) _12;
  _14 = sb->len;
  _15 = extra + _14;
  _16 = _15 + 1;
  if (_13 < _16)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  _17 = sb->len;
  _18 = extra + _17;
  _19 = _18 + 1;
  sb->alloc = _19;
  goto <bb 11>; [INV]

  <bb 10> :
  _20 = sb->alloc;
  _21 = alloc_nr (_20);
  _22 = (long unsigned int) _21;
  sb->alloc = _22;

  <bb 11> :
  _23 = sb->alloc;
  _24 = st_mult (1, _23);
  _25 = (long unsigned int) _24;
  _26 = sb->buf;
  _27 = xrealloc (_26, _25);
  sb->buf = _27;

  <bb 12> :
  if (new_buf != 0)
    goto <bb 13>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 13> :
  _28 = sb->buf;
  *_28 = 0;

  <bb 14> :
  return;

}



;; Function strbuf_vaddf (strbuf_vaddf, funcdef_no=33, decl_uid=3249, cgraph_uid=34, symbol_order=35)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4
;; 2 succs { 3 4 }
;; 3 succs { 4 }
;; 4 succs { 1 }
void strbuf_vaddf (struct strbuf * sb, const char * fmt, const char * ap)
{
  const char * cp;
  int len;

  <bb 2> :
  cp = ap;
  _1 = strbuf_avail (sb);
  if (_1 == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  strbuf_grow (sb, 64);

  <bb 4> :
  _2 = sb->len;
  _3 = (long unsigned int) len;
  _4 = _2 + _3;
  strbuf_setlen (sb, _4);
  return;

}



;; Function strbuf_setlen (strbuf_setlen, funcdef_no=29, decl_uid=3219, cgraph_uid=30, symbol_order=31)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7
;; 2 succs { 3 4 }
;; 3 succs { 5 }
;; 4 succs { 5 }
;; 5 succs { 6 7 }
;; 6 succs { }
;; 7 succs { 1 }
void strbuf_setlen (struct strbuf * sb, size_t len)
{
  size_t iftmp.0;

  <bb 2> :
  _1 = sb->alloc;
  if (_1 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  _2 = sb->alloc;
  iftmp.0 = _2 + 18446744073709551615;
  goto <bb 5>; [INV]

  <bb 4> :
  iftmp.0 = 0;

  <bb 5> :
  if (iftmp.0 < len)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  printf ("BUG: strbuf_setlen() beyond buffer%s", "");
  exit (1);

  <bb 7> :
  sb->len = len;
  _3 = sb->buf;
  _4 = _3 + len;
  *_4 = 0;
  return;

}



;; Function strbuf_addf (strbuf_addf, funcdef_no=34, decl_uid=3258, cgraph_uid=35, symbol_order=36)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
void strbuf_addf (struct strbuf * sb, const char * fmt, const char * ap)
{
  <bb 2> :
  strbuf_vaddf (sb, fmt, ap);
  return;

}



;; Function checkout_entry (checkout_entry, funcdef_no=36, decl_uid=3272, cgraph_uid=37, symbol_order=38)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5
;; 2 succs { 3 4 }
;; 3 succs { 5 }
;; 4 succs { 5 }
;; 5 succs { 1 }
int checkout_entry (struct cache_entry * ce, const struct checkout * state, char * topath)
{
  <<< error >>> st;
  static struct strbuf path = {.alloc=0, .len=0, .buf=(char *) &strbuf_slopbuf};
  int D.3421;

  <bb 2> :
  if (topath != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  D.3421 = write_entry (ce, topath, state, 1);
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 5>; [INV]

  <bb 4> :
  strbuf_reset (&path);
  _1 = state->base_dir_len;
  _2 = state->base_dir;
  strbuf_add (&path, _2, _1);
  _3 = path.len;
  _4 = path.buf;
  create_directories (_4, _3, state);
  _5 = path.buf;
  D.3421 = write_entry (ce, _5, state, 0);

  <bb 5> :
  return D.3421;

}



;; Function main (main, funcdef_no=39, decl_uid=3377, cgraph_uid=40, symbol_order=41)

Removing basic block 3
Merging blocks 2 and 4
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
int main (int argc, char * * argv)
{
  int symlinks;
  int D.3423;

  <bb 2> :
  run_dir_diff ("extcmd", symlinks, "prefix", argc, argv);
  D.3423 = 0;
  return D.3423;

}



;; Function run_dir_diff (run_dir_diff, funcdef_no=38, decl_uid=3301, cgraph_uid=39, symbol_order=40)

Removing basic block 19
Removing basic block 24
Merging blocks 31 and 32
;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29
;;
;; Loop 1
;;  header 27, latch 24
;;  depth 1, outer 0
;;  nodes: 27 24 14 15 17 21 20 19 16 11 12
;; 2 succs { 3 4 }
;; 3 succs { 5 }
;; 4 succs { 5 }
;; 5 succs { 6 7 }
;; 6 succs { 29 }
;; 7 succs { 9 8 }
;; 8 succs { 9 10 }
;; 9 succs { 10 }
;; 10 succs { 27 }
;; 11 succs { 12 14 }
;; 12 succs { 13 14 }
;; 13 succs { 25 }
;; 14 succs { 15 24 }
;; 15 succs { 16 24 }
;; 16 succs { 17 19 }
;; 17 succs { 18 24 }
;; 18 succs { 25 }
;; 19 succs { 20 23 }
;; 20 succs { 21 24 }
;; 21 succs { 22 24 }
;; 22 succs { 26 }
;; 23 succs { 26 }
;; 24 succs { 27 }
;; 25 succs { 29 }
;; 26 succs { 28 }
;; 27 succs { 11 28 }
;; 28 succs { 29 }
;; 29 succs { 1 }
int run_dir_diff (const char * extcmd, int symlinks, const char * prefix, int argc, const char * * argv)
{
  struct cache_entry * ce2;
  struct working_tree_entry * entry;
  const char * dst_path;
  const char * src_path;
  char status;
  struct object_id roid;
  struct object_id loid;
  int rmode;
  int lmode;
  int indices_loaded;
  struct hashmap tmp_modified;
  struct hashmap wt_modified;
  const char * helper_argv[4];
  struct checkout rstate;
  struct checkout lstate;
  struct index_state wtindex;
  struct pair_entry * entry;
  <<< error >>> iter;
  struct hashmap symlinks2;
  struct hashmap submodules;
  struct hashmap working_tree_dups;
  struct FILE * fp;
  int i;
  int ret;
  const char * tmp;
  const char * workdir;
  size_t wtdir_len;
  size_t rdir_len;
  size_t ldir_len;
  struct strbuf wtdir;
  struct strbuf rdir;
  struct strbuf ldir;
  struct strbuf buf;
  struct strbuf rpath;
  struct strbuf lpath;
  struct strbuf info;
  char tmpdir[4096];
  int D.3431;
  const char * iftmp.1;

  <bb 2> :
  info.alloc = 0;
  info.len = 0;
  info.buf = &strbuf_slopbuf;
  lpath.alloc = 0;
  lpath.len = 0;
  lpath.buf = &strbuf_slopbuf;
  rpath.alloc = 0;
  rpath.len = 0;
  rpath.buf = &strbuf_slopbuf;
  buf.alloc = 0;
  buf.len = 0;
  buf.buf = &strbuf_slopbuf;
  ldir.alloc = 0;
  ldir.len = 0;
  ldir.buf = &strbuf_slopbuf;
  rdir.alloc = 0;
  rdir.len = 0;
  rdir.buf = &strbuf_slopbuf;
  wtdir.alloc = 0;
  wtdir.len = 0;
  wtdir.buf = &strbuf_slopbuf;
  ret = 0;
  helper_argv[0] = "difftool--helper";
  helper_argv[1] = 0B;
  helper_argv[2] = 0B;
  helper_argv[3] = 0B;
  indices_loaded = 0;
  _1 = get_git_work_tree ();
  _2 = (long int) _1;
  workdir = (const char *) _2;
  tmp = getenv ("TMPDIR");
  if (tmp != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  iftmp.1 = tmp;
  goto <bb 5>; [INV]

  <bb 4> :
  iftmp.1 = "/tmp";

  <bb 5> :
  xsnprintf (&tmpdir, 4096, "%s/git-difftool.XXXXXX", iftmp.1);
  _3 = mkdtemp (&tmpdir);
  if (_3 == 0B)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  D.3431 = error ("could not create \'%s\'", &tmpdir);
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 29>; [INV]

  <bb 7> :
  strbuf_addf (&ldir, "%s/left/", &tmpdir);
  strbuf_addf (&rdir, "%s/right/", &tmpdir);
  strbuf_addstr (&wtdir, workdir);
  _4 = wtdir.len;
  if (_4 == 0)
    goto <bb 9>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 8> :
  _5 = wtdir.buf;
  _6 = wtdir.len;
  _7 = _6 + 18446744073709551615;
  _8 = _5 + _7;
  _9 = *_8;
  _10 = (int) _9;
  _11 = is_dir_sep (_10);
  if (_11 == 0)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  strbuf_addch (&wtdir, 47);

  <bb 10> :
  _12 = ldir.buf;
  mkdir (_12, 448);
  _13 = rdir.buf;
  mkdir (_13, 448);
  memset (&wtindex, 0, 80);
  memset (&lstate, 0, 24);
  _14 = ldir.buf;
  lstate.base_dir = _14;
  _15 = ldir.len;
  _16 = (int) _15;
  lstate.base_dir_len = _16;
  lstate.force = 1;
  memset (&rstate, 0, 24);
  _17 = rdir.buf;
  rstate.base_dir = _17;
  _18 = rdir.len;
  _19 = (int) _18;
  rstate.base_dir_len = _19;
  rstate.force = 1;
  ldir_len = ldir.len;
  rdir_len = rdir.len;
  wtdir_len = wtdir.len;
  i = 0;
  goto <bb 27>; [INV]

  <bb 11> :
  _20 = lmode != 0;
  _21 = status != 67;
  _22 = _20 & _21;
  if (_22 != 0)
    goto <bb 12>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 12> :
  lmode.2_23 = (unsigned int) lmode;
  _24 = checkout_path (lmode.2_23, &loid, src_path, &lstate);
  if (_24 != 0)
    goto <bb 13>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 13> :
  D.3431 = error ("could not write \'%s\'", src_path);
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 25>; [INV]

  <bb 14> :
  if (rmode != 0)
    goto <bb 15>; [INV]
  else
    goto <bb 24>; [INV]

  <bb 15> :
  _25 = S_ISLNK (rmode);
  if (_25 == 0)
    goto <bb 16>; [INV]
  else
    goto <bb 24>; [INV]

  <bb 16> :
  _26 = use_wt_file (workdir, dst_path, &roid);
  if (_26 == 0)
    goto <bb 17>; [INV]
  else
    goto <bb 19>; [INV]

  <bb 17> :
  rmode.3_27 = (unsigned int) rmode;
  _28 = checkout_path (rmode.3_27, &roid, dst_path, &rstate);
  if (_28 != 0)
    goto <bb 18>; [INV]
  else
    goto <bb 24>; [INV]

  <bb 18> :
  D.3431 = error ("could not write \'%s\'", dst_path);
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 25>; [INV]

  <bb 19> :
  _29 = is_null_oid (&roid);
  if (_29 == 0)
    goto <bb 20>; [INV]
  else
    goto <bb 23>; [INV]

  <bb 20> :
  _30 = make_cache_entry (rmode, &roid.hash, dst_path, 0, 0);
  _31 = (long int) _30;
  ce2 = (struct cache_entry *) _31;
  add_path (&rdir, rdir_len, dst_path);
  if (symlinks != 0)
    goto <bb 21>; [INV]
  else
    goto <bb 24>; [INV]

  <bb 21> :
  _32 = rdir.buf;
  _33 = wtdir.buf;
  _34 = symlink (_33, _32);
  if (_34 != 0)
    goto <bb 22>; [INV]
  else
    goto <bb 24>; [INV]

  <bb 22> :
  _35 = rdir.buf;
  _36 = wtdir.buf;
  ret = error_errno ("could not symlink \'%s\' to \'%s\'", _36, _35);
  // predicted unlikely by goto predictor.
  goto <bb 26>; [INV]

  <bb 23> :
  // predicted unlikely by goto predictor.
  goto <bb 26>; [INV]

  <bb 24> :
  loid = {CLOBBER};
  roid = {CLOBBER};
  goto <bb 27>; [INV]

  <bb 25> :
  loid = {CLOBBER};
  roid = {CLOBBER};
  goto <bb 29>; [INV]

  <bb 26> :
  loid = {CLOBBER};
  roid = {CLOBBER};
  goto <bb 28>; [INV]

  <bb 27> :
  _37 = strbuf_getline_nul (&info, fp);
  if (_37 == 0)
    goto <bb 11>; [INV]
  else
    goto <bb 28>; [INV]

  <bb 28> :
finish:
  strbuf_release (&ldir);
  strbuf_release (&rdir);
  strbuf_release (&wtdir);
  strbuf_release (&buf);
  D.3431 = ret;

  <bb 29> :
  tmpdir = {CLOBBER};
  info = {CLOBBER};
  lpath = {CLOBBER};
  rpath = {CLOBBER};
  buf = {CLOBBER};
  ldir = {CLOBBER};
  rdir = {CLOBBER};
  wtdir = {CLOBBER};
  working_tree_dups = {CLOBBER};
  submodules = {CLOBBER};
  symlinks2 = {CLOBBER};
  wtindex = {CLOBBER};
  lstate = {CLOBBER};
  rstate = {CLOBBER};
  helper_argv = {CLOBBER};
  wt_modified = {CLOBBER};
  tmp_modified = {CLOBBER};
  return D.3431;

}



;; Function checkout_path (checkout_path, funcdef_no=37, decl_uid=3290, cgraph_uid=38, symbol_order=39)

Merging blocks 2 and 3
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
int checkout_path (unsigned int mode, struct object_id * oid, const char * path, const struct checkout * state)
{
  int ret;
  struct cache_entry * ce;
  int D.3460;

  <bb 2> :
  _1 = &oid->hash;
  _2 = make_cache_entry (mode, _1, path, 0, 0);
  _3 = (long int) _2;
  ce = (struct cache_entry *) _3;
  ret = checkout_entry (ce, state, 0B);
  free (ce);
  D.3460 = ret;
  return D.3460;

}



;; Function add_path (add_path, funcdef_no=35, decl_uid=3263, cgraph_uid=36, symbol_order=37)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5
;; 2 succs { 3 5 }
;; 3 succs { 4 5 }
;; 4 succs { 5 }
;; 5 succs { 1 }
void add_path (struct strbuf * buf, size_t base_len, const char * path)
{
  <bb 2> :
  strbuf_setlen (buf, base_len);
  _1 = buf->len;
  if (_1 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 3> :
  _2 = buf->buf;
  _3 = buf->len;
  _4 = _3 + 18446744073709551615;
  _5 = _2 + _4;
  _6 = *_5;
  if (_6 != 47)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  strbuf_addch (buf, 47);

  <bb 5> :
  strbuf_addstr (buf, path);
  return;

}


