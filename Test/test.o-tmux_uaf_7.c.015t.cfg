
;; Function winlink_cmp (winlink_cmp, funcdef_no=22, decl_uid=4011, cgraph_uid=23, symbol_order=24)

Merging blocks 2 and 3
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
int winlink_cmp (struct winlink * wl1, struct winlink * wl2)
{
  int D.4329;

  <bb 2> :
  _1 = wl1->idx;
  _2 = wl2->idx;
  D.4329 = _1 - _2;
  return D.4329;

}



;; Function winlinks_RB_INSERT_COLOR (winlinks_RB_INSERT_COLOR, funcdef_no=23, decl_uid=4015, cgraph_uid=24, symbol_order=25)

Removing basic block 14
Merging blocks 16 and 17
Removing basic block 24
Merging blocks 26 and 27
Removing basic block 38
Merging blocks 40 and 41
Removing basic block 48
;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46
;;
;; Loop 1
;;  header 44, multiple latches: 6 23 26 43
;;  depth 1, outer 0
;;  nodes: 44 6 23 26 43 41 42 40 39 38 36 37 27 35 33 34 32 31 30 28 29 24 25 3 45 21 22 20 19 18 16 17 7 15 13 14 12 11 10 8 9 4 5
;; 2 succs { 44 }
;; 3 succs { 4 24 }
;; 4 succs { 5 7 }
;; 5 succs { 6 7 }
;; 6 succs { 44 }
;; 7 succs { 8 16 }
;; 8 succs { 9 10 }
;; 9 succs { 10 }
;; 10 succs { 11 14 }
;; 11 succs { 12 13 }
;; 12 succs { 15 }
;; 13 succs { 15 }
;; 14 succs { 15 }
;; 15 succs { 16 }
;; 16 succs { 17 18 }
;; 17 succs { 18 }
;; 18 succs { 19 22 }
;; 19 succs { 20 21 }
;; 20 succs { 23 }
;; 21 succs { 23 }
;; 22 succs { 23 }
;; 23 succs { 44 }
;; 24 succs { 25 27 }
;; 25 succs { 26 27 }
;; 26 succs { 44 }
;; 27 succs { 28 36 }
;; 28 succs { 29 30 }
;; 29 succs { 30 }
;; 30 succs { 31 34 }
;; 31 succs { 32 33 }
;; 32 succs { 35 }
;; 33 succs { 35 }
;; 34 succs { 35 }
;; 35 succs { 36 }
;; 36 succs { 37 38 }
;; 37 succs { 38 }
;; 38 succs { 39 42 }
;; 39 succs { 40 41 }
;; 40 succs { 43 }
;; 41 succs { 43 }
;; 42 succs { 43 }
;; 43 succs { 44 }
;; 44 succs { 45 46 }
;; 45 succs { 3 46 }
;; 46 succs { 1 }
void winlinks_RB_INSERT_COLOR (struct winlinks * head, struct winlink * elm)
{
  struct winlink * tmp;
  struct winlink * gparent;
  struct winlink * parent;

  <bb 2> :
  goto <bb 44>; [INV]

  <bb 3> :
  gparent = parent->entry.rbe_parent;
  _1 = gparent->entry.rbe_left;
  if (parent == _1)
    goto <bb 4>; [INV]
  else
    goto <bb 24>; [INV]

  <bb 4> :
  tmp = gparent->entry.rbe_right;
  if (tmp != 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 5> :
  _2 = tmp->entry.rbe_color;
  if (_2 == 1)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  tmp->entry.rbe_color = 0;
  parent->entry.rbe_color = 0;
  gparent->entry.rbe_color = 1;
  elm = gparent;
  // predicted unlikely by continue predictor.
  goto <bb 44>; [INV]

  <bb 7> :
  _3 = parent->entry.rbe_right;
  if (elm == _3)
    goto <bb 8>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 8> :
  tmp = parent->entry.rbe_right;
  _4 = tmp->entry.rbe_left;
  parent->entry.rbe_right = _4;
  _5 = parent->entry.rbe_right;
  if (_5 != 0B)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  _6 = tmp->entry.rbe_left;
  _6->entry.rbe_parent = parent;

  <bb 10> :
  _7 = parent->entry.rbe_parent;
  tmp->entry.rbe_parent = _7;
  _8 = tmp->entry.rbe_parent;
  if (_8 != 0B)
    goto <bb 11>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 11> :
  _9 = parent->entry.rbe_parent;
  _10 = _9->entry.rbe_left;
  if (parent == _10)
    goto <bb 12>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 12> :
  _11 = parent->entry.rbe_parent;
  _11->entry.rbe_left = tmp;
  goto <bb 15>; [INV]

  <bb 13> :
  _12 = parent->entry.rbe_parent;
  _12->entry.rbe_right = tmp;
  goto <bb 15>; [INV]

  <bb 14> :
  head->rbh_root = tmp;

  <bb 15> :
  tmp->entry.rbe_left = parent;
  parent->entry.rbe_parent = tmp;
  _13 = tmp->entry.rbe_parent;
  tmp = parent;
  parent = elm;
  elm = tmp;

  <bb 16> :
  parent->entry.rbe_color = 0;
  gparent->entry.rbe_color = 1;
  tmp = gparent->entry.rbe_left;
  _14 = tmp->entry.rbe_right;
  gparent->entry.rbe_left = _14;
  _15 = gparent->entry.rbe_left;
  if (_15 != 0B)
    goto <bb 17>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 17> :
  _16 = tmp->entry.rbe_right;
  _16->entry.rbe_parent = gparent;

  <bb 18> :
  _17 = gparent->entry.rbe_parent;
  tmp->entry.rbe_parent = _17;
  _18 = tmp->entry.rbe_parent;
  if (_18 != 0B)
    goto <bb 19>; [INV]
  else
    goto <bb 22>; [INV]

  <bb 19> :
  _19 = gparent->entry.rbe_parent;
  _20 = _19->entry.rbe_left;
  if (gparent == _20)
    goto <bb 20>; [INV]
  else
    goto <bb 21>; [INV]

  <bb 20> :
  _21 = gparent->entry.rbe_parent;
  _21->entry.rbe_left = tmp;
  goto <bb 23>; [INV]

  <bb 21> :
  _22 = gparent->entry.rbe_parent;
  _22->entry.rbe_right = tmp;
  goto <bb 23>; [INV]

  <bb 22> :
  head->rbh_root = tmp;

  <bb 23> :
  tmp->entry.rbe_right = gparent;
  gparent->entry.rbe_parent = tmp;
  _23 = tmp->entry.rbe_parent;
  goto <bb 44>; [INV]

  <bb 24> :
  tmp = gparent->entry.rbe_left;
  if (tmp != 0B)
    goto <bb 25>; [INV]
  else
    goto <bb 27>; [INV]

  <bb 25> :
  _24 = tmp->entry.rbe_color;
  if (_24 == 1)
    goto <bb 26>; [INV]
  else
    goto <bb 27>; [INV]

  <bb 26> :
  tmp->entry.rbe_color = 0;
  parent->entry.rbe_color = 0;
  gparent->entry.rbe_color = 1;
  elm = gparent;
  // predicted unlikely by continue predictor.
  goto <bb 44>; [INV]

  <bb 27> :
  _25 = parent->entry.rbe_left;
  if (elm == _25)
    goto <bb 28>; [INV]
  else
    goto <bb 36>; [INV]

  <bb 28> :
  tmp = parent->entry.rbe_left;
  _26 = tmp->entry.rbe_right;
  parent->entry.rbe_left = _26;
  _27 = parent->entry.rbe_left;
  if (_27 != 0B)
    goto <bb 29>; [INV]
  else
    goto <bb 30>; [INV]

  <bb 29> :
  _28 = tmp->entry.rbe_right;
  _28->entry.rbe_parent = parent;

  <bb 30> :
  _29 = parent->entry.rbe_parent;
  tmp->entry.rbe_parent = _29;
  _30 = tmp->entry.rbe_parent;
  if (_30 != 0B)
    goto <bb 31>; [INV]
  else
    goto <bb 34>; [INV]

  <bb 31> :
  _31 = parent->entry.rbe_parent;
  _32 = _31->entry.rbe_left;
  if (parent == _32)
    goto <bb 32>; [INV]
  else
    goto <bb 33>; [INV]

  <bb 32> :
  _33 = parent->entry.rbe_parent;
  _33->entry.rbe_left = tmp;
  goto <bb 35>; [INV]

  <bb 33> :
  _34 = parent->entry.rbe_parent;
  _34->entry.rbe_right = tmp;
  goto <bb 35>; [INV]

  <bb 34> :
  head->rbh_root = tmp;

  <bb 35> :
  tmp->entry.rbe_right = parent;
  parent->entry.rbe_parent = tmp;
  _35 = tmp->entry.rbe_parent;
  tmp = parent;
  parent = elm;
  elm = tmp;

  <bb 36> :
  parent->entry.rbe_color = 0;
  gparent->entry.rbe_color = 1;
  tmp = gparent->entry.rbe_right;
  _36 = tmp->entry.rbe_left;
  gparent->entry.rbe_right = _36;
  _37 = gparent->entry.rbe_right;
  if (_37 != 0B)
    goto <bb 37>; [INV]
  else
    goto <bb 38>; [INV]

  <bb 37> :
  _38 = tmp->entry.rbe_left;
  _38->entry.rbe_parent = gparent;

  <bb 38> :
  _39 = gparent->entry.rbe_parent;
  tmp->entry.rbe_parent = _39;
  _40 = tmp->entry.rbe_parent;
  if (_40 != 0B)
    goto <bb 39>; [INV]
  else
    goto <bb 42>; [INV]

  <bb 39> :
  _41 = gparent->entry.rbe_parent;
  _42 = _41->entry.rbe_left;
  if (gparent == _42)
    goto <bb 40>; [INV]
  else
    goto <bb 41>; [INV]

  <bb 40> :
  _43 = gparent->entry.rbe_parent;
  _43->entry.rbe_left = tmp;
  goto <bb 43>; [INV]

  <bb 41> :
  _44 = gparent->entry.rbe_parent;
  _44->entry.rbe_right = tmp;
  goto <bb 43>; [INV]

  <bb 42> :
  head->rbh_root = tmp;

  <bb 43> :
  tmp->entry.rbe_left = gparent;
  gparent->entry.rbe_parent = tmp;
  _45 = tmp->entry.rbe_parent;

  <bb 44> :
  parent = elm->entry.rbe_parent;
  if (parent != 0B)
    goto <bb 45>; [INV]
  else
    goto <bb 46>; [INV]

  <bb 45> :
  _46 = parent->entry.rbe_color;
  if (_46 == 1)
    goto <bb 3>; [INV]
  else
    goto <bb 46>; [INV]

  <bb 46> :
  _47 = head->rbh_root;
  _47->entry.rbe_color = 0;
  return;

}



;; Function winlinks_RB_REMOVE_COLOR (winlinks_RB_REMOVE_COLOR, funcdef_no=24, decl_uid=4066, cgraph_uid=25, symbol_order=26)

Removing basic block 11
Merging blocks 13 and 14
Merging blocks 19 and 46
Removing basic block 30
Merging blocks 32 and 33
Removing basic block 42
Merging blocks 44 and 45
Removing basic block 54
Merging blocks 56 and 57
Removing basic block 73
Merging blocks 75 and 76
Removing basic block 85
Merging blocks 87 and 88
;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81
;;
;; Loop 1
;;  header 76, multiple latches: 17 53
;;  depth 1, outer 0
;;  nodes: 76 17 53 51 52 49 50 40 48 46 47 45 44 43 41 42 3 78 77 15 16 13 14 4 12 10 11 9 8 7 5 6
;; 2 succs { 76 }
;; 3 succs { 4 40 }
;; 4 succs { 5 13 }
;; 5 succs { 6 7 }
;; 6 succs { 7 }
;; 7 succs { 8 11 }
;; 8 succs { 9 10 }
;; 9 succs { 12 }
;; 10 succs { 12 }
;; 11 succs { 12 }
;; 12 succs { 13 }
;; 13 succs { 15 14 }
;; 14 succs { 15 18 }
;; 15 succs { 17 16 }
;; 16 succs { 17 18 }
;; 17 succs { 76 }
;; 18 succs { 20 19 }
;; 19 succs { 20 30 }
;; 20 succs { 21 22 }
;; 21 succs { 22 }
;; 22 succs { 23 24 }
;; 23 succs { 24 }
;; 24 succs { 25 28 }
;; 25 succs { 26 27 }
;; 26 succs { 29 }
;; 27 succs { 29 }
;; 28 succs { 29 }
;; 29 succs { 30 }
;; 30 succs { 31 32 }
;; 31 succs { 32 }
;; 32 succs { 33 34 }
;; 33 succs { 34 }
;; 34 succs { 35 38 }
;; 35 succs { 36 37 }
;; 36 succs { 39 }
;; 37 succs { 39 }
;; 38 succs { 39 }
;; 39 succs { 79 }
;; 40 succs { 41 49 }
;; 41 succs { 42 43 }
;; 42 succs { 43 }
;; 43 succs { 44 47 }
;; 44 succs { 45 46 }
;; 45 succs { 48 }
;; 46 succs { 48 }
;; 47 succs { 48 }
;; 48 succs { 49 }
;; 49 succs { 51 50 }
;; 50 succs { 51 54 }
;; 51 succs { 53 52 }
;; 52 succs { 53 54 }
;; 53 succs { 76 }
;; 54 succs { 56 55 }
;; 55 succs { 56 66 }
;; 56 succs { 57 58 }
;; 57 succs { 58 }
;; 58 succs { 59 60 }
;; 59 succs { 60 }
;; 60 succs { 61 64 }
;; 61 succs { 62 63 }
;; 62 succs { 65 }
;; 63 succs { 65 }
;; 64 succs { 65 }
;; 65 succs { 66 }
;; 66 succs { 67 68 }
;; 67 succs { 68 }
;; 68 succs { 69 70 }
;; 69 succs { 70 }
;; 70 succs { 71 74 }
;; 71 succs { 72 73 }
;; 72 succs { 75 }
;; 73 succs { 75 }
;; 74 succs { 75 }
;; 75 succs { 79 }
;; 76 succs { 78 77 }
;; 77 succs { 78 79 }
;; 78 succs { 3 79 }
;; 79 succs { 80 81 }
;; 80 succs { 81 }
;; 81 succs { 1 }
void winlinks_RB_REMOVE_COLOR (struct winlinks * head, struct winlink * parent, struct winlink * elm)
{
  struct winlink * oright;
  struct winlink * oleft;
  struct winlink * tmp;

  <bb 2> :
  goto <bb 76>; [INV]

  <bb 3> :
  _1 = parent->entry.rbe_left;
  if (elm == _1)
    goto <bb 4>; [INV]
  else
    goto <bb 40>; [INV]

  <bb 4> :
  tmp = parent->entry.rbe_right;
  _2 = tmp->entry.rbe_color;
  if (_2 == 1)
    goto <bb 5>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 5> :
  tmp->entry.rbe_color = 0;
  parent->entry.rbe_color = 1;
  tmp = parent->entry.rbe_right;
  _3 = tmp->entry.rbe_left;
  parent->entry.rbe_right = _3;
  _4 = parent->entry.rbe_right;
  if (_4 != 0B)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  _5 = tmp->entry.rbe_left;
  _5->entry.rbe_parent = parent;

  <bb 7> :
  _6 = parent->entry.rbe_parent;
  tmp->entry.rbe_parent = _6;
  _7 = tmp->entry.rbe_parent;
  if (_7 != 0B)
    goto <bb 8>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 8> :
  _8 = parent->entry.rbe_parent;
  _9 = _8->entry.rbe_left;
  if (parent == _9)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  _10 = parent->entry.rbe_parent;
  _10->entry.rbe_left = tmp;
  goto <bb 12>; [INV]

  <bb 10> :
  _11 = parent->entry.rbe_parent;
  _11->entry.rbe_right = tmp;
  goto <bb 12>; [INV]

  <bb 11> :
  head->rbh_root = tmp;

  <bb 12> :
  tmp->entry.rbe_left = parent;
  parent->entry.rbe_parent = tmp;
  _12 = tmp->entry.rbe_parent;
  tmp = parent->entry.rbe_right;

  <bb 13> :
  _13 = tmp->entry.rbe_left;
  if (_13 == 0B)
    goto <bb 15>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 14> :
  _14 = tmp->entry.rbe_left;
  _15 = _14->entry.rbe_color;
  if (_15 == 0)
    goto <bb 15>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 15> :
  _16 = tmp->entry.rbe_right;
  if (_16 == 0B)
    goto <bb 17>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 16> :
  _17 = tmp->entry.rbe_right;
  _18 = _17->entry.rbe_color;
  if (_18 == 0)
    goto <bb 17>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 17> :
  tmp->entry.rbe_color = 1;
  elm = parent;
  parent = elm->entry.rbe_parent;
  goto <bb 76>; [INV]

  <bb 18> :
  _19 = tmp->entry.rbe_right;
  if (_19 == 0B)
    goto <bb 20>; [INV]
  else
    goto <bb 19>; [INV]

  <bb 19> :
  _20 = tmp->entry.rbe_right;
  _21 = _20->entry.rbe_color;
  if (_21 == 0)
    goto <bb 20>; [INV]
  else
    goto <bb 30>; [INV]

  <bb 20> :
  oleft = tmp->entry.rbe_left;
  if (oleft != 0B)
    goto <bb 21>; [INV]
  else
    goto <bb 22>; [INV]

  <bb 21> :
  oleft->entry.rbe_color = 0;

  <bb 22> :
  tmp->entry.rbe_color = 1;
  oleft = tmp->entry.rbe_left;
  _22 = oleft->entry.rbe_right;
  tmp->entry.rbe_left = _22;
  _23 = tmp->entry.rbe_left;
  if (_23 != 0B)
    goto <bb 23>; [INV]
  else
    goto <bb 24>; [INV]

  <bb 23> :
  _24 = oleft->entry.rbe_right;
  _24->entry.rbe_parent = tmp;

  <bb 24> :
  _25 = tmp->entry.rbe_parent;
  oleft->entry.rbe_parent = _25;
  _26 = oleft->entry.rbe_parent;
  if (_26 != 0B)
    goto <bb 25>; [INV]
  else
    goto <bb 28>; [INV]

  <bb 25> :
  _27 = tmp->entry.rbe_parent;
  _28 = _27->entry.rbe_left;
  if (tmp == _28)
    goto <bb 26>; [INV]
  else
    goto <bb 27>; [INV]

  <bb 26> :
  _29 = tmp->entry.rbe_parent;
  _29->entry.rbe_left = oleft;
  goto <bb 29>; [INV]

  <bb 27> :
  _30 = tmp->entry.rbe_parent;
  _30->entry.rbe_right = oleft;
  goto <bb 29>; [INV]

  <bb 28> :
  head->rbh_root = oleft;

  <bb 29> :
  oleft->entry.rbe_right = tmp;
  tmp->entry.rbe_parent = oleft;
  _31 = oleft->entry.rbe_parent;
  tmp = parent->entry.rbe_right;

  <bb 30> :
  _32 = parent->entry.rbe_color;
  tmp->entry.rbe_color = _32;
  parent->entry.rbe_color = 0;
  _33 = tmp->entry.rbe_right;
  if (_33 != 0B)
    goto <bb 31>; [INV]
  else
    goto <bb 32>; [INV]

  <bb 31> :
  _34 = tmp->entry.rbe_right;
  _34->entry.rbe_color = 0;

  <bb 32> :
  tmp = parent->entry.rbe_right;
  _35 = tmp->entry.rbe_left;
  parent->entry.rbe_right = _35;
  _36 = parent->entry.rbe_right;
  if (_36 != 0B)
    goto <bb 33>; [INV]
  else
    goto <bb 34>; [INV]

  <bb 33> :
  _37 = tmp->entry.rbe_left;
  _37->entry.rbe_parent = parent;

  <bb 34> :
  _38 = parent->entry.rbe_parent;
  tmp->entry.rbe_parent = _38;
  _39 = tmp->entry.rbe_parent;
  if (_39 != 0B)
    goto <bb 35>; [INV]
  else
    goto <bb 38>; [INV]

  <bb 35> :
  _40 = parent->entry.rbe_parent;
  _41 = _40->entry.rbe_left;
  if (parent == _41)
    goto <bb 36>; [INV]
  else
    goto <bb 37>; [INV]

  <bb 36> :
  _42 = parent->entry.rbe_parent;
  _42->entry.rbe_left = tmp;
  goto <bb 39>; [INV]

  <bb 37> :
  _43 = parent->entry.rbe_parent;
  _43->entry.rbe_right = tmp;
  goto <bb 39>; [INV]

  <bb 38> :
  head->rbh_root = tmp;

  <bb 39> :
  tmp->entry.rbe_left = parent;
  parent->entry.rbe_parent = tmp;
  _44 = tmp->entry.rbe_parent;
  elm = head->rbh_root;
  goto <bb 79>; [INV]

  <bb 40> :
  tmp = parent->entry.rbe_left;
  _45 = tmp->entry.rbe_color;
  if (_45 == 1)
    goto <bb 41>; [INV]
  else
    goto <bb 49>; [INV]

  <bb 41> :
  tmp->entry.rbe_color = 0;
  parent->entry.rbe_color = 1;
  tmp = parent->entry.rbe_left;
  _46 = tmp->entry.rbe_right;
  parent->entry.rbe_left = _46;
  _47 = parent->entry.rbe_left;
  if (_47 != 0B)
    goto <bb 42>; [INV]
  else
    goto <bb 43>; [INV]

  <bb 42> :
  _48 = tmp->entry.rbe_right;
  _48->entry.rbe_parent = parent;

  <bb 43> :
  _49 = parent->entry.rbe_parent;
  tmp->entry.rbe_parent = _49;
  _50 = tmp->entry.rbe_parent;
  if (_50 != 0B)
    goto <bb 44>; [INV]
  else
    goto <bb 47>; [INV]

  <bb 44> :
  _51 = parent->entry.rbe_parent;
  _52 = _51->entry.rbe_left;
  if (parent == _52)
    goto <bb 45>; [INV]
  else
    goto <bb 46>; [INV]

  <bb 45> :
  _53 = parent->entry.rbe_parent;
  _53->entry.rbe_left = tmp;
  goto <bb 48>; [INV]

  <bb 46> :
  _54 = parent->entry.rbe_parent;
  _54->entry.rbe_right = tmp;
  goto <bb 48>; [INV]

  <bb 47> :
  head->rbh_root = tmp;

  <bb 48> :
  tmp->entry.rbe_right = parent;
  parent->entry.rbe_parent = tmp;
  _55 = tmp->entry.rbe_parent;
  tmp = parent->entry.rbe_left;

  <bb 49> :
  _56 = tmp->entry.rbe_left;
  if (_56 == 0B)
    goto <bb 51>; [INV]
  else
    goto <bb 50>; [INV]

  <bb 50> :
  _57 = tmp->entry.rbe_left;
  _58 = _57->entry.rbe_color;
  if (_58 == 0)
    goto <bb 51>; [INV]
  else
    goto <bb 54>; [INV]

  <bb 51> :
  _59 = tmp->entry.rbe_right;
  if (_59 == 0B)
    goto <bb 53>; [INV]
  else
    goto <bb 52>; [INV]

  <bb 52> :
  _60 = tmp->entry.rbe_right;
  _61 = _60->entry.rbe_color;
  if (_61 == 0)
    goto <bb 53>; [INV]
  else
    goto <bb 54>; [INV]

  <bb 53> :
  tmp->entry.rbe_color = 1;
  elm = parent;
  parent = elm->entry.rbe_parent;
  goto <bb 76>; [INV]

  <bb 54> :
  _62 = tmp->entry.rbe_left;
  if (_62 == 0B)
    goto <bb 56>; [INV]
  else
    goto <bb 55>; [INV]

  <bb 55> :
  _63 = tmp->entry.rbe_left;
  _64 = _63->entry.rbe_color;
  if (_64 == 0)
    goto <bb 56>; [INV]
  else
    goto <bb 66>; [INV]

  <bb 56> :
  oright = tmp->entry.rbe_right;
  if (oright != 0B)
    goto <bb 57>; [INV]
  else
    goto <bb 58>; [INV]

  <bb 57> :
  oright->entry.rbe_color = 0;

  <bb 58> :
  tmp->entry.rbe_color = 1;
  oright = tmp->entry.rbe_right;
  _65 = oright->entry.rbe_left;
  tmp->entry.rbe_right = _65;
  _66 = tmp->entry.rbe_right;
  if (_66 != 0B)
    goto <bb 59>; [INV]
  else
    goto <bb 60>; [INV]

  <bb 59> :
  _67 = oright->entry.rbe_left;
  _67->entry.rbe_parent = tmp;

  <bb 60> :
  _68 = tmp->entry.rbe_parent;
  oright->entry.rbe_parent = _68;
  _69 = oright->entry.rbe_parent;
  if (_69 != 0B)
    goto <bb 61>; [INV]
  else
    goto <bb 64>; [INV]

  <bb 61> :
  _70 = tmp->entry.rbe_parent;
  _71 = _70->entry.rbe_left;
  if (tmp == _71)
    goto <bb 62>; [INV]
  else
    goto <bb 63>; [INV]

  <bb 62> :
  _72 = tmp->entry.rbe_parent;
  _72->entry.rbe_left = oright;
  goto <bb 65>; [INV]

  <bb 63> :
  _73 = tmp->entry.rbe_parent;
  _73->entry.rbe_right = oright;
  goto <bb 65>; [INV]

  <bb 64> :
  head->rbh_root = oright;

  <bb 65> :
  oright->entry.rbe_left = tmp;
  tmp->entry.rbe_parent = oright;
  _74 = oright->entry.rbe_parent;
  tmp = parent->entry.rbe_left;

  <bb 66> :
  _75 = parent->entry.rbe_color;
  tmp->entry.rbe_color = _75;
  parent->entry.rbe_color = 0;
  _76 = tmp->entry.rbe_left;
  if (_76 != 0B)
    goto <bb 67>; [INV]
  else
    goto <bb 68>; [INV]

  <bb 67> :
  _77 = tmp->entry.rbe_left;
  _77->entry.rbe_color = 0;

  <bb 68> :
  tmp = parent->entry.rbe_left;
  _78 = tmp->entry.rbe_right;
  parent->entry.rbe_left = _78;
  _79 = parent->entry.rbe_left;
  if (_79 != 0B)
    goto <bb 69>; [INV]
  else
    goto <bb 70>; [INV]

  <bb 69> :
  _80 = tmp->entry.rbe_right;
  _80->entry.rbe_parent = parent;

  <bb 70> :
  _81 = parent->entry.rbe_parent;
  tmp->entry.rbe_parent = _81;
  _82 = tmp->entry.rbe_parent;
  if (_82 != 0B)
    goto <bb 71>; [INV]
  else
    goto <bb 74>; [INV]

  <bb 71> :
  _83 = parent->entry.rbe_parent;
  _84 = _83->entry.rbe_left;
  if (parent == _84)
    goto <bb 72>; [INV]
  else
    goto <bb 73>; [INV]

  <bb 72> :
  _85 = parent->entry.rbe_parent;
  _85->entry.rbe_left = tmp;
  goto <bb 75>; [INV]

  <bb 73> :
  _86 = parent->entry.rbe_parent;
  _86->entry.rbe_right = tmp;
  goto <bb 75>; [INV]

  <bb 74> :
  head->rbh_root = tmp;

  <bb 75> :
  tmp->entry.rbe_right = parent;
  parent->entry.rbe_parent = tmp;
  _87 = tmp->entry.rbe_parent;
  elm = head->rbh_root;
  goto <bb 79>; [INV]

  <bb 76> :
  if (elm == 0B)
    goto <bb 78>; [INV]
  else
    goto <bb 77>; [INV]

  <bb 77> :
  _88 = elm->entry.rbe_color;
  if (_88 == 0)
    goto <bb 78>; [INV]
  else
    goto <bb 79>; [INV]

  <bb 78> :
  _89 = head->rbh_root;
  if (elm != _89)
    goto <bb 3>; [INV]
  else
    goto <bb 79>; [INV]

  <bb 79> :
  if (elm != 0B)
    goto <bb 80>; [INV]
  else
    goto <bb 81>; [INV]

  <bb 80> :
  elm->entry.rbe_color = 0;

  <bb 81> :
  return;

}



;; Function winlinks_RB_INSERT (winlinks_RB_INSERT, funcdef_no=25, decl_uid=4128, cgraph_uid=26, symbol_order=27)

Removing basic block 13
;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
;;
;; Loop 1
;;  header 8, multiple latches: 4 6
;;  depth 1, outer 0
;;  nodes: 8 4 6 5 3
;; 2 succs { 8 }
;; 3 succs { 4 5 }
;; 4 succs { 8 }
;; 5 succs { 6 7 }
;; 6 succs { 8 }
;; 7 succs { 15 }
;; 8 succs { 3 9 }
;; 9 succs { 10 13 }
;; 10 succs { 11 12 }
;; 11 succs { 14 }
;; 12 succs { 14 }
;; 13 succs { 14 }
;; 14 succs { 15 }
;; 15 succs { 1 }
struct winlink * winlinks_RB_INSERT (struct winlinks * head, struct winlink * elm)
{
  int comp;
  struct winlink * parent;
  struct winlink * tmp;
  struct winlink * D.4490;

  <bb 2> :
  parent = 0B;
  comp = 0;
  tmp = head->rbh_root;
  goto <bb 8>; [INV]

  <bb 3> :
  parent = tmp;
  comp = winlink_cmp (elm, parent);
  if (comp < 0)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  tmp = tmp->entry.rbe_left;
  goto <bb 8>; [INV]

  <bb 5> :
  if (comp > 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  tmp = tmp->entry.rbe_right;
  goto <bb 8>; [INV]

  <bb 7> :
  D.4490 = tmp;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 15>; [INV]

  <bb 8> :
  if (tmp != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 9> :
  elm->entry.rbe_parent = parent;
  elm->entry.rbe_right = 0B;
  _1 = elm->entry.rbe_right;
  elm->entry.rbe_left = _1;
  elm->entry.rbe_color = 1;
  if (parent != 0B)
    goto <bb 10>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 10> :
  if (comp < 0)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  parent->entry.rbe_left = elm;
  goto <bb 14>; [INV]

  <bb 12> :
  parent->entry.rbe_right = elm;
  goto <bb 14>; [INV]

  <bb 13> :
  head->rbh_root = elm;

  <bb 14> :
  winlinks_RB_INSERT_COLOR (head, elm);
  D.4490 = 0B;

  <bb 15> :
  return D.4490;

}



;; Function winlinks_RB_REMOVE (winlinks_RB_REMOVE, funcdef_no=26, decl_uid=4142, cgraph_uid=27, symbol_order=28)

Removing basic block 15
Removing basic block 23
Removing basic block 37
Merging blocks 41 and 42
;; 3 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38
;;
;; Loop 2
;;  header 27, latch 27
;;  depth 1, outer 0
;;  nodes: 27
;;
;; Loop 1
;;  header 8, latch 7
;;  depth 1, outer 0
;;  nodes: 8 7
;; 2 succs { 3 4 }
;; 3 succs { 29 }
;; 4 succs { 5 6 }
;; 5 succs { 29 }
;; 6 succs { 8 }
;; 7 succs { 8 }
;; 8 succs { 7 9 }
;; 9 succs { 10 11 }
;; 10 succs { 11 }
;; 11 succs { 12 15 }
;; 12 succs { 13 14 }
;; 13 succs { 16 }
;; 14 succs { 16 }
;; 15 succs { 16 }
;; 16 succs { 17 18 }
;; 17 succs { 18 }
;; 18 succs { 19 22 }
;; 19 succs { 20 21 }
;; 20 succs { 23 }
;; 21 succs { 23 }
;; 22 succs { 23 }
;; 23 succs { 24 25 }
;; 24 succs { 25 }
;; 25 succs { 26 28 }
;; 26 succs { 27 }
;; 27 succs { 27 28 }
;; 28 succs { 36 }
;; 29 succs { 30 31 }
;; 30 succs { 31 }
;; 31 succs { 32 35 }
;; 32 succs { 33 34 }
;; 33 succs { 36 }
;; 34 succs { 36 }
;; 35 succs { 36 }
;; 36 succs { 37 38 }
;; 37 succs { 38 }
;; 38 succs { 1 }
struct winlink * winlinks_RB_REMOVE (struct winlinks * head, struct winlink * elm)
{
  struct winlink * left;
  int color;
  struct winlink * old;
  struct winlink * parent;
  struct winlink * child;
  struct winlink * D.4534;

  <bb 2> :
  old = elm;
  _1 = elm->entry.rbe_left;
  if (_1 == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  child = elm->entry.rbe_right;
  goto <bb 29>; [INV]

  <bb 4> :
  _2 = elm->entry.rbe_right;
  if (_2 == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  child = elm->entry.rbe_left;
  goto <bb 29>; [INV]

  <bb 6> :
  elm = elm->entry.rbe_right;
  goto <bb 8>; [INV]

  <bb 7> :
  elm = left;

  <bb 8> :
  left = elm->entry.rbe_left;
  if (left != 0B)
    goto <bb 7>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 9> :
  child = elm->entry.rbe_right;
  parent = elm->entry.rbe_parent;
  color = elm->entry.rbe_color;
  if (child != 0B)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  child->entry.rbe_parent = parent;

  <bb 11> :
  if (parent != 0B)
    goto <bb 12>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 12> :
  _3 = parent->entry.rbe_left;
  if (elm == _3)
    goto <bb 13>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 13> :
  parent->entry.rbe_left = child;
  goto <bb 16>; [INV]

  <bb 14> :
  parent->entry.rbe_right = child;
  goto <bb 16>; [INV]

  <bb 15> :
  head->rbh_root = child;

  <bb 16> :
  _4 = elm->entry.rbe_parent;
  if (old == _4)
    goto <bb 17>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 17> :
  parent = elm;

  <bb 18> :
  elm->entry = old->entry;
  _5 = old->entry.rbe_parent;
  if (_5 != 0B)
    goto <bb 19>; [INV]
  else
    goto <bb 22>; [INV]

  <bb 19> :
  _6 = old->entry.rbe_parent;
  _7 = _6->entry.rbe_left;
  if (old == _7)
    goto <bb 20>; [INV]
  else
    goto <bb 21>; [INV]

  <bb 20> :
  _8 = old->entry.rbe_parent;
  _8->entry.rbe_left = elm;
  goto <bb 23>; [INV]

  <bb 21> :
  _9 = old->entry.rbe_parent;
  _9->entry.rbe_right = elm;
  goto <bb 23>; [INV]

  <bb 22> :
  head->rbh_root = elm;

  <bb 23> :
  _10 = old->entry.rbe_left;
  _10->entry.rbe_parent = elm;
  _11 = old->entry.rbe_right;
  if (_11 != 0B)
    goto <bb 24>; [INV]
  else
    goto <bb 25>; [INV]

  <bb 24> :
  _12 = old->entry.rbe_right;
  _12->entry.rbe_parent = elm;

  <bb 25> :
  if (parent != 0B)
    goto <bb 26>; [INV]
  else
    goto <bb 28>; [INV]

  <bb 26> :
  left = parent;

  <bb 27> :
  left = left->entry.rbe_parent;
  if (left != 0B)
    goto <bb 27>; [INV]
  else
    goto <bb 28>; [INV]

  <bb 28> :
  // predicted unlikely by goto predictor.
  goto <bb 36>; [INV]

  <bb 29> :
  parent = elm->entry.rbe_parent;
  color = elm->entry.rbe_color;
  if (child != 0B)
    goto <bb 30>; [INV]
  else
    goto <bb 31>; [INV]

  <bb 30> :
  child->entry.rbe_parent = parent;

  <bb 31> :
  if (parent != 0B)
    goto <bb 32>; [INV]
  else
    goto <bb 35>; [INV]

  <bb 32> :
  _13 = parent->entry.rbe_left;
  if (elm == _13)
    goto <bb 33>; [INV]
  else
    goto <bb 34>; [INV]

  <bb 33> :
  parent->entry.rbe_left = child;
  goto <bb 36>; [INV]

  <bb 34> :
  parent->entry.rbe_right = child;
  goto <bb 36>; [INV]

  <bb 35> :
  head->rbh_root = child;

  <bb 36> :
color:
  if (color == 0)
    goto <bb 37>; [INV]
  else
    goto <bb 38>; [INV]

  <bb 37> :
  winlinks_RB_REMOVE_COLOR (head, parent, child);

  <bb 38> :
  D.4534 = old;
  return D.4534;

}



;; Function winlinks_RB_FIND (winlinks_RB_FIND, funcdef_no=27, decl_uid=4166, cgraph_uid=28, symbol_order=29)

;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10
;;
;; Loop 1
;;  header 8, multiple latches: 4 6
;;  depth 1, outer 0
;;  nodes: 8 4 6 5 3
;; 2 succs { 8 }
;; 3 succs { 4 5 }
;; 4 succs { 8 }
;; 5 succs { 6 7 }
;; 6 succs { 8 }
;; 7 succs { 10 }
;; 8 succs { 3 9 }
;; 9 succs { 10 }
;; 10 succs { 1 }
struct winlink * winlinks_RB_FIND (struct winlinks * head, struct winlink * elm)
{
  int comp;
  struct winlink * tmp;
  struct winlink * D.4542;

  <bb 2> :
  tmp = head->rbh_root;
  goto <bb 8>; [INV]

  <bb 3> :
  comp = winlink_cmp (elm, tmp);
  if (comp < 0)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  tmp = tmp->entry.rbe_left;
  goto <bb 8>; [INV]

  <bb 5> :
  if (comp > 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  tmp = tmp->entry.rbe_right;
  goto <bb 8>; [INV]

  <bb 7> :
  D.4542 = tmp;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 10>; [INV]

  <bb 8> :
  if (tmp != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 9> :
  D.4542 = 0B;

  <bb 10> :
  return D.4542;

}



;; Function winlinks_RB_NFIND (winlinks_RB_NFIND, funcdef_no=28, decl_uid=4175, cgraph_uid=29, symbol_order=30)

;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10
;;
;; Loop 1
;;  header 8, multiple latches: 4 6
;;  depth 1, outer 0
;;  nodes: 8 4 6 5 3
;; 2 succs { 8 }
;; 3 succs { 4 5 }
;; 4 succs { 8 }
;; 5 succs { 6 7 }
;; 6 succs { 8 }
;; 7 succs { 10 }
;; 8 succs { 3 9 }
;; 9 succs { 10 }
;; 10 succs { 1 }
struct winlink * winlinks_RB_NFIND (struct winlinks * head, struct winlink * elm)
{
  int comp;
  struct winlink * res;
  struct winlink * tmp;
  struct winlink * D.4550;

  <bb 2> :
  tmp = head->rbh_root;
  res = 0B;
  goto <bb 8>; [INV]

  <bb 3> :
  comp = winlink_cmp (elm, tmp);
  if (comp < 0)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  res = tmp;
  tmp = tmp->entry.rbe_left;
  goto <bb 8>; [INV]

  <bb 5> :
  if (comp > 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  tmp = tmp->entry.rbe_right;
  goto <bb 8>; [INV]

  <bb 7> :
  D.4550 = tmp;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 10>; [INV]

  <bb 8> :
  if (tmp != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 9> :
  D.4550 = res;

  <bb 10> :
  return D.4550;

}



;; Function winlinks_RB_NEXT (winlinks_RB_NEXT, funcdef_no=29, decl_uid=4184, cgraph_uid=30, symbol_order=31)

Removing basic block 6
Removing basic block 10
Merging blocks 15 and 16
;; 3 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13
;;
;; Loop 2
;;  header 5, latch 4
;;  depth 1, outer 0
;;  nodes: 5 4
;;
;; Loop 1
;;  header 10, latch 9
;;  depth 1, outer 0
;;  nodes: 10 9 11
;; 2 succs { 3 6 }
;; 3 succs { 5 }
;; 4 succs { 5 }
;; 5 succs { 4 13 }
;; 6 succs { 7 10 }
;; 7 succs { 8 10 }
;; 8 succs { 13 }
;; 9 succs { 10 }
;; 10 succs { 11 12 }
;; 11 succs { 9 12 }
;; 12 succs { 13 }
;; 13 succs { 1 }
struct winlink * winlinks_RB_NEXT (struct winlink * elm)
{
  struct winlink * D.4560;

  <bb 2> :
  _1 = elm->entry.rbe_right;
  if (_1 != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 3> :
  elm = elm->entry.rbe_right;
  goto <bb 5>; [INV]

  <bb 4> :
  elm = elm->entry.rbe_left;

  <bb 5> :
  _2 = elm->entry.rbe_left;
  if (_2 != 0B)
    goto <bb 4>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 6> :
  _3 = elm->entry.rbe_parent;
  if (_3 != 0B)
    goto <bb 7>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 7> :
  _4 = elm->entry.rbe_parent;
  _5 = _4->entry.rbe_left;
  if (elm == _5)
    goto <bb 8>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 8> :
  elm = elm->entry.rbe_parent;
  goto <bb 13>; [INV]

  <bb 9> :
  elm = elm->entry.rbe_parent;

  <bb 10> :
  _6 = elm->entry.rbe_parent;
  if (_6 != 0B)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  _7 = elm->entry.rbe_parent;
  _8 = _7->entry.rbe_right;
  if (elm == _8)
    goto <bb 9>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 12> :
  elm = elm->entry.rbe_parent;

  <bb 13> :
  D.4560 = elm;
  return D.4560;

}



;; Function winlinks_RB_PREV (winlinks_RB_PREV, funcdef_no=30, decl_uid=4193, cgraph_uid=31, symbol_order=32)

Removing basic block 6
Removing basic block 10
Merging blocks 15 and 16
;; 3 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13
;;
;; Loop 2
;;  header 5, latch 4
;;  depth 1, outer 0
;;  nodes: 5 4
;;
;; Loop 1
;;  header 10, latch 9
;;  depth 1, outer 0
;;  nodes: 10 9 11
;; 2 succs { 3 6 }
;; 3 succs { 5 }
;; 4 succs { 5 }
;; 5 succs { 4 13 }
;; 6 succs { 7 10 }
;; 7 succs { 8 10 }
;; 8 succs { 13 }
;; 9 succs { 10 }
;; 10 succs { 11 12 }
;; 11 succs { 9 12 }
;; 12 succs { 13 }
;; 13 succs { 1 }
struct winlink * winlinks_RB_PREV (struct winlink * elm)
{
  struct winlink * D.4570;

  <bb 2> :
  _1 = elm->entry.rbe_left;
  if (_1 != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 3> :
  elm = elm->entry.rbe_left;
  goto <bb 5>; [INV]

  <bb 4> :
  elm = elm->entry.rbe_right;

  <bb 5> :
  _2 = elm->entry.rbe_right;
  if (_2 != 0B)
    goto <bb 4>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 6> :
  _3 = elm->entry.rbe_parent;
  if (_3 != 0B)
    goto <bb 7>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 7> :
  _4 = elm->entry.rbe_parent;
  _5 = _4->entry.rbe_right;
  if (elm == _5)
    goto <bb 8>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 8> :
  elm = elm->entry.rbe_parent;
  goto <bb 13>; [INV]

  <bb 9> :
  elm = elm->entry.rbe_parent;

  <bb 10> :
  _6 = elm->entry.rbe_parent;
  if (_6 != 0B)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  _7 = elm->entry.rbe_parent;
  _8 = _7->entry.rbe_left;
  if (elm == _8)
    goto <bb 9>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 12> :
  elm = elm->entry.rbe_parent;

  <bb 13> :
  D.4570 = elm;
  return D.4570;

}



;; Function winlinks_RB_MINMAX (winlinks_RB_MINMAX, funcdef_no=31, decl_uid=4203, cgraph_uid=32, symbol_order=33)

Merging blocks 7 and 8
;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7
;;
;; Loop 1
;;  header 6, multiple latches: 4 5
;;  depth 1, outer 0
;;  nodes: 6 4 5 3
;; 2 succs { 6 }
;; 3 succs { 4 5 }
;; 4 succs { 6 }
;; 5 succs { 6 }
;; 6 succs { 3 7 }
;; 7 succs { 1 }
struct winlink * winlinks_RB_MINMAX (struct winlinks * head, int val)
{
  struct winlink * parent;
  struct winlink * tmp;
  struct winlink * D.4575;

  <bb 2> :
  tmp = head->rbh_root;
  parent = 0B;
  goto <bb 6>; [INV]

  <bb 3> :
  parent = tmp;
  if (val < 0)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  tmp = tmp->entry.rbe_left;
  goto <bb 6>; [INV]

  <bb 5> :
  tmp = tmp->entry.rbe_right;

  <bb 6> :
  if (tmp != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  D.4575 = parent;
  return D.4575;

}



;; Function window_scroll_init (window_scroll_init, funcdef_no=32, decl_uid=3985, cgraph_uid=33, symbol_order=34)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
void window_scroll_init (struct window * w)
{
  struct window_scroll_mode_data * data;

  <bb 2> :
  data = malloc (8);
  w->modedata = data;
  data->off = 0;
  _1 = w->screen.hsize;
  data->size = _1;
  return;

}



;; Function window_scroll_key (window_scroll_key, funcdef_no=33, decl_uid=3997, cgraph_uid=34, symbol_order=35)

Removing basic block 6
Removing basic block 9
Removing basic block 13
Removing basic block 17
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16
;; 2 succs { 14 11 8 6 4 3 }
;; 3 succs { 14 }
;; 4 succs { 5 14 }
;; 5 succs { 14 }
;; 6 succs { 7 14 }
;; 7 succs { 14 }
;; 8 succs { 9 10 }
;; 9 succs { 14 }
;; 10 succs { 14 }
;; 11 succs { 12 13 }
;; 12 succs { 14 }
;; 13 succs { 14 }
;; 14 succs { 15 16 }
;; 15 succs { 16 }
;; 16 succs { 1 }
void window_scroll_key (struct window * w, int key)
{
  u_int sy;
  u_int off;
  struct window_scroll_mode_data * data;

  <bb 2> :
  data = w->modedata;
  _1 = w->screen.grid;
  sy = _1->sy;
  off = data->off;
  switch (key) <default: <L22> [INV], case 6: <L17> [INV], case 21: <L12> [INV], case 74: <L7> [INV], case 75: <L2> [INV], case 81: <L0> [INV], case 106: <L7> [INV], case 107: <L2> [INV], case 113: <L0> [INV], case 268435542: <L17> [INV], case 268435543: <L12> [INV], case 268435545: <L2> [INV], case 268435546: <L7> [INV]>

  <bb 3> :
<L0>:
  w->mode = 0B;
  _2 = w->modedata;
  free (_2);
  goto <bb 14>; [INV]

  <bb 4> :
<L2>:
  _3 = data->off;
  _4 = data->size;
  if (_3 < _4)
    goto <bb 5>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 5> :
  _5 = data->off;
  _6 = _5 + 1;
  data->off = _6;
  goto <bb 14>; [INV]

  <bb 6> :
<L7>:
  _7 = data->off;
  if (_7 != 0)
    goto <bb 7>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 7> :
  _8 = data->off;
  _9 = _8 + 4294967295;
  data->off = _9;
  goto <bb 14>; [INV]

  <bb 8> :
<L12>:
  _10 = data->off;
  _11 = sy + _10;
  _12 = data->size;
  if (_11 > _12)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  _13 = data->size;
  data->off = _13;
  goto <bb 14>; [INV]

  <bb 10> :
  _14 = data->off;
  _15 = sy + _14;
  data->off = _15;
  goto <bb 14>; [INV]

  <bb 11> :
<L17>:
  _16 = data->off;
  if (sy > _16)
    goto <bb 12>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 12> :
  data->off = 0;
  goto <bb 14>; [INV]

  <bb 13> :
  _17 = data->off;
  _18 = _17 - sy;
  data->off = _18;

  <bb 14> :
<L22>:
  _19 = data->off;
  if (off != _19)
    goto <bb 15>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 15> :
  // predicted unlikely by early return (on trees) predictor.

  <bb 16> :
  return;

}



;; Function input_store8 (input_store8, funcdef_no=34, decl_uid=4236, cgraph_uid=35, symbol_order=36)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
void input_store8 (struct buffer * b, uint8_t n)
{
  <bb 2> :
  _1 = b->base;
  _2 = b->off;
  _3 = b->size;
  _4 = _2 + _3;
  _5 = _1 + _4;
  _6 = (unsigned char) n;
  *_5 = _6;
  _7 = b->size;
  _8 = _7 + 1;
  b->size = _8;
  return;

}



;; Function input_key (input_key, funcdef_no=35, decl_uid=4240, cgraph_uid=36, symbol_order=37)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4
;; 2 succs { 3 4 }
;; 3 succs { 4 }
;; 4 succs { 1 }
void input_key (struct buffer * b, int key)
{
  u_int i;

  <bb 2> :
  if (key >= 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  key.0_1 = (unsigned int) key;
  input_store8 (b, key.0_1);
  // predicted unlikely by early return (on trees) predictor.

  <bb 4> :
  return;

}



;; Function window_key (window_key, funcdef_no=36, decl_uid=4245, cgraph_uid=37, symbol_order=38)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5
;; 2 succs { 3 4 }
;; 3 succs { 5 }
;; 4 succs { 5 }
;; 5 succs { 1 }
void window_key (struct window * w, int key)
{
  <bb 2> :
  _1 = w->mode;
  if (_1 != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  _2 = w->mode;
  _3 = _2->key;
  _3 (w, key);
  goto <bb 5>; [INV]

  <bb 4> :
  _4 = w->out;
  input_key (_4, key);

  <bb 5> :
  return;

}



;; Function window_create (window_create, funcdef_no=37, decl_uid=4252, cgraph_uid=38, symbol_order=39)

Merging blocks 4 and 5
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4
;; 2 succs { 3 4 }
;; 3 succs { 4 }
;; 4 succs { 1 }
struct window * window_create (const char * name, const char * cmd, const char * * env, u_int sx, u_int sy)
{
  struct window * w;
  struct window * D.4599;

  <bb 2> :
  w = malloc (200);
  w->mode = 0B;
  _1 = rand ();
  _2 = _1 % 2;
  if (_2 == 1)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  w->mode = &window_scroll_mode;
  _3 = w->mode;
  _4 = _3->init;
  _4 (w);

  <bb 4> :
  D.4599 = w;
  return D.4599;

}



;; Function window_destroy (window_destroy, funcdef_no=38, decl_uid=4256, cgraph_uid=39, symbol_order=40)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
void window_destroy (struct window * w)
{
  <bb 2> :
  free (w);
  return;

}



;; Function winlink_add (winlink_add, funcdef_no=39, decl_uid=4261, cgraph_uid=40, symbol_order=41)

Merging blocks 2 and 3
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
struct winlink * winlink_add (struct winlinks * wwl, struct window * w, int idx)
{
  struct winlink * wl;
  struct winlink * D.4601;

  <bb 2> :
  wl = calloc (1, 136);
  wl->idx = idx;
  wl->window = w;
  winlinks_RB_INSERT (wwl, wl);
  _1 = w->references;
  _2 = _1 + 1;
  w->references = _2;
  D.4601 = wl;
  return D.4601;

}



;; Function winlink_remove (winlink_remove, funcdef_no=40, decl_uid=4266, cgraph_uid=41, symbol_order=42)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6
;; 2 succs { 3 4 }
;; 3 succs { }
;; 4 succs { 5 6 }
;; 5 succs { 6 }
;; 6 succs { 1 }
void winlink_remove (struct winlinks * wwl, struct winlink * wl)
{
  struct window * w;

  <bb 2> :
  w = wl->window;
  winlinks_RB_REMOVE (wwl, wl);
  free (wl);
  _1 = w->references;
  if (_1 == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  printf ("bad reference count%s\n", "");
  exit (1);

  <bb 4> :
  _2 = w->references;
  _3 = _2 + 4294967295;
  w->references = _3;
  _4 = w->references;
  if (_4 == 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  window_destroy (w);

  <bb 6> :
  return;

}



;; Function session_destroy (session_destroy, funcdef_no=41, decl_uid=4270, cgraph_uid=42, symbol_order=43)

;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5
;;
;; Loop 1
;;  header 4, latch 3
;;  depth 1, outer 0
;;  nodes: 4 3
;; 2 succs { 4 }
;; 3 succs { 4 }
;; 4 succs { 3 5 }
;; 5 succs { 1 }
void session_destroy (struct session * s)
{
  u_int i;

  <bb 2> :
  _1 = s->name;
  printf ("session %s destroyed\n", _1);
  goto <bb 4>; [INV]

  <bb 3> :
  _2 = s->windows.rbh_root;
  _3 = &s->windows;
  winlink_remove (_3, _2);

  <bb 4> :
  _4 = s->windows.rbh_root;
  if (_4 != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 5> :
  _5 = s->name;
  free (_5);
  free (s);
  return;

}



;; Function session_attach (session_attach, funcdef_no=42, decl_uid=4280, cgraph_uid=43, symbol_order=44)

Merging blocks 4 and 5
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4
;; 2 succs { 3 4 }
;; 3 succs { 4 }
;; 4 succs { 1 }
struct winlink * session_attach (struct session * s, struct window * w, int idx, char * * cause)
{
  struct winlink * wl;
  struct winlink * D.4609;

  <bb 2> :
  _1 = &s->windows;
  wl = winlink_add (_1, w, idx);
  if (wl == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  printf ("index in use: %d\n", idx);

  <bb 4> :
  D.4609 = wl;
  return D.4609;

}



;; Function session_new (session_new, funcdef_no=43, decl_uid=4289, cgraph_uid=44, symbol_order=45)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5
;; 2 succs { 3 4 }
;; 3 succs { 5 }
;; 4 succs { 5 }
;; 5 succs { 1 }
struct winlink * session_new (struct session * s, const char * name, const char * cmd, const char * cwd, int idx, char * * cause)
{
  u_int hlimit;
  const char * shell;
  struct window * w;
  struct winlink * D.4613;

  <bb 2> :
  _1 = s->sy;
  _2 = s->sx;
  w = window_create (name, cmd, 0B, _2, _1);
  if (w == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  D.4613 = 0B;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 5>; [INV]

  <bb 4> :
  D.4613 = session_attach (s, w, idx, cause);

  <bb 5> :
  return D.4613;

}



;; Function session_create (session_create, funcdef_no=44, decl_uid=4303, cgraph_uid=45, symbol_order=46)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9
;; 2 succs { 3 4 }
;; 3 succs { }
;; 4 succs { 5 8 }
;; 5 succs { 6 7 }
;; 6 succs { 9 }
;; 7 succs { 8 }
;; 8 succs { 9 }
;; 9 succs { 1 }
struct session * session_create (const char * name, const char * cmd, const char * cwd, struct environ * env, struct termios * tio, int idx, u_int sx, u_int sy, char * * cause)
{
  u_int i;
  struct winlink * wl;
  struct session * s;
  struct session * D.4621;

  <bb 2> :
  s = malloc (32);
  s->curw = 0B;
  s->windows.rbh_root = 0B;
  s->sx = sx;
  s->sy = sy;
  if (name == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  printf ("no name%s\n", "");
  exit (1);

  <bb 4> :
  _1 = strdup (name);
  s->name = _1;
  if (cmd != 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 5> :
  wl = session_new (s, 0B, cmd, cwd, idx, cause);
  if (wl == 0B)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  session_destroy (s);
  D.4621 = 0B;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 9>; [INV]

  <bb 7> :
  s->curw = wl;

  <bb 8> :
  D.4621 = s;

  <bb 9> :
  return D.4621;

}



;; Function main (main, funcdef_no=45, decl_uid=4313, cgraph_uid=46, symbol_order=47)

Removing basic block 12
Merging blocks 11 and 13
;; 3 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11
;;
;; Loop 1
;;  header 5, latch 9
;;  depth 1, outer 0
;;  nodes: 5 9 8 6 7
;;
;; Loop 2
;;  header 8, latch 7
;;  depth 2, outer 1
;;  nodes: 8 7
;; 2 succs { 3 4 }
;; 3 succs { 11 }
;; 4 succs { 5 }
;; 5 succs { 10 6 }
;; 6 succs { 8 }
;; 7 succs { 8 }
;; 8 succs { 7 9 }
;; 9 succs { 5 }
;; 10 succs { 11 }
;; 11 succs { 1 }
int main (int argc, char * * argv)
{
  char env;
  char * cause;
  uint8_t sy;
  uint8_t sx;
  int key;
  struct window * w;
  struct session * s;
  int D.4625;

  <bb 2> :
  if (argc == 1)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  D.4625 = 1;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 11>; [INV]

  <bb 4> :
  _1 = *argv;
  s = session_create ("name", _1, "cwd", 0B, 0B, 0, sx, sy, &cause);
  _2 = argv + 8;
  _3 = *_2;
  w = window_create (_3, "cwd", &env, sx, sy);
  _4 = session_attach (s, w, 0, &cause);
  s->curw = _4;

  <bb 5> :
  _5 = s->curw;
  if (_5 == 0B)
    goto <bb 10>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 6> :
  _6 = s->curw;
  w = _6->window;
  goto <bb 8>; [INV]

  <bb 7> :
  key.1_7 = key;
  window_key (w, key.1_7);

  <bb 8> :
  _8 = scanf ("%d", &key);
  if (_8 != -1)
    goto <bb 7>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 9> :
  _9 = s->curw;
  _10 = &s->windows;
  winlink_remove (_10, _9);
  goto <bb 5>; [INV]

  <bb 10> :
  session_destroy (s);
  D.4625 = 0;

  <bb 11> :
  key = {CLOBBER};
  cause = {CLOBBER};
  env = {CLOBBER};
  return D.4625;

}


