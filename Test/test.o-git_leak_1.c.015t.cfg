
;; Function xrealloc (xrealloc, funcdef_no=26, decl_uid=3195, cgraph_uid=27, symbol_order=27)

Merging blocks 9 and 10
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9
;; 2 succs { 3 4 }
;; 3 succs { 4 }
;; 4 succs { 5 9 }
;; 5 succs { 6 7 }
;; 6 succs { 7 }
;; 7 succs { 8 9 }
;; 8 succs { }
;; 9 succs { 1 }
void * xrealloc (void * ptr, size_t size)
{
  void * ret;
  void * D.3379;

  <bb 2> :
  ret = realloc (ptr, size);
  _1 = ret == 0B;
  _2 = size == 0;
  _3 = _1 & _2;
  if (_3 != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  ret = realloc (ptr, 1);

  <bb 4> :
  if (ret == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 5> :
  ret = realloc (ptr, size);
  _4 = ret == 0B;
  _5 = size == 0;
  _6 = _4 & _5;
  if (_6 != 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  ret = realloc (ptr, 1);

  <bb 7> :
  if (ret == 0B)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  printf ("Out of memory, realloc failed%s", "");
  exit (1);

  <bb 9> :
  D.3379 = ret;
  return D.3379;

}



;; Function string_list_init (string_list_init, funcdef_no=27, decl_uid=3255, cgraph_uid=28, symbol_order=61)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
void string_list_init (struct string_list * list, int strdup_strings)
{
  <bb 2> :
  memset (list, 0, 32);
  _1 = (<unnamed-unsigned:1>) strdup_strings;
  list->strdup_strings = _1;
  return;

}



;; Function string_list_insert (string_list_insert, funcdef_no=29, decl_uid=3275, cgraph_uid=30, symbol_order=63)

Merging blocks 4 and 5
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4
;; 2 succs { 3 4 }
;; 3 succs { 4 }
;; 4 succs { 1 }
struct string_list_item * string_list_insert (struct string_list * list, const char * string)
{
  int index;
  struct string_list_item * D.3383;

  <bb 2> :
  index = add_entry (-1, list, string);
  if (index < 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  index = ~index;

  <bb 4> :
  _1 = list->items;
  _2 = (long unsigned int) index;
  _3 = _2 * 16;
  D.3383 = _1 + _3;
  return D.3383;

}



;; Function add_entry (add_entry, funcdef_no=28, decl_uid=3261, cgraph_uid=29, symbol_order=62)

Merging blocks 18 and 19
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18
;; 2 succs { 3 4 }
;; 3 succs { 5 }
;; 4 succs { 5 }
;; 5 succs { 6 7 }
;; 6 succs { 18 }
;; 7 succs { 8 12 }
;; 8 succs { 9 10 }
;; 9 succs { 11 }
;; 10 succs { 11 }
;; 11 succs { 12 }
;; 12 succs { 13 14 }
;; 13 succs { 14 }
;; 14 succs { 15 16 }
;; 15 succs { 17 }
;; 16 succs { 17 }
;; 17 succs { 18 }
;; 18 succs { 1 }
int add_entry (int insert_at, struct string_list * list, const char * string)
{
  int index;
  int exact_match;
  char * iftmp.4;
  int D.3391;
  int iftmp.0;

  <bb 2> :
  exact_match = 0;
  if (insert_at == -1)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  iftmp.0 = get_entry_index (list, string, &exact_match);
  goto <bb 5>; [INV]

  <bb 4> :
  iftmp.0 = insert_at;

  <bb 5> :
  index = iftmp.0;
  exact_match.1_1 = exact_match;
  if (exact_match.1_1 != 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  D.3391 = ~index;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 18>; [INV]

  <bb 7> :
  _2 = list->nr;
  _3 = _2 + 1;
  _4 = list->alloc;
  if (_3 > _4)
    goto <bb 8>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 8> :
  _5 = list->alloc;
  _6 = alloc_nr (_5);
  _7 = (unsigned int) _6;
  _8 = list->nr;
  _9 = _8 + 1;
  if (_7 < _9)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  _10 = list->nr;
  _11 = _10 + 1;
  list->alloc = _11;
  goto <bb 11>; [INV]

  <bb 10> :
  _12 = list->alloc;
  _13 = alloc_nr (_12);
  _14 = (unsigned int) _13;
  list->alloc = _14;

  <bb 11> :
  _15 = list->alloc;
  _16 = st_mult (16, _15);
  _17 = (long unsigned int) _16;
  _18 = list->items;
  _19 = xrealloc (_18, _17);
  list->items = _19;

  <bb 12> :
  _20 = list->nr;
  index.2_21 = (unsigned int) index;
  if (_20 > index.2_21)
    goto <bb 13>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 13> :
  _22 = list->nr;
  index.3_23 = (unsigned int) index;
  _24 = _22 - index.3_23;
  _25 = (long unsigned int) _24;
  _26 = list->items;
  _27 = (long unsigned int) index;
  _28 = _27 * 16;
  _29 = _26 + _28;
  _30 = list->items;
  _31 = (sizetype) index;
  _32 = _31 + 1;
  _33 = _32 * 16;
  _34 = _30 + _33;
  move_array (_34, _29, _25, 16);

  <bb 14> :
  _35 = BIT_FIELD_REF <*list, 8, 128>;
  _36 = _35 & 1;
  if (_36 != 0)
    goto <bb 15>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 15> :
  iftmp.4 = strdup (string);
  goto <bb 17>; [INV]

  <bb 16> :
  iftmp.4 = string;

  <bb 17> :
  _37 = list->items;
  _38 = (long unsigned int) index;
  _39 = _38 * 16;
  _40 = _37 + _39;
  _40->string = iftmp.4;
  _41 = list->items;
  _42 = (long unsigned int) index;
  _43 = _42 * 16;
  _44 = _41 + _43;
  _44->util = 0B;
  _45 = list->nr;
  _46 = _45 + 1;
  list->nr = _46;
  D.3391 = index;

  <bb 18> :
  exact_match = {CLOBBER};
  return D.3391;

}



;; Function move_array (move_array, funcdef_no=23, decl_uid=2979, cgraph_uid=24, symbol_order=24)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4
;; 2 succs { 3 4 }
;; 3 succs { 4 }
;; 4 succs { 1 }
void move_array (void * dst, const void * src, size_t n, size_t size)
{
  <bb 2> :
  if (n != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  _1 = st_mult (size, n);
  _2 = (long unsigned int) _1;
  memmove (dst, src, _2);

  <bb 4> :
  return;

}



;; Function parse_pathspec (parse_pathspec, funcdef_no=30, decl_uid=3283, cgraph_uid=31, symbol_order=64)

;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31
;;
;; Loop 1
;;  header 25, latch 24
;;  depth 1, outer 0
;;  nodes: 25 24 22 23 19 20 17 18
;; 2 succs { 3 4 }
;; 3 succs { 5 }
;; 4 succs { 5 }
;; 5 succs { 6 7 }
;; 6 succs { 7 }
;; 7 succs { 8 9 }
;; 8 succs { 31 }
;; 9 succs { 10 13 }
;; 10 succs { 11 12 }
;; 11 succs { 31 }
;; 12 succs { 31 }
;; 13 succs { 14 15 }
;; 14 succs { 16 }
;; 15 succs { 16 }
;; 16 succs { 25 }
;; 17 succs { 18 19 }
;; 18 succs { 19 }
;; 19 succs { 20 22 }
;; 20 succs { 21 22 }
;; 21 succs { }
;; 22 succs { 23 24 }
;; 23 succs { 24 }
;; 24 succs { 25 }
;; 25 succs { 17 26 }
;; 26 succs { 27 31 }
;; 27 succs { 28 29 }
;; 28 succs { 30 }
;; 29 succs { 30 }
;; 30 succs { 31 }
;; 31 succs { 1 }
void parse_pathspec (struct pathspec * pathspec, unsigned int magic_mask, unsigned int flags, const char * prefix, const char * * argv)
{
  int plen;
  int nr_exclude;
  int warn_empty_string;
  int prefixlen;
  int n;
  int i;
  const char * entry;
  struct pathspec_item * item;
  int iftmp.7;
  int iftmp.6;
  const char * iftmp.5;

  <bb 2> :
  if (argv != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  iftmp.5 = *argv;
  goto <bb 5>; [INV]

  <bb 4> :
  iftmp.5 = 0B;

  <bb 5> :
  entry = iftmp.5;
  nr_exclude = 0;
  memset (pathspec, 0, 24);
  _1 = flags & 4;
  if (_1 != 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  _2 = pathspec->magic;
  _3 = _2 | 2;
  pathspec->magic = _3;

  <bb 7> :
  _4 = entry == 0B;
  _5 = prefix == 0B;
  _6 = _4 & _5;
  if (_6 != 0)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 31>; [INV]

  <bb 9> :
  if (entry == 0B)
    goto <bb 10>; [INV]
  else
    goto <bb 13>; [INV]

  <bb 10> :
  _7 = flags & 2;
  if (_7 != 0)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 31>; [INV]

  <bb 12> :
  item = calloc (1, 56);
  pathspec->items = item;
  _8 = strdup (prefix);
  item->match = _8;
  _9 = strdup (prefix);
  item->original = _9;
  _10 = strlen (prefix);
  _11 = (int) _10;
  item->len = _11;
  _12 = item->len;
  item->nowildcard_len = _12;
  _13 = item->len;
  item->prefix = _13;
  pathspec->nr = 1;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 31>; [INV]

  <bb 13> :
  n = 0;
  warn_empty_string = 1;
  pathspec->nr = n;
  _14 = n + 1;
  _15 = st_mult (56, _14);
  _16 = (long unsigned int) _15;
  _17 = malloc (_16);
  pathspec->items = _17;
  item = pathspec->items;
  if (prefix != 0B)
    goto <bb 14>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 14> :
  _18 = strlen (prefix);
  iftmp.6 = (int) _18;
  goto <bb 16>; [INV]

  <bb 15> :
  iftmp.6 = 0;

  <bb 16> :
  prefixlen = iftmp.6;
  i = 0;
  goto <bb 25>; [INV]

  <bb 17> :
  _19 = (long unsigned int) i;
  _20 = _19 * 8;
  _21 = argv + _20;
  entry = *_21;
  _22 = (long unsigned int) i;
  _23 = _22 * 56;
  _24 = item + _23;
  _25 = malloc (10);
  _24->match = _25;
  _26 = (long unsigned int) i;
  _27 = _26 * 56;
  _28 = item + _27;
  _29 = malloc (100);
  _28->original = _29;
  _30 = (long unsigned int) i;
  _31 = _30 * 56;
  _32 = item + _31;
  _33 = _32->magic;
  _34 = _33 & 32;
  if (_34 != 0)
    goto <bb 18>; [INV]
  else
    goto <bb 19>; [INV]

  <bb 18> :
  nr_exclude = nr_exclude + 1;

  <bb 19> :
  _35 = flags & 8;
  if (_35 != 0)
    goto <bb 20>; [INV]
  else
    goto <bb 22>; [INV]

  <bb 20> :
  _36 = (long unsigned int) i;
  _37 = _36 * 56;
  _38 = item + _37;
  _39 = _38->len;
  _40 = (long unsigned int) i;
  _41 = _40 * 56;
  _42 = item + _41;
  _43 = _42->match;
  _44 = has_symlink_leading_path (_43, _39);
  if (_44 != 0)
    goto <bb 21>; [INV]
  else
    goto <bb 22>; [INV]

  <bb 21> :
  _45 = _ ("pathspec \'%s\' is beyond a symbolic link");
  _46 = (long int) _45;
  _47 = (const char *) _46;
  printf (_47, entry);
  exit (1);

  <bb 22> :
  _48 = (long unsigned int) i;
  _49 = _48 * 56;
  _50 = item + _49;
  _51 = _50->nowildcard_len;
  _52 = (long unsigned int) i;
  _53 = _52 * 56;
  _54 = item + _53;
  _55 = _54->len;
  if (_51 < _55)
    goto <bb 23>; [INV]
  else
    goto <bb 24>; [INV]

  <bb 23> :
  pathspec->has_wildcard = 1;

  <bb 24> :
  _56 = pathspec->magic;
  _57 = (long unsigned int) i;
  _58 = _57 * 56;
  _59 = item + _58;
  _60 = _59->magic;
  _61 = _56 | _60;
  pathspec->magic = _61;
  i = i + 1;

  <bb 25> :
  if (i < n)
    goto <bb 17>; [INV]
  else
    goto <bb 26>; [INV]

  <bb 26> :
  if (nr_exclude == n)
    goto <bb 27>; [INV]
  else
    goto <bb 31>; [INV]

  <bb 27> :
  _62 = flags & 1;
  if (_62 != 0)
    goto <bb 28>; [INV]
  else
    goto <bb 29>; [INV]

  <bb 28> :
  iftmp.7 = prefixlen;
  goto <bb 30>; [INV]

  <bb 29> :
  iftmp.7 = 0;

  <bb 30> :
  plen = iftmp.7;
  _63 = (long unsigned int) n;
  _64 = _63 * 56;
  _65 = item + _64;
  init_pathspec_item (_65, 0, prefix, plen, "");
  _66 = pathspec->nr;
  _67 = _66 + 1;
  pathspec->nr = _67;

  <bb 31> :
  return;

}



;; Function main (main, funcdef_no=33, decl_uid=3366, cgraph_uid=34, symbol_order=67)

Removing basic block 3
Merging blocks 2 and 4
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
int main (int argc, char * * argv)
{
  int is_status;
  struct commit * current_head;
  int D.3438;

  <bb 2> :
  prepare_index (argc, argv, "prefix", current_head, is_status);
  D.3438 = 0;
  return D.3438;

}



;; Function prepare_index (prepare_index, funcdef_no=32, decl_uid=3337, cgraph_uid=33, symbol_order=66)

Merging blocks 28 and 29
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28
;; 2 succs { 3 4 }
;; 3 succs { 4 }
;; 4 succs { 5 6 }
;; 5 succs { }
;; 6 succs { 7 10 }
;; 7 succs { 8 9 }
;; 8 succs { }
;; 9 succs { 28 }
;; 10 succs { 13 11 }
;; 11 succs { 12 17 }
;; 12 succs { 13 17 }
;; 13 succs { 14 15 }
;; 14 succs { 16 }
;; 15 succs { 16 }
;; 16 succs { 28 }
;; 17 succs { 18 22 }
;; 18 succs { 19 22 }
;; 19 succs { 20 21 }
;; 20 succs { }
;; 21 succs { 28 }
;; 22 succs { 23 24 }
;; 23 succs { 25 }
;; 24 succs { 25 }
;; 25 succs { 26 27 }
;; 26 succs { }
;; 27 succs { 28 }
;; 28 succs { 1 }
const char * prepare_index (int argc, const char * * argv, const char * prefix, const struct commit * current_head, int is_status)
{
  char * old_index_env;
  const char * ret;
  int refresh_flags;
  struct pathspec pathspec;
  struct string_list partial;
  const char * iftmp.15;
  const char * iftmp.12;
  const char * D.3448;

  <bb 2> :
  refresh_flags = 4;
  if (is_status != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  refresh_flags = refresh_flags | 2;

  <bb 4> :
  parse_pathspec (&pathspec, 0, 2, prefix, argv);
  _1 = read_index_preload (&the_index, &pathspec);
  if (_1 < 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  _2 = _ ("index file corrupt%s");
  _3 = (long int) _2;
  _4 = (const char *) _3;
  printf (_4, "");
  exit (1);

  <bb 6> :
  interactive.8_5 = interactive;
  if (interactive.8_5 != 0)
    goto <bb 7>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 7> :
  old_index_env = 0B;
  patch_interactive.9_6 = patch_interactive;
  _7 = interactive_add (argc, argv, prefix, patch_interactive.9_6);
  if (_7 != 0)
    goto <bb 8>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 8> :
  _8 = _ ("interactive add failed%s");
  _9 = (long int) _8;
  _10 = (const char *) _9;
  printf (_10, "");
  exit (1);

  <bb 9> :
  _11 = get_lock_file_path (&index_lock);
  read_index_from (&the_index, _11);
  commit_style = 2;
  _12 = get_lock_file_path (&index_lock);
  _13 = (long int) _12;
  D.3448 = (const char *) _13;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 28>; [INV]

  <bb 10> :
  all.10_14 = all;
  if (all.10_14 != 0)
    goto <bb 13>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 11> :
  also.11_15 = also;
  if (also.11_15 != 0)
    goto <bb 12>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 12> :
  _16 = pathspec.nr;
  if (_16 != 0)
    goto <bb 13>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 13> :
  also.13_17 = also;
  if (also.13_17 != 0)
    goto <bb 14>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 14> :
  iftmp.12 = prefix;
  goto <bb 16>; [INV]

  <bb 15> :
  iftmp.12 = 0B;

  <bb 16> :
  add_files_to_cache (iftmp.12, &pathspec, 0);
  commit_style = 2;
  _18 = get_lock_file_path (&index_lock);
  _19 = (long int) _18;
  D.3448 = (const char *) _19;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 28>; [INV]

  <bb 17> :
  only.14_20 = only;
  if (only.14_20 == 0)
    goto <bb 18>; [INV]
  else
    goto <bb 22>; [INV]

  <bb 18> :
  _21 = pathspec.nr;
  if (_21 == 0)
    goto <bb 19>; [INV]
  else
    goto <bb 22>; [INV]

  <bb 19> :
  _22 = the_index.cache_changed;
  if (_22 != 0)
    goto <bb 20>; [INV]
  else
    goto <bb 21>; [INV]

  <bb 20> :
  _23 = _ ("unable to write new_index file%s");
  _24 = (long int) _23;
  _25 = (const char *) _24;
  printf (_25, "");
  exit (1);

  <bb 21> :
  rollback_lock_file (&index_lock);
  commit_style = 1;
  _26 = get_index_file ();
  _27 = (long int) _26;
  D.3448 = (const char *) _27;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 28>; [INV]

  <bb 22> :
  commit_style = 3;
  string_list_init (&partial, 1);
  if (current_head != 0B)
    goto <bb 23>; [INV]
  else
    goto <bb 24>; [INV]

  <bb 23> :
  iftmp.15 = "HEAD";
  goto <bb 25>; [INV]

  <bb 24> :
  iftmp.15 = 0B;

  <bb 25> :
  _28 = list_paths (&partial, iftmp.15, prefix, &pathspec);
  if (_28 != 0)
    goto <bb 26>; [INV]
  else
    goto <bb 27>; [INV]

  <bb 26> :
  exit (1);

  <bb 27> :
  discard_index (&the_index);
  D.3448 = ret;

  <bb 28> :
  partial = {CLOBBER};
  pathspec = {CLOBBER};
  return D.3448;

}



;; Function list_paths (list_paths, funcdef_no=31, decl_uid=3312, cgraph_uid=32, symbol_order=65)

;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
;;
;; Loop 1
;;  header 13, latch 12
;;  depth 1, outer 0
;;  nodes: 13 12 10 11
;; 2 succs { 3 4 }
;; 3 succs { 15 }
;; 4 succs { 5 9 }
;; 5 succs { 6 7 }
;; 6 succs { 8 }
;; 7 succs { 8 }
;; 8 succs { 9 }
;; 9 succs { 13 }
;; 10 succs { 11 12 }
;; 11 succs { 12 }
;; 12 succs { 13 }
;; 13 succs { 10 14 }
;; 14 succs { 15 }
;; 15 succs { 1 }
int list_paths (struct string_list * list, const char * with_tree, const char * prefix, const struct pathspec * pattern)
{
  struct string_list_item * item;
  const struct cache_entry * ce;
  char * max_prefix;
  char * m;
  int ret;
  int i;
  const char * iftmp.16;
  int D.3473;

  <bb 2> :
  _1 = pattern->nr;
  if (_1 == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  D.3473 = 0;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 15>; [INV]

  <bb 4> :
  if (with_tree != 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 5> :
  _2 = common_prefix (pattern);
  _3 = (long int) _2;
  max_prefix = (char *) _3;
  if (max_prefix != 0B)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  iftmp.16 = max_prefix;
  goto <bb 8>; [INV]

  <bb 7> :
  iftmp.16 = prefix;

  <bb 8> :
  overlay_tree_on_index (&the_index, with_tree, iftmp.16);
  free (max_prefix);

  <bb 9> :
  i = 0;
  goto <bb 13>; [INV]

  <bb 10> :
  _4 = the_index.cache;
  _5 = (long unsigned int) i;
  _6 = _5 * 8;
  _7 = _4 + _6;
  ce = *_7;
  _8 = &ce->name;
  item = string_list_insert (list, _8);
  _9 = ce_skip_worktree (ce);
  if (_9 != 0)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  item->util = item;

  <bb 12> :
  i = i + 1;

  <bb 13> :
  _10 = the_index.cache_nr;
  i.17_11 = (unsigned int) i;
  if (_10 > i.17_11)
    goto <bb 10>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 14> :
  ret = report_path_error (m, pattern, prefix);
  free (m);
  D.3473 = ret;

  <bb 15> :
  return D.3473;

}


