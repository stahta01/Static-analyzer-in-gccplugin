../Compiler/newplugin.so 11.2.0 
test.c: In function â€˜mainâ€™:
test.c:21:5: warning: implicit declaration of function â€˜foo2â€™; did you mean â€˜fooâ€™? [-Wimplicit-function-declaration]
   21 |     foo2(a);
      |     ^~~~
      |     foo

Time variable                                   usr           sys          wall           GGC
 phase setup                        :   0.00 (  0%)   0.00 (  0%)   0.00 (  0%)  1298k ( 65%)
 phase parsing                      :   0.02 ( 67%)   0.00 (  0%)   0.02 (100%)   653k ( 33%)
 phase opt and generate             :   0.01 ( 33%)   0.00 (  0%)   0.00 (  0%)    37k (  2%)
 preprocessing                      :   0.01 ( 33%)   0.00 (  0%)   0.00 (  0%)   222k ( 11%)
 lexical analysis                   :   0.00 (  0%)   0.00 (  0%)   0.02 (100%)     0  (  0%)
 parser (global)                    :   0.01 ( 33%)   0.00 (  0%)   0.00 (  0%)   372k ( 19%)
 dominance computation              :   0.01 ( 33%)   0.00 (  0%)   0.00 (  0%)     0  (  0%)
 TOTAL                              :   0.03          0.00          0.02         1999k
../Compiler/newplugin.so 11.2.0 

Time variable                                   usr           sys          wall           GGC
 phase setup                        :   0.00 (  0%)   0.00 (  0%)   0.00 (  0%)  2157k ( 99%)
 TOTAL                              :   0.00          0.00          0.00         2181k
../Compiler/newplugin.so 11.2.0 
=======ipa_pta=========
=============== The first stage : Point of interest stmt collect =================
=======node_fun:main=========
=======node_fun:foo=========
=======node_fun:freeptr=========
=============== The first stage :  record fucntion =================
start PointerConstraint
ptable point 5 
===============The second stage : Mapping stmt=================
# .MEM_10 = VDEF <.MEM_9(D)>
a_3 = foo ();
# .MEM_12 = VDEF <.MEM_11>
foo2 (a_3);
# .MEM_13 = VDEF <.MEM_12>
freeptr (a_3);
# .MEM_14 = VDEF <.MEM_13>
a_8 = foo ();
# .MEM_5 = VDEF <.MEM_4(D)>
ptr2_3 = malloc (40);
===============The second stage : Program slicing=================
=============== *this point analyzable =================
a_3 = foo ();
=============== *this point analyzable =================
a_8 = foo ();
=============== *this point analyzable =================
ptr2_3 = malloc (40);
===============The second stage : build fucntion type=================
[40;41mSTART CHECKSTART CHECKSTART CHECKSTART CHECKSTART CHECK[0m
[40;41mSTART CHECKSTART CHECKSTART CHECKSTART CHECKSTART CHECK[0m
    =()=
 ,/'_||_
  (___  `.
 ./  `=='
      |||
      |||
      |||
      |||
[40;41mSTART CHECKSTART CHECKSTART CHECKSTART CHECKSTART CHECK[0m
[40;41mSTART CHECKSTART CHECKSTART CHECKSTART CHECKSTART CHECK[0m

=============== The third stage : Start detection  =================
[40;44m =======node_fun:main========= [0m
[40;44m fucntion collect path  [0m
[40;44m =======print_function_path main  function_call count: 4 level :0========  [0m
[40;44m =======print_function_type 0  ========  [0m
[40;42m =======pre add _ fucntion:free========= [0m
[40;33m =======POP node_fun stack:free========= [0m
[40;42m =======pre add _ fucntion:foo========= [0m
[40;44m =======print_function_type 2  ========  [0m
[40;44m =======print_function_path foo  function_call count: 1 level :1========  [0m
[40;44m =======print_function_type 2  ========  [0m
[40;42m =======pre add _ fucntion:malloc========= [0m
[40;33m =======POP node_fun stack:malloc========= [0m
[40;42m =======pre_check_funciton:foo========= [0m
[40;42m =======start_check_funciton:foo========= [0m

======================================================================
 <ssa_name 0x7ff9ffd408b8
    type <pointer_type 0x7ff9ffd549d8
        type <integer_type 0x7ff9ffd4d5e8 int public SI
            size <integer_cst 0x7ff9ffd38df8 constant 32>
            unit-size <integer_cst 0x7ff9ffd38e10 constant 4>
            align:32 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7ff9ffd4d5e8 precision:32 min <integer_cst 0x7ff9ffd38db0 -2147483648> max <integer_cst 0x7ff9ffd38dc8 2147483647>
            pointer_to_this <pointer_type 0x7ff9ffd549d8>>
        unsigned DI
        size <integer_cst 0x7ff9ffd38bb8 constant 64>
        unit-size <integer_cst 0x7ff9ffd38bd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
    var <var_decl 0x7ffa005e0ea0 ptr2>
    def_stmt ptr2_3 = malloc (40);
    version:3
    ptr-info 0x7ff9ff85e150>
# .MEM_5 = VDEF <.MEM_4(D)>
ptr2_3 = malloc (40);

 ================== pre trace ptable ================== 
trace fucntion name:malloc 

 ================== pre trace ptable finish================== 

 ================== this stmt hava call fucntion ================== 
is Reserved word function :malloc
 
 Start check Pointer Collect  

======================================================================
return ptr2_3;
In function â€˜mainâ€™:
test.c:14:12: warning: use location
   14 |     return ptr2;
      |            ^
MEM[(int *)ptr2_3 + 8B] = 8;
test.c:13:12: warning: use location
   13 |     ptr2[2]=8;
      |            ^
# .MEM_5 = VDEF <.MEM_4(D)>
ptr2_3 = malloc (40);
ptr2_3 = malloc (40);
test.c:12:17: warning: use location
   12 |     ptr2=(int*) malloc(40);
      |                 ^
this stmt call this function :malloc

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7ff9ffd408b8
    type <pointer_type 0x7ff9ffd549d8
        type <integer_type 0x7ff9ffd4d5e8 int public SI
            size <integer_cst 0x7ff9ffd38df8 constant 32>
            unit-size <integer_cst 0x7ff9ffd38e10 constant 4>
            align:32 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7ff9ffd4d5e8 precision:32 min <integer_cst 0x7ff9ffd38db0 -2147483648> max <integer_cst 0x7ff9ffd38dc8 2147483647>
            pointer_to_this <pointer_type 0x7ff9ffd549d8>>
        unsigned DI
        size <integer_cst 0x7ff9ffd38bb8 constant 64>
        unit-size <integer_cst 0x7ff9ffd38bd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
    var <var_decl 0x7ffa005e0ea0 ptr2>
    def_stmt ptr2_3 = malloc (40);
    version:3
    ptr-info 0x7ff9ff85e150>

 ================================================================= 

 ================== Start Use after free Check ================== 
 
 Finish check Pointer Collect  

======================================================================
[40;35m  	Looserules free count:0 [0m
[40;31m  	free count:0 [0m

======================================================================

======================================================================
[40;31m    no free stmt possible memory leak [0m

======================================================================

======================================================================

======================================================================
 <ssa_name 0x7ff9ffd408b8
    type <pointer_type 0x7ff9ffd549d8
        type <integer_type 0x7ff9ffd4d5e8 int public SI
            size <integer_cst 0x7ff9ffd38df8 constant 32>
            unit-size <integer_cst 0x7ff9ffd38e10 constant 4>
            align:32 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7ff9ffd4d5e8 precision:32 min <integer_cst 0x7ff9ffd38db0 -2147483648> max <integer_cst 0x7ff9ffd38dc8 2147483647>
            pointer_to_this <pointer_type 0x7ff9ffd549d8>>
        unsigned DI
        size <integer_cst 0x7ff9ffd38bb8 constant 64>
        unit-size <integer_cst 0x7ff9ffd38bd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
    var <var_decl 0x7ffa005e0ea0 ptr2>
    def_stmt ptr2_3 = malloc (40);
    version:3
    ptr-info 0x7ff9ff85e150>
# .MEM_5 = VDEF <.MEM_4(D)>
ptr2_3 = malloc (40);

 ================== pre trace ptable ================== 
trace fucntion name:malloc 

 ================== pre trace ptable finish================== 

 ================== this stmt hava call fucntion ================== 
is Reserved word function :malloc
 
 Start check Pointer Collect  

======================================================================
return ptr2_3;
test.c:14:12: warning: use location
   14 |     return ptr2;
      |            ^
MEM[(int *)ptr2_3 + 8B] = 8;
test.c:13:12: warning: use location
   13 |     ptr2[2]=8;
      |            ^
# .MEM_5 = VDEF <.MEM_4(D)>
ptr2_3 = malloc (40);
ptr2_3 = malloc (40);
test.c:12:17: warning: use location
   12 |     ptr2=(int*) malloc(40);
      |                 ^
this stmt call this function :malloc

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7ff9ffd408b8
    type <pointer_type 0x7ff9ffd549d8
        type <integer_type 0x7ff9ffd4d5e8 int public SI
            size <integer_cst 0x7ff9ffd38df8 constant 32>
            unit-size <integer_cst 0x7ff9ffd38e10 constant 4>
            align:32 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7ff9ffd4d5e8 precision:32 min <integer_cst 0x7ff9ffd38db0 -2147483648> max <integer_cst 0x7ff9ffd38dc8 2147483647>
            pointer_to_this <pointer_type 0x7ff9ffd549d8>>
        unsigned DI
        size <integer_cst 0x7ff9ffd38bb8 constant 64>
        unit-size <integer_cst 0x7ff9ffd38bd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
    var <var_decl 0x7ffa005e0ea0 ptr2>
    def_stmt ptr2_3 = malloc (40);
    version:3
    ptr-info 0x7ff9ff85e150>

 ================================================================= 

 ================== Start Use after free Check ================== 
 
 Finish check Pointer Collect  

======================================================================
[40;35m  	Looserules free count:0 [0m
[40;31m  	free count:0 [0m

======================================================================

======================================================================
[40;31m    no free stmt possible memory leak [0m

======================================================================

======================================================================
[40;33m =======POP node_fun stack:foo========= [0m
[40;42m =======pre add _ fucntion:freeptr========= [0m
[40;44m =======print_function_type 0  ========  [0m
[40;44m =======print_function_path freeptr  function_call count: 1 level :1========  [0m
[40;44m =======print_function_type 0  ========  [0m
[40;42m =======pre add _ fucntion:free========= [0m
[40;33m =======POP node_fun stack:free========= [0m
[40;42m =======pre_check_funciton:freeptr========= [0m
[40;42m =======start_check_funciton:freeptr========= [0m
[40;33m =======POP node_fun stack:freeptr========= [0m
[40;42m =======pre add _ fucntion:foo2========= [0m
[40;33m =======POP node_fun stack:foo2========= [0m
[40;42m =======pre_check_funciton:main========= [0m
[40;42m =======start_check_funciton:main========= [0m

======================================================================
 <ssa_name 0x7ff9ffd405e8
    type <pointer_type 0x7ff9ffd549d8
        type <integer_type 0x7ff9ffd4d5e8 int public SI
            size <integer_cst 0x7ff9ffd38df8 constant 32>
            unit-size <integer_cst 0x7ff9ffd38e10 constant 4>
            align:32 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7ff9ffd4d5e8 precision:32 min <integer_cst 0x7ff9ffd38db0 -2147483648> max <integer_cst 0x7ff9ffd38dc8 2147483647>
            pointer_to_this <pointer_type 0x7ff9ffd549d8>>
        unsigned DI
        size <integer_cst 0x7ff9ffd38bb8 constant 64>
        unit-size <integer_cst 0x7ff9ffd38bd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
    var <var_decl 0x7ffa005e0b40 a>
    def_stmt a_3 = foo ();
    version:3
    ptr-info 0x7ff9ff85e120>
# .MEM_10 = VDEF <.MEM_9(D)>
a_3 = foo ();

 ================== pre trace ptable ================== 
trace fucntion name:foo 
[40;44m =======trace_function_path foo  function_call count: 1 level :888========  [0m
[40;31m  find return stmt  [0m
[40;31m  this fucntion return heap-object  [0m
# VUSE <.MEM_6>
return ptr2_3;
test.c:14:12: warning: use location
   14 |     return ptr2;
      |            ^
[40;36m ======= node_fun:foo========= [0m
[40;36m ======= find relate stmt with a ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:malloc========= [0m
[40;46m =======add node_fun stack:malloc========= [0m

 ================== pre trace ptable finish================== 

 ================== this stmt hava call fucntion ================== 
is Other function foo
 
 Start check Pointer Collect  

======================================================================
freeptr (a_3);
test.c:22:5: warning: use location
   22 |     freeptr(a);
      |     ^
this stmt call this function :freeptr
trace fucntion name:freeptr 
[40;44m =======trace_function_path freeptr  function_call count: 1 level :0========  [0m
# .MEM_4 = VDEF <.MEM_3(D)>
free (p_2(D));
[40;31m  find free stmt free same pointer [0m
# .MEM_4 = VDEF <.MEM_3(D)>
free (p_2(D));
test.c:3:5: warning: use location
    3 |     free(p);
      |     ^
[40;42m =======pre add _ fucntion:free========= [0m
[40;46m =======add node_fun stack:free========= [0m

 ================== trace ================== 
trace fucntion free:1 
foo2 (a_3);
test.c:21:5: warning: use location
   21 |     foo2(a);
      |     ^
this stmt call this function :foo2
trace fucntion name:foo2 

 ================== trace ================== 
trace fucntion free:1 
MEM[(int *)a_3 + 8B] = 10;
test.c:20:9: warning: use location
   20 |     a[2]=10;
      |         ^
MEM[(int *)a_3 + 8B] = 10;
test.c:20:9: warning: use location
# .MEM_10 = VDEF <.MEM_9(D)>
a_3 = foo ();
a_3 = foo ();
test.c:19:7: warning: use location
   19 |     a=foo();
      |       ^
this stmt call this function :foo
trace fucntion name:foo 
[40;44m =======trace_function_path foo  function_call count: 1 level :0========  [0m
[40;42m =======pre add _ fucntion:malloc========= [0m
[40;46m =======add node_fun stack:malloc========= [0m

 ================== trace ================== 
trace fucntion free:1 

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7ff9ffd405e8
    type <pointer_type 0x7ff9ffd549d8
        type <integer_type 0x7ff9ffd4d5e8 int public SI
            size <integer_cst 0x7ff9ffd38df8 constant 32>
            unit-size <integer_cst 0x7ff9ffd38e10 constant 4>
            align:32 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7ff9ffd4d5e8 precision:32 min <integer_cst 0x7ff9ffd38db0 -2147483648> max <integer_cst 0x7ff9ffd38dc8 2147483647>
            pointer_to_this <pointer_type 0x7ff9ffd549d8>>
        unsigned DI
        size <integer_cst 0x7ff9ffd38bb8 constant 64>
        unit-size <integer_cst 0x7ff9ffd38bd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
    var <var_decl 0x7ffa005e0b40 a>
    def_stmt a_3 = foo ();
    version:3
    ptr-info 0x7ff9ff85e120>

 ================================================================= 
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_15 = VDEF <.MEM_14>
free (a_8);
test.c:25:5: warning: use location
   25 |     free(a);
      |     ^

 ================== Start Use after free Check ================== 
 
 Finish check Pointer Collect  

======================================================================
[40;35m  	Looserules free count:1 [0m
[40;31m  	free count:1 [0m

======================================================================

======================================================================
[40;32m   No memory leak, need more check!  [0m

======================================================================


======================================================================

======================================================================
 <ssa_name 0x7ff9ffd40630
    type <pointer_type 0x7ff9ffd549d8
        type <integer_type 0x7ff9ffd4d5e8 int public SI
            size <integer_cst 0x7ff9ffd38df8 constant 32>
            unit-size <integer_cst 0x7ff9ffd38e10 constant 4>
            align:32 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7ff9ffd4d5e8 precision:32 min <integer_cst 0x7ff9ffd38db0 -2147483648> max <integer_cst 0x7ff9ffd38dc8 2147483647>
            pointer_to_this <pointer_type 0x7ff9ffd549d8>>
        unsigned DI
        size <integer_cst 0x7ff9ffd38bb8 constant 64>
        unit-size <integer_cst 0x7ff9ffd38bd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
    var <var_decl 0x7ffa005e0b40 a>
    def_stmt a_8 = foo ();
    version:8
    ptr-info 0x7ff9ff85e138>
# .MEM_14 = VDEF <.MEM_13>
a_8 = foo ();

 ================== pre trace ptable ================== 
trace fucntion name:foo 
[40;44m =======trace_function_path foo  function_call count: 1 level :888========  [0m
[40;31m  find return stmt  [0m
[40;31m  this fucntion return heap-object  [0m
# VUSE <.MEM_6>
return ptr2_3;
test.c:14:12: warning: use location
   14 |     return ptr2;
      |            ^
[40;36m ======= node_fun:foo========= [0m
[40;36m ======= find relate stmt with a ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:malloc========= [0m
[40;46m =======add node_fun stack:malloc========= [0m

 ================== pre trace ptable finish================== 

 ================== this stmt hava call fucntion ================== 
is Other function foo
 
 Start check Pointer Collect  

======================================================================
MEM[(int *)a_8 + 24B] = 4;
test.c:26:9: warning: use location
   26 |     a[6]=4;
      |         ^
MEM[(int *)a_8 + 24B] = 4;
test.c:26:9: warning: use location
free (a_8);
test.c:25:5: warning: use location
   25 |     free(a);
      |     ^
this stmt call this function :free

 ================== find free stmt ================== 
free (a_8);
test.c:25:5: warning: use location
[40;32m    HAS FREE STMT count:1 name:free [0m

 ================== find free stmt ================== 
# .MEM_14 = VDEF <.MEM_13>
a_8 = foo ();
a_8 = foo ();
test.c:24:7: warning: use location
   24 |     a=foo();
      |       ^
this stmt call this function :foo
trace fucntion name:foo 
[40;44m =======trace_function_path foo  function_call count: 1 level :0========  [0m
[40;42m =======pre add _ fucntion:malloc========= [0m
[40;46m =======add node_fun stack:malloc========= [0m

 ================== trace ================== 
trace fucntion free:1 

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7ff9ffd40630
    type <pointer_type 0x7ff9ffd549d8
        type <integer_type 0x7ff9ffd4d5e8 int public SI
            size <integer_cst 0x7ff9ffd38df8 constant 32>
            unit-size <integer_cst 0x7ff9ffd38e10 constant 4>
            align:32 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7ff9ffd4d5e8 precision:32 min <integer_cst 0x7ff9ffd38db0 -2147483648> max <integer_cst 0x7ff9ffd38dc8 2147483647>
            pointer_to_this <pointer_type 0x7ff9ffd549d8>>
        unsigned DI
        size <integer_cst 0x7ff9ffd38bb8 constant 64>
        unit-size <integer_cst 0x7ff9ffd38bd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
    var <var_decl 0x7ffa005e0b40 a>
    def_stmt a_8 = foo ();
    version:8
    ptr-info 0x7ff9ff85e138>

 ================================================================= 
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_15 = VDEF <.MEM_14>
free (a_8);
test.c:25:5: warning: use location
   25 |     free(a);
      |     ^

 ================== Start Use after free Check ================== 

============================================================
# .MEM_15 = VDEF <.MEM_14>
free (a_8);
test.c:25:5: warning: free in this location
[40;35m target gimple type: ssa_name [0m
# .MEM_16 = VDEF <.MEM_15>
MEM[(int *)a_8 + 24B] = 4;
test.c:26:9: warning: use location
   26 |     a[6]=4;
      |         ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_15 = VDEF <.MEM_14>
free (a_8);
test.c:25:5: warning: free in this location
   25 |     free(a);
      |     ^
[40;35m target gimple type: ssa_name [0m
# .MEM_16 = VDEF <.MEM_15>
MEM[(int *)a_8 + 24B] = 4;
test.c:26:9: warning: use location
   26 |     a[6]=4;
      |         ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
# .MEM_15 = VDEF <.MEM_14>
free (a_8);
test.c:25:5: warning: free in this location
   25 |     free(a);
      |     ^
[40;35m target gimple type: mem_ref [0m
# .MEM_16 = VDEF <.MEM_15>
MEM[(int *)a_8 + 24B] = 4;
test.c:26:9: warning: use location
   26 |     a[6]=4;
      |         ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_15 = VDEF <.MEM_14>
free (a_8);
test.c:25:5: warning: free in this location
   25 |     free(a);
      |     ^
[40;35m target gimple type: mem_ref [0m
# .MEM_16 = VDEF <.MEM_15>
MEM[(int *)a_8 + 24B] = 4;
test.c:26:9: warning: use location
   26 |     a[6]=4;
      |         ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 
 
 Finish check Pointer Collect  

======================================================================
[40;35m  	Looserules free count:1 [0m
[40;31m  	free count:1 [0m

======================================================================

======================================================================
[40;32m   No memory leak, need more check!  [0m

======================================================================


======================================================================
[40;33m =======POP node_fun stack:main========= [0m
[40;44m =======node_fun:foo========= [0m
[40;44m fucntion collect path  [0m
[40;44m =======print_function_path foo  function_call count: 1 level :0========  [0m
[40;44m =======print_function_type 2  ========  [0m
[40;42m =======pre add _ fucntion:malloc========= [0m
[40;33m =======POP node_fun stack:malloc========= [0m
[40;42m =======pre_check_funciton:foo========= [0m
[40;42m =======start_check_funciton:foo========= [0m

======================================================================
 <ssa_name 0x7ff9ffd408b8
    type <pointer_type 0x7ff9ffd549d8
        type <integer_type 0x7ff9ffd4d5e8 int public SI
            size <integer_cst 0x7ff9ffd38df8 constant 32>
            unit-size <integer_cst 0x7ff9ffd38e10 constant 4>
            align:32 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7ff9ffd4d5e8 precision:32 min <integer_cst 0x7ff9ffd38db0 -2147483648> max <integer_cst 0x7ff9ffd38dc8 2147483647>
            pointer_to_this <pointer_type 0x7ff9ffd549d8>>
        unsigned DI
        size <integer_cst 0x7ff9ffd38bb8 constant 64>
        unit-size <integer_cst 0x7ff9ffd38bd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
    var <var_decl 0x7ffa005e0ea0 ptr2>
    def_stmt ptr2_3 = malloc (40);
    version:3
    ptr-info 0x7ff9ff85e150>
# .MEM_5 = VDEF <.MEM_4(D)>
ptr2_3 = malloc (40);

 ================== pre trace ptable ================== 
trace fucntion name:malloc 

 ================== pre trace ptable finish================== 

 ================== this stmt hava call fucntion ================== 
is Reserved word function :malloc
 
 Start check Pointer Collect  

======================================================================
return ptr2_3;
In function â€˜fooâ€™:
test.c:14:12: warning: use location
   14 |     return ptr2;
      |            ^
MEM[(int *)ptr2_3 + 8B] = 8;
test.c:13:12: warning: use location
   13 |     ptr2[2]=8;
      |            ^
# .MEM_5 = VDEF <.MEM_4(D)>
ptr2_3 = malloc (40);
ptr2_3 = malloc (40);
test.c:12:17: warning: use location
   12 |     ptr2=(int*) malloc(40);
      |                 ^
this stmt call this function :malloc

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7ff9ffd408b8
    type <pointer_type 0x7ff9ffd549d8
        type <integer_type 0x7ff9ffd4d5e8 int public SI
            size <integer_cst 0x7ff9ffd38df8 constant 32>
            unit-size <integer_cst 0x7ff9ffd38e10 constant 4>
            align:32 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7ff9ffd4d5e8 precision:32 min <integer_cst 0x7ff9ffd38db0 -2147483648> max <integer_cst 0x7ff9ffd38dc8 2147483647>
            pointer_to_this <pointer_type 0x7ff9ffd549d8>>
        unsigned DI
        size <integer_cst 0x7ff9ffd38bb8 constant 64>
        unit-size <integer_cst 0x7ff9ffd38bd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
    var <var_decl 0x7ffa005e0ea0 ptr2>
    def_stmt ptr2_3 = malloc (40);
    version:3
    ptr-info 0x7ff9ff85e150>

 ================================================================= 

 ================== Start Use after free Check ================== 
 
 Finish check Pointer Collect  

======================================================================
[40;35m  	Looserules free count:0 [0m
[40;31m  	free count:0 [0m

======================================================================

======================================================================
[40;31m    no free stmt possible memory leak [0m

======================================================================

======================================================================

======================================================================
 <ssa_name 0x7ff9ffd408b8
    type <pointer_type 0x7ff9ffd549d8
        type <integer_type 0x7ff9ffd4d5e8 int public SI
            size <integer_cst 0x7ff9ffd38df8 constant 32>
            unit-size <integer_cst 0x7ff9ffd38e10 constant 4>
            align:32 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7ff9ffd4d5e8 precision:32 min <integer_cst 0x7ff9ffd38db0 -2147483648> max <integer_cst 0x7ff9ffd38dc8 2147483647>
            pointer_to_this <pointer_type 0x7ff9ffd549d8>>
        unsigned DI
        size <integer_cst 0x7ff9ffd38bb8 constant 64>
        unit-size <integer_cst 0x7ff9ffd38bd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
    var <var_decl 0x7ffa005e0ea0 ptr2>
    def_stmt ptr2_3 = malloc (40);
    version:3
    ptr-info 0x7ff9ff85e150>
# .MEM_5 = VDEF <.MEM_4(D)>
ptr2_3 = malloc (40);

 ================== pre trace ptable ================== 
trace fucntion name:malloc 

 ================== pre trace ptable finish================== 

 ================== this stmt hava call fucntion ================== 
is Reserved word function :malloc
 
 Start check Pointer Collect  

======================================================================
return ptr2_3;
test.c:14:12: warning: use location
   14 |     return ptr2;
      |            ^
MEM[(int *)ptr2_3 + 8B] = 8;
test.c:13:12: warning: use location
   13 |     ptr2[2]=8;
      |            ^
# .MEM_5 = VDEF <.MEM_4(D)>
ptr2_3 = malloc (40);
ptr2_3 = malloc (40);
test.c:12:17: warning: use location
   12 |     ptr2=(int*) malloc(40);
      |                 ^
this stmt call this function :malloc

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7ff9ffd408b8
    type <pointer_type 0x7ff9ffd549d8
        type <integer_type 0x7ff9ffd4d5e8 int public SI
            size <integer_cst 0x7ff9ffd38df8 constant 32>
            unit-size <integer_cst 0x7ff9ffd38e10 constant 4>
            align:32 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7ff9ffd4d5e8 precision:32 min <integer_cst 0x7ff9ffd38db0 -2147483648> max <integer_cst 0x7ff9ffd38dc8 2147483647>
            pointer_to_this <pointer_type 0x7ff9ffd549d8>>
        unsigned DI
        size <integer_cst 0x7ff9ffd38bb8 constant 64>
        unit-size <integer_cst 0x7ff9ffd38bd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
    var <var_decl 0x7ffa005e0ea0 ptr2>
    def_stmt ptr2_3 = malloc (40);
    version:3
    ptr-info 0x7ff9ff85e150>

 ================================================================= 

 ================== Start Use after free Check ================== 
 
 Finish check Pointer Collect  

======================================================================
[40;35m  	Looserules free count:0 [0m
[40;31m  	free count:0 [0m

======================================================================

======================================================================
[40;31m    no free stmt possible memory leak [0m

======================================================================

======================================================================
[40;33m =======POP node_fun stack:foo========= [0m
[40;44m =======node_fun:freeptr========= [0m
[40;44m fucntion collect path  [0m
[40;44m =======print_function_path freeptr  function_call count: 1 level :0========  [0m
[40;44m =======print_function_type 0  ========  [0m
[40;42m =======pre add _ fucntion:free========= [0m
[40;33m =======POP node_fun stack:free========= [0m
[40;42m =======pre_check_funciton:freeptr========= [0m
[40;42m =======start_check_funciton:freeptr========= [0m
[40;33m =======POP node_fun stack:freeptr========= [0m
fucntion collect path finsh

=============== The third stage : detection  End=================

===============Print ALL GIMPLE IR=================
=======Mapping node_fun:main=========
=======is loop:0=========

 bb index 2 
<bb 2> [local count: 1073741824]:
a_3 = foo ();
MEM[(int *)a_3 + 8B] = 10;
foo2 (a_3);
freeptr (a_3);
a_8 = foo ();
free (a_8);
MEM[(int *)a_8 + 24B] = 4;
return 0;

=======Mapping node_fun:foo=========
=======is loop:0=========

 bb index 2 
<bb 2> [local count: 1073741824]:
ptr2_3 = malloc (40);
MEM[(int *)ptr2_3 + 8B] = 8;
return ptr2_3;

=======Mapping node_fun:freeptr=========
=======is loop:0=========

 bb index 2 
<bb 2> [local count: 1073741824]:
free (p_2(D));
return;


===============Print ALL GIMPLE IR=================
[40;32mSTART CHECKSTART CHECKSTART CHECKSTART CHECKSTART CHECK[0m
[40;32mSTART CHECKSTART CHECKSTART CHECKSTART CHECKSTART CHECK[0m
    =()=
 ,/'_||_
  (___  `.
 ./  `=='
                   
    ~~~~~~~~~~~  
 ~~~~~~
           ~~~~~~~
[40;34m    gimple malloc count : 1 [0m
[40;34m    gimple free   count : 2 [0m
[40;34m    all ptable point : 6 [0m
[40;34m    analyzable ptable point : 3 [0m
[40;34m    used_stmt array stack totalsize of : 0.000072 mb[0m
[40;34m    collect time: : 0.000281 s [0m
[40;34m    algorithm time: 0.006155 s [0m
[40;34m    gimple stmt count : : 13 [0m
[40;34m    this report analysis in Fri Feb 11 20:00:03 2022
 [0m
[40;32mSTART CHECKSTART CHECKSTART CHECKSTART CHECKSTART CHECK[0m
[40;32mSTART CHECKSTART CHECKSTART CHECKSTART CHECKSTART CHECK[0m

Time variable                                   usr           sys          wall           GGC
 phase setup                        :   0.00 (  0%)   0.00 (  0%)   0.00 (  0%)  2157k ( 92%)
 phase opt and generate             :   0.01 (100%)   0.00 (  0%)   0.02 (100%)   167k (  7%)
 callgraph functions expansion      :   0.00 (  0%)   0.00 (  0%)   0.01 ( 50%)   131k (  6%)
 ipa lto gimple in                  :   0.01 (100%)   0.00 (  0%)   0.00 (  0%)    29k (  1%)
 plugin execution                   :   0.00 (  0%)   0.00 (  0%)   0.01 ( 50%)    96  (  0%)
 initialize rtl                     :   0.00 (  0%)   0.00 (  0%)   0.01 ( 50%)    12k (  1%)
 TOTAL                              :   0.01          0.00          0.02         2347k
/usr/bin/ld: /tmp/cc0zntmG.ltrans0.ltrans.o: in function `main':
<artificial>:(.text+0x41): undefined reference to `foo2'
collect2: error: ld returned 1 exit status
