In file included from test.c:7:0:
common.h: In function â€˜discard_my_cleanupsâ€™:
common.h:94:21: warning: format â€˜%xâ€™ expects argument of type â€˜unsigned intâ€™, but argument 2 has type â€˜void *â€™ [-Wformat=]
   printf("freearg: %x\n", ptr->arg);
                    ~^     ~~~~~~~~
                    %p
common.h: In function â€˜do_my_cleanupsâ€™:
common.h:108:13: warning: format â€˜%xâ€™ expects argument of type â€˜unsigned intâ€™, but argument 2 has type â€˜void *â€™ [-Wformat=]
    printf("%x\n", ptr->arg);
            ~^     ~~~~~~~~
            %p
test.c: In function â€˜ldirnameâ€™:
test.c:44:3: warning: implicit declaration of function â€˜memcpyâ€™ [-Wimplicit-function-declaration]
   memcpy (dirname, filename, base - filename);
   ^~~~~~
test.c:44:3: warning: incompatible implicit declaration of built-in function â€˜memcpyâ€™
test.c:44:3: note: include â€˜<string.h>â€™ or provide a declaration of â€˜memcpyâ€™
test.c: In function â€˜vconcat_copyâ€™:
test.c:61:25: warning: implicit declaration of function â€˜strlenâ€™ [-Wimplicit-function-declaration]
  unsigned long length = strlen (arg);
                         ^~~~~~
test.c:61:25: warning: incompatible implicit declaration of built-in function â€˜strlenâ€™
test.c:61:25: note: include â€˜<string.h>â€™ or provide a declaration of â€˜strlenâ€™
test.c:62:2: warning: incompatible implicit declaration of built-in function â€˜memcpyâ€™
  memcpy (end, arg, length);
  ^~~~~~
test.c:62:2: note: include â€˜<string.h>â€™ or provide a declaration of â€˜memcpyâ€™
In file included from test.c:7:0:
test.c: In function â€˜do_start_initializationâ€™:
common.h:22:20: warning: implicit declaration of function â€˜strdupâ€™ [-Wimplicit-function-declaration]
 #define xstrdup(a) strdup(a)
                    ^
test.c:110:12: note: in expansion of macro â€˜xstrdupâ€™
   oldloc = xstrdup (setlocale (LC_ALL, NULL));
            ^~~~~~~
common.h:22:20: warning: incompatible implicit declaration of built-in function â€˜strdupâ€™
 #define xstrdup(a) strdup(a)
                    ^
test.c:110:12: note: in expansion of macro â€˜xstrdupâ€™
   oldloc = xstrdup (setlocale (LC_ALL, NULL));
            ^~~~~~~
test.c:110:21: warning: implicit declaration of function â€˜setlocaleâ€™; did you mean â€˜setstateâ€™? [-Wimplicit-function-declaration]
   oldloc = xstrdup (setlocale (LC_ALL, NULL));
                     ^
common.h:22:27: note: in definition of macro â€˜xstrdupâ€™
 #define xstrdup(a) strdup(a)
                           ^
test.c:110:21: warning: passing argument 1 of â€˜strdupâ€™ makes pointer from integer without a cast [-Wint-conversion]
   oldloc = xstrdup (setlocale (LC_ALL, NULL));
                     ^
common.h:22:27: note: in definition of macro â€˜xstrdupâ€™
 #define xstrdup(a) strdup(a)
                           ^
test.c:110:21: note: expected â€˜const char *â€™ but argument is of type â€˜intâ€™
   oldloc = xstrdup (setlocale (LC_ALL, NULL));
                     ^
common.h:22:27: note: in definition of macro â€˜xstrdupâ€™
 #define xstrdup(a) strdup(a)
                           ^
test.c:112:14: warning: incompatible implicit declaration of built-in function â€˜strlenâ€™
   progsize = strlen (progname);
              ^~~~~~
test.c:112:14: note: include â€˜<string.h>â€™ or provide a declaration of â€˜strlenâ€™
=======ipa_pta=========
===============The first stage : Point of interest stmt collect=================
--------GIMPLE Cond -------
succs:= 4
--------GIMPLE Cond -------
succs:= 7
--------GIMPLE Cond -------
--------GIMPLE Cond -------
succs:= 7
succs:= 8
succs:= 9
--------GIMPLE Cond -------
succs:= 10
--------GIMPLE Cond -------
succs:= 11
--------GIMPLE Cond -------
succs:= 12
succs:= 10
succs:= 11
succs:= 12
succs:= 9
--------GIMPLE Cond -------
succs:= 15
succs:= 15
--------GIMPLE Cond -------
succs:= 17
--------GIMPLE Cond -------
succs:= 18
succs:= 18
--------GIMPLE Cond -------
succs:= 20
succs:= 17
succs:= 20
--------GIMPLE Cond -------
succs:= 23
succs:= 23
===============The first stage : Point of interest stmt collect=================
start PointerConstraint
pointer ftable is 1 
pointer ptable is 1 
===============The second stage : Mapping stmt=================
# .MEM_9 = VDEF <.MEM_8(D)>
newstr_3 = malloc (1);
# VUSE <.MEM_9>
length_11 = strlen (arg_5(D));
# .MEM_13 = VDEF <.MEM_9>
memcpy (newstr_3, arg_5(D), length_11);
# .MEM_92 = VDEF <.MEM_5(D)>
dirname_52 = malloc (_51);
# .MEM_93 = VDEF <.MEM_92>
memcpy (dirname_52, _9, _56);
# .MEM_97 = VDEF <.MEM_87>
progname_11 = concat (_10, "bin");
# .MEM_98 = VDEF <.MEM_97>
_12 = setlocale ("LC_ALL", 0B);
# .MEM_99 = VDEF <.MEM_98>
oldloc_15 = strdup (_14);
# .MEM_100 = VDEF <.MEM_99>
setlocale ("LC_ALL", "");
# VUSE <.MEM_100>
progsize_16 = strlen (progname_11);
# .MEM_101 = VDEF <.MEM_100>
ret_41 = malloc (_18);
# .MEM_114 = VDEF <.MEM_113>
_21 = __fprintf_chk (_20, 1, "out of memory\n");
# VUSE <.MEM_101>
_24 = __builtin_object_size (progname_copy_19, 1);
_25 = __builtin_constant_p (_23);
# VUSE <.MEM_101>
_26 = __builtin_object_size (progname_copy_19, 1);
# .MEM_104 = VDEF <.MEM_101>
_28 = __mbstowcs_chk (progname_copy_19, progname_11, _23, _27);
# VUSE <.MEM_101>
_29 = __builtin_object_size (progname_copy_19, 1);
# VUSE <.MEM_101>
_31 = __builtin_object_size (progname_copy_19, 1);
# .MEM_103 = VDEF <.MEM_101>
_33 = __mbstowcs_chk_warn (progname_copy_19, progname_11, _23, _32);
# .MEM_105 = VDEF <.MEM_101>
_34 = __mbstowcs_alias (progname_copy_19, progname_11, _23);
# .MEM_112 = VDEF <.MEM_111>
_37 = __fprintf_chk (_36, 1, "Could not convert python path to string\n");
# .MEM_106 = VDEF <.MEM_88>
setlocale ("LC_ALL", oldloc_15);
# .MEM_108 = VDEF <.MEM_107>
_85 = __printf_chk (1, "%d\n", _84);
# .MEM_7 = VDEF <.MEM_89>
concat ("dummy", "");
# .MEM_8 = VDEF <.MEM_7>
_4 = __printf_chk (1, "%d\n", 1835890020);
start collect similar stmtstart collect similar stmtstart collect similar stmtstart collect similar stmt
start collect similar stmtstart collect similar stmtstart collect similar stmtstart collect similar stmt
start collect similar stmtstart collect similar stmtstart collect similar stmtstart collect similar stmt
start collect similar stmtstart collect similar stmtstart collect similar stmtstart collect similar stmt
start collect similar stmtstart collect similar stmtstart collect similar stmtstart collect similar stmt
===============The second stage : build fucntion type=================
[40;41mSTART CHECKSTART CHECKSTART CHECKSTART CHECKSTART CHECK[0m
[40;41mSTART CHECKSTART CHECKSTART CHECKSTART CHECKSTART CHECK[0m
    =()=
 ,/'_||_
  (___  `.
 ./  `=='
      |||
      |||
      |||
      |||
[40;41mSTART CHECKSTART CHECKSTART CHECKSTART CHECKSTART CHECK[0m
[40;41mSTART CHECKSTART CHECKSTART CHECKSTART CHECKSTART CHECK[0m
===============The second stage : record fucntion =================

=============== The third stage : Start detection  =================
[40;44m =======node_fun:concat========= [0m
[40;44m fucntion collect path  [0m
[40;44m =======print_function_path concat  function_call count: 3 level :0========  [0m
[40;44m =======print_function_type 2  ========  [0m
[40;42m =======pre add _ fucntion:memcpy========= [0m
[40;33m =======POP node_fun stack:memcpy========= [0m
[40;42m =======pre add _ fucntion:strlen========= [0m
[40;33m =======POP node_fun stack:strlen========= [0m
[40;42m =======pre add _ fucntion:malloc========= [0m
[40;33m =======POP node_fun stack:malloc========= [0m
[40;42m =======pre_check_funciton:concat========= [0m
[40;42m =======start_check_funciton:concat========= [0m

dot graph START

======================================================================
 <ssa_name 0x7f034cea4900
    type <pointer_type 0x7f034c9c65e8
        type <integer_type 0x7f034c9c6dc8 char public string-flag QI
            size <integer_cst 0x7f034ce9ccd8 constant 8>
            unit size <integer_cst 0x7f034ce9ccf0 constant 1>
            align 8 symtab 0 alias set -1 canonical type 0x7f034ceb03f0 precision 8 min <integer_cst 0x7f034c9c91b0 -128> max <integer_cst 0x7f034c9c9198 127>
            pointer_to_this <pointer_type 0x7f034c9c65e8>>
        public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality context <translation_unit_decl 0x7f034cea7168 test.c>
        pointer_to_this <pointer_type 0x7f034c9d2bd0>>
    var <var_decl 0x7f034dc31d80 newstr>
    def_stmt newstr_3 = malloc (1);
    version 3
    ptr-info 0x7f034c9f1108>
# .MEM_9 = VDEF <.MEM_8(D)>
newstr_3 = malloc (1);

 ================== trace ptable================== 
trace fucntion name:malloc 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr---malloc-----
this Reserved word function ------malloc-----
 
 Start check Pointer Collect  

======================================================================
_15 = newstr_3;
In function â€˜concatâ€™:
lto1: warning: use location
end_12 = newstr_3 + length_11;
test.c:63:6: warning: use location
  end += length;
      ^
*end_12 = 0;
test.c:65:7: warning: use location
  *end = '\000';
       ^
memcpy (newstr_3, arg_5(D), length_11);
test.c:62:2: warning: use location
  memcpy (end, arg, length);
  ^
this stmt is child function---memcpy-----

 ================== trace ================== 
 <ssa_name 0x7f034cea4900
    type <pointer_type 0x7f034c9c65e8
        type <integer_type 0x7f034c9c6dc8 char public string-flag QI
            size <integer_cst 0x7f034ce9ccd8 constant 8>
            unit size <integer_cst 0x7f034ce9ccf0 constant 1>
            align 8 symtab 0 alias set -1 canonical type 0x7f034ceb03f0 precision 8 min <integer_cst 0x7f034c9c91b0 -128> max <integer_cst 0x7f034c9c9198 127>
            pointer_to_this <pointer_type 0x7f034c9c65e8>>
        public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality context <translation_unit_decl 0x7f034cea7168 test.c>
        pointer_to_this <pointer_type 0x7f034c9d2bd0>>
    var <var_decl 0x7f034dc31d80 newstr>
    def_stmt newstr_3 = malloc (1);
    version 3
    ptr-info 0x7f034c9f1108>
trace fucntion name:memcpy 

 ================== trace ================== 
trace fucntion free:0 
return newstr_3;
test.c:81:10: warning: use location
   return newstr;
          ^
_7 = newstr_3;
test.c:81:10: warning: use location
newstr_3 = malloc (1);
test.c:76:10: warning: use location
   newstr = XNEWVEC (char, 1);
          ^
this stmt is child function---malloc-----

 ================== trace ================== 
 <ssa_name 0x7f034cea4900
    type <pointer_type 0x7f034c9c65e8
        type <integer_type 0x7f034c9c6dc8 char public string-flag QI
            size <integer_cst 0x7f034ce9ccd8 constant 8>
            unit size <integer_cst 0x7f034ce9ccf0 constant 1>
            align 8 symtab 0 alias set -1 canonical type 0x7f034ceb03f0 precision 8 min <integer_cst 0x7f034c9c91b0 -128> max <integer_cst 0x7f034c9c9198 127>
            pointer_to_this <pointer_type 0x7f034c9c65e8>>
        public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality context <translation_unit_decl 0x7f034cea7168 test.c>
        pointer_to_this <pointer_type 0x7f034c9d2bd0>>
    var <var_decl 0x7f034dc31d80 newstr>
    def_stmt newstr_3 = malloc (1);
    version 3
    ptr-info 0x7f034c9f1108>
trace fucntion name:malloc 

 ================== trace ================== 
trace fucntion free:0 

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7f034cea4900
    type <pointer_type 0x7f034c9c65e8
        type <integer_type 0x7f034c9c6dc8 char public string-flag QI
            size <integer_cst 0x7f034ce9ccd8 constant 8>
            unit size <integer_cst 0x7f034ce9ccf0 constant 1>
            align 8 symtab 0 alias set -1 canonical type 0x7f034ceb03f0 precision 8 min <integer_cst 0x7f034c9c91b0 -128> max <integer_cst 0x7f034c9c9198 127>
            pointer_to_this <pointer_type 0x7f034c9c65e8>>
        public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality context <translation_unit_decl 0x7f034cea7168 test.c>
        pointer_to_this <pointer_type 0x7f034c9d2bd0>>
    var <var_decl 0x7f034dc31d80 newstr>
    def_stmt newstr_3 = malloc (1);
    version 3
    ptr-info 0x7f034c9f1108>

 ================== Start Use after free Check ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:0 [0m

======================================================================

======================================================================
[40;31m    no free stmt possible memory leak [0m

======================================================================

dot graph START

======================================================================

 ================== collect possiable invalid ================== 
 <integer_cst 0x7f034c9c9e40 type <integer_type 0x7f034ceb07e0 long unsigned int> constant 1>

dot graph START

======================================================================
 <ssa_name 0x7f034cea4990
    type <pointer_type 0x7f034c9c6f18
        type <integer_type 0x7f034c9c6e70 char readonly public string-flag QI
            size <integer_cst 0x7f034ce9ccd8 constant 8>
            unit size <integer_cst 0x7f034ce9ccf0 constant 1>
            align 8 symtab 0 alias set -1 canonical type 0x7f034ceb03f0 precision 8 min <integer_cst 0x7f034c9c91b0 -128> max <integer_cst 0x7f034c9c9198 127>
            pointer_to_this <pointer_type 0x7f034c9c6f18>>
        public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality>
    var <parm_decl 0x7f034c9d5380 arg>
    def_stmt GIMPLE_NOP
    version 5
    ptr-info 0x7f034c9f1138>
GIMPLE_NOP

 ================== trace ptable================== 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr--------
this other function -----------
 
 Start check Pointer Collect  

======================================================================
length_11 = strlen (arg_5(D));
test.c:61:16: warning: use location
  unsigned long length = strlen (arg);
                ^
this stmt is child function---strlen-----

 ================== trace ================== 
 <ssa_name 0x7f034cea4990
    type <pointer_type 0x7f034c9c6f18
        type <integer_type 0x7f034c9c6e70 char readonly public string-flag QI
            size <integer_cst 0x7f034ce9ccd8 constant 8>
            unit size <integer_cst 0x7f034ce9ccf0 constant 1>
            align 8 symtab 0 alias set -1 canonical type 0x7f034ceb03f0 precision 8 min <integer_cst 0x7f034c9c91b0 -128> max <integer_cst 0x7f034c9c9198 127>
            pointer_to_this <pointer_type 0x7f034c9c6f18>>
        public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality>
    var <parm_decl 0x7f034c9d5380 arg>
    def_stmt GIMPLE_NOP
    version 5
    ptr-info 0x7f034c9f1138>
trace fucntion name:strlen 

 ================== trace ================== 
trace fucntion free:0 
end_12 = newstr_3 + length_11;
test.c:63:6: warning: use location
  end += length;
      ^
*end_12 = 0;
test.c:65:7: warning: use location
  *end = '\000';
       ^
memcpy (newstr_3, arg_5(D), length_11);
test.c:62:2: warning: use location
  memcpy (end, arg, length);
  ^
this stmt is child function---memcpy-----

 ================== trace ================== 
 <ssa_name 0x7f034cea4990
    type <pointer_type 0x7f034c9c6f18
        type <integer_type 0x7f034c9c6e70 char readonly public string-flag QI
            size <integer_cst 0x7f034ce9ccd8 constant 8>
            unit size <integer_cst 0x7f034ce9ccf0 constant 1>
            align 8 symtab 0 alias set -1 canonical type 0x7f034ceb03f0 precision 8 min <integer_cst 0x7f034c9c91b0 -128> max <integer_cst 0x7f034c9c9198 127>
            pointer_to_this <pointer_type 0x7f034c9c6f18>>
        public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality>
    var <parm_decl 0x7f034c9d5380 arg>
    def_stmt GIMPLE_NOP
    version 5
    ptr-info 0x7f034c9f1138>
trace fucntion name:memcpy 

 ================== trace ================== 
trace fucntion free:0 

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7f034cea4990
    type <pointer_type 0x7f034c9c6f18
        type <integer_type 0x7f034c9c6e70 char readonly public string-flag QI
            size <integer_cst 0x7f034ce9ccd8 constant 8>
            unit size <integer_cst 0x7f034ce9ccf0 constant 1>
            align 8 symtab 0 alias set -1 canonical type 0x7f034ceb03f0 precision 8 min <integer_cst 0x7f034c9c91b0 -128> max <integer_cst 0x7f034c9c9198 127>
            pointer_to_this <pointer_type 0x7f034c9c6f18>>
        public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality>
    var <parm_decl 0x7f034c9d5380 arg>
    def_stmt GIMPLE_NOP
    version 5
    ptr-info 0x7f034c9f1138>

 ================== Start Use after free Check ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:0 [0m

======================================================================

======================================================================
[40;31m    no free stmt possible memory leak [0m

======================================================================
[40;33m =======POP node_fun stack:concat========= [0m
[40;44m =======node_fun:main========= [0m
[40;44m fucntion collect path  [0m
[40;44m =======print_function_path main  function_call count: 13 level :0========  [0m
[40;44m =======print_function_type 0  ========  [0m
[40;42m =======pre add _ fucntion:__printf_chk========= [0m
[40;33m =======POP node_fun stack:__printf_chk========= [0m
[40;42m =======pre add _ fucntion:concat========= [0m
[40;44m =======print_function_type 2  ========  [0m
[40;44m =======print_function_path concat  function_call count: 3 level :1========  [0m
[40;44m =======print_function_type 2  ========  [0m
[40;42m =======pre add _ fucntion:memcpy========= [0m
[40;33m =======POP node_fun stack:memcpy========= [0m
[40;42m =======pre add _ fucntion:strlen========= [0m
[40;33m =======POP node_fun stack:strlen========= [0m
[40;42m =======pre add _ fucntion:malloc========= [0m
[40;33m =======POP node_fun stack:malloc========= [0m
[40;42m =======pre_check_funciton:concat========= [0m
[40;42m =======start_check_funciton:concat========= [0m

dot graph START

======================================================================
 <ssa_name 0x7f034cea4900
    type <pointer_type 0x7f034c9c65e8
        type <integer_type 0x7f034c9c6dc8 char public string-flag QI
            size <integer_cst 0x7f034ce9ccd8 constant 8>
            unit size <integer_cst 0x7f034ce9ccf0 constant 1>
            align 8 symtab 0 alias set -1 canonical type 0x7f034ceb03f0 precision 8 min <integer_cst 0x7f034c9c91b0 -128> max <integer_cst 0x7f034c9c9198 127>
            pointer_to_this <pointer_type 0x7f034c9c65e8>>
        public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality context <translation_unit_decl 0x7f034cea7168 test.c>
        pointer_to_this <pointer_type 0x7f034c9d2bd0>>
    var <var_decl 0x7f034dc31d80 newstr>
    def_stmt newstr_3 = malloc (1);
    version 3
    ptr-info 0x7f034c9f1108>
# .MEM_9 = VDEF <.MEM_8(D)>
newstr_3 = malloc (1);

 ================== trace ptable================== 
trace fucntion name:malloc 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr---malloc-----
this Reserved word function ------malloc-----
 
 Start check Pointer Collect  

======================================================================
_15 = newstr_3;
In function â€˜mainâ€™:
lto1: warning: use location
end_12 = newstr_3 + length_11;
test.c:63:6: warning: use location
  end += length;
      ^
*end_12 = 0;
test.c:65:7: warning: use location
  *end = '\000';
       ^
memcpy (newstr_3, arg_5(D), length_11);
test.c:62:2: warning: use location
  memcpy (end, arg, length);
  ^
this stmt is child function---memcpy-----

 ================== trace ================== 
 <ssa_name 0x7f034cea4900
    type <pointer_type 0x7f034c9c65e8
        type <integer_type 0x7f034c9c6dc8 char public string-flag QI
            size <integer_cst 0x7f034ce9ccd8 constant 8>
            unit size <integer_cst 0x7f034ce9ccf0 constant 1>
            align 8 symtab 0 alias set -1 canonical type 0x7f034ceb03f0 precision 8 min <integer_cst 0x7f034c9c91b0 -128> max <integer_cst 0x7f034c9c9198 127>
            pointer_to_this <pointer_type 0x7f034c9c65e8>>
        public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality context <translation_unit_decl 0x7f034cea7168 test.c>
        pointer_to_this <pointer_type 0x7f034c9d2bd0>>
    var <var_decl 0x7f034dc31d80 newstr>
    def_stmt newstr_3 = malloc (1);
    version 3
    ptr-info 0x7f034c9f1108>
trace fucntion name:memcpy 

 ================== trace ================== 
trace fucntion free:0 
return newstr_3;
test.c:81:10: warning: use location
   return newstr;
          ^
_7 = newstr_3;
test.c:81:10: warning: use location
newstr_3 = malloc (1);
test.c:76:10: warning: use location
   newstr = XNEWVEC (char, 1);
          ^
this stmt is child function---malloc-----

 ================== trace ================== 
 <ssa_name 0x7f034cea4900
    type <pointer_type 0x7f034c9c65e8
        type <integer_type 0x7f034c9c6dc8 char public string-flag QI
            size <integer_cst 0x7f034ce9ccd8 constant 8>
            unit size <integer_cst 0x7f034ce9ccf0 constant 1>
            align 8 symtab 0 alias set -1 canonical type 0x7f034ceb03f0 precision 8 min <integer_cst 0x7f034c9c91b0 -128> max <integer_cst 0x7f034c9c9198 127>
            pointer_to_this <pointer_type 0x7f034c9c65e8>>
        public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality context <translation_unit_decl 0x7f034cea7168 test.c>
        pointer_to_this <pointer_type 0x7f034c9d2bd0>>
    var <var_decl 0x7f034dc31d80 newstr>
    def_stmt newstr_3 = malloc (1);
    version 3
    ptr-info 0x7f034c9f1108>
trace fucntion name:malloc 

 ================== trace ================== 
trace fucntion free:0 

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7f034cea4900
    type <pointer_type 0x7f034c9c65e8
        type <integer_type 0x7f034c9c6dc8 char public string-flag QI
            size <integer_cst 0x7f034ce9ccd8 constant 8>
            unit size <integer_cst 0x7f034ce9ccf0 constant 1>
            align 8 symtab 0 alias set -1 canonical type 0x7f034ceb03f0 precision 8 min <integer_cst 0x7f034c9c91b0 -128> max <integer_cst 0x7f034c9c9198 127>
            pointer_to_this <pointer_type 0x7f034c9c65e8>>
        public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality context <translation_unit_decl 0x7f034cea7168 test.c>
        pointer_to_this <pointer_type 0x7f034c9d2bd0>>
    var <var_decl 0x7f034dc31d80 newstr>
    def_stmt newstr_3 = malloc (1);
    version 3
    ptr-info 0x7f034c9f1108>

 ================== Start Use after free Check ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:0 [0m

======================================================================

======================================================================
[40;31m    no free stmt possible memory leak [0m

======================================================================

dot graph START

======================================================================

 ================== collect possiable invalid ================== 
 <integer_cst 0x7f034c9c9e40 type <integer_type 0x7f034ceb07e0 long unsigned int> constant 1>

dot graph START

======================================================================
 <ssa_name 0x7f034cea4990
    type <pointer_type 0x7f034c9c6f18
        type <integer_type 0x7f034c9c6e70 char readonly public string-flag QI
            size <integer_cst 0x7f034ce9ccd8 constant 8>
            unit size <integer_cst 0x7f034ce9ccf0 constant 1>
            align 8 symtab 0 alias set -1 canonical type 0x7f034ceb03f0 precision 8 min <integer_cst 0x7f034c9c91b0 -128> max <integer_cst 0x7f034c9c9198 127>
            pointer_to_this <pointer_type 0x7f034c9c6f18>>
        public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality>
    var <parm_decl 0x7f034c9d5380 arg>
    def_stmt GIMPLE_NOP
    version 5
    ptr-info 0x7f034c9f1138>
GIMPLE_NOP

 ================== trace ptable================== 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr--------
this other function -----------
 
 Start check Pointer Collect  

======================================================================
length_11 = strlen (arg_5(D));
test.c:61:16: warning: use location
  unsigned long length = strlen (arg);
                ^
this stmt is child function---strlen-----

 ================== trace ================== 
 <ssa_name 0x7f034cea4990
    type <pointer_type 0x7f034c9c6f18
        type <integer_type 0x7f034c9c6e70 char readonly public string-flag QI
            size <integer_cst 0x7f034ce9ccd8 constant 8>
            unit size <integer_cst 0x7f034ce9ccf0 constant 1>
            align 8 symtab 0 alias set -1 canonical type 0x7f034ceb03f0 precision 8 min <integer_cst 0x7f034c9c91b0 -128> max <integer_cst 0x7f034c9c9198 127>
            pointer_to_this <pointer_type 0x7f034c9c6f18>>
        public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality>
    var <parm_decl 0x7f034c9d5380 arg>
    def_stmt GIMPLE_NOP
    version 5
    ptr-info 0x7f034c9f1138>
trace fucntion name:strlen 

 ================== trace ================== 
trace fucntion free:0 
end_12 = newstr_3 + length_11;
test.c:63:6: warning: use location
  end += length;
      ^
*end_12 = 0;
test.c:65:7: warning: use location
  *end = '\000';
       ^
memcpy (newstr_3, arg_5(D), length_11);
test.c:62:2: warning: use location
  memcpy (end, arg, length);
  ^
this stmt is child function---memcpy-----

 ================== trace ================== 
 <ssa_name 0x7f034cea4990
    type <pointer_type 0x7f034c9c6f18
        type <integer_type 0x7f034c9c6e70 char readonly public string-flag QI
            size <integer_cst 0x7f034ce9ccd8 constant 8>
            unit size <integer_cst 0x7f034ce9ccf0 constant 1>
            align 8 symtab 0 alias set -1 canonical type 0x7f034ceb03f0 precision 8 min <integer_cst 0x7f034c9c91b0 -128> max <integer_cst 0x7f034c9c9198 127>
            pointer_to_this <pointer_type 0x7f034c9c6f18>>
        public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality>
    var <parm_decl 0x7f034c9d5380 arg>
    def_stmt GIMPLE_NOP
    version 5
    ptr-info 0x7f034c9f1138>
trace fucntion name:memcpy 

 ================== trace ================== 
trace fucntion free:0 

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7f034cea4990
    type <pointer_type 0x7f034c9c6f18
        type <integer_type 0x7f034c9c6e70 char readonly public string-flag QI
            size <integer_cst 0x7f034ce9ccd8 constant 8>
            unit size <integer_cst 0x7f034ce9ccf0 constant 1>
            align 8 symtab 0 alias set -1 canonical type 0x7f034ceb03f0 precision 8 min <integer_cst 0x7f034c9c91b0 -128> max <integer_cst 0x7f034c9c9198 127>
            pointer_to_this <pointer_type 0x7f034c9c6f18>>
        public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality>
    var <parm_decl 0x7f034c9d5380 arg>
    def_stmt GIMPLE_NOP
    version 5
    ptr-info 0x7f034c9f1138>

 ================== Start Use after free Check ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:0 [0m

======================================================================

======================================================================
[40;31m    no free stmt possible memory leak [0m

======================================================================
[40;33m =======POP node_fun stack:concat========= [0m
[40;42m =======pre add _ fucntion:free========= [0m
[40;33m =======POP node_fun stack:free========= [0m
[40;42m =======pre add _ fucntion:setlocale========= [0m
[40;33m =======POP node_fun stack:setlocale========= [0m
[40;42m =======pre add _ fucntion:__fprintf_chk========= [0m
[40;33m =======POP node_fun stack:__fprintf_chk========= [0m
[40;42m =======pre add _ fucntion:__mbstowcs_alias========= [0m
[40;33m =======POP node_fun stack:__mbstowcs_alias========= [0m
[40;42m =======pre add _ fucntion:__mbstowcs_chk_warn========= [0m
[40;33m =======POP node_fun stack:__mbstowcs_chk_warn========= [0m
[40;42m =======pre add _ fucntion:__builtin_object_size========= [0m
[40;33m =======POP node_fun stack:__builtin_object_size========= [0m
[40;42m =======pre add _ fucntion:__builtin_constant_p========= [0m
[40;33m =======POP node_fun stack:__builtin_constant_p========= [0m
[40;42m =======pre add _ fucntion:malloc========= [0m
[40;33m =======POP node_fun stack:malloc========= [0m
[40;42m =======pre add _ fucntion:strlen========= [0m
[40;33m =======POP node_fun stack:strlen========= [0m
[40;42m =======pre add _ fucntion:strdup========= [0m
[40;33m =======POP node_fun stack:strdup========= [0m
[40;42m =======pre add _ fucntion:memcpy========= [0m
[40;33m =======POP node_fun stack:memcpy========= [0m
[40;42m =======pre_check_funciton:main========= [0m
[40;42m =======start_check_funciton:main========= [0m

dot graph START

======================================================================
 <ssa_name 0x7f034c9f3900
    type <pointer_type 0x7f034c9c65e8
        type <integer_type 0x7f034c9c6dc8 char public string-flag QI
            size <integer_cst 0x7f034ce9ccd8 constant 8>
            unit size <integer_cst 0x7f034ce9ccf0 constant 1>
            align 8 symtab 0 alias set -1 canonical type 0x7f034ceb03f0 precision 8 min <integer_cst 0x7f034c9c91b0 -128> max <integer_cst 0x7f034c9c9198 127>
            pointer_to_this <pointer_type 0x7f034c9c65e8>>
        public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality context <translation_unit_decl 0x7f034cea7168 test.c>
        pointer_to_this <pointer_type 0x7f034c9d2bd0>>
    var <var_decl 0x7f034c9efa20 dirname>
    def_stmt dirname_52 = malloc (_51);
    version 52
    ptr-info 0x7f034c9f12d0>
# .MEM_92 = VDEF <.MEM_5(D)>
dirname_52 = malloc (_51);

 ================== trace ptable================== 
trace fucntion name:malloc 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr---malloc-----
this Reserved word function ------malloc-----
 
 Start check Pointer Collect  

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
_76 = PHI <0B(9), dirname_52(14)>
bb index := 15
# VUSE <.MEM_8>
return 0;
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
_76 = PHI <0B(9), dirname_52(14)>
bb index := 15
# VUSE <.MEM_8>
return 0;
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================
_76 = PHI <0B(9), dirname_52(14)>
lto1: warning: use location
this stmt have mutiple branch --------

======================================================================
[40;31m    branch possiable have return or exit  [0m
_96 = _76;
bb index := 15
# VUSE <.MEM_8>
return 0;
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
_96 = _76;
bb index := 15
# VUSE <.MEM_8>
return 0;
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================
_96 = _76;
lto1: warning: use location

======================================================================
[40;31m    branch possiable have return or exit  [0m
_10 = _96;
bb index := 15
# VUSE <.MEM_8>
return 0;
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
_10 = _96;
bb index := 15
# VUSE <.MEM_8>
return 0;
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================
_10 = _96;
test.c:109:22: warning: use location
   progname = concat (ldirname (python_libdir), "bin");
                      ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_97 = VDEF <.MEM_87>
progname_11 = concat (_10, "bin");
bb index := 15
# VUSE <.MEM_8>
return 0;
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_97 = VDEF <.MEM_87>
progname_11 = concat (_10, "bin");
bb index := 15
# VUSE <.MEM_8>
return 0;
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================
progname_11 = concat (_10, "bin");
test.c:109:12: warning: use location
   progname = concat (ldirname (python_libdir), "bin");
            ^
this stmt is child function---concat-----

 ================== trace ================== 
 <ssa_name 0x7f034c9f3900
    type <pointer_type 0x7f034c9c65e8
        type <integer_type 0x7f034c9c6dc8 char public string-flag QI
            size <integer_cst 0x7f034ce9ccd8 constant 8>
            unit size <integer_cst 0x7f034ce9ccf0 constant 1>
            align 8 symtab 0 alias set -1 canonical type 0x7f034ceb03f0 precision 8 min <integer_cst 0x7f034c9c91b0 -128> max <integer_cst 0x7f034c9c9198 127>
            pointer_to_this <pointer_type 0x7f034c9c65e8>>
        public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality context <translation_unit_decl 0x7f034cea7168 test.c>
        pointer_to_this <pointer_type 0x7f034c9d2bd0>>
    var <var_decl 0x7f034c9efa20 dirname>
    def_stmt dirname_52 = malloc (_51);
    version 52
    ptr-info 0x7f034c9f12d0>
trace fucntion name:concat 
[40;44m =======trace_function_path concat  function_call count: 3 level :0========  [0m
[40;42m =======pre add _ fucntion:memcpy========= [0m
[40;46m =======add node_fun stack:memcpy========= [0m
[40;42m =======pre add _ fucntion:strlen========= [0m
[40;46m =======add node_fun stack:strlen========= [0m
[40;42m =======pre add _ fucntion:malloc========= [0m
[40;46m =======add node_fun stack:malloc========= [0m

 ================== trace ================== 
trace fucntion free:0 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# VUSE <.MEM_100>
progsize_16 = strlen (progname_11);
bb index := 15
# VUSE <.MEM_8>
return 0;
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# VUSE <.MEM_100>
progsize_16 = strlen (progname_11);
bb index := 15
# VUSE <.MEM_8>
return 0;
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================
progsize_16 = strlen (progname_11);
test.c:112:12: warning: use location
   progsize = strlen (progname);
            ^
this stmt is child function---strlen-----

 ================== trace ================== 
 <ssa_name 0x7f034c9f3900
    type <pointer_type 0x7f034c9c65e8
        type <integer_type 0x7f034c9c6dc8 char public string-flag QI
            size <integer_cst 0x7f034ce9ccd8 constant 8>
            unit size <integer_cst 0x7f034ce9ccf0 constant 1>
            align 8 symtab 0 alias set -1 canonical type 0x7f034ceb03f0 precision 8 min <integer_cst 0x7f034c9c91b0 -128> max <integer_cst 0x7f034c9c9198 127>
            pointer_to_this <pointer_type 0x7f034c9c65e8>>
        public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality context <translation_unit_decl 0x7f034cea7168 test.c>
        pointer_to_this <pointer_type 0x7f034c9d2bd0>>
    var <var_decl 0x7f034c9efa20 dirname>
    def_stmt dirname_52 = malloc (_51);
    version 52
    ptr-info 0x7f034c9f12d0>
trace fucntion name:strlen 

 ================== trace ================== 
trace fucntion free:0 
_23 = progsize_16 + 1;
test.c:120:11: warning: use location
   count = mbstowcs (progname_copy, progname, progsize + 1);
           ^
_25 = __builtin_constant_p (_23);
this stmt is child function---__builtin_constant_p-----

 ================== trace ================== 
 <ssa_name 0x7f034c9f3900
    type <pointer_type 0x7f034c9c65e8
        type <integer_type 0x7f034c9c6dc8 char public string-flag QI
            size <integer_cst 0x7f034ce9ccd8 constant 8>
            unit size <integer_cst 0x7f034ce9ccf0 constant 1>
            align 8 symtab 0 alias set -1 canonical type 0x7f034ceb03f0 precision 8 min <integer_cst 0x7f034c9c91b0 -128> max <integer_cst 0x7f034c9c9198 127>
            pointer_to_this <pointer_type 0x7f034c9c65e8>>
        public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality context <translation_unit_decl 0x7f034cea7168 test.c>
        pointer_to_this <pointer_type 0x7f034c9d2bd0>>
    var <var_decl 0x7f034c9efa20 dirname>
    def_stmt dirname_52 = malloc (_51);
    version 52
    ptr-info 0x7f034c9f12d0>
trace fucntion name:__builtin_constant_p 

 ================== trace ================== 
trace fucntion free:0 
if (_25 == 0)
if (_25 == 0)

 ================== find cond branch ================= 
Cond in fucntion main basic block 18
 ================== possible direct basic block ================= 
from main basic block 19
 ================== possible direct basic block ================= 
from main basic block 20
 ================== warring ================== 
[40;35m    need check this branch possible have return or exit stmt [0m

 ================== warring ================== 

 ================== find cond branch ================= 
_34 = __mbstowcs_alias (progname_copy_19, progname_11, _23);
this stmt is child function---__mbstowcs_alias-----

 ================== trace ================== 
 <ssa_name 0x7f034c9f3900
    type <pointer_type 0x7f034c9c65e8
        type <integer_type 0x7f034c9c6dc8 char public string-flag QI
            size <integer_cst 0x7f034ce9ccd8 constant 8>
            unit size <integer_cst 0x7f034ce9ccf0 constant 1>
            align 8 symtab 0 alias set -1 canonical type 0x7f034ceb03f0 precision 8 min <integer_cst 0x7f034c9c91b0 -128> max <integer_cst 0x7f034c9c9198 127>
            pointer_to_this <pointer_type 0x7f034c9c65e8>>
        public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality context <translation_unit_decl 0x7f034cea7168 test.c>
        pointer_to_this <pointer_type 0x7f034c9d2bd0>>
    var <var_decl 0x7f034c9efa20 dirname>
    def_stmt dirname_52 = malloc (_51);
    version 52
    ptr-info 0x7f034c9f12d0>
trace fucntion name:__mbstowcs_alias 

 ================== trace ================== 
trace fucntion free:0 
_35 = PHI <_28(19), _33(21), _34(22)>
lto1: warning: use location
this stmt have mutiple branch --------
if (_35 == 18446744073709551615)
test.c:121:6: warning: use location
   if (count == (size_t) -1)
      ^
if (_35 == 18446744073709551615)

 ================== find cond branch ================= 
test.c:121:6: warning: use location
Cond in fucntion main basic block 23
 ================== possible direct basic block ================= 
from main basic block 24
 ================== possible direct basic block ================= 
from main basic block 25
 ================== warring ================== 
[40;35m    need check this branch possible have return or exit stmt [0m

 ================== warring ================== 

 ================== find cond branch ================= 
_31 = __builtin_object_size (progname_copy_19, 1);
this stmt is child function---__builtin_object_size-----

 ================== trace ================== 
 <ssa_name 0x7f034c9f3900
    type <pointer_type 0x7f034c9c65e8
        type <integer_type 0x7f034c9c6dc8 char public string-flag QI
            size <integer_cst 0x7f034ce9ccd8 constant 8>
            unit size <integer_cst 0x7f034ce9ccf0 constant 1>
            align 8 symtab 0 alias set -1 canonical type 0x7f034ceb03f0 precision 8 min <integer_cst 0x7f034c9c91b0 -128> max <integer_cst 0x7f034c9c9198 127>
            pointer_to_this <pointer_type 0x7f034c9c65e8>>
        public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality context <translation_unit_decl 0x7f034cea7168 test.c>
        pointer_to_this <pointer_type 0x7f034c9d2bd0>>
    var <var_decl 0x7f034c9efa20 dirname>
    def_stmt dirname_52 = malloc (_51);
    version 52
    ptr-info 0x7f034c9f12d0>
trace fucntion name:__builtin_object_size 

 ================== trace ================== 
trace fucntion free:0 
_29 = __builtin_object_size (progname_copy_19, 1);
this stmt is child function---__builtin_object_size-----

 ================== trace ================== 
 <ssa_name 0x7f034c9f3900
    type <pointer_type 0x7f034c9c65e8
        type <integer_type 0x7f034c9c6dc8 char public string-flag QI
            size <integer_cst 0x7f034ce9ccd8 constant 8>
            unit size <integer_cst 0x7f034ce9ccf0 constant 1>
            align 8 symtab 0 alias set -1 canonical type 0x7f034ceb03f0 precision 8 min <integer_cst 0x7f034c9c91b0 -128> max <integer_cst 0x7f034c9c9198 127>
            pointer_to_this <pointer_type 0x7f034c9c65e8>>
        public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality context <translation_unit_decl 0x7f034cea7168 test.c>
        pointer_to_this <pointer_type 0x7f034c9d2bd0>>
    var <var_decl 0x7f034c9efa20 dirname>
    def_stmt dirname_52 = malloc (_51);
    version 52
    ptr-info 0x7f034c9f12d0>
trace fucntion name:__builtin_object_size 

 ================== trace ================== 
trace fucntion free:0 
_30 = _29 / 4;
_26 = __builtin_object_size (progname_copy_19, 1);
this stmt is child function---__builtin_object_size-----

 ================== trace ================== 
 <ssa_name 0x7f034c9f3900
    type <pointer_type 0x7f034c9c65e8
        type <integer_type 0x7f034c9c6dc8 char public string-flag QI
            size <integer_cst 0x7f034ce9ccd8 constant 8>
            unit size <integer_cst 0x7f034ce9ccf0 constant 1>
            align 8 symtab 0 alias set -1 canonical type 0x7f034ceb03f0 precision 8 min <integer_cst 0x7f034c9c91b0 -128> max <integer_cst 0x7f034c9c9198 127>
            pointer_to_this <pointer_type 0x7f034c9c65e8>>
        public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality context <translation_unit_decl 0x7f034cea7168 test.c>
        pointer_to_this <pointer_type 0x7f034c9d2bd0>>
    var <var_decl 0x7f034c9efa20 dirname>
    def_stmt dirname_52 = malloc (_51);
    version 52
    ptr-info 0x7f034c9f12d0>
trace fucntion name:__builtin_object_size 

 ================== trace ================== 
trace fucntion free:0 
_27 = _26 / 4;
_28 = __mbstowcs_chk (progname_copy_19, progname_11, _23, _27);
this stmt is child function---__mbstowcs_chk-----

 ================== trace ================== 
 <ssa_name 0x7f034c9f3900
    type <pointer_type 0x7f034c9c65e8
        type <integer_type 0x7f034c9c6dc8 char public string-flag QI
            size <integer_cst 0x7f034ce9ccd8 constant 8>
            unit size <integer_cst 0x7f034ce9ccf0 constant 1>
            align 8 symtab 0 alias set -1 canonical type 0x7f034ceb03f0 precision 8 min <integer_cst 0x7f034c9c91b0 -128> max <integer_cst 0x7f034c9c9198 127>
            pointer_to_this <pointer_type 0x7f034c9c65e8>>
        public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality context <translation_unit_decl 0x7f034cea7168 test.c>
        pointer_to_this <pointer_type 0x7f034c9d2bd0>>
    var <var_decl 0x7f034c9efa20 dirname>
    def_stmt dirname_52 = malloc (_51);
    version 52
    ptr-info 0x7f034c9f12d0>
trace fucntion name:__mbstowcs_chk 

 ================== trace ================== 
trace fucntion free:0 
_24 = __builtin_object_size (progname_copy_19, 1);
this stmt is child function---__builtin_object_size-----

 ================== trace ================== 
 <ssa_name 0x7f034c9f3900
    type <pointer_type 0x7f034c9c65e8
        type <integer_type 0x7f034c9c6dc8 char public string-flag QI
            size <integer_cst 0x7f034ce9ccd8 constant 8>
            unit size <integer_cst 0x7f034ce9ccf0 constant 1>
            align 8 symtab 0 alias set -1 canonical type 0x7f034ceb03f0 precision 8 min <integer_cst 0x7f034c9c91b0 -128> max <integer_cst 0x7f034c9c9198 127>
            pointer_to_this <pointer_type 0x7f034c9c65e8>>
        public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality context <translation_unit_decl 0x7f034cea7168 test.c>
        pointer_to_this <pointer_type 0x7f034c9d2bd0>>
    var <var_decl 0x7f034c9efa20 dirname>
    def_stmt dirname_52 = malloc (_51);
    version 52
    ptr-info 0x7f034c9f12d0>
trace fucntion name:__builtin_object_size 

 ================== trace ================== 
trace fucntion free:0 
if (_24 != 18446744073709551615)
if (_24 != 18446744073709551615)

 ================== find cond branch ================= 
Cond in fucntion main basic block 17
 ================== possible direct basic block ================= 
from main basic block 18
 ================== possible direct basic block ================= 
from main basic block 22
 ================== warring ================== 
[40;35m    need check this branch possible have return or exit stmt [0m

 ================== warring ================== 

 ================== find cond branch ================= 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_109 = VDEF <.MEM_108>
free (progname_copy_19);
bb index := 25
# VUSE <.MEM_8>
return 0;
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 25 ,possiable got to succ := 26

======================================================================
free (progname_copy_19);
test.c:135:2: warning: use location
  xfree(progname_copy);
  ^
this stmt is child function---free-----

 ================== find ================== 
free (progname_copy_19);
test.c:135:2: warning: use location
[40;32m    HAS FREE STMT count:1 name:free [0m

 ================== find ================== 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_111 = VDEF <.MEM_110>
free (progname_copy_19);
bb index := 24
# VUSE <.MEM_8>
return 0;
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 24 ,possiable got to succ := 26

======================================================================
free (progname_copy_19);
test.c:124:4: warning: use location
    xfree(progname_copy);
    ^
this stmt is child function---free-----

 ================== find ================== 
free (progname_copy_19);
test.c:124:4: warning: use location
[40;32m    HAS FREE STMT count:2 name:free [0m

 ================== find ================== 
_33 = __mbstowcs_chk_warn (progname_copy_19, progname_11, _23, _32);
this stmt is child function---__mbstowcs_chk_warn-----

 ================== trace ================== 
 <ssa_name 0x7f034c9f3900
    type <pointer_type 0x7f034c9c65e8
        type <integer_type 0x7f034c9c6dc8 char public string-flag QI
            size <integer_cst 0x7f034ce9ccd8 constant 8>
            unit size <integer_cst 0x7f034ce9ccf0 constant 1>
            align 8 symtab 0 alias set -1 canonical type 0x7f034ceb03f0 precision 8 min <integer_cst 0x7f034c9c91b0 -128> max <integer_cst 0x7f034c9c9198 127>
            pointer_to_this <pointer_type 0x7f034c9c65e8>>
        public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality context <translation_unit_decl 0x7f034cea7168 test.c>
        pointer_to_this <pointer_type 0x7f034c9d2bd0>>
    var <var_decl 0x7f034c9efa20 dirname>
    def_stmt dirname_52 = malloc (_51);
    version 52
    ptr-info 0x7f034c9f12d0>
trace fucntion name:__mbstowcs_chk_warn 

 ================== trace ================== 
trace fucntion free:2 

======================================================================
[40;31m    branch possiable have return or exit  [0m
if (progname_copy_19 == 0B)
bb index := 15
# VUSE <.MEM_8>
return 0;
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
if (progname_copy_19 == 0B)
bb index := 15
# VUSE <.MEM_8>
return 0;
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================
if (progname_copy_19 == 0B)
test.c:114:6: warning: use location
   if (!progname_copy)
      ^
if (progname_copy_19 == 0B)

 ================== find cond branch ================= 
test.c:114:6: warning: use location
Cond in fucntion main basic block 15
 ================== possible direct basic block ================= 
from main basic block 16
 ================== possible direct basic block ================= 
from main basic block 17
 ================== warring ================== 
[40;35m    need check this branch possible have return or exit stmt [0m

 ================== warring ================== 

 ================== find cond branch ================= 

======================================================================
[40;31m    branch possiable have return or exit  [0m
_17 = progsize_16 + 1;
bb index := 15
# VUSE <.MEM_8>
return 0;
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
_17 = progsize_16 + 1;
bb index := 15
# VUSE <.MEM_8>
return 0;
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================
_17 = progsize_16 + 1;
test.c:113:31: warning: use location
   progname_copy = (wchar_t *) PyMem_Malloc ((progsize + 1) * sizeof (wchar_t));
                               ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
_18 = _17 * 4;
bb index := 15
# VUSE <.MEM_8>
return 0;
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
_18 = _17 * 4;
bb index := 15
# VUSE <.MEM_8>
return 0;
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================
_18 = _17 * 4;
test.c:113:31: warning: use location

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_101 = VDEF <.MEM_100>
ret_41 = malloc (_18);
bb index := 15
# VUSE <.MEM_8>
return 0;
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_101 = VDEF <.MEM_100>
ret_41 = malloc (_18);
bb index := 15
# VUSE <.MEM_8>
return 0;
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================
ret_41 = malloc (_18);
test.c:86:8: warning: use location
  void *ret = malloc(size);
        ^
this stmt is child function---malloc-----

 ================== trace ================== 
 <ssa_name 0x7f034c9f3900
    type <pointer_type 0x7f034c9c65e8
        type <integer_type 0x7f034c9c6dc8 char public string-flag QI
            size <integer_cst 0x7f034ce9ccd8 constant 8>
            unit size <integer_cst 0x7f034ce9ccf0 constant 1>
            align 8 symtab 0 alias set -1 canonical type 0x7f034ceb03f0 precision 8 min <integer_cst 0x7f034c9c91b0 -128> max <integer_cst 0x7f034c9c9198 127>
            pointer_to_this <pointer_type 0x7f034c9c65e8>>
        public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality context <translation_unit_decl 0x7f034cea7168 test.c>
        pointer_to_this <pointer_type 0x7f034c9d2bd0>>
    var <var_decl 0x7f034c9efa20 dirname>
    def_stmt dirname_52 = malloc (_51);
    version 52
    ptr-info 0x7f034c9f12d0>
trace fucntion name:malloc 

 ================== trace ================== 
trace fucntion free:2 

======================================================================
[40;31m    branch possiable have return or exit  [0m
_102 = ret_41;
bb index := 15
# VUSE <.MEM_8>
return 0;
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
_102 = ret_41;
bb index := 15
# VUSE <.MEM_8>
return 0;
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================
_102 = ret_41;
lto1: warning: use location

======================================================================
[40;31m    branch possiable have return or exit  [0m
_42 = ret_41;
bb index := 15
# VUSE <.MEM_8>
return 0;
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
_42 = ret_41;
bb index := 15
# VUSE <.MEM_8>
return 0;
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================
_42 = ret_41;
test.c:87:9: warning: use location
  return ret;
         ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
_75 = dirname_52;
bb index := 14
# VUSE <.MEM_8>
return 0;
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 14 ,possiable got to succ := 26

======================================================================
_75 = dirname_52;
test.c:53:10: warning: use location
   return dirname;
          ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
_74 = dirname_52 + _73;
bb index := 14
# VUSE <.MEM_8>
return 0;
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 14 ,possiable got to succ := 26

======================================================================
_74 = dirname_52 + _73;
test.c:52:10: warning: use location
   dirname[base - filename] = '\0';
          ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_95 = VDEF <.MEM_86>
*_74 = 0;
bb index := 14
# VUSE <.MEM_8>
return 0;
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 14 ,possiable got to succ := 26

======================================================================
*_74 = 0;
test.c:52:28: warning: use location
   dirname[base - filename] = '\0';
                            ^
_68 = dirname_52 + _67;
test.c:50:12: warning: use location
     dirname[base++ - filename] = '.';
            ^
*_68 = 46;
test.c:50:32: warning: use location
     dirname[base++ - filename] = '.';
                                ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_93 = VDEF <.MEM_92>
memcpy (dirname_52, _9, _56);
bb index := 10
# VUSE <.MEM_8>
return 0;
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 10 ,possiable got to succ := 26

======================================================================
memcpy (dirname_52, _9, _56);
test.c:44:3: warning: use location
   memcpy (dirname, filename, base - filename);
   ^
this stmt is child function---memcpy-----

 ================== trace ================== 
 <ssa_name 0x7f034c9f3900
    type <pointer_type 0x7f034c9c65e8
        type <integer_type 0x7f034c9c6dc8 char public string-flag QI
            size <integer_cst 0x7f034ce9ccd8 constant 8>
            unit size <integer_cst 0x7f034ce9ccf0 constant 1>
            align 8 symtab 0 alias set -1 canonical type 0x7f034ceb03f0 precision 8 min <integer_cst 0x7f034c9c91b0 -128> max <integer_cst 0x7f034c9c9198 127>
            pointer_to_this <pointer_type 0x7f034c9c65e8>>
        public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality context <translation_unit_decl 0x7f034cea7168 test.c>
        pointer_to_this <pointer_type 0x7f034c9d2bd0>>
    var <var_decl 0x7f034c9efa20 dirname>
    def_stmt dirname_52 = malloc (_51);
    version 52
    ptr-info 0x7f034c9f12d0>
trace fucntion name:memcpy 

 ================== trace ================== 
trace fucntion free:2 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_92 = VDEF <.MEM_5(D)>
dirname_52 = malloc (_51);
bb index := 10
# VUSE <.MEM_8>
return 0;
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 10 ,possiable got to succ := 26

======================================================================
dirname_52 = malloc (_51);
test.c:43:11: warning: use location
   dirname = (char *) xmalloc (base - filename + 2);         /* allocation site */
           ^
this stmt is child function---malloc-----

 ================== trace ================== 
 <ssa_name 0x7f034c9f3900
    type <pointer_type 0x7f034c9c65e8
        type <integer_type 0x7f034c9c6dc8 char public string-flag QI
            size <integer_cst 0x7f034ce9ccd8 constant 8>
            unit size <integer_cst 0x7f034ce9ccf0 constant 1>
            align 8 symtab 0 alias set -1 canonical type 0x7f034ceb03f0 precision 8 min <integer_cst 0x7f034c9c91b0 -128> max <integer_cst 0x7f034c9c9198 127>
            pointer_to_this <pointer_type 0x7f034c9c65e8>>
        public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality context <translation_unit_decl 0x7f034cea7168 test.c>
        pointer_to_this <pointer_type 0x7f034c9d2bd0>>
    var <var_decl 0x7f034c9efa20 dirname>
    def_stmt dirname_52 = malloc (_51);
    version 52
    ptr-info 0x7f034c9f12d0>
trace fucntion name:malloc 

 ================== trace ================== 
trace fucntion free:2 

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7f034c9f3900
    type <pointer_type 0x7f034c9c65e8
        type <integer_type 0x7f034c9c6dc8 char public string-flag QI
            size <integer_cst 0x7f034ce9ccd8 constant 8>
            unit size <integer_cst 0x7f034ce9ccf0 constant 1>
            align 8 symtab 0 alias set -1 canonical type 0x7f034ceb03f0 precision 8 min <integer_cst 0x7f034c9c91b0 -128> max <integer_cst 0x7f034c9c9198 127>
            pointer_to_this <pointer_type 0x7f034c9c65e8>>
        public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality context <translation_unit_decl 0x7f034cea7168 test.c>
        pointer_to_this <pointer_type 0x7f034c9d2bd0>>
    var <var_decl 0x7f034c9efa20 dirname>
    def_stmt dirname_52 = malloc (_51);
    version 52
    ptr-info 0x7f034c9f12d0>

 ================== Start Use after free Check ================== 

============================================================
# .MEM_109 = VDEF <.MEM_108>
free (progname_copy_19);
At top level:
test.c:135:2: warning: Use after free error!: free location 
  xfree(progname_copy);
  ^
_76 = PHI <0B(9), dirname_52(14)>
lto1: warning: use location

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
# .MEM_111 = VDEF <.MEM_110>
free (progname_copy_19);
test.c:124:4: warning: Use after free error!: free location 
    xfree(progname_copy);
    ^
_76 = PHI <0B(9), dirname_52(14)>
lto1: warning: use location

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
# .MEM_109 = VDEF <.MEM_108>
free (progname_copy_19);
test.c:135:2: warning: Use after free error!: free location 
  xfree(progname_copy);
  ^
_35 = PHI <_28(19), _33(21), _34(22)>
lto1: warning: use location

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
# .MEM_111 = VDEF <.MEM_110>
free (progname_copy_19);
test.c:124:4: warning: Use after free error!: free location 
    xfree(progname_copy);
    ^
_35 = PHI <_28(19), _33(21), _34(22)>
lto1: warning: use location

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:0 [0m

======================================================================

======================================================================
[40;31m  	possible double free :2 [0m

======================================================================

dot graph START

======================================================================
 <ssa_name 0x7f034c9eb0d8
    type <pointer_type 0x7f034c9c65e8
        type <integer_type 0x7f034c9c6dc8 char public string-flag QI
            size <integer_cst 0x7f034ce9ccd8 constant 8>
            unit size <integer_cst 0x7f034ce9ccf0 constant 1>
            align 8 symtab 0 alias set -1 canonical type 0x7f034ceb03f0 precision 8 min <integer_cst 0x7f034c9c91b0 -128> max <integer_cst 0x7f034c9c9198 127>
            pointer_to_this <pointer_type 0x7f034c9c65e8>>
        public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality context <translation_unit_decl 0x7f034cea7168 test.c>
        pointer_to_this <pointer_type 0x7f034c9d2bd0>>
    var <var_decl 0x7f034c9e9510 oldloc>
    def_stmt oldloc_15 = strdup (_14);
    version 15
    ptr-info 0x7f034c9f11f8>
# .MEM_99 = VDEF <.MEM_98>
oldloc_15 = strdup (_14);

 ================== trace ptable================== 
trace fucntion name:strdup 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr---strdup-----
this Reserved word function ------strdup-----
 
 Start check Pointer Collect  

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_99 = VDEF <.MEM_98>
oldloc_15 = strdup (_14);
bb index := 15
# VUSE <.MEM_8>
return 0;
In function â€˜mainâ€™:
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_99 = VDEF <.MEM_98>
oldloc_15 = strdup (_14);
bb index := 15
# VUSE <.MEM_8>
return 0;
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================
oldloc_15 = strdup (_14);
At top level:
test.c:110:10: warning: use location
   oldloc = xstrdup (setlocale (LC_ALL, NULL));
          ^
this stmt is child function---strdup-----

 ================== trace ================== 
 <ssa_name 0x7f034c9eb0d8
    type <pointer_type 0x7f034c9c65e8
        type <integer_type 0x7f034c9c6dc8 char public string-flag QI
            size <integer_cst 0x7f034ce9ccd8 constant 8>
            unit size <integer_cst 0x7f034ce9ccf0 constant 1>
            align 8 symtab 0 alias set -1 canonical type 0x7f034ceb03f0 precision 8 min <integer_cst 0x7f034c9c91b0 -128> max <integer_cst 0x7f034c9c9198 127>
            pointer_to_this <pointer_type 0x7f034c9c65e8>>
        public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality context <translation_unit_decl 0x7f034cea7168 test.c>
        pointer_to_this <pointer_type 0x7f034c9d2bd0>>
    var <var_decl 0x7f034c9e9510 oldloc>
    def_stmt oldloc_15 = strdup (_14);
    version 15
    ptr-info 0x7f034c9f11f8>
trace fucntion name:strdup 

 ================== trace ================== 
trace fucntion free:0 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_107 = VDEF <.MEM_106>
free (oldloc_15);
bb index := 25
# VUSE <.MEM_8>
return 0;
In function â€˜mainâ€™:
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 25 ,possiable got to succ := 26

======================================================================
free (oldloc_15);
At top level:
test.c:129:3: warning: use location
   xfree (oldloc);
   ^
this stmt is child function---free-----

 ================== find ================== 
free (oldloc_15);
test.c:129:3: warning: use location
[40;32m    HAS FREE STMT count:1 name:free [0m

 ================== find ================== 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_106 = VDEF <.MEM_88>
setlocale ("LC_ALL", oldloc_15);
bb index := 25
# VUSE <.MEM_8>
return 0;
In function â€˜mainâ€™:
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 25 ,possiable got to succ := 26

======================================================================
setlocale ("LC_ALL", oldloc_15);
At top level:
test.c:128:3: warning: use location
   setlocale (LC_ALL, oldloc);
   ^
this stmt is child function---setlocale-----

 ================== trace ================== 
 <ssa_name 0x7f034c9eb0d8
    type <pointer_type 0x7f034c9c65e8
        type <integer_type 0x7f034c9c6dc8 char public string-flag QI
            size <integer_cst 0x7f034ce9ccd8 constant 8>
            unit size <integer_cst 0x7f034ce9ccf0 constant 1>
            align 8 symtab 0 alias set -1 canonical type 0x7f034ceb03f0 precision 8 min <integer_cst 0x7f034c9c91b0 -128> max <integer_cst 0x7f034c9c9198 127>
            pointer_to_this <pointer_type 0x7f034c9c65e8>>
        public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality context <translation_unit_decl 0x7f034cea7168 test.c>
        pointer_to_this <pointer_type 0x7f034c9d2bd0>>
    var <var_decl 0x7f034c9e9510 oldloc>
    def_stmt oldloc_15 = strdup (_14);
    version 15
    ptr-info 0x7f034c9f11f8>
trace fucntion name:setlocale 

 ================== trace ================== 
trace fucntion free:1 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_110 = VDEF <.MEM_88>
free (oldloc_15);
bb index := 24
# VUSE <.MEM_8>
return 0;
In function â€˜mainâ€™:
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 24 ,possiable got to succ := 26

======================================================================
free (oldloc_15);
At top level:
test.c:123:7: warning: use location
       xfree (oldloc);
       ^
this stmt is child function---free-----

 ================== find ================== 
free (oldloc_15);
test.c:123:7: warning: use location
[40;32m    HAS FREE STMT count:2 name:free [0m

 ================== find ================== 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_113 = VDEF <.MEM_101>
free (oldloc_15);
bb index := 16
# VUSE <.MEM_8>
return 0;
In function â€˜mainâ€™:
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 16 ,possiable got to succ := 26

======================================================================
free (oldloc_15);
At top level:
test.c:116:7: warning: use location
       xfree (oldloc);
       ^
this stmt is child function---free-----

 ================== find ================== 
free (oldloc_15);
test.c:116:7: warning: use location
[40;32m    HAS FREE STMT count:3 name:free [0m

 ================== find ================== 

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7f034c9eb0d8
    type <pointer_type 0x7f034c9c65e8
        type <integer_type 0x7f034c9c6dc8 char public string-flag QI
            size <integer_cst 0x7f034ce9ccd8 constant 8>
            unit size <integer_cst 0x7f034ce9ccf0 constant 1>
            align 8 symtab 0 alias set -1 canonical type 0x7f034ceb03f0 precision 8 min <integer_cst 0x7f034c9c91b0 -128> max <integer_cst 0x7f034c9c9198 127>
            pointer_to_this <pointer_type 0x7f034c9c65e8>>
        public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality context <translation_unit_decl 0x7f034cea7168 test.c>
        pointer_to_this <pointer_type 0x7f034c9d2bd0>>
    var <var_decl 0x7f034c9e9510 oldloc>
    def_stmt oldloc_15 = strdup (_14);
    version 15
    ptr-info 0x7f034c9f11f8>
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_113 = VDEF <.MEM_101>
free (oldloc_15);
test.c:116:7: warning: use location
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_110 = VDEF <.MEM_88>
free (oldloc_15);
test.c:123:7: warning: use location
       xfree (oldloc);
       ^
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_107 = VDEF <.MEM_106>
free (oldloc_15);
test.c:129:3: warning: use location
   xfree (oldloc);
   ^

 ================== Start Use after free Check ================== 

============================================================
# .MEM_110 = VDEF <.MEM_88>
free (oldloc_15);
test.c:123:7: warning: Use after free error!: free location 
       xfree (oldloc);
       ^
# .MEM_106 = VDEF <.MEM_88>
setlocale ("LC_ALL", oldloc_15);
test.c:128:3: warning: use location
   setlocale (LC_ALL, oldloc);
   ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
# .MEM_113 = VDEF <.MEM_101>
free (oldloc_15);
test.c:116:7: warning: Use after free error!: free location 
       xfree (oldloc);
       ^
# .MEM_106 = VDEF <.MEM_88>
setlocale ("LC_ALL", oldloc_15);
test.c:128:3: warning: use location
   setlocale (LC_ALL, oldloc);
   ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_113 = VDEF <.MEM_101>
free (oldloc_15);
test.c:116:7: warning: Use after free error!: free location 
       xfree (oldloc);
       ^
# .MEM_106 = VDEF <.MEM_88>
setlocale ("LC_ALL", oldloc_15);
test.c:128:3: warning: use location
   setlocale (LC_ALL, oldloc);
   ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_110 = VDEF <.MEM_88>
free (oldloc_15);
test.c:123:7: warning: Use after free error!: free location 
       xfree (oldloc);
       ^
# .MEM_106 = VDEF <.MEM_88>
setlocale ("LC_ALL", oldloc_15);
test.c:128:3: warning: use location
   setlocale (LC_ALL, oldloc);
   ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:3 [0m

======================================================================

======================================================================
[40;31m  	possible double free :3 [0m

======================================================================

dot graph START

======================================================================
 <ssa_name 0x7f034c9eb9d8
    type <pointer_type 0x7f034ceb70a8
        type <void_type 0x7f034ceb0f18 void VOID
            align 8 symtab 0 alias set -1 structural equality
            pointer_to_this <pointer_type 0x7f034ceb70a8>>
        public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality
        pointer_to_this <pointer_type 0x7f034cebcbd0>>
    var <var_decl 0x7f034c9ef3f0 ret>
    def_stmt ret_41 = malloc (_18);
    version 41
    ptr-info 0x7f034c9f1258>
# .MEM_101 = VDEF <.MEM_100>
ret_41 = malloc (_18);

 ================== trace ptable================== 
trace fucntion name:malloc 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr---malloc-----
this Reserved word function ------malloc-----
 
 Start check Pointer Collect  

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
_102 = ret_41;
bb index := 15
# VUSE <.MEM_8>
return 0;
In function â€˜mainâ€™:
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
_102 = ret_41;
bb index := 15
# VUSE <.MEM_8>
return 0;
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================
_102 = ret_41;
At top level:
lto1: warning: use location

======================================================================
[40;31m    branch possiable have return or exit  [0m
progname_copy_19 = _102;
bb index := 15
# VUSE <.MEM_8>
return 0;
In function â€˜mainâ€™:
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
progname_copy_19 = _102;
bb index := 15
# VUSE <.MEM_8>
return 0;
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================
progname_copy_19 = _102;
At top level:
test.c:113:17: warning: use location
   progname_copy = (wchar_t *) PyMem_Malloc ((progsize + 1) * sizeof (wchar_t));
                 ^
_31 = __builtin_object_size (progname_copy_19, 1);
this stmt is child function---__builtin_object_size-----

 ================== trace ================== 
 <ssa_name 0x7f034c9eb9d8
    type <pointer_type 0x7f034ceb70a8
        type <void_type 0x7f034ceb0f18 void VOID
            align 8 symtab 0 alias set -1 structural equality
            pointer_to_this <pointer_type 0x7f034ceb70a8>>
        public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality
        pointer_to_this <pointer_type 0x7f034cebcbd0>>
    var <var_decl 0x7f034c9ef3f0 ret>
    def_stmt ret_41 = malloc (_18);
    version 41
    ptr-info 0x7f034c9f1258>
trace fucntion name:__builtin_object_size 

 ================== trace ================== 
trace fucntion free:0 
_29 = __builtin_object_size (progname_copy_19, 1);
this stmt is child function---__builtin_object_size-----

 ================== trace ================== 
 <ssa_name 0x7f034c9eb9d8
    type <pointer_type 0x7f034ceb70a8
        type <void_type 0x7f034ceb0f18 void VOID
            align 8 symtab 0 alias set -1 structural equality
            pointer_to_this <pointer_type 0x7f034ceb70a8>>
        public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality
        pointer_to_this <pointer_type 0x7f034cebcbd0>>
    var <var_decl 0x7f034c9ef3f0 ret>
    def_stmt ret_41 = malloc (_18);
    version 41
    ptr-info 0x7f034c9f1258>
trace fucntion name:__builtin_object_size 

 ================== trace ================== 
trace fucntion free:0 
_30 = _29 / 4;
_26 = __builtin_object_size (progname_copy_19, 1);
this stmt is child function---__builtin_object_size-----

 ================== trace ================== 
 <ssa_name 0x7f034c9eb9d8
    type <pointer_type 0x7f034ceb70a8
        type <void_type 0x7f034ceb0f18 void VOID
            align 8 symtab 0 alias set -1 structural equality
            pointer_to_this <pointer_type 0x7f034ceb70a8>>
        public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality
        pointer_to_this <pointer_type 0x7f034cebcbd0>>
    var <var_decl 0x7f034c9ef3f0 ret>
    def_stmt ret_41 = malloc (_18);
    version 41
    ptr-info 0x7f034c9f1258>
trace fucntion name:__builtin_object_size 

 ================== trace ================== 
trace fucntion free:0 
_27 = _26 / 4;
_28 = __mbstowcs_chk (progname_copy_19, progname_11, _23, _27);
this stmt is child function---__mbstowcs_chk-----

 ================== trace ================== 
 <ssa_name 0x7f034c9eb9d8
    type <pointer_type 0x7f034ceb70a8
        type <void_type 0x7f034ceb0f18 void VOID
            align 8 symtab 0 alias set -1 structural equality
            pointer_to_this <pointer_type 0x7f034ceb70a8>>
        public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality
        pointer_to_this <pointer_type 0x7f034cebcbd0>>
    var <var_decl 0x7f034c9ef3f0 ret>
    def_stmt ret_41 = malloc (_18);
    version 41
    ptr-info 0x7f034c9f1258>
trace fucntion name:__mbstowcs_chk 

 ================== trace ================== 
trace fucntion free:0 
_35 = PHI <_28(19), _33(21), _34(22)>
lto1: warning: use location
this stmt have mutiple branch --------
if (_35 == 18446744073709551615)
test.c:121:6: warning: use location
   if (count == (size_t) -1)
      ^
if (_35 == 18446744073709551615)

 ================== find cond branch ================= 
test.c:121:6: warning: use location
Cond in fucntion main basic block 23
 ================== possible direct basic block ================= 
from main basic block 24
 ================== possible direct basic block ================= 
from main basic block 25
 ================== warring ================== 
[40;35m    need check this branch possible have return or exit stmt [0m

 ================== warring ================== 

 ================== find cond branch ================= 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# VUSE <.MEM_100>
progsize_16 = strlen (progname_11);
bb index := 15
# VUSE <.MEM_8>
return 0;
In function â€˜mainâ€™:
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# VUSE <.MEM_100>
progsize_16 = strlen (progname_11);
bb index := 15
# VUSE <.MEM_8>
return 0;
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================
progsize_16 = strlen (progname_11);
At top level:
test.c:112:12: warning: use location
   progsize = strlen (progname);
            ^
this stmt is child function---strlen-----

 ================== trace ================== 
 <ssa_name 0x7f034c9eb9d8
    type <pointer_type 0x7f034ceb70a8
        type <void_type 0x7f034ceb0f18 void VOID
            align 8 symtab 0 alias set -1 structural equality
            pointer_to_this <pointer_type 0x7f034ceb70a8>>
        public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality
        pointer_to_this <pointer_type 0x7f034cebcbd0>>
    var <var_decl 0x7f034c9ef3f0 ret>
    def_stmt ret_41 = malloc (_18);
    version 41
    ptr-info 0x7f034c9f1258>
trace fucntion name:strlen 

 ================== trace ================== 
trace fucntion free:0 
_23 = progsize_16 + 1;
test.c:120:11: warning: use location
   count = mbstowcs (progname_copy, progname, progsize + 1);
           ^
_25 = __builtin_constant_p (_23);
this stmt is child function---__builtin_constant_p-----

 ================== trace ================== 
 <ssa_name 0x7f034c9eb9d8
    type <pointer_type 0x7f034ceb70a8
        type <void_type 0x7f034ceb0f18 void VOID
            align 8 symtab 0 alias set -1 structural equality
            pointer_to_this <pointer_type 0x7f034ceb70a8>>
        public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality
        pointer_to_this <pointer_type 0x7f034cebcbd0>>
    var <var_decl 0x7f034c9ef3f0 ret>
    def_stmt ret_41 = malloc (_18);
    version 41
    ptr-info 0x7f034c9f1258>
trace fucntion name:__builtin_constant_p 

 ================== trace ================== 
trace fucntion free:0 
if (_25 == 0)
if (_25 == 0)

 ================== find cond branch ================= 
Cond in fucntion main basic block 18
 ================== possible direct basic block ================= 
from main basic block 19
 ================== possible direct basic block ================= 
from main basic block 20
 ================== warring ================== 
[40;35m    need check this branch possible have return or exit stmt [0m

 ================== warring ================== 

 ================== find cond branch ================= 
_34 = __mbstowcs_alias (progname_copy_19, progname_11, _23);
this stmt is child function---__mbstowcs_alias-----

 ================== trace ================== 
 <ssa_name 0x7f034c9eb9d8
    type <pointer_type 0x7f034ceb70a8
        type <void_type 0x7f034ceb0f18 void VOID
            align 8 symtab 0 alias set -1 structural equality
            pointer_to_this <pointer_type 0x7f034ceb70a8>>
        public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality
        pointer_to_this <pointer_type 0x7f034cebcbd0>>
    var <var_decl 0x7f034c9ef3f0 ret>
    def_stmt ret_41 = malloc (_18);
    version 41
    ptr-info 0x7f034c9f1258>
trace fucntion name:__mbstowcs_alias 

 ================== trace ================== 
trace fucntion free:0 
_33 = __mbstowcs_chk_warn (progname_copy_19, progname_11, _23, _32);
this stmt is child function---__mbstowcs_chk_warn-----

 ================== trace ================== 
 <ssa_name 0x7f034c9eb9d8
    type <pointer_type 0x7f034ceb70a8
        type <void_type 0x7f034ceb0f18 void VOID
            align 8 symtab 0 alias set -1 structural equality
            pointer_to_this <pointer_type 0x7f034ceb70a8>>
        public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality
        pointer_to_this <pointer_type 0x7f034cebcbd0>>
    var <var_decl 0x7f034c9ef3f0 ret>
    def_stmt ret_41 = malloc (_18);
    version 41
    ptr-info 0x7f034c9f1258>
trace fucntion name:__mbstowcs_chk_warn 

 ================== trace ================== 
trace fucntion free:0 

======================================================================
[40;31m    branch possiable have return or exit  [0m
_17 = progsize_16 + 1;
bb index := 15
# VUSE <.MEM_8>
return 0;
In function â€˜mainâ€™:
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
_17 = progsize_16 + 1;
bb index := 15
# VUSE <.MEM_8>
return 0;
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================
_17 = progsize_16 + 1;
At top level:
test.c:113:31: warning: use location
   progname_copy = (wchar_t *) PyMem_Malloc ((progsize + 1) * sizeof (wchar_t));
                               ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
_18 = _17 * 4;
bb index := 15
# VUSE <.MEM_8>
return 0;
In function â€˜mainâ€™:
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
_18 = _17 * 4;
bb index := 15
# VUSE <.MEM_8>
return 0;
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================
_18 = _17 * 4;
At top level:
test.c:113:31: warning: use location

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_101 = VDEF <.MEM_100>
ret_41 = malloc (_18);
bb index := 15
# VUSE <.MEM_8>
return 0;
In function â€˜mainâ€™:
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_101 = VDEF <.MEM_100>
ret_41 = malloc (_18);
bb index := 15
# VUSE <.MEM_8>
return 0;
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================
ret_41 = malloc (_18);
At top level:
test.c:86:8: warning: use location
  void *ret = malloc(size);
        ^
this stmt is child function---malloc-----

 ================== trace ================== 
 <ssa_name 0x7f034c9eb9d8
    type <pointer_type 0x7f034ceb70a8
        type <void_type 0x7f034ceb0f18 void VOID
            align 8 symtab 0 alias set -1 structural equality
            pointer_to_this <pointer_type 0x7f034ceb70a8>>
        public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality
        pointer_to_this <pointer_type 0x7f034cebcbd0>>
    var <var_decl 0x7f034c9ef3f0 ret>
    def_stmt ret_41 = malloc (_18);
    version 41
    ptr-info 0x7f034c9f1258>
trace fucntion name:malloc 

 ================== trace ================== 
trace fucntion free:0 
_24 = __builtin_object_size (progname_copy_19, 1);
this stmt is child function---__builtin_object_size-----

 ================== trace ================== 
 <ssa_name 0x7f034c9eb9d8
    type <pointer_type 0x7f034ceb70a8
        type <void_type 0x7f034ceb0f18 void VOID
            align 8 symtab 0 alias set -1 structural equality
            pointer_to_this <pointer_type 0x7f034ceb70a8>>
        public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality
        pointer_to_this <pointer_type 0x7f034cebcbd0>>
    var <var_decl 0x7f034c9ef3f0 ret>
    def_stmt ret_41 = malloc (_18);
    version 41
    ptr-info 0x7f034c9f1258>
trace fucntion name:__builtin_object_size 

 ================== trace ================== 
trace fucntion free:0 
if (_24 != 18446744073709551615)
if (_24 != 18446744073709551615)

 ================== find cond branch ================= 
Cond in fucntion main basic block 17
 ================== possible direct basic block ================= 
from main basic block 18
 ================== possible direct basic block ================= 
from main basic block 22
 ================== warring ================== 
[40;35m    need check this branch possible have return or exit stmt [0m

 ================== warring ================== 

 ================== find cond branch ================= 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_109 = VDEF <.MEM_108>
free (progname_copy_19);
bb index := 25
# VUSE <.MEM_8>
return 0;
In function â€˜mainâ€™:
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 25 ,possiable got to succ := 26

======================================================================
free (progname_copy_19);
At top level:
test.c:135:2: warning: use location
  xfree(progname_copy);
  ^
this stmt is child function---free-----

 ================== find ================== 
free (progname_copy_19);
test.c:135:2: warning: use location
[40;32m    HAS FREE STMT count:1 name:free [0m

 ================== find ================== 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_111 = VDEF <.MEM_110>
free (progname_copy_19);
bb index := 24
# VUSE <.MEM_8>
return 0;
In function â€˜mainâ€™:
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 24 ,possiable got to succ := 26

======================================================================
free (progname_copy_19);
At top level:
test.c:124:4: warning: use location
    xfree(progname_copy);
    ^
this stmt is child function---free-----

 ================== find ================== 
free (progname_copy_19);
test.c:124:4: warning: use location
[40;32m    HAS FREE STMT count:2 name:free [0m

 ================== find ================== 

======================================================================
[40;31m    branch possiable have return or exit  [0m
if (progname_copy_19 == 0B)
bb index := 15
# VUSE <.MEM_8>
return 0;
In function â€˜mainâ€™:
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
if (progname_copy_19 == 0B)
bb index := 15
# VUSE <.MEM_8>
return 0;
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================
if (progname_copy_19 == 0B)
At top level:
test.c:114:6: warning: use location
   if (!progname_copy)
      ^
if (progname_copy_19 == 0B)

 ================== find cond branch ================= 
test.c:114:6: warning: use location
Cond in fucntion main basic block 15
 ================== possible direct basic block ================= 
from main basic block 16
 ================== possible direct basic block ================= 
from main basic block 17
 ================== warring ================== 
[40;35m    need check this branch possible have return or exit stmt [0m

 ================== warring ================== 

 ================== find cond branch ================= 

======================================================================
[40;31m    branch possiable have return or exit  [0m
_42 = ret_41;
bb index := 15
# VUSE <.MEM_8>
return 0;
In function â€˜mainâ€™:
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
_42 = ret_41;
bb index := 15
# VUSE <.MEM_8>
return 0;
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================
_42 = ret_41;
At top level:
test.c:87:9: warning: use location
  return ret;
         ^

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7f034c9eb9d8
    type <pointer_type 0x7f034ceb70a8
        type <void_type 0x7f034ceb0f18 void VOID
            align 8 symtab 0 alias set -1 structural equality
            pointer_to_this <pointer_type 0x7f034ceb70a8>>
        public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality
        pointer_to_this <pointer_type 0x7f034cebcbd0>>
    var <var_decl 0x7f034c9ef3f0 ret>
    def_stmt ret_41 = malloc (_18);
    version 41
    ptr-info 0x7f034c9f1258>
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_111 = VDEF <.MEM_110>
free (progname_copy_19);
test.c:124:4: warning: use location
    xfree(progname_copy);
    ^
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_109 = VDEF <.MEM_108>
free (progname_copy_19);
test.c:135:2: warning: use location
  xfree(progname_copy);
  ^

 ================== Start Use after free Check ================== 

============================================================
# .MEM_109 = VDEF <.MEM_108>
free (progname_copy_19);
test.c:135:2: warning: Use after free error!: free location 
_35 = PHI <_28(19), _33(21), _34(22)>
lto1: warning: use location

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
# .MEM_111 = VDEF <.MEM_110>
free (progname_copy_19);
test.c:124:4: warning: Use after free error!: free location 
    xfree(progname_copy);
    ^
_35 = PHI <_28(19), _33(21), _34(22)>
lto1: warning: use location

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_111 = VDEF <.MEM_110>
free (progname_copy_19);
test.c:124:4: warning: Use after free error!: free location 
_35 = PHI <_28(19), _33(21), _34(22)>
lto1: warning: use location

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_109 = VDEF <.MEM_108>
free (progname_copy_19);
test.c:135:2: warning: Use after free error!: free location 
  xfree(progname_copy);
  ^
_35 = PHI <_28(19), _33(21), _34(22)>
lto1: warning: use location

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:2 [0m

======================================================================

======================================================================
[40;31m  	possible double free :2 [0m

======================================================================

dot graph START

======================================================================
 <ssa_name 0x7f034c9f38b8
    type <integer_type 0x7f034ceb07e0 long unsigned int public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 canonical type 0x7f034ceb0738 precision 64 min <integer_cst 0x7f034ce9ceb8 0> max <integer_cst 0x7f034ce9e500 18446744073709551615>
        pointer_to_this <pointer_type 0x7f034cebc9d8>>
   
    def_stmt _51 = (long unsigned int) _50;
    version 51>
_51 = (long unsigned int) _50;

 ================== trace ptable================== 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr--------
this other function -----------
 
 Start check Pointer Collect  

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_92 = VDEF <.MEM_5(D)>
dirname_52 = malloc (_51);
bb index := 10
# VUSE <.MEM_8>
return 0;
In function â€˜mainâ€™:
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 10 ,possiable got to succ := 26

======================================================================
dirname_52 = malloc (_51);
At top level:
test.c:43:11: warning: use location
   dirname = (char *) xmalloc (base - filename + 2);         /* allocation site */
           ^
this stmt is child function---malloc-----

 ================== trace ================== 
 <ssa_name 0x7f034c9f38b8
    type <integer_type 0x7f034ceb07e0 long unsigned int public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 canonical type 0x7f034ceb0738 precision 64 min <integer_cst 0x7f034ce9ceb8 0> max <integer_cst 0x7f034ce9e500 18446744073709551615>
        pointer_to_this <pointer_type 0x7f034cebc9d8>>
   
    def_stmt _51 = (long unsigned int) _50;
    version 51>
trace fucntion name:malloc 

 ================== trace ================== 
trace fucntion free:0 

======================================================================
[40;31m    branch possiable have return or exit  [0m
_76 = PHI <0B(9), dirname_52(14)>
bb index := 15
# VUSE <.MEM_8>
return 0;
In function â€˜mainâ€™:
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
_76 = PHI <0B(9), dirname_52(14)>
bb index := 15
# VUSE <.MEM_8>
return 0;
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================
_76 = PHI <0B(9), dirname_52(14)>
At top level:
lto1: warning: use location
this stmt have mutiple branch --------

======================================================================
[40;31m    branch possiable have return or exit  [0m
_96 = _76;
bb index := 15
# VUSE <.MEM_8>
return 0;
In function â€˜mainâ€™:
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
_96 = _76;
bb index := 15
# VUSE <.MEM_8>
return 0;
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================
_96 = _76;
At top level:
lto1: warning: use location

======================================================================
[40;31m    branch possiable have return or exit  [0m
_10 = _96;
bb index := 15
# VUSE <.MEM_8>
return 0;
In function â€˜mainâ€™:
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
_10 = _96;
bb index := 15
# VUSE <.MEM_8>
return 0;
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================
_10 = _96;
At top level:
test.c:109:22: warning: use location
   progname = concat (ldirname (python_libdir), "bin");
                      ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_97 = VDEF <.MEM_87>
progname_11 = concat (_10, "bin");
bb index := 15
# VUSE <.MEM_8>
return 0;
In function â€˜mainâ€™:
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_97 = VDEF <.MEM_87>
progname_11 = concat (_10, "bin");
bb index := 15
# VUSE <.MEM_8>
return 0;
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================
progname_11 = concat (_10, "bin");
At top level:
test.c:109:12: warning: use location
   progname = concat (ldirname (python_libdir), "bin");
            ^
this stmt is child function---concat-----

 ================== trace ================== 
 <ssa_name 0x7f034c9f38b8
    type <integer_type 0x7f034ceb07e0 long unsigned int public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 canonical type 0x7f034ceb0738 precision 64 min <integer_cst 0x7f034ce9ceb8 0> max <integer_cst 0x7f034ce9e500 18446744073709551615>
        pointer_to_this <pointer_type 0x7f034cebc9d8>>
   
    def_stmt _51 = (long unsigned int) _50;
    version 51>
trace fucntion name:concat 
[40;44m =======trace_function_path concat  function_call count: 3 level :0========  [0m
[40;42m =======pre add _ fucntion:memcpy========= [0m
[40;46m =======add node_fun stack:memcpy========= [0m
[40;42m =======pre add _ fucntion:strlen========= [0m
[40;46m =======add node_fun stack:strlen========= [0m
[40;42m =======pre add _ fucntion:malloc========= [0m
[40;46m =======add node_fun stack:malloc========= [0m

 ================== trace ================== 
trace fucntion free:0 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# VUSE <.MEM_100>
progsize_16 = strlen (progname_11);
bb index := 15
# VUSE <.MEM_8>
return 0;
In function â€˜mainâ€™:
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# VUSE <.MEM_100>
progsize_16 = strlen (progname_11);
bb index := 15
# VUSE <.MEM_8>
return 0;
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================
progsize_16 = strlen (progname_11);
At top level:
test.c:112:12: warning: use location
   progsize = strlen (progname);
            ^
this stmt is child function---strlen-----

 ================== trace ================== 
 <ssa_name 0x7f034c9f38b8
    type <integer_type 0x7f034ceb07e0 long unsigned int public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 canonical type 0x7f034ceb0738 precision 64 min <integer_cst 0x7f034ce9ceb8 0> max <integer_cst 0x7f034ce9e500 18446744073709551615>
        pointer_to_this <pointer_type 0x7f034cebc9d8>>
   
    def_stmt _51 = (long unsigned int) _50;
    version 51>
trace fucntion name:strlen 

 ================== trace ================== 
trace fucntion free:0 
_23 = progsize_16 + 1;
test.c:120:11: warning: use location
   count = mbstowcs (progname_copy, progname, progsize + 1);
           ^
_25 = __builtin_constant_p (_23);
this stmt is child function---__builtin_constant_p-----

 ================== trace ================== 
 <ssa_name 0x7f034c9f38b8
    type <integer_type 0x7f034ceb07e0 long unsigned int public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 canonical type 0x7f034ceb0738 precision 64 min <integer_cst 0x7f034ce9ceb8 0> max <integer_cst 0x7f034ce9e500 18446744073709551615>
        pointer_to_this <pointer_type 0x7f034cebc9d8>>
   
    def_stmt _51 = (long unsigned int) _50;
    version 51>
trace fucntion name:__builtin_constant_p 

 ================== trace ================== 
trace fucntion free:0 
if (_25 == 0)
if (_25 == 0)

 ================== find cond branch ================= 
Cond in fucntion main basic block 18
 ================== possible direct basic block ================= 
from main basic block 19
 ================== possible direct basic block ================= 
from main basic block 20
 ================== warring ================== 
[40;35m    need check this branch possible have return or exit stmt [0m

 ================== warring ================== 

 ================== find cond branch ================= 
_34 = __mbstowcs_alias (progname_copy_19, progname_11, _23);
this stmt is child function---__mbstowcs_alias-----

 ================== trace ================== 
 <ssa_name 0x7f034c9f38b8
    type <integer_type 0x7f034ceb07e0 long unsigned int public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 canonical type 0x7f034ceb0738 precision 64 min <integer_cst 0x7f034ce9ceb8 0> max <integer_cst 0x7f034ce9e500 18446744073709551615>
        pointer_to_this <pointer_type 0x7f034cebc9d8>>
   
    def_stmt _51 = (long unsigned int) _50;
    version 51>
trace fucntion name:__mbstowcs_alias 

 ================== trace ================== 
trace fucntion free:0 
_35 = PHI <_28(19), _33(21), _34(22)>
lto1: warning: use location
this stmt have mutiple branch --------
if (_35 == 18446744073709551615)
test.c:121:6: warning: use location
   if (count == (size_t) -1)
      ^
if (_35 == 18446744073709551615)

 ================== find cond branch ================= 
test.c:121:6: warning: use location
Cond in fucntion main basic block 23
 ================== possible direct basic block ================= 
from main basic block 24
 ================== possible direct basic block ================= 
from main basic block 25
 ================== warring ================== 
[40;35m    need check this branch possible have return or exit stmt [0m

 ================== warring ================== 

 ================== find cond branch ================= 
_31 = __builtin_object_size (progname_copy_19, 1);
this stmt is child function---__builtin_object_size-----

 ================== trace ================== 
 <ssa_name 0x7f034c9f38b8
    type <integer_type 0x7f034ceb07e0 long unsigned int public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 canonical type 0x7f034ceb0738 precision 64 min <integer_cst 0x7f034ce9ceb8 0> max <integer_cst 0x7f034ce9e500 18446744073709551615>
        pointer_to_this <pointer_type 0x7f034cebc9d8>>
   
    def_stmt _51 = (long unsigned int) _50;
    version 51>
trace fucntion name:__builtin_object_size 

 ================== trace ================== 
trace fucntion free:0 
_29 = __builtin_object_size (progname_copy_19, 1);
this stmt is child function---__builtin_object_size-----

 ================== trace ================== 
 <ssa_name 0x7f034c9f38b8
    type <integer_type 0x7f034ceb07e0 long unsigned int public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 canonical type 0x7f034ceb0738 precision 64 min <integer_cst 0x7f034ce9ceb8 0> max <integer_cst 0x7f034ce9e500 18446744073709551615>
        pointer_to_this <pointer_type 0x7f034cebc9d8>>
   
    def_stmt _51 = (long unsigned int) _50;
    version 51>
trace fucntion name:__builtin_object_size 

 ================== trace ================== 
trace fucntion free:0 
_30 = _29 / 4;
_26 = __builtin_object_size (progname_copy_19, 1);
this stmt is child function---__builtin_object_size-----

 ================== trace ================== 
 <ssa_name 0x7f034c9f38b8
    type <integer_type 0x7f034ceb07e0 long unsigned int public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 canonical type 0x7f034ceb0738 precision 64 min <integer_cst 0x7f034ce9ceb8 0> max <integer_cst 0x7f034ce9e500 18446744073709551615>
        pointer_to_this <pointer_type 0x7f034cebc9d8>>
   
    def_stmt _51 = (long unsigned int) _50;
    version 51>
trace fucntion name:__builtin_object_size 

 ================== trace ================== 
trace fucntion free:0 
_27 = _26 / 4;
_28 = __mbstowcs_chk (progname_copy_19, progname_11, _23, _27);
this stmt is child function---__mbstowcs_chk-----

 ================== trace ================== 
 <ssa_name 0x7f034c9f38b8
    type <integer_type 0x7f034ceb07e0 long unsigned int public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 canonical type 0x7f034ceb0738 precision 64 min <integer_cst 0x7f034ce9ceb8 0> max <integer_cst 0x7f034ce9e500 18446744073709551615>
        pointer_to_this <pointer_type 0x7f034cebc9d8>>
   
    def_stmt _51 = (long unsigned int) _50;
    version 51>
trace fucntion name:__mbstowcs_chk 

 ================== trace ================== 
trace fucntion free:0 
_24 = __builtin_object_size (progname_copy_19, 1);
this stmt is child function---__builtin_object_size-----

 ================== trace ================== 
 <ssa_name 0x7f034c9f38b8
    type <integer_type 0x7f034ceb07e0 long unsigned int public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 canonical type 0x7f034ceb0738 precision 64 min <integer_cst 0x7f034ce9ceb8 0> max <integer_cst 0x7f034ce9e500 18446744073709551615>
        pointer_to_this <pointer_type 0x7f034cebc9d8>>
   
    def_stmt _51 = (long unsigned int) _50;
    version 51>
trace fucntion name:__builtin_object_size 

 ================== trace ================== 
trace fucntion free:0 
if (_24 != 18446744073709551615)
if (_24 != 18446744073709551615)

 ================== find cond branch ================= 
Cond in fucntion main basic block 17
 ================== possible direct basic block ================= 
from main basic block 18
 ================== possible direct basic block ================= 
from main basic block 22
 ================== warring ================== 
[40;35m    need check this branch possible have return or exit stmt [0m

 ================== warring ================== 

 ================== find cond branch ================= 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_109 = VDEF <.MEM_108>
free (progname_copy_19);
bb index := 25
# VUSE <.MEM_8>
return 0;
In function â€˜mainâ€™:
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 25 ,possiable got to succ := 26

======================================================================
free (progname_copy_19);
At top level:
test.c:135:2: warning: use location
  xfree(progname_copy);
  ^
this stmt is child function---free-----

 ================== find ================== 
free (progname_copy_19);
test.c:135:2: warning: use location
[40;32m    HAS FREE STMT count:1 name:free [0m

 ================== find ================== 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_111 = VDEF <.MEM_110>
free (progname_copy_19);
bb index := 24
# VUSE <.MEM_8>
return 0;
In function â€˜mainâ€™:
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 24 ,possiable got to succ := 26

======================================================================
free (progname_copy_19);
At top level:
test.c:124:4: warning: use location
    xfree(progname_copy);
    ^
this stmt is child function---free-----

 ================== find ================== 
free (progname_copy_19);
test.c:124:4: warning: use location
[40;32m    HAS FREE STMT count:2 name:free [0m

 ================== find ================== 
_33 = __mbstowcs_chk_warn (progname_copy_19, progname_11, _23, _32);
this stmt is child function---__mbstowcs_chk_warn-----

 ================== trace ================== 
 <ssa_name 0x7f034c9f38b8
    type <integer_type 0x7f034ceb07e0 long unsigned int public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 canonical type 0x7f034ceb0738 precision 64 min <integer_cst 0x7f034ce9ceb8 0> max <integer_cst 0x7f034ce9e500 18446744073709551615>
        pointer_to_this <pointer_type 0x7f034cebc9d8>>
   
    def_stmt _51 = (long unsigned int) _50;
    version 51>
trace fucntion name:__mbstowcs_chk_warn 

 ================== trace ================== 
trace fucntion free:2 

======================================================================
[40;31m    branch possiable have return or exit  [0m
if (progname_copy_19 == 0B)
bb index := 15
# VUSE <.MEM_8>
return 0;
In function â€˜mainâ€™:
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
if (progname_copy_19 == 0B)
bb index := 15
# VUSE <.MEM_8>
return 0;
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================
if (progname_copy_19 == 0B)
At top level:
test.c:114:6: warning: use location
   if (!progname_copy)
      ^
if (progname_copy_19 == 0B)

 ================== find cond branch ================= 
test.c:114:6: warning: use location
Cond in fucntion main basic block 15
 ================== possible direct basic block ================= 
from main basic block 16
 ================== possible direct basic block ================= 
from main basic block 17
 ================== warring ================== 
[40;35m    need check this branch possible have return or exit stmt [0m

 ================== warring ================== 

 ================== find cond branch ================= 

======================================================================
[40;31m    branch possiable have return or exit  [0m
_17 = progsize_16 + 1;
bb index := 15
# VUSE <.MEM_8>
return 0;
In function â€˜mainâ€™:
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
_17 = progsize_16 + 1;
bb index := 15
# VUSE <.MEM_8>
return 0;
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================
_17 = progsize_16 + 1;
At top level:
test.c:113:31: warning: use location
   progname_copy = (wchar_t *) PyMem_Malloc ((progsize + 1) * sizeof (wchar_t));
                               ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
_18 = _17 * 4;
bb index := 15
# VUSE <.MEM_8>
return 0;
In function â€˜mainâ€™:
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
_18 = _17 * 4;
bb index := 15
# VUSE <.MEM_8>
return 0;
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================
_18 = _17 * 4;
At top level:
test.c:113:31: warning: use location

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_101 = VDEF <.MEM_100>
ret_41 = malloc (_18);
bb index := 15
# VUSE <.MEM_8>
return 0;
In function â€˜mainâ€™:
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_101 = VDEF <.MEM_100>
ret_41 = malloc (_18);
bb index := 15
# VUSE <.MEM_8>
return 0;
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================
ret_41 = malloc (_18);
At top level:
test.c:86:8: warning: use location
  void *ret = malloc(size);
        ^
this stmt is child function---malloc-----

 ================== trace ================== 
 <ssa_name 0x7f034c9f38b8
    type <integer_type 0x7f034ceb07e0 long unsigned int public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 canonical type 0x7f034ceb0738 precision 64 min <integer_cst 0x7f034ce9ceb8 0> max <integer_cst 0x7f034ce9e500 18446744073709551615>
        pointer_to_this <pointer_type 0x7f034cebc9d8>>
   
    def_stmt _51 = (long unsigned int) _50;
    version 51>
trace fucntion name:malloc 

 ================== trace ================== 
trace fucntion free:2 

======================================================================
[40;31m    branch possiable have return or exit  [0m
_102 = ret_41;
bb index := 15
# VUSE <.MEM_8>
return 0;
In function â€˜mainâ€™:
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
_102 = ret_41;
bb index := 15
# VUSE <.MEM_8>
return 0;
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================
_102 = ret_41;
At top level:
lto1: warning: use location

======================================================================
[40;31m    branch possiable have return or exit  [0m
_42 = ret_41;
bb index := 15
# VUSE <.MEM_8>
return 0;
In function â€˜mainâ€™:
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
_42 = ret_41;
bb index := 15
# VUSE <.MEM_8>
return 0;
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================
_42 = ret_41;
At top level:
test.c:87:9: warning: use location
  return ret;
         ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
_75 = dirname_52;
bb index := 14
# VUSE <.MEM_8>
return 0;
In function â€˜mainâ€™:
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 14 ,possiable got to succ := 26

======================================================================
_75 = dirname_52;
At top level:
test.c:53:10: warning: use location
   return dirname;
          ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
_74 = dirname_52 + _73;
bb index := 14
# VUSE <.MEM_8>
return 0;
In function â€˜mainâ€™:
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 14 ,possiable got to succ := 26

======================================================================
_74 = dirname_52 + _73;
At top level:
test.c:52:10: warning: use location
   dirname[base - filename] = '\0';
          ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_95 = VDEF <.MEM_86>
*_74 = 0;
bb index := 14
# VUSE <.MEM_8>
return 0;
In function â€˜mainâ€™:
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 14 ,possiable got to succ := 26

======================================================================
*_74 = 0;
At top level:
test.c:52:28: warning: use location
   dirname[base - filename] = '\0';
                            ^
_68 = dirname_52 + _67;
test.c:50:12: warning: use location
     dirname[base++ - filename] = '.';
            ^
*_68 = 46;
test.c:50:32: warning: use location
     dirname[base++ - filename] = '.';
                                ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_93 = VDEF <.MEM_92>
memcpy (dirname_52, _9, _56);
bb index := 10
# VUSE <.MEM_8>
return 0;
In function â€˜mainâ€™:
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 10 ,possiable got to succ := 26

======================================================================
memcpy (dirname_52, _9, _56);
At top level:
test.c:44:3: warning: use location
   memcpy (dirname, filename, base - filename);
   ^
this stmt is child function---memcpy-----

 ================== trace ================== 
 <ssa_name 0x7f034c9f38b8
    type <integer_type 0x7f034ceb07e0 long unsigned int public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 canonical type 0x7f034ceb0738 precision 64 min <integer_cst 0x7f034ce9ceb8 0> max <integer_cst 0x7f034ce9e500 18446744073709551615>
        pointer_to_this <pointer_type 0x7f034cebc9d8>>
   
    def_stmt _51 = (long unsigned int) _50;
    version 51>
trace fucntion name:memcpy 

 ================== trace ================== 
trace fucntion free:2 

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7f034c9f38b8
    type <integer_type 0x7f034ceb07e0 long unsigned int public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 canonical type 0x7f034ceb0738 precision 64 min <integer_cst 0x7f034ce9ceb8 0> max <integer_cst 0x7f034ce9e500 18446744073709551615>
        pointer_to_this <pointer_type 0x7f034cebc9d8>>
   
    def_stmt _51 = (long unsigned int) _50;
    version 51>
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_113 = VDEF <.MEM_101>
free (oldloc_15);
test.c:116:7: warning: use location
       xfree (oldloc);
       ^
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_110 = VDEF <.MEM_88>
free (oldloc_15);
test.c:123:7: warning: use location
       xfree (oldloc);
       ^
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_111 = VDEF <.MEM_110>
free (progname_copy_19);
test.c:124:4: warning: use location
    xfree(progname_copy);
    ^
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_107 = VDEF <.MEM_106>
free (oldloc_15);
test.c:129:3: warning: use location
   xfree (oldloc);
   ^
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_109 = VDEF <.MEM_108>
free (progname_copy_19);
test.c:135:2: warning: use location
  xfree(progname_copy);
  ^

 ================== Start Use after free Check ================== 

============================================================
# .MEM_109 = VDEF <.MEM_108>
free (progname_copy_19);
test.c:135:2: warning: Use after free error!: free location 
_76 = PHI <0B(9), dirname_52(14)>
lto1: warning: use location

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
# .MEM_111 = VDEF <.MEM_110>
free (progname_copy_19);
test.c:124:4: warning: Use after free error!: free location 
    xfree(progname_copy);
    ^
_76 = PHI <0B(9), dirname_52(14)>
lto1: warning: use location

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_113 = VDEF <.MEM_101>
free (oldloc_15);
test.c:116:7: warning: Use after free error!: free location 
       xfree (oldloc);
       ^
_76 = PHI <0B(9), dirname_52(14)>
lto1: warning: use location

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_110 = VDEF <.MEM_88>
free (oldloc_15);
test.c:123:7: warning: Use after free error!: free location 
       xfree (oldloc);
       ^
_76 = PHI <0B(9), dirname_52(14)>
lto1: warning: use location

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_111 = VDEF <.MEM_110>
free (progname_copy_19);
test.c:124:4: warning: Use after free error!: free location 
    xfree(progname_copy);
    ^
_76 = PHI <0B(9), dirname_52(14)>
lto1: warning: use location

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_107 = VDEF <.MEM_106>
free (oldloc_15);
test.c:129:3: warning: Use after free error!: free location 
   xfree (oldloc);
   ^
_76 = PHI <0B(9), dirname_52(14)>
lto1: warning: use location

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_109 = VDEF <.MEM_108>
free (progname_copy_19);
test.c:135:2: warning: Use after free error!: free location 
  xfree(progname_copy);
  ^
_76 = PHI <0B(9), dirname_52(14)>
lto1: warning: use location

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_113 = VDEF <.MEM_101>
free (oldloc_15);
test.c:116:7: warning: Use after free error!: free location 
       xfree (oldloc);
       ^
_23 = progsize_16 + 1;
test.c:120:11: warning: use location
   count = mbstowcs (progname_copy, progname, progsize + 1);
           ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_113 = VDEF <.MEM_101>
free (oldloc_15);
test.c:116:7: warning: Use after free error!: free location 
       xfree (oldloc);
       ^
_25 = __builtin_constant_p (_23);

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_113 = VDEF <.MEM_101>
free (oldloc_15);
test.c:116:7: warning: Use after free error!: free location 
if (_25 == 0)

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_113 = VDEF <.MEM_101>
free (oldloc_15);
test.c:116:7: warning: Use after free error!: free location 
# .MEM_105 = VDEF <.MEM_101>
_34 = __mbstowcs_alias (progname_copy_19, progname_11, _23);

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
# .MEM_109 = VDEF <.MEM_108>
free (progname_copy_19);
test.c:135:2: warning: Use after free error!: free location 
  xfree(progname_copy);
  ^
_35 = PHI <_28(19), _33(21), _34(22)>
lto1: warning: use location

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
# .MEM_111 = VDEF <.MEM_110>
free (progname_copy_19);
test.c:124:4: warning: Use after free error!: free location 
    xfree(progname_copy);
    ^
_35 = PHI <_28(19), _33(21), _34(22)>
lto1: warning: use location

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_113 = VDEF <.MEM_101>
free (oldloc_15);
test.c:116:7: warning: Use after free error!: free location 
       xfree (oldloc);
       ^
_35 = PHI <_28(19), _33(21), _34(22)>
lto1: warning: use location

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_110 = VDEF <.MEM_88>
free (oldloc_15);
test.c:123:7: warning: Use after free error!: free location 
       xfree (oldloc);
       ^
_35 = PHI <_28(19), _33(21), _34(22)>
lto1: warning: use location

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_111 = VDEF <.MEM_110>
free (progname_copy_19);
test.c:124:4: warning: Use after free error!: free location 
    xfree(progname_copy);
    ^
_35 = PHI <_28(19), _33(21), _34(22)>
lto1: warning: use location

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_107 = VDEF <.MEM_106>
free (oldloc_15);
test.c:129:3: warning: Use after free error!: free location 
   xfree (oldloc);
   ^
_35 = PHI <_28(19), _33(21), _34(22)>
lto1: warning: use location

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_109 = VDEF <.MEM_108>
free (progname_copy_19);
test.c:135:2: warning: Use after free error!: free location 
  xfree(progname_copy);
  ^
_35 = PHI <_28(19), _33(21), _34(22)>
lto1: warning: use location

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_113 = VDEF <.MEM_101>
free (oldloc_15);
test.c:116:7: warning: Use after free error!: free location 
       xfree (oldloc);
       ^
if (_35 == 18446744073709551615)
test.c:121:6: warning: use location
   if (count == (size_t) -1)
      ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_113 = VDEF <.MEM_101>
free (oldloc_15);
test.c:116:7: warning: Use after free error!: free location 
       xfree (oldloc);
       ^
# VUSE <.MEM_101>
_31 = __builtin_object_size (progname_copy_19, 1);

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_113 = VDEF <.MEM_101>
free (oldloc_15);
test.c:116:7: warning: Use after free error!: free location 
# VUSE <.MEM_101>
_29 = __builtin_object_size (progname_copy_19, 1);

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_113 = VDEF <.MEM_101>
free (oldloc_15);
test.c:116:7: warning: Use after free error!: free location 
_30 = _29 / 4;

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_113 = VDEF <.MEM_101>
free (oldloc_15);
test.c:116:7: warning: Use after free error!: free location 
# VUSE <.MEM_101>
_26 = __builtin_object_size (progname_copy_19, 1);

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_113 = VDEF <.MEM_101>
free (oldloc_15);
test.c:116:7: warning: Use after free error!: free location 
_27 = _26 / 4;

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_113 = VDEF <.MEM_101>
free (oldloc_15);
test.c:116:7: warning: Use after free error!: free location 
# .MEM_104 = VDEF <.MEM_101>
_28 = __mbstowcs_chk (progname_copy_19, progname_11, _23, _27);

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_113 = VDEF <.MEM_101>
free (oldloc_15);
test.c:116:7: warning: Use after free error!: free location 
# VUSE <.MEM_101>
_24 = __builtin_object_size (progname_copy_19, 1);

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_113 = VDEF <.MEM_101>
free (oldloc_15);
test.c:116:7: warning: Use after free error!: free location 
if (_24 != 18446744073709551615)

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_113 = VDEF <.MEM_101>
free (oldloc_15);
test.c:116:7: warning: Use after free error!: free location 
# .MEM_103 = VDEF <.MEM_101>
_33 = __mbstowcs_chk_warn (progname_copy_19, progname_11, _23, _32);

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:5 [0m

======================================================================

======================================================================
[40;31m  	possible double free :2 [0m

======================================================================

dot graph START

======================================================================
 <ssa_name 0x7f034c9e7f78
    type <pointer_type 0x7f034c9c65e8
        type <integer_type 0x7f034c9c6dc8 char public string-flag QI
            size <integer_cst 0x7f034ce9ccd8 constant 8>
            unit size <integer_cst 0x7f034ce9ccf0 constant 1>
            align 8 symtab 0 alias set -1 canonical type 0x7f034ceb03f0 precision 8 min <integer_cst 0x7f034c9c91b0 -128> max <integer_cst 0x7f034c9c9198 127>
            pointer_to_this <pointer_type 0x7f034c9c65e8>>
        public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality context <translation_unit_decl 0x7f034cea7168 test.c>
        pointer_to_this <pointer_type 0x7f034c9d2bd0>>
   
    def_stmt _10 = _96;
    version 10
    ptr-info 0x7f034c9f11b0>
_10 = _96;

 ================== trace ptable================== 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr--------
this other function -----------
 
 Start check Pointer Collect  

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_97 = VDEF <.MEM_87>
progname_11 = concat (_10, "bin");
bb index := 15
# VUSE <.MEM_8>
return 0;
In function â€˜mainâ€™:
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_97 = VDEF <.MEM_87>
progname_11 = concat (_10, "bin");
bb index := 15
# VUSE <.MEM_8>
return 0;
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================
progname_11 = concat (_10, "bin");
At top level:
test.c:109:12: warning: use location
   progname = concat (ldirname (python_libdir), "bin");
            ^
this stmt is child function---concat-----

 ================== trace ================== 
 <ssa_name 0x7f034c9e7f78
    type <pointer_type 0x7f034c9c65e8
        type <integer_type 0x7f034c9c6dc8 char public string-flag QI
            size <integer_cst 0x7f034ce9ccd8 constant 8>
            unit size <integer_cst 0x7f034ce9ccf0 constant 1>
            align 8 symtab 0 alias set -1 canonical type 0x7f034ceb03f0 precision 8 min <integer_cst 0x7f034c9c91b0 -128> max <integer_cst 0x7f034c9c9198 127>
            pointer_to_this <pointer_type 0x7f034c9c65e8>>
        public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality context <translation_unit_decl 0x7f034cea7168 test.c>
        pointer_to_this <pointer_type 0x7f034c9d2bd0>>
   
    def_stmt _10 = _96;
    version 10
    ptr-info 0x7f034c9f11b0>
trace fucntion name:concat 
[40;44m =======trace_function_path concat  function_call count: 3 level :0========  [0m
[40;36m ======= node_fun:concat========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:memcpy========= [0m
[40;46m =======add node_fun stack:memcpy========= [0m
[40;42m =======pre add _ fucntion:strlen========= [0m
[40;46m =======add node_fun stack:strlen========= [0m
[40;42m =======pre add _ fucntion:malloc========= [0m
[40;46m =======add node_fun stack:malloc========= [0m

 ================== trace ================== 
trace fucntion free:0 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# VUSE <.MEM_100>
progsize_16 = strlen (progname_11);
bb index := 15
# VUSE <.MEM_8>
return 0;
In function â€˜mainâ€™:
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# VUSE <.MEM_100>
progsize_16 = strlen (progname_11);
bb index := 15
# VUSE <.MEM_8>
return 0;
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================
progsize_16 = strlen (progname_11);
At top level:
test.c:112:12: warning: use location
   progsize = strlen (progname);
            ^
this stmt is child function---strlen-----

 ================== trace ================== 
 <ssa_name 0x7f034c9e7f78
    type <pointer_type 0x7f034c9c65e8
        type <integer_type 0x7f034c9c6dc8 char public string-flag QI
            size <integer_cst 0x7f034ce9ccd8 constant 8>
            unit size <integer_cst 0x7f034ce9ccf0 constant 1>
            align 8 symtab 0 alias set -1 canonical type 0x7f034ceb03f0 precision 8 min <integer_cst 0x7f034c9c91b0 -128> max <integer_cst 0x7f034c9c9198 127>
            pointer_to_this <pointer_type 0x7f034c9c65e8>>
        public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality context <translation_unit_decl 0x7f034cea7168 test.c>
        pointer_to_this <pointer_type 0x7f034c9d2bd0>>
   
    def_stmt _10 = _96;
    version 10
    ptr-info 0x7f034c9f11b0>
trace fucntion name:strlen 

 ================== trace ================== 
trace fucntion free:0 
_23 = progsize_16 + 1;
test.c:120:11: warning: use location
   count = mbstowcs (progname_copy, progname, progsize + 1);
           ^
_25 = __builtin_constant_p (_23);
this stmt is child function---__builtin_constant_p-----

 ================== trace ================== 
 <ssa_name 0x7f034c9e7f78
    type <pointer_type 0x7f034c9c65e8
        type <integer_type 0x7f034c9c6dc8 char public string-flag QI
            size <integer_cst 0x7f034ce9ccd8 constant 8>
            unit size <integer_cst 0x7f034ce9ccf0 constant 1>
            align 8 symtab 0 alias set -1 canonical type 0x7f034ceb03f0 precision 8 min <integer_cst 0x7f034c9c91b0 -128> max <integer_cst 0x7f034c9c9198 127>
            pointer_to_this <pointer_type 0x7f034c9c65e8>>
        public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality context <translation_unit_decl 0x7f034cea7168 test.c>
        pointer_to_this <pointer_type 0x7f034c9d2bd0>>
   
    def_stmt _10 = _96;
    version 10
    ptr-info 0x7f034c9f11b0>
trace fucntion name:__builtin_constant_p 

 ================== trace ================== 
trace fucntion free:0 
if (_25 == 0)
if (_25 == 0)

 ================== find cond branch ================= 
Cond in fucntion main basic block 18
 ================== possible direct basic block ================= 
from main basic block 19
 ================== possible direct basic block ================= 
from main basic block 20
 ================== warring ================== 
[40;35m    need check this branch possible have return or exit stmt [0m

 ================== warring ================== 

 ================== find cond branch ================= 
_34 = __mbstowcs_alias (progname_copy_19, progname_11, _23);
this stmt is child function---__mbstowcs_alias-----

 ================== trace ================== 
 <ssa_name 0x7f034c9e7f78
    type <pointer_type 0x7f034c9c65e8
        type <integer_type 0x7f034c9c6dc8 char public string-flag QI
            size <integer_cst 0x7f034ce9ccd8 constant 8>
            unit size <integer_cst 0x7f034ce9ccf0 constant 1>
            align 8 symtab 0 alias set -1 canonical type 0x7f034ceb03f0 precision 8 min <integer_cst 0x7f034c9c91b0 -128> max <integer_cst 0x7f034c9c9198 127>
            pointer_to_this <pointer_type 0x7f034c9c65e8>>
        public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality context <translation_unit_decl 0x7f034cea7168 test.c>
        pointer_to_this <pointer_type 0x7f034c9d2bd0>>
   
    def_stmt _10 = _96;
    version 10
    ptr-info 0x7f034c9f11b0>
trace fucntion name:__mbstowcs_alias 

 ================== trace ================== 
trace fucntion free:0 
_35 = PHI <_28(19), _33(21), _34(22)>
lto1: warning: use location
this stmt have mutiple branch --------
if (_35 == 18446744073709551615)
test.c:121:6: warning: use location
   if (count == (size_t) -1)
      ^
if (_35 == 18446744073709551615)

 ================== find cond branch ================= 
test.c:121:6: warning: use location
Cond in fucntion main basic block 23
 ================== possible direct basic block ================= 
from main basic block 24
 ================== possible direct basic block ================= 
from main basic block 25
 ================== warring ================== 
[40;35m    need check this branch possible have return or exit stmt [0m

 ================== warring ================== 

 ================== find cond branch ================= 
_31 = __builtin_object_size (progname_copy_19, 1);
this stmt is child function---__builtin_object_size-----

 ================== trace ================== 
 <ssa_name 0x7f034c9e7f78
    type <pointer_type 0x7f034c9c65e8
        type <integer_type 0x7f034c9c6dc8 char public string-flag QI
            size <integer_cst 0x7f034ce9ccd8 constant 8>
            unit size <integer_cst 0x7f034ce9ccf0 constant 1>
            align 8 symtab 0 alias set -1 canonical type 0x7f034ceb03f0 precision 8 min <integer_cst 0x7f034c9c91b0 -128> max <integer_cst 0x7f034c9c9198 127>
            pointer_to_this <pointer_type 0x7f034c9c65e8>>
        public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality context <translation_unit_decl 0x7f034cea7168 test.c>
        pointer_to_this <pointer_type 0x7f034c9d2bd0>>
   
    def_stmt _10 = _96;
    version 10
    ptr-info 0x7f034c9f11b0>
trace fucntion name:__builtin_object_size 

 ================== trace ================== 
trace fucntion free:0 
_29 = __builtin_object_size (progname_copy_19, 1);
this stmt is child function---__builtin_object_size-----

 ================== trace ================== 
 <ssa_name 0x7f034c9e7f78
    type <pointer_type 0x7f034c9c65e8
        type <integer_type 0x7f034c9c6dc8 char public string-flag QI
            size <integer_cst 0x7f034ce9ccd8 constant 8>
            unit size <integer_cst 0x7f034ce9ccf0 constant 1>
            align 8 symtab 0 alias set -1 canonical type 0x7f034ceb03f0 precision 8 min <integer_cst 0x7f034c9c91b0 -128> max <integer_cst 0x7f034c9c9198 127>
            pointer_to_this <pointer_type 0x7f034c9c65e8>>
        public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality context <translation_unit_decl 0x7f034cea7168 test.c>
        pointer_to_this <pointer_type 0x7f034c9d2bd0>>
   
    def_stmt _10 = _96;
    version 10
    ptr-info 0x7f034c9f11b0>
trace fucntion name:__builtin_object_size 

 ================== trace ================== 
trace fucntion free:0 
_30 = _29 / 4;
_26 = __builtin_object_size (progname_copy_19, 1);
this stmt is child function---__builtin_object_size-----

 ================== trace ================== 
 <ssa_name 0x7f034c9e7f78
    type <pointer_type 0x7f034c9c65e8
        type <integer_type 0x7f034c9c6dc8 char public string-flag QI
            size <integer_cst 0x7f034ce9ccd8 constant 8>
            unit size <integer_cst 0x7f034ce9ccf0 constant 1>
            align 8 symtab 0 alias set -1 canonical type 0x7f034ceb03f0 precision 8 min <integer_cst 0x7f034c9c91b0 -128> max <integer_cst 0x7f034c9c9198 127>
            pointer_to_this <pointer_type 0x7f034c9c65e8>>
        public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality context <translation_unit_decl 0x7f034cea7168 test.c>
        pointer_to_this <pointer_type 0x7f034c9d2bd0>>
   
    def_stmt _10 = _96;
    version 10
    ptr-info 0x7f034c9f11b0>
trace fucntion name:__builtin_object_size 

 ================== trace ================== 
trace fucntion free:0 
_27 = _26 / 4;
_28 = __mbstowcs_chk (progname_copy_19, progname_11, _23, _27);
this stmt is child function---__mbstowcs_chk-----

 ================== trace ================== 
 <ssa_name 0x7f034c9e7f78
    type <pointer_type 0x7f034c9c65e8
        type <integer_type 0x7f034c9c6dc8 char public string-flag QI
            size <integer_cst 0x7f034ce9ccd8 constant 8>
            unit size <integer_cst 0x7f034ce9ccf0 constant 1>
            align 8 symtab 0 alias set -1 canonical type 0x7f034ceb03f0 precision 8 min <integer_cst 0x7f034c9c91b0 -128> max <integer_cst 0x7f034c9c9198 127>
            pointer_to_this <pointer_type 0x7f034c9c65e8>>
        public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality context <translation_unit_decl 0x7f034cea7168 test.c>
        pointer_to_this <pointer_type 0x7f034c9d2bd0>>
   
    def_stmt _10 = _96;
    version 10
    ptr-info 0x7f034c9f11b0>
trace fucntion name:__mbstowcs_chk 

 ================== trace ================== 
trace fucntion free:0 
_24 = __builtin_object_size (progname_copy_19, 1);
this stmt is child function---__builtin_object_size-----

 ================== trace ================== 
 <ssa_name 0x7f034c9e7f78
    type <pointer_type 0x7f034c9c65e8
        type <integer_type 0x7f034c9c6dc8 char public string-flag QI
            size <integer_cst 0x7f034ce9ccd8 constant 8>
            unit size <integer_cst 0x7f034ce9ccf0 constant 1>
            align 8 symtab 0 alias set -1 canonical type 0x7f034ceb03f0 precision 8 min <integer_cst 0x7f034c9c91b0 -128> max <integer_cst 0x7f034c9c9198 127>
            pointer_to_this <pointer_type 0x7f034c9c65e8>>
        public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality context <translation_unit_decl 0x7f034cea7168 test.c>
        pointer_to_this <pointer_type 0x7f034c9d2bd0>>
   
    def_stmt _10 = _96;
    version 10
    ptr-info 0x7f034c9f11b0>
trace fucntion name:__builtin_object_size 

 ================== trace ================== 
trace fucntion free:0 
if (_24 != 18446744073709551615)
if (_24 != 18446744073709551615)

 ================== find cond branch ================= 
Cond in fucntion main basic block 17
 ================== possible direct basic block ================= 
from main basic block 18
 ================== possible direct basic block ================= 
from main basic block 22
 ================== warring ================== 
[40;35m    need check this branch possible have return or exit stmt [0m

 ================== warring ================== 

 ================== find cond branch ================= 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_109 = VDEF <.MEM_108>
free (progname_copy_19);
bb index := 25
# VUSE <.MEM_8>
return 0;
In function â€˜mainâ€™:
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 25 ,possiable got to succ := 26

======================================================================
free (progname_copy_19);
At top level:
test.c:135:2: warning: use location
  xfree(progname_copy);
  ^
this stmt is child function---free-----

 ================== find ================== 
free (progname_copy_19);
test.c:135:2: warning: use location
[40;32m    HAS FREE STMT count:1 name:free [0m

 ================== find ================== 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_111 = VDEF <.MEM_110>
free (progname_copy_19);
bb index := 24
# VUSE <.MEM_8>
return 0;
In function â€˜mainâ€™:
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 24 ,possiable got to succ := 26

======================================================================
free (progname_copy_19);
At top level:
test.c:124:4: warning: use location
    xfree(progname_copy);
    ^
this stmt is child function---free-----

 ================== find ================== 
free (progname_copy_19);
test.c:124:4: warning: use location
[40;32m    HAS FREE STMT count:2 name:free [0m

 ================== find ================== 
_33 = __mbstowcs_chk_warn (progname_copy_19, progname_11, _23, _32);
this stmt is child function---__mbstowcs_chk_warn-----

 ================== trace ================== 
 <ssa_name 0x7f034c9e7f78
    type <pointer_type 0x7f034c9c65e8
        type <integer_type 0x7f034c9c6dc8 char public string-flag QI
            size <integer_cst 0x7f034ce9ccd8 constant 8>
            unit size <integer_cst 0x7f034ce9ccf0 constant 1>
            align 8 symtab 0 alias set -1 canonical type 0x7f034ceb03f0 precision 8 min <integer_cst 0x7f034c9c91b0 -128> max <integer_cst 0x7f034c9c9198 127>
            pointer_to_this <pointer_type 0x7f034c9c65e8>>
        public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality context <translation_unit_decl 0x7f034cea7168 test.c>
        pointer_to_this <pointer_type 0x7f034c9d2bd0>>
   
    def_stmt _10 = _96;
    version 10
    ptr-info 0x7f034c9f11b0>
trace fucntion name:__mbstowcs_chk_warn 

 ================== trace ================== 
trace fucntion free:2 

======================================================================
[40;31m    branch possiable have return or exit  [0m
if (progname_copy_19 == 0B)
bb index := 15
# VUSE <.MEM_8>
return 0;
In function â€˜mainâ€™:
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
if (progname_copy_19 == 0B)
bb index := 15
# VUSE <.MEM_8>
return 0;
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================
if (progname_copy_19 == 0B)
At top level:
test.c:114:6: warning: use location
   if (!progname_copy)
      ^
if (progname_copy_19 == 0B)

 ================== find cond branch ================= 
test.c:114:6: warning: use location
Cond in fucntion main basic block 15
 ================== possible direct basic block ================= 
from main basic block 16
 ================== possible direct basic block ================= 
from main basic block 17
 ================== warring ================== 
[40;35m    need check this branch possible have return or exit stmt [0m

 ================== warring ================== 

 ================== find cond branch ================= 

======================================================================
[40;31m    branch possiable have return or exit  [0m
_17 = progsize_16 + 1;
bb index := 15
# VUSE <.MEM_8>
return 0;
In function â€˜mainâ€™:
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
_17 = progsize_16 + 1;
bb index := 15
# VUSE <.MEM_8>
return 0;
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================
_17 = progsize_16 + 1;
At top level:
test.c:113:31: warning: use location
   progname_copy = (wchar_t *) PyMem_Malloc ((progsize + 1) * sizeof (wchar_t));
                               ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
_18 = _17 * 4;
bb index := 15
# VUSE <.MEM_8>
return 0;
In function â€˜mainâ€™:
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
_18 = _17 * 4;
bb index := 15
# VUSE <.MEM_8>
return 0;
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================
_18 = _17 * 4;
At top level:
test.c:113:31: warning: use location

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_101 = VDEF <.MEM_100>
ret_41 = malloc (_18);
bb index := 15
# VUSE <.MEM_8>
return 0;
In function â€˜mainâ€™:
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_101 = VDEF <.MEM_100>
ret_41 = malloc (_18);
bb index := 15
# VUSE <.MEM_8>
return 0;
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================
ret_41 = malloc (_18);
At top level:
test.c:86:8: warning: use location
  void *ret = malloc(size);
        ^
this stmt is child function---malloc-----

 ================== trace ================== 
 <ssa_name 0x7f034c9e7f78
    type <pointer_type 0x7f034c9c65e8
        type <integer_type 0x7f034c9c6dc8 char public string-flag QI
            size <integer_cst 0x7f034ce9ccd8 constant 8>
            unit size <integer_cst 0x7f034ce9ccf0 constant 1>
            align 8 symtab 0 alias set -1 canonical type 0x7f034ceb03f0 precision 8 min <integer_cst 0x7f034c9c91b0 -128> max <integer_cst 0x7f034c9c9198 127>
            pointer_to_this <pointer_type 0x7f034c9c65e8>>
        public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality context <translation_unit_decl 0x7f034cea7168 test.c>
        pointer_to_this <pointer_type 0x7f034c9d2bd0>>
   
    def_stmt _10 = _96;
    version 10
    ptr-info 0x7f034c9f11b0>
trace fucntion name:malloc 

 ================== trace ================== 
trace fucntion free:2 

======================================================================
[40;31m    branch possiable have return or exit  [0m
_102 = ret_41;
bb index := 15
# VUSE <.MEM_8>
return 0;
In function â€˜mainâ€™:
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
_102 = ret_41;
bb index := 15
# VUSE <.MEM_8>
return 0;
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================
_102 = ret_41;
At top level:
lto1: warning: use location

======================================================================
[40;31m    branch possiable have return or exit  [0m
_42 = ret_41;
bb index := 15
# VUSE <.MEM_8>
return 0;
In function â€˜mainâ€™:
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
_42 = ret_41;
bb index := 15
# VUSE <.MEM_8>
return 0;
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================
_42 = ret_41;
At top level:
test.c:87:9: warning: use location
  return ret;
         ^

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7f034c9e7f78
    type <pointer_type 0x7f034c9c65e8
        type <integer_type 0x7f034c9c6dc8 char public string-flag QI
            size <integer_cst 0x7f034ce9ccd8 constant 8>
            unit size <integer_cst 0x7f034ce9ccf0 constant 1>
            align 8 symtab 0 alias set -1 canonical type 0x7f034ceb03f0 precision 8 min <integer_cst 0x7f034c9c91b0 -128> max <integer_cst 0x7f034c9c9198 127>
            pointer_to_this <pointer_type 0x7f034c9c65e8>>
        public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality context <translation_unit_decl 0x7f034cea7168 test.c>
        pointer_to_this <pointer_type 0x7f034c9d2bd0>>
   
    def_stmt _10 = _96;
    version 10
    ptr-info 0x7f034c9f11b0>

 ================== Start Use after free Check ================== 

============================================================
# .MEM_109 = VDEF <.MEM_108>
free (progname_copy_19);
test.c:135:2: warning: Use after free error!: free location 
  xfree(progname_copy);
  ^
_35 = PHI <_28(19), _33(21), _34(22)>
lto1: warning: use location

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
# .MEM_111 = VDEF <.MEM_110>
free (progname_copy_19);
test.c:124:4: warning: Use after free error!: free location 
    xfree(progname_copy);
    ^
_35 = PHI <_28(19), _33(21), _34(22)>
lto1: warning: use location

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:0 [0m

======================================================================

======================================================================
[40;31m 	this stmt need double check [0m

======================================================================

dot graph START

======================================================================
 <addr_expr 0x7f034c9ea300
    type <pointer_type 0x7f034c9d2f18
        type <array_type 0x7f034c9d2e70 type <integer_type 0x7f034c9c6dc8 char>
            BLK
            size <integer_cst 0x7f034c9c9468 constant 56>
            unit size <integer_cst 0x7f034c9c9450 constant 7>
            align 8 symtab 0 alias set -1 structural equality domain <integer_type 0x7f034c9d2dc8>
            pointer_to_this <pointer_type 0x7f034c9d2f18>>
        unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality>
    readonly constant
    arg 0 <string_cst 0x7f034c9bad20 type <array_type 0x7f034c9d2e70>
        readonly constant static "LC_ALL\000">
    test.c:110:12 start: test.c:110:12 finish: test.c:110:12>

 ================== trace ptable================== 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr--------
this other function -----------

======================================================================
[40;35m  	Looserules free count:0 [0m

======================================================================

======================================================================
[40;31m 	Can't find this fucntion in Pointer table [0m
[40;31m 	Possiable no other stmt relate with this stmt [0m

======================================================================

dot graph START

======================================================================
 <ssa_name 0x7f034c9eb090
    type <pointer_type 0x7f034c9c6f18
        type <integer_type 0x7f034c9c6e70 char readonly public string-flag QI
            size <integer_cst 0x7f034ce9ccd8 constant 8>
            unit size <integer_cst 0x7f034ce9ccf0 constant 1>
            align 8 symtab 0 alias set -1 canonical type 0x7f034ceb03f0 precision 8 min <integer_cst 0x7f034c9c91b0 -128> max <integer_cst 0x7f034c9c9198 127>
            pointer_to_this <pointer_type 0x7f034c9c6f18>>
        public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality>
   
    def_stmt _14 = (const char *) _13;
    version 14
    ptr-info 0x7f034c9f11e0>
_14 = (const char *) _13;

 ================== trace ptable================== 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr--------
this other function -----------
 
 Start check Pointer Collect  

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_99 = VDEF <.MEM_98>
oldloc_15 = strdup (_14);
bb index := 15
# VUSE <.MEM_8>
return 0;
In function â€˜mainâ€™:
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_99 = VDEF <.MEM_98>
oldloc_15 = strdup (_14);
bb index := 15
# VUSE <.MEM_8>
return 0;
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================
oldloc_15 = strdup (_14);
At top level:
test.c:110:10: warning: use location
   oldloc = xstrdup (setlocale (LC_ALL, NULL));
          ^
this stmt is child function---strdup-----

 ================== trace ================== 
 <ssa_name 0x7f034c9eb090
    type <pointer_type 0x7f034c9c6f18
        type <integer_type 0x7f034c9c6e70 char readonly public string-flag QI
            size <integer_cst 0x7f034ce9ccd8 constant 8>
            unit size <integer_cst 0x7f034ce9ccf0 constant 1>
            align 8 symtab 0 alias set -1 canonical type 0x7f034ceb03f0 precision 8 min <integer_cst 0x7f034c9c91b0 -128> max <integer_cst 0x7f034c9c9198 127>
            pointer_to_this <pointer_type 0x7f034c9c6f18>>
        public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality>
   
    def_stmt _14 = (const char *) _13;
    version 14
    ptr-info 0x7f034c9f11e0>
trace fucntion name:strdup 

 ================== trace ================== 
trace fucntion free:0 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_107 = VDEF <.MEM_106>
free (oldloc_15);
bb index := 25
# VUSE <.MEM_8>
return 0;
In function â€˜mainâ€™:
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 25 ,possiable got to succ := 26

======================================================================
free (oldloc_15);
At top level:
test.c:129:3: warning: use location
   xfree (oldloc);
   ^
this stmt is child function---free-----

 ================== find ================== 
free (oldloc_15);
test.c:129:3: warning: use location
[40;32m    HAS FREE STMT count:1 name:free [0m

 ================== find ================== 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_106 = VDEF <.MEM_88>
setlocale ("LC_ALL", oldloc_15);
bb index := 25
# VUSE <.MEM_8>
return 0;
In function â€˜mainâ€™:
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 25 ,possiable got to succ := 26

======================================================================
setlocale ("LC_ALL", oldloc_15);
At top level:
test.c:128:3: warning: use location
   setlocale (LC_ALL, oldloc);
   ^
this stmt is child function---setlocale-----

 ================== trace ================== 
 <ssa_name 0x7f034c9eb090
    type <pointer_type 0x7f034c9c6f18
        type <integer_type 0x7f034c9c6e70 char readonly public string-flag QI
            size <integer_cst 0x7f034ce9ccd8 constant 8>
            unit size <integer_cst 0x7f034ce9ccf0 constant 1>
            align 8 symtab 0 alias set -1 canonical type 0x7f034ceb03f0 precision 8 min <integer_cst 0x7f034c9c91b0 -128> max <integer_cst 0x7f034c9c9198 127>
            pointer_to_this <pointer_type 0x7f034c9c6f18>>
        public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality>
   
    def_stmt _14 = (const char *) _13;
    version 14
    ptr-info 0x7f034c9f11e0>
trace fucntion name:setlocale 

 ================== trace ================== 
trace fucntion free:1 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_110 = VDEF <.MEM_88>
free (oldloc_15);
bb index := 24
# VUSE <.MEM_8>
return 0;
In function â€˜mainâ€™:
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 24 ,possiable got to succ := 26

======================================================================
free (oldloc_15);
At top level:
test.c:123:7: warning: use location
       xfree (oldloc);
       ^
this stmt is child function---free-----

 ================== find ================== 
free (oldloc_15);
test.c:123:7: warning: use location
[40;32m    HAS FREE STMT count:2 name:free [0m

 ================== find ================== 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_113 = VDEF <.MEM_101>
free (oldloc_15);
bb index := 16
# VUSE <.MEM_8>
return 0;
In function â€˜mainâ€™:
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 16 ,possiable got to succ := 26

======================================================================
free (oldloc_15);
At top level:
test.c:116:7: warning: use location
       xfree (oldloc);
       ^
this stmt is child function---free-----

 ================== find ================== 
free (oldloc_15);
test.c:116:7: warning: use location
[40;32m    HAS FREE STMT count:3 name:free [0m

 ================== find ================== 

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7f034c9eb090
    type <pointer_type 0x7f034c9c6f18
        type <integer_type 0x7f034c9c6e70 char readonly public string-flag QI
            size <integer_cst 0x7f034ce9ccd8 constant 8>
            unit size <integer_cst 0x7f034ce9ccf0 constant 1>
            align 8 symtab 0 alias set -1 canonical type 0x7f034ceb03f0 precision 8 min <integer_cst 0x7f034c9c91b0 -128> max <integer_cst 0x7f034c9c9198 127>
            pointer_to_this <pointer_type 0x7f034c9c6f18>>
        public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality>
   
    def_stmt _14 = (const char *) _13;
    version 14
    ptr-info 0x7f034c9f11e0>
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_113 = VDEF <.MEM_101>
free (oldloc_15);
test.c:116:7: warning: use location
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_110 = VDEF <.MEM_88>
free (oldloc_15);
test.c:123:7: warning: use location
       xfree (oldloc);
       ^
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_111 = VDEF <.MEM_110>
free (progname_copy_19);
test.c:124:4: warning: use location
    xfree(progname_copy);
    ^
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_107 = VDEF <.MEM_106>
free (oldloc_15);
test.c:129:3: warning: use location
   xfree (oldloc);
   ^
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_109 = VDEF <.MEM_108>
free (progname_copy_19);
test.c:135:2: warning: use location
  xfree(progname_copy);
  ^

 ================== Start Use after free Check ================== 

============================================================
# .MEM_110 = VDEF <.MEM_88>
free (oldloc_15);
test.c:123:7: warning: Use after free error!: free location 
       xfree (oldloc);
       ^
# .MEM_106 = VDEF <.MEM_88>
setlocale ("LC_ALL", oldloc_15);
test.c:128:3: warning: use location
   setlocale (LC_ALL, oldloc);
   ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
# .MEM_113 = VDEF <.MEM_101>
free (oldloc_15);
test.c:116:7: warning: Use after free error!: free location 
       xfree (oldloc);
       ^
# .MEM_106 = VDEF <.MEM_88>
setlocale ("LC_ALL", oldloc_15);
test.c:128:3: warning: use location
   setlocale (LC_ALL, oldloc);
   ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_113 = VDEF <.MEM_101>
free (oldloc_15);
test.c:116:7: warning: Use after free error!: free location 
       xfree (oldloc);
       ^
# .MEM_106 = VDEF <.MEM_88>
setlocale ("LC_ALL", oldloc_15);
test.c:128:3: warning: use location
   setlocale (LC_ALL, oldloc);
   ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_110 = VDEF <.MEM_88>
free (oldloc_15);
test.c:123:7: warning: Use after free error!: free location 
       xfree (oldloc);
       ^
# .MEM_106 = VDEF <.MEM_88>
setlocale ("LC_ALL", oldloc_15);
test.c:128:3: warning: use location
   setlocale (LC_ALL, oldloc);
   ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_111 = VDEF <.MEM_110>
free (progname_copy_19);
test.c:124:4: warning: Use after free error!: free location 
    xfree(progname_copy);
    ^
# .MEM_106 = VDEF <.MEM_88>
setlocale ("LC_ALL", oldloc_15);
test.c:128:3: warning: use location
   setlocale (LC_ALL, oldloc);
   ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:5 [0m

======================================================================

======================================================================
[40;31m  	possible double free :3 [0m

======================================================================

dot graph START

======================================================================
 <addr_expr 0x7f034c9ea3e0
    type <pointer_type 0x7f034c9d2f18
        type <array_type 0x7f034c9d2e70 type <integer_type 0x7f034c9c6dc8 char>
            BLK
            size <integer_cst 0x7f034c9c9468 constant 56>
            unit size <integer_cst 0x7f034c9c9450 constant 7>
            align 8 symtab 0 alias set -1 structural equality domain <integer_type 0x7f034c9d2dc8>
            pointer_to_this <pointer_type 0x7f034c9d2f18>>
        unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality>
    readonly constant
    arg 0 <string_cst 0x7f034c9bada0 type <array_type 0x7f034c9d2e70>
        readonly constant static "LC_ALL\000">
    test.c:111:14 start: test.c:111:14 finish: test.c:111:14>

 ================== trace ptable================== 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr--------
this other function -----------

======================================================================
[40;35m  	Looserules free count:0 [0m

======================================================================

======================================================================
[40;31m 	Can't find this fucntion in Pointer table [0m
[40;31m 	Possiable no other stmt relate with this stmt [0m

======================================================================

dot graph START

======================================================================
 <ssa_name 0x7f034cea4678
    type <pointer_type 0x7f034c9c65e8
        type <integer_type 0x7f034c9c6dc8 char public string-flag QI
            size <integer_cst 0x7f034ce9ccd8 constant 8>
            unit size <integer_cst 0x7f034ce9ccf0 constant 1>
            align 8 symtab 0 alias set -1 canonical type 0x7f034ceb03f0 precision 8 min <integer_cst 0x7f034c9c91b0 -128> max <integer_cst 0x7f034c9c9198 127>
            pointer_to_this <pointer_type 0x7f034c9c65e8>>
        public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality context <translation_unit_decl 0x7f034cea7168 test.c>
        pointer_to_this <pointer_type 0x7f034c9d2bd0>>
    var <var_decl 0x7f034dc31cf0 progname>
    def_stmt progname_11 = concat (_10, "bin");
    version 11
    ptr-info 0x7f034c9f11c8>
# .MEM_97 = VDEF <.MEM_87>
progname_11 = concat (_10, "bin");

 ================== trace ptable================== 
trace fucntion name:concat 
[40;44m =======trace_function_path concat  function_call count: 3 level :-100========  [0m
[40;42m =======pre add _ fucntion:memcpy========= [0m
[40;46m =======add node_fun stack:memcpy========= [0m
[40;42m =======pre add _ fucntion:strlen========= [0m
[40;46m =======add node_fun stack:strlen========= [0m
[40;42m =======pre add _ fucntion:malloc========= [0m
[40;46m =======add node_fun stack:malloc========= [0m

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr---concat-----
this other function ------concat-----
 
 Start check Pointer Collect  

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_97 = VDEF <.MEM_87>
progname_11 = concat (_10, "bin");
bb index := 15
# VUSE <.MEM_8>
return 0;
In function â€˜mainâ€™:
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_97 = VDEF <.MEM_87>
progname_11 = concat (_10, "bin");
bb index := 15
# VUSE <.MEM_8>
return 0;
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================
progname_11 = concat (_10, "bin");
At top level:
test.c:109:12: warning: use location
   progname = concat (ldirname (python_libdir), "bin");
            ^
this stmt is child function---concat-----

 ================== trace ================== 
 <ssa_name 0x7f034cea4678
    type <pointer_type 0x7f034c9c65e8
        type <integer_type 0x7f034c9c6dc8 char public string-flag QI
            size <integer_cst 0x7f034ce9ccd8 constant 8>
            unit size <integer_cst 0x7f034ce9ccf0 constant 1>
            align 8 symtab 0 alias set -1 canonical type 0x7f034ceb03f0 precision 8 min <integer_cst 0x7f034c9c91b0 -128> max <integer_cst 0x7f034c9c9198 127>
            pointer_to_this <pointer_type 0x7f034c9c65e8>>
        public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality context <translation_unit_decl 0x7f034cea7168 test.c>
        pointer_to_this <pointer_type 0x7f034c9d2bd0>>
    var <var_decl 0x7f034dc31cf0 progname>
    def_stmt progname_11 = concat (_10, "bin");
    version 11
    ptr-info 0x7f034c9f11c8>
trace fucntion name:concat 
[40;44m =======trace_function_path concat  function_call count: 3 level :0========  [0m
[40;36m ======= node_fun:concat========= [0m
[40;36m ======= find relate stmt with progname ========= [0m
[40;36m ======= relate stmt argument:progname ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:memcpy========= [0m
[40;46m =======add node_fun stack:memcpy========= [0m
[40;42m =======pre add _ fucntion:strlen========= [0m
[40;46m =======add node_fun stack:strlen========= [0m
[40;42m =======pre add _ fucntion:malloc========= [0m
[40;46m =======add node_fun stack:malloc========= [0m

 ================== trace ================== 
trace fucntion free:0 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# VUSE <.MEM_100>
progsize_16 = strlen (progname_11);
bb index := 15
# VUSE <.MEM_8>
return 0;
In function â€˜mainâ€™:
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# VUSE <.MEM_100>
progsize_16 = strlen (progname_11);
bb index := 15
# VUSE <.MEM_8>
return 0;
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================
progsize_16 = strlen (progname_11);
At top level:
test.c:112:12: warning: use location
   progsize = strlen (progname);
            ^
this stmt is child function---strlen-----

 ================== trace ================== 
 <ssa_name 0x7f034cea4678
    type <pointer_type 0x7f034c9c65e8
        type <integer_type 0x7f034c9c6dc8 char public string-flag QI
            size <integer_cst 0x7f034ce9ccd8 constant 8>
            unit size <integer_cst 0x7f034ce9ccf0 constant 1>
            align 8 symtab 0 alias set -1 canonical type 0x7f034ceb03f0 precision 8 min <integer_cst 0x7f034c9c91b0 -128> max <integer_cst 0x7f034c9c9198 127>
            pointer_to_this <pointer_type 0x7f034c9c65e8>>
        public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality context <translation_unit_decl 0x7f034cea7168 test.c>
        pointer_to_this <pointer_type 0x7f034c9d2bd0>>
    var <var_decl 0x7f034dc31cf0 progname>
    def_stmt progname_11 = concat (_10, "bin");
    version 11
    ptr-info 0x7f034c9f11c8>
trace fucntion name:strlen 

 ================== trace ================== 
trace fucntion free:0 
_23 = progsize_16 + 1;
test.c:120:11: warning: use location
   count = mbstowcs (progname_copy, progname, progsize + 1);
           ^
_25 = __builtin_constant_p (_23);
this stmt is child function---__builtin_constant_p-----

 ================== trace ================== 
 <ssa_name 0x7f034cea4678
    type <pointer_type 0x7f034c9c65e8
        type <integer_type 0x7f034c9c6dc8 char public string-flag QI
            size <integer_cst 0x7f034ce9ccd8 constant 8>
            unit size <integer_cst 0x7f034ce9ccf0 constant 1>
            align 8 symtab 0 alias set -1 canonical type 0x7f034ceb03f0 precision 8 min <integer_cst 0x7f034c9c91b0 -128> max <integer_cst 0x7f034c9c9198 127>
            pointer_to_this <pointer_type 0x7f034c9c65e8>>
        public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality context <translation_unit_decl 0x7f034cea7168 test.c>
        pointer_to_this <pointer_type 0x7f034c9d2bd0>>
    var <var_decl 0x7f034dc31cf0 progname>
    def_stmt progname_11 = concat (_10, "bin");
    version 11
    ptr-info 0x7f034c9f11c8>
trace fucntion name:__builtin_constant_p 

 ================== trace ================== 
trace fucntion free:0 
if (_25 == 0)
if (_25 == 0)

 ================== find cond branch ================= 
Cond in fucntion main basic block 18
 ================== possible direct basic block ================= 
from main basic block 19
 ================== possible direct basic block ================= 
from main basic block 20
 ================== warring ================== 
[40;35m    need check this branch possible have return or exit stmt [0m

 ================== warring ================== 

 ================== find cond branch ================= 
_34 = __mbstowcs_alias (progname_copy_19, progname_11, _23);
this stmt is child function---__mbstowcs_alias-----

 ================== trace ================== 
 <ssa_name 0x7f034cea4678
    type <pointer_type 0x7f034c9c65e8
        type <integer_type 0x7f034c9c6dc8 char public string-flag QI
            size <integer_cst 0x7f034ce9ccd8 constant 8>
            unit size <integer_cst 0x7f034ce9ccf0 constant 1>
            align 8 symtab 0 alias set -1 canonical type 0x7f034ceb03f0 precision 8 min <integer_cst 0x7f034c9c91b0 -128> max <integer_cst 0x7f034c9c9198 127>
            pointer_to_this <pointer_type 0x7f034c9c65e8>>
        public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality context <translation_unit_decl 0x7f034cea7168 test.c>
        pointer_to_this <pointer_type 0x7f034c9d2bd0>>
    var <var_decl 0x7f034dc31cf0 progname>
    def_stmt progname_11 = concat (_10, "bin");
    version 11
    ptr-info 0x7f034c9f11c8>
trace fucntion name:__mbstowcs_alias 

 ================== trace ================== 
trace fucntion free:0 
_35 = PHI <_28(19), _33(21), _34(22)>
lto1: warning: use location
this stmt have mutiple branch --------
if (_35 == 18446744073709551615)
test.c:121:6: warning: use location
   if (count == (size_t) -1)
      ^
if (_35 == 18446744073709551615)

 ================== find cond branch ================= 
test.c:121:6: warning: use location
Cond in fucntion main basic block 23
 ================== possible direct basic block ================= 
from main basic block 24
 ================== possible direct basic block ================= 
from main basic block 25
 ================== warring ================== 
[40;35m    need check this branch possible have return or exit stmt [0m

 ================== warring ================== 

 ================== find cond branch ================= 
_31 = __builtin_object_size (progname_copy_19, 1);
this stmt is child function---__builtin_object_size-----

 ================== trace ================== 
 <ssa_name 0x7f034cea4678
    type <pointer_type 0x7f034c9c65e8
        type <integer_type 0x7f034c9c6dc8 char public string-flag QI
            size <integer_cst 0x7f034ce9ccd8 constant 8>
            unit size <integer_cst 0x7f034ce9ccf0 constant 1>
            align 8 symtab 0 alias set -1 canonical type 0x7f034ceb03f0 precision 8 min <integer_cst 0x7f034c9c91b0 -128> max <integer_cst 0x7f034c9c9198 127>
            pointer_to_this <pointer_type 0x7f034c9c65e8>>
        public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality context <translation_unit_decl 0x7f034cea7168 test.c>
        pointer_to_this <pointer_type 0x7f034c9d2bd0>>
    var <var_decl 0x7f034dc31cf0 progname>
    def_stmt progname_11 = concat (_10, "bin");
    version 11
    ptr-info 0x7f034c9f11c8>
trace fucntion name:__builtin_object_size 

 ================== trace ================== 
trace fucntion free:0 
_29 = __builtin_object_size (progname_copy_19, 1);
this stmt is child function---__builtin_object_size-----

 ================== trace ================== 
 <ssa_name 0x7f034cea4678
    type <pointer_type 0x7f034c9c65e8
        type <integer_type 0x7f034c9c6dc8 char public string-flag QI
            size <integer_cst 0x7f034ce9ccd8 constant 8>
            unit size <integer_cst 0x7f034ce9ccf0 constant 1>
            align 8 symtab 0 alias set -1 canonical type 0x7f034ceb03f0 precision 8 min <integer_cst 0x7f034c9c91b0 -128> max <integer_cst 0x7f034c9c9198 127>
            pointer_to_this <pointer_type 0x7f034c9c65e8>>
        public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality context <translation_unit_decl 0x7f034cea7168 test.c>
        pointer_to_this <pointer_type 0x7f034c9d2bd0>>
    var <var_decl 0x7f034dc31cf0 progname>
    def_stmt progname_11 = concat (_10, "bin");
    version 11
    ptr-info 0x7f034c9f11c8>
trace fucntion name:__builtin_object_size 

 ================== trace ================== 
trace fucntion free:0 
_30 = _29 / 4;
_26 = __builtin_object_size (progname_copy_19, 1);
this stmt is child function---__builtin_object_size-----

 ================== trace ================== 
 <ssa_name 0x7f034cea4678
    type <pointer_type 0x7f034c9c65e8
        type <integer_type 0x7f034c9c6dc8 char public string-flag QI
            size <integer_cst 0x7f034ce9ccd8 constant 8>
            unit size <integer_cst 0x7f034ce9ccf0 constant 1>
            align 8 symtab 0 alias set -1 canonical type 0x7f034ceb03f0 precision 8 min <integer_cst 0x7f034c9c91b0 -128> max <integer_cst 0x7f034c9c9198 127>
            pointer_to_this <pointer_type 0x7f034c9c65e8>>
        public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality context <translation_unit_decl 0x7f034cea7168 test.c>
        pointer_to_this <pointer_type 0x7f034c9d2bd0>>
    var <var_decl 0x7f034dc31cf0 progname>
    def_stmt progname_11 = concat (_10, "bin");
    version 11
    ptr-info 0x7f034c9f11c8>
trace fucntion name:__builtin_object_size 

 ================== trace ================== 
trace fucntion free:0 
_27 = _26 / 4;
_28 = __mbstowcs_chk (progname_copy_19, progname_11, _23, _27);
this stmt is child function---__mbstowcs_chk-----

 ================== trace ================== 
 <ssa_name 0x7f034cea4678
    type <pointer_type 0x7f034c9c65e8
        type <integer_type 0x7f034c9c6dc8 char public string-flag QI
            size <integer_cst 0x7f034ce9ccd8 constant 8>
            unit size <integer_cst 0x7f034ce9ccf0 constant 1>
            align 8 symtab 0 alias set -1 canonical type 0x7f034ceb03f0 precision 8 min <integer_cst 0x7f034c9c91b0 -128> max <integer_cst 0x7f034c9c9198 127>
            pointer_to_this <pointer_type 0x7f034c9c65e8>>
        public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality context <translation_unit_decl 0x7f034cea7168 test.c>
        pointer_to_this <pointer_type 0x7f034c9d2bd0>>
    var <var_decl 0x7f034dc31cf0 progname>
    def_stmt progname_11 = concat (_10, "bin");
    version 11
    ptr-info 0x7f034c9f11c8>
trace fucntion name:__mbstowcs_chk 

 ================== trace ================== 
trace fucntion free:0 
_24 = __builtin_object_size (progname_copy_19, 1);
this stmt is child function---__builtin_object_size-----

 ================== trace ================== 
 <ssa_name 0x7f034cea4678
    type <pointer_type 0x7f034c9c65e8
        type <integer_type 0x7f034c9c6dc8 char public string-flag QI
            size <integer_cst 0x7f034ce9ccd8 constant 8>
            unit size <integer_cst 0x7f034ce9ccf0 constant 1>
            align 8 symtab 0 alias set -1 canonical type 0x7f034ceb03f0 precision 8 min <integer_cst 0x7f034c9c91b0 -128> max <integer_cst 0x7f034c9c9198 127>
            pointer_to_this <pointer_type 0x7f034c9c65e8>>
        public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality context <translation_unit_decl 0x7f034cea7168 test.c>
        pointer_to_this <pointer_type 0x7f034c9d2bd0>>
    var <var_decl 0x7f034dc31cf0 progname>
    def_stmt progname_11 = concat (_10, "bin");
    version 11
    ptr-info 0x7f034c9f11c8>
trace fucntion name:__builtin_object_size 

 ================== trace ================== 
trace fucntion free:0 
if (_24 != 18446744073709551615)
if (_24 != 18446744073709551615)

 ================== find cond branch ================= 
Cond in fucntion main basic block 17
 ================== possible direct basic block ================= 
from main basic block 18
 ================== possible direct basic block ================= 
from main basic block 22
 ================== warring ================== 
[40;35m    need check this branch possible have return or exit stmt [0m

 ================== warring ================== 

 ================== find cond branch ================= 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_109 = VDEF <.MEM_108>
free (progname_copy_19);
bb index := 25
# VUSE <.MEM_8>
return 0;
In function â€˜mainâ€™:
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 25 ,possiable got to succ := 26

======================================================================
free (progname_copy_19);
At top level:
test.c:135:2: warning: use location
  xfree(progname_copy);
  ^
this stmt is child function---free-----

 ================== find ================== 
free (progname_copy_19);
test.c:135:2: warning: use location
[40;32m    HAS FREE STMT count:1 name:free [0m

 ================== find ================== 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_111 = VDEF <.MEM_110>
free (progname_copy_19);
bb index := 24
# VUSE <.MEM_8>
return 0;
In function â€˜mainâ€™:
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 24 ,possiable got to succ := 26

======================================================================
free (progname_copy_19);
At top level:
test.c:124:4: warning: use location
    xfree(progname_copy);
    ^
this stmt is child function---free-----

 ================== find ================== 
free (progname_copy_19);
test.c:124:4: warning: use location
[40;32m    HAS FREE STMT count:2 name:free [0m

 ================== find ================== 
_33 = __mbstowcs_chk_warn (progname_copy_19, progname_11, _23, _32);
this stmt is child function---__mbstowcs_chk_warn-----

 ================== trace ================== 
 <ssa_name 0x7f034cea4678
    type <pointer_type 0x7f034c9c65e8
        type <integer_type 0x7f034c9c6dc8 char public string-flag QI
            size <integer_cst 0x7f034ce9ccd8 constant 8>
            unit size <integer_cst 0x7f034ce9ccf0 constant 1>
            align 8 symtab 0 alias set -1 canonical type 0x7f034ceb03f0 precision 8 min <integer_cst 0x7f034c9c91b0 -128> max <integer_cst 0x7f034c9c9198 127>
            pointer_to_this <pointer_type 0x7f034c9c65e8>>
        public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality context <translation_unit_decl 0x7f034cea7168 test.c>
        pointer_to_this <pointer_type 0x7f034c9d2bd0>>
    var <var_decl 0x7f034dc31cf0 progname>
    def_stmt progname_11 = concat (_10, "bin");
    version 11
    ptr-info 0x7f034c9f11c8>
trace fucntion name:__mbstowcs_chk_warn 

 ================== trace ================== 
trace fucntion free:2 

======================================================================
[40;31m    branch possiable have return or exit  [0m
if (progname_copy_19 == 0B)
bb index := 15
# VUSE <.MEM_8>
return 0;
In function â€˜mainâ€™:
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
if (progname_copy_19 == 0B)
bb index := 15
# VUSE <.MEM_8>
return 0;
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================
if (progname_copy_19 == 0B)
At top level:
test.c:114:6: warning: use location
   if (!progname_copy)
      ^
if (progname_copy_19 == 0B)

 ================== find cond branch ================= 
test.c:114:6: warning: use location
Cond in fucntion main basic block 15
 ================== possible direct basic block ================= 
from main basic block 16
 ================== possible direct basic block ================= 
from main basic block 17
 ================== warring ================== 
[40;35m    need check this branch possible have return or exit stmt [0m

 ================== warring ================== 

 ================== find cond branch ================= 

======================================================================
[40;31m    branch possiable have return or exit  [0m
_17 = progsize_16 + 1;
bb index := 15
# VUSE <.MEM_8>
return 0;
In function â€˜mainâ€™:
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
_17 = progsize_16 + 1;
bb index := 15
# VUSE <.MEM_8>
return 0;
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================
_17 = progsize_16 + 1;
At top level:
test.c:113:31: warning: use location
   progname_copy = (wchar_t *) PyMem_Malloc ((progsize + 1) * sizeof (wchar_t));
                               ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
_18 = _17 * 4;
bb index := 15
# VUSE <.MEM_8>
return 0;
In function â€˜mainâ€™:
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
_18 = _17 * 4;
bb index := 15
# VUSE <.MEM_8>
return 0;
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================
_18 = _17 * 4;
At top level:
test.c:113:31: warning: use location

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_101 = VDEF <.MEM_100>
ret_41 = malloc (_18);
bb index := 15
# VUSE <.MEM_8>
return 0;
In function â€˜mainâ€™:
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_101 = VDEF <.MEM_100>
ret_41 = malloc (_18);
bb index := 15
# VUSE <.MEM_8>
return 0;
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================
ret_41 = malloc (_18);
At top level:
test.c:86:8: warning: use location
  void *ret = malloc(size);
        ^
this stmt is child function---malloc-----

 ================== trace ================== 
 <ssa_name 0x7f034cea4678
    type <pointer_type 0x7f034c9c65e8
        type <integer_type 0x7f034c9c6dc8 char public string-flag QI
            size <integer_cst 0x7f034ce9ccd8 constant 8>
            unit size <integer_cst 0x7f034ce9ccf0 constant 1>
            align 8 symtab 0 alias set -1 canonical type 0x7f034ceb03f0 precision 8 min <integer_cst 0x7f034c9c91b0 -128> max <integer_cst 0x7f034c9c9198 127>
            pointer_to_this <pointer_type 0x7f034c9c65e8>>
        public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality context <translation_unit_decl 0x7f034cea7168 test.c>
        pointer_to_this <pointer_type 0x7f034c9d2bd0>>
    var <var_decl 0x7f034dc31cf0 progname>
    def_stmt progname_11 = concat (_10, "bin");
    version 11
    ptr-info 0x7f034c9f11c8>
trace fucntion name:malloc 

 ================== trace ================== 
trace fucntion free:2 

======================================================================
[40;31m    branch possiable have return or exit  [0m
_102 = ret_41;
bb index := 15
# VUSE <.MEM_8>
return 0;
In function â€˜mainâ€™:
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
_102 = ret_41;
bb index := 15
# VUSE <.MEM_8>
return 0;
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================
_102 = ret_41;
At top level:
lto1: warning: use location

======================================================================
[40;31m    branch possiable have return or exit  [0m
_42 = ret_41;
bb index := 15
# VUSE <.MEM_8>
return 0;
In function â€˜mainâ€™:
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
_42 = ret_41;
bb index := 15
# VUSE <.MEM_8>
return 0;
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================
_42 = ret_41;
At top level:
test.c:87:9: warning: use location
  return ret;
         ^

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7f034cea4678
    type <pointer_type 0x7f034c9c65e8
        type <integer_type 0x7f034c9c6dc8 char public string-flag QI
            size <integer_cst 0x7f034ce9ccd8 constant 8>
            unit size <integer_cst 0x7f034ce9ccf0 constant 1>
            align 8 symtab 0 alias set -1 canonical type 0x7f034ceb03f0 precision 8 min <integer_cst 0x7f034c9c91b0 -128> max <integer_cst 0x7f034c9c9198 127>
            pointer_to_this <pointer_type 0x7f034c9c65e8>>
        public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality context <translation_unit_decl 0x7f034cea7168 test.c>
        pointer_to_this <pointer_type 0x7f034c9d2bd0>>
    var <var_decl 0x7f034dc31cf0 progname>
    def_stmt progname_11 = concat (_10, "bin");
    version 11
    ptr-info 0x7f034c9f11c8>

 ================== Start Use after free Check ================== 

============================================================
# .MEM_109 = VDEF <.MEM_108>
free (progname_copy_19);
test.c:135:2: warning: Use after free error!: free location 
  xfree(progname_copy);
  ^
_35 = PHI <_28(19), _33(21), _34(22)>
lto1: warning: use location

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
# .MEM_111 = VDEF <.MEM_110>
free (progname_copy_19);
test.c:124:4: warning: Use after free error!: free location 
    xfree(progname_copy);
    ^
_35 = PHI <_28(19), _33(21), _34(22)>
lto1: warning: use location

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:0 [0m

======================================================================

======================================================================
[40;31m 	this stmt need double check [0m

======================================================================

dot graph START

======================================================================
 <ssa_name 0x7f034c9eb1b0
    type <integer_type 0x7f034ceb07e0 long unsigned int public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 canonical type 0x7f034ceb0738 precision 64 min <integer_cst 0x7f034ce9ceb8 0> max <integer_cst 0x7f034ce9e500 18446744073709551615>
        pointer_to_this <pointer_type 0x7f034cebc9d8>>
   
    def_stmt _18 = _17 * 4;
    version 18>
_18 = _17 * 4;

 ================== trace ptable================== 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr--------
this other function -----------
 
 Start check Pointer Collect  

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_101 = VDEF <.MEM_100>
ret_41 = malloc (_18);
bb index := 15
# VUSE <.MEM_8>
return 0;
In function â€˜mainâ€™:
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_101 = VDEF <.MEM_100>
ret_41 = malloc (_18);
bb index := 15
# VUSE <.MEM_8>
return 0;
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================
ret_41 = malloc (_18);
At top level:
test.c:86:8: warning: use location
  void *ret = malloc(size);
        ^
this stmt is child function---malloc-----

 ================== trace ================== 
 <ssa_name 0x7f034c9eb1b0
    type <integer_type 0x7f034ceb07e0 long unsigned int public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 canonical type 0x7f034ceb0738 precision 64 min <integer_cst 0x7f034ce9ceb8 0> max <integer_cst 0x7f034ce9e500 18446744073709551615>
        pointer_to_this <pointer_type 0x7f034cebc9d8>>
   
    def_stmt _18 = _17 * 4;
    version 18>
trace fucntion name:malloc 

 ================== trace ================== 
trace fucntion free:0 

======================================================================
[40;31m    branch possiable have return or exit  [0m
_102 = ret_41;
bb index := 15
# VUSE <.MEM_8>
return 0;
In function â€˜mainâ€™:
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
_102 = ret_41;
bb index := 15
# VUSE <.MEM_8>
return 0;
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================
_102 = ret_41;
At top level:
lto1: warning: use location

======================================================================
[40;31m    branch possiable have return or exit  [0m
progname_copy_19 = _102;
bb index := 15
# VUSE <.MEM_8>
return 0;
In function â€˜mainâ€™:
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
progname_copy_19 = _102;
bb index := 15
# VUSE <.MEM_8>
return 0;
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================
progname_copy_19 = _102;
At top level:
test.c:113:17: warning: use location
   progname_copy = (wchar_t *) PyMem_Malloc ((progsize + 1) * sizeof (wchar_t));
                 ^
_31 = __builtin_object_size (progname_copy_19, 1);
this stmt is child function---__builtin_object_size-----

 ================== trace ================== 
 <ssa_name 0x7f034c9eb1b0
    type <integer_type 0x7f034ceb07e0 long unsigned int public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 canonical type 0x7f034ceb0738 precision 64 min <integer_cst 0x7f034ce9ceb8 0> max <integer_cst 0x7f034ce9e500 18446744073709551615>
        pointer_to_this <pointer_type 0x7f034cebc9d8>>
   
    def_stmt _18 = _17 * 4;
    version 18>
trace fucntion name:__builtin_object_size 

 ================== trace ================== 
trace fucntion free:0 
_29 = __builtin_object_size (progname_copy_19, 1);
this stmt is child function---__builtin_object_size-----

 ================== trace ================== 
 <ssa_name 0x7f034c9eb1b0
    type <integer_type 0x7f034ceb07e0 long unsigned int public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 canonical type 0x7f034ceb0738 precision 64 min <integer_cst 0x7f034ce9ceb8 0> max <integer_cst 0x7f034ce9e500 18446744073709551615>
        pointer_to_this <pointer_type 0x7f034cebc9d8>>
   
    def_stmt _18 = _17 * 4;
    version 18>
trace fucntion name:__builtin_object_size 

 ================== trace ================== 
trace fucntion free:0 
_30 = _29 / 4;
_26 = __builtin_object_size (progname_copy_19, 1);
this stmt is child function---__builtin_object_size-----

 ================== trace ================== 
 <ssa_name 0x7f034c9eb1b0
    type <integer_type 0x7f034ceb07e0 long unsigned int public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 canonical type 0x7f034ceb0738 precision 64 min <integer_cst 0x7f034ce9ceb8 0> max <integer_cst 0x7f034ce9e500 18446744073709551615>
        pointer_to_this <pointer_type 0x7f034cebc9d8>>
   
    def_stmt _18 = _17 * 4;
    version 18>
trace fucntion name:__builtin_object_size 

 ================== trace ================== 
trace fucntion free:0 
_27 = _26 / 4;
_28 = __mbstowcs_chk (progname_copy_19, progname_11, _23, _27);
this stmt is child function---__mbstowcs_chk-----

 ================== trace ================== 
 <ssa_name 0x7f034c9eb1b0
    type <integer_type 0x7f034ceb07e0 long unsigned int public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 canonical type 0x7f034ceb0738 precision 64 min <integer_cst 0x7f034ce9ceb8 0> max <integer_cst 0x7f034ce9e500 18446744073709551615>
        pointer_to_this <pointer_type 0x7f034cebc9d8>>
   
    def_stmt _18 = _17 * 4;
    version 18>
trace fucntion name:__mbstowcs_chk 

 ================== trace ================== 
trace fucntion free:0 
_35 = PHI <_28(19), _33(21), _34(22)>
lto1: warning: use location
this stmt have mutiple branch --------
if (_35 == 18446744073709551615)
test.c:121:6: warning: use location
   if (count == (size_t) -1)
      ^
if (_35 == 18446744073709551615)

 ================== find cond branch ================= 
test.c:121:6: warning: use location
Cond in fucntion main basic block 23
 ================== possible direct basic block ================= 
from main basic block 24
 ================== possible direct basic block ================= 
from main basic block 25
 ================== warring ================== 
[40;35m    need check this branch possible have return or exit stmt [0m

 ================== warring ================== 

 ================== find cond branch ================= 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# VUSE <.MEM_100>
progsize_16 = strlen (progname_11);
bb index := 15
# VUSE <.MEM_8>
return 0;
In function â€˜mainâ€™:
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# VUSE <.MEM_100>
progsize_16 = strlen (progname_11);
bb index := 15
# VUSE <.MEM_8>
return 0;
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================
progsize_16 = strlen (progname_11);
At top level:
test.c:112:12: warning: use location
   progsize = strlen (progname);
            ^
this stmt is child function---strlen-----

 ================== trace ================== 
 <ssa_name 0x7f034c9eb1b0
    type <integer_type 0x7f034ceb07e0 long unsigned int public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 canonical type 0x7f034ceb0738 precision 64 min <integer_cst 0x7f034ce9ceb8 0> max <integer_cst 0x7f034ce9e500 18446744073709551615>
        pointer_to_this <pointer_type 0x7f034cebc9d8>>
   
    def_stmt _18 = _17 * 4;
    version 18>
trace fucntion name:strlen 

 ================== trace ================== 
trace fucntion free:0 
_23 = progsize_16 + 1;
test.c:120:11: warning: use location
   count = mbstowcs (progname_copy, progname, progsize + 1);
           ^
_25 = __builtin_constant_p (_23);
this stmt is child function---__builtin_constant_p-----

 ================== trace ================== 
 <ssa_name 0x7f034c9eb1b0
    type <integer_type 0x7f034ceb07e0 long unsigned int public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 canonical type 0x7f034ceb0738 precision 64 min <integer_cst 0x7f034ce9ceb8 0> max <integer_cst 0x7f034ce9e500 18446744073709551615>
        pointer_to_this <pointer_type 0x7f034cebc9d8>>
   
    def_stmt _18 = _17 * 4;
    version 18>
trace fucntion name:__builtin_constant_p 

 ================== trace ================== 
trace fucntion free:0 
if (_25 == 0)
if (_25 == 0)

 ================== find cond branch ================= 
Cond in fucntion main basic block 18
 ================== possible direct basic block ================= 
from main basic block 19
 ================== possible direct basic block ================= 
from main basic block 20
 ================== warring ================== 
[40;35m    need check this branch possible have return or exit stmt [0m

 ================== warring ================== 

 ================== find cond branch ================= 
_34 = __mbstowcs_alias (progname_copy_19, progname_11, _23);
this stmt is child function---__mbstowcs_alias-----

 ================== trace ================== 
 <ssa_name 0x7f034c9eb1b0
    type <integer_type 0x7f034ceb07e0 long unsigned int public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 canonical type 0x7f034ceb0738 precision 64 min <integer_cst 0x7f034ce9ceb8 0> max <integer_cst 0x7f034ce9e500 18446744073709551615>
        pointer_to_this <pointer_type 0x7f034cebc9d8>>
   
    def_stmt _18 = _17 * 4;
    version 18>
trace fucntion name:__mbstowcs_alias 

 ================== trace ================== 
trace fucntion free:0 
_33 = __mbstowcs_chk_warn (progname_copy_19, progname_11, _23, _32);
this stmt is child function---__mbstowcs_chk_warn-----

 ================== trace ================== 
 <ssa_name 0x7f034c9eb1b0
    type <integer_type 0x7f034ceb07e0 long unsigned int public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 canonical type 0x7f034ceb0738 precision 64 min <integer_cst 0x7f034ce9ceb8 0> max <integer_cst 0x7f034ce9e500 18446744073709551615>
        pointer_to_this <pointer_type 0x7f034cebc9d8>>
   
    def_stmt _18 = _17 * 4;
    version 18>
trace fucntion name:__mbstowcs_chk_warn 

 ================== trace ================== 
trace fucntion free:0 

======================================================================
[40;31m    branch possiable have return or exit  [0m
_17 = progsize_16 + 1;
bb index := 15
# VUSE <.MEM_8>
return 0;
In function â€˜mainâ€™:
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
_17 = progsize_16 + 1;
bb index := 15
# VUSE <.MEM_8>
return 0;
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================
_17 = progsize_16 + 1;
At top level:
test.c:113:31: warning: use location
   progname_copy = (wchar_t *) PyMem_Malloc ((progsize + 1) * sizeof (wchar_t));
                               ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
_18 = _17 * 4;
bb index := 15
# VUSE <.MEM_8>
return 0;
In function â€˜mainâ€™:
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
_18 = _17 * 4;
bb index := 15
# VUSE <.MEM_8>
return 0;
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================
_18 = _17 * 4;
At top level:
test.c:113:31: warning: use location
_24 = __builtin_object_size (progname_copy_19, 1);
this stmt is child function---__builtin_object_size-----

 ================== trace ================== 
 <ssa_name 0x7f034c9eb1b0
    type <integer_type 0x7f034ceb07e0 long unsigned int public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 canonical type 0x7f034ceb0738 precision 64 min <integer_cst 0x7f034ce9ceb8 0> max <integer_cst 0x7f034ce9e500 18446744073709551615>
        pointer_to_this <pointer_type 0x7f034cebc9d8>>
   
    def_stmt _18 = _17 * 4;
    version 18>
trace fucntion name:__builtin_object_size 

 ================== trace ================== 
trace fucntion free:0 
if (_24 != 18446744073709551615)
if (_24 != 18446744073709551615)

 ================== find cond branch ================= 
Cond in fucntion main basic block 17
 ================== possible direct basic block ================= 
from main basic block 18
 ================== possible direct basic block ================= 
from main basic block 22
 ================== warring ================== 
[40;35m    need check this branch possible have return or exit stmt [0m

 ================== warring ================== 

 ================== find cond branch ================= 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_109 = VDEF <.MEM_108>
free (progname_copy_19);
bb index := 25
# VUSE <.MEM_8>
return 0;
In function â€˜mainâ€™:
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 25 ,possiable got to succ := 26

======================================================================
free (progname_copy_19);
At top level:
test.c:135:2: warning: use location
  xfree(progname_copy);
  ^
this stmt is child function---free-----

 ================== find ================== 
free (progname_copy_19);
test.c:135:2: warning: use location
[40;32m    HAS FREE STMT count:1 name:free [0m

 ================== find ================== 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_111 = VDEF <.MEM_110>
free (progname_copy_19);
bb index := 24
# VUSE <.MEM_8>
return 0;
In function â€˜mainâ€™:
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 24 ,possiable got to succ := 26

======================================================================
free (progname_copy_19);
At top level:
test.c:124:4: warning: use location
    xfree(progname_copy);
    ^
this stmt is child function---free-----

 ================== find ================== 
free (progname_copy_19);
test.c:124:4: warning: use location
[40;32m    HAS FREE STMT count:2 name:free [0m

 ================== find ================== 

======================================================================
[40;31m    branch possiable have return or exit  [0m
if (progname_copy_19 == 0B)
bb index := 15
# VUSE <.MEM_8>
return 0;
In function â€˜mainâ€™:
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
if (progname_copy_19 == 0B)
bb index := 15
# VUSE <.MEM_8>
return 0;
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================
if (progname_copy_19 == 0B)
At top level:
test.c:114:6: warning: use location
   if (!progname_copy)
      ^
if (progname_copy_19 == 0B)

 ================== find cond branch ================= 
test.c:114:6: warning: use location
Cond in fucntion main basic block 15
 ================== possible direct basic block ================= 
from main basic block 16
 ================== possible direct basic block ================= 
from main basic block 17
 ================== warring ================== 
[40;35m    need check this branch possible have return or exit stmt [0m

 ================== warring ================== 

 ================== find cond branch ================= 

======================================================================
[40;31m    branch possiable have return or exit  [0m
_42 = ret_41;
bb index := 15
# VUSE <.MEM_8>
return 0;
In function â€˜mainâ€™:
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
_42 = ret_41;
bb index := 15
# VUSE <.MEM_8>
return 0;
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================
_42 = ret_41;
At top level:
test.c:87:9: warning: use location
  return ret;
         ^

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7f034c9eb1b0
    type <integer_type 0x7f034ceb07e0 long unsigned int public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 canonical type 0x7f034ceb0738 precision 64 min <integer_cst 0x7f034ce9ceb8 0> max <integer_cst 0x7f034ce9e500 18446744073709551615>
        pointer_to_this <pointer_type 0x7f034cebc9d8>>
   
    def_stmt _18 = _17 * 4;
    version 18>
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_113 = VDEF <.MEM_101>
free (oldloc_15);
test.c:116:7: warning: use location
       xfree (oldloc);
       ^
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_110 = VDEF <.MEM_88>
free (oldloc_15);
test.c:123:7: warning: use location
       xfree (oldloc);
       ^
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_111 = VDEF <.MEM_110>
free (progname_copy_19);
test.c:124:4: warning: use location
    xfree(progname_copy);
    ^
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_107 = VDEF <.MEM_106>
free (oldloc_15);
test.c:129:3: warning: use location
   xfree (oldloc);
   ^
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_109 = VDEF <.MEM_108>
free (progname_copy_19);
test.c:135:2: warning: use location
  xfree(progname_copy);
  ^

 ================== Start Use after free Check ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_113 = VDEF <.MEM_101>
free (oldloc_15);
test.c:116:7: warning: Use after free error!: free location 
       xfree (oldloc);
       ^
# VUSE <.MEM_101>
_31 = __builtin_object_size (progname_copy_19, 1);

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_113 = VDEF <.MEM_101>
free (oldloc_15);
test.c:116:7: warning: Use after free error!: free location 
# VUSE <.MEM_101>
_29 = __builtin_object_size (progname_copy_19, 1);

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_113 = VDEF <.MEM_101>
free (oldloc_15);
test.c:116:7: warning: Use after free error!: free location 
_30 = _29 / 4;

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_113 = VDEF <.MEM_101>
free (oldloc_15);
test.c:116:7: warning: Use after free error!: free location 
# VUSE <.MEM_101>
_26 = __builtin_object_size (progname_copy_19, 1);

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_113 = VDEF <.MEM_101>
free (oldloc_15);
test.c:116:7: warning: Use after free error!: free location 
_27 = _26 / 4;

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_113 = VDEF <.MEM_101>
free (oldloc_15);
test.c:116:7: warning: Use after free error!: free location 
# .MEM_104 = VDEF <.MEM_101>
_28 = __mbstowcs_chk (progname_copy_19, progname_11, _23, _27);

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
# .MEM_109 = VDEF <.MEM_108>
free (progname_copy_19);
test.c:135:2: warning: Use after free error!: free location 
  xfree(progname_copy);
  ^
_35 = PHI <_28(19), _33(21), _34(22)>
lto1: warning: use location

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
# .MEM_111 = VDEF <.MEM_110>
free (progname_copy_19);
test.c:124:4: warning: Use after free error!: free location 
    xfree(progname_copy);
    ^
_35 = PHI <_28(19), _33(21), _34(22)>
lto1: warning: use location

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_113 = VDEF <.MEM_101>
free (oldloc_15);
test.c:116:7: warning: Use after free error!: free location 
       xfree (oldloc);
       ^
_35 = PHI <_28(19), _33(21), _34(22)>
lto1: warning: use location

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_110 = VDEF <.MEM_88>
free (oldloc_15);
test.c:123:7: warning: Use after free error!: free location 
       xfree (oldloc);
       ^
_35 = PHI <_28(19), _33(21), _34(22)>
lto1: warning: use location

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_111 = VDEF <.MEM_110>
free (progname_copy_19);
test.c:124:4: warning: Use after free error!: free location 
    xfree(progname_copy);
    ^
_35 = PHI <_28(19), _33(21), _34(22)>
lto1: warning: use location

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_107 = VDEF <.MEM_106>
free (oldloc_15);
test.c:129:3: warning: Use after free error!: free location 
   xfree (oldloc);
   ^
_35 = PHI <_28(19), _33(21), _34(22)>
lto1: warning: use location

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_109 = VDEF <.MEM_108>
free (progname_copy_19);
test.c:135:2: warning: Use after free error!: free location 
  xfree(progname_copy);
  ^
_35 = PHI <_28(19), _33(21), _34(22)>
lto1: warning: use location

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_113 = VDEF <.MEM_101>
free (oldloc_15);
test.c:116:7: warning: Use after free error!: free location 
       xfree (oldloc);
       ^
if (_35 == 18446744073709551615)
test.c:121:6: warning: use location
   if (count == (size_t) -1)
      ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_113 = VDEF <.MEM_101>
free (oldloc_15);
test.c:116:7: warning: Use after free error!: free location 
       xfree (oldloc);
       ^
_23 = progsize_16 + 1;
test.c:120:11: warning: use location
   count = mbstowcs (progname_copy, progname, progsize + 1);
           ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_113 = VDEF <.MEM_101>
free (oldloc_15);
test.c:116:7: warning: Use after free error!: free location 
       xfree (oldloc);
       ^
_25 = __builtin_constant_p (_23);

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_113 = VDEF <.MEM_101>
free (oldloc_15);
test.c:116:7: warning: Use after free error!: free location 
if (_25 == 0)

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_113 = VDEF <.MEM_101>
free (oldloc_15);
test.c:116:7: warning: Use after free error!: free location 
# .MEM_105 = VDEF <.MEM_101>
_34 = __mbstowcs_alias (progname_copy_19, progname_11, _23);

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_113 = VDEF <.MEM_101>
free (oldloc_15);
test.c:116:7: warning: Use after free error!: free location 
# .MEM_103 = VDEF <.MEM_101>
_33 = __mbstowcs_chk_warn (progname_copy_19, progname_11, _23, _32);

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_113 = VDEF <.MEM_101>
free (oldloc_15);
test.c:116:7: warning: Use after free error!: free location 
# VUSE <.MEM_101>
_24 = __builtin_object_size (progname_copy_19, 1);

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_113 = VDEF <.MEM_101>
free (oldloc_15);
test.c:116:7: warning: Use after free error!: free location 
if (_24 != 18446744073709551615)

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:5 [0m

======================================================================

======================================================================
[40;31m 	this stmt need double check [0m

======================================================================

dot graph START

======================================================================
 <ssa_name 0x7f034c9eb240
    type <pointer_type 0x7f034c9cfe70
        type <record_type 0x7f034c9cfdc8 FILE BLK
            size <integer_cst 0x7f034c9c91f8 constant 1728>
            unit size <integer_cst 0x7f034c9c9330 constant 216>
            align 64 symtab 0 alias set -1 canonical type 0x7f034c9cfc78 fields <field_decl 0x7f034c9d1850 _flags> context <translation_unit_decl 0x7f034cea7168 test.c>
            pointer_to_this <pointer_type 0x7f034c9cfe70> chain <type_decl 0x7f034c9d18e8 D.4038>>
        unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality
        pointer_to_this <pointer_type 0x7f034c9d42a0>>
   
    def_stmt _20 = stderr;
    version 20
    ptr-info 0x7f034c9f1228>
# VUSE <.MEM_113>
_20 = stderr;

 ================== trace ptable================== 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr--------
this other function -----------
 
 Start check Pointer Collect  

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_114 = VDEF <.MEM_113>
_21 = __fprintf_chk (_20, 1, "out of memory\n");
bb index := 16
# VUSE <.MEM_8>
return 0;
In function â€˜mainâ€™:
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 16 ,possiable got to succ := 26

======================================================================
_21 = __fprintf_chk (_20, 1, "out of memory\n");
this stmt is child function---__fprintf_chk-----

 ================== trace ================== 
 <ssa_name 0x7f034c9eb240
    type <pointer_type 0x7f034c9cfe70
        type <record_type 0x7f034c9cfdc8 FILE BLK
            size <integer_cst 0x7f034c9c91f8 constant 1728>
            unit size <integer_cst 0x7f034c9c9330 constant 216>
            align 64 symtab 0 alias set -1 canonical type 0x7f034c9cfc78 fields <field_decl 0x7f034c9d1850 _flags> context <translation_unit_decl 0x7f034cea7168 test.c>
            pointer_to_this <pointer_type 0x7f034c9cfe70> chain <type_decl 0x7f034c9d18e8 D.4038>>
        unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality
        pointer_to_this <pointer_type 0x7f034c9d42a0>>
   
    def_stmt _20 = stderr;
    version 20
    ptr-info 0x7f034c9f1228>
trace fucntion name:__fprintf_chk 

 ================== trace ================== 
trace fucntion free:0 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_114 = VDEF <.MEM_113>
_21 = __fprintf_chk (_20, 1, "out of memory\n");
bb index := 16
# VUSE <.MEM_8>
return 0;
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 16 ,possiable got to succ := 26

======================================================================
_21 = __fprintf_chk (_20, 1, "out of memory\n");
this stmt is child function---__fprintf_chk-----

 ================== trace ================== 
 <ssa_name 0x7f034c9eb240
    type <pointer_type 0x7f034c9cfe70
        type <record_type 0x7f034c9cfdc8 FILE BLK
            size <integer_cst 0x7f034c9c91f8 constant 1728>
            unit size <integer_cst 0x7f034c9c9330 constant 216>
            align 64 symtab 0 alias set -1 canonical type 0x7f034c9cfc78 fields <field_decl 0x7f034c9d1850 _flags> context <translation_unit_decl 0x7f034cea7168 test.c>
            pointer_to_this <pointer_type 0x7f034c9cfe70> chain <type_decl 0x7f034c9d18e8 D.4038>>
        unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality
        pointer_to_this <pointer_type 0x7f034c9d42a0>>
   
    def_stmt _20 = stderr;
    version 20
    ptr-info 0x7f034c9f1228>
trace fucntion name:__fprintf_chk 

 ================== trace ================== 
trace fucntion free:0 

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7f034c9eb240
    type <pointer_type 0x7f034c9cfe70
        type <record_type 0x7f034c9cfdc8 FILE BLK
            size <integer_cst 0x7f034c9c91f8 constant 1728>
            unit size <integer_cst 0x7f034c9c9330 constant 216>
            align 64 symtab 0 alias set -1 canonical type 0x7f034c9cfc78 fields <field_decl 0x7f034c9d1850 _flags> context <translation_unit_decl 0x7f034cea7168 test.c>
            pointer_to_this <pointer_type 0x7f034c9cfe70> chain <type_decl 0x7f034c9d18e8 D.4038>>
        unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality
        pointer_to_this <pointer_type 0x7f034c9d42a0>>
   
    def_stmt _20 = stderr;
    version 20
    ptr-info 0x7f034c9f1228>
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_113 = VDEF <.MEM_101>
free (oldloc_15);
At top level:
test.c:116:7: warning: use location
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_110 = VDEF <.MEM_88>
free (oldloc_15);
test.c:123:7: warning: use location
       xfree (oldloc);
       ^
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_111 = VDEF <.MEM_110>
free (progname_copy_19);
test.c:124:4: warning: use location
    xfree(progname_copy);
    ^
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_107 = VDEF <.MEM_106>
free (oldloc_15);
test.c:129:3: warning: use location
   xfree (oldloc);
   ^
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_109 = VDEF <.MEM_108>
free (progname_copy_19);
test.c:135:2: warning: use location
  xfree(progname_copy);
  ^

 ================== Start Use after free Check ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_113 = VDEF <.MEM_101>
free (oldloc_15);
test.c:116:7: warning: Use after free error!: free location 
       xfree (oldloc);
       ^
# .MEM_114 = VDEF <.MEM_113>
_21 = __fprintf_chk (_20, 1, "out of memory\n");

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_113 = VDEF <.MEM_101>
free (oldloc_15);
test.c:116:7: warning: Use after free error!: free location 
# .MEM_114 = VDEF <.MEM_113>
_21 = __fprintf_chk (_20, 1, "out of memory\n");

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:5 [0m

======================================================================

======================================================================
[40;31m    no free stmt possible memory leak [0m

======================================================================

dot graph START

======================================================================
 <ssa_name 0x7f034c9eb1f8
    type <pointer_type 0x7f034c9c61f8
        type <integer_type 0x7f034c9c6a80 wchar_t SI
            size <integer_cst 0x7f034ce9ce28 constant 32>
            unit size <integer_cst 0x7f034ce9ce40 constant 4>
            align 32 symtab 0 alias set -1 canonical type 0x7f034ceb05e8 precision 32 min <integer_cst 0x7f034ce9cde0 -2147483648> max <integer_cst 0x7f034ce9cdf8 2147483647> context <translation_unit_decl 0x7f034cea7168 test.c>
            pointer_to_this <pointer_type 0x7f034c9c61f8>>
        public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality>
    var <var_decl 0x7f034c9e95a0 progname_copy>
    def_stmt progname_copy_19 = _102;
    version 19
    ptr-info 0x7f034c9f1210>
progname_copy_19 = _102;

 ================== trace ptable================== 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr--------
this other function -----------
 
 Start check Pointer Collect  

======================================================================
_31 = __builtin_object_size (progname_copy_19, 1);
this stmt is child function---__builtin_object_size-----

 ================== trace ================== 
 <ssa_name 0x7f034c9eb1f8
    type <pointer_type 0x7f034c9c61f8
        type <integer_type 0x7f034c9c6a80 wchar_t SI
            size <integer_cst 0x7f034ce9ce28 constant 32>
            unit size <integer_cst 0x7f034ce9ce40 constant 4>
            align 32 symtab 0 alias set -1 canonical type 0x7f034ceb05e8 precision 32 min <integer_cst 0x7f034ce9cde0 -2147483648> max <integer_cst 0x7f034ce9cdf8 2147483647> context <translation_unit_decl 0x7f034cea7168 test.c>
            pointer_to_this <pointer_type 0x7f034c9c61f8>>
        public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality>
    var <var_decl 0x7f034c9e95a0 progname_copy>
    def_stmt progname_copy_19 = _102;
    version 19
    ptr-info 0x7f034c9f1210>
trace fucntion name:__builtin_object_size 

 ================== trace ================== 
trace fucntion free:0 
_29 = __builtin_object_size (progname_copy_19, 1);
this stmt is child function---__builtin_object_size-----

 ================== trace ================== 
 <ssa_name 0x7f034c9eb1f8
    type <pointer_type 0x7f034c9c61f8
        type <integer_type 0x7f034c9c6a80 wchar_t SI
            size <integer_cst 0x7f034ce9ce28 constant 32>
            unit size <integer_cst 0x7f034ce9ce40 constant 4>
            align 32 symtab 0 alias set -1 canonical type 0x7f034ceb05e8 precision 32 min <integer_cst 0x7f034ce9cde0 -2147483648> max <integer_cst 0x7f034ce9cdf8 2147483647> context <translation_unit_decl 0x7f034cea7168 test.c>
            pointer_to_this <pointer_type 0x7f034c9c61f8>>
        public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality>
    var <var_decl 0x7f034c9e95a0 progname_copy>
    def_stmt progname_copy_19 = _102;
    version 19
    ptr-info 0x7f034c9f1210>
trace fucntion name:__builtin_object_size 

 ================== trace ================== 
trace fucntion free:0 
_30 = _29 / 4;
_26 = __builtin_object_size (progname_copy_19, 1);
this stmt is child function---__builtin_object_size-----

 ================== trace ================== 
 <ssa_name 0x7f034c9eb1f8
    type <pointer_type 0x7f034c9c61f8
        type <integer_type 0x7f034c9c6a80 wchar_t SI
            size <integer_cst 0x7f034ce9ce28 constant 32>
            unit size <integer_cst 0x7f034ce9ce40 constant 4>
            align 32 symtab 0 alias set -1 canonical type 0x7f034ceb05e8 precision 32 min <integer_cst 0x7f034ce9cde0 -2147483648> max <integer_cst 0x7f034ce9cdf8 2147483647> context <translation_unit_decl 0x7f034cea7168 test.c>
            pointer_to_this <pointer_type 0x7f034c9c61f8>>
        public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality>
    var <var_decl 0x7f034c9e95a0 progname_copy>
    def_stmt progname_copy_19 = _102;
    version 19
    ptr-info 0x7f034c9f1210>
trace fucntion name:__builtin_object_size 

 ================== trace ================== 
trace fucntion free:0 
_27 = _26 / 4;
_28 = __mbstowcs_chk (progname_copy_19, progname_11, _23, _27);
this stmt is child function---__mbstowcs_chk-----

 ================== trace ================== 
 <ssa_name 0x7f034c9eb1f8
    type <pointer_type 0x7f034c9c61f8
        type <integer_type 0x7f034c9c6a80 wchar_t SI
            size <integer_cst 0x7f034ce9ce28 constant 32>
            unit size <integer_cst 0x7f034ce9ce40 constant 4>
            align 32 symtab 0 alias set -1 canonical type 0x7f034ceb05e8 precision 32 min <integer_cst 0x7f034ce9cde0 -2147483648> max <integer_cst 0x7f034ce9cdf8 2147483647> context <translation_unit_decl 0x7f034cea7168 test.c>
            pointer_to_this <pointer_type 0x7f034c9c61f8>>
        public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality>
    var <var_decl 0x7f034c9e95a0 progname_copy>
    def_stmt progname_copy_19 = _102;
    version 19
    ptr-info 0x7f034c9f1210>
trace fucntion name:__mbstowcs_chk 

 ================== trace ================== 
trace fucntion free:0 
_35 = PHI <_28(19), _33(21), _34(22)>
lto1: warning: use location
this stmt have mutiple branch --------
if (_35 == 18446744073709551615)
test.c:121:6: warning: use location
   if (count == (size_t) -1)
      ^
if (_35 == 18446744073709551615)

 ================== find cond branch ================= 
test.c:121:6: warning: use location
Cond in fucntion main basic block 23
 ================== possible direct basic block ================= 
from main basic block 24
 ================== possible direct basic block ================= 
from main basic block 25
 ================== warring ================== 
[40;35m    need check this branch possible have return or exit stmt [0m

 ================== warring ================== 

 ================== find cond branch ================= 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# VUSE <.MEM_100>
progsize_16 = strlen (progname_11);
bb index := 15
# VUSE <.MEM_8>
return 0;
In function â€˜mainâ€™:
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# VUSE <.MEM_100>
progsize_16 = strlen (progname_11);
bb index := 15
# VUSE <.MEM_8>
return 0;
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================
progsize_16 = strlen (progname_11);
At top level:
test.c:112:12: warning: use location
   progsize = strlen (progname);
            ^
this stmt is child function---strlen-----

 ================== trace ================== 
 <ssa_name 0x7f034c9eb1f8
    type <pointer_type 0x7f034c9c61f8
        type <integer_type 0x7f034c9c6a80 wchar_t SI
            size <integer_cst 0x7f034ce9ce28 constant 32>
            unit size <integer_cst 0x7f034ce9ce40 constant 4>
            align 32 symtab 0 alias set -1 canonical type 0x7f034ceb05e8 precision 32 min <integer_cst 0x7f034ce9cde0 -2147483648> max <integer_cst 0x7f034ce9cdf8 2147483647> context <translation_unit_decl 0x7f034cea7168 test.c>
            pointer_to_this <pointer_type 0x7f034c9c61f8>>
        public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality>
    var <var_decl 0x7f034c9e95a0 progname_copy>
    def_stmt progname_copy_19 = _102;
    version 19
    ptr-info 0x7f034c9f1210>
trace fucntion name:strlen 

 ================== trace ================== 
trace fucntion free:0 
_23 = progsize_16 + 1;
test.c:120:11: warning: use location
   count = mbstowcs (progname_copy, progname, progsize + 1);
           ^
_25 = __builtin_constant_p (_23);
this stmt is child function---__builtin_constant_p-----

 ================== trace ================== 
 <ssa_name 0x7f034c9eb1f8
    type <pointer_type 0x7f034c9c61f8
        type <integer_type 0x7f034c9c6a80 wchar_t SI
            size <integer_cst 0x7f034ce9ce28 constant 32>
            unit size <integer_cst 0x7f034ce9ce40 constant 4>
            align 32 symtab 0 alias set -1 canonical type 0x7f034ceb05e8 precision 32 min <integer_cst 0x7f034ce9cde0 -2147483648> max <integer_cst 0x7f034ce9cdf8 2147483647> context <translation_unit_decl 0x7f034cea7168 test.c>
            pointer_to_this <pointer_type 0x7f034c9c61f8>>
        public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality>
    var <var_decl 0x7f034c9e95a0 progname_copy>
    def_stmt progname_copy_19 = _102;
    version 19
    ptr-info 0x7f034c9f1210>
trace fucntion name:__builtin_constant_p 

 ================== trace ================== 
trace fucntion free:0 
if (_25 == 0)
if (_25 == 0)

 ================== find cond branch ================= 
Cond in fucntion main basic block 18
 ================== possible direct basic block ================= 
from main basic block 19
 ================== possible direct basic block ================= 
from main basic block 20
 ================== warring ================== 
[40;35m    need check this branch possible have return or exit stmt [0m

 ================== warring ================== 

 ================== find cond branch ================= 
_34 = __mbstowcs_alias (progname_copy_19, progname_11, _23);
this stmt is child function---__mbstowcs_alias-----

 ================== trace ================== 
 <ssa_name 0x7f034c9eb1f8
    type <pointer_type 0x7f034c9c61f8
        type <integer_type 0x7f034c9c6a80 wchar_t SI
            size <integer_cst 0x7f034ce9ce28 constant 32>
            unit size <integer_cst 0x7f034ce9ce40 constant 4>
            align 32 symtab 0 alias set -1 canonical type 0x7f034ceb05e8 precision 32 min <integer_cst 0x7f034ce9cde0 -2147483648> max <integer_cst 0x7f034ce9cdf8 2147483647> context <translation_unit_decl 0x7f034cea7168 test.c>
            pointer_to_this <pointer_type 0x7f034c9c61f8>>
        public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality>
    var <var_decl 0x7f034c9e95a0 progname_copy>
    def_stmt progname_copy_19 = _102;
    version 19
    ptr-info 0x7f034c9f1210>
trace fucntion name:__mbstowcs_alias 

 ================== trace ================== 
trace fucntion free:0 
_33 = __mbstowcs_chk_warn (progname_copy_19, progname_11, _23, _32);
this stmt is child function---__mbstowcs_chk_warn-----

 ================== trace ================== 
 <ssa_name 0x7f034c9eb1f8
    type <pointer_type 0x7f034c9c61f8
        type <integer_type 0x7f034c9c6a80 wchar_t SI
            size <integer_cst 0x7f034ce9ce28 constant 32>
            unit size <integer_cst 0x7f034ce9ce40 constant 4>
            align 32 symtab 0 alias set -1 canonical type 0x7f034ceb05e8 precision 32 min <integer_cst 0x7f034ce9cde0 -2147483648> max <integer_cst 0x7f034ce9cdf8 2147483647> context <translation_unit_decl 0x7f034cea7168 test.c>
            pointer_to_this <pointer_type 0x7f034c9c61f8>>
        public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality>
    var <var_decl 0x7f034c9e95a0 progname_copy>
    def_stmt progname_copy_19 = _102;
    version 19
    ptr-info 0x7f034c9f1210>
trace fucntion name:__mbstowcs_chk_warn 

 ================== trace ================== 
trace fucntion free:0 

======================================================================
[40;31m    branch possiable have return or exit  [0m
_17 = progsize_16 + 1;
bb index := 15
# VUSE <.MEM_8>
return 0;
In function â€˜mainâ€™:
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
_17 = progsize_16 + 1;
bb index := 15
# VUSE <.MEM_8>
return 0;
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================
_17 = progsize_16 + 1;
At top level:
test.c:113:31: warning: use location
   progname_copy = (wchar_t *) PyMem_Malloc ((progsize + 1) * sizeof (wchar_t));
                               ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
_18 = _17 * 4;
bb index := 15
# VUSE <.MEM_8>
return 0;
In function â€˜mainâ€™:
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
_18 = _17 * 4;
bb index := 15
# VUSE <.MEM_8>
return 0;
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================
_18 = _17 * 4;
At top level:
test.c:113:31: warning: use location

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_101 = VDEF <.MEM_100>
ret_41 = malloc (_18);
bb index := 15
# VUSE <.MEM_8>
return 0;
In function â€˜mainâ€™:
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_101 = VDEF <.MEM_100>
ret_41 = malloc (_18);
bb index := 15
# VUSE <.MEM_8>
return 0;
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================
ret_41 = malloc (_18);
At top level:
test.c:86:8: warning: use location
  void *ret = malloc(size);
        ^
this stmt is child function---malloc-----

 ================== trace ================== 
 <ssa_name 0x7f034c9eb1f8
    type <pointer_type 0x7f034c9c61f8
        type <integer_type 0x7f034c9c6a80 wchar_t SI
            size <integer_cst 0x7f034ce9ce28 constant 32>
            unit size <integer_cst 0x7f034ce9ce40 constant 4>
            align 32 symtab 0 alias set -1 canonical type 0x7f034ceb05e8 precision 32 min <integer_cst 0x7f034ce9cde0 -2147483648> max <integer_cst 0x7f034ce9cdf8 2147483647> context <translation_unit_decl 0x7f034cea7168 test.c>
            pointer_to_this <pointer_type 0x7f034c9c61f8>>
        public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality>
    var <var_decl 0x7f034c9e95a0 progname_copy>
    def_stmt progname_copy_19 = _102;
    version 19
    ptr-info 0x7f034c9f1210>
trace fucntion name:malloc 

 ================== trace ================== 
trace fucntion free:0 

======================================================================
[40;31m    branch possiable have return or exit  [0m
_102 = ret_41;
bb index := 15
# VUSE <.MEM_8>
return 0;
In function â€˜mainâ€™:
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
_102 = ret_41;
bb index := 15
# VUSE <.MEM_8>
return 0;
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================
_102 = ret_41;
At top level:
lto1: warning: use location

======================================================================
[40;31m    branch possiable have return or exit  [0m
_42 = ret_41;
bb index := 15
# VUSE <.MEM_8>
return 0;
In function â€˜mainâ€™:
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
_42 = ret_41;
bb index := 15
# VUSE <.MEM_8>
return 0;
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================
_42 = ret_41;
At top level:
test.c:87:9: warning: use location
  return ret;
         ^
_24 = __builtin_object_size (progname_copy_19, 1);
this stmt is child function---__builtin_object_size-----

 ================== trace ================== 
 <ssa_name 0x7f034c9eb1f8
    type <pointer_type 0x7f034c9c61f8
        type <integer_type 0x7f034c9c6a80 wchar_t SI
            size <integer_cst 0x7f034ce9ce28 constant 32>
            unit size <integer_cst 0x7f034ce9ce40 constant 4>
            align 32 symtab 0 alias set -1 canonical type 0x7f034ceb05e8 precision 32 min <integer_cst 0x7f034ce9cde0 -2147483648> max <integer_cst 0x7f034ce9cdf8 2147483647> context <translation_unit_decl 0x7f034cea7168 test.c>
            pointer_to_this <pointer_type 0x7f034c9c61f8>>
        public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality>
    var <var_decl 0x7f034c9e95a0 progname_copy>
    def_stmt progname_copy_19 = _102;
    version 19
    ptr-info 0x7f034c9f1210>
trace fucntion name:__builtin_object_size 

 ================== trace ================== 
trace fucntion free:0 
if (_24 != 18446744073709551615)
if (_24 != 18446744073709551615)

 ================== find cond branch ================= 
Cond in fucntion main basic block 17
 ================== possible direct basic block ================= 
from main basic block 18
 ================== possible direct basic block ================= 
from main basic block 22
 ================== warring ================== 
[40;35m    need check this branch possible have return or exit stmt [0m

 ================== warring ================== 

 ================== find cond branch ================= 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_109 = VDEF <.MEM_108>
free (progname_copy_19);
bb index := 25
# VUSE <.MEM_8>
return 0;
In function â€˜mainâ€™:
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 25 ,possiable got to succ := 26

======================================================================
free (progname_copy_19);
At top level:
test.c:135:2: warning: use location
  xfree(progname_copy);
  ^
this stmt is child function---free-----

 ================== find ================== 
free (progname_copy_19);
test.c:135:2: warning: use location
[40;32m    HAS FREE STMT count:1 name:free [0m

 ================== find ================== 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_111 = VDEF <.MEM_110>
free (progname_copy_19);
bb index := 24
# VUSE <.MEM_8>
return 0;
In function â€˜mainâ€™:
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 24 ,possiable got to succ := 26

======================================================================
free (progname_copy_19);
At top level:
test.c:124:4: warning: use location
    xfree(progname_copy);
    ^
this stmt is child function---free-----

 ================== find ================== 
free (progname_copy_19);
test.c:124:4: warning: use location
[40;32m    HAS FREE STMT count:2 name:free [0m

 ================== find ================== 

======================================================================
[40;31m    branch possiable have return or exit  [0m
if (progname_copy_19 == 0B)
bb index := 15
# VUSE <.MEM_8>
return 0;
In function â€˜mainâ€™:
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
if (progname_copy_19 == 0B)
bb index := 15
# VUSE <.MEM_8>
return 0;
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================
if (progname_copy_19 == 0B)
At top level:
test.c:114:6: warning: use location
   if (!progname_copy)
      ^
if (progname_copy_19 == 0B)

 ================== find cond branch ================= 
test.c:114:6: warning: use location
Cond in fucntion main basic block 15
 ================== possible direct basic block ================= 
from main basic block 16
 ================== possible direct basic block ================= 
from main basic block 17
 ================== warring ================== 
[40;35m    need check this branch possible have return or exit stmt [0m

 ================== warring ================== 

 ================== find cond branch ================= 

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7f034c9eb1f8
    type <pointer_type 0x7f034c9c61f8
        type <integer_type 0x7f034c9c6a80 wchar_t SI
            size <integer_cst 0x7f034ce9ce28 constant 32>
            unit size <integer_cst 0x7f034ce9ce40 constant 4>
            align 32 symtab 0 alias set -1 canonical type 0x7f034ceb05e8 precision 32 min <integer_cst 0x7f034ce9cde0 -2147483648> max <integer_cst 0x7f034ce9cdf8 2147483647> context <translation_unit_decl 0x7f034cea7168 test.c>
            pointer_to_this <pointer_type 0x7f034c9c61f8>>
        public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality>
    var <var_decl 0x7f034c9e95a0 progname_copy>
    def_stmt progname_copy_19 = _102;
    version 19
    ptr-info 0x7f034c9f1210>
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_111 = VDEF <.MEM_110>
free (progname_copy_19);
test.c:124:4: warning: use location
    xfree(progname_copy);
    ^
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_109 = VDEF <.MEM_108>
free (progname_copy_19);
test.c:135:2: warning: use location
  xfree(progname_copy);
  ^

 ================== Start Use after free Check ================== 

============================================================
# .MEM_109 = VDEF <.MEM_108>
free (progname_copy_19);
test.c:135:2: warning: Use after free error!: free location 
_35 = PHI <_28(19), _33(21), _34(22)>
lto1: warning: use location

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
# .MEM_111 = VDEF <.MEM_110>
free (progname_copy_19);
test.c:124:4: warning: Use after free error!: free location 
    xfree(progname_copy);
    ^
_35 = PHI <_28(19), _33(21), _34(22)>
lto1: warning: use location

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_111 = VDEF <.MEM_110>
free (progname_copy_19);
test.c:124:4: warning: Use after free error!: free location 
_35 = PHI <_28(19), _33(21), _34(22)>
lto1: warning: use location

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_109 = VDEF <.MEM_108>
free (progname_copy_19);
test.c:135:2: warning: Use after free error!: free location 
  xfree(progname_copy);
  ^
_35 = PHI <_28(19), _33(21), _34(22)>
lto1: warning: use location

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:2 [0m

======================================================================

======================================================================
[40;31m 	this stmt need double check [0m

======================================================================

dot graph START

======================================================================
 <ssa_name 0x7f034c9eb318
    type <integer_type 0x7f034ceb07e0 long unsigned int public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 canonical type 0x7f034ceb0738 precision 64 min <integer_cst 0x7f034ce9ceb8 0> max <integer_cst 0x7f034ce9e500 18446744073709551615>
        pointer_to_this <pointer_type 0x7f034cebc9d8>>
   
    def_stmt _23 = progsize_16 + 1;
    version 23>
_23 = progsize_16 + 1;

 ================== trace ptable================== 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr--------
this other function -----------
 
 Start check Pointer Collect  

======================================================================
_25 = __builtin_constant_p (_23);
this stmt is child function---__builtin_constant_p-----

 ================== trace ================== 
 <ssa_name 0x7f034c9eb318
    type <integer_type 0x7f034ceb07e0 long unsigned int public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 canonical type 0x7f034ceb0738 precision 64 min <integer_cst 0x7f034ce9ceb8 0> max <integer_cst 0x7f034ce9e500 18446744073709551615>
        pointer_to_this <pointer_type 0x7f034cebc9d8>>
   
    def_stmt _23 = progsize_16 + 1;
    version 23>
trace fucntion name:__builtin_constant_p 

 ================== trace ================== 
trace fucntion free:0 
if (_25 == 0)
if (_25 == 0)

 ================== find cond branch ================= 
Cond in fucntion main basic block 18
 ================== possible direct basic block ================= 
from main basic block 19
 ================== possible direct basic block ================= 
from main basic block 20
 ================== warring ================== 
[40;35m    need check this branch possible have return or exit stmt [0m

 ================== warring ================== 

 ================== find cond branch ================= 
_34 = __mbstowcs_alias (progname_copy_19, progname_11, _23);
this stmt is child function---__mbstowcs_alias-----

 ================== trace ================== 
 <ssa_name 0x7f034c9eb318
    type <integer_type 0x7f034ceb07e0 long unsigned int public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 canonical type 0x7f034ceb0738 precision 64 min <integer_cst 0x7f034ce9ceb8 0> max <integer_cst 0x7f034ce9e500 18446744073709551615>
        pointer_to_this <pointer_type 0x7f034cebc9d8>>
   
    def_stmt _23 = progsize_16 + 1;
    version 23>
trace fucntion name:__mbstowcs_alias 

 ================== trace ================== 
trace fucntion free:0 
_35 = PHI <_28(19), _33(21), _34(22)>
lto1: warning: use location
this stmt have mutiple branch --------
if (_35 == 18446744073709551615)
test.c:121:6: warning: use location
   if (count == (size_t) -1)
      ^
if (_35 == 18446744073709551615)

 ================== find cond branch ================= 
test.c:121:6: warning: use location
Cond in fucntion main basic block 23
 ================== possible direct basic block ================= 
from main basic block 24
 ================== possible direct basic block ================= 
from main basic block 25
 ================== warring ================== 
[40;35m    need check this branch possible have return or exit stmt [0m

 ================== warring ================== 

 ================== find cond branch ================= 
_31 = __builtin_object_size (progname_copy_19, 1);
this stmt is child function---__builtin_object_size-----

 ================== trace ================== 
 <ssa_name 0x7f034c9eb318
    type <integer_type 0x7f034ceb07e0 long unsigned int public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 canonical type 0x7f034ceb0738 precision 64 min <integer_cst 0x7f034ce9ceb8 0> max <integer_cst 0x7f034ce9e500 18446744073709551615>
        pointer_to_this <pointer_type 0x7f034cebc9d8>>
   
    def_stmt _23 = progsize_16 + 1;
    version 23>
trace fucntion name:__builtin_object_size 

 ================== trace ================== 
trace fucntion free:0 
_29 = __builtin_object_size (progname_copy_19, 1);
this stmt is child function---__builtin_object_size-----

 ================== trace ================== 
 <ssa_name 0x7f034c9eb318
    type <integer_type 0x7f034ceb07e0 long unsigned int public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 canonical type 0x7f034ceb0738 precision 64 min <integer_cst 0x7f034ce9ceb8 0> max <integer_cst 0x7f034ce9e500 18446744073709551615>
        pointer_to_this <pointer_type 0x7f034cebc9d8>>
   
    def_stmt _23 = progsize_16 + 1;
    version 23>
trace fucntion name:__builtin_object_size 

 ================== trace ================== 
trace fucntion free:0 
_30 = _29 / 4;
_26 = __builtin_object_size (progname_copy_19, 1);
this stmt is child function---__builtin_object_size-----

 ================== trace ================== 
 <ssa_name 0x7f034c9eb318
    type <integer_type 0x7f034ceb07e0 long unsigned int public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 canonical type 0x7f034ceb0738 precision 64 min <integer_cst 0x7f034ce9ceb8 0> max <integer_cst 0x7f034ce9e500 18446744073709551615>
        pointer_to_this <pointer_type 0x7f034cebc9d8>>
   
    def_stmt _23 = progsize_16 + 1;
    version 23>
trace fucntion name:__builtin_object_size 

 ================== trace ================== 
trace fucntion free:0 
_27 = _26 / 4;
_28 = __mbstowcs_chk (progname_copy_19, progname_11, _23, _27);
this stmt is child function---__mbstowcs_chk-----

 ================== trace ================== 
 <ssa_name 0x7f034c9eb318
    type <integer_type 0x7f034ceb07e0 long unsigned int public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 canonical type 0x7f034ceb0738 precision 64 min <integer_cst 0x7f034ce9ceb8 0> max <integer_cst 0x7f034ce9e500 18446744073709551615>
        pointer_to_this <pointer_type 0x7f034cebc9d8>>
   
    def_stmt _23 = progsize_16 + 1;
    version 23>
trace fucntion name:__mbstowcs_chk 

 ================== trace ================== 
trace fucntion free:0 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# VUSE <.MEM_100>
progsize_16 = strlen (progname_11);
bb index := 15
# VUSE <.MEM_8>
return 0;
In function â€˜mainâ€™:
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# VUSE <.MEM_100>
progsize_16 = strlen (progname_11);
bb index := 15
# VUSE <.MEM_8>
return 0;
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================
progsize_16 = strlen (progname_11);
At top level:
test.c:112:12: warning: use location
   progsize = strlen (progname);
            ^
this stmt is child function---strlen-----

 ================== trace ================== 
 <ssa_name 0x7f034c9eb318
    type <integer_type 0x7f034ceb07e0 long unsigned int public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 canonical type 0x7f034ceb0738 precision 64 min <integer_cst 0x7f034ce9ceb8 0> max <integer_cst 0x7f034ce9e500 18446744073709551615>
        pointer_to_this <pointer_type 0x7f034cebc9d8>>
   
    def_stmt _23 = progsize_16 + 1;
    version 23>
trace fucntion name:strlen 

 ================== trace ================== 
trace fucntion free:0 
_23 = progsize_16 + 1;
test.c:120:11: warning: use location
   count = mbstowcs (progname_copy, progname, progsize + 1);
           ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
_17 = progsize_16 + 1;
bb index := 15
# VUSE <.MEM_8>
return 0;
In function â€˜mainâ€™:
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
_17 = progsize_16 + 1;
bb index := 15
# VUSE <.MEM_8>
return 0;
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================
_17 = progsize_16 + 1;
At top level:
test.c:113:31: warning: use location
   progname_copy = (wchar_t *) PyMem_Malloc ((progsize + 1) * sizeof (wchar_t));
                               ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
_18 = _17 * 4;
bb index := 15
# VUSE <.MEM_8>
return 0;
In function â€˜mainâ€™:
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
_18 = _17 * 4;
bb index := 15
# VUSE <.MEM_8>
return 0;
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================
_18 = _17 * 4;
At top level:
test.c:113:31: warning: use location

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_101 = VDEF <.MEM_100>
ret_41 = malloc (_18);
bb index := 15
# VUSE <.MEM_8>
return 0;
In function â€˜mainâ€™:
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_101 = VDEF <.MEM_100>
ret_41 = malloc (_18);
bb index := 15
# VUSE <.MEM_8>
return 0;
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================
ret_41 = malloc (_18);
At top level:
test.c:86:8: warning: use location
  void *ret = malloc(size);
        ^
this stmt is child function---malloc-----

 ================== trace ================== 
 <ssa_name 0x7f034c9eb318
    type <integer_type 0x7f034ceb07e0 long unsigned int public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 canonical type 0x7f034ceb0738 precision 64 min <integer_cst 0x7f034ce9ceb8 0> max <integer_cst 0x7f034ce9e500 18446744073709551615>
        pointer_to_this <pointer_type 0x7f034cebc9d8>>
   
    def_stmt _23 = progsize_16 + 1;
    version 23>
trace fucntion name:malloc 

 ================== trace ================== 
trace fucntion free:0 

======================================================================
[40;31m    branch possiable have return or exit  [0m
_102 = ret_41;
bb index := 15
# VUSE <.MEM_8>
return 0;
In function â€˜mainâ€™:
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
_102 = ret_41;
bb index := 15
# VUSE <.MEM_8>
return 0;
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================
_102 = ret_41;
At top level:
lto1: warning: use location

======================================================================
[40;31m    branch possiable have return or exit  [0m
_42 = ret_41;
bb index := 15
# VUSE <.MEM_8>
return 0;
In function â€˜mainâ€™:
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
_42 = ret_41;
bb index := 15
# VUSE <.MEM_8>
return 0;
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================
_42 = ret_41;
At top level:
test.c:87:9: warning: use location
  return ret;
         ^
_33 = __mbstowcs_chk_warn (progname_copy_19, progname_11, _23, _32);
this stmt is child function---__mbstowcs_chk_warn-----

 ================== trace ================== 
 <ssa_name 0x7f034c9eb318
    type <integer_type 0x7f034ceb07e0 long unsigned int public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 canonical type 0x7f034ceb0738 precision 64 min <integer_cst 0x7f034ce9ceb8 0> max <integer_cst 0x7f034ce9e500 18446744073709551615>
        pointer_to_this <pointer_type 0x7f034cebc9d8>>
   
    def_stmt _23 = progsize_16 + 1;
    version 23>
trace fucntion name:__mbstowcs_chk_warn 

 ================== trace ================== 
trace fucntion free:0 
_24 = __builtin_object_size (progname_copy_19, 1);
this stmt is child function---__builtin_object_size-----

 ================== trace ================== 
 <ssa_name 0x7f034c9eb318
    type <integer_type 0x7f034ceb07e0 long unsigned int public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 canonical type 0x7f034ceb0738 precision 64 min <integer_cst 0x7f034ce9ceb8 0> max <integer_cst 0x7f034ce9e500 18446744073709551615>
        pointer_to_this <pointer_type 0x7f034cebc9d8>>
   
    def_stmt _23 = progsize_16 + 1;
    version 23>
trace fucntion name:__builtin_object_size 

 ================== trace ================== 
trace fucntion free:0 
if (_24 != 18446744073709551615)
if (_24 != 18446744073709551615)

 ================== find cond branch ================= 
Cond in fucntion main basic block 17
 ================== possible direct basic block ================= 
from main basic block 18
 ================== possible direct basic block ================= 
from main basic block 22
 ================== warring ================== 
[40;35m    need check this branch possible have return or exit stmt [0m

 ================== warring ================== 

 ================== find cond branch ================= 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_109 = VDEF <.MEM_108>
free (progname_copy_19);
bb index := 25
# VUSE <.MEM_8>
return 0;
In function â€˜mainâ€™:
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 25 ,possiable got to succ := 26

======================================================================
free (progname_copy_19);
At top level:
test.c:135:2: warning: use location
  xfree(progname_copy);
  ^
this stmt is child function---free-----

 ================== find ================== 
free (progname_copy_19);
test.c:135:2: warning: use location
[40;32m    HAS FREE STMT count:1 name:free [0m

 ================== find ================== 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_111 = VDEF <.MEM_110>
free (progname_copy_19);
bb index := 24
# VUSE <.MEM_8>
return 0;
In function â€˜mainâ€™:
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 24 ,possiable got to succ := 26

======================================================================
free (progname_copy_19);
At top level:
test.c:124:4: warning: use location
    xfree(progname_copy);
    ^
this stmt is child function---free-----

 ================== find ================== 
free (progname_copy_19);
test.c:124:4: warning: use location
[40;32m    HAS FREE STMT count:2 name:free [0m

 ================== find ================== 

======================================================================
[40;31m    branch possiable have return or exit  [0m
if (progname_copy_19 == 0B)
bb index := 15
# VUSE <.MEM_8>
return 0;
In function â€˜mainâ€™:
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
if (progname_copy_19 == 0B)
bb index := 15
# VUSE <.MEM_8>
return 0;
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 15 ,possiable got to succ := 26

======================================================================
if (progname_copy_19 == 0B)
At top level:
test.c:114:6: warning: use location
   if (!progname_copy)
      ^
if (progname_copy_19 == 0B)

 ================== find cond branch ================= 
test.c:114:6: warning: use location
Cond in fucntion main basic block 15
 ================== possible direct basic block ================= 
from main basic block 16
 ================== possible direct basic block ================= 
from main basic block 17
 ================== warring ================== 
[40;35m    need check this branch possible have return or exit stmt [0m

 ================== warring ================== 

 ================== find cond branch ================= 

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7f034c9eb318
    type <integer_type 0x7f034ceb07e0 long unsigned int public unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 canonical type 0x7f034ceb0738 precision 64 min <integer_cst 0x7f034ce9ceb8 0> max <integer_cst 0x7f034ce9e500 18446744073709551615>
        pointer_to_this <pointer_type 0x7f034cebc9d8>>
   
    def_stmt _23 = progsize_16 + 1;
    version 23>
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_113 = VDEF <.MEM_101>
free (oldloc_15);
test.c:116:7: warning: use location
       xfree (oldloc);
       ^
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_110 = VDEF <.MEM_88>
free (oldloc_15);
test.c:123:7: warning: use location
       xfree (oldloc);
       ^
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_111 = VDEF <.MEM_110>
free (progname_copy_19);
test.c:124:4: warning: use location
    xfree(progname_copy);
    ^
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_107 = VDEF <.MEM_106>
free (oldloc_15);
test.c:129:3: warning: use location
   xfree (oldloc);
   ^
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_109 = VDEF <.MEM_108>
free (progname_copy_19);
test.c:135:2: warning: use location
  xfree(progname_copy);
  ^

 ================== Start Use after free Check ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_113 = VDEF <.MEM_101>
free (oldloc_15);
test.c:116:7: warning: Use after free error!: free location 
       xfree (oldloc);
       ^
_25 = __builtin_constant_p (_23);

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_113 = VDEF <.MEM_101>
free (oldloc_15);
test.c:116:7: warning: Use after free error!: free location 
if (_25 == 0)

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_113 = VDEF <.MEM_101>
free (oldloc_15);
test.c:116:7: warning: Use after free error!: free location 
# .MEM_105 = VDEF <.MEM_101>
_34 = __mbstowcs_alias (progname_copy_19, progname_11, _23);

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
# .MEM_109 = VDEF <.MEM_108>
free (progname_copy_19);
test.c:135:2: warning: Use after free error!: free location 
  xfree(progname_copy);
  ^
_35 = PHI <_28(19), _33(21), _34(22)>
lto1: warning: use location

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
# .MEM_111 = VDEF <.MEM_110>
free (progname_copy_19);
test.c:124:4: warning: Use after free error!: free location 
    xfree(progname_copy);
    ^
_35 = PHI <_28(19), _33(21), _34(22)>
lto1: warning: use location

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_113 = VDEF <.MEM_101>
free (oldloc_15);
test.c:116:7: warning: Use after free error!: free location 
       xfree (oldloc);
       ^
_35 = PHI <_28(19), _33(21), _34(22)>
lto1: warning: use location

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_110 = VDEF <.MEM_88>
free (oldloc_15);
test.c:123:7: warning: Use after free error!: free location 
       xfree (oldloc);
       ^
_35 = PHI <_28(19), _33(21), _34(22)>
lto1: warning: use location

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_111 = VDEF <.MEM_110>
free (progname_copy_19);
test.c:124:4: warning: Use after free error!: free location 
    xfree(progname_copy);
    ^
_35 = PHI <_28(19), _33(21), _34(22)>
lto1: warning: use location

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_107 = VDEF <.MEM_106>
free (oldloc_15);
test.c:129:3: warning: Use after free error!: free location 
   xfree (oldloc);
   ^
_35 = PHI <_28(19), _33(21), _34(22)>
lto1: warning: use location

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_109 = VDEF <.MEM_108>
free (progname_copy_19);
test.c:135:2: warning: Use after free error!: free location 
  xfree(progname_copy);
  ^
_35 = PHI <_28(19), _33(21), _34(22)>
lto1: warning: use location

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_113 = VDEF <.MEM_101>
free (oldloc_15);
test.c:116:7: warning: Use after free error!: free location 
       xfree (oldloc);
       ^
if (_35 == 18446744073709551615)
test.c:121:6: warning: use location
   if (count == (size_t) -1)
      ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_113 = VDEF <.MEM_101>
free (oldloc_15);
test.c:116:7: warning: Use after free error!: free location 
       xfree (oldloc);
       ^
# VUSE <.MEM_101>
_31 = __builtin_object_size (progname_copy_19, 1);

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_113 = VDEF <.MEM_101>
free (oldloc_15);
test.c:116:7: warning: Use after free error!: free location 
# VUSE <.MEM_101>
_29 = __builtin_object_size (progname_copy_19, 1);

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_113 = VDEF <.MEM_101>
free (oldloc_15);
test.c:116:7: warning: Use after free error!: free location 
_30 = _29 / 4;

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_113 = VDEF <.MEM_101>
free (oldloc_15);
test.c:116:7: warning: Use after free error!: free location 
# VUSE <.MEM_101>
_26 = __builtin_object_size (progname_copy_19, 1);

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_113 = VDEF <.MEM_101>
free (oldloc_15);
test.c:116:7: warning: Use after free error!: free location 
_27 = _26 / 4;

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_113 = VDEF <.MEM_101>
free (oldloc_15);
test.c:116:7: warning: Use after free error!: free location 
# .MEM_104 = VDEF <.MEM_101>
_28 = __mbstowcs_chk (progname_copy_19, progname_11, _23, _27);

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_113 = VDEF <.MEM_101>
free (oldloc_15);
test.c:116:7: warning: Use after free error!: free location 
_23 = progsize_16 + 1;
test.c:120:11: warning: use location
   count = mbstowcs (progname_copy, progname, progsize + 1);
           ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_113 = VDEF <.MEM_101>
free (oldloc_15);
test.c:116:7: warning: Use after free error!: free location 
       xfree (oldloc);
       ^
# .MEM_103 = VDEF <.MEM_101>
_33 = __mbstowcs_chk_warn (progname_copy_19, progname_11, _23, _32);

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_113 = VDEF <.MEM_101>
free (oldloc_15);
test.c:116:7: warning: Use after free error!: free location 
# VUSE <.MEM_101>
_24 = __builtin_object_size (progname_copy_19, 1);

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_113 = VDEF <.MEM_101>
free (oldloc_15);
test.c:116:7: warning: Use after free error!: free location 
if (_24 != 18446744073709551615)

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:5 [0m

======================================================================

======================================================================
[40;31m 	this stmt need double check [0m

======================================================================

dot graph START

======================================================================
 <ssa_name 0x7f034c9eb6c0
    type <pointer_type 0x7f034c9cfe70
        type <record_type 0x7f034c9cfdc8 FILE BLK
            size <integer_cst 0x7f034c9c91f8 constant 1728>
            unit size <integer_cst 0x7f034c9c9330 constant 216>
            align 64 symtab 0 alias set -1 canonical type 0x7f034c9cfc78 fields <field_decl 0x7f034c9d1850 _flags> context <translation_unit_decl 0x7f034cea7168 test.c>
            pointer_to_this <pointer_type 0x7f034c9cfe70> chain <type_decl 0x7f034c9d18e8 D.4038>>
        unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality
        pointer_to_this <pointer_type 0x7f034c9d42a0>>
   
    def_stmt _36 = stderr;
    version 36
    ptr-info 0x7f034c9f1240>
# VUSE <.MEM_111>
_36 = stderr;

 ================== trace ptable================== 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr--------
this other function -----------
 
 Start check Pointer Collect  

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_112 = VDEF <.MEM_111>
_37 = __fprintf_chk (_36, 1, "Could not convert python path to string\n");
bb index := 24
# VUSE <.MEM_8>
return 0;
In function â€˜mainâ€™:
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 24 ,possiable got to succ := 26

======================================================================
_37 = __fprintf_chk (_36, 1, "Could not convert python path to string\n");
this stmt is child function---__fprintf_chk-----

 ================== trace ================== 
 <ssa_name 0x7f034c9eb6c0
    type <pointer_type 0x7f034c9cfe70
        type <record_type 0x7f034c9cfdc8 FILE BLK
            size <integer_cst 0x7f034c9c91f8 constant 1728>
            unit size <integer_cst 0x7f034c9c9330 constant 216>
            align 64 symtab 0 alias set -1 canonical type 0x7f034c9cfc78 fields <field_decl 0x7f034c9d1850 _flags> context <translation_unit_decl 0x7f034cea7168 test.c>
            pointer_to_this <pointer_type 0x7f034c9cfe70> chain <type_decl 0x7f034c9d18e8 D.4038>>
        unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality
        pointer_to_this <pointer_type 0x7f034c9d42a0>>
   
    def_stmt _36 = stderr;
    version 36
    ptr-info 0x7f034c9f1240>
trace fucntion name:__fprintf_chk 

 ================== trace ================== 
trace fucntion free:0 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_112 = VDEF <.MEM_111>
_37 = __fprintf_chk (_36, 1, "Could not convert python path to string\n");
bb index := 24
# VUSE <.MEM_8>
return 0;
lto1: warning: use location
beacuse in succ := 26 have return or exit
gimple stmt in succ := 24 ,possiable got to succ := 26

======================================================================
_37 = __fprintf_chk (_36, 1, "Could not convert python path to string\n");
this stmt is child function---__fprintf_chk-----

 ================== trace ================== 
 <ssa_name 0x7f034c9eb6c0
    type <pointer_type 0x7f034c9cfe70
        type <record_type 0x7f034c9cfdc8 FILE BLK
            size <integer_cst 0x7f034c9c91f8 constant 1728>
            unit size <integer_cst 0x7f034c9c9330 constant 216>
            align 64 symtab 0 alias set -1 canonical type 0x7f034c9cfc78 fields <field_decl 0x7f034c9d1850 _flags> context <translation_unit_decl 0x7f034cea7168 test.c>
            pointer_to_this <pointer_type 0x7f034c9cfe70> chain <type_decl 0x7f034c9d18e8 D.4038>>
        unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality
        pointer_to_this <pointer_type 0x7f034c9d42a0>>
   
    def_stmt _36 = stderr;
    version 36
    ptr-info 0x7f034c9f1240>
trace fucntion name:__fprintf_chk 

 ================== trace ================== 
trace fucntion free:0 

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7f034c9eb6c0
    type <pointer_type 0x7f034c9cfe70
        type <record_type 0x7f034c9cfdc8 FILE BLK
            size <integer_cst 0x7f034c9c91f8 constant 1728>
            unit size <integer_cst 0x7f034c9c9330 constant 216>
            align 64 symtab 0 alias set -1 canonical type 0x7f034c9cfc78 fields <field_decl 0x7f034c9d1850 _flags> context <translation_unit_decl 0x7f034cea7168 test.c>
            pointer_to_this <pointer_type 0x7f034c9cfe70> chain <type_decl 0x7f034c9d18e8 D.4038>>
        unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality
        pointer_to_this <pointer_type 0x7f034c9d42a0>>
   
    def_stmt _36 = stderr;
    version 36
    ptr-info 0x7f034c9f1240>
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_113 = VDEF <.MEM_101>
free (oldloc_15);
At top level:
test.c:116:7: warning: use location
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_110 = VDEF <.MEM_88>
free (oldloc_15);
test.c:123:7: warning: use location
       xfree (oldloc);
       ^
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_111 = VDEF <.MEM_110>
free (progname_copy_19);
test.c:124:4: warning: use location
    xfree(progname_copy);
    ^
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_107 = VDEF <.MEM_106>
free (oldloc_15);
test.c:129:3: warning: use location
   xfree (oldloc);
   ^
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_109 = VDEF <.MEM_108>
free (progname_copy_19);
test.c:135:2: warning: use location
  xfree(progname_copy);
  ^

 ================== Start Use after free Check ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_113 = VDEF <.MEM_101>
free (oldloc_15);
test.c:116:7: warning: Use after free error!: free location 
       xfree (oldloc);
       ^
# .MEM_112 = VDEF <.MEM_111>
_37 = __fprintf_chk (_36, 1, "Could not convert python path to string\n");

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_110 = VDEF <.MEM_88>
free (oldloc_15);
test.c:123:7: warning: Use after free error!: free location 
       xfree (oldloc);
       ^
# .MEM_112 = VDEF <.MEM_111>
_37 = __fprintf_chk (_36, 1, "Could not convert python path to string\n");

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_111 = VDEF <.MEM_110>
free (progname_copy_19);
test.c:124:4: warning: Use after free error!: free location 
    xfree(progname_copy);
    ^
# .MEM_112 = VDEF <.MEM_111>
_37 = __fprintf_chk (_36, 1, "Could not convert python path to string\n");

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_113 = VDEF <.MEM_101>
free (oldloc_15);
test.c:116:7: warning: Use after free error!: free location 
       xfree (oldloc);
       ^
# .MEM_112 = VDEF <.MEM_111>
_37 = __fprintf_chk (_36, 1, "Could not convert python path to string\n");

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_110 = VDEF <.MEM_88>
free (oldloc_15);
test.c:123:7: warning: Use after free error!: free location 
       xfree (oldloc);
       ^
# .MEM_112 = VDEF <.MEM_111>
_37 = __fprintf_chk (_36, 1, "Could not convert python path to string\n");

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_111 = VDEF <.MEM_110>
free (progname_copy_19);
test.c:124:4: warning: Use after free error!: free location 
    xfree(progname_copy);
    ^
# .MEM_112 = VDEF <.MEM_111>
_37 = __fprintf_chk (_36, 1, "Could not convert python path to string\n");

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:5 [0m

======================================================================

======================================================================
[40;31m    no free stmt possible memory leak [0m

======================================================================

dot graph START

======================================================================
 <addr_expr 0x7f034c9ea8c0
    type <pointer_type 0x7f034c9d2f18
        type <array_type 0x7f034c9d2e70 type <integer_type 0x7f034c9c6dc8 char>
            BLK
            size <integer_cst 0x7f034c9c9468 constant 56>
            unit size <integer_cst 0x7f034c9c9450 constant 7>
            align 8 symtab 0 alias set -1 structural equality domain <integer_type 0x7f034c9d2dc8>
            pointer_to_this <pointer_type 0x7f034c9d2f18>>
        unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality>
    readonly constant
    arg 0 <string_cst 0x7f034c9ea120 type <array_type 0x7f034c9d2e70>
        readonly constant static "LC_ALL\000">
    test.c:128:14 start: test.c:128:14 finish: test.c:128:14>

 ================== trace ptable================== 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr--------
this other function -----------

======================================================================
[40;35m  	Looserules free count:0 [0m

======================================================================

======================================================================
[40;31m 	Can't find this fucntion in Pointer table [0m
[40;31m 	Possiable no other stmt relate with this stmt [0m

======================================================================

dot graph START

======================================================================

 ================== collect possiable invalid ================== 
 <integer_cst 0x7f034ce9cf90 type <integer_type 0x7f034ceb05e8 int> constant 1>

dot graph START

======================================================================
 <addr_expr 0x7f034c9bab60
    type <pointer_type 0x7f034c9d2738
        type <array_type 0x7f034c9d2690 type <integer_type 0x7f034c9c6dc8 char>
            BLK
            size <integer_cst 0x7f034c9c9408 constant 48>
            unit size <integer_cst 0x7f034c9c93f0 constant 6>
            align 8 symtab 0 alias set -1 structural equality domain <integer_type 0x7f034c9d25e8>
            pointer_to_this <pointer_type 0x7f034c9d2738>>
        unsigned DI
        size <integer_cst 0x7f034ce9cbe8 constant 64>
        unit size <integer_cst 0x7f034ce9cc00 constant 8>
        align 64 symtab 0 alias set -1 structural equality>
    readonly constant
    arg 0 <string_cst 0x7f034c9bab40 type <array_type 0x7f034c9d2690>
        readonly constant static "dummy\000">
    test.c:147:17 start: test.c:147:17 finish: test.c:147:17>

 ================== trace ptable================== 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr--------
this other function -----------

======================================================================
[40;35m  	Looserules free count:0 [0m

======================================================================

======================================================================
[40;31m 	Can't find this fucntion in Pointer table [0m
[40;31m 	Possiable no other stmt relate with this stmt [0m

======================================================================
[40;33m =======POP node_fun stack:main========= [0m
fucntion collect path finsh

=============== The third stage : detection  End=================

===============Print ALL GIMPLE IR=================
=======Mapping node_fun:concat=========
=======is loop:0=========

 bb index 2 
<bb 2> [100.00%]:
newstr_3 = malloc (1);
length_11 = strlen (arg_5(D));
memcpy (newstr_3, arg_5(D), length_11);
end_12 = newstr_3 + length_11;
*end_12 = 0;
_15 = newstr_3;
_7 = newstr_3;
return newstr_3;

=======Mapping node_fun:main=========
=======is loop:0=========

 bb index 2 
<bb 2> [14.44%]:
_9 = 0B;
goto <bb 4>; [100.00%]

=======is loop:1=========

 bb index 3 
<bb 3> [81.81%]:
base_79 = name_78 + 1;
name_80 = name_78 + 1;

=======is loop:1=========

 bb index 4 
<bb 4> [96.25%]:
# name_78 = PHI <_9(2), name_80(3)>
# base_82 = PHI <_9(2), base_79(3)>
_81 = *name_78;
if (_81 != 0)
  goto <bb 3>; [85.00%]
else
  goto <bb 5>; [15.00%]

=======is loop:0=========

 bb index 5 
<bb 5> [14.44%]:
_83 = base_82;
_90 = base_82;
_77 = _90;
_91 = _77;
base_43 = _91;
goto <bb 7>; [100.00%]

=======is loop:1=========

 bb index 6 
<bb 6> [85.56%]:
base_45 = base_44 + 18446744073709551615;

=======is loop:1=========

 bb index 7 
<bb 7> [100.00%]:
# base_44 = PHI <base_43(5), base_45(6)>
if (_9 < base_44)
  goto <bb 8>; [92.50%]
else
  goto <bb 9>; [7.50%]

=======is loop:1=========

 bb index 8 
<bb 8> [92.50%]:
_46 = MEM[(const char *)base_44 + -1B];
if (_46 == 47)
  goto <bb 6>; [92.50%]
else
  goto <bb 9>; [7.50%]

=======is loop:0=========

 bb index 9 
<bb 9> [14.44%]:
if (_9 == base_44)
  goto <bb 15>; [7.92%]
else
  goto <bb 10>; [92.08%]

=======is loop:0=========

 bb index 10 
<bb 10> [13.29%]:
_47 = (long int) base_44;
_48 = (long int) _9;
_49 = _47 - _48;
_50 = _49 + 2;
_51 = (long unsigned int) _50;
dirname_52 = malloc (_51);
_53 = (long int) base_44;
_54 = (long int) _9;
_55 = _53 - _54;
_56 = (long unsigned int) _55;
memcpy (dirname_52, _9, _56);
_57 = (long int) base_44;
_58 = (long int) _9;
_59 = _57 - _58;
if (_59 == 2)
  goto <bb 11>; [34.00%]
else
  goto <bb 14>; [66.00%]

=======is loop:0=========

 bb index 11 
<bb 11> [4.52%]:
_60 = *base_44;
if (_60 == 47)
  goto <bb 12>; [34.00%]
else
  goto <bb 14>; [66.00%]

=======is loop:0=========

 bb index 12 
<bb 12> [1.54%]:
_61 = MEM[(const char *)_9];
if (_61 != 47)
  goto <bb 13>; [66.00%]
else
  goto <bb 14>; [34.00%]

=======is loop:0=========

 bb index 13 
<bb 13> [1.01%]:
_62 = base_44;
base_63 = base_44 + 1;
_64 = (long int) base_44;
_65 = (long int) _9;
_66 = _64 - _65;
_67 = (sizetype) _66;
_68 = dirname_52 + _67;
*_68 = 46;

=======is loop:0=========

 bb index 14 
<bb 14> [13.29%]:
# base_69 = PHI <base_44(10), base_44(11), base_44(12), base_63(13)>
_70 = (long int) base_69;
_71 = (long int) _9;
_72 = _70 - _71;
_73 = (sizetype) _72;
_74 = dirname_52 + _73;
*_74 = 0;
_75 = dirname_52;

=======is loop:0=========

 bb index 15 
<bb 15> [14.44%]:
# _76 = PHI <0B(9), dirname_52(14)>
_96 = _76;
_10 = _96;
progname_11 = concat (_10, "bin");
_12 = setlocale ("LC_ALL", 0B);
_13 = (long int) _12;
_14 = (const char *) _13;
oldloc_15 = strdup (_14);
setlocale ("LC_ALL", "");
progsize_16 = strlen (progname_11);
_17 = progsize_16 + 1;
_18 = _17 * 4;
ret_41 = malloc (_18);
_42 = ret_41;
_102 = ret_41;
progname_copy_19 = _102;
if (progname_copy_19 == 0B)
  goto <bb 16>; [15.24%]
else
  goto <bb 17>; [84.76%]

=======is loop:0=========

 bb index 16 
<bb 16> [2.20%]:
free (oldloc_15);
_20 = stderr;
_21 = __fprintf_chk (_20, 1, "out of memory\n");
_22 = 0;
goto <bb 26>; [100.00%]

=======is loop:0=========

 bb index 17 
<bb 17> [12.24%]:
_23 = progsize_16 + 1;
_24 = __builtin_object_size (progname_copy_19, 1);
if (_24 != 18446744073709551615)
  goto <bb 18>; [79.76%]
else
  goto <bb 22>; [20.24%]

=======is loop:0=========

 bb index 18 
<bb 18> [9.76%]:
_25 = __builtin_constant_p (_23);
if (_25 == 0)
  goto <bb 19>; [33.00%]
else
  goto <bb 20>; [67.00%]

=======is loop:0=========

 bb index 19 
<bb 19> [3.22%]:
_26 = __builtin_object_size (progname_copy_19, 1);
_27 = _26 / 4;
_28 = __mbstowcs_chk (progname_copy_19, progname_11, _23, _27);
goto <bb 23>; [100.00%]

=======is loop:0=========

 bb index 20 
<bb 20> [6.54%]:
_29 = __builtin_object_size (progname_copy_19, 1);
_30 = _29 / 4;
if (_23 > _30)
  goto <bb 21>; [33.00%]
else
  goto <bb 22>; [67.00%]

=======is loop:0=========

 bb index 21 
<bb 21> [2.16%]:
_31 = __builtin_object_size (progname_copy_19, 1);
_32 = _31 / 4;
_33 = __mbstowcs_chk_warn (progname_copy_19, progname_11, _23, _32);
goto <bb 23>; [100.00%]

=======is loop:0=========

 bb index 22 
<bb 22> [6.86%]:
_34 = __mbstowcs_alias (progname_copy_19, progname_11, _23);

=======is loop:0=========

 bb index 23 
<bb 23> [12.24%]:
# _35 = PHI <_28(19), _33(21), _34(22)>
if (_35 == 18446744073709551615)
  goto <bb 24>; [30.50%]
else
  goto <bb 25>; [69.50%]

=======is loop:0=========

 bb index 24 
<bb 24> [3.73%]:
free (oldloc_15);
free (progname_copy_19);
_36 = stderr;
_37 = __fprintf_chk (_36, 1, "Could not convert python path to string\n");
_38 = 0;
goto <bb 26>; [100.00%]

=======is loop:0=========

 bb index 25 
<bb 25> [8.50%]:
setlocale ("LC_ALL", oldloc_15);
free (oldloc_15);
_84 = MEM[(int *)progname_copy_19];
_85 = __printf_chk (1, "%d\n", _84);
free (progname_copy_19);
_39 = 1;

=======is loop:0=========

 bb index 26 
<bb 26> [14.44%]:
# _40 = PHI <_22(16), _38(24), _39(25)>
_115 = _40;
concat ("dummy", "");
_4 = __printf_chk (1, "%d\n", 1835890020);
return 0;


===============Print ALL GIMPLE IR=================
[40;32mSTART CHECKSTART CHECKSTART CHECKSTART CHECKSTART CHECK[0m
    =()=
 ,/'_||_
  (___  `.
 ./  `=='
                   
    ~~~~~~~~~~~  
 ~~~~~~
           ~~~~~~~
[40;34m    find Entry point : 14 [0m
[40;34m    used_stmt array stack totalsize of : 6968 [0m
[40;34m    collect time: : 0.000285 s [0m
[40;34m    algorithm time: 0.054188 s [0m
[40;34m    gimple stmt count : : 108 [0m
[40;32mSTART CHECKSTART CHECKSTART CHECKSTART CHECKSTART CHECK[0m
