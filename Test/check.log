test.c: In function â€˜fooâ€™:
test.c:14:5: warning: assignment makes integer from pointer without a cast [-Wint-conversion]
  *z = malloc(10);
     ^
=======ipa_pta=========
--------GIMPLE_SWITCH -------
--------GIMPLE Cond -------
--------GIMPLE Cond -------
succs:= 8
succs:= 9
--------GIMPLE Cond -------
succs:= 10
succs:= 10
succs:= 9
--------GIMPLE Cond -------
succs:= 13
succs:= 13
--------GIMPLE Cond -------
succs:= 16
--------GIMPLE Cond -------
succs:= 8
succs:= 18
--------GIMPLE Cond -------
succs:= 18
succs:= 20
succs:= 16
succs:= 20
start PointerConstraint
pointer ftable is 0 
pointer ptable is 1 
# .MEM_8 = VDEF <.MEM_7(D)>
_1 = malloc (10);
# .MEM_37 = VDEF <.MEM_30>
foo (p5_9(D));
# .MEM_38 = VDEF <.MEM_35>
foo (p5_9(D));
# .MEM_40 = VDEF <.MEM_38>
foo (p5_9(D));
# .MEM_39 = VDEF <.MEM_38>
foo (p5_9(D));
# .MEM_41 = VDEF <.MEM_38>
foo (p5_9(D));
# .MEM_47 = VDEF <.MEM_32>
foo (p_20(D));
# .MEM_49 = VDEF <.MEM_47>
foo (p_20(D));
# .MEM_48 = VDEF <.MEM_47>
foo (p_20(D));
# .MEM_44 = VDEF <.MEM_32>
foo (p_20(D));
# .MEM_46 = VDEF <.MEM_44>
foo (p3_24(D));
# .MEM_45 = VDEF <.MEM_44>
foo (p5_9(D));
# .MEM_50 = VDEF <.MEM_33>
foo (p_20(D));
# .MEM_43 = VDEF <.MEM_32>
foo (p_20(D));
# .MEM_42 = VDEF <.MEM_32>
foo (p4_18(D));
start collect similar stmtstart collect similar stmtstart collect similar stmtstart collect similar stmt
start collect similar stmtstart collect similar stmtstart collect similar stmtstart collect similar stmt
start collect similar stmtstart collect similar stmtstart collect similar stmtstart collect similar stmt
start collect similar stmtstart collect similar stmtstart collect similar stmtstart collect similar stmt
start collect similar stmtstart collect similar stmtstart collect similar stmtstart collect similar stmt
 <ssa_name 0x7f4812c2c708
    type <pointer_type 0x7f4812c3f0a8
        type <void_type 0x7f4812c38f18 void VOID
            align 8 symtab 0 alias set -1 structural equality
            pointer_to_this <pointer_type 0x7f4812c3f0a8>>
        public unsigned DI
        size <integer_cst 0x7f4812c24be8 constant 64>
        unit size <integer_cst 0x7f4812c24c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality
        pointer_to_this <pointer_type 0x7f4812c44bd0>>
   
    def_stmt _1 = malloc (10);
    version 1
    ptr-info 0x7f4812759b10>
[40;41mSTART CHECKSTART CHECKSTART CHECKSTART CHECKSTART CHECK[0m
[40;41mSTART CHECKSTART CHECKSTART CHECKSTART CHECKSTART CHECK[0m
    =()=
 ,/'_||_
  (___  `.
 ./  `=='
      |||
      |||
      |||
      |||
[40;41mSTART CHECKSTART CHECKSTART CHECKSTART CHECKSTART CHECK[0m
[40;41mSTART CHECKSTART CHECKSTART CHECKSTART CHECKSTART CHECK[0m
=======================================================
[40;44m =======node_fun:foo========= [0m
[40;44m fucntion collect path  [0m
[40;44m =======print_function_path foo  function_call count: 1 level :0========  [0m
[40;42m =======pre add _ fucntion:malloc========= [0m
[40;33m =======POP node_fun stack:malloc========= [0m
[40;42m =======pre_check_funciton:foo========= [0m
[40;42m =======start_check_funciton:foo========= [0m

dot graph START

======================================================================
 <ssa_name 0x7f4812c2c708
    type <pointer_type 0x7f4812c3f0a8
        type <void_type 0x7f4812c38f18 void VOID
            align 8 symtab 0 alias set -1 structural equality
            pointer_to_this <pointer_type 0x7f4812c3f0a8>>
        public unsigned DI
        size <integer_cst 0x7f4812c24be8 constant 64>
        unit size <integer_cst 0x7f4812c24c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality
        pointer_to_this <pointer_type 0x7f4812c44bd0>>
   
    def_stmt _1 = malloc (10);
    version 1
    ptr-info 0x7f4812759b10>
 <ssa_name 0x7f4812c2c708
    type <pointer_type 0x7f4812c3f0a8
        type <void_type 0x7f4812c38f18 void VOID
            align 8 symtab 0 alias set -1 structural equality
            pointer_to_this <pointer_type 0x7f4812c3f0a8>>
        public unsigned DI
        size <integer_cst 0x7f4812c24be8 constant 64>
        unit size <integer_cst 0x7f4812c24c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality
        pointer_to_this <pointer_type 0x7f4812c44bd0>>
   
    def_stmt _1 = malloc (10);
    version 1
    ptr-info 0x7f4812759b10>
# .MEM_8 = VDEF <.MEM_7(D)>
_1 = malloc (10);

 ================== trace ptable================== 
trace fucntion name:malloc 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr---malloc-----
this Reserved word function ------malloc-----
 
 Start check Pointer Collect  

======================================================================
_2 = (long int) _1;
In function â€˜fooâ€™:
test.c:14:5: warning: use location
  *z = malloc(10);
     ^
_3 = (int) _2;
test.c:14:5: warning: use location
*z_6(D) = _3;
test.c:14:5: warning: use location

 ================== Start Use after free Check ================== 

dot graph END

 ================== Start Use after free Check ================== 

======================================================================
[40;31m    no free stmt possible memory leak [0m

======================================================================

dot graph START

======================================================================
 <integer_cst 0x7f4812759ab0 type <integer_type 0x7f4812756930 size_t> constant 10>
[40;33m =======POP node_fun stack:foo========= [0m
[40;44m =======node_fun:main========= [0m
[40;44m fucntion collect path  [0m
[40;44m =======print_function_path main  function_call count: 1 level :0========  [0m
[40;44m =======print_function_type 0  ========  [0m
[40;42m =======pre add _ fucntion:foo========= [0m
[40;44m =======print_function_path foo  function_call count: 1 level :1========  [0m
[40;42m =======pre add _ fucntion:malloc========= [0m
[40;33m =======POP node_fun stack:malloc========= [0m
[40;42m =======pre_check_funciton:foo========= [0m
[40;42m =======start_check_funciton:foo========= [0m

dot graph START

======================================================================
 <ssa_name 0x7f4812c2c708
    type <pointer_type 0x7f4812c3f0a8
        type <void_type 0x7f4812c38f18 void VOID
            align 8 symtab 0 alias set -1 structural equality
            pointer_to_this <pointer_type 0x7f4812c3f0a8>>
        public unsigned DI
        size <integer_cst 0x7f4812c24be8 constant 64>
        unit size <integer_cst 0x7f4812c24c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality
        pointer_to_this <pointer_type 0x7f4812c44bd0>>
   
    def_stmt _1 = malloc (10);
    version 1
    ptr-info 0x7f4812759b10>
 <ssa_name 0x7f4812c2c708
    type <pointer_type 0x7f4812c3f0a8
        type <void_type 0x7f4812c38f18 void VOID
            align 8 symtab 0 alias set -1 structural equality
            pointer_to_this <pointer_type 0x7f4812c3f0a8>>
        public unsigned DI
        size <integer_cst 0x7f4812c24be8 constant 64>
        unit size <integer_cst 0x7f4812c24c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality
        pointer_to_this <pointer_type 0x7f4812c44bd0>>
   
    def_stmt _1 = malloc (10);
    version 1
    ptr-info 0x7f4812759b10>
# .MEM_8 = VDEF <.MEM_7(D)>
_1 = malloc (10);

 ================== trace ptable================== 
trace fucntion name:malloc 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr---malloc-----
this Reserved word function ------malloc-----
 
 Start check Pointer Collect  

======================================================================
_2 = (long int) _1;
In function â€˜mainâ€™:
test.c:14:5: warning: use location
_3 = (int) _2;
test.c:14:5: warning: use location
*z_6(D) = _3;
test.c:14:5: warning: use location

 ================== Start Use after free Check ================== 

dot graph END

 ================== Start Use after free Check ================== 

======================================================================
[40;31m    no free stmt possible memory leak [0m

======================================================================

dot graph START

======================================================================
 <integer_cst 0x7f4812759ab0 type <integer_type 0x7f4812756930 size_t> constant 10>
[40;33m =======POP node_fun stack:foo========= [0m
[40;42m =======pre_check_funciton:main========= [0m
[40;42m =======start_check_funciton:main========= [0m

dot graph START

======================================================================
 <ssa_name 0x7f4812c2c9d8
    type <pointer_type 0x7f4812c3fa80
        type <integer_type 0x7f4812c385e8 int public SI
            size <integer_cst 0x7f4812c24e28 constant 32>
            unit size <integer_cst 0x7f4812c24e40 constant 4>
            align 32 symtab 0 alias set -1 canonical type 0x7f4812c385e8 precision 32 min <integer_cst 0x7f4812c24de0 -2147483648> max <integer_cst 0x7f4812c24df8 2147483647>
            pointer_to_this <pointer_type 0x7f4812c3fa80>>
        public unsigned DI
        size <integer_cst 0x7f4812c24be8 constant 64>
        unit size <integer_cst 0x7f4812c24c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality>
    var <var_decl 0x7f48139b9e10 p5>
    def_stmt GIMPLE_NOP
    version 9
    ptr-info 0x7f4812759b40>
 <ssa_name 0x7f4812c2c9d8
    type <pointer_type 0x7f4812c3fa80
        type <integer_type 0x7f4812c385e8 int public SI
            size <integer_cst 0x7f4812c24e28 constant 32>
            unit size <integer_cst 0x7f4812c24e40 constant 4>
            align 32 symtab 0 alias set -1 canonical type 0x7f4812c385e8 precision 32 min <integer_cst 0x7f4812c24de0 -2147483648> max <integer_cst 0x7f4812c24df8 2147483647>
            pointer_to_this <pointer_type 0x7f4812c3fa80>>
        public unsigned DI
        size <integer_cst 0x7f4812c24be8 constant 64>
        unit size <integer_cst 0x7f4812c24c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality>
    var <var_decl 0x7f48139b9e10 p5>
    def_stmt GIMPLE_NOP
    version 9
    ptr-info 0x7f4812759b40>
GIMPLE_NOP

 ================== trace ptable================== 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr--------
this other function -----------
 
 Start check Pointer Collect  

======================================================================

 Expand conflict 
 The same function may have multiple branches :foo
# .MEM_37 = VDEF <.MEM_30>
foo (p5_9(D));
test.c:35:3: warning: use location
   foo(p5);
   ^
# .MEM_45 = VDEF <.MEM_44>
foo (p5_9(D));
test.c:74:5: warning: use location
     foo(p5);
     ^
=======================Path Constaint===========================

=succs:= 13
if (test_16(D) < test2_17(D))
test.c:69:7: warning: use location
    if (test < test2)
       ^
	relate logic:= 0
=succs:= 9
if (test_16(D) > test2_17(D))
test.c:56:6: warning: use location
   if (test > test2)
      ^
	relate logic:= 1
=succs:= 8
if (test_16(D) != 0)
test.c:50:5: warning: use location
  if (test)
     ^
	relate logic:= 1
=======================Path Constaint===========================


 Expand conflict 
 The same function may have multiple branches :foo
# .MEM_37 = VDEF <.MEM_30>
foo (p5_9(D));
test.c:35:3: warning: use location
   foo(p5);
   ^
# .MEM_41 = VDEF <.MEM_38>
foo (p5_9(D));
test.c:47:3: warning: use location
   foo(p5);
   ^

 Expand conflict 
 The same function may have multiple branches :foo
# .MEM_37 = VDEF <.MEM_30>
foo (p5_9(D));
test.c:35:3: warning: use location
   foo(p5);
   ^
# .MEM_39 = VDEF <.MEM_38>
foo (p5_9(D));
test.c:44:3: warning: use location
   foo(p5);
   ^

 Expand conflict 
 The same function may have multiple branches :foo
# .MEM_37 = VDEF <.MEM_30>
foo (p5_9(D));
test.c:35:3: warning: use location
   foo(p5);
   ^
# .MEM_40 = VDEF <.MEM_38>
foo (p5_9(D));
test.c:41:3: warning: use location
   foo(p5);
   ^

 Expand conflict 
 The same function may have multiple branches :foo
# .MEM_37 = VDEF <.MEM_30>
foo (p5_9(D));
test.c:35:3: warning: use location
   foo(p5);
   ^
# .MEM_38 = VDEF <.MEM_35>
foo (p5_9(D));
test.c:37:3: warning: use location
   foo(p5);
   ^
# .MEM_37 = VDEF <.MEM_30>
foo (p5_9(D));
foo (p5_9(D));
test.c:35:3: warning: use location
   foo(p5);
   ^
this stmt is child function---foo-----

 ================== trace ================== 
 <ssa_name 0x7f4812c2c9d8
    type <pointer_type 0x7f4812c3fa80
        type <integer_type 0x7f4812c385e8 int public SI
            size <integer_cst 0x7f4812c24e28 constant 32>
            unit size <integer_cst 0x7f4812c24e40 constant 4>
            align 32 symtab 0 alias set -1 canonical type 0x7f4812c385e8 precision 32 min <integer_cst 0x7f4812c24de0 -2147483648> max <integer_cst 0x7f4812c24df8 2147483647>
            pointer_to_this <pointer_type 0x7f4812c3fa80>>
        public unsigned DI
        size <integer_cst 0x7f4812c24be8 constant 64>
        unit size <integer_cst 0x7f4812c24c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality>
    var <var_decl 0x7f48139b9e10 p5>
    def_stmt GIMPLE_NOP
    version 9
    ptr-info 0x7f4812759b40>
trace fucntion name:foo 
[40;44m =======trace_function_path foo  function_call count: 1 level :0========  [0m
[40;36m ======= node_fun:foo========= [0m
[40;36m ======= find relate stmt with p5 ========= [0m
[40;36m ======= relate stmt argument:p5 ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:malloc========= [0m
[40;46m =======add node_fun stack:malloc========= [0m

 ================== trace ================== 
trace fucntion free:0 

 ================== Start Use after free Check ================== 

dot graph END

 ================== Start Use after free Check ================== 

======================================================================
[40;31m    no free stmt possible memory leak [0m

======================================================================

dot graph START

======================================================================
 <ssa_name 0x7f4812c2c9d8
    type <pointer_type 0x7f4812c3fa80
        type <integer_type 0x7f4812c385e8 int public SI
            size <integer_cst 0x7f4812c24e28 constant 32>
            unit size <integer_cst 0x7f4812c24e40 constant 4>
            align 32 symtab 0 alias set -1 canonical type 0x7f4812c385e8 precision 32 min <integer_cst 0x7f4812c24de0 -2147483648> max <integer_cst 0x7f4812c24df8 2147483647>
            pointer_to_this <pointer_type 0x7f4812c3fa80>>
        public unsigned DI
        size <integer_cst 0x7f4812c24be8 constant 64>
        unit size <integer_cst 0x7f4812c24c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality>
    var <var_decl 0x7f48139b9e10 p5>
    def_stmt GIMPLE_NOP
    version 9
    ptr-info 0x7f4812759b40>
 <ssa_name 0x7f4812c2c9d8
    type <pointer_type 0x7f4812c3fa80
        type <integer_type 0x7f4812c385e8 int public SI
            size <integer_cst 0x7f4812c24e28 constant 32>
            unit size <integer_cst 0x7f4812c24e40 constant 4>
            align 32 symtab 0 alias set -1 canonical type 0x7f4812c385e8 precision 32 min <integer_cst 0x7f4812c24de0 -2147483648> max <integer_cst 0x7f4812c24df8 2147483647>
            pointer_to_this <pointer_type 0x7f4812c3fa80>>
        public unsigned DI
        size <integer_cst 0x7f4812c24be8 constant 64>
        unit size <integer_cst 0x7f4812c24c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality>
    var <var_decl 0x7f48139b9e10 p5>
    def_stmt GIMPLE_NOP
    version 9
    ptr-info 0x7f4812759b40>
GIMPLE_NOP

 ================== trace ptable================== 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr--------
this other function -----------
 
 Start check Pointer Collect  

======================================================================

 Expand conflict 
 The same function may have multiple branches :foo
# .MEM_38 = VDEF <.MEM_35>
foo (p5_9(D));
test.c:37:3: warning: use location
   foo(p5);
   ^
# .MEM_45 = VDEF <.MEM_44>
foo (p5_9(D));
test.c:74:5: warning: use location
     foo(p5);
     ^
=======================Path Constaint===========================

=succs:= 13
if (test_16(D) < test2_17(D))
test.c:69:7: warning: use location
    if (test < test2)
       ^
	relate logic:= 0
=succs:= 9
if (test_16(D) > test2_17(D))
test.c:56:6: warning: use location
   if (test > test2)
      ^
	relate logic:= 1
=succs:= 8
if (test_16(D) != 0)
test.c:50:5: warning: use location
  if (test)
     ^
	relate logic:= 1
=======================Path Constaint===========================


 Expand conflict 
 The same function may have multiple branches :foo
# .MEM_38 = VDEF <.MEM_35>
foo (p5_9(D));
test.c:37:3: warning: use location
   foo(p5);
   ^
# .MEM_41 = VDEF <.MEM_38>
foo (p5_9(D));
test.c:47:3: warning: use location
   foo(p5);
   ^

 Expand conflict 
 The same function may have multiple branches :foo
# .MEM_38 = VDEF <.MEM_35>
foo (p5_9(D));
test.c:37:3: warning: use location
   foo(p5);
   ^
# .MEM_39 = VDEF <.MEM_38>
foo (p5_9(D));
test.c:44:3: warning: use location
   foo(p5);
   ^

 Expand conflict 
 The same function may have multiple branches :foo
# .MEM_38 = VDEF <.MEM_35>
foo (p5_9(D));
test.c:37:3: warning: use location
   foo(p5);
   ^
# .MEM_40 = VDEF <.MEM_38>
foo (p5_9(D));
test.c:41:3: warning: use location
   foo(p5);
   ^
# .MEM_38 = VDEF <.MEM_35>
foo (p5_9(D));
foo (p5_9(D));
test.c:37:3: warning: use location
   foo(p5);
   ^
this stmt is child function---foo-----

 ================== trace ================== 
 <ssa_name 0x7f4812c2c9d8
    type <pointer_type 0x7f4812c3fa80
        type <integer_type 0x7f4812c385e8 int public SI
            size <integer_cst 0x7f4812c24e28 constant 32>
            unit size <integer_cst 0x7f4812c24e40 constant 4>
            align 32 symtab 0 alias set -1 canonical type 0x7f4812c385e8 precision 32 min <integer_cst 0x7f4812c24de0 -2147483648> max <integer_cst 0x7f4812c24df8 2147483647>
            pointer_to_this <pointer_type 0x7f4812c3fa80>>
        public unsigned DI
        size <integer_cst 0x7f4812c24be8 constant 64>
        unit size <integer_cst 0x7f4812c24c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality>
    var <var_decl 0x7f48139b9e10 p5>
    def_stmt GIMPLE_NOP
    version 9
    ptr-info 0x7f4812759b40>
trace fucntion name:foo 
[40;44m =======trace_function_path foo  function_call count: 1 level :0========  [0m
[40;36m ======= node_fun:foo========= [0m
[40;36m ======= find relate stmt with p5 ========= [0m
[40;36m ======= relate stmt argument:p5 ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:malloc========= [0m
[40;46m =======add node_fun stack:malloc========= [0m

 ================== trace ================== 
trace fucntion free:0 

 Expand conflict 
 The same function may have multiple branches :foo
# .MEM_38 = VDEF <.MEM_35>
foo (p5_9(D));
test.c:37:3: warning: use location
# .MEM_37 = VDEF <.MEM_30>
foo (p5_9(D));
test.c:35:3: warning: use location
   foo(p5);
   ^

 ================== Start Use after free Check ================== 

dot graph END

 ================== Start Use after free Check ================== 

======================================================================
[40;31m    no free stmt possible memory leak [0m

======================================================================

dot graph START

======================================================================
 <ssa_name 0x7f4812c2cb40
    type <pointer_type 0x7f4812c3fa80
        type <integer_type 0x7f4812c385e8 int public SI
            size <integer_cst 0x7f4812c24e28 constant 32>
            unit size <integer_cst 0x7f4812c24e40 constant 4>
            align 32 symtab 0 alias set -1 canonical type 0x7f4812c385e8 precision 32 min <integer_cst 0x7f4812c24de0 -2147483648> max <integer_cst 0x7f4812c24df8 2147483647>
            pointer_to_this <pointer_type 0x7f4812c3fa80>>
        public unsigned DI
        size <integer_cst 0x7f4812c24be8 constant 64>
        unit size <integer_cst 0x7f4812c24c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality>
    var <var_decl 0x7f4812768000 p>
    def_stmt GIMPLE_NOP
    version 20
    ptr-info 0x7f4812759b70>
 <ssa_name 0x7f4812c2cb40
    type <pointer_type 0x7f4812c3fa80
        type <integer_type 0x7f4812c385e8 int public SI
            size <integer_cst 0x7f4812c24e28 constant 32>
            unit size <integer_cst 0x7f4812c24e40 constant 4>
            align 32 symtab 0 alias set -1 canonical type 0x7f4812c385e8 precision 32 min <integer_cst 0x7f4812c24de0 -2147483648> max <integer_cst 0x7f4812c24df8 2147483647>
            pointer_to_this <pointer_type 0x7f4812c3fa80>>
        public unsigned DI
        size <integer_cst 0x7f4812c24be8 constant 64>
        unit size <integer_cst 0x7f4812c24c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality>
    var <var_decl 0x7f4812768000 p>
    def_stmt GIMPLE_NOP
    version 20
    ptr-info 0x7f4812759b70>
GIMPLE_NOP

 ================== trace ptable================== 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr--------
this other function -----------
 
 Start check Pointer Collect  

======================================================================

 Expand conflict 
 The same function may have multiple branches :foo
# .MEM_47 = VDEF <.MEM_32>
foo (p_20(D));
test.c:58:4: warning: use location
    foo(p);
    ^
# .MEM_43 = VDEF <.MEM_32>
foo (p_20(D));
test.c:84:3: warning: use location
   foo(p);
   ^
=======================Path Constaint===========================

succs:= 18
if (test_16(D) == test2_17(D))
test.c:83:10: warning: use location
  else if (test == test2)
          ^
	relate logic:= 1
succs:= 8
if (test_16(D) != 0)
test.c:50:5: warning: use location
  if (test)
     ^
	relate logic:= 1
=======================Path Constaint===========================


 Expand conflict 
 The same function may have multiple branches :foo
# .MEM_47 = VDEF <.MEM_32>
foo (p_20(D));
test.c:58:4: warning: use location
    foo(p);
    ^
# .MEM_50 = VDEF <.MEM_33>
foo (p_20(D));
test.c:79:4: warning: use location
    foo(p);
    ^
=======================Path Constaint===========================

succs:= 16
if (test3_29(D) != 0)
test.c:77:6: warning: use location
   if (test3)
      ^
	relate logic:= 1
succs:= 9
if (test_16(D) > test2_17(D))
test.c:56:6: warning: use location
   if (test > test2)
      ^
	relate logic:= 1
succs:= 8
if (test_16(D) != 0)
test.c:50:5: warning: use location
  if (test)
     ^
	relate logic:= 1
=======================Path Constaint===========================


 Expand conflict 
 The same function may have multiple branches :foo
# .MEM_47 = VDEF <.MEM_32>
foo (p_20(D));
test.c:58:4: warning: use location
    foo(p);
    ^
# .MEM_44 = VDEF <.MEM_32>
foo (p_20(D));
test.c:68:4: warning: use location
    foo(p);
    ^
=======================Path Constaint===========================

=succs:= 9
if (test_16(D) > test2_17(D))
test.c:56:6: warning: use location
   if (test > test2)
      ^
	relate logic:= 0
=succs:= 8
if (test_16(D) != 0)
test.c:50:5: warning: use location
  if (test)
     ^
	relate logic:= 1
=======================Path Constaint===========================


 Expand conflict 
 The same function may have multiple branches :foo
# .MEM_47 = VDEF <.MEM_32>
foo (p_20(D));
test.c:58:4: warning: use location
    foo(p);
    ^
# .MEM_48 = VDEF <.MEM_47>
foo (p_20(D));
test.c:64:5: warning: use location
     foo(p);
     ^
=======================Path Constaint===========================

=succs:= 10
if (test_16(D) < test2_17(D))
test.c:59:7: warning: use location
    if (test < test2)
       ^
	relate logic:= 0
=succs:= 9
if (test_16(D) > test2_17(D))
test.c:56:6: warning: use location
   if (test > test2)
      ^
	relate logic:= 1
=succs:= 8
if (test_16(D) != 0)
test.c:50:5: warning: use location
  if (test)
     ^
	relate logic:= 1
=======================Path Constaint===========================


 Expand conflict 
 The same function may have multiple branches :foo
# .MEM_47 = VDEF <.MEM_32>
foo (p_20(D));
test.c:58:4: warning: use location
    foo(p);
    ^
# .MEM_49 = VDEF <.MEM_47>
foo (p_20(D));
test.c:61:5: warning: use location
     foo(p);
     ^
=======================Path Constaint===========================

succs:= 10
if (test_16(D) < test2_17(D))
test.c:59:7: warning: use location
    if (test < test2)
       ^
	relate logic:= 1
succs:= 9
if (test_16(D) > test2_17(D))
test.c:56:6: warning: use location
   if (test > test2)
      ^
	relate logic:= 1
succs:= 8
if (test_16(D) != 0)
test.c:50:5: warning: use location
  if (test)
     ^
	relate logic:= 1
=======================Path Constaint===========================

# .MEM_47 = VDEF <.MEM_32>
foo (p_20(D));
foo (p_20(D));
test.c:58:4: warning: use location
    foo(p);
    ^
this stmt is child function---foo-----

 ================== trace ================== 
 <ssa_name 0x7f4812c2cb40
    type <pointer_type 0x7f4812c3fa80
        type <integer_type 0x7f4812c385e8 int public SI
            size <integer_cst 0x7f4812c24e28 constant 32>
            unit size <integer_cst 0x7f4812c24e40 constant 4>
            align 32 symtab 0 alias set -1 canonical type 0x7f4812c385e8 precision 32 min <integer_cst 0x7f4812c24de0 -2147483648> max <integer_cst 0x7f4812c24df8 2147483647>
            pointer_to_this <pointer_type 0x7f4812c3fa80>>
        public unsigned DI
        size <integer_cst 0x7f4812c24be8 constant 64>
        unit size <integer_cst 0x7f4812c24c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality>
    var <var_decl 0x7f4812768000 p>
    def_stmt GIMPLE_NOP
    version 20
    ptr-info 0x7f4812759b70>
trace fucntion name:foo 
[40;44m =======trace_function_path foo  function_call count: 1 level :0========  [0m
[40;36m ======= node_fun:foo========= [0m
[40;36m ======= find relate stmt with p ========= [0m
[40;36m ======= relate stmt argument:p ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:malloc========= [0m
[40;46m =======add node_fun stack:malloc========= [0m

 ================== trace ================== 
trace fucntion free:0 

 ================== Start Use after free Check ================== 

dot graph END

 ================== Start Use after free Check ================== 

======================================================================
[40;31m    no free stmt possible memory leak [0m

======================================================================

dot graph START

======================================================================
 <ssa_name 0x7f4812c2cb40
    type <pointer_type 0x7f4812c3fa80
        type <integer_type 0x7f4812c385e8 int public SI
            size <integer_cst 0x7f4812c24e28 constant 32>
            unit size <integer_cst 0x7f4812c24e40 constant 4>
            align 32 symtab 0 alias set -1 canonical type 0x7f4812c385e8 precision 32 min <integer_cst 0x7f4812c24de0 -2147483648> max <integer_cst 0x7f4812c24df8 2147483647>
            pointer_to_this <pointer_type 0x7f4812c3fa80>>
        public unsigned DI
        size <integer_cst 0x7f4812c24be8 constant 64>
        unit size <integer_cst 0x7f4812c24c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality>
    var <var_decl 0x7f4812768000 p>
    def_stmt GIMPLE_NOP
    version 20
    ptr-info 0x7f4812759b70>
 <ssa_name 0x7f4812c2cb40
    type <pointer_type 0x7f4812c3fa80
        type <integer_type 0x7f4812c385e8 int public SI
            size <integer_cst 0x7f4812c24e28 constant 32>
            unit size <integer_cst 0x7f4812c24e40 constant 4>
            align 32 symtab 0 alias set -1 canonical type 0x7f4812c385e8 precision 32 min <integer_cst 0x7f4812c24de0 -2147483648> max <integer_cst 0x7f4812c24df8 2147483647>
            pointer_to_this <pointer_type 0x7f4812c3fa80>>
        public unsigned DI
        size <integer_cst 0x7f4812c24be8 constant 64>
        unit size <integer_cst 0x7f4812c24c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality>
    var <var_decl 0x7f4812768000 p>
    def_stmt GIMPLE_NOP
    version 20
    ptr-info 0x7f4812759b70>
GIMPLE_NOP

 ================== trace ptable================== 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr--------
this other function -----------
 
 Start check Pointer Collect  

======================================================================

 Expand conflict 
 The same function may have multiple branches :foo
# .MEM_49 = VDEF <.MEM_47>
foo (p_20(D));
test.c:61:5: warning: use location
     foo(p);
     ^
# .MEM_43 = VDEF <.MEM_32>
foo (p_20(D));
test.c:84:3: warning: use location
   foo(p);
   ^
=======================Path Constaint===========================

succs:= 18
if (test_16(D) == test2_17(D))
test.c:83:10: warning: use location
  else if (test == test2)
          ^
	relate logic:= 1
succs:= 8
if (test_16(D) != 0)
test.c:50:5: warning: use location
  if (test)
     ^
	relate logic:= 1
=======================Path Constaint===========================


 Expand conflict 
 The same function may have multiple branches :foo
# .MEM_49 = VDEF <.MEM_47>
foo (p_20(D));
test.c:61:5: warning: use location
     foo(p);
     ^
# .MEM_50 = VDEF <.MEM_33>
foo (p_20(D));
test.c:79:4: warning: use location
    foo(p);
    ^
=======================Path Constaint===========================

succs:= 16
if (test3_29(D) != 0)
test.c:77:6: warning: use location
   if (test3)
      ^
	relate logic:= 1
succs:= 9
if (test_16(D) > test2_17(D))
test.c:56:6: warning: use location
   if (test > test2)
      ^
	relate logic:= 1
succs:= 8
if (test_16(D) != 0)
test.c:50:5: warning: use location
  if (test)
     ^
	relate logic:= 1
=======================Path Constaint===========================


 Expand conflict 
 The same function may have multiple branches :foo
# .MEM_49 = VDEF <.MEM_47>
foo (p_20(D));
test.c:61:5: warning: use location
     foo(p);
     ^
# .MEM_44 = VDEF <.MEM_32>
foo (p_20(D));
test.c:68:4: warning: use location
    foo(p);
    ^
=======================Path Constaint===========================

=succs:= 9
if (test_16(D) > test2_17(D))
test.c:56:6: warning: use location
   if (test > test2)
      ^
	relate logic:= 0
=succs:= 8
if (test_16(D) != 0)
test.c:50:5: warning: use location
  if (test)
     ^
	relate logic:= 1
=======================Path Constaint===========================


 Expand conflict 
 The same function may have multiple branches :foo
# .MEM_49 = VDEF <.MEM_47>
foo (p_20(D));
test.c:61:5: warning: use location
     foo(p);
     ^
# .MEM_48 = VDEF <.MEM_47>
foo (p_20(D));
test.c:64:5: warning: use location
     foo(p);
     ^
=======================Path Constaint===========================

=succs:= 10
if (test_16(D) < test2_17(D))
test.c:59:7: warning: use location
    if (test < test2)
       ^
	relate logic:= 0
=succs:= 9
if (test_16(D) > test2_17(D))
test.c:56:6: warning: use location
   if (test > test2)
      ^
	relate logic:= 1
=succs:= 8
if (test_16(D) != 0)
test.c:50:5: warning: use location
  if (test)
     ^
	relate logic:= 1
=======================Path Constaint===========================

# .MEM_49 = VDEF <.MEM_47>
foo (p_20(D));
foo (p_20(D));
test.c:61:5: warning: use location
     foo(p);
     ^
this stmt is child function---foo-----

 ================== trace ================== 
 <ssa_name 0x7f4812c2cb40
    type <pointer_type 0x7f4812c3fa80
        type <integer_type 0x7f4812c385e8 int public SI
            size <integer_cst 0x7f4812c24e28 constant 32>
            unit size <integer_cst 0x7f4812c24e40 constant 4>
            align 32 symtab 0 alias set -1 canonical type 0x7f4812c385e8 precision 32 min <integer_cst 0x7f4812c24de0 -2147483648> max <integer_cst 0x7f4812c24df8 2147483647>
            pointer_to_this <pointer_type 0x7f4812c3fa80>>
        public unsigned DI
        size <integer_cst 0x7f4812c24be8 constant 64>
        unit size <integer_cst 0x7f4812c24c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality>
    var <var_decl 0x7f4812768000 p>
    def_stmt GIMPLE_NOP
    version 20
    ptr-info 0x7f4812759b70>
trace fucntion name:foo 
[40;44m =======trace_function_path foo  function_call count: 1 level :0========  [0m
[40;36m ======= node_fun:foo========= [0m
[40;36m ======= find relate stmt with p ========= [0m
[40;36m ======= relate stmt argument:p ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:malloc========= [0m
[40;46m =======add node_fun stack:malloc========= [0m

 ================== trace ================== 
trace fucntion free:0 

 Expand conflict 
 The same function may have multiple branches :foo
# .MEM_49 = VDEF <.MEM_47>
foo (p_20(D));
test.c:61:5: warning: use location
# .MEM_47 = VDEF <.MEM_32>
foo (p_20(D));
test.c:58:4: warning: use location
    foo(p);
    ^
=======================Path Constaint===========================

succs:= 9
if (test_16(D) > test2_17(D))
test.c:56:6: warning: use location
   if (test > test2)
      ^
	relate logic:= 1
succs:= 8
if (test_16(D) != 0)
test.c:50:5: warning: use location
  if (test)
     ^
	relate logic:= 1
=======================Path Constaint===========================


 ================== Start Use after free Check ================== 

dot graph END

 ================== Start Use after free Check ================== 

======================================================================
[40;31m    no free stmt possible memory leak [0m

======================================================================

dot graph START

======================================================================
 <ssa_name 0x7f4812c2cb88
    type <pointer_type 0x7f4812c3fa80
        type <integer_type 0x7f4812c385e8 int public SI
            size <integer_cst 0x7f4812c24e28 constant 32>
            unit size <integer_cst 0x7f4812c24e40 constant 4>
            align 32 symtab 0 alias set -1 canonical type 0x7f4812c385e8 precision 32 min <integer_cst 0x7f4812c24de0 -2147483648> max <integer_cst 0x7f4812c24df8 2147483647>
            pointer_to_this <pointer_type 0x7f4812c3fa80>>
        public unsigned DI
        size <integer_cst 0x7f4812c24be8 constant 64>
        unit size <integer_cst 0x7f4812c24c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality>
    var <var_decl 0x7f48139b9f30 p3>
    def_stmt GIMPLE_NOP
    version 24
    ptr-info 0x7f4812759b88>
 <ssa_name 0x7f4812c2cb88
    type <pointer_type 0x7f4812c3fa80
        type <integer_type 0x7f4812c385e8 int public SI
            size <integer_cst 0x7f4812c24e28 constant 32>
            unit size <integer_cst 0x7f4812c24e40 constant 4>
            align 32 symtab 0 alias set -1 canonical type 0x7f4812c385e8 precision 32 min <integer_cst 0x7f4812c24de0 -2147483648> max <integer_cst 0x7f4812c24df8 2147483647>
            pointer_to_this <pointer_type 0x7f4812c3fa80>>
        public unsigned DI
        size <integer_cst 0x7f4812c24be8 constant 64>
        unit size <integer_cst 0x7f4812c24c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality>
    var <var_decl 0x7f48139b9f30 p3>
    def_stmt GIMPLE_NOP
    version 24
    ptr-info 0x7f4812759b88>
GIMPLE_NOP

 ================== trace ptable================== 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr--------
this other function -----------
 
 Start check Pointer Collect  

======================================================================
# .MEM_46 = VDEF <.MEM_44>
foo (p3_24(D));
foo (p3_24(D));
test.c:71:5: warning: use location
     foo(p3);
     ^
this stmt is child function---foo-----

 ================== trace ================== 
 <ssa_name 0x7f4812c2cb88
    type <pointer_type 0x7f4812c3fa80
        type <integer_type 0x7f4812c385e8 int public SI
            size <integer_cst 0x7f4812c24e28 constant 32>
            unit size <integer_cst 0x7f4812c24e40 constant 4>
            align 32 symtab 0 alias set -1 canonical type 0x7f4812c385e8 precision 32 min <integer_cst 0x7f4812c24de0 -2147483648> max <integer_cst 0x7f4812c24df8 2147483647>
            pointer_to_this <pointer_type 0x7f4812c3fa80>>
        public unsigned DI
        size <integer_cst 0x7f4812c24be8 constant 64>
        unit size <integer_cst 0x7f4812c24c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality>
    var <var_decl 0x7f48139b9f30 p3>
    def_stmt GIMPLE_NOP
    version 24
    ptr-info 0x7f4812759b88>
trace fucntion name:foo 
[40;44m =======trace_function_path foo  function_call count: 1 level :0========  [0m
[40;36m ======= node_fun:foo========= [0m
[40;36m ======= find relate stmt with p3 ========= [0m
[40;36m ======= relate stmt argument:p3 ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:malloc========= [0m
[40;46m =======add node_fun stack:malloc========= [0m

 ================== trace ================== 
trace fucntion free:0 

 ================== Start Use after free Check ================== 

dot graph END

 ================== Start Use after free Check ================== 

======================================================================
[40;31m    no free stmt possible memory leak [0m

======================================================================

dot graph START

======================================================================
 <ssa_name 0x7f4812c2caf8
    type <pointer_type 0x7f4812c3fa80
        type <integer_type 0x7f4812c385e8 int public SI
            size <integer_cst 0x7f4812c24e28 constant 32>
            unit size <integer_cst 0x7f4812c24e40 constant 4>
            align 32 symtab 0 alias set -1 canonical type 0x7f4812c385e8 precision 32 min <integer_cst 0x7f4812c24de0 -2147483648> max <integer_cst 0x7f4812c24df8 2147483647>
            pointer_to_this <pointer_type 0x7f4812c3fa80>>
        public unsigned DI
        size <integer_cst 0x7f4812c24be8 constant 64>
        unit size <integer_cst 0x7f4812c24c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality>
    var <var_decl 0x7f48139b9ea0 p4>
    def_stmt GIMPLE_NOP
    version 18
    ptr-info 0x7f4812759b58>
 <ssa_name 0x7f4812c2caf8
    type <pointer_type 0x7f4812c3fa80
        type <integer_type 0x7f4812c385e8 int public SI
            size <integer_cst 0x7f4812c24e28 constant 32>
            unit size <integer_cst 0x7f4812c24e40 constant 4>
            align 32 symtab 0 alias set -1 canonical type 0x7f4812c385e8 precision 32 min <integer_cst 0x7f4812c24de0 -2147483648> max <integer_cst 0x7f4812c24df8 2147483647>
            pointer_to_this <pointer_type 0x7f4812c3fa80>>
        public unsigned DI
        size <integer_cst 0x7f4812c24be8 constant 64>
        unit size <integer_cst 0x7f4812c24c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality>
    var <var_decl 0x7f48139b9ea0 p4>
    def_stmt GIMPLE_NOP
    version 18
    ptr-info 0x7f4812759b58>
GIMPLE_NOP

 ================== trace ptable================== 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr--------
this other function -----------

======================================================================
[40;31m 	Can't find this fucntion in Pointer table [0m
[40;31m 	Possiable no other stmt relate with this stmt [0m

======================================================================
[40;33m =======POP node_fun stack:main========= [0m
fucntion collect path finsh
=======Mapping node_fun:foo=========
=======is loop:0=========
<bb 2> [100.00%]:
_1 = malloc (10);
_2 = (long int) _1;
_3 = (int) _2;
*z_6(D) = _3;
return;

=======Mapping node_fun:main=========
=======is loop:0=========
<bb 2> [8.03%]:

=======is loop:1=========
label2 [14.45%]:
foo (p5_9(D));
goto <bb 23>; [100.00%]

=======is loop:1=========
label3 [85.55%]:

=======is loop:1=========
<bb 23> [100.00%]:
foo (p5_9(D));
_1 = test5_12(D) / 10;
switch (_1) <default: <L4> [33.33%], case 5: <L2> [33.33%], case 10: <L3> [33.33%]>

=======is loop:1=========
<L2> [33.33%]:
foo (p5_9(D));
goto <bb 8>; [100.00%]

=======is loop:1=========
<L3> [33.33%]:
foo (p5_9(D));
goto <bb 8>; [100.00%]

=======is loop:1=========
<L4> [33.33%]:
foo (p5_9(D));

=======is loop:1=========
<bb 8> [99.99%]:
if (test_16(D) != 0)
  goto <bb 9>; [92.50%]
else
  goto <bb 18>; [7.50%]

=======is loop:1=========
<bb 9> [92.49%]:
if (test_16(D) > test2_17(D))
  goto <bb 10>; [7.50%]
else
  goto <bb 13>; [92.50%]

=======is loop:1=========
<bb 10> [6.94%]:
foo (p_20(D));
if (test_16(D) < test2_17(D))
  goto <bb 11>; [50.00%]
else
  goto <bb 12>; [50.00%]

=======is loop:1=========
<bb 11> [3.47%]:
foo (p_20(D));
goto <bb 16>; [100.00%]

=======is loop:1=========
<bb 12> [3.47%]:
foo (p_20(D));
goto <bb 16>; [100.00%]

=======is loop:1=========
<bb 13> [85.55%]:
foo (p_20(D));
if (test_16(D) < test2_17(D))
  goto <bb 14>; [50.00%]
else
  goto <bb 15>; [50.00%]

=======is loop:1=========
<bb 14> [42.78%]:
foo (p3_24(D));
goto <bb 4> (label3); [100.00%]

=======is loop:1=========
<bb 15> [42.78%]:
foo (p5_9(D));
goto <bb 4> (label3); [100.00%]

=======is loop:1=========
<bb 16> [6.94%]:
if (test3_29(D) != 0)
  goto <bb 17>; [92.50%]
else
  goto <bb 22>; [7.50%]

=======is loop:1=========
<bb 17> [6.42%]:
foo (p_20(D));
goto <bb 3> (label2); [100.00%]

=======is loop:0=========
<bb 18> [7.50%]:
if (test_16(D) == test2_17(D))
  goto <bb 19>; [17.77%]
else
  goto <bb 20>; [82.23%]

=======is loop:0=========
<bb 19> [1.33%]:
foo (p_20(D));
goto <bb 22>; [100.00%]

=======is loop:0=========
<bb 20> [6.17%]:
if (test_16(D) > test2_17(D))
  goto <bb 21>; [36.64%]
else
  goto <bb 22>; [63.36%]

=======is loop:0=========
<bb 21> [2.26%]:
foo (p4_18(D));

=======is loop:0=========
<bb 22> [8.02%]:
return 0;

[40;32mSTART CHECKSTART CHECKSTART CHECKSTART CHECKSTART CHECK[0m
    =()=
 ,/'_||_
  (___  `.
 ./  `=='
                   
    ~~~~~~~~~~~  
 ~~~~~~
           ~~~~~~~
[40;34m    find Entry point : 4 [0m
[40;34m    used_stmt array stack totalsize of : 480 [0m
[40;34m    collect time: : 0.000267 s [0m
[40;34m    algorithm time: 0.007575 s [0m
[40;34m    gimple stmt count : : 34 [0m
[40;32mSTART CHECKSTART CHECKSTART CHECKSTART CHECKSTART CHECK[0m
