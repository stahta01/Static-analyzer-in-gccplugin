../Compiler/newplugin.so 11.2.0 

Time variable                                   usr           sys          wall           GGC
 phase setup                        :   0.00 (  0%)   0.00 (  0%)   0.01 ( 17%)  1298k ( 57%)
 phase parsing                      :   0.04 ( 80%)   0.00 (  0%)   0.03 ( 50%)   941k ( 41%)
 phase opt and generate             :   0.01 ( 20%)   0.00 (  0%)   0.02 ( 33%)    42k (  2%)
 callgraph ipa passes               :   0.01 ( 20%)   0.00 (  0%)   0.02 ( 33%)    28k (  1%)
 lto stream compression             :   0.00 (  0%)   0.00 (  0%)   0.01 ( 17%)     0  (  0%)
 ipa free lang data                 :   0.00 (  0%)   0.00 (  0%)   0.01 ( 17%)  5152  (  0%)
 preprocessing                      :   0.03 ( 60%)   0.00 (  0%)   0.01 ( 17%)   270k ( 12%)
 lexical analysis                   :   0.01 ( 20%)   0.00 (  0%)   0.00 (  0%)     0  (  0%)
 parser (global)                    :   0.00 (  0%)   0.00 (  0%)   0.02 ( 33%)   583k ( 25%)
 tree PTA                           :   0.01 ( 20%)   0.00 (  0%)   0.00 (  0%)   136  (  0%)
 TOTAL                              :   0.05          0.00          0.06         2292k
../Compiler/newplugin.so 11.2.0 
test2.c: In function â€˜foo2â€™:
test2.c:3:7: warning: implicit declaration of function â€˜mallocâ€™ [-Wimplicit-function-declaration]
    3 |     d=malloc(10);
      |       ^~~~~~
test2.c:1:1: note: include â€˜<stdlib.h>â€™ or provide a declaration of â€˜mallocâ€™
  +++ |+#include <stdlib.h>
    1 | int *foo2(void){
test2.c:3:7: warning: incompatible implicit declaration of built-in function â€˜mallocâ€™ [-Wbuiltin-declaration-mismatch]
    3 |     d=malloc(10);
      |       ^~~~~~
test2.c:3:7: note: include â€˜<stdlib.h>â€™ or provide a declaration of â€˜mallocâ€™

Time variable                                   usr           sys          wall           GGC
 phase setup                        :   0.00 (  0%)   0.00 (  0%)   0.00 (  0%)  1298k ( 88%)
 phase opt and generate             :   0.01 (100%)   0.01 (100%)   0.01 (100%)    26k (  2%)
 callgraph ipa passes               :   0.01 (100%)   0.01 (100%)   0.01 (100%)    16k (  1%)
 lto stream compression             :   0.00 (  0%)   0.00 (  0%)   0.01 (100%)     0  (  0%)
 plugin execution                   :   0.01 (100%)   0.01 (100%)   0.00 (  0%)     0  (  0%)
 TOTAL                              :   0.01          0.01          0.01         1477k
../Compiler/newplugin.so 11.2.0 

Time variable                                   usr           sys          wall           GGC
 phase setup                        :   0.00 (  0%)   0.00 (  0%)   0.00 (  0%)  2157k ( 98%)
 phase stream in                    :   0.01 (100%)   0.00 (  0%)   0.01 (100%)    31k (  1%)
 ipa lto decl in                    :   0.00 (  0%)   0.00 (  0%)   0.01 (100%)    24k (  1%)
 TOTAL                              :   0.01          0.00          0.01         2190k
../Compiler/newplugin.so 11.2.0 
--------plugin argument-----------
contextsentive 1
debugoutput 1
prebranchexit 1
traceallfucntion 0
retnotheapobjskipcheck 1
debugmod 0
relatemod 1
=======ipa_pta=========
=============== The first stage : Point of interest stmt collect =================
=======node_fun:foo=========
=======node_fun:foo2=========
=======node_fun:main=========
=============== The first stage :  record fucntion =================
start PointerConstraint
ptable point 7 
===============The second stage : Mapping stmt=================
# .MEM_12 = VDEF <.MEM_10(D)>
b_8 = foo2 ();
# .MEM_11 = VDEF <.MEM_10(D)>
b_6 = foo2 ();
# .MEM_5 = VDEF <.MEM_4(D)>
d_3 = malloc (10);
# .MEM_30 = VDEF <.MEM_29(D)>
srand (10);
# .MEM_31 = VDEF <.MEM_27>
_1 = rand ();
# .MEM_32 = VDEF <.MEM_31>
p_13 = foo ();
# .MEM_43 = VDEF <.MEM_42>
printf ("%d\n", p_13);
===============The second stage : Program slicing=================
=============== *this point analyzable =================
b_8 = foo2 ();
=============== program slcing stmt count:1=================
test2.c:12:13: warning: use location
   12 |         b = foo2();
      |             ^
========================================================
=============== *this point analyzable =================
b_6 = foo2 ();
=============== program slcing stmt count:1=================
test2.c:14:13: warning: use location
   14 |         b = foo2();
      |             ^
========================================================
=============== *this point analyzable =================
d_3 = malloc (10);
=============== program slcing stmt count:0=================
test2.c:3:7: warning: use location
    3 |     d=malloc(10);
      |       ^
========================================================
=============== *this point analyzable =================
_1 = rand ();
=============== program slcing stmt count:1=================
test.c:10:23: warning: use location
   10 |                 test= rand()% (10 - 0 + 1) + 0;
      |                       ^
========================================================
=============== *this point analyzable =================
p_13 = foo ();
=============== program slcing stmt count:12=================
test.c:11:19: warning: use location
   11 |                 p=foo();
      |                   ^
========================================================
===============The second stage : build fucntion type=================
[40;41mSTART CHECKSTART CHECKSTART CHECKSTART CHECKSTART CHECK[0m
[40;41mSTART CHECKSTART CHECKSTART CHECKSTART CHECKSTART CHECK[0m
    =()=
 ,/'_||_
  (___  `.
 ./  `=='
      |||
      |||
      |||
      |||
[40;41mSTART CHECKSTART CHECKSTART CHECKSTART CHECKSTART CHECK[0m
[40;41mSTART CHECKSTART CHECKSTART CHECKSTART CHECKSTART CHECK[0m

=============== The third stage : Start detection  =================
[40;44m =======print_function_path main  function_call count: 5 level :0========  [0m
[40;44m =======print_function_type 0  ========  [0m
[40;42m =======pre add _ fucntion:free========= [0m
[40;42m =======pre add _ fucntion:printf========= [0m
[40;42m =======pre add _ fucntion:foo========= [0m
[40;44m =======print_function_path foo  function_call count: 1 level :1========  [0m
[40;44m =======print_function_type 0  ========  [0m
[40;42m =======pre add _ fucntion:foo2========= [0m
[40;44m =======print_function_path foo2  function_call count: 1 level :2========  [0m
[40;44m =======print_function_type 2  ========  [0m
[40;42m =======pre add _ fucntion:malloc========= [0m
[40;42m =======pre_check_funciton:foo2========= [0m
[40;42m =======start_check_funciton:foo2========= [0m

=============================output_basic_block_stage==================================
alloc index -1

=============================output_basic_block_stage==================================
alloc index -1

dot graph START

======================================================================

 ================== pre trace ptable ================== 
trace fucntion name:malloc 

 ================== pre trace ptable finish================== 

 ================== gimple stmt ================== 
# .MEM_5 = VDEF <.MEM_4(D)>
d_3 = malloc (10);
is Reserved word function :malloc

 ================== gimple tree ================== 
 <ssa_name 0x7fc328c89870
    type <pointer_type 0x7fc328c9d9d8
        type <integer_type 0x7fc328c965e8 int public SI
            size <integer_cst 0x7fc328c81df8 constant 32>
            unit-size <integer_cst 0x7fc328c81e10 constant 4>
            align:32 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7fc328c965e8 precision:32 min <integer_cst 0x7fc328c81db0 -2147483648> max <integer_cst 0x7fc328c81dc8 2147483647>
            pointer_to_this <pointer_type 0x7fc328c9d9d8>>
        public unsigned DI
        size <integer_cst 0x7fc328c81bb8 constant 64>
        unit-size <integer_cst 0x7fc328c81bd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
    var <var_decl 0x7fc32952bd80 d>
    def_stmt d_3 = malloc (10);
    version:3
    ptr-info 0x7fc32878f318>
 
 Start check Pointer Collect  

======================================================================
return d_3;
In function â€˜mainâ€™:
test2.c:4:12: warning: use location
    4 |     return d;
      |            ^

This stmt may duplicate memory requests.
# .MEM_5 = VDEF <.MEM_4(D)>
d_3 = malloc (10);
d_3 = malloc (10);
test2.c:3:7: warning: use location
    3 |     d=malloc(10);
      |       ^
this stmt call this function :malloc

This stmt may duplicate memory requests.

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 

=====================prebranchexit:start================

=====================prebranchexit:end================
 
 Finish check Pointer Collect  

======================================================================
[40;35m  	Looserules free count:0 [0m
[40;31m  	free count:0 [0m

======================================================================

======================================================================
[40;31m    no free stmt possible memory leak [0m

======================================================================

======================================================================

=============================output_basic_block_stage==================================
alloc index 2
[2,1,0,1],

=============================output_basic_block_stage==================================
alloc index -1

=============================output_basic_block_stage==================================
alloc index -1
[40;42m =======pre_check_funciton:foo========= [0m
[40;42m =======start_check_funciton:foo========= [0m

dot graph START

======================================================================

 ================== pre trace ptable ================== 
trace fucntion name:foo2 
[40;44m =======trace_function_path foo2  function_call count: 1 level :888========  [0m
[40;31m  find return stmt  [0m
[40;31m  this fucntion return heap-object  [0m
# VUSE <.MEM_5>
return d_3;
test2.c:4:12: warning: use location
    4 |     return d;
      |            ^
[40;42m =======pre add _ fucntion:malloc========= [0m
[40;46m =======add node_fun stack:malloc========= [0m
some fucntion return value is heap-object and with Collection SSA_NAME alias relation

 ================== pre trace ptable finish================== 

 ================== gimple stmt ================== 
# .MEM_12 = VDEF <.MEM_10(D)>
b_8 = foo2 ();
is Other function foo2

 ================== gimple tree ================== 
 <ssa_name 0x7fc328c89708
    type <pointer_type 0x7fc328c9d9d8
        type <integer_type 0x7fc328c965e8 int public SI
            size <integer_cst 0x7fc328c81df8 constant 32>
            unit-size <integer_cst 0x7fc328c81e10 constant 4>
            align:32 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7fc328c965e8 precision:32 min <integer_cst 0x7fc328c81db0 -2147483648> max <integer_cst 0x7fc328c81dc8 2147483647>
            pointer_to_this <pointer_type 0x7fc328c9d9d8>>
        public unsigned DI
        size <integer_cst 0x7fc328c81bb8 constant 64>
        unit-size <integer_cst 0x7fc328c81bd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
    var <var_decl 0x7fc32952bbd0 b>
    def_stmt b_8 = foo2 ();
    version:8
    ptr-info 0x7fc32878f300>
 
 Start check Pointer Collect  

======================================================================
b_1 = PHI <b_8(3), b_6(4)>
lto1: warning: use location
this stmt have mutiple branch ---foo2-----
# .MEM_12 = VDEF <.MEM_10(D)>
b_8 = foo2 ();
b_8 = foo2 ();
test2.c:12:13: warning: use location
   12 |         b = foo2();
      |             ^
this stmt call this function :foo2
trace fucntion name:foo2 
[40;44m =======trace_function_path foo2  function_call count: 1 level :0========  [0m
[40;36m ======= node_fun:foo2========= [0m
[40;36m ======= find relate stmt with b ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:malloc========= [0m
[40;46m =======add node_fun stack:malloc========= [0m

 ================== trace ================== 
trace fucntion free:0 

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 

=====================prebranchexit:start================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_12 = VDEF <.MEM_10(D)>
b_8 = foo2 ();
In function â€˜fooâ€™:
test2.c:12:13: warning: use location
# VUSE <.MEM_9>
return b_1;
test2.c:15:12: warning: use location
   15 |     return b;
      |            ^
gimple stmt in succ := 3 
In fucntion name:foo 
branch in succ := 5 have 

======================================================================

=====================prebranchexit:end================
 
 Finish check Pointer Collect  

======================================================================
[40;35m  	Looserules free count:0 [0m
[40;31m  	free count:0 [0m

======================================================================

======================================================================
[40;31m    no free stmt possible memory leak [0m

======================================================================

======================================================================

=============================output_basic_block_stage==================================
alloc index 3
[5,1,0,1],
[3,1,0,0],

dot graph START

======================================================================

 ================== pre trace ptable ================== 
trace fucntion name:foo2 
[40;44m =======trace_function_path foo2  function_call count: 1 level :888========  [0m
[40;31m  find return stmt  [0m
[40;31m  this fucntion return heap-object  [0m
# VUSE <.MEM_5>
return d_3;
In function â€˜mainâ€™:
test2.c:4:12: warning: use location
    4 |     return d;
      |            ^
[40;42m =======pre add _ fucntion:malloc========= [0m
[40;46m =======add node_fun stack:malloc========= [0m
some fucntion return value is heap-object and with Collection SSA_NAME alias relation

 ================== pre trace ptable finish================== 

 ================== gimple stmt ================== 
# .MEM_11 = VDEF <.MEM_10(D)>
b_6 = foo2 ();
is Other function foo2

 ================== gimple tree ================== 
 <ssa_name 0x7fc328c896c0
    type <pointer_type 0x7fc328c9d9d8
        type <integer_type 0x7fc328c965e8 int public SI
            size <integer_cst 0x7fc328c81df8 constant 32>
            unit-size <integer_cst 0x7fc328c81e10 constant 4>
            align:32 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7fc328c965e8 precision:32 min <integer_cst 0x7fc328c81db0 -2147483648> max <integer_cst 0x7fc328c81dc8 2147483647>
            pointer_to_this <pointer_type 0x7fc328c9d9d8>>
        public unsigned DI
        size <integer_cst 0x7fc328c81bb8 constant 64>
        unit-size <integer_cst 0x7fc328c81bd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
    var <var_decl 0x7fc32952bbd0 b>
    def_stmt b_6 = foo2 ();
    version:6
    ptr-info 0x7fc32878f2e8>
 
 Start check Pointer Collect  

======================================================================
b_1 = PHI <b_8(3), b_6(4)>
lto1: warning: use location
this stmt have mutiple branch ---foo2-----
# .MEM_11 = VDEF <.MEM_10(D)>
b_6 = foo2 ();
b_6 = foo2 ();
test2.c:14:13: warning: use location
   14 |         b = foo2();
      |             ^
this stmt call this function :foo2
trace fucntion name:foo2 
[40;44m =======trace_function_path foo2  function_call count: 1 level :0========  [0m
[40;36m ======= node_fun:foo2========= [0m
[40;36m ======= find relate stmt with b ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:malloc========= [0m
[40;46m =======add node_fun stack:malloc========= [0m

 ================== trace ================== 
trace fucntion free:0 

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 

=====================prebranchexit:start================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_11 = VDEF <.MEM_10(D)>
b_6 = foo2 ();
In function â€˜fooâ€™:
test2.c:14:13: warning: use location
# VUSE <.MEM_9>
return b_1;
test2.c:15:12: warning: use location
   15 |     return b;
      |            ^
gimple stmt in succ := 4 
In fucntion name:foo 
branch in succ := 5 have 

======================================================================

=====================prebranchexit:end================
 
 Finish check Pointer Collect  

======================================================================
[40;35m  	Looserules free count:0 [0m
[40;31m  	free count:0 [0m

======================================================================

======================================================================
[40;31m    no free stmt possible memory leak [0m

======================================================================

======================================================================

=============================output_basic_block_stage==================================
alloc index 4
[5,1,0,1],
[4,1,0,0],

=============================output_basic_block_stage==================================
alloc index -1

=============================output_basic_block_stage==================================
alloc index -1

=============================output_basic_block_stage==================================
alloc index -1
[40;42m =======pre add _ fucntion:rand========= [0m
[40;42m =======pre add _ fucntion:srand========= [0m
[40;42m =======pre_check_funciton:main========= [0m
[40;42m =======start_check_funciton:main========= [0m

=============================output_basic_block_stage==================================
alloc index -1

=============================output_basic_block_stage==================================
alloc index -1

=============================output_basic_block_stage==================================
alloc index -1

dot graph START

======================================================================

 ================== pre trace ptable ================== 
trace fucntion name:rand 

 ================== pre trace ptable finish================== 

 ================== gimple stmt ================== 
# .MEM_31 = VDEF <.MEM_27>
_1 = rand ();
is Other function rand

dot graph START

======================================================================

 ================== pre trace ptable ================== 
trace fucntion name:foo 
[40;44m =======trace_function_path foo  function_call count: 1 level :888========  [0m
[40;31m  find return stmt  [0m
[40;31m  this fucntion return heap-object  [0m
# VUSE <.MEM_9>
return b_1;
In function â€˜mainâ€™:
test2.c:15:12: warning: use location
[40;42m =======pre add _ fucntion:foo2========= [0m
foo2 this fucntion return value is heap-object 
foo this fucntion return value is heap-object foo2
foo2 this fucntion return value is heap-object 
foo this fucntion return value is heap-object foo2
[40;46m =======add node_fun stack:foo2========= [0m
[40;44m =======trace_function_path foo2  function_call count: 1 level :889========  [0m
[40;36m ======= node_fun:foo2========= [0m
[40;36m ======= find relate stmt with p ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:malloc========= [0m
[40;46m =======add node_fun stack:malloc========= [0m
some fucntion return value is heap-object and with Collection SSA_NAME alias relation

 ================== pre trace ptable finish================== 

 ================== gimple stmt ================== 
# .MEM_32 = VDEF <.MEM_31>
p_13 = foo ();
is Other function foo

 ================== gimple tree ================== 
 <ssa_name 0x7fc328c89b40
    type <pointer_type 0x7fc328c9d9d8
        type <integer_type 0x7fc328c965e8 int public SI
            size <integer_cst 0x7fc328c81df8 constant 32>
            unit-size <integer_cst 0x7fc328c81e10 constant 4>
            align:32 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7fc328c965e8 precision:32 min <integer_cst 0x7fc328c81db0 -2147483648> max <integer_cst 0x7fc328c81dc8 2147483647>
            pointer_to_this <pointer_type 0x7fc328c9d9d8>>
        public unsigned DI
        size <integer_cst 0x7fc328c81bb8 constant 64>
        unit-size <integer_cst 0x7fc328c81bd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
    var <var_decl 0x7fc328796000 p>
    def_stmt p_13 = foo ();
    version:13
    ptr-info 0x7fc32878f360>
 
 Start check Pointer Collect  

======================================================================
p_3 = PHI <p_13(4), p_2(6)>
lto1: warning: use location
this stmt have mutiple branch ---foo-----
free (p_3);
test.c:29:1: warning: use location
   29 | free(p);
      | ^
this stmt call this function :free
free (p_3);
test.c:29:1: warning: use location
[40;32m    HAS FREE STMT count:1 name:free [0m

 ================== find free stmt ================== 
p_2 = PHI <p_9(D)(2), p_13(5)>
lto1: warning: use location
this stmt have mutiple branch ---free-----
free (p_13);
test.c:25:17: warning: use location
   25 |                 free(p);
      |                 ^
this stmt call this function :free
free (p_13);
test.c:25:17: warning: use location
[40;32m    HAS FREE STMT count:2 name:free [0m

 ================== find free stmt ================== 
printf ("%d\n", p_13);
test.c:22:17: warning: use location
   22 |                 printf("%d\n", p);
      |                 ^
this stmt call this function :printf
trace fucntion name:printf 

 ================== trace ================== 
trace fucntion free:2 
MEM[(int *)p_13 + 36B] = 10;
test.c:21:21: warning: use location
   21 |                 p[9]=10;
      |                     ^
MEM[(int *)p_13 + 36B] = 10;
test.c:21:21: warning: use location
MEM[(int *)p_13 + 32B] = 9;
test.c:20:21: warning: use location
   20 |                 p[8]=9;
      |                     ^
MEM[(int *)p_13 + 28B] = 8;
test.c:19:21: warning: use location
   19 |                 p[7]=8;
      |                     ^
MEM[(int *)p_13 + 24B] = 7;
test.c:18:21: warning: use location
   18 |                 p[6]=7;
      |                     ^
MEM[(int *)p_13 + 20B] = 6;
test.c:17:21: warning: use location
   17 |                 p[5]=6;
      |                     ^
MEM[(int *)p_13 + 16B] = 5;
test.c:16:21: warning: use location
   16 |                 p[4]=5;
      |                     ^
MEM[(int *)p_13 + 12B] = 4;
test.c:15:21: warning: use location
   15 |                 p[3]=4;
      |                     ^
MEM[(int *)p_13 + 8B] = 3;
test.c:14:21: warning: use location
   14 |                 p[2]=3;
      |                     ^
MEM[(int *)p_13 + 4B] = 2;
test.c:13:21: warning: use location
   13 |                 p[1]=2;
      |                     ^
*p_13 = 1;
test.c:12:21: warning: use location
   12 |                 p[0]=1;
      |                     ^
# .MEM_32 = VDEF <.MEM_31>
p_13 = foo ();
p_13 = foo ();
test.c:11:19: warning: use location
   11 |                 p=foo();
      |                   ^
this stmt call this function :foo
trace fucntion name:foo 
[40;44m =======trace_function_path foo  function_call count: 1 level :0========  [0m
[40;36m ======= node_fun:foo========= [0m
[40;36m ======= find relate stmt with p ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:foo2========= [0m
foo2 this fucntion return value is heap-object 
foo this fucntion return value is heap-object foo2
foo2 this fucntion return value is heap-object 
foo this fucntion return value is heap-object foo2
[40;46m =======add node_fun stack:foo2========= [0m
[40;44m =======trace_function_path foo2  function_call count: 1 level :1========  [0m
[40;36m ======= node_fun:foo2========= [0m
[40;36m ======= find relate stmt with p ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:malloc========= [0m
[40;46m =======add node_fun stack:malloc========= [0m

 ================== trace ================== 
trace fucntion free:2 

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_44 = VDEF <.MEM_43>
free (p_13);
test.c:25:17: warning: use location
   25 |                 free(p);
      |                 ^
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_45 = VDEF <.MEM_28>
free (p_3);
test.c:29:1: warning: use location
   29 | free(p);
      | ^

=====================prebranchexit:start================
[40;31m    branch possiable have return or exit  [0m
In fucntion name:main 
# .MEM_43 = VDEF <.MEM_42>
printf ("%d\n", p_13);
test.c:22:17: warning: use location
   22 |                 printf("%d\n", p);
      |                 ^
gimple stmt in succ := 3 
// predicted unlikely by goto predictor.
test.c:24:25: warning: use location
   24 |                         goto EXIT;
      |                         ^
branch in succ := 4 have goto
# .MEM_44 = VDEF <.MEM_43>
free (p_13);
test.c:25:17: warning: use location
   25 |                 free(p);
      |                 ^
The path has a release memory in succ := 5 

======================================================================
[40;31m    branch possiable have return or exit  [0m
In fucntion name:main 
# .MEM_43 = VDEF <.MEM_42>
printf ("%d\n", p_13);
test.c:22:17: warning: use location
   22 |                 printf("%d\n", p);
      |                 ^
gimple stmt in succ := 3 
// predicted unlikely by goto predictor.
test.c:24:25: warning: use location
   24 |                         goto EXIT;
      |                         ^
branch in succ := 4 have goto
# .MEM_45 = VDEF <.MEM_28>
free (p_3);
test.c:29:1: warning: use location
   29 | free(p);
      | ^
The path has a release memory in succ := 7 

======================================================================
[40;31m    branch possiable have return or exit  [0m
In fucntion name:main 
# .MEM_43 = VDEF <.MEM_42>
printf ("%d\n", p_13);
test.c:22:17: warning: use location
   22 |                 printf("%d\n", p);
      |                 ^
gimple stmt in succ := 3 
# VUSE <.MEM_45>
return 0;
lto1: warning: use location
branch in succ := 7 have 
# .MEM_44 = VDEF <.MEM_43>
free (p_13);
test.c:25:17: warning: use location
   25 |                 free(p);
      |                 ^
The path has a release memory in succ := 5 

======================================================================
[40;31m    branch possiable have return or exit  [0m
In fucntion name:main 
# .MEM_42 = VDEF <.MEM_41>
MEM[(int *)p_13 + 36B] = 10;
test.c:21:21: warning: use location
   21 |                 p[9]=10;
      |                     ^
gimple stmt in succ := 3 
// predicted unlikely by goto predictor.
test.c:24:25: warning: use location
   24 |                         goto EXIT;
      |                         ^
branch in succ := 4 have goto
# .MEM_44 = VDEF <.MEM_43>
free (p_13);
test.c:25:17: warning: use location
   25 |                 free(p);
      |                 ^
The path has a release memory in succ := 5 

======================================================================
[40;31m    branch possiable have return or exit  [0m
In fucntion name:main 
# .MEM_42 = VDEF <.MEM_41>
MEM[(int *)p_13 + 36B] = 10;
test.c:21:21: warning: use location
   21 |                 p[9]=10;
      |                     ^
gimple stmt in succ := 3 
// predicted unlikely by goto predictor.
test.c:24:25: warning: use location
   24 |                         goto EXIT;
      |                         ^
branch in succ := 4 have goto
# .MEM_45 = VDEF <.MEM_28>
free (p_3);
test.c:29:1: warning: use location
   29 | free(p);
      | ^
The path has a release memory in succ := 7 

======================================================================
[40;31m    branch possiable have return or exit  [0m
In fucntion name:main 
# .MEM_42 = VDEF <.MEM_41>
MEM[(int *)p_13 + 36B] = 10;
test.c:21:21: warning: use location
   21 |                 p[9]=10;
      |                     ^
gimple stmt in succ := 3 
# VUSE <.MEM_45>
return 0;
lto1: warning: use location
branch in succ := 7 have 
# .MEM_44 = VDEF <.MEM_43>
free (p_13);
test.c:25:17: warning: use location
   25 |                 free(p);
      |                 ^
The path has a release memory in succ := 5 

======================================================================
[40;31m    branch possiable have return or exit  [0m
In fucntion name:main 
# .MEM_42 = VDEF <.MEM_41>
MEM[(int *)p_13 + 36B] = 10;
test.c:21:21: warning: use location
   21 |                 p[9]=10;
      |                     ^
gimple stmt in succ := 3 
// predicted unlikely by goto predictor.
test.c:24:25: warning: use location
   24 |                         goto EXIT;
      |                         ^
branch in succ := 4 have goto
# .MEM_44 = VDEF <.MEM_43>
free (p_13);
test.c:25:17: warning: use location
   25 |                 free(p);
      |                 ^
The path has a release memory in succ := 5 

======================================================================
[40;31m    branch possiable have return or exit  [0m
In fucntion name:main 
# .MEM_42 = VDEF <.MEM_41>
MEM[(int *)p_13 + 36B] = 10;
test.c:21:21: warning: use location
   21 |                 p[9]=10;
      |                     ^
gimple stmt in succ := 3 
// predicted unlikely by goto predictor.
test.c:24:25: warning: use location
   24 |                         goto EXIT;
      |                         ^
branch in succ := 4 have goto
# .MEM_45 = VDEF <.MEM_28>
free (p_3);
test.c:29:1: warning: use location
   29 | free(p);
      | ^
The path has a release memory in succ := 7 

======================================================================
[40;31m    branch possiable have return or exit  [0m
In fucntion name:main 
# .MEM_42 = VDEF <.MEM_41>
MEM[(int *)p_13 + 36B] = 10;
test.c:21:21: warning: use location
   21 |                 p[9]=10;
      |                     ^
gimple stmt in succ := 3 
# VUSE <.MEM_45>
return 0;
lto1: warning: use location
branch in succ := 7 have 
# .MEM_44 = VDEF <.MEM_43>
free (p_13);
test.c:25:17: warning: use location
   25 |                 free(p);
      |                 ^
The path has a release memory in succ := 5 

======================================================================
[40;31m    branch possiable have return or exit  [0m
In fucntion name:main 
# .MEM_41 = VDEF <.MEM_40>
MEM[(int *)p_13 + 32B] = 9;
test.c:20:21: warning: use location
   20 |                 p[8]=9;
      |                     ^
gimple stmt in succ := 3 
// predicted unlikely by goto predictor.
test.c:24:25: warning: use location
   24 |                         goto EXIT;
      |                         ^
branch in succ := 4 have goto
# .MEM_44 = VDEF <.MEM_43>
free (p_13);
test.c:25:17: warning: use location
   25 |                 free(p);
      |                 ^
The path has a release memory in succ := 5 

======================================================================
[40;31m    branch possiable have return or exit  [0m
In fucntion name:main 
# .MEM_41 = VDEF <.MEM_40>
MEM[(int *)p_13 + 32B] = 9;
test.c:20:21: warning: use location
   20 |                 p[8]=9;
      |                     ^
gimple stmt in succ := 3 
// predicted unlikely by goto predictor.
test.c:24:25: warning: use location
   24 |                         goto EXIT;
      |                         ^
branch in succ := 4 have goto
# .MEM_45 = VDEF <.MEM_28>
free (p_3);
test.c:29:1: warning: use location
   29 | free(p);
      | ^
The path has a release memory in succ := 7 

======================================================================
[40;31m    branch possiable have return or exit  [0m
In fucntion name:main 
# .MEM_41 = VDEF <.MEM_40>
MEM[(int *)p_13 + 32B] = 9;
test.c:20:21: warning: use location
   20 |                 p[8]=9;
      |                     ^
gimple stmt in succ := 3 
# VUSE <.MEM_45>
return 0;
lto1: warning: use location
branch in succ := 7 have 
# .MEM_44 = VDEF <.MEM_43>
free (p_13);
test.c:25:17: warning: use location
   25 |                 free(p);
      |                 ^
The path has a release memory in succ := 5 

======================================================================
[40;31m    branch possiable have return or exit  [0m
In fucntion name:main 
# .MEM_40 = VDEF <.MEM_39>
MEM[(int *)p_13 + 28B] = 8;
test.c:19:21: warning: use location
   19 |                 p[7]=8;
      |                     ^
gimple stmt in succ := 3 
// predicted unlikely by goto predictor.
test.c:24:25: warning: use location
   24 |                         goto EXIT;
      |                         ^
branch in succ := 4 have goto
# .MEM_44 = VDEF <.MEM_43>
free (p_13);
test.c:25:17: warning: use location
   25 |                 free(p);
      |                 ^
The path has a release memory in succ := 5 

======================================================================
[40;31m    branch possiable have return or exit  [0m
In fucntion name:main 
# .MEM_40 = VDEF <.MEM_39>
MEM[(int *)p_13 + 28B] = 8;
test.c:19:21: warning: use location
   19 |                 p[7]=8;
      |                     ^
gimple stmt in succ := 3 
// predicted unlikely by goto predictor.
test.c:24:25: warning: use location
   24 |                         goto EXIT;
      |                         ^
branch in succ := 4 have goto
# .MEM_45 = VDEF <.MEM_28>
free (p_3);
test.c:29:1: warning: use location
   29 | free(p);
      | ^
The path has a release memory in succ := 7 

======================================================================
[40;31m    branch possiable have return or exit  [0m
In fucntion name:main 
# .MEM_40 = VDEF <.MEM_39>
MEM[(int *)p_13 + 28B] = 8;
test.c:19:21: warning: use location
   19 |                 p[7]=8;
      |                     ^
gimple stmt in succ := 3 
# VUSE <.MEM_45>
return 0;
lto1: warning: use location
branch in succ := 7 have 
# .MEM_44 = VDEF <.MEM_43>
free (p_13);
test.c:25:17: warning: use location
   25 |                 free(p);
      |                 ^
The path has a release memory in succ := 5 

======================================================================
[40;31m    branch possiable have return or exit  [0m
In fucntion name:main 
# .MEM_39 = VDEF <.MEM_38>
MEM[(int *)p_13 + 24B] = 7;
test.c:18:21: warning: use location
   18 |                 p[6]=7;
      |                     ^
gimple stmt in succ := 3 
// predicted unlikely by goto predictor.
test.c:24:25: warning: use location
   24 |                         goto EXIT;
      |                         ^
branch in succ := 4 have goto
# .MEM_44 = VDEF <.MEM_43>
free (p_13);
test.c:25:17: warning: use location
   25 |                 free(p);
      |                 ^
The path has a release memory in succ := 5 

======================================================================
[40;31m    branch possiable have return or exit  [0m
In fucntion name:main 
# .MEM_39 = VDEF <.MEM_38>
MEM[(int *)p_13 + 24B] = 7;
test.c:18:21: warning: use location
   18 |                 p[6]=7;
      |                     ^
gimple stmt in succ := 3 
// predicted unlikely by goto predictor.
test.c:24:25: warning: use location
   24 |                         goto EXIT;
      |                         ^
branch in succ := 4 have goto
# .MEM_45 = VDEF <.MEM_28>
free (p_3);
test.c:29:1: warning: use location
   29 | free(p);
      | ^
The path has a release memory in succ := 7 

======================================================================
[40;31m    branch possiable have return or exit  [0m
In fucntion name:main 
# .MEM_39 = VDEF <.MEM_38>
MEM[(int *)p_13 + 24B] = 7;
test.c:18:21: warning: use location
   18 |                 p[6]=7;
      |                     ^
gimple stmt in succ := 3 
# VUSE <.MEM_45>
return 0;
lto1: warning: use location
branch in succ := 7 have 
# .MEM_44 = VDEF <.MEM_43>
free (p_13);
test.c:25:17: warning: use location
   25 |                 free(p);
      |                 ^
The path has a release memory in succ := 5 

======================================================================
[40;31m    branch possiable have return or exit  [0m
In fucntion name:main 
# .MEM_38 = VDEF <.MEM_37>
MEM[(int *)p_13 + 20B] = 6;
test.c:17:21: warning: use location
   17 |                 p[5]=6;
      |                     ^
gimple stmt in succ := 3 
// predicted unlikely by goto predictor.
test.c:24:25: warning: use location
   24 |                         goto EXIT;
      |                         ^
branch in succ := 4 have goto
# .MEM_44 = VDEF <.MEM_43>
free (p_13);
test.c:25:17: warning: use location
   25 |                 free(p);
      |                 ^
The path has a release memory in succ := 5 

======================================================================
[40;31m    branch possiable have return or exit  [0m
In fucntion name:main 
# .MEM_38 = VDEF <.MEM_37>
MEM[(int *)p_13 + 20B] = 6;
test.c:17:21: warning: use location
   17 |                 p[5]=6;
      |                     ^
gimple stmt in succ := 3 
// predicted unlikely by goto predictor.
test.c:24:25: warning: use location
   24 |                         goto EXIT;
      |                         ^
branch in succ := 4 have goto
# .MEM_45 = VDEF <.MEM_28>
free (p_3);
test.c:29:1: warning: use location
   29 | free(p);
      | ^
The path has a release memory in succ := 7 

======================================================================
[40;31m    branch possiable have return or exit  [0m
In fucntion name:main 
# .MEM_38 = VDEF <.MEM_37>
MEM[(int *)p_13 + 20B] = 6;
test.c:17:21: warning: use location
   17 |                 p[5]=6;
      |                     ^
gimple stmt in succ := 3 
# VUSE <.MEM_45>
return 0;
lto1: warning: use location
branch in succ := 7 have 
# .MEM_44 = VDEF <.MEM_43>
free (p_13);
test.c:25:17: warning: use location
   25 |                 free(p);
      |                 ^
The path has a release memory in succ := 5 

======================================================================
[40;31m    branch possiable have return or exit  [0m
In fucntion name:main 
# .MEM_37 = VDEF <.MEM_36>
MEM[(int *)p_13 + 16B] = 5;
test.c:16:21: warning: use location
   16 |                 p[4]=5;
      |                     ^
gimple stmt in succ := 3 
// predicted unlikely by goto predictor.
test.c:24:25: warning: use location
   24 |                         goto EXIT;
      |                         ^
branch in succ := 4 have goto
# .MEM_44 = VDEF <.MEM_43>
free (p_13);
test.c:25:17: warning: use location
   25 |                 free(p);
      |                 ^
The path has a release memory in succ := 5 

======================================================================
[40;31m    branch possiable have return or exit  [0m
In fucntion name:main 
# .MEM_37 = VDEF <.MEM_36>
MEM[(int *)p_13 + 16B] = 5;
test.c:16:21: warning: use location
   16 |                 p[4]=5;
      |                     ^
gimple stmt in succ := 3 
// predicted unlikely by goto predictor.
test.c:24:25: warning: use location
   24 |                         goto EXIT;
      |                         ^
branch in succ := 4 have goto
# .MEM_45 = VDEF <.MEM_28>
free (p_3);
test.c:29:1: warning: use location
   29 | free(p);
      | ^
The path has a release memory in succ := 7 

======================================================================
[40;31m    branch possiable have return or exit  [0m
In fucntion name:main 
# .MEM_37 = VDEF <.MEM_36>
MEM[(int *)p_13 + 16B] = 5;
test.c:16:21: warning: use location
   16 |                 p[4]=5;
      |                     ^
gimple stmt in succ := 3 
# VUSE <.MEM_45>
return 0;
lto1: warning: use location
branch in succ := 7 have 
# .MEM_44 = VDEF <.MEM_43>
free (p_13);
test.c:25:17: warning: use location
   25 |                 free(p);
      |                 ^
The path has a release memory in succ := 5 

======================================================================
[40;31m    branch possiable have return or exit  [0m
In fucntion name:main 
# .MEM_36 = VDEF <.MEM_35>
MEM[(int *)p_13 + 12B] = 4;
test.c:15:21: warning: use location
   15 |                 p[3]=4;
      |                     ^
gimple stmt in succ := 3 
// predicted unlikely by goto predictor.
test.c:24:25: warning: use location
   24 |                         goto EXIT;
      |                         ^
branch in succ := 4 have goto
# .MEM_44 = VDEF <.MEM_43>
free (p_13);
test.c:25:17: warning: use location
   25 |                 free(p);
      |                 ^
The path has a release memory in succ := 5 

======================================================================
[40;31m    branch possiable have return or exit  [0m
In fucntion name:main 
# .MEM_36 = VDEF <.MEM_35>
MEM[(int *)p_13 + 12B] = 4;
test.c:15:21: warning: use location
   15 |                 p[3]=4;
      |                     ^
gimple stmt in succ := 3 
// predicted unlikely by goto predictor.
test.c:24:25: warning: use location
   24 |                         goto EXIT;
      |                         ^
branch in succ := 4 have goto
# .MEM_45 = VDEF <.MEM_28>
free (p_3);
test.c:29:1: warning: use location
   29 | free(p);
      | ^
The path has a release memory in succ := 7 

======================================================================
[40;31m    branch possiable have return or exit  [0m
In fucntion name:main 
# .MEM_36 = VDEF <.MEM_35>
MEM[(int *)p_13 + 12B] = 4;
test.c:15:21: warning: use location
   15 |                 p[3]=4;
      |                     ^
gimple stmt in succ := 3 
# VUSE <.MEM_45>
return 0;
lto1: warning: use location
branch in succ := 7 have 
# .MEM_44 = VDEF <.MEM_43>
free (p_13);
test.c:25:17: warning: use location
   25 |                 free(p);
      |                 ^
The path has a release memory in succ := 5 

======================================================================
[40;31m    branch possiable have return or exit  [0m
In fucntion name:main 
# .MEM_35 = VDEF <.MEM_34>
MEM[(int *)p_13 + 8B] = 3;
test.c:14:21: warning: use location
   14 |                 p[2]=3;
      |                     ^
gimple stmt in succ := 3 
// predicted unlikely by goto predictor.
test.c:24:25: warning: use location
   24 |                         goto EXIT;
      |                         ^
branch in succ := 4 have goto
# .MEM_44 = VDEF <.MEM_43>
free (p_13);
test.c:25:17: warning: use location
   25 |                 free(p);
      |                 ^
The path has a release memory in succ := 5 

======================================================================
[40;31m    branch possiable have return or exit  [0m
In fucntion name:main 
# .MEM_35 = VDEF <.MEM_34>
MEM[(int *)p_13 + 8B] = 3;
test.c:14:21: warning: use location
   14 |                 p[2]=3;
      |                     ^
gimple stmt in succ := 3 
// predicted unlikely by goto predictor.
test.c:24:25: warning: use location
   24 |                         goto EXIT;
      |                         ^
branch in succ := 4 have goto
# .MEM_45 = VDEF <.MEM_28>
free (p_3);
test.c:29:1: warning: use location
   29 | free(p);
      | ^
The path has a release memory in succ := 7 

======================================================================
[40;31m    branch possiable have return or exit  [0m
In fucntion name:main 
# .MEM_35 = VDEF <.MEM_34>
MEM[(int *)p_13 + 8B] = 3;
test.c:14:21: warning: use location
   14 |                 p[2]=3;
      |                     ^
gimple stmt in succ := 3 
# VUSE <.MEM_45>
return 0;
lto1: warning: use location
branch in succ := 7 have 
# .MEM_44 = VDEF <.MEM_43>
free (p_13);
test.c:25:17: warning: use location
   25 |                 free(p);
      |                 ^
The path has a release memory in succ := 5 

======================================================================
[40;31m    branch possiable have return or exit  [0m
In fucntion name:main 
# .MEM_34 = VDEF <.MEM_33>
MEM[(int *)p_13 + 4B] = 2;
test.c:13:21: warning: use location
   13 |                 p[1]=2;
      |                     ^
gimple stmt in succ := 3 
// predicted unlikely by goto predictor.
test.c:24:25: warning: use location
   24 |                         goto EXIT;
      |                         ^
branch in succ := 4 have goto
# .MEM_44 = VDEF <.MEM_43>
free (p_13);
test.c:25:17: warning: use location
   25 |                 free(p);
      |                 ^
The path has a release memory in succ := 5 

======================================================================
[40;31m    branch possiable have return or exit  [0m
In fucntion name:main 
# .MEM_34 = VDEF <.MEM_33>
MEM[(int *)p_13 + 4B] = 2;
test.c:13:21: warning: use location
   13 |                 p[1]=2;
      |                     ^
gimple stmt in succ := 3 
// predicted unlikely by goto predictor.
test.c:24:25: warning: use location
   24 |                         goto EXIT;
      |                         ^
branch in succ := 4 have goto
# .MEM_45 = VDEF <.MEM_28>
free (p_3);
test.c:29:1: warning: use location
   29 | free(p);
      | ^
The path has a release memory in succ := 7 

======================================================================
[40;31m    branch possiable have return or exit  [0m
In fucntion name:main 
# .MEM_34 = VDEF <.MEM_33>
MEM[(int *)p_13 + 4B] = 2;
test.c:13:21: warning: use location
   13 |                 p[1]=2;
      |                     ^
gimple stmt in succ := 3 
# VUSE <.MEM_45>
return 0;
lto1: warning: use location
branch in succ := 7 have 
# .MEM_44 = VDEF <.MEM_43>
free (p_13);
test.c:25:17: warning: use location
   25 |                 free(p);
      |                 ^
The path has a release memory in succ := 5 

======================================================================
[40;31m    branch possiable have return or exit  [0m
In fucntion name:main 
# .MEM_33 = VDEF <.MEM_32>
*p_13 = 1;
test.c:12:21: warning: use location
   12 |                 p[0]=1;
      |                     ^
gimple stmt in succ := 3 
// predicted unlikely by goto predictor.
test.c:24:25: warning: use location
   24 |                         goto EXIT;
      |                         ^
branch in succ := 4 have goto
# .MEM_44 = VDEF <.MEM_43>
free (p_13);
test.c:25:17: warning: use location
   25 |                 free(p);
      |                 ^
The path has a release memory in succ := 5 

======================================================================
[40;31m    branch possiable have return or exit  [0m
In fucntion name:main 
# .MEM_33 = VDEF <.MEM_32>
*p_13 = 1;
test.c:12:21: warning: use location
   12 |                 p[0]=1;
      |                     ^
gimple stmt in succ := 3 
// predicted unlikely by goto predictor.
test.c:24:25: warning: use location
   24 |                         goto EXIT;
      |                         ^
branch in succ := 4 have goto
# .MEM_45 = VDEF <.MEM_28>
free (p_3);
test.c:29:1: warning: use location
   29 | free(p);
      | ^
The path has a release memory in succ := 7 

======================================================================
[40;31m    branch possiable have return or exit  [0m
In fucntion name:main 
# .MEM_33 = VDEF <.MEM_32>
*p_13 = 1;
test.c:12:21: warning: use location
   12 |                 p[0]=1;
      |                     ^
gimple stmt in succ := 3 
# VUSE <.MEM_45>
return 0;
lto1: warning: use location
branch in succ := 7 have 
# .MEM_44 = VDEF <.MEM_43>
free (p_13);
test.c:25:17: warning: use location
   25 |                 free(p);
      |                 ^
The path has a release memory in succ := 5 

======================================================================
[40;31m    branch possiable have return or exit  [0m
In fucntion name:main 
# .MEM_32 = VDEF <.MEM_31>
p_13 = foo ();
test.c:11:19: warning: use location
   11 |                 p=foo();
      |                   ^
gimple stmt in succ := 3 
// predicted unlikely by goto predictor.
test.c:24:25: warning: use location
   24 |                         goto EXIT;
      |                         ^
branch in succ := 4 have goto
# .MEM_44 = VDEF <.MEM_43>
free (p_13);
test.c:25:17: warning: use location
   25 |                 free(p);
      |                 ^
The path has a release memory in succ := 5 

======================================================================
[40;31m    branch possiable have return or exit  [0m
In fucntion name:main 
# .MEM_32 = VDEF <.MEM_31>
p_13 = foo ();
test.c:11:19: warning: use location
   11 |                 p=foo();
      |                   ^
gimple stmt in succ := 3 
// predicted unlikely by goto predictor.
test.c:24:25: warning: use location
   24 |                         goto EXIT;
      |                         ^
branch in succ := 4 have goto
# .MEM_45 = VDEF <.MEM_28>
free (p_3);
test.c:29:1: warning: use location
   29 | free(p);
      | ^
The path has a release memory in succ := 7 

======================================================================
[40;31m    branch possiable have return or exit  [0m
In fucntion name:main 
# .MEM_32 = VDEF <.MEM_31>
p_13 = foo ();
test.c:11:19: warning: use location
   11 |                 p=foo();
      |                   ^
gimple stmt in succ := 3 
# VUSE <.MEM_45>
return 0;
lto1: warning: use location
branch in succ := 7 have 
# .MEM_44 = VDEF <.MEM_43>
free (p_13);
test.c:25:17: warning: use location
   25 |                 free(p);
      |                 ^
The path has a release memory in succ := 5 

======================================================================

=====================prebranchexit:end================
 
 Finish check Pointer Collect  

======================================================================
[40;35m  	Looserules free count:2 [0m
[40;31m  	free count:2 [0m
[40;31m  	possible double free [Looserules]:2 [0m
[40;31m  	possible double free [rigorous]:2 [0m

======================================================================

======================================================================
[40;31m  	possible double free [rigorous]:2 [0m

======================================================================

======================================================================

=============================output_basic_block_stage==================================
alloc index 3
[7,1,1,1],
[6,1,0,0],
[5,1,1,0],
[3,1,0,0],
[4,0,0,1],
fucntion collect path finsh

=============== The third stage : detection  End=================

===============Print ALL GIMPLE IR=================
=======Mapping node_fun:foo=========
=======is loop:0=========

 bb index 2 
<bb 2> [local count: 1073741824]:
if (test_3(D) != 0)
  goto <bb 3>; [50.00%]
else
  goto <bb 4>; [50.00%]

In function â€˜fooâ€™:
test2.c:11:8: warning: use location
   11 |     if (test)
      |        ^
=======is loop:0=========

 bb index 3 
<bb 3> [local count: 536870913]:
b_8 = foo2 ();
goto <bb 5>; [100.00%]

test2.c:12:13: warning: use location
   12 |         b = foo2();
      |             ^
=======is loop:0=========

 bb index 4 
<bb 4> [local count: 536870913]:
b_6 = foo2 ();

test2.c:14:13: warning: use location
   14 |         b = foo2();
      |             ^
=======is loop:0=========

 bb index 5 
<bb 5> [local count: 1073741824]:
# b_1 = PHI <b_8(3), b_6(4)>
return b_1;

test2.c:15:12: warning: use location
   15 |     return b;
      |            ^
=======Mapping node_fun:foo2=========
=======is loop:0=========

 bb index 2 
<bb 2> [local count: 1073741824]:
d_3 = malloc (10);
return d_3;

In function â€˜foo2â€™:
test2.c:3:7: warning: use location
    3 |     d=malloc(10);
      |       ^
test2.c:4:12: warning: use location
    4 |     return d;
      |            ^
=======Mapping node_fun:main=========
=======is loop:0=========

 bb index 2 
<bb 2> [local count: 151290756]:
srand (10);
goto <bb 6>; [100.00%]

In function â€˜mainâ€™:
test.c:6:9: warning: use location
    6 |         srand( 10 );
      |         ^
=======is loop:1=========

 bb index 3 
<bb 3> [local count: 976138698]:
_1 = rand ();
test_11 = _1 % 11;
p_13 = foo ();
*p_13 = 1;
MEM[(int *)p_13 + 4B] = 2;
MEM[(int *)p_13 + 8B] = 3;
MEM[(int *)p_13 + 12B] = 4;
MEM[(int *)p_13 + 16B] = 5;
MEM[(int *)p_13 + 20B] = 6;
MEM[(int *)p_13 + 24B] = 7;
MEM[(int *)p_13 + 28B] = 8;
MEM[(int *)p_13 + 32B] = 9;
MEM[(int *)p_13 + 36B] = 10;
printf ("%d\n", p_13);
if (test_11 > 5)
  goto <bb 4>; [5.50%]
else
  goto <bb 5>; [94.50%]

test.c:10:23: warning: use location
   10 |                 test= rand()% (10 - 0 + 1) + 0;
      |                       ^
test.c:10:21: warning: use location
   10 |                 test= rand()% (10 - 0 + 1) + 0;
      |                     ^
test.c:11:19: warning: use location
   11 |                 p=foo();
      |                   ^
test.c:12:21: warning: use location
   12 |                 p[0]=1;
      |                     ^
test.c:13:21: warning: use location
   13 |                 p[1]=2;
      |                     ^
test.c:14:21: warning: use location
   14 |                 p[2]=3;
      |                     ^
test.c:15:21: warning: use location
   15 |                 p[3]=4;
      |                     ^
test.c:16:21: warning: use location
   16 |                 p[4]=5;
      |                     ^
test.c:17:21: warning: use location
   17 |                 p[5]=6;
      |                     ^
test.c:18:21: warning: use location
   18 |                 p[6]=7;
      |                     ^
test.c:19:21: warning: use location
   19 |                 p[7]=8;
      |                     ^
test.c:20:21: warning: use location
   20 |                 p[8]=9;
      |                     ^
test.c:21:21: warning: use location
   21 |                 p[9]=10;
      |                     ^
test.c:22:17: warning: use location
   22 |                 printf("%d\n", p);
      |                 ^
test.c:23:19: warning: use location
   23 |                 if(test >5)
      |                   ^
=======is loop:0=========

 bb index 4 
<bb 4> [local count: 53687628]:
// predicted unlikely by goto predictor.
goto <bb 7>; [100.00%]

test.c:24:25: warning: use location
   24 |                         goto EXIT;
      |                         ^
=======is loop:1=========

 bb index 5 
<bb 5> [local count: 922451069]:
free (p_13);
i_26 = i_4 + 1;

test.c:25:17: warning: use location
   25 |                 free(p);
      |                 ^
test.c:9:34: warning: use location
    9 |         for (int i = 0;i < 10 ; i++){
      |                                  ^
=======is loop:1=========

 bb index 6 
<bb 6> [local count: 1073741824]:
# p_2 = PHI <p_9(D)(2), p_13(5)>
# i_4 = PHI <0(2), i_26(5)>
if (i_4 <= 9)
  goto <bb 3>; [90.91%]
else
  goto <bb 7>; [9.09%]

test.c:9:26: warning: use location
    9 |         for (int i = 0;i < 10 ; i++){
      |                          ^
=======is loop:0=========

 bb index 7 
<bb 7> [local count: 151290756]:
# p_3 = PHI <p_13(4), p_2(6)>
EXIT:
free (p_3);
return 0;

test.c:28:1: warning: use location
   28 | EXIT:
      | ^
test.c:29:1: warning: use location
   29 | free(p);
      | ^
lto1: warning: use location

===============Print ALL GIMPLE IR=================
[40;32mSTART CHECKSTART CHECKSTART CHECKSTART CHECKSTART CHECK[0m
[40;32mSTART CHECKSTART CHECKSTART CHECKSTART CHECKSTART CHECK[0m
    =()=
 ,/'_||_
  (___  `.
 ./  `=='
                   
    ~~~~~~~~~~~  
 ~~~~~~
           ~~~~~~~
[40;34m    gimple malloc count : 1 [0m
[40;34m    gimple free   count : 2 [0m
[40;34m    all ptable point : 7 [0m
[40;34m    analyzable ptable point : 5 [0m
[40;34m    analyzable ptable point (function return heap-object): 4 [0m
[40;34m    relate stmt of analyzable ptable : 15 [0m
[40;34m    used_stmt array stack totalsize of : 0.000304 mb[0m
[40;34m    collect time: : 0.000274 s [0m
[40;34m    mapping time: : 0.000535 s [0m
[40;34m    algorithm time: 0.006653 s [0m
[40;34m    gimple stmt count : : 29 [0m
[40;34m    this report analysis in Tue Aug  9 20:02:51 2022
 [0m
[40;32mSTART CHECKSTART CHECKSTART CHECKSTART CHECKSTART CHECK[0m
[40;32mSTART CHECKSTART CHECKSTART CHECKSTART CHECKSTART CHECK[0m

Time variable                                   usr           sys          wall           GGC
 phase setup                        :   0.00 (  0%)   0.00 (  0%)   0.01 ( 33%)  2157k ( 89%)
 phase opt and generate             :   0.02 (100%)   0.01 (100%)   0.02 ( 67%)   231k ( 10%)
 callgraph functions expansion      :   0.01 ( 50%)   0.01 (100%)   0.01 ( 33%)   183k (  8%)
 ipa points-to                      :   0.01 ( 50%)   0.00 (  0%)   0.00 (  0%)  1576  (  0%)
 tree SSA uncprop                   :   0.00 (  0%)   0.00 (  0%)   0.01 ( 33%)     0  (  0%)
 combiner                           :   0.01 ( 50%)   0.00 (  0%)   0.00 (  0%)    11k (  0%)
 LRA non-specific                   :   0.00 (  0%)   0.01 (100%)   0.00 (  0%)   392  (  0%)
 plugin execution                   :   0.00 (  0%)   0.00 (  0%)   0.01 ( 33%)   472  (  0%)
 TOTAL                              :   0.02          0.01          0.03         2416k
