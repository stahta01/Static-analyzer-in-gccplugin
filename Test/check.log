test.c: In function â€˜fooâ€™:
test.c:14:5: warning: assignment makes integer from pointer without a cast [-Wint-conversion]
  *z = malloc(10);
     ^
=======ipa_pta=========
--------GIMPLE_SWITCH -------
--------GIMPLE_SWITCHss -------
node:= 23 
 succs:= 7
 succs:= 5
 succs:= 6
max_path := 0
max_path := 0
max_path := 0
max_path := 0
max_path := 0
max_path := 0
max_path := 0
max_path := 0
start PointerConstraint
pointer ftable is 0 
pointer ptable is 1 
# .MEM_8 = VDEF <.MEM_7(D)>
_1 = malloc (10);
# .MEM_37 = VDEF <.MEM_30>
foo (p5_9(D));
# .MEM_38 = VDEF <.MEM_35>
foo (p5_9(D));
# .MEM_40 = VDEF <.MEM_38>
foo (p5_9(D));
# .MEM_39 = VDEF <.MEM_38>
foo (p5_9(D));
# .MEM_41 = VDEF <.MEM_38>
foo (p5_9(D));
# .MEM_47 = VDEF <.MEM_32>
foo (p_20(D));
# .MEM_49 = VDEF <.MEM_47>
foo (p_20(D));
# .MEM_48 = VDEF <.MEM_47>
foo (p_20(D));
# .MEM_44 = VDEF <.MEM_32>
foo (p_20(D));
# .MEM_46 = VDEF <.MEM_44>
foo (p3_24(D));
# .MEM_45 = VDEF <.MEM_44>
foo (p5_9(D));
# .MEM_50 = VDEF <.MEM_33>
foo (p_20(D));
# .MEM_43 = VDEF <.MEM_32>
foo (p_20(D));
# .MEM_42 = VDEF <.MEM_32>
foo (p4_18(D));
start collect similar stmtstart collect similar stmtstart collect similar stmtstart collect similar stmt
start collect similar stmtstart collect similar stmtstart collect similar stmtstart collect similar stmt
start collect similar stmtstart collect similar stmtstart collect similar stmtstart collect similar stmt
start collect similar stmtstart collect similar stmtstart collect similar stmtstart collect similar stmt
start collect similar stmtstart collect similar stmtstart collect similar stmtstart collect similar stmt
[40;41mSTART CHECKSTART CHECKSTART CHECKSTART CHECKSTART CHECK[0m
[40;41mSTART CHECKSTART CHECKSTART CHECKSTART CHECKSTART CHECK[0m
    =()=
 ,/'_||_
  (___  `.
 ./  `=='
      |||
      |||
      |||
      |||
[40;41mSTART CHECKSTART CHECKSTART CHECKSTART CHECKSTART CHECK[0m
[40;41mSTART CHECKSTART CHECKSTART CHECKSTART CHECKSTART CHECK[0m
=======================================================
[40;44m =======node_fun:foo========= [0m
[40;44m fucntion collect path  [0m
[40;44m =======print_function_path foo  function_call count: 1 level :0========  [0m
[40;42m =======pre add _ fucntion:malloc========= [0m
[40;33m =======POP node_fun stack:malloc========= [0m
[40;42m =======pre_check_funciton:foo========= [0m
[40;42m =======start_check_funciton:foo========= [0m

dot graph START

======================================================================
 <ssa_name 0x7f67de6ee708
    type <pointer_type 0x7f67de7010a8
        type <void_type 0x7f67de6faf18 void VOID
            align 8 symtab 0 alias set -1 structural equality
            pointer_to_this <pointer_type 0x7f67de7010a8>>
        public unsigned DI
        size <integer_cst 0x7f67de6e6be8 constant 64>
        unit size <integer_cst 0x7f67de6e6c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality
        pointer_to_this <pointer_type 0x7f67de706bd0>>
   
    def_stmt _1 = malloc (10);
    version 1
    ptr-info 0x7f67de219b10>

 ================== trace ptable================== 
trace fucntion name:malloc 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr---malloc-----
this Reserved word function ------malloc-----
 
 Start check Pointer Collect  

======================================================================
_2 = (long int) _1;
In function â€˜fooâ€™:
test.c:14:5: warning: use location
  *z = malloc(10);
     ^
_3 = (int) _2;
test.c:14:5: warning: use location
*z_6(D) = _3;
test.c:14:5: warning: use location

 ================== Start Use after free Check ================== 

dot graph END

 ================== Start Use after free Check ================== 

======================================================================
[40;31m    no free stmt possible memory leak [0m

======================================================================

dot graph START

======================================================================
 <integer_cst 0x7f67de219ab0 type <integer_type 0x7f67de216930 size_t> constant 10>
[40;33m =======POP node_fun stack:foo========= [0m
[40;44m =======node_fun:main========= [0m
[40;44m fucntion collect path  [0m
[40;44m =======print_function_path main  function_call count: 1 level :0========  [0m
[40;44m =======print_function_type 0  ========  [0m
[40;42m =======pre add _ fucntion:foo========= [0m
[40;44m =======print_function_path foo  function_call count: 1 level :1========  [0m
[40;42m =======pre add _ fucntion:malloc========= [0m
[40;33m =======POP node_fun stack:malloc========= [0m
[40;42m =======pre_check_funciton:foo========= [0m
[40;42m =======start_check_funciton:foo========= [0m

dot graph START

======================================================================
 <ssa_name 0x7f67de6ee708
    type <pointer_type 0x7f67de7010a8
        type <void_type 0x7f67de6faf18 void VOID
            align 8 symtab 0 alias set -1 structural equality
            pointer_to_this <pointer_type 0x7f67de7010a8>>
        public unsigned DI
        size <integer_cst 0x7f67de6e6be8 constant 64>
        unit size <integer_cst 0x7f67de6e6c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality
        pointer_to_this <pointer_type 0x7f67de706bd0>>
   
    def_stmt _1 = malloc (10);
    version 1
    ptr-info 0x7f67de219b10>

 ================== trace ptable================== 
trace fucntion name:malloc 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr---malloc-----
this Reserved word function ------malloc-----
 
 Start check Pointer Collect  

======================================================================
_2 = (long int) _1;
In function â€˜mainâ€™:
test.c:14:5: warning: use location
_3 = (int) _2;
test.c:14:5: warning: use location
*z_6(D) = _3;
test.c:14:5: warning: use location

 ================== Start Use after free Check ================== 

dot graph END

 ================== Start Use after free Check ================== 

======================================================================
[40;31m    no free stmt possible memory leak [0m

======================================================================

dot graph START

======================================================================
 <integer_cst 0x7f67de219ab0 type <integer_type 0x7f67de216930 size_t> constant 10>
[40;33m =======POP node_fun stack:foo========= [0m
[40;42m =======pre_check_funciton:main========= [0m
[40;42m =======start_check_funciton:main========= [0m

dot graph START

======================================================================
 <ssa_name 0x7f67de6ee9d8
    type <pointer_type 0x7f67de701a80
        type <integer_type 0x7f67de6fa5e8 int public SI
            size <integer_cst 0x7f67de6e6e28 constant 32>
            unit size <integer_cst 0x7f67de6e6e40 constant 4>
            align 32 symtab 0 alias set -1 canonical type 0x7f67de6fa5e8 precision 32 min <integer_cst 0x7f67de6e6de0 -2147483648> max <integer_cst 0x7f67de6e6df8 2147483647>
            pointer_to_this <pointer_type 0x7f67de701a80>>
        public unsigned DI
        size <integer_cst 0x7f67de6e6be8 constant 64>
        unit size <integer_cst 0x7f67de6e6c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality>
    var <var_decl 0x7f67df47be10 p5>
    def_stmt GIMPLE_NOP
    version 9
    ptr-info 0x7f67de219b40>

 ================== trace ptable================== 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr--------
this other function -----------
 
 Start check Pointer Collect  

======================================================================
=======================Path Constaint===========================

=succs:= 13
if (test_16(D) < test2_17(D))
test.c:69:7: warning: use location
    if (test < test2)
       ^
	relate logic:= 0
=succs:= 9
if (test_16(D) > test2_17(D))
test.c:56:6: warning: use location
   if (test > test2)
      ^
	relate logic:= 0
=succs:= 8
if (test_16(D) != 0)
test.c:50:5: warning: use location
  if (test)
     ^
	relate logic:= 1
=======================Path Constaint===========================


 Expand conflict 
 The same function may have multiple branches :foo
# .MEM_37 = VDEF <.MEM_30>
foo (p5_9(D));
test.c:35:3: warning: use location
   foo(p5);
   ^
# .MEM_45 = VDEF <.MEM_44>
foo (p5_9(D));
test.c:74:5: warning: use location
     foo(p5);
     ^
=======================Path Constaint===========================

=succs:= 13
if (test_16(D) < test2_17(D))
test.c:69:7: warning: use location
    if (test < test2)
       ^
	relate logic:= 0
=succs:= 9
if (test_16(D) > test2_17(D))
test.c:56:6: warning: use location
   if (test > test2)
      ^
	relate logic:= 0
=succs:= 8
if (test_16(D) != 0)
test.c:50:5: warning: use location
  if (test)
     ^
	relate logic:= 1
=======================Path Constaint===========================

switch (_1) <default: <L4> [33.33%], case 5: <L2> [33.33%], case 10: <L3> [33.33%]>
test.c:38:2: warning: use location
  switch (test5 / 10)
  ^
in switch succs:= 7
default:

 Expand conflict 
 The same function may have multiple branches :foo
# .MEM_37 = VDEF <.MEM_30>
foo (p5_9(D));
test.c:35:3: warning: use location
   foo(p5);
   ^
# .MEM_41 = VDEF <.MEM_38>
foo (p5_9(D));
test.c:47:3: warning: use location
   foo(p5);
   ^
switch (_1) <default: <L4> [33.33%], case 5: <L2> [33.33%], case 10: <L3> [33.33%]>
test.c:38:2: warning: use location
  switch (test5 / 10)
  ^
in switch succs:= 7
default:
switch (_1) <default: <L4> [33.33%], case 5: <L2> [33.33%], case 10: <L3> [33.33%]>
test.c:38:2: warning: use location
in switch succs:= 6
case 10:

 Expand conflict 
 The same function may have multiple branches :foo
# .MEM_37 = VDEF <.MEM_30>
foo (p5_9(D));
test.c:35:3: warning: use location
   foo(p5);
   ^
# .MEM_39 = VDEF <.MEM_38>
foo (p5_9(D));
test.c:44:3: warning: use location
   foo(p5);
   ^
switch (_1) <default: <L4> [33.33%], case 5: <L2> [33.33%], case 10: <L3> [33.33%]>
test.c:38:2: warning: use location
  switch (test5 / 10)
  ^
in switch succs:= 6
case 10:
switch (_1) <default: <L4> [33.33%], case 5: <L2> [33.33%], case 10: <L3> [33.33%]>
test.c:38:2: warning: use location
in switch succs:= 5
case 5:

 Expand conflict 
 The same function may have multiple branches :foo
# .MEM_37 = VDEF <.MEM_30>
foo (p5_9(D));
test.c:35:3: warning: use location
   foo(p5);
   ^
# .MEM_40 = VDEF <.MEM_38>
foo (p5_9(D));
test.c:41:3: warning: use location
   foo(p5);
   ^
switch (_1) <default: <L4> [33.33%], case 5: <L2> [33.33%], case 10: <L3> [33.33%]>
test.c:38:2: warning: use location
  switch (test5 / 10)
  ^
in switch succs:= 5
case 5:

 Expand conflict 
 The same function may have multiple branches :foo
# .MEM_37 = VDEF <.MEM_30>
foo (p5_9(D));
test.c:35:3: warning: use location
   foo(p5);
   ^
# .MEM_38 = VDEF <.MEM_35>
foo (p5_9(D));
test.c:37:3: warning: use location
   foo(p5);
   ^
# .MEM_37 = VDEF <.MEM_30>
foo (p5_9(D));
foo (p5_9(D));
test.c:35:3: warning: use location
   foo(p5);
   ^
this stmt is child function---foo-----

 ================== trace ================== 
 <ssa_name 0x7f67de6ee9d8
    type <pointer_type 0x7f67de701a80
        type <integer_type 0x7f67de6fa5e8 int public SI
            size <integer_cst 0x7f67de6e6e28 constant 32>
            unit size <integer_cst 0x7f67de6e6e40 constant 4>
            align 32 symtab 0 alias set -1 canonical type 0x7f67de6fa5e8 precision 32 min <integer_cst 0x7f67de6e6de0 -2147483648> max <integer_cst 0x7f67de6e6df8 2147483647>
            pointer_to_this <pointer_type 0x7f67de701a80>>
        public unsigned DI
        size <integer_cst 0x7f67de6e6be8 constant 64>
        unit size <integer_cst 0x7f67de6e6c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality>
    var <var_decl 0x7f67df47be10 p5>
    def_stmt GIMPLE_NOP
    version 9
    ptr-info 0x7f67de219b40>
trace fucntion name:foo 
[40;44m =======trace_function_path foo  function_call count: 1 level :0========  [0m
[40;36m ======= node_fun:foo========= [0m
[40;36m ======= find relate stmt with p5 ========= [0m
[40;36m ======= relate stmt argument:p5 ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:malloc========= [0m
[40;46m =======add node_fun stack:malloc========= [0m

 ================== trace ================== 
trace fucntion free:0 

 ================== Start Use after free Check ================== 

dot graph END

 ================== Start Use after free Check ================== 

======================================================================
[40;31m    no free stmt possible memory leak [0m

======================================================================

dot graph START

======================================================================
 <ssa_name 0x7f67de6ee9d8
    type <pointer_type 0x7f67de701a80
        type <integer_type 0x7f67de6fa5e8 int public SI
            size <integer_cst 0x7f67de6e6e28 constant 32>
            unit size <integer_cst 0x7f67de6e6e40 constant 4>
            align 32 symtab 0 alias set -1 canonical type 0x7f67de6fa5e8 precision 32 min <integer_cst 0x7f67de6e6de0 -2147483648> max <integer_cst 0x7f67de6e6df8 2147483647>
            pointer_to_this <pointer_type 0x7f67de701a80>>
        public unsigned DI
        size <integer_cst 0x7f67de6e6be8 constant 64>
        unit size <integer_cst 0x7f67de6e6c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality>
    var <var_decl 0x7f67df47be10 p5>
    def_stmt GIMPLE_NOP
    version 9
    ptr-info 0x7f67de219b40>

 ================== trace ptable================== 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr--------
this other function -----------
 
 Start check Pointer Collect  

======================================================================
=======================Path Constaint===========================

=succs:= 13
if (test_16(D) < test2_17(D))
test.c:69:7: warning: use location
    if (test < test2)
       ^
	relate logic:= 0
=succs:= 9
if (test_16(D) > test2_17(D))
test.c:56:6: warning: use location
   if (test > test2)
      ^
	relate logic:= 0
=succs:= 8
if (test_16(D) != 0)
test.c:50:5: warning: use location
  if (test)
     ^
	relate logic:= 1
=======================Path Constaint===========================


 Expand conflict 
 The same function may have multiple branches :foo
# .MEM_38 = VDEF <.MEM_35>
foo (p5_9(D));
test.c:37:3: warning: use location
   foo(p5);
   ^
# .MEM_45 = VDEF <.MEM_44>
foo (p5_9(D));
test.c:74:5: warning: use location
     foo(p5);
     ^
=======================Path Constaint===========================

=succs:= 13
if (test_16(D) < test2_17(D))
test.c:69:7: warning: use location
    if (test < test2)
       ^
	relate logic:= 0
=succs:= 9
if (test_16(D) > test2_17(D))
test.c:56:6: warning: use location
   if (test > test2)
      ^
	relate logic:= 0
=succs:= 8
if (test_16(D) != 0)
test.c:50:5: warning: use location
  if (test)
     ^
	relate logic:= 1
=======================Path Constaint===========================

switch (_1) <default: <L4> [33.33%], case 5: <L2> [33.33%], case 10: <L3> [33.33%]>
test.c:38:2: warning: use location
  switch (test5 / 10)
  ^
in switch succs:= 7
default:

 Expand conflict 
 The same function may have multiple branches :foo
# .MEM_38 = VDEF <.MEM_35>
foo (p5_9(D));
test.c:37:3: warning: use location
   foo(p5);
   ^
# .MEM_41 = VDEF <.MEM_38>
foo (p5_9(D));
test.c:47:3: warning: use location
   foo(p5);
   ^
switch (_1) <default: <L4> [33.33%], case 5: <L2> [33.33%], case 10: <L3> [33.33%]>
test.c:38:2: warning: use location
  switch (test5 / 10)
  ^
in switch succs:= 7
default:
switch (_1) <default: <L4> [33.33%], case 5: <L2> [33.33%], case 10: <L3> [33.33%]>
test.c:38:2: warning: use location
in switch succs:= 6
case 10:

 Expand conflict 
 The same function may have multiple branches :foo
# .MEM_38 = VDEF <.MEM_35>
foo (p5_9(D));
test.c:37:3: warning: use location
   foo(p5);
   ^
# .MEM_39 = VDEF <.MEM_38>
foo (p5_9(D));
test.c:44:3: warning: use location
   foo(p5);
   ^
switch (_1) <default: <L4> [33.33%], case 5: <L2> [33.33%], case 10: <L3> [33.33%]>
test.c:38:2: warning: use location
  switch (test5 / 10)
  ^
in switch succs:= 6
case 10:
switch (_1) <default: <L4> [33.33%], case 5: <L2> [33.33%], case 10: <L3> [33.33%]>
test.c:38:2: warning: use location
in switch succs:= 5
case 5:

 Expand conflict 
 The same function may have multiple branches :foo
# .MEM_38 = VDEF <.MEM_35>
foo (p5_9(D));
test.c:37:3: warning: use location
   foo(p5);
   ^
# .MEM_40 = VDEF <.MEM_38>
foo (p5_9(D));
test.c:41:3: warning: use location
   foo(p5);
   ^
switch (_1) <default: <L4> [33.33%], case 5: <L2> [33.33%], case 10: <L3> [33.33%]>
test.c:38:2: warning: use location
  switch (test5 / 10)
  ^
in switch succs:= 5
case 5:
# .MEM_38 = VDEF <.MEM_35>
foo (p5_9(D));
foo (p5_9(D));
test.c:37:3: warning: use location
   foo(p5);
   ^
this stmt is child function---foo-----

 ================== trace ================== 
 <ssa_name 0x7f67de6ee9d8
    type <pointer_type 0x7f67de701a80
        type <integer_type 0x7f67de6fa5e8 int public SI
            size <integer_cst 0x7f67de6e6e28 constant 32>
            unit size <integer_cst 0x7f67de6e6e40 constant 4>
            align 32 symtab 0 alias set -1 canonical type 0x7f67de6fa5e8 precision 32 min <integer_cst 0x7f67de6e6de0 -2147483648> max <integer_cst 0x7f67de6e6df8 2147483647>
            pointer_to_this <pointer_type 0x7f67de701a80>>
        public unsigned DI
        size <integer_cst 0x7f67de6e6be8 constant 64>
        unit size <integer_cst 0x7f67de6e6c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality>
    var <var_decl 0x7f67df47be10 p5>
    def_stmt GIMPLE_NOP
    version 9
    ptr-info 0x7f67de219b40>
trace fucntion name:foo 
[40;44m =======trace_function_path foo  function_call count: 1 level :0========  [0m
[40;36m ======= node_fun:foo========= [0m
[40;36m ======= find relate stmt with p5 ========= [0m
[40;36m ======= relate stmt argument:p5 ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:malloc========= [0m
[40;46m =======add node_fun stack:malloc========= [0m

 ================== trace ================== 
trace fucntion free:0 

 Expand conflict 
 The same function may have multiple branches :foo
# .MEM_38 = VDEF <.MEM_35>
foo (p5_9(D));
test.c:37:3: warning: use location
# .MEM_37 = VDEF <.MEM_30>
foo (p5_9(D));
test.c:35:3: warning: use location
   foo(p5);
   ^

 ================== Start Use after free Check ================== 

dot graph END

 ================== Start Use after free Check ================== 

======================================================================
[40;31m    no free stmt possible memory leak [0m

======================================================================

dot graph START

======================================================================
 <ssa_name 0x7f67de6eeb40
    type <pointer_type 0x7f67de701a80
        type <integer_type 0x7f67de6fa5e8 int public SI
            size <integer_cst 0x7f67de6e6e28 constant 32>
            unit size <integer_cst 0x7f67de6e6e40 constant 4>
            align 32 symtab 0 alias set -1 canonical type 0x7f67de6fa5e8 precision 32 min <integer_cst 0x7f67de6e6de0 -2147483648> max <integer_cst 0x7f67de6e6df8 2147483647>
            pointer_to_this <pointer_type 0x7f67de701a80>>
        public unsigned DI
        size <integer_cst 0x7f67de6e6be8 constant 64>
        unit size <integer_cst 0x7f67de6e6c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality>
    var <var_decl 0x7f67de228000 p>
    def_stmt GIMPLE_NOP
    version 20
    ptr-info 0x7f67de219b70>

 ================== trace ptable================== 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr--------
this other function -----------
 
 Start check Pointer Collect  

======================================================================
=======================Path Constaint===========================

succs:= 18
if (test_16(D) == test2_17(D))
test.c:83:10: warning: use location
  else if (test == test2)
          ^
	relate logic:= 1
succs:= 8
if (test_16(D) != 0)
test.c:50:5: warning: use location
  if (test)
     ^
	relate logic:= 0
=======================Path Constaint===========================


 Expand conflict 
 The same function may have multiple branches :foo
# .MEM_47 = VDEF <.MEM_32>
foo (p_20(D));
test.c:58:4: warning: use location
    foo(p);
    ^
# .MEM_43 = VDEF <.MEM_32>
foo (p_20(D));
test.c:84:3: warning: use location
   foo(p);
   ^
=======================Path Constaint===========================

succs:= 18
if (test_16(D) == test2_17(D))
test.c:83:10: warning: use location
  else if (test == test2)
          ^
	relate logic:= 1
succs:= 8
if (test_16(D) != 0)
test.c:50:5: warning: use location
  if (test)
     ^
	relate logic:= 0
=======================Path Constaint===========================

=======================Path Constaint===========================

succs:= 16
if (test3_29(D) != 0)
test.c:77:6: warning: use location
   if (test3)
      ^
	relate logic:= 1
succs:= 9
if (test_16(D) > test2_17(D))
test.c:56:6: warning: use location
   if (test > test2)
      ^
	relate logic:= 1
succs:= 8
if (test_16(D) != 0)
test.c:50:5: warning: use location
  if (test)
     ^
	relate logic:= 1
=======================Path Constaint===========================


 Expand conflict 
 The same function may have multiple branches :foo
# .MEM_47 = VDEF <.MEM_32>
foo (p_20(D));
test.c:58:4: warning: use location
    foo(p);
    ^
# .MEM_50 = VDEF <.MEM_33>
foo (p_20(D));
test.c:79:4: warning: use location
    foo(p);
    ^
=======================Path Constaint===========================

succs:= 16
if (test3_29(D) != 0)
test.c:77:6: warning: use location
   if (test3)
      ^
	relate logic:= 1
succs:= 9
if (test_16(D) > test2_17(D))
test.c:56:6: warning: use location
   if (test > test2)
      ^
	relate logic:= 1
succs:= 8
if (test_16(D) != 0)
test.c:50:5: warning: use location
  if (test)
     ^
	relate logic:= 1
=======================Path Constaint===========================

=======================Path Constaint===========================

=succs:= 9
if (test_16(D) > test2_17(D))
test.c:56:6: warning: use location
   if (test > test2)
      ^
	relate logic:= 0
=succs:= 8
if (test_16(D) != 0)
test.c:50:5: warning: use location
  if (test)
     ^
	relate logic:= 1
=======================Path Constaint===========================


 Expand conflict 
 The same function may have multiple branches :foo
# .MEM_47 = VDEF <.MEM_32>
foo (p_20(D));
test.c:58:4: warning: use location
    foo(p);
    ^
# .MEM_44 = VDEF <.MEM_32>
foo (p_20(D));
test.c:68:4: warning: use location
    foo(p);
    ^
=======================Path Constaint===========================

=succs:= 9
if (test_16(D) > test2_17(D))
test.c:56:6: warning: use location
   if (test > test2)
      ^
	relate logic:= 0
=succs:= 8
if (test_16(D) != 0)
test.c:50:5: warning: use location
  if (test)
     ^
	relate logic:= 1
=======================Path Constaint===========================

=======================Path Constaint===========================

=succs:= 10
if (test_16(D) < test2_17(D))
test.c:59:7: warning: use location
    if (test < test2)
       ^
	relate logic:= 0
=succs:= 9
if (test_16(D) > test2_17(D))
test.c:56:6: warning: use location
   if (test > test2)
      ^
	relate logic:= 1
=succs:= 8
if (test_16(D) != 0)
test.c:50:5: warning: use location
  if (test)
     ^
	relate logic:= 1
=======================Path Constaint===========================


 Expand conflict 
 The same function may have multiple branches :foo
# .MEM_47 = VDEF <.MEM_32>
foo (p_20(D));
test.c:58:4: warning: use location
    foo(p);
    ^
# .MEM_48 = VDEF <.MEM_47>
foo (p_20(D));
test.c:64:5: warning: use location
     foo(p);
     ^
=======================Path Constaint===========================

=succs:= 10
if (test_16(D) < test2_17(D))
test.c:59:7: warning: use location
    if (test < test2)
       ^
	relate logic:= 0
=succs:= 9
if (test_16(D) > test2_17(D))
test.c:56:6: warning: use location
   if (test > test2)
      ^
	relate logic:= 1
=succs:= 8
if (test_16(D) != 0)
test.c:50:5: warning: use location
  if (test)
     ^
	relate logic:= 1
=======================Path Constaint===========================

=======================Path Constaint===========================

succs:= 10
if (test_16(D) < test2_17(D))
test.c:59:7: warning: use location
    if (test < test2)
       ^
	relate logic:= 1
succs:= 9
if (test_16(D) > test2_17(D))
test.c:56:6: warning: use location
   if (test > test2)
      ^
	relate logic:= 1
succs:= 8
if (test_16(D) != 0)
test.c:50:5: warning: use location
  if (test)
     ^
	relate logic:= 1
=======================Path Constaint===========================


 Expand conflict 
 The same function may have multiple branches :foo
# .MEM_47 = VDEF <.MEM_32>
foo (p_20(D));
test.c:58:4: warning: use location
    foo(p);
    ^
# .MEM_49 = VDEF <.MEM_47>
foo (p_20(D));
test.c:61:5: warning: use location
     foo(p);
     ^
=======================Path Constaint===========================

succs:= 10
if (test_16(D) < test2_17(D))
test.c:59:7: warning: use location
    if (test < test2)
       ^
	relate logic:= 1
succs:= 9
if (test_16(D) > test2_17(D))
test.c:56:6: warning: use location
   if (test > test2)
      ^
	relate logic:= 1
succs:= 8
if (test_16(D) != 0)
test.c:50:5: warning: use location
  if (test)
     ^
	relate logic:= 1
=======================Path Constaint===========================

=======================Path Constaint===========================

succs:= 9
if (test_16(D) > test2_17(D))
test.c:56:6: warning: use location
   if (test > test2)
      ^
	relate logic:= 1
succs:= 8
if (test_16(D) != 0)
test.c:50:5: warning: use location
  if (test)
     ^
	relate logic:= 1
=======================Path Constaint===========================

# .MEM_47 = VDEF <.MEM_32>
foo (p_20(D));
foo (p_20(D));
test.c:58:4: warning: use location
    foo(p);
    ^
this stmt is child function---foo-----

 ================== trace ================== 
 <ssa_name 0x7f67de6eeb40
    type <pointer_type 0x7f67de701a80
        type <integer_type 0x7f67de6fa5e8 int public SI
            size <integer_cst 0x7f67de6e6e28 constant 32>
            unit size <integer_cst 0x7f67de6e6e40 constant 4>
            align 32 symtab 0 alias set -1 canonical type 0x7f67de6fa5e8 precision 32 min <integer_cst 0x7f67de6e6de0 -2147483648> max <integer_cst 0x7f67de6e6df8 2147483647>
            pointer_to_this <pointer_type 0x7f67de701a80>>
        public unsigned DI
        size <integer_cst 0x7f67de6e6be8 constant 64>
        unit size <integer_cst 0x7f67de6e6c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality>
    var <var_decl 0x7f67de228000 p>
    def_stmt GIMPLE_NOP
    version 20
    ptr-info 0x7f67de219b70>
trace fucntion name:foo 
[40;44m =======trace_function_path foo  function_call count: 1 level :0========  [0m
[40;36m ======= node_fun:foo========= [0m
[40;36m ======= find relate stmt with p ========= [0m
[40;36m ======= relate stmt argument:p ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:malloc========= [0m
[40;46m =======add node_fun stack:malloc========= [0m

 ================== trace ================== 
trace fucntion free:0 

 ================== Start Use after free Check ================== 

dot graph END

 ================== Start Use after free Check ================== 

======================================================================
[40;31m    no free stmt possible memory leak [0m

======================================================================

dot graph START

======================================================================
 <ssa_name 0x7f67de6eeb40
    type <pointer_type 0x7f67de701a80
        type <integer_type 0x7f67de6fa5e8 int public SI
            size <integer_cst 0x7f67de6e6e28 constant 32>
            unit size <integer_cst 0x7f67de6e6e40 constant 4>
            align 32 symtab 0 alias set -1 canonical type 0x7f67de6fa5e8 precision 32 min <integer_cst 0x7f67de6e6de0 -2147483648> max <integer_cst 0x7f67de6e6df8 2147483647>
            pointer_to_this <pointer_type 0x7f67de701a80>>
        public unsigned DI
        size <integer_cst 0x7f67de6e6be8 constant 64>
        unit size <integer_cst 0x7f67de6e6c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality>
    var <var_decl 0x7f67de228000 p>
    def_stmt GIMPLE_NOP
    version 20
    ptr-info 0x7f67de219b70>

 ================== trace ptable================== 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr--------
this other function -----------
 
 Start check Pointer Collect  

======================================================================
=======================Path Constaint===========================

succs:= 18
if (test_16(D) == test2_17(D))
test.c:83:10: warning: use location
  else if (test == test2)
          ^
	relate logic:= 1
succs:= 8
if (test_16(D) != 0)
test.c:50:5: warning: use location
  if (test)
     ^
	relate logic:= 0
=======================Path Constaint===========================


 Expand conflict 
 The same function may have multiple branches :foo
# .MEM_49 = VDEF <.MEM_47>
foo (p_20(D));
test.c:61:5: warning: use location
     foo(p);
     ^
# .MEM_43 = VDEF <.MEM_32>
foo (p_20(D));
test.c:84:3: warning: use location
   foo(p);
   ^
=======================Path Constaint===========================

succs:= 18
if (test_16(D) == test2_17(D))
test.c:83:10: warning: use location
  else if (test == test2)
          ^
	relate logic:= 1
succs:= 8
if (test_16(D) != 0)
test.c:50:5: warning: use location
  if (test)
     ^
	relate logic:= 0
=======================Path Constaint===========================

=======================Path Constaint===========================

succs:= 16
if (test3_29(D) != 0)
test.c:77:6: warning: use location
   if (test3)
      ^
	relate logic:= 1
succs:= 9
if (test_16(D) > test2_17(D))
test.c:56:6: warning: use location
   if (test > test2)
      ^
	relate logic:= 1
succs:= 8
if (test_16(D) != 0)
test.c:50:5: warning: use location
  if (test)
     ^
	relate logic:= 1
=======================Path Constaint===========================


 Expand conflict 
 The same function may have multiple branches :foo
# .MEM_49 = VDEF <.MEM_47>
foo (p_20(D));
test.c:61:5: warning: use location
     foo(p);
     ^
# .MEM_50 = VDEF <.MEM_33>
foo (p_20(D));
test.c:79:4: warning: use location
    foo(p);
    ^
=======================Path Constaint===========================

succs:= 16
if (test3_29(D) != 0)
test.c:77:6: warning: use location
   if (test3)
      ^
	relate logic:= 1
succs:= 9
if (test_16(D) > test2_17(D))
test.c:56:6: warning: use location
   if (test > test2)
      ^
	relate logic:= 1
succs:= 8
if (test_16(D) != 0)
test.c:50:5: warning: use location
  if (test)
     ^
	relate logic:= 1
=======================Path Constaint===========================

=======================Path Constaint===========================

=succs:= 9
if (test_16(D) > test2_17(D))
test.c:56:6: warning: use location
   if (test > test2)
      ^
	relate logic:= 0
=succs:= 8
if (test_16(D) != 0)
test.c:50:5: warning: use location
  if (test)
     ^
	relate logic:= 1
=======================Path Constaint===========================


 Expand conflict 
 The same function may have multiple branches :foo
# .MEM_49 = VDEF <.MEM_47>
foo (p_20(D));
test.c:61:5: warning: use location
     foo(p);
     ^
# .MEM_44 = VDEF <.MEM_32>
foo (p_20(D));
test.c:68:4: warning: use location
    foo(p);
    ^
=======================Path Constaint===========================

=succs:= 9
if (test_16(D) > test2_17(D))
test.c:56:6: warning: use location
   if (test > test2)
      ^
	relate logic:= 0
=succs:= 8
if (test_16(D) != 0)
test.c:50:5: warning: use location
  if (test)
     ^
	relate logic:= 1
=======================Path Constaint===========================

=======================Path Constaint===========================

=succs:= 10
if (test_16(D) < test2_17(D))
test.c:59:7: warning: use location
    if (test < test2)
       ^
	relate logic:= 0
=succs:= 9
if (test_16(D) > test2_17(D))
test.c:56:6: warning: use location
   if (test > test2)
      ^
	relate logic:= 1
=succs:= 8
if (test_16(D) != 0)
test.c:50:5: warning: use location
  if (test)
     ^
	relate logic:= 1
=======================Path Constaint===========================


 Expand conflict 
 The same function may have multiple branches :foo
# .MEM_49 = VDEF <.MEM_47>
foo (p_20(D));
test.c:61:5: warning: use location
     foo(p);
     ^
# .MEM_48 = VDEF <.MEM_47>
foo (p_20(D));
test.c:64:5: warning: use location
     foo(p);
     ^
=======================Path Constaint===========================

=succs:= 10
if (test_16(D) < test2_17(D))
test.c:59:7: warning: use location
    if (test < test2)
       ^
	relate logic:= 0
=succs:= 9
if (test_16(D) > test2_17(D))
test.c:56:6: warning: use location
   if (test > test2)
      ^
	relate logic:= 1
=succs:= 8
if (test_16(D) != 0)
test.c:50:5: warning: use location
  if (test)
     ^
	relate logic:= 1
=======================Path Constaint===========================

=======================Path Constaint===========================

succs:= 10
if (test_16(D) < test2_17(D))
test.c:59:7: warning: use location
    if (test < test2)
       ^
	relate logic:= 1
succs:= 9
if (test_16(D) > test2_17(D))
test.c:56:6: warning: use location
   if (test > test2)
      ^
	relate logic:= 1
succs:= 8
if (test_16(D) != 0)
test.c:50:5: warning: use location
  if (test)
     ^
	relate logic:= 1
=======================Path Constaint===========================

# .MEM_49 = VDEF <.MEM_47>
foo (p_20(D));
foo (p_20(D));
test.c:61:5: warning: use location
     foo(p);
     ^
this stmt is child function---foo-----

 ================== trace ================== 
 <ssa_name 0x7f67de6eeb40
    type <pointer_type 0x7f67de701a80
        type <integer_type 0x7f67de6fa5e8 int public SI
            size <integer_cst 0x7f67de6e6e28 constant 32>
            unit size <integer_cst 0x7f67de6e6e40 constant 4>
            align 32 symtab 0 alias set -1 canonical type 0x7f67de6fa5e8 precision 32 min <integer_cst 0x7f67de6e6de0 -2147483648> max <integer_cst 0x7f67de6e6df8 2147483647>
            pointer_to_this <pointer_type 0x7f67de701a80>>
        public unsigned DI
        size <integer_cst 0x7f67de6e6be8 constant 64>
        unit size <integer_cst 0x7f67de6e6c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality>
    var <var_decl 0x7f67de228000 p>
    def_stmt GIMPLE_NOP
    version 20
    ptr-info 0x7f67de219b70>
trace fucntion name:foo 
[40;44m =======trace_function_path foo  function_call count: 1 level :0========  [0m
[40;36m ======= node_fun:foo========= [0m
[40;36m ======= find relate stmt with p ========= [0m
[40;36m ======= relate stmt argument:p ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:malloc========= [0m
[40;46m =======add node_fun stack:malloc========= [0m

 ================== trace ================== 
trace fucntion free:0 
=======================Path Constaint===========================

succs:= 9
if (test_16(D) > test2_17(D))
test.c:56:6: warning: use location
   if (test > test2)
      ^
	relate logic:= 1
succs:= 8
if (test_16(D) != 0)
test.c:50:5: warning: use location
  if (test)
     ^
	relate logic:= 1
=======================Path Constaint===========================


 Expand conflict 
 The same function may have multiple branches :foo
# .MEM_49 = VDEF <.MEM_47>
foo (p_20(D));
test.c:61:5: warning: use location
     foo(p);
     ^
# .MEM_47 = VDEF <.MEM_32>
foo (p_20(D));
test.c:58:4: warning: use location
    foo(p);
    ^
=======================Path Constaint===========================

succs:= 9
if (test_16(D) > test2_17(D))
test.c:56:6: warning: use location
   if (test > test2)
      ^
	relate logic:= 1
succs:= 8
if (test_16(D) != 0)
test.c:50:5: warning: use location
  if (test)
     ^
	relate logic:= 1
=======================Path Constaint===========================


 ================== Start Use after free Check ================== 

dot graph END

 ================== Start Use after free Check ================== 

======================================================================
[40;31m    no free stmt possible memory leak [0m

======================================================================

dot graph START

======================================================================
 <ssa_name 0x7f67de6eeb88
    type <pointer_type 0x7f67de701a80
        type <integer_type 0x7f67de6fa5e8 int public SI
            size <integer_cst 0x7f67de6e6e28 constant 32>
            unit size <integer_cst 0x7f67de6e6e40 constant 4>
            align 32 symtab 0 alias set -1 canonical type 0x7f67de6fa5e8 precision 32 min <integer_cst 0x7f67de6e6de0 -2147483648> max <integer_cst 0x7f67de6e6df8 2147483647>
            pointer_to_this <pointer_type 0x7f67de701a80>>
        public unsigned DI
        size <integer_cst 0x7f67de6e6be8 constant 64>
        unit size <integer_cst 0x7f67de6e6c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality>
    var <var_decl 0x7f67df47bf30 p3>
    def_stmt GIMPLE_NOP
    version 24
    ptr-info 0x7f67de219b88>

 ================== trace ptable================== 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr--------
this other function -----------
 
 Start check Pointer Collect  

======================================================================
=======================Path Constaint===========================

succs:= 13
if (test_16(D) < test2_17(D))
test.c:69:7: warning: use location
    if (test < test2)
       ^
	relate logic:= 1
succs:= 9
if (test_16(D) > test2_17(D))
test.c:56:6: warning: use location
   if (test > test2)
      ^
	relate logic:= 0
succs:= 8
if (test_16(D) != 0)
test.c:50:5: warning: use location
  if (test)
     ^
	relate logic:= 1
=======================Path Constaint===========================

# .MEM_46 = VDEF <.MEM_44>
foo (p3_24(D));
foo (p3_24(D));
test.c:71:5: warning: use location
     foo(p3);
     ^
this stmt is child function---foo-----

 ================== trace ================== 
 <ssa_name 0x7f67de6eeb88
    type <pointer_type 0x7f67de701a80
        type <integer_type 0x7f67de6fa5e8 int public SI
            size <integer_cst 0x7f67de6e6e28 constant 32>
            unit size <integer_cst 0x7f67de6e6e40 constant 4>
            align 32 symtab 0 alias set -1 canonical type 0x7f67de6fa5e8 precision 32 min <integer_cst 0x7f67de6e6de0 -2147483648> max <integer_cst 0x7f67de6e6df8 2147483647>
            pointer_to_this <pointer_type 0x7f67de701a80>>
        public unsigned DI
        size <integer_cst 0x7f67de6e6be8 constant 64>
        unit size <integer_cst 0x7f67de6e6c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality>
    var <var_decl 0x7f67df47bf30 p3>
    def_stmt GIMPLE_NOP
    version 24
    ptr-info 0x7f67de219b88>
trace fucntion name:foo 
[40;44m =======trace_function_path foo  function_call count: 1 level :0========  [0m
[40;36m ======= node_fun:foo========= [0m
[40;36m ======= find relate stmt with p3 ========= [0m
[40;36m ======= relate stmt argument:p3 ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:malloc========= [0m
[40;46m =======add node_fun stack:malloc========= [0m

 ================== trace ================== 
trace fucntion free:0 

 ================== Start Use after free Check ================== 

dot graph END

 ================== Start Use after free Check ================== 

======================================================================
[40;31m    no free stmt possible memory leak [0m

======================================================================

dot graph START

======================================================================
 <ssa_name 0x7f67de6eeaf8
    type <pointer_type 0x7f67de701a80
        type <integer_type 0x7f67de6fa5e8 int public SI
            size <integer_cst 0x7f67de6e6e28 constant 32>
            unit size <integer_cst 0x7f67de6e6e40 constant 4>
            align 32 symtab 0 alias set -1 canonical type 0x7f67de6fa5e8 precision 32 min <integer_cst 0x7f67de6e6de0 -2147483648> max <integer_cst 0x7f67de6e6df8 2147483647>
            pointer_to_this <pointer_type 0x7f67de701a80>>
        public unsigned DI
        size <integer_cst 0x7f67de6e6be8 constant 64>
        unit size <integer_cst 0x7f67de6e6c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality>
    var <var_decl 0x7f67df47bea0 p4>
    def_stmt GIMPLE_NOP
    version 18
    ptr-info 0x7f67de219b58>

 ================== trace ptable================== 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr--------
this other function -----------

======================================================================
[40;31m 	Can't find this fucntion in Pointer table [0m
[40;31m 	Possiable no other stmt relate with this stmt [0m

======================================================================
[40;33m =======POP node_fun stack:main========= [0m
fucntion collect path finsh
=======Mapping node_fun:foo=========
=======is loop:0=========
<bb 2> [100.00%]:
_1 = malloc (10);
_2 = (long int) _1;
_3 = (int) _2;
*z_6(D) = _3;
return;

=======Mapping node_fun:main=========
=======is loop:0=========
<bb 2> [8.03%]:

=======is loop:1=========
label2 [14.45%]:
foo (p5_9(D));
goto <bb 23>; [100.00%]

=======is loop:1=========
label3 [85.55%]:

=======is loop:1=========
<bb 23> [100.00%]:
foo (p5_9(D));
_1 = test5_12(D) / 10;
switch (_1) <default: <L4> [33.33%], case 5: <L2> [33.33%], case 10: <L3> [33.33%]>

=======is loop:1=========
<L2> [33.33%]:
foo (p5_9(D));
goto <bb 8>; [100.00%]

=======is loop:1=========
<L3> [33.33%]:
foo (p5_9(D));
goto <bb 8>; [100.00%]

=======is loop:1=========
<L4> [33.33%]:
foo (p5_9(D));

=======is loop:1=========
<bb 8> [99.99%]:
if (test_16(D) != 0)
  goto <bb 9>; [92.50%]
else
  goto <bb 18>; [7.50%]

=======is loop:1=========
<bb 9> [92.49%]:
if (test_16(D) > test2_17(D))
  goto <bb 10>; [7.50%]
else
  goto <bb 13>; [92.50%]

=======is loop:1=========
<bb 10> [6.94%]:
foo (p_20(D));
if (test_16(D) < test2_17(D))
  goto <bb 11>; [50.00%]
else
  goto <bb 12>; [50.00%]

=======is loop:1=========
<bb 11> [3.47%]:
foo (p_20(D));
goto <bb 16>; [100.00%]

=======is loop:1=========
<bb 12> [3.47%]:
foo (p_20(D));
goto <bb 16>; [100.00%]

=======is loop:1=========
<bb 13> [85.55%]:
foo (p_20(D));
if (test_16(D) < test2_17(D))
  goto <bb 14>; [50.00%]
else
  goto <bb 15>; [50.00%]

=======is loop:1=========
<bb 14> [42.78%]:
foo (p3_24(D));
goto <bb 4> (label3); [100.00%]

=======is loop:1=========
<bb 15> [42.78%]:
foo (p5_9(D));
goto <bb 4> (label3); [100.00%]

=======is loop:1=========
<bb 16> [6.94%]:
if (test3_29(D) != 0)
  goto <bb 17>; [92.50%]
else
  goto <bb 22>; [7.50%]

=======is loop:1=========
<bb 17> [6.42%]:
foo (p_20(D));
goto <bb 3> (label2); [100.00%]

=======is loop:0=========
<bb 18> [7.50%]:
if (test_16(D) == test2_17(D))
  goto <bb 19>; [17.77%]
else
  goto <bb 20>; [82.23%]

=======is loop:0=========
<bb 19> [1.33%]:
foo (p_20(D));
goto <bb 22>; [100.00%]

=======is loop:0=========
<bb 20> [6.17%]:
if (test_16(D) > test2_17(D))
  goto <bb 21>; [36.64%]
else
  goto <bb 22>; [63.36%]

=======is loop:0=========
<bb 21> [2.26%]:
foo (p4_18(D));

=======is loop:0=========
<bb 22> [8.02%]:
return 0;

[40;32mSTART CHECKSTART CHECKSTART CHECKSTART CHECKSTART CHECK[0m
    =()=
 ,/'_||_
  (___  `.
 ./  `=='
                   
    ~~~~~~~~~~~  
 ~~~~~~
           ~~~~~~~
[40;34m    find Entry point : 4 [0m
[40;34m    used_stmt array stack totalsize of : 480 [0m
[40;34m    collect time: : 0.000074 s [0m
[40;34m    algorithm time: 0.006054 s [0m
[40;34m    gimple stmt count : : 34 [0m
[40;32mSTART CHECKSTART CHECKSTART CHECKSTART CHECKSTART CHECK[0m
