test.c: In function â€˜mainâ€™:
test.c:60:14: warning: assignment to â€˜intâ€™ from â€˜char *â€™ makes integer from pointer without a cast [-Wint-conversion]
   60 |         q[0] = "0";
      |              ^
test.c:61:14: warning: assignment to â€˜intâ€™ from â€˜char *â€™ makes integer from pointer without a cast [-Wint-conversion]
   61 |         q[1] = "0";
      |              ^
test.c:80:13: warning: passing argument 1 of â€˜fooâ€™ from incompatible pointer type [-Wincompatible-pointer-types]
   80 |         foo(p);
      |             ^
      |             |
      |             struct st *
test.c:27:14: note: expected â€˜int *â€™ but argument is of type â€˜struct st *â€™
   27 | int foo(int *z)
      |         ~~~~~^
test.c:99:12: warning: assignment to â€˜int *â€™ from â€˜intâ€™ makes pointer from integer without a cast [-Wint-conversion]
   99 |         p5 = foo9(p5);
      |            ^
test.c:123:29: warning: passing argument 1 of â€˜fooâ€™ from incompatible pointer type [-Wincompatible-pointer-types]
  123 |                         foo(p);
      |                             ^
      |                             |
      |                             struct st *
test.c:27:14: note: expected â€˜int *â€™ but argument is of type â€˜struct st *â€™
   27 | int foo(int *z)
      |         ~~~~~^
test.c:126:37: warning: passing argument 1 of â€˜fooâ€™ from incompatible pointer type [-Wincompatible-pointer-types]
  126 |                                 foo(p);
      |                                     ^
      |                                     |
      |                                     struct st *
test.c:27:14: note: expected â€˜int *â€™ but argument is of type â€˜struct st *â€™
   27 | int foo(int *z)
      |         ~~~~~^
test.c:130:37: warning: passing argument 1 of â€˜fooâ€™ from incompatible pointer type [-Wincompatible-pointer-types]
  130 |                                 foo(p);
      |                                     ^
      |                                     |
      |                                     struct st *
test.c:27:14: note: expected â€˜int *â€™ but argument is of type â€˜struct st *â€™
   27 | int foo(int *z)
      |         ~~~~~^
test.c:134:29: warning: passing argument 1 of â€˜fooâ€™ from incompatible pointer type [-Wincompatible-pointer-types]
  134 |                         foo(p);
      |                             ^
      |                             |
      |                             struct st *
test.c:27:14: note: expected â€˜int *â€™ but argument is of type â€˜struct st *â€™
   27 | int foo(int *z)
      |         ~~~~~^
test.c:145:29: warning: passing argument 1 of â€˜fooâ€™ from incompatible pointer type [-Wincompatible-pointer-types]
  145 |                         foo(p);
      |                             ^
      |                             |
      |                             struct st *
test.c:27:14: note: expected â€˜int *â€™ but argument is of type â€˜struct st *â€™
   27 | int foo(int *z)
      |         ~~~~~^
Profile consistency report:

                                 |mismatch     |mismatch     |                     |
Pass name                        |IN    |IN    |OUT   |OUT   |overall              |
                                 |freq  |count |freq  |count |size      |time      |
cfg                  ------------|      |      |      |      |          |          |
ompexp                           |      |      |      |      |   +100.0%|          |
fixup_cfg            ------------|      |      |      |      |          |          |
ssa                              |      |      |      |      |     -1.0%|          |
nothrow                          |      |      |      |      |     -1.0%|          |
fixup_cfg            ------------|      |      |      |      |          |          |
local-fnsummary      ------------|      |      |      |      |          |          |
einline              ------------|      |      |      |      |          |          |
early_optimizations  ------------|      |      |      |      |          |          |
objsz                ------------|      |      |      |      |          |          |
ccp                  ------------|      |      |      |      |          |          |
forwprop                         |      |      |      |      |     -2.0%|          |
ethread                          |      |      |      |      |     -2.0%|          |
esra                 ------------|      |      |      |      |          |          |
ealias               ------------|      |      |      |      |          |          |
mergephi             ------------|      |      |      |      |          |          |
cddce                ------------|      |      |      |      |          |          |
phiopt               ------------|      |      |      |      |          |          |
modref               ------------|      |      |      |      |          |          |
iftoswitch           ------------|      |      |      |      |          |          |
profile_estimate     ------------|      |      |      |      |          |          |
local-pure-const                 |      |      |      |      |          |   +100.0%|
release_ssa          ------------|      |      |      |      |          |          |
local-fnsummary      ------------|      |      |      |      |          |          |
=======ipa_pta=========
===============The first stage : Point of interest stmt collect=================
=======node_fun:main=========
--------GIMPLE Cond -------
 initssssss:= 0
 initssssss:= 1
if (test_38(D) != 0)
FIND 1:= 3
--------GIMPLE Cond -------
 initssssss:= 0
 initssssss:= 1
 testtss:= 2
if (test_38(D) != 0)
FIND 1:= 3
succs:= 2
if (test_38(D) > test2_40(D))
FIND 1:= 4
--------GIMPLE Cond -------
 initssssss:= 0
 initssssss:= 1
 testtss:= 3
 testtss:= 2
if (test_38(D) > test2_40(D))
FIND 1:= 4
succs:= 3
if (test_38(D) < test2_40(D))
FIND 1:= 5
if (test_38(D) < test2_40(D))
FIND 1:= 5
succs:= 4
if (test_38(D) < test2_40(D))
FIND 2:= 6
if (test_38(D) > test2_40(D))
FIND 2:= 7
--------GIMPLE Cond -------
 initssssss:= 0
 initssssss:= 1
 testtss:= 3
 testtss:= 2
if (test_38(D) > test2_40(D))
FIND 2:= 7
succs2:= 3
if (test_38(D) < test2_40(D))
FIND 1:= 8
if (test_38(D) < test2_40(D))
FIND 2:= 9
--------GIMPLE Cond -------
 initssssss:= 0
 initssssss:= 1
 testtss:= 2
if (test3_49(D) != 0)
FIND 1:= 11
--------GIMPLE Cond -------
 initssssss:= 0
 initssssss:= 1
 testtss:= 10
 testtss:= 2
if (test_38(D) != 0)
FIND 2:= 12
if (test3_49(D) != 0)
FIND 2:= 12
if (test_38(D) == test2_40(D))
FIND 1:= 13
--------GIMPLE Cond -------
 initssssss:= 0
 initssssss:= 1
 testtss:= 12
 testtss:= 10
 testtss:= 2
if (test_38(D) == test2_40(D))
FIND 2:= 14
if (test_38(D) >= test2_40(D))
FIND 1:= 15
--------GIMPLE Cond -------
 initssssss:= 0
 initssssss:= 1
 testtss:= 14
 testtss:= 12
 testtss:= 10
 testtss:= 2
if (test_38(D) >= test2_40(D))
FIND 2:= 16
if (test_38(D) > test2_40(D))
FIND 1:= 17
if (test_38(D) > test2_40(D))
FIND 1:= 17
succs:= 16
if (test_38(D) > test2_40(D))
FIND 2:= 18
=======node_fun:foo9=========
=======node_fun:foo=========
===============The first stage : Point of interest stmt collect=================
start PointerConstraint
pointer ftable is 1 
pointer ptable is 1 
===============The second stage : Mapping stmt=================
# .MEM_57 = VDEF <.MEM_56(D)>
p6_15 = malloc (100);
# .MEM_63 = VDEF <.MEM_62>
p9_24 = malloc (0);
# .MEM_64 = VDEF <.MEM_63>
_5 = malloc (1);
# .MEM_67 = VDEF <.MEM_66>
p_29 = malloc (10);
# .MEM_68 = VDEF <.MEM_67>
_6 = malloc (1);
# .MEM_70 = VDEF <.MEM_69>
_7 = malloc (1);
# .MEM_72 = VDEF <.MEM_71>
foo (p_29);
# .MEM_73 = VDEF <.MEM_72>
_8 = foo9 (p5_35(D));
# .MEM_74 = VDEF <.MEM_73>
foo9 (p5_37);
# .MEM_78 = VDEF <.MEM_74>
foo (p_29);
# .MEM_80 = VDEF <.MEM_78>
foo (p_29);
# .MEM_81 = VDEF <.MEM_80>
foo9 (p5_37);
# .MEM_79 = VDEF <.MEM_78>
foo (p_29);
# .MEM_75 = VDEF <.MEM_74>
foo (p_29);
# .MEM_77 = VDEF <.MEM_75>
foo (p3_43(D));
# .MEM_76 = VDEF <.MEM_75>
foo9 (p5_37);
# .MEM_82 = VDEF <.MEM_53>
foo (p_29);
# .MEM_86 = VDEF <.MEM_54>
foo9 (p5_37);
# .MEM_85 = VDEF <.MEM_54>
foo9 (p5_37);
# .MEM_83 = VDEF <.MEM_54>
foo9 (p5_37);
# .MEM_84 = VDEF <.MEM_83>
foo (p4_52(D));
start collect similar stmtstart collect similar stmtstart collect similar stmtstart collect similar stmt
start collect similar stmtstart collect similar stmtstart collect similar stmtstart collect similar stmt
start collect similar stmtstart collect similar stmtstart collect similar stmtstart collect similar stmt
start collect similar stmtstart collect similar stmtstart collect similar stmtstart collect similar stmt
start collect similar stmtstart collect similar stmtstart collect similar stmtstart collect similar stmt
===============The second stage : build fucntion type=================
[40;41mSTART CHECKSTART CHECKSTART CHECKSTART CHECKSTART CHECK[0m
[40;41mSTART CHECKSTART CHECKSTART CHECKSTART CHECKSTART CHECK[0m
    =()=
 ,/'_||_
  (___  `.
 ./  `=='
      |||
      |||
      |||
      |||
[40;41mSTART CHECKSTART CHECKSTART CHECKSTART CHECKSTART CHECK[0m
[40;41mSTART CHECKSTART CHECKSTART CHECKSTART CHECKSTART CHECK[0m
===============The second stage : record fucntion =================

=============== The third stage : Start detection  =================
[40;44m =======node_fun:main========= [0m
[40;44m fucntion collect path  [0m
[40;44m =======print_function_path main  function_call count: 5 level :0========  [0m
[40;44m =======print_function_type 0  ========  [0m
[40;42m =======pre add _ fucntion:foo========= [0m
[40;44m =======print_function_type 0  ========  [0m
[40;44m =======print_function_path foo  function_call count: 1 level :1========  [0m
[40;44m =======print_function_type 0  ========  [0m
[40;42m =======pre add _ fucntion:free========= [0m
[40;33m =======POP node_fun stack:free========= [0m
[40;42m =======pre_check_funciton:foo========= [0m
[40;42m =======start_check_funciton:foo========= [0m
[40;33m =======POP node_fun stack:foo========= [0m
[40;42m =======pre add _ fucntion:foo9========= [0m
[40;44m =======print_function_type 0  ========  [0m
[40;44m =======print_function_path foo9  function_call count: 1 level :1========  [0m
[40;44m =======print_function_type 0  ========  [0m
[40;42m =======pre add _ fucntion:free========= [0m
[40;33m =======POP node_fun stack:free========= [0m
[40;42m =======pre_check_funciton:foo9========= [0m
[40;42m =======start_check_funciton:foo9========= [0m
[40;33m =======POP node_fun stack:foo9========= [0m
[40;42m =======pre add _ fucntion:malloc========= [0m
[40;33m =======POP node_fun stack:malloc========= [0m
[40;42m =======pre add _ fucntion:free========= [0m
[40;33m =======POP node_fun stack:free========= [0m
[40;42m =======pre add _ fucntion:realloc========= [0m
[40;33m =======POP node_fun stack:realloc========= [0m
[40;42m =======pre_check_funciton:main========= [0m
[40;42m =======start_check_funciton:main========= [0m

dot graph START

======================================================================
 <ssa_name 0x7f091f19a870
    type <pointer_type 0x7f091f1ae9d8
        type <integer_type 0x7f091f1a75e8 int public SI
            size <integer_cst 0x7f091f192df8 constant 32>
            unit-size <integer_cst 0x7f091f192e10 constant 4>
            align:32 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7f091f1a75e8 precision:32 min <integer_cst 0x7f091f192db0 -2147483648> max <integer_cst 0x7f091f192dc8 2147483647>
            pointer_to_this <pointer_type 0x7f091f1ae9d8>>
        public unsigned DI
        size <integer_cst 0x7f091f192bb8 constant 64>
        unit-size <integer_cst 0x7f091f192bd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
    var <var_decl 0x7f091fa3acf0 p6>
    def_stmt p6_15 = malloc (100);
    version:15
    ptr-info 0x7f091ecc9228>
# .MEM_57 = VDEF <.MEM_56(D)>
p6_15 = malloc (100);

 ================== trace ptable================== 
trace fucntion name:malloc 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr---malloc-----
this Reserved word function ------malloc-----
 
 Start check Pointer Collect  

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_62 = VDEF <.MEM_61>
MEM[(int *)p6_15 + 4B] = _4;
bb index := 2
# VUSE <.MEM_55>
return 0;
In function â€˜mainâ€™:
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
MEM[(int *)p6_15 + 4B] = _4;
test.c:61:14: warning: use location
   61 |         q[1] = "0";
      |              ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_62 = VDEF <.MEM_61>
MEM[(int *)p6_15 + 4B] = _4;
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
MEM[(int *)p6_15 + 4B] = _4;
test.c:61:14: warning: use location

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_61 = VDEF <.MEM_60>
*p6_15 = _2;
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
*p6_15 = _2;
test.c:60:14: warning: use location
   60 |         q[0] = "0";
      |              ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_61 = VDEF <.MEM_60>
*p6_15 = _2;
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
*p6_15 = _2;
test.c:60:14: warning: use location

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: use location
   57 |         p6 = realloc(p6, 100);
      |              ^
this stmt is child function---realloc-----

 ================== find ================== 
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: use location
[40;32m    FIND REALLOC STMT count:1 name:realloc [0m
[40;32m    this stmt possiable free memory [0m

 ================== find ================== 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: use location
   58 |         p7 = realloc(p6, 100);
      |              ^
this stmt is child function---realloc-----

 ================== find ================== 
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: use location
[40;32m    FIND REALLOC STMT count:2 name:realloc [0m
[40;32m    this stmt possiable free memory [0m

 ================== find ================== 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_60 = VDEF <.MEM_59>
*p7_19 = 48;
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
*p7_19 = 48;
test.c:59:15: warning: use location
   59 |         p7[0] = '0';
      |               ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_57 = VDEF <.MEM_56(D)>
p6_15 = malloc (100);
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
# .MEM_57 = VDEF <.MEM_56(D)>
p6_15 = malloc (100);
p6_15 = malloc (100);
test.c:54:19: warning: use location
   54 |         int *p6 = malloc(100);
      |                   ^
this stmt is child function---malloc-----

 ================== trace ================== 

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7f091f19a870
    type <pointer_type 0x7f091f1ae9d8
        type <integer_type 0x7f091f1a75e8 int public SI
            size <integer_cst 0x7f091f192df8 constant 32>
            unit-size <integer_cst 0x7f091f192e10 constant 4>
            align:32 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7f091f1a75e8 precision:32 min <integer_cst 0x7f091f192db0 -2147483648> max <integer_cst 0x7f091f192dc8 2147483647>
            pointer_to_this <pointer_type 0x7f091f1ae9d8>>
        public unsigned DI
        size <integer_cst 0x7f091f192bb8 constant 64>
        unit-size <integer_cst 0x7f091f192bd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
    var <var_decl 0x7f091fa3acf0 p6>
    def_stmt p6_15 = malloc (100);
    version:15
    ptr-info 0x7f091ecc9228>
[40;35m <Looserules> find realloc stmt free same pointer [0m
*/If realloc() fails, the initial memory block will not be freed() */# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: use location
   57 |         p6 = realloc(p6, 100);
      |              ^
[40;35m <Looserules> find realloc stmt free same pointer [0m
*/If realloc() fails, the initial memory block will not be freed() */# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: use location
   58 |         p7 = realloc(p6, 100);
      |              ^

 ================== Start Use after free Check ================== 

============================================================
# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: Use after free error!: free location 
   57 |         p6 = realloc(p6, 100);
      |              ^
# .MEM_62 = VDEF <.MEM_61>
MEM[(int *)p6_15 + 4B] = _4;
test.c:61:14: warning: use location
   61 |         q[1] = "0";
      |              ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m

 ================== warring ================== 

============================================================
# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: Use after free error!: free location 
   58 |         p7 = realloc(p6, 100);
      |              ^
# .MEM_62 = VDEF <.MEM_61>
MEM[(int *)p6_15 + 4B] = _4;
test.c:61:14: warning: use location
   61 |         q[1] = "0";
      |              ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: Use after free error!: free location 
   57 |         p6 = realloc(p6, 100);
      |              ^
# .MEM_62 = VDEF <.MEM_61>
MEM[(int *)p6_15 + 4B] = _4;
test.c:61:14: warning: use location
   61 |         q[1] = "0";
      |              ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: Use after free error!: free location 
   58 |         p7 = realloc(p6, 100);
      |              ^
# .MEM_62 = VDEF <.MEM_61>
MEM[(int *)p6_15 + 4B] = _4;
test.c:61:14: warning: use location
   61 |         q[1] = "0";
      |              ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m

 ================== warring ================== 

============================================================
# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: Use after free error!: free location 
   57 |         p6 = realloc(p6, 100);
      |              ^
# .MEM_62 = VDEF <.MEM_61>
MEM[(int *)p6_15 + 4B] = _4;
test.c:61:14: warning: use location
   61 |         q[1] = "0";
      |              ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m

 ================== warring ================== 

============================================================
# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: Use after free error!: free location 
   58 |         p7 = realloc(p6, 100);
      |              ^
# .MEM_62 = VDEF <.MEM_61>
MEM[(int *)p6_15 + 4B] = _4;
test.c:61:14: warning: use location
   61 |         q[1] = "0";
      |              ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: Use after free error!: free location 
   57 |         p6 = realloc(p6, 100);
      |              ^
# .MEM_62 = VDEF <.MEM_61>
MEM[(int *)p6_15 + 4B] = _4;
test.c:61:14: warning: use location
   61 |         q[1] = "0";
      |              ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: Use after free error!: free location 
   58 |         p7 = realloc(p6, 100);
      |              ^
# .MEM_62 = VDEF <.MEM_61>
MEM[(int *)p6_15 + 4B] = _4;
test.c:61:14: warning: use location
   61 |         q[1] = "0";
      |              ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m

 ================== warring ================== 

============================================================
# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: Use after free error!: free location 
   57 |         p6 = realloc(p6, 100);
      |              ^
# .MEM_61 = VDEF <.MEM_60>
*p6_15 = _2;
test.c:60:14: warning: use location
   60 |         q[0] = "0";
      |              ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m

 ================== warring ================== 

============================================================
# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: Use after free error!: free location 
   58 |         p7 = realloc(p6, 100);
      |              ^
# .MEM_61 = VDEF <.MEM_60>
*p6_15 = _2;
test.c:60:14: warning: use location
   60 |         q[0] = "0";
      |              ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: Use after free error!: free location 
   57 |         p6 = realloc(p6, 100);
      |              ^
# .MEM_61 = VDEF <.MEM_60>
*p6_15 = _2;
test.c:60:14: warning: use location
   60 |         q[0] = "0";
      |              ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: Use after free error!: free location 
   58 |         p7 = realloc(p6, 100);
      |              ^
# .MEM_61 = VDEF <.MEM_60>
*p6_15 = _2;
test.c:60:14: warning: use location
   60 |         q[0] = "0";
      |              ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m

 ================== warring ================== 

============================================================
# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: Use after free error!: free location 
   57 |         p6 = realloc(p6, 100);
      |              ^
# .MEM_61 = VDEF <.MEM_60>
*p6_15 = _2;
test.c:60:14: warning: use location
   60 |         q[0] = "0";
      |              ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m

 ================== warring ================== 

============================================================
# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: Use after free error!: free location 
   58 |         p7 = realloc(p6, 100);
      |              ^
# .MEM_61 = VDEF <.MEM_60>
*p6_15 = _2;
test.c:60:14: warning: use location
   60 |         q[0] = "0";
      |              ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: Use after free error!: free location 
   57 |         p6 = realloc(p6, 100);
      |              ^
# .MEM_61 = VDEF <.MEM_60>
*p6_15 = _2;
test.c:60:14: warning: use location
   60 |         q[0] = "0";
      |              ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: Use after free error!: free location 
   58 |         p7 = realloc(p6, 100);
      |              ^
# .MEM_61 = VDEF <.MEM_60>
*p6_15 = _2;
test.c:60:14: warning: use location
   60 |         q[0] = "0";
      |              ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m

 ================== warring ================== 

============================================================
# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: Use after free error!: free location 
   57 |         p6 = realloc(p6, 100);
      |              ^
# .MEM_60 = VDEF <.MEM_59>
*p7_19 = 48;
test.c:59:15: warning: use location
   59 |         p7[0] = '0';
      |               ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m

 ================== warring ================== 

============================================================
# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: Use after free error!: free location 
   58 |         p7 = realloc(p6, 100);
      |              ^
# .MEM_60 = VDEF <.MEM_59>
*p7_19 = 48;
test.c:59:15: warning: use location
   59 |         p7[0] = '0';
      |               ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: Use after free error!: free location 
   57 |         p6 = realloc(p6, 100);
      |              ^
# .MEM_60 = VDEF <.MEM_59>
*p7_19 = 48;
test.c:59:15: warning: use location
   59 |         p7[0] = '0';
      |               ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: Use after free error!: free location 
   58 |         p7 = realloc(p6, 100);
      |              ^
# .MEM_60 = VDEF <.MEM_59>
*p7_19 = 48;
test.c:59:15: warning: use location
   59 |         p7[0] = '0';
      |               ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m

 ================== warring ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:2 [0m
[40;31m  	free count:2 [0m
[40;31m  	possible double free [Looserules]:2 [0m
[40;31m  	possible double free [rigorous]:2 [0m

======================================================================

======================================================================
[40;31m  	possible double free [rigorous]:2 [0m

======================================================================

dot graph START

======================================================================
 <ssa_name 0x7f091f19a8b8
    type <pointer_type 0x7f091f1ae9d8
        type <integer_type 0x7f091f1a75e8 int public SI
            size <integer_cst 0x7f091f192df8 constant 32>
            unit-size <integer_cst 0x7f091f192e10 constant 4>
            align:32 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7f091f1a75e8 precision:32 min <integer_cst 0x7f091f192db0 -2147483648> max <integer_cst 0x7f091f192dc8 2147483647>
            pointer_to_this <pointer_type 0x7f091f1ae9d8>>
        public unsigned DI
        size <integer_cst 0x7f091f192bb8 constant 64>
        unit-size <integer_cst 0x7f091f192bd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
    var <var_decl 0x7f091fa3acf0 p6>
    def_stmt p6_17 = realloc (p6_15, 100);
    version:17
    ptr-info 0x7f091ecc9240>
# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);

 ================== trace ptable================== 
trace fucntion name:realloc 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr---realloc-----
this Reserved word function ------realloc-----
 
 Start check Pointer Collect  

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_62 = VDEF <.MEM_61>
MEM[(int *)p6_15 + 4B] = _4;
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
MEM[(int *)p6_15 + 4B] = _4;
test.c:61:14: warning: use location
   61 |         q[1] = "0";
      |              ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_62 = VDEF <.MEM_61>
MEM[(int *)p6_15 + 4B] = _4;
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
MEM[(int *)p6_15 + 4B] = _4;
test.c:61:14: warning: use location

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_61 = VDEF <.MEM_60>
*p6_15 = _2;
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
*p6_15 = _2;
test.c:60:14: warning: use location
   60 |         q[0] = "0";
      |              ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_61 = VDEF <.MEM_60>
*p6_15 = _2;
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
*p6_15 = _2;
test.c:60:14: warning: use location

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: use location
   57 |         p6 = realloc(p6, 100);
      |              ^
this stmt is child function---realloc-----

 ================== find ================== 
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: use location
[40;32m    FIND REALLOC STMT count:1 name:realloc [0m
[40;32m    this stmt possiable free memory [0m

 ================== find ================== 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================

 Expand conflict 
 The same function may have multiple branches :realloc
# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: use location
# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: use location
   58 |         p7 = realloc(p6, 100);
      |              ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_60 = VDEF <.MEM_59>
*p7_19 = 48;
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
*p7_19 = 48;
test.c:59:15: warning: use location
   59 |         p7[0] = '0';
      |               ^

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7f091f19a8b8
    type <pointer_type 0x7f091f1ae9d8
        type <integer_type 0x7f091f1a75e8 int public SI
            size <integer_cst 0x7f091f192df8 constant 32>
            unit-size <integer_cst 0x7f091f192e10 constant 4>
            align:32 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7f091f1a75e8 precision:32 min <integer_cst 0x7f091f192db0 -2147483648> max <integer_cst 0x7f091f192dc8 2147483647>
            pointer_to_this <pointer_type 0x7f091f1ae9d8>>
        public unsigned DI
        size <integer_cst 0x7f091f192bb8 constant 64>
        unit-size <integer_cst 0x7f091f192bd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
    var <var_decl 0x7f091fa3acf0 p6>
    def_stmt p6_17 = realloc (p6_15, 100);
    version:17
    ptr-info 0x7f091ecc9240>
[40;35m <Looserules> find realloc stmt free same pointer [0m
*/If realloc() fails, the initial memory block will not be freed() */# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: use location
   57 |         p6 = realloc(p6, 100);
      |              ^
[40;35m <Looserules> find realloc stmt free same pointer [0m
*/If realloc() fails, the initial memory block will not be freed() */# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: use location
   58 |         p7 = realloc(p6, 100);
      |              ^

 ================== Start Use after free Check ================== 

============================================================
# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: Use after free error!: free location 
   57 |         p6 = realloc(p6, 100);
      |              ^
# .MEM_62 = VDEF <.MEM_61>
MEM[(int *)p6_15 + 4B] = _4;
test.c:61:14: warning: use location
   61 |         q[1] = "0";
      |              ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: Use after free error!: free location 
   57 |         p6 = realloc(p6, 100);
      |              ^
# .MEM_62 = VDEF <.MEM_61>
MEM[(int *)p6_15 + 4B] = _4;
test.c:61:14: warning: use location
   61 |         q[1] = "0";
      |              ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: Use after free error!: free location 
   58 |         p7 = realloc(p6, 100);
      |              ^
# .MEM_62 = VDEF <.MEM_61>
MEM[(int *)p6_15 + 4B] = _4;
test.c:61:14: warning: use location
   61 |         q[1] = "0";
      |              ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m

 ================== warring ================== 

============================================================
# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: Use after free error!: free location 
   57 |         p6 = realloc(p6, 100);
      |              ^
# .MEM_62 = VDEF <.MEM_61>
MEM[(int *)p6_15 + 4B] = _4;
test.c:61:14: warning: use location
   61 |         q[1] = "0";
      |              ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: Use after free error!: free location 
   57 |         p6 = realloc(p6, 100);
      |              ^
# .MEM_62 = VDEF <.MEM_61>
MEM[(int *)p6_15 + 4B] = _4;
test.c:61:14: warning: use location
   61 |         q[1] = "0";
      |              ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: Use after free error!: free location 
   58 |         p7 = realloc(p6, 100);
      |              ^
# .MEM_62 = VDEF <.MEM_61>
MEM[(int *)p6_15 + 4B] = _4;
test.c:61:14: warning: use location
   61 |         q[1] = "0";
      |              ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m

 ================== warring ================== 

============================================================
# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: Use after free error!: free location 
   57 |         p6 = realloc(p6, 100);
      |              ^
# .MEM_61 = VDEF <.MEM_60>
*p6_15 = _2;
test.c:60:14: warning: use location
   60 |         q[0] = "0";
      |              ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: Use after free error!: free location 
   57 |         p6 = realloc(p6, 100);
      |              ^
# .MEM_61 = VDEF <.MEM_60>
*p6_15 = _2;
test.c:60:14: warning: use location
   60 |         q[0] = "0";
      |              ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: Use after free error!: free location 
   58 |         p7 = realloc(p6, 100);
      |              ^
# .MEM_61 = VDEF <.MEM_60>
*p6_15 = _2;
test.c:60:14: warning: use location
   60 |         q[0] = "0";
      |              ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m

 ================== warring ================== 

============================================================
# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: Use after free error!: free location 
   57 |         p6 = realloc(p6, 100);
      |              ^
# .MEM_61 = VDEF <.MEM_60>
*p6_15 = _2;
test.c:60:14: warning: use location
   60 |         q[0] = "0";
      |              ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: Use after free error!: free location 
   57 |         p6 = realloc(p6, 100);
      |              ^
# .MEM_61 = VDEF <.MEM_60>
*p6_15 = _2;
test.c:60:14: warning: use location
   60 |         q[0] = "0";
      |              ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: Use after free error!: free location 
   58 |         p7 = realloc(p6, 100);
      |              ^
# .MEM_61 = VDEF <.MEM_60>
*p6_15 = _2;
test.c:60:14: warning: use location
   60 |         q[0] = "0";
      |              ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m

 ================== warring ================== 

============================================================
# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: Use after free error!: free location 
   57 |         p6 = realloc(p6, 100);
      |              ^
# .MEM_60 = VDEF <.MEM_59>
*p7_19 = 48;
test.c:59:15: warning: use location
   59 |         p7[0] = '0';
      |               ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: Use after free error!: free location 
   57 |         p6 = realloc(p6, 100);
      |              ^
# .MEM_60 = VDEF <.MEM_59>
*p7_19 = 48;
test.c:59:15: warning: use location
   59 |         p7[0] = '0';
      |               ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: Use after free error!: free location 
   58 |         p7 = realloc(p6, 100);
      |              ^
# .MEM_60 = VDEF <.MEM_59>
*p7_19 = 48;
test.c:59:15: warning: use location
   59 |         p7[0] = '0';
      |               ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m

 ================== warring ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:2 [0m
[40;31m  	free count:1 [0m
[40;31m  	possible double free [Looserules]:2 [0m

======================================================================

======================================================================
[40;32m   Maybe you don't have memory leak.... need more checks  [0m

======================================================================


dot graph START

======================================================================
 <ssa_name 0x7f091f19a900
    type <pointer_type 0x7f091f1ae9d8
        type <integer_type 0x7f091f1a75e8 int public SI
            size <integer_cst 0x7f091f192df8 constant 32>
            unit-size <integer_cst 0x7f091f192e10 constant 4>
            align:32 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7f091f1a75e8 precision:32 min <integer_cst 0x7f091f192db0 -2147483648> max <integer_cst 0x7f091f192dc8 2147483647>
            pointer_to_this <pointer_type 0x7f091f1ae9d8>>
        public unsigned DI
        size <integer_cst 0x7f091f192bb8 constant 64>
        unit-size <integer_cst 0x7f091f192bd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
    var <var_decl 0x7f091fa3ac60 p7>
    def_stmt p7_19 = realloc (p6_17, 100);
    version:19
    ptr-info 0x7f091ecc9258>
# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);

 ================== trace ptable================== 
trace fucntion name:realloc 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr---realloc-----
this Reserved word function ------realloc-----
 
 Start check Pointer Collect  

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: use location
   58 |         p7 = realloc(p6, 100);
      |              ^
this stmt is child function---realloc-----

 ================== find ================== 
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: use location
[40;32m    FIND REALLOC STMT count:1 name:realloc [0m
[40;32m    this stmt possiable free memory [0m

 ================== find ================== 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_60 = VDEF <.MEM_59>
*p7_19 = 48;
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
*p7_19 = 48;
test.c:59:15: warning: use location
   59 |         p7[0] = '0';
      |               ^

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7f091f19a900
    type <pointer_type 0x7f091f1ae9d8
        type <integer_type 0x7f091f1a75e8 int public SI
            size <integer_cst 0x7f091f192df8 constant 32>
            unit-size <integer_cst 0x7f091f192e10 constant 4>
            align:32 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7f091f1a75e8 precision:32 min <integer_cst 0x7f091f192db0 -2147483648> max <integer_cst 0x7f091f192dc8 2147483647>
            pointer_to_this <pointer_type 0x7f091f1ae9d8>>
        public unsigned DI
        size <integer_cst 0x7f091f192bb8 constant 64>
        unit-size <integer_cst 0x7f091f192bd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
    var <var_decl 0x7f091fa3ac60 p7>
    def_stmt p7_19 = realloc (p6_17, 100);
    version:19
    ptr-info 0x7f091ecc9258>
[40;35m <Looserules> find realloc stmt free same pointer [0m
*/If realloc() fails, the initial memory block will not be freed() */# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: use location
   57 |         p6 = realloc(p6, 100);
      |              ^
[40;35m <Looserules> find realloc stmt free same pointer [0m
*/If realloc() fails, the initial memory block will not be freed() */# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: use location
   58 |         p7 = realloc(p6, 100);
      |              ^

 ================== Start Use after free Check ================== 

============================================================
# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: Use after free error!: free location 
# .MEM_60 = VDEF <.MEM_59>
*p7_19 = 48;
test.c:59:15: warning: use location
   59 |         p7[0] = '0';
      |               ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: Use after free error!: free location 
   57 |         p6 = realloc(p6, 100);
      |              ^
# .MEM_60 = VDEF <.MEM_59>
*p7_19 = 48;
test.c:59:15: warning: use location
   59 |         p7[0] = '0';
      |               ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: Use after free error!: free location 
   58 |         p7 = realloc(p6, 100);
      |              ^
# .MEM_60 = VDEF <.MEM_59>
*p7_19 = 48;
test.c:59:15: warning: use location
   59 |         p7[0] = '0';
      |               ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m

 ================== warring ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:2 [0m
[40;31m  	free count:1 [0m
[40;31m  	possible double free [Looserules]:2 [0m

======================================================================

======================================================================
[40;32m   Maybe you don't have memory leak.... need more checks  [0m

======================================================================


dot graph START

======================================================================
 <ssa_name 0x7f091f19a948
    type <pointer_type 0x7f091ecbb348
        type <record_type 0x7f091ecbbf18 st TI
            size <integer_cst 0x7f091f192c00 constant 128>
            unit-size <integer_cst 0x7f091f192c18 constant 16>
            align:64 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7f091ecbbf18 fields <field_decl 0x7f091ecbe1c8 flag> context <translation_unit_decl 0x7f091f19d168 test.c>
            pointer_to_this <pointer_type 0x7f091ecbb348>>
        unsigned DI
        size <integer_cst 0x7f091f192bb8 constant 64>
        unit-size <integer_cst 0x7f091f192bd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
    var <var_decl 0x7f091fa3abd0 p9>
    def_stmt p9_24 = malloc (0);
    version:24
    ptr-info 0x7f091ecc9270>
# .MEM_63 = VDEF <.MEM_62>
p9_24 = malloc (0);

 ================== trace ptable================== 
trace fucntion name:malloc 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr---malloc-----
this Reserved word function ------malloc-----
 
 Start check Pointer Collect  

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_66 = VDEF <.MEM_65>
free (p9_24);
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
free (p9_24);
test.c:74:9: warning: use location
   74 |         free(p9);
      |         ^
this stmt is child function---free-----

 ================== find ================== 
free (p9_24);
test.c:74:9: warning: use location
[40;32m    HAS FREE STMT count:1 name:free [0m

 ================== find ================== 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_65 = VDEF <.MEM_64>
MEM[(struct st *)p9_24 + 48B].f = _5;
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
MEM[(struct st *)p9_24 + 48B].f = _5;
test.c:73:17: warning: use location
   73 |         p9[3].f = malloc(1);
      |                 ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_65 = VDEF <.MEM_64>
MEM[(struct st *)p9_24 + 48B].f = _5;
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
MEM[(struct st *)p9_24 + 48B].f = _5;
test.c:73:17: warning: use location

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_63 = VDEF <.MEM_62>
p9_24 = malloc (0);
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
# .MEM_63 = VDEF <.MEM_62>
p9_24 = malloc (0);
p9_24 = malloc (0);
test.c:72:25: warning: use location
   72 |         struct st *p9 = malloc(0);
      |                         ^
this stmt is child function---malloc-----

 ================== trace ================== 

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7f091f19a948
    type <pointer_type 0x7f091ecbb348
        type <record_type 0x7f091ecbbf18 st TI
            size <integer_cst 0x7f091f192c00 constant 128>
            unit-size <integer_cst 0x7f091f192c18 constant 16>
            align:64 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7f091ecbbf18 fields <field_decl 0x7f091ecbe1c8 flag> context <translation_unit_decl 0x7f091f19d168 test.c>
            pointer_to_this <pointer_type 0x7f091ecbb348>>
        unsigned DI
        size <integer_cst 0x7f091f192bb8 constant 64>
        unit-size <integer_cst 0x7f091f192bd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
    var <var_decl 0x7f091fa3abd0 p9>
    def_stmt p9_24 = malloc (0);
    version:24
    ptr-info 0x7f091ecc9270>
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_66 = VDEF <.MEM_65>
free (p9_24);
test.c:74:9: warning: use location
   74 |         free(p9);
      |         ^

 ================== Start Use after free Check ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:1 [0m
[40;31m  	free count:1 [0m

======================================================================

======================================================================
[40;32m   Maybe you don't have memory leak.... need more checks  [0m

======================================================================


dot graph START

======================================================================
 <ssa_name 0x7f091f19a708
    type <pointer_type 0x7f091f1ae000
        type <void_type 0x7f091f1a7f18 void VOID
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality
            pointer_to_this <pointer_type 0x7f091f1ae000>>
        public unsigned DI
        size <integer_cst 0x7f091f192bb8 constant 64>
        unit-size <integer_cst 0x7f091f192bd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality
        pointer_to_this <pointer_type 0x7f091f1b39d8>>
   
    def_stmt _5 = malloc (1);
    version:5
    ptr-info 0x7f091ecc91e0>
# .MEM_64 = VDEF <.MEM_63>
_5 = malloc (1);

 ================== trace ptable================== 
trace fucntion name:malloc 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr---malloc-----
this Reserved word function ------malloc-----
 
 Start check Pointer Collect  

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_65 = VDEF <.MEM_64>
MEM[(struct st *)p9_24 + 48B].f = _5;
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
MEM[(struct st *)p9_24 + 48B].f = _5;
test.c:73:17: warning: use location
   73 |         p9[3].f = malloc(1);
      |                 ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_65 = VDEF <.MEM_64>
MEM[(struct st *)p9_24 + 48B].f = _5;
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
MEM[(struct st *)p9_24 + 48B].f = _5;
test.c:73:17: warning: use location

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_66 = VDEF <.MEM_65>
free (p9_24);
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
free (p9_24);
test.c:74:9: warning: use location
   74 |         free(p9);
      |         ^
this stmt is child function---free-----

 ================== find ================== 
free (p9_24);
test.c:74:9: warning: use location
[40;32m    HAS FREE STMT count:1 name:free [0m

 ================== find ================== 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_64 = VDEF <.MEM_63>
_5 = malloc (1);
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
# .MEM_64 = VDEF <.MEM_63>
_5 = malloc (1);
_5 = malloc (1);
test.c:73:19: warning: use location
   73 |         p9[3].f = malloc(1);
      |                   ^
this stmt is child function---malloc-----

 ================== trace ================== 

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7f091f19a708
    type <pointer_type 0x7f091f1ae000
        type <void_type 0x7f091f1a7f18 void VOID
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality
            pointer_to_this <pointer_type 0x7f091f1ae000>>
        public unsigned DI
        size <integer_cst 0x7f091f192bb8 constant 64>
        unit-size <integer_cst 0x7f091f192bd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality
        pointer_to_this <pointer_type 0x7f091f1b39d8>>
   
    def_stmt _5 = malloc (1);
    version:5
    ptr-info 0x7f091ecc91e0>

 ================== Start Use after free Check ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:0 [0m
[40;31m  	free count:1 [0m

======================================================================

======================================================================
[40;32m   Maybe you don't have memory leak.... need more checks  [0m

======================================================================


dot graph START

======================================================================
 <ssa_name 0x7f091f19a990
    type <pointer_type 0x7f091ecbb348
        type <record_type 0x7f091ecbbf18 st TI
            size <integer_cst 0x7f091f192c00 constant 128>
            unit-size <integer_cst 0x7f091f192c18 constant 16>
            align:64 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7f091ecbbf18 fields <field_decl 0x7f091ecbe1c8 flag> context <translation_unit_decl 0x7f091f19d168 test.c>
            pointer_to_this <pointer_type 0x7f091ecbb348>>
        unsigned DI
        size <integer_cst 0x7f091f192bb8 constant 64>
        unit-size <integer_cst 0x7f091f192bd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
    var <var_decl 0x7f091fa3ab40 p>
    def_stmt p_29 = malloc (10);
    version:29
    ptr-info 0x7f091ecc9288>
# .MEM_67 = VDEF <.MEM_66>
p_29 = malloc (10);

 ================== trace ptable================== 
trace fucntion name:malloc 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr---malloc-----
this Reserved word function ------malloc-----
 
 Start check Pointer Collect  

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_82 = VDEF <.MEM_53>
foo (p_29);
bb index := 11
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 11 ,possiable got to succ := 18

======================================================================
foo (p_29);
test.c:145:25: warning: use location
  145 |                         foo(p);
      |                         ^
this stmt is child function---foo-----

 ================== trace ================== 
trace fucntion name:foo 
[40;44m =======trace_function_path foo  function_call count: 1 level :0========  [0m
# .MEM_4 = VDEF <.MEM_3(D)>
free (z_2(D));
[40;31m  find free stmt free same pointer [0m
# .MEM_4 = VDEF <.MEM_3(D)>
free (z_2(D));
test.c:29:9: warning: use location
   29 |         free(z);
      |         ^
[40;36m ======= node_fun:foo========= [0m
[40;36m ======= find relate stmt with p ========= [0m
[40;36m ======= relate stmt argument:p ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:free========= [0m
[40;46m =======add node_fun stack:free========= [0m

 ================== trace ================== 
trace fucntion free:1 
foo (p_29);
test.c:134:25: warning: use location
  134 |                         foo(p);
      |                         ^
this stmt is child function---foo-----

 ================== trace ================== 
trace fucntion name:foo 
[40;44m =======trace_function_path foo  function_call count: 1 level :0========  [0m
# .MEM_4 = VDEF <.MEM_3(D)>
free (z_2(D));
[40;31m  find free stmt free same pointer [0m
# .MEM_4 = VDEF <.MEM_3(D)>
free (z_2(D));
test.c:29:9: warning: use location
   29 |         free(z);
      |         ^
[40;36m ======= node_fun:foo========= [0m
[40;36m ======= find relate stmt with p ========= [0m
[40;36m ======= relate stmt argument:p ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:free========= [0m
[40;46m =======add node_fun stack:free========= [0m

 ================== trace ================== 
trace fucntion free:2 
foo (p_29);
test.c:130:33: warning: use location
  130 |                                 foo(p);
      |                                 ^
this stmt is child function---foo-----

 ================== trace ================== 
trace fucntion name:foo 
[40;44m =======trace_function_path foo  function_call count: 1 level :0========  [0m
# .MEM_4 = VDEF <.MEM_3(D)>
free (z_2(D));
[40;31m  find free stmt free same pointer [0m
# .MEM_4 = VDEF <.MEM_3(D)>
free (z_2(D));
test.c:29:9: warning: use location
   29 |         free(z);
      |         ^
[40;36m ======= node_fun:foo========= [0m
[40;36m ======= find relate stmt with p ========= [0m
[40;36m ======= relate stmt argument:p ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:free========= [0m
[40;46m =======add node_fun stack:free========= [0m

 ================== trace ================== 
trace fucntion free:3 
foo (p_29);
test.c:126:33: warning: use location
  126 |                                 foo(p);
      |                                 ^
this stmt is child function---foo-----

 ================== trace ================== 
trace fucntion name:foo 
[40;44m =======trace_function_path foo  function_call count: 1 level :0========  [0m
# .MEM_4 = VDEF <.MEM_3(D)>
free (z_2(D));
[40;31m  find free stmt free same pointer [0m
# .MEM_4 = VDEF <.MEM_3(D)>
free (z_2(D));
test.c:29:9: warning: use location
   29 |         free(z);
      |         ^
[40;36m ======= node_fun:foo========= [0m
[40;36m ======= find relate stmt with p ========= [0m
[40;36m ======= relate stmt argument:p ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:free========= [0m
[40;46m =======add node_fun stack:free========= [0m

 ================== trace ================== 
trace fucntion free:4 
foo (p_29);
test.c:123:25: warning: use location
  123 |                         foo(p);
      |                         ^
this stmt is child function---foo-----

 ================== trace ================== 
trace fucntion name:foo 
[40;44m =======trace_function_path foo  function_call count: 1 level :0========  [0m
# .MEM_4 = VDEF <.MEM_3(D)>
free (z_2(D));
[40;31m  find free stmt free same pointer [0m
# .MEM_4 = VDEF <.MEM_3(D)>
free (z_2(D));
test.c:29:9: warning: use location
   29 |         free(z);
      |         ^
[40;36m ======= node_fun:foo========= [0m
[40;36m ======= find relate stmt with p ========= [0m
[40;36m ======= relate stmt argument:p ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:free========= [0m
[40;46m =======add node_fun stack:free========= [0m

 ================== trace ================== 
trace fucntion free:5 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_72 = VDEF <.MEM_71>
foo (p_29);
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
foo (p_29);
test.c:80:9: warning: use location
   80 |         foo(p);
      |         ^
this stmt is child function---foo-----

 ================== trace ================== 
trace fucntion name:foo 
[40;44m =======trace_function_path foo  function_call count: 1 level :0========  [0m
# .MEM_4 = VDEF <.MEM_3(D)>
free (z_2(D));
[40;31m  find free stmt free same pointer [0m
# .MEM_4 = VDEF <.MEM_3(D)>
free (z_2(D));
test.c:29:9: warning: use location
   29 |         free(z);
      |         ^
[40;36m ======= node_fun:foo========= [0m
[40;36m ======= find relate stmt with p ========= [0m
[40;36m ======= relate stmt argument:p ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:free========= [0m
[40;46m =======add node_fun stack:free========= [0m

 ================== trace ================== 
trace fucntion free:6 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_71 = VDEF <.MEM_70>
MEM[(struct st *)p_29 + 32B].f = _7;
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
MEM[(struct st *)p_29 + 32B].f = _7;
test.c:79:16: warning: use location
   79 |         p[2].f = malloc(1);
      |                ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_71 = VDEF <.MEM_70>
MEM[(struct st *)p_29 + 32B].f = _7;
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
MEM[(struct st *)p_29 + 32B].f = _7;
test.c:79:16: warning: use location

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_69 = VDEF <.MEM_68>
MEM[(struct st *)p_29 + 48B].f = _6;
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
MEM[(struct st *)p_29 + 48B].f = _6;
test.c:76:16: warning: use location
   76 |         p[3].f = malloc(1);
      |                ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_69 = VDEF <.MEM_68>
MEM[(struct st *)p_29 + 48B].f = _6;
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
MEM[(struct st *)p_29 + 48B].f = _6;
test.c:76:16: warning: use location

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_67 = VDEF <.MEM_66>
p_29 = malloc (10);
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
# .MEM_67 = VDEF <.MEM_66>
p_29 = malloc (10);
p_29 = malloc (10);
test.c:75:24: warning: use location
   75 |         struct st *p = malloc(10);
      |                        ^
this stmt is child function---malloc-----

 ================== trace ================== 

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7f091f19a990
    type <pointer_type 0x7f091ecbb348
        type <record_type 0x7f091ecbbf18 st TI
            size <integer_cst 0x7f091f192c00 constant 128>
            unit-size <integer_cst 0x7f091f192c18 constant 16>
            align:64 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7f091ecbbf18 fields <field_decl 0x7f091ecbe1c8 flag> context <translation_unit_decl 0x7f091f19d168 test.c>
            pointer_to_this <pointer_type 0x7f091ecbb348>>
        unsigned DI
        size <integer_cst 0x7f091f192bb8 constant 64>
        unit-size <integer_cst 0x7f091f192bd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
    var <var_decl 0x7f091fa3ab40 p>
    def_stmt p_29 = malloc (10);
    version:29
    ptr-info 0x7f091ecc9288>

 ================== Start Use after free Check ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:0 [0m
[40;31m  	free count:6 [0m
[40;31m  	possible double free [rigorous]:6 [0m

======================================================================

======================================================================
[40;31m  	possible double free [rigorous]:6 [0m

======================================================================

dot graph START

======================================================================
 <ssa_name 0x7f091f19a750
    type <pointer_type 0x7f091f1ae000
        type <void_type 0x7f091f1a7f18 void VOID
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality
            pointer_to_this <pointer_type 0x7f091f1ae000>>
        public unsigned DI
        size <integer_cst 0x7f091f192bb8 constant 64>
        unit-size <integer_cst 0x7f091f192bd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality
        pointer_to_this <pointer_type 0x7f091f1b39d8>>
   
    def_stmt _6 = malloc (1);
    version:6
    ptr-info 0x7f091ecc91f8>
# .MEM_68 = VDEF <.MEM_67>
_6 = malloc (1);

 ================== trace ptable================== 
trace fucntion name:malloc 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr---malloc-----
this Reserved word function ------malloc-----
 
 Start check Pointer Collect  

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_69 = VDEF <.MEM_68>
MEM[(struct st *)p_29 + 48B].f = _6;
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
MEM[(struct st *)p_29 + 48B].f = _6;
test.c:76:16: warning: use location
   76 |         p[3].f = malloc(1);
      |                ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_69 = VDEF <.MEM_68>
MEM[(struct st *)p_29 + 48B].f = _6;
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
MEM[(struct st *)p_29 + 48B].f = _6;
test.c:76:16: warning: use location

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_82 = VDEF <.MEM_53>
foo (p_29);
bb index := 11
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 11 ,possiable got to succ := 18

======================================================================
foo (p_29);
test.c:145:25: warning: use location
  145 |                         foo(p);
      |                         ^
this stmt is child function---foo-----

 ================== trace ================== 
trace fucntion name:foo 
[40;44m =======trace_function_path foo  function_call count: 1 level :0========  [0m
# .MEM_4 = VDEF <.MEM_3(D)>
free (z_2(D));
[40;36m ======= node_fun:foo========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:free========= [0m
[40;46m =======add node_fun stack:free========= [0m

 ================== trace ================== 
trace fucntion free:0 
foo (p_29);
test.c:134:25: warning: use location
  134 |                         foo(p);
      |                         ^
this stmt is child function---foo-----

 ================== trace ================== 
trace fucntion name:foo 
[40;44m =======trace_function_path foo  function_call count: 1 level :0========  [0m
# .MEM_4 = VDEF <.MEM_3(D)>
free (z_2(D));
[40;36m ======= node_fun:foo========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:free========= [0m
[40;46m =======add node_fun stack:free========= [0m

 ================== trace ================== 
trace fucntion free:0 
foo (p_29);
test.c:130:33: warning: use location
  130 |                                 foo(p);
      |                                 ^
this stmt is child function---foo-----

 ================== trace ================== 
trace fucntion name:foo 
[40;44m =======trace_function_path foo  function_call count: 1 level :0========  [0m
# .MEM_4 = VDEF <.MEM_3(D)>
free (z_2(D));
[40;36m ======= node_fun:foo========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:free========= [0m
[40;46m =======add node_fun stack:free========= [0m

 ================== trace ================== 
trace fucntion free:0 
foo (p_29);
test.c:126:33: warning: use location
  126 |                                 foo(p);
      |                                 ^
this stmt is child function---foo-----

 ================== trace ================== 
trace fucntion name:foo 
[40;44m =======trace_function_path foo  function_call count: 1 level :0========  [0m
# .MEM_4 = VDEF <.MEM_3(D)>
free (z_2(D));
[40;36m ======= node_fun:foo========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:free========= [0m
[40;46m =======add node_fun stack:free========= [0m

 ================== trace ================== 
trace fucntion free:0 
foo (p_29);
test.c:123:25: warning: use location
  123 |                         foo(p);
      |                         ^
this stmt is child function---foo-----

 ================== trace ================== 
trace fucntion name:foo 
[40;44m =======trace_function_path foo  function_call count: 1 level :0========  [0m
# .MEM_4 = VDEF <.MEM_3(D)>
free (z_2(D));
[40;36m ======= node_fun:foo========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:free========= [0m
[40;46m =======add node_fun stack:free========= [0m

 ================== trace ================== 
trace fucntion free:0 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_72 = VDEF <.MEM_71>
foo (p_29);
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
foo (p_29);
test.c:80:9: warning: use location
   80 |         foo(p);
      |         ^
this stmt is child function---foo-----

 ================== trace ================== 
trace fucntion name:foo 
[40;44m =======trace_function_path foo  function_call count: 1 level :0========  [0m
# .MEM_4 = VDEF <.MEM_3(D)>
free (z_2(D));
[40;36m ======= node_fun:foo========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:free========= [0m
[40;46m =======add node_fun stack:free========= [0m

 ================== trace ================== 
trace fucntion free:0 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_71 = VDEF <.MEM_70>
MEM[(struct st *)p_29 + 32B].f = _7;
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
MEM[(struct st *)p_29 + 32B].f = _7;
test.c:79:16: warning: use location
   79 |         p[2].f = malloc(1);
      |                ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_71 = VDEF <.MEM_70>
MEM[(struct st *)p_29 + 32B].f = _7;
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
MEM[(struct st *)p_29 + 32B].f = _7;
test.c:79:16: warning: use location

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_68 = VDEF <.MEM_67>
_6 = malloc (1);
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
# .MEM_68 = VDEF <.MEM_67>
_6 = malloc (1);
_6 = malloc (1);
test.c:76:18: warning: use location
   76 |         p[3].f = malloc(1);
      |                  ^
this stmt is child function---malloc-----

 ================== trace ================== 

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7f091f19a750
    type <pointer_type 0x7f091f1ae000
        type <void_type 0x7f091f1a7f18 void VOID
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality
            pointer_to_this <pointer_type 0x7f091f1ae000>>
        public unsigned DI
        size <integer_cst 0x7f091f192bb8 constant 64>
        unit-size <integer_cst 0x7f091f192bd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality
        pointer_to_this <pointer_type 0x7f091f1b39d8>>
   
    def_stmt _6 = malloc (1);
    version:6
    ptr-info 0x7f091ecc91f8>

 ================== Start Use after free Check ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:0 [0m
[40;31m  	free count:0 [0m

======================================================================

======================================================================
[40;31m    no free stmt possible memory leak [0m

======================================================================

dot graph START

======================================================================
 <ssa_name 0x7f091f19a798
    type <pointer_type 0x7f091f1ae000
        type <void_type 0x7f091f1a7f18 void VOID
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality
            pointer_to_this <pointer_type 0x7f091f1ae000>>
        public unsigned DI
        size <integer_cst 0x7f091f192bb8 constant 64>
        unit-size <integer_cst 0x7f091f192bd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality
        pointer_to_this <pointer_type 0x7f091f1b39d8>>
   
    def_stmt _7 = malloc (1);
    version:7
    ptr-info 0x7f091ecc9210>
# .MEM_70 = VDEF <.MEM_69>
_7 = malloc (1);

 ================== trace ptable================== 
trace fucntion name:malloc 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr---malloc-----
this Reserved word function ------malloc-----
 
 Start check Pointer Collect  

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_71 = VDEF <.MEM_70>
MEM[(struct st *)p_29 + 32B].f = _7;
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
MEM[(struct st *)p_29 + 32B].f = _7;
test.c:79:16: warning: use location
   79 |         p[2].f = malloc(1);
      |                ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_71 = VDEF <.MEM_70>
MEM[(struct st *)p_29 + 32B].f = _7;
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
MEM[(struct st *)p_29 + 32B].f = _7;
test.c:79:16: warning: use location

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_82 = VDEF <.MEM_53>
foo (p_29);
bb index := 11
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 11 ,possiable got to succ := 18

======================================================================
foo (p_29);
test.c:145:25: warning: use location
  145 |                         foo(p);
      |                         ^
this stmt is child function---foo-----

 ================== trace ================== 
trace fucntion name:foo 
[40;44m =======trace_function_path foo  function_call count: 1 level :0========  [0m
# .MEM_4 = VDEF <.MEM_3(D)>
free (z_2(D));
[40;36m ======= node_fun:foo========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:free========= [0m
[40;46m =======add node_fun stack:free========= [0m

 ================== trace ================== 
trace fucntion free:0 
foo (p_29);
test.c:134:25: warning: use location
  134 |                         foo(p);
      |                         ^
this stmt is child function---foo-----

 ================== trace ================== 
trace fucntion name:foo 
[40;44m =======trace_function_path foo  function_call count: 1 level :0========  [0m
# .MEM_4 = VDEF <.MEM_3(D)>
free (z_2(D));
[40;36m ======= node_fun:foo========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:free========= [0m
[40;46m =======add node_fun stack:free========= [0m

 ================== trace ================== 
trace fucntion free:0 
foo (p_29);
test.c:130:33: warning: use location
  130 |                                 foo(p);
      |                                 ^
this stmt is child function---foo-----

 ================== trace ================== 
trace fucntion name:foo 
[40;44m =======trace_function_path foo  function_call count: 1 level :0========  [0m
# .MEM_4 = VDEF <.MEM_3(D)>
free (z_2(D));
[40;36m ======= node_fun:foo========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:free========= [0m
[40;46m =======add node_fun stack:free========= [0m

 ================== trace ================== 
trace fucntion free:0 
foo (p_29);
test.c:126:33: warning: use location
  126 |                                 foo(p);
      |                                 ^
this stmt is child function---foo-----

 ================== trace ================== 
trace fucntion name:foo 
[40;44m =======trace_function_path foo  function_call count: 1 level :0========  [0m
# .MEM_4 = VDEF <.MEM_3(D)>
free (z_2(D));
[40;36m ======= node_fun:foo========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:free========= [0m
[40;46m =======add node_fun stack:free========= [0m

 ================== trace ================== 
trace fucntion free:0 
foo (p_29);
test.c:123:25: warning: use location
  123 |                         foo(p);
      |                         ^
this stmt is child function---foo-----

 ================== trace ================== 
trace fucntion name:foo 
[40;44m =======trace_function_path foo  function_call count: 1 level :0========  [0m
# .MEM_4 = VDEF <.MEM_3(D)>
free (z_2(D));
[40;36m ======= node_fun:foo========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:free========= [0m
[40;46m =======add node_fun stack:free========= [0m

 ================== trace ================== 
trace fucntion free:0 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_72 = VDEF <.MEM_71>
foo (p_29);
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
foo (p_29);
test.c:80:9: warning: use location
   80 |         foo(p);
      |         ^
this stmt is child function---foo-----

 ================== trace ================== 
trace fucntion name:foo 
[40;44m =======trace_function_path foo  function_call count: 1 level :0========  [0m
# .MEM_4 = VDEF <.MEM_3(D)>
free (z_2(D));
[40;36m ======= node_fun:foo========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:free========= [0m
[40;46m =======add node_fun stack:free========= [0m

 ================== trace ================== 
trace fucntion free:0 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_69 = VDEF <.MEM_68>
MEM[(struct st *)p_29 + 48B].f = _6;
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
MEM[(struct st *)p_29 + 48B].f = _6;
test.c:76:16: warning: use location
   76 |         p[3].f = malloc(1);
      |                ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_69 = VDEF <.MEM_68>
MEM[(struct st *)p_29 + 48B].f = _6;
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
MEM[(struct st *)p_29 + 48B].f = _6;
test.c:76:16: warning: use location

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_70 = VDEF <.MEM_69>
_7 = malloc (1);
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
# .MEM_70 = VDEF <.MEM_69>
_7 = malloc (1);
_7 = malloc (1);
test.c:79:18: warning: use location
   79 |         p[2].f = malloc(1);
      |                  ^
this stmt is child function---malloc-----

 ================== trace ================== 

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7f091f19a798
    type <pointer_type 0x7f091f1ae000
        type <void_type 0x7f091f1a7f18 void VOID
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality
            pointer_to_this <pointer_type 0x7f091f1ae000>>
        public unsigned DI
        size <integer_cst 0x7f091f192bb8 constant 64>
        unit-size <integer_cst 0x7f091f192bd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality
        pointer_to_this <pointer_type 0x7f091f1b39d8>>
   
    def_stmt _7 = malloc (1);
    version:7
    ptr-info 0x7f091ecc9210>

 ================== Start Use after free Check ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:0 [0m
[40;31m  	free count:0 [0m

======================================================================

======================================================================
[40;31m    no free stmt possible memory leak [0m

======================================================================

dot graph START

======================================================================
 <ssa_name 0x7f091f19a798
    type <pointer_type 0x7f091f1ae000
        type <void_type 0x7f091f1a7f18 void VOID
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality
            pointer_to_this <pointer_type 0x7f091f1ae000>>
        public unsigned DI
        size <integer_cst 0x7f091f192bb8 constant 64>
        unit-size <integer_cst 0x7f091f192bd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality
        pointer_to_this <pointer_type 0x7f091f1b39d8>>
   
    def_stmt _7 = malloc (1);
    version:7
    ptr-info 0x7f091ecc9210>
# .MEM_70 = VDEF <.MEM_69>
_7 = malloc (1);

 ================== trace ptable================== 
trace fucntion name:malloc 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr---malloc-----
this Reserved word function ------malloc-----
 
 Start check Pointer Collect  

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_71 = VDEF <.MEM_70>
MEM[(struct st *)p_29 + 32B].f = _7;
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
MEM[(struct st *)p_29 + 32B].f = _7;
test.c:79:16: warning: use location
   79 |         p[2].f = malloc(1);
      |                ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_71 = VDEF <.MEM_70>
MEM[(struct st *)p_29 + 32B].f = _7;
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
MEM[(struct st *)p_29 + 32B].f = _7;
test.c:79:16: warning: use location

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_82 = VDEF <.MEM_53>
foo (p_29);
bb index := 11
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 11 ,possiable got to succ := 18

======================================================================
foo (p_29);
test.c:145:25: warning: use location
  145 |                         foo(p);
      |                         ^
this stmt is child function---foo-----

 ================== trace ================== 
trace fucntion name:foo 
[40;44m =======trace_function_path foo  function_call count: 1 level :0========  [0m
# .MEM_4 = VDEF <.MEM_3(D)>
free (z_2(D));
[40;36m ======= node_fun:foo========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:free========= [0m
[40;46m =======add node_fun stack:free========= [0m

 ================== trace ================== 
trace fucntion free:0 
foo (p_29);
test.c:134:25: warning: use location
  134 |                         foo(p);
      |                         ^
this stmt is child function---foo-----

 ================== trace ================== 
trace fucntion name:foo 
[40;44m =======trace_function_path foo  function_call count: 1 level :0========  [0m
# .MEM_4 = VDEF <.MEM_3(D)>
free (z_2(D));
[40;36m ======= node_fun:foo========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:free========= [0m
[40;46m =======add node_fun stack:free========= [0m

 ================== trace ================== 
trace fucntion free:0 
foo (p_29);
test.c:130:33: warning: use location
  130 |                                 foo(p);
      |                                 ^
this stmt is child function---foo-----

 ================== trace ================== 
trace fucntion name:foo 
[40;44m =======trace_function_path foo  function_call count: 1 level :0========  [0m
# .MEM_4 = VDEF <.MEM_3(D)>
free (z_2(D));
[40;36m ======= node_fun:foo========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:free========= [0m
[40;46m =======add node_fun stack:free========= [0m

 ================== trace ================== 
trace fucntion free:0 
foo (p_29);
test.c:126:33: warning: use location
  126 |                                 foo(p);
      |                                 ^
this stmt is child function---foo-----

 ================== trace ================== 
trace fucntion name:foo 
[40;44m =======trace_function_path foo  function_call count: 1 level :0========  [0m
# .MEM_4 = VDEF <.MEM_3(D)>
free (z_2(D));
[40;36m ======= node_fun:foo========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:free========= [0m
[40;46m =======add node_fun stack:free========= [0m

 ================== trace ================== 
trace fucntion free:0 
foo (p_29);
test.c:123:25: warning: use location
  123 |                         foo(p);
      |                         ^
this stmt is child function---foo-----

 ================== trace ================== 
trace fucntion name:foo 
[40;44m =======trace_function_path foo  function_call count: 1 level :0========  [0m
# .MEM_4 = VDEF <.MEM_3(D)>
free (z_2(D));
[40;36m ======= node_fun:foo========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:free========= [0m
[40;46m =======add node_fun stack:free========= [0m

 ================== trace ================== 
trace fucntion free:0 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_72 = VDEF <.MEM_71>
foo (p_29);
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
foo (p_29);
test.c:80:9: warning: use location
   80 |         foo(p);
      |         ^
this stmt is child function---foo-----

 ================== trace ================== 
trace fucntion name:foo 
[40;44m =======trace_function_path foo  function_call count: 1 level :0========  [0m
# .MEM_4 = VDEF <.MEM_3(D)>
free (z_2(D));
[40;36m ======= node_fun:foo========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:free========= [0m
[40;46m =======add node_fun stack:free========= [0m

 ================== trace ================== 
trace fucntion free:0 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_69 = VDEF <.MEM_68>
MEM[(struct st *)p_29 + 48B].f = _6;
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
MEM[(struct st *)p_29 + 48B].f = _6;
test.c:76:16: warning: use location
   76 |         p[3].f = malloc(1);
      |                ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_69 = VDEF <.MEM_68>
MEM[(struct st *)p_29 + 48B].f = _6;
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
MEM[(struct st *)p_29 + 48B].f = _6;
test.c:76:16: warning: use location

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_70 = VDEF <.MEM_69>
_7 = malloc (1);
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
# .MEM_70 = VDEF <.MEM_69>
_7 = malloc (1);
_7 = malloc (1);
test.c:79:18: warning: use location
   79 |         p[2].f = malloc(1);
      |                  ^
this stmt is child function---malloc-----

 ================== trace ================== 

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7f091f19a798
    type <pointer_type 0x7f091f1ae000
        type <void_type 0x7f091f1a7f18 void VOID
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality
            pointer_to_this <pointer_type 0x7f091f1ae000>>
        public unsigned DI
        size <integer_cst 0x7f091f192bb8 constant 64>
        unit-size <integer_cst 0x7f091f192bd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality
        pointer_to_this <pointer_type 0x7f091f1b39d8>>
   
    def_stmt _7 = malloc (1);
    version:7
    ptr-info 0x7f091ecc9210>

 ================== Start Use after free Check ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:0 [0m
[40;31m  	free count:0 [0m

======================================================================

======================================================================
[40;31m    no free stmt possible memory leak [0m

======================================================================

dot graph START

======================================================================
 <ssa_name 0x7f091f19a7e0
    type <integer_type 0x7f091f1a75e8 int public SI
        size <integer_cst 0x7f091f192df8 constant 32>
        unit-size <integer_cst 0x7f091f192e10 constant 4>
        align:32 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7f091f1a75e8 precision:32 min <integer_cst 0x7f091f192db0 -2147483648> max <integer_cst 0x7f091f192dc8 2147483647>
        pointer_to_this <pointer_type 0x7f091f1ae9d8>>
   
    def_stmt _8 = foo9 (p5_35(D));
    version:8>
# .MEM_73 = VDEF <.MEM_72>
_8 = foo9 (p5_35(D));

 ================== trace ptable================== 
trace fucntion name:foo9 
[40;44m =======trace_function_path foo9  function_call count: 1 level :888========  [0m
# .MEM_4 = VDEF <.MEM_3(D)>
free (z_2(D));
[40;31m  find free stmt free same pointer [0m
# .MEM_4 = VDEF <.MEM_3(D)>
free (z_2(D));
test.c:33:9: warning: use location
   33 |         free(z);
      |         ^
[40;42m =======pre add _ fucntion:free========= [0m
[40;46m =======add node_fun stack:free========= [0m

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr---foo9-----
this other function ------foo9-----
 
 Start check Pointer Collect  

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_73 = VDEF <.MEM_72>
_8 = foo9 (p5_35(D));
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
# .MEM_73 = VDEF <.MEM_72>
_8 = foo9 (p5_35(D));
_8 = foo9 (p5_35(D));
test.c:99:14: warning: use location
   99 |         p5 = foo9(p5);
      |              ^
this stmt is child function---foo9-----

 ================== trace ================== 
trace fucntion name:foo9 
[40;44m =======trace_function_path foo9  function_call count: 1 level :0========  [0m
# .MEM_4 = VDEF <.MEM_3(D)>
free (z_2(D));
[40;31m  find free stmt free same pointer [0m
# .MEM_4 = VDEF <.MEM_3(D)>
free (z_2(D));
test.c:33:9: warning: use location
   33 |         free(z);
      |         ^
[40;42m =======pre add _ fucntion:free========= [0m
[40;46m =======add node_fun stack:free========= [0m

 ================== trace ================== 
trace fucntion free:1 

======================================================================
[40;31m    branch possiable have return or exit  [0m
_9 = (long int) _8;
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
_9 = (long int) _8;
test.c:99:14: warning: use location
   99 |         p5 = foo9(p5);
      |              ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
p5_37 = (int *) _9;
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
p5_37 = (int *) _9;
test.c:99:12: warning: use location
   99 |         p5 = foo9(p5);
      |            ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_83 = VDEF <.MEM_54>
foo9 (p5_37);
bb index := 17
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 17 ,possiable got to succ := 18

======================================================================

 Expand conflict 
 The same function may have multiple branches :foo9
# .MEM_73 = VDEF <.MEM_72>
_8 = foo9 (p5_35(D));
test.c:99:14: warning: use location
   99 |         p5 = foo9(p5);
      |              ^
# .MEM_83 = VDEF <.MEM_54>
foo9 (p5_37);
test.c:157:25: warning: use location
  157 |                         foo9(p5);
      |                         ^
=======================Path Constaint===========================

succs:= 16
if (test_38(D) > test2_40(D))
test.c:155:20: warning: use location
  155 |                 if (test > test2)
      |                    ^
	relate logic:= 1
succs:= 14
if (test_38(D) >= test2_40(D))
test.c:151:17: warning: use location
  151 |         else if (test >= test2)
      |                 ^
	relate logic:= 0
succs:= 12
if (test_38(D) == test2_40(D))
test.c:149:12: warning: use location
  149 |         if (test == test2)
      |            ^
	relate logic:= 0
succs:= 10
if (test3_49(D) != 0)
test.c:143:20: warning: use location
  143 |                 if (test3)
      |                    ^
	relate logic:= 0
succs:= 2
if (test_38(D) != 0)
test.c:114:12: warning: use location
  114 |         if (test)
      |            ^
	relate logic:= 0
=======================Path Constaint===========================


 Expand conflict 
 The same function may have multiple branches :foo9
# .MEM_73 = VDEF <.MEM_72>
_8 = foo9 (p5_35(D));
test.c:99:14: warning: use location
   99 |         p5 = foo9(p5);
      |              ^
# .MEM_85 = VDEF <.MEM_54>
foo9 (p5_37);
test.c:152:17: warning: use location
  152 |                 foo9(p5);
      |                 ^
=======================Path Constaint===========================

succs:= 14
if (test_38(D) >= test2_40(D))
test.c:151:17: warning: use location
  151 |         else if (test >= test2)
      |                 ^
	relate logic:= 1
succs:= 12
if (test_38(D) == test2_40(D))
test.c:149:12: warning: use location
  149 |         if (test == test2)
      |            ^
	relate logic:= 0
succs:= 10
if (test3_49(D) != 0)
test.c:143:20: warning: use location
  143 |                 if (test3)
      |                    ^
	relate logic:= 0
succs:= 2
if (test_38(D) != 0)
test.c:114:12: warning: use location
  114 |         if (test)
      |            ^
	relate logic:= 0
=======================Path Constaint===========================


 Expand conflict 
 The same function may have multiple branches :foo9
# .MEM_73 = VDEF <.MEM_72>
_8 = foo9 (p5_35(D));
test.c:99:14: warning: use location
   99 |         p5 = foo9(p5);
      |              ^
# .MEM_86 = VDEF <.MEM_54>
foo9 (p5_37);
test.c:150:17: warning: use location
  150 |                 foo9(p5);
      |                 ^
=======================Path Constaint===========================

succs:= 12
if (test_38(D) == test2_40(D))
test.c:149:12: warning: use location
  149 |         if (test == test2)
      |            ^
	relate logic:= 1
succs:= 10
if (test3_49(D) != 0)
test.c:143:20: warning: use location
  143 |                 if (test3)
      |                    ^
	relate logic:= 0
succs:= 2
if (test_38(D) != 0)
test.c:114:12: warning: use location
  114 |         if (test)
      |            ^
	relate logic:= 0
=======================Path Constaint===========================


 Expand conflict 
 The same function may have multiple branches :foo9
# .MEM_73 = VDEF <.MEM_72>
_8 = foo9 (p5_35(D));
test.c:99:14: warning: use location
   99 |         p5 = foo9(p5);
      |              ^
# .MEM_76 = VDEF <.MEM_75>
foo9 (p5_37);
test.c:140:33: warning: use location
  140 |                                 foo9(p5);
      |                                 ^
=======================Path Constaint===========================

=succs:= 7
if (test_38(D) < test2_40(D))
test.c:135:28: warning: use location
  135 |                         if (test < test2)
      |                            ^
	relate logic:= 0
=succs:= 3
if (test_38(D) > test2_40(D))
test.c:121:20: warning: use location
  121 |                 if (test > test2)
      |                    ^
	relate logic:= 0
=succs:= 2
if (test_38(D) != 0)
test.c:114:12: warning: use location
  114 |         if (test)
      |            ^
	relate logic:= 0
=======================Path Constaint===========================


 Expand conflict 
 The same function may have multiple branches :foo9
# .MEM_73 = VDEF <.MEM_72>
_8 = foo9 (p5_35(D));
test.c:99:14: warning: use location
   99 |         p5 = foo9(p5);
      |              ^
# .MEM_81 = VDEF <.MEM_80>
foo9 (p5_37);
test.c:127:33: warning: use location
  127 |                                 foo9(p5);
      |                                 ^
=======================Path Constaint===========================

succs:= 4
if (test_38(D) < test2_40(D))
test.c:124:28: warning: use location
  124 |                         if (test < test2)
      |                            ^
	relate logic:= 1
succs:= 3
if (test_38(D) > test2_40(D))
test.c:121:20: warning: use location
  121 |                 if (test > test2)
      |                    ^
	relate logic:= 1
succs:= 2
if (test_38(D) != 0)
test.c:114:12: warning: use location
  114 |         if (test)
      |            ^
	relate logic:= 1
=======================Path Constaint===========================


======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_74 = VDEF <.MEM_73>
foo9 (p5_37);
bb index := 3
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 3 ,possiable got to succ := 18

======================================================================

 Expand conflict 
 The same function may have multiple branches :foo9
# .MEM_73 = VDEF <.MEM_72>
_8 = foo9 (p5_35(D));
test.c:99:14: warning: use location
   99 |         p5 = foo9(p5);
      |              ^
# .MEM_74 = VDEF <.MEM_73>
foo9 (p5_37);
test.c:116:17: warning: use location
  116 |                 foo9(p5);
      |                 ^
=======================Path Constaint===========================

succs:= 2
if (test_38(D) != 0)
test.c:114:12: warning: use location
  114 |         if (test)
      |            ^
	relate logic:= 1
=======================Path Constaint===========================


 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7f091f19a7e0
    type <integer_type 0x7f091f1a75e8 int public SI
        size <integer_cst 0x7f091f192df8 constant 32>
        unit-size <integer_cst 0x7f091f192e10 constant 4>
        align:32 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7f091f1a75e8 precision:32 min <integer_cst 0x7f091f192db0 -2147483648> max <integer_cst 0x7f091f192dc8 2147483647>
        pointer_to_this <pointer_type 0x7f091f1ae9d8>>
   
    def_stmt _8 = foo9 (p5_35(D));
    version:8>
[40;35m <Looserules> find realloc stmt free same pointer [0m
*/If realloc() fails, the initial memory block will not be freed() */# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: use location
   57 |         p6 = realloc(p6, 100);
      |              ^
[40;35m <Looserules> find realloc stmt free same pointer [0m
*/If realloc() fails, the initial memory block will not be freed() */# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: use location
   58 |         p7 = realloc(p6, 100);
      |              ^
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_66 = VDEF <.MEM_65>
free (p9_24);
test.c:74:9: warning: use location
   74 |         free(p9);
      |         ^

 ================== Start Use after free Check ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: Use after free error!: free location 
   57 |         p6 = realloc(p6, 100);
      |              ^
# .MEM_73 = VDEF <.MEM_72>
_8 = foo9 (p5_35(D));
test.c:99:14: warning: use location
   99 |         p5 = foo9(p5);
      |              ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: Use after free error!: free location 
   58 |         p7 = realloc(p6, 100);
      |              ^
# .MEM_73 = VDEF <.MEM_72>
_8 = foo9 (p5_35(D));
test.c:99:14: warning: use location
   99 |         p5 = foo9(p5);
      |              ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_66 = VDEF <.MEM_65>
free (p9_24);
test.c:74:9: warning: Use after free error!: free location 
   74 |         free(p9);
      |         ^
# .MEM_73 = VDEF <.MEM_72>
_8 = foo9 (p5_35(D));
test.c:99:14: warning: use location
   99 |         p5 = foo9(p5);
      |              ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
# .MEM_73 = VDEF <.MEM_72>
_8 = foo9 (p5_35(D));
test.c:99:14: warning: Use after free error!: free location 
_9 = (long int) _8;
test.c:99:14: warning: use location

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: Use after free error!: free location 
   57 |         p6 = realloc(p6, 100);
      |              ^
_9 = (long int) _8;
test.c:99:14: warning: use location
   99 |         p5 = foo9(p5);
      |              ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: Use after free error!: free location 
   58 |         p7 = realloc(p6, 100);
      |              ^
_9 = (long int) _8;
test.c:99:14: warning: use location
   99 |         p5 = foo9(p5);
      |              ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_66 = VDEF <.MEM_65>
free (p9_24);
test.c:74:9: warning: Use after free error!: free location 
   74 |         free(p9);
      |         ^
_9 = (long int) _8;
test.c:99:14: warning: use location
   99 |         p5 = foo9(p5);
      |              ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
# .MEM_73 = VDEF <.MEM_72>
_8 = foo9 (p5_35(D));
test.c:99:14: warning: Use after free error!: free location 
p5_37 = (int *) _9;
test.c:99:12: warning: use location
   99 |         p5 = foo9(p5);
      |            ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: Use after free error!: free location 
   57 |         p6 = realloc(p6, 100);
      |              ^
p5_37 = (int *) _9;
test.c:99:12: warning: use location
   99 |         p5 = foo9(p5);
      |            ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: Use after free error!: free location 
   58 |         p7 = realloc(p6, 100);
      |              ^
p5_37 = (int *) _9;
test.c:99:12: warning: use location
   99 |         p5 = foo9(p5);
      |            ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_66 = VDEF <.MEM_65>
free (p9_24);
test.c:74:9: warning: Use after free error!: free location 
   74 |         free(p9);
      |         ^
p5_37 = (int *) _9;
test.c:99:12: warning: use location
   99 |         p5 = foo9(p5);
      |            ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: Use after free error!: free location 
   57 |         p6 = realloc(p6, 100);
      |              ^
# .MEM_83 = VDEF <.MEM_54>
foo9 (p5_37);
test.c:157:25: warning: use location
  157 |                         foo9(p5);
      |                         ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: Use after free error!: free location 
   58 |         p7 = realloc(p6, 100);
      |              ^
# .MEM_83 = VDEF <.MEM_54>
foo9 (p5_37);
test.c:157:25: warning: use location
  157 |                         foo9(p5);
      |                         ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_66 = VDEF <.MEM_65>
free (p9_24);
test.c:74:9: warning: Use after free error!: free location 
   74 |         free(p9);
      |         ^
# .MEM_83 = VDEF <.MEM_54>
foo9 (p5_37);
test.c:157:25: warning: use location
  157 |                         foo9(p5);
      |                         ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: Use after free error!: free location 
   57 |         p6 = realloc(p6, 100);
      |              ^
# .MEM_85 = VDEF <.MEM_54>
foo9 (p5_37);
test.c:152:17: warning: use location
  152 |                 foo9(p5);
      |                 ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: Use after free error!: free location 
   58 |         p7 = realloc(p6, 100);
      |              ^
# .MEM_85 = VDEF <.MEM_54>
foo9 (p5_37);
test.c:152:17: warning: use location
  152 |                 foo9(p5);
      |                 ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_66 = VDEF <.MEM_65>
free (p9_24);
test.c:74:9: warning: Use after free error!: free location 
   74 |         free(p9);
      |         ^
# .MEM_85 = VDEF <.MEM_54>
foo9 (p5_37);
test.c:152:17: warning: use location
  152 |                 foo9(p5);
      |                 ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: Use after free error!: free location 
   57 |         p6 = realloc(p6, 100);
      |              ^
# .MEM_86 = VDEF <.MEM_54>
foo9 (p5_37);
test.c:150:17: warning: use location
  150 |                 foo9(p5);
      |                 ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: Use after free error!: free location 
   58 |         p7 = realloc(p6, 100);
      |              ^
# .MEM_86 = VDEF <.MEM_54>
foo9 (p5_37);
test.c:150:17: warning: use location
  150 |                 foo9(p5);
      |                 ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_66 = VDEF <.MEM_65>
free (p9_24);
test.c:74:9: warning: Use after free error!: free location 
   74 |         free(p9);
      |         ^
# .MEM_86 = VDEF <.MEM_54>
foo9 (p5_37);
test.c:150:17: warning: use location
  150 |                 foo9(p5);
      |                 ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: Use after free error!: free location 
   57 |         p6 = realloc(p6, 100);
      |              ^
# .MEM_76 = VDEF <.MEM_75>
foo9 (p5_37);
test.c:140:33: warning: use location
  140 |                                 foo9(p5);
      |                                 ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: Use after free error!: free location 
   58 |         p7 = realloc(p6, 100);
      |              ^
# .MEM_76 = VDEF <.MEM_75>
foo9 (p5_37);
test.c:140:33: warning: use location
  140 |                                 foo9(p5);
      |                                 ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_66 = VDEF <.MEM_65>
free (p9_24);
test.c:74:9: warning: Use after free error!: free location 
   74 |         free(p9);
      |         ^
# .MEM_76 = VDEF <.MEM_75>
foo9 (p5_37);
test.c:140:33: warning: use location
  140 |                                 foo9(p5);
      |                                 ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: Use after free error!: free location 
   57 |         p6 = realloc(p6, 100);
      |              ^
# .MEM_81 = VDEF <.MEM_80>
foo9 (p5_37);
test.c:127:33: warning: use location
  127 |                                 foo9(p5);
      |                                 ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: Use after free error!: free location 
   58 |         p7 = realloc(p6, 100);
      |              ^
# .MEM_81 = VDEF <.MEM_80>
foo9 (p5_37);
test.c:127:33: warning: use location
  127 |                                 foo9(p5);
      |                                 ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_66 = VDEF <.MEM_65>
free (p9_24);
test.c:74:9: warning: Use after free error!: free location 
   74 |         free(p9);
      |         ^
# .MEM_81 = VDEF <.MEM_80>
foo9 (p5_37);
test.c:127:33: warning: use location
  127 |                                 foo9(p5);
      |                                 ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: Use after free error!: free location 
   57 |         p6 = realloc(p6, 100);
      |              ^
# .MEM_74 = VDEF <.MEM_73>
foo9 (p5_37);
test.c:116:17: warning: use location
  116 |                 foo9(p5);
      |                 ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: Use after free error!: free location 
   58 |         p7 = realloc(p6, 100);
      |              ^
# .MEM_74 = VDEF <.MEM_73>
foo9 (p5_37);
test.c:116:17: warning: use location
  116 |                 foo9(p5);
      |                 ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_66 = VDEF <.MEM_65>
free (p9_24);
test.c:74:9: warning: Use after free error!: free location 
   74 |         free(p9);
      |         ^
# .MEM_74 = VDEF <.MEM_73>
foo9 (p5_37);
test.c:116:17: warning: use location
  116 |                 foo9(p5);
      |                 ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:3 [0m
[40;31m  	free count:1 [0m
[40;31m  	possible double free [Looserules]:3 [0m

======================================================================

======================================================================
[40;31m 	this stmt need double check [0m

======================================================================

dot graph START

======================================================================
 <ssa_name 0x7f091f19a9d8
    type <pointer_type 0x7f091f1ae9d8
        type <integer_type 0x7f091f1a75e8 int public SI
            size <integer_cst 0x7f091f192df8 constant 32>
            unit-size <integer_cst 0x7f091f192e10 constant 4>
            align:32 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7f091f1a75e8 precision:32 min <integer_cst 0x7f091f192db0 -2147483648> max <integer_cst 0x7f091f192dc8 2147483647>
            pointer_to_this <pointer_type 0x7f091f1ae9d8>>
        public unsigned DI
        size <integer_cst 0x7f091f192bb8 constant 64>
        unit-size <integer_cst 0x7f091f192bd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
    var <var_decl 0x7f091fa3af30 p5>
    def_stmt GIMPLE_NOP
    version:35>
GIMPLE_NOP

 ================== trace ptable================== 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr--------
this other function -----------
 
 Start check Pointer Collect  

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_73 = VDEF <.MEM_72>
_8 = foo9 (p5_35(D));
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
# .MEM_73 = VDEF <.MEM_72>
_8 = foo9 (p5_35(D));
_8 = foo9 (p5_35(D));
test.c:99:14: warning: use location
   99 |         p5 = foo9(p5);
      |              ^
this stmt is child function---foo9-----

 ================== trace ================== 
trace fucntion name:foo9 
[40;44m =======trace_function_path foo9  function_call count: 1 level :0========  [0m
# .MEM_4 = VDEF <.MEM_3(D)>
free (z_2(D));
[40;31m  find free stmt free same pointer [0m
# .MEM_4 = VDEF <.MEM_3(D)>
free (z_2(D));
test.c:33:9: warning: use location
   33 |         free(z);
      |         ^
[40;42m =======pre add _ fucntion:free========= [0m
[40;46m =======add node_fun stack:free========= [0m

 ================== trace ================== 
trace fucntion free:1 

======================================================================
[40;31m    branch possiable have return or exit  [0m
_9 = (long int) _8;
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
_9 = (long int) _8;
test.c:99:14: warning: use location
   99 |         p5 = foo9(p5);
      |              ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
p5_37 = (int *) _9;
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
p5_37 = (int *) _9;
test.c:99:12: warning: use location
   99 |         p5 = foo9(p5);
      |            ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_83 = VDEF <.MEM_54>
foo9 (p5_37);
bb index := 17
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 17 ,possiable got to succ := 18

======================================================================

 Expand conflict 
 The same function may have multiple branches :foo9
# .MEM_73 = VDEF <.MEM_72>
_8 = foo9 (p5_35(D));
test.c:99:14: warning: use location
   99 |         p5 = foo9(p5);
      |              ^
# .MEM_83 = VDEF <.MEM_54>
foo9 (p5_37);
test.c:157:25: warning: use location
  157 |                         foo9(p5);
      |                         ^
=======================Path Constaint===========================

succs:= 16
if (test_38(D) > test2_40(D))
test.c:155:20: warning: use location
  155 |                 if (test > test2)
      |                    ^
	relate logic:= 1
succs:= 14
if (test_38(D) >= test2_40(D))
test.c:151:17: warning: use location
  151 |         else if (test >= test2)
      |                 ^
	relate logic:= 0
succs:= 12
if (test_38(D) == test2_40(D))
test.c:149:12: warning: use location
  149 |         if (test == test2)
      |            ^
	relate logic:= 0
succs:= 10
if (test3_49(D) != 0)
test.c:143:20: warning: use location
  143 |                 if (test3)
      |                    ^
	relate logic:= 0
succs:= 2
if (test_38(D) != 0)
test.c:114:12: warning: use location
  114 |         if (test)
      |            ^
	relate logic:= 0
=======================Path Constaint===========================


 Expand conflict 
 The same function may have multiple branches :foo9
# .MEM_73 = VDEF <.MEM_72>
_8 = foo9 (p5_35(D));
test.c:99:14: warning: use location
   99 |         p5 = foo9(p5);
      |              ^
# .MEM_85 = VDEF <.MEM_54>
foo9 (p5_37);
test.c:152:17: warning: use location
  152 |                 foo9(p5);
      |                 ^
=======================Path Constaint===========================

succs:= 14
if (test_38(D) >= test2_40(D))
test.c:151:17: warning: use location
  151 |         else if (test >= test2)
      |                 ^
	relate logic:= 1
succs:= 12
if (test_38(D) == test2_40(D))
test.c:149:12: warning: use location
  149 |         if (test == test2)
      |            ^
	relate logic:= 0
succs:= 10
if (test3_49(D) != 0)
test.c:143:20: warning: use location
  143 |                 if (test3)
      |                    ^
	relate logic:= 0
succs:= 2
if (test_38(D) != 0)
test.c:114:12: warning: use location
  114 |         if (test)
      |            ^
	relate logic:= 0
=======================Path Constaint===========================


 Expand conflict 
 The same function may have multiple branches :foo9
# .MEM_73 = VDEF <.MEM_72>
_8 = foo9 (p5_35(D));
test.c:99:14: warning: use location
   99 |         p5 = foo9(p5);
      |              ^
# .MEM_86 = VDEF <.MEM_54>
foo9 (p5_37);
test.c:150:17: warning: use location
  150 |                 foo9(p5);
      |                 ^
=======================Path Constaint===========================

succs:= 12
if (test_38(D) == test2_40(D))
test.c:149:12: warning: use location
  149 |         if (test == test2)
      |            ^
	relate logic:= 1
succs:= 10
if (test3_49(D) != 0)
test.c:143:20: warning: use location
  143 |                 if (test3)
      |                    ^
	relate logic:= 0
succs:= 2
if (test_38(D) != 0)
test.c:114:12: warning: use location
  114 |         if (test)
      |            ^
	relate logic:= 0
=======================Path Constaint===========================


 Expand conflict 
 The same function may have multiple branches :foo9
# .MEM_73 = VDEF <.MEM_72>
_8 = foo9 (p5_35(D));
test.c:99:14: warning: use location
   99 |         p5 = foo9(p5);
      |              ^
# .MEM_76 = VDEF <.MEM_75>
foo9 (p5_37);
test.c:140:33: warning: use location
  140 |                                 foo9(p5);
      |                                 ^
=======================Path Constaint===========================

=succs:= 7
if (test_38(D) < test2_40(D))
test.c:135:28: warning: use location
  135 |                         if (test < test2)
      |                            ^
	relate logic:= 0
=succs:= 3
if (test_38(D) > test2_40(D))
test.c:121:20: warning: use location
  121 |                 if (test > test2)
      |                    ^
	relate logic:= 0
=succs:= 2
if (test_38(D) != 0)
test.c:114:12: warning: use location
  114 |         if (test)
      |            ^
	relate logic:= 0
=======================Path Constaint===========================


 Expand conflict 
 The same function may have multiple branches :foo9
# .MEM_73 = VDEF <.MEM_72>
_8 = foo9 (p5_35(D));
test.c:99:14: warning: use location
   99 |         p5 = foo9(p5);
      |              ^
# .MEM_81 = VDEF <.MEM_80>
foo9 (p5_37);
test.c:127:33: warning: use location
  127 |                                 foo9(p5);
      |                                 ^
=======================Path Constaint===========================

succs:= 4
if (test_38(D) < test2_40(D))
test.c:124:28: warning: use location
  124 |                         if (test < test2)
      |                            ^
	relate logic:= 1
succs:= 3
if (test_38(D) > test2_40(D))
test.c:121:20: warning: use location
  121 |                 if (test > test2)
      |                    ^
	relate logic:= 1
succs:= 2
if (test_38(D) != 0)
test.c:114:12: warning: use location
  114 |         if (test)
      |            ^
	relate logic:= 1
=======================Path Constaint===========================


======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_74 = VDEF <.MEM_73>
foo9 (p5_37);
bb index := 3
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 3 ,possiable got to succ := 18

======================================================================

 Expand conflict 
 The same function may have multiple branches :foo9
# .MEM_73 = VDEF <.MEM_72>
_8 = foo9 (p5_35(D));
test.c:99:14: warning: use location
   99 |         p5 = foo9(p5);
      |              ^
# .MEM_74 = VDEF <.MEM_73>
foo9 (p5_37);
test.c:116:17: warning: use location
  116 |                 foo9(p5);
      |                 ^
=======================Path Constaint===========================

succs:= 2
if (test_38(D) != 0)
test.c:114:12: warning: use location
  114 |         if (test)
      |            ^
	relate logic:= 1
=======================Path Constaint===========================


 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7f091f19a9d8
    type <pointer_type 0x7f091f1ae9d8
        type <integer_type 0x7f091f1a75e8 int public SI
            size <integer_cst 0x7f091f192df8 constant 32>
            unit-size <integer_cst 0x7f091f192e10 constant 4>
            align:32 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7f091f1a75e8 precision:32 min <integer_cst 0x7f091f192db0 -2147483648> max <integer_cst 0x7f091f192dc8 2147483647>
            pointer_to_this <pointer_type 0x7f091f1ae9d8>>
        public unsigned DI
        size <integer_cst 0x7f091f192bb8 constant 64>
        unit-size <integer_cst 0x7f091f192bd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
    var <var_decl 0x7f091fa3af30 p5>
    def_stmt GIMPLE_NOP
    version:35>
[40;35m <Looserules> find realloc stmt free same pointer [0m
*/If realloc() fails, the initial memory block will not be freed() */# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: use location
   57 |         p6 = realloc(p6, 100);
      |              ^
[40;35m <Looserules> find realloc stmt free same pointer [0m
*/If realloc() fails, the initial memory block will not be freed() */# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: use location
   58 |         p7 = realloc(p6, 100);
      |              ^
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_66 = VDEF <.MEM_65>
free (p9_24);
test.c:74:9: warning: use location
   74 |         free(p9);
      |         ^

 ================== Start Use after free Check ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: Use after free error!: free location 
   57 |         p6 = realloc(p6, 100);
      |              ^
# .MEM_73 = VDEF <.MEM_72>
_8 = foo9 (p5_35(D));
test.c:99:14: warning: use location
   99 |         p5 = foo9(p5);
      |              ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: Use after free error!: free location 
   58 |         p7 = realloc(p6, 100);
      |              ^
# .MEM_73 = VDEF <.MEM_72>
_8 = foo9 (p5_35(D));
test.c:99:14: warning: use location
   99 |         p5 = foo9(p5);
      |              ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_66 = VDEF <.MEM_65>
free (p9_24);
test.c:74:9: warning: Use after free error!: free location 
   74 |         free(p9);
      |         ^
# .MEM_73 = VDEF <.MEM_72>
_8 = foo9 (p5_35(D));
test.c:99:14: warning: use location
   99 |         p5 = foo9(p5);
      |              ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
# .MEM_73 = VDEF <.MEM_72>
_8 = foo9 (p5_35(D));
test.c:99:14: warning: Use after free error!: free location 
_9 = (long int) _8;
test.c:99:14: warning: use location

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: Use after free error!: free location 
   57 |         p6 = realloc(p6, 100);
      |              ^
_9 = (long int) _8;
test.c:99:14: warning: use location
   99 |         p5 = foo9(p5);
      |              ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: Use after free error!: free location 
   58 |         p7 = realloc(p6, 100);
      |              ^
_9 = (long int) _8;
test.c:99:14: warning: use location
   99 |         p5 = foo9(p5);
      |              ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_66 = VDEF <.MEM_65>
free (p9_24);
test.c:74:9: warning: Use after free error!: free location 
   74 |         free(p9);
      |         ^
_9 = (long int) _8;
test.c:99:14: warning: use location
   99 |         p5 = foo9(p5);
      |              ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
# .MEM_73 = VDEF <.MEM_72>
_8 = foo9 (p5_35(D));
test.c:99:14: warning: Use after free error!: free location 
p5_37 = (int *) _9;
test.c:99:12: warning: use location
   99 |         p5 = foo9(p5);
      |            ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: Use after free error!: free location 
   57 |         p6 = realloc(p6, 100);
      |              ^
p5_37 = (int *) _9;
test.c:99:12: warning: use location
   99 |         p5 = foo9(p5);
      |            ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: Use after free error!: free location 
   58 |         p7 = realloc(p6, 100);
      |              ^
p5_37 = (int *) _9;
test.c:99:12: warning: use location
   99 |         p5 = foo9(p5);
      |            ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_66 = VDEF <.MEM_65>
free (p9_24);
test.c:74:9: warning: Use after free error!: free location 
   74 |         free(p9);
      |         ^
p5_37 = (int *) _9;
test.c:99:12: warning: use location
   99 |         p5 = foo9(p5);
      |            ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: Use after free error!: free location 
   57 |         p6 = realloc(p6, 100);
      |              ^
# .MEM_83 = VDEF <.MEM_54>
foo9 (p5_37);
test.c:157:25: warning: use location
  157 |                         foo9(p5);
      |                         ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: Use after free error!: free location 
   58 |         p7 = realloc(p6, 100);
      |              ^
# .MEM_83 = VDEF <.MEM_54>
foo9 (p5_37);
test.c:157:25: warning: use location
  157 |                         foo9(p5);
      |                         ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_66 = VDEF <.MEM_65>
free (p9_24);
test.c:74:9: warning: Use after free error!: free location 
   74 |         free(p9);
      |         ^
# .MEM_83 = VDEF <.MEM_54>
foo9 (p5_37);
test.c:157:25: warning: use location
  157 |                         foo9(p5);
      |                         ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: Use after free error!: free location 
   57 |         p6 = realloc(p6, 100);
      |              ^
# .MEM_85 = VDEF <.MEM_54>
foo9 (p5_37);
test.c:152:17: warning: use location
  152 |                 foo9(p5);
      |                 ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: Use after free error!: free location 
   58 |         p7 = realloc(p6, 100);
      |              ^
# .MEM_85 = VDEF <.MEM_54>
foo9 (p5_37);
test.c:152:17: warning: use location
  152 |                 foo9(p5);
      |                 ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_66 = VDEF <.MEM_65>
free (p9_24);
test.c:74:9: warning: Use after free error!: free location 
   74 |         free(p9);
      |         ^
# .MEM_85 = VDEF <.MEM_54>
foo9 (p5_37);
test.c:152:17: warning: use location
  152 |                 foo9(p5);
      |                 ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: Use after free error!: free location 
   57 |         p6 = realloc(p6, 100);
      |              ^
# .MEM_86 = VDEF <.MEM_54>
foo9 (p5_37);
test.c:150:17: warning: use location
  150 |                 foo9(p5);
      |                 ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: Use after free error!: free location 
   58 |         p7 = realloc(p6, 100);
      |              ^
# .MEM_86 = VDEF <.MEM_54>
foo9 (p5_37);
test.c:150:17: warning: use location
  150 |                 foo9(p5);
      |                 ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_66 = VDEF <.MEM_65>
free (p9_24);
test.c:74:9: warning: Use after free error!: free location 
   74 |         free(p9);
      |         ^
# .MEM_86 = VDEF <.MEM_54>
foo9 (p5_37);
test.c:150:17: warning: use location
  150 |                 foo9(p5);
      |                 ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: Use after free error!: free location 
   57 |         p6 = realloc(p6, 100);
      |              ^
# .MEM_76 = VDEF <.MEM_75>
foo9 (p5_37);
test.c:140:33: warning: use location
  140 |                                 foo9(p5);
      |                                 ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: Use after free error!: free location 
   58 |         p7 = realloc(p6, 100);
      |              ^
# .MEM_76 = VDEF <.MEM_75>
foo9 (p5_37);
test.c:140:33: warning: use location
  140 |                                 foo9(p5);
      |                                 ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_66 = VDEF <.MEM_65>
free (p9_24);
test.c:74:9: warning: Use after free error!: free location 
   74 |         free(p9);
      |         ^
# .MEM_76 = VDEF <.MEM_75>
foo9 (p5_37);
test.c:140:33: warning: use location
  140 |                                 foo9(p5);
      |                                 ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: Use after free error!: free location 
   57 |         p6 = realloc(p6, 100);
      |              ^
# .MEM_81 = VDEF <.MEM_80>
foo9 (p5_37);
test.c:127:33: warning: use location
  127 |                                 foo9(p5);
      |                                 ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: Use after free error!: free location 
   58 |         p7 = realloc(p6, 100);
      |              ^
# .MEM_81 = VDEF <.MEM_80>
foo9 (p5_37);
test.c:127:33: warning: use location
  127 |                                 foo9(p5);
      |                                 ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_66 = VDEF <.MEM_65>
free (p9_24);
test.c:74:9: warning: Use after free error!: free location 
   74 |         free(p9);
      |         ^
# .MEM_81 = VDEF <.MEM_80>
foo9 (p5_37);
test.c:127:33: warning: use location
  127 |                                 foo9(p5);
      |                                 ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: Use after free error!: free location 
   57 |         p6 = realloc(p6, 100);
      |              ^
# .MEM_74 = VDEF <.MEM_73>
foo9 (p5_37);
test.c:116:17: warning: use location
  116 |                 foo9(p5);
      |                 ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: Use after free error!: free location 
   58 |         p7 = realloc(p6, 100);
      |              ^
# .MEM_74 = VDEF <.MEM_73>
foo9 (p5_37);
test.c:116:17: warning: use location
  116 |                 foo9(p5);
      |                 ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_66 = VDEF <.MEM_65>
free (p9_24);
test.c:74:9: warning: Use after free error!: free location 
   74 |         free(p9);
      |         ^
# .MEM_74 = VDEF <.MEM_73>
foo9 (p5_37);
test.c:116:17: warning: use location
  116 |                 foo9(p5);
      |                 ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:3 [0m
[40;31m  	free count:1 [0m
[40;31m  	possible double free [Looserules]:3 [0m

======================================================================

======================================================================
[40;31m 	this stmt need double check [0m

======================================================================

dot graph START

======================================================================
 <ssa_name 0x7f091f19aa20
    type <pointer_type 0x7f091f1ae9d8
        type <integer_type 0x7f091f1a75e8 int public SI
            size <integer_cst 0x7f091f192df8 constant 32>
            unit-size <integer_cst 0x7f091f192e10 constant 4>
            align:32 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7f091f1a75e8 precision:32 min <integer_cst 0x7f091f192db0 -2147483648> max <integer_cst 0x7f091f192dc8 2147483647>
            pointer_to_this <pointer_type 0x7f091f1ae9d8>>
        public unsigned DI
        size <integer_cst 0x7f091f192bb8 constant 64>
        unit-size <integer_cst 0x7f091f192bd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
    var <var_decl 0x7f091fa3af30 p5>
    def_stmt p5_37 = (int *) _9;
    version:37
    ptr-info 0x7f091ecc92a0>
p5_37 = (int *) _9;

 ================== trace ptable================== 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr--------
this other function -----------
 
 Start check Pointer Collect  

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_83 = VDEF <.MEM_54>
foo9 (p5_37);
bb index := 17
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 17 ,possiable got to succ := 18

======================================================================

 Expand conflict 
 The same function may have multiple branches :foo9
# .MEM_74 = VDEF <.MEM_73>
foo9 (p5_37);
test.c:116:17: warning: use location
# .MEM_83 = VDEF <.MEM_54>
foo9 (p5_37);
test.c:157:25: warning: use location
  157 |                         foo9(p5);
      |                         ^
=======================Path Constaint===========================

succs:= 16
if (test_38(D) > test2_40(D))
test.c:155:20: warning: use location
  155 |                 if (test > test2)
      |                    ^
	relate logic:= 1
succs:= 14
if (test_38(D) >= test2_40(D))
test.c:151:17: warning: use location
  151 |         else if (test >= test2)
      |                 ^
	relate logic:= 0
succs:= 12
if (test_38(D) == test2_40(D))
test.c:149:12: warning: use location
  149 |         if (test == test2)
      |            ^
	relate logic:= 0
succs:= 10
if (test3_49(D) != 0)
test.c:143:20: warning: use location
  143 |                 if (test3)
      |                    ^
	relate logic:= 0
succs:= 2
if (test_38(D) != 0)
test.c:114:12: warning: use location
  114 |         if (test)
      |            ^
	relate logic:= 0
=======================Path Constaint===========================


 Expand conflict 
 The same function may have multiple branches :foo9
# .MEM_74 = VDEF <.MEM_73>
foo9 (p5_37);
test.c:116:17: warning: use location
  116 |                 foo9(p5);
      |                 ^
# .MEM_85 = VDEF <.MEM_54>
foo9 (p5_37);
test.c:152:17: warning: use location
  152 |                 foo9(p5);
      |                 ^
=======================Path Constaint===========================

succs:= 14
if (test_38(D) >= test2_40(D))
test.c:151:17: warning: use location
  151 |         else if (test >= test2)
      |                 ^
	relate logic:= 1
succs:= 12
if (test_38(D) == test2_40(D))
test.c:149:12: warning: use location
  149 |         if (test == test2)
      |            ^
	relate logic:= 0
succs:= 10
if (test3_49(D) != 0)
test.c:143:20: warning: use location
  143 |                 if (test3)
      |                    ^
	relate logic:= 0
succs:= 2
if (test_38(D) != 0)
test.c:114:12: warning: use location
  114 |         if (test)
      |            ^
	relate logic:= 0
=======================Path Constaint===========================


 Expand conflict 
 The same function may have multiple branches :foo9
# .MEM_74 = VDEF <.MEM_73>
foo9 (p5_37);
test.c:116:17: warning: use location
  116 |                 foo9(p5);
      |                 ^
# .MEM_86 = VDEF <.MEM_54>
foo9 (p5_37);
test.c:150:17: warning: use location
  150 |                 foo9(p5);
      |                 ^
=======================Path Constaint===========================

succs:= 12
if (test_38(D) == test2_40(D))
test.c:149:12: warning: use location
  149 |         if (test == test2)
      |            ^
	relate logic:= 1
succs:= 10
if (test3_49(D) != 0)
test.c:143:20: warning: use location
  143 |                 if (test3)
      |                    ^
	relate logic:= 0
succs:= 2
if (test_38(D) != 0)
test.c:114:12: warning: use location
  114 |         if (test)
      |            ^
	relate logic:= 0
=======================Path Constaint===========================


 Expand conflict 
 The same function may have multiple branches :foo9
# .MEM_74 = VDEF <.MEM_73>
foo9 (p5_37);
test.c:116:17: warning: use location
  116 |                 foo9(p5);
      |                 ^
# .MEM_76 = VDEF <.MEM_75>
foo9 (p5_37);
test.c:140:33: warning: use location
  140 |                                 foo9(p5);
      |                                 ^
=======================Path Constaint===========================

=succs:= 7
if (test_38(D) < test2_40(D))
test.c:135:28: warning: use location
  135 |                         if (test < test2)
      |                            ^
	relate logic:= 0
=succs:= 3
if (test_38(D) > test2_40(D))
test.c:121:20: warning: use location
  121 |                 if (test > test2)
      |                    ^
	relate logic:= 0
=succs:= 2
if (test_38(D) != 0)
test.c:114:12: warning: use location
  114 |         if (test)
      |            ^
	relate logic:= 0
=======================Path Constaint===========================


 Expand conflict 
 The same function may have multiple branches :foo9
# .MEM_74 = VDEF <.MEM_73>
foo9 (p5_37);
test.c:116:17: warning: use location
  116 |                 foo9(p5);
      |                 ^
# .MEM_81 = VDEF <.MEM_80>
foo9 (p5_37);
test.c:127:33: warning: use location
  127 |                                 foo9(p5);
      |                                 ^
=======================Path Constaint===========================

succs:= 4
if (test_38(D) < test2_40(D))
test.c:124:28: warning: use location
  124 |                         if (test < test2)
      |                            ^
	relate logic:= 1
succs:= 3
if (test_38(D) > test2_40(D))
test.c:121:20: warning: use location
  121 |                 if (test > test2)
      |                    ^
	relate logic:= 1
succs:= 2
if (test_38(D) != 0)
test.c:114:12: warning: use location
  114 |         if (test)
      |            ^
	relate logic:= 1
=======================Path Constaint===========================


======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_74 = VDEF <.MEM_73>
foo9 (p5_37);
bb index := 3
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 3 ,possiable got to succ := 18

======================================================================
# .MEM_74 = VDEF <.MEM_73>
foo9 (p5_37);
foo9 (p5_37);
test.c:116:17: warning: use location
  116 |                 foo9(p5);
      |                 ^
this stmt is child function---foo9-----

 ================== trace ================== 
trace fucntion name:foo9 
[40;44m =======trace_function_path foo9  function_call count: 1 level :0========  [0m
# .MEM_4 = VDEF <.MEM_3(D)>
free (z_2(D));
[40;36m ======= node_fun:foo9========= [0m
[40;36m ======= find relate stmt with p5 ========= [0m
[40;36m ======= relate stmt argument:p5 ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:free========= [0m
[40;46m =======add node_fun stack:free========= [0m

 ================== trace ================== 
trace fucntion free:0 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_74 = VDEF <.MEM_73>
foo9 (p5_37);
bb index := 3
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 3 ,possiable got to succ := 18

======================================================================
# .MEM_74 = VDEF <.MEM_73>
foo9 (p5_37);
foo9 (p5_37);
test.c:116:17: warning: use location
this stmt is child function---foo9-----

 ================== trace ================== 
trace fucntion name:foo9 
[40;44m =======trace_function_path foo9  function_call count: 1 level :0========  [0m
# .MEM_4 = VDEF <.MEM_3(D)>
free (z_2(D));
[40;36m ======= node_fun:foo9========= [0m
[40;36m ======= find relate stmt with p5 ========= [0m
[40;36m ======= relate stmt argument:p5 ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:free========= [0m
[40;46m =======add node_fun stack:free========= [0m

 ================== trace ================== 
trace fucntion free:0 

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7f091f19aa20
    type <pointer_type 0x7f091f1ae9d8
        type <integer_type 0x7f091f1a75e8 int public SI
            size <integer_cst 0x7f091f192df8 constant 32>
            unit-size <integer_cst 0x7f091f192e10 constant 4>
            align:32 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7f091f1a75e8 precision:32 min <integer_cst 0x7f091f192db0 -2147483648> max <integer_cst 0x7f091f192dc8 2147483647>
            pointer_to_this <pointer_type 0x7f091f1ae9d8>>
        public unsigned DI
        size <integer_cst 0x7f091f192bb8 constant 64>
        unit-size <integer_cst 0x7f091f192bd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
    var <var_decl 0x7f091fa3af30 p5>
    def_stmt p5_37 = (int *) _9;
    version:37
    ptr-info 0x7f091ecc92a0>

 ================== Start Use after free Check ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:0 [0m
[40;31m  	free count:0 [0m

======================================================================

======================================================================
[40;31m    no free stmt possible memory leak [0m

======================================================================

dot graph START

======================================================================
 <ssa_name 0x7f091f19aa20
    type <pointer_type 0x7f091f1ae9d8
        type <integer_type 0x7f091f1a75e8 int public SI
            size <integer_cst 0x7f091f192df8 constant 32>
            unit-size <integer_cst 0x7f091f192e10 constant 4>
            align:32 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7f091f1a75e8 precision:32 min <integer_cst 0x7f091f192db0 -2147483648> max <integer_cst 0x7f091f192dc8 2147483647>
            pointer_to_this <pointer_type 0x7f091f1ae9d8>>
        public unsigned DI
        size <integer_cst 0x7f091f192bb8 constant 64>
        unit-size <integer_cst 0x7f091f192bd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
    var <var_decl 0x7f091fa3af30 p5>
    def_stmt p5_37 = (int *) _9;
    version:37
    ptr-info 0x7f091ecc92a0>
p5_37 = (int *) _9;

 ================== trace ptable================== 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr--------
this other function -----------
 
 Start check Pointer Collect  

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_83 = VDEF <.MEM_54>
foo9 (p5_37);
bb index := 17
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 17 ,possiable got to succ := 18

======================================================================

 Expand conflict 
 The same function may have multiple branches :foo9
# .MEM_81 = VDEF <.MEM_80>
foo9 (p5_37);
test.c:127:33: warning: use location
  127 |                                 foo9(p5);
      |                                 ^
# .MEM_83 = VDEF <.MEM_54>
foo9 (p5_37);
test.c:157:25: warning: use location
  157 |                         foo9(p5);
      |                         ^
=======================Path Constaint===========================

succs:= 16
if (test_38(D) > test2_40(D))
test.c:155:20: warning: use location
  155 |                 if (test > test2)
      |                    ^
	relate logic:= 1
succs:= 14
if (test_38(D) >= test2_40(D))
test.c:151:17: warning: use location
  151 |         else if (test >= test2)
      |                 ^
	relate logic:= 0
succs:= 12
if (test_38(D) == test2_40(D))
test.c:149:12: warning: use location
  149 |         if (test == test2)
      |            ^
	relate logic:= 0
succs:= 10
if (test3_49(D) != 0)
test.c:143:20: warning: use location
  143 |                 if (test3)
      |                    ^
	relate logic:= 0
succs:= 2
if (test_38(D) != 0)
test.c:114:12: warning: use location
  114 |         if (test)
      |            ^
	relate logic:= 0
=======================Path Constaint===========================


 Expand conflict 
 The same function may have multiple branches :foo9
# .MEM_81 = VDEF <.MEM_80>
foo9 (p5_37);
test.c:127:33: warning: use location
  127 |                                 foo9(p5);
      |                                 ^
# .MEM_85 = VDEF <.MEM_54>
foo9 (p5_37);
test.c:152:17: warning: use location
  152 |                 foo9(p5);
      |                 ^
=======================Path Constaint===========================

succs:= 14
if (test_38(D) >= test2_40(D))
test.c:151:17: warning: use location
  151 |         else if (test >= test2)
      |                 ^
	relate logic:= 1
succs:= 12
if (test_38(D) == test2_40(D))
test.c:149:12: warning: use location
  149 |         if (test == test2)
      |            ^
	relate logic:= 0
succs:= 10
if (test3_49(D) != 0)
test.c:143:20: warning: use location
  143 |                 if (test3)
      |                    ^
	relate logic:= 0
succs:= 2
if (test_38(D) != 0)
test.c:114:12: warning: use location
  114 |         if (test)
      |            ^
	relate logic:= 0
=======================Path Constaint===========================


 Expand conflict 
 The same function may have multiple branches :foo9
# .MEM_81 = VDEF <.MEM_80>
foo9 (p5_37);
test.c:127:33: warning: use location
  127 |                                 foo9(p5);
      |                                 ^
# .MEM_86 = VDEF <.MEM_54>
foo9 (p5_37);
test.c:150:17: warning: use location
  150 |                 foo9(p5);
      |                 ^
=======================Path Constaint===========================

succs:= 12
if (test_38(D) == test2_40(D))
test.c:149:12: warning: use location
  149 |         if (test == test2)
      |            ^
	relate logic:= 1
succs:= 10
if (test3_49(D) != 0)
test.c:143:20: warning: use location
  143 |                 if (test3)
      |                    ^
	relate logic:= 0
succs:= 2
if (test_38(D) != 0)
test.c:114:12: warning: use location
  114 |         if (test)
      |            ^
	relate logic:= 0
=======================Path Constaint===========================


 Expand conflict 
 The same function may have multiple branches :foo9
# .MEM_81 = VDEF <.MEM_80>
foo9 (p5_37);
test.c:127:33: warning: use location
  127 |                                 foo9(p5);
      |                                 ^
# .MEM_76 = VDEF <.MEM_75>
foo9 (p5_37);
test.c:140:33: warning: use location
  140 |                                 foo9(p5);
      |                                 ^
=======================Path Constaint===========================

=succs:= 7
if (test_38(D) < test2_40(D))
test.c:135:28: warning: use location
  135 |                         if (test < test2)
      |                            ^
	relate logic:= 0
=succs:= 3
if (test_38(D) > test2_40(D))
test.c:121:20: warning: use location
  121 |                 if (test > test2)
      |                    ^
	relate logic:= 0
=succs:= 2
if (test_38(D) != 0)
test.c:114:12: warning: use location
  114 |         if (test)
      |            ^
	relate logic:= 0
=======================Path Constaint===========================

# .MEM_81 = VDEF <.MEM_80>
foo9 (p5_37);
foo9 (p5_37);
test.c:127:33: warning: use location
  127 |                                 foo9(p5);
      |                                 ^
this stmt is child function---foo9-----

 ================== trace ================== 
trace fucntion name:foo9 
[40;44m =======trace_function_path foo9  function_call count: 1 level :0========  [0m
# .MEM_4 = VDEF <.MEM_3(D)>
free (z_2(D));
[40;36m ======= node_fun:foo9========= [0m
[40;36m ======= find relate stmt with p5 ========= [0m
[40;36m ======= relate stmt argument:p5 ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:free========= [0m
[40;46m =======add node_fun stack:free========= [0m

 ================== trace ================== 
trace fucntion free:0 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_74 = VDEF <.MEM_73>
foo9 (p5_37);
bb index := 3
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 3 ,possiable got to succ := 18

======================================================================

 Expand conflict 
 The same function may have multiple branches :foo9
# .MEM_81 = VDEF <.MEM_80>
foo9 (p5_37);
test.c:127:33: warning: use location
# .MEM_74 = VDEF <.MEM_73>
foo9 (p5_37);
test.c:116:17: warning: use location
  116 |                 foo9(p5);
      |                 ^
=======================Path Constaint===========================

succs:= 2
if (test_38(D) != 0)
test.c:114:12: warning: use location
  114 |         if (test)
      |            ^
	relate logic:= 1
=======================Path Constaint===========================


======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_74 = VDEF <.MEM_73>
foo9 (p5_37);
bb index := 3
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 3 ,possiable got to succ := 18

======================================================================

 Expand conflict 
 The same function may have multiple branches :foo9
# .MEM_81 = VDEF <.MEM_80>
foo9 (p5_37);
test.c:127:33: warning: use location
  127 |                                 foo9(p5);
      |                                 ^
# .MEM_74 = VDEF <.MEM_73>
foo9 (p5_37);
test.c:116:17: warning: use location
  116 |                 foo9(p5);
      |                 ^
=======================Path Constaint===========================

succs:= 2
if (test_38(D) != 0)
test.c:114:12: warning: use location
  114 |         if (test)
      |            ^
	relate logic:= 1
=======================Path Constaint===========================


 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7f091f19aa20
    type <pointer_type 0x7f091f1ae9d8
        type <integer_type 0x7f091f1a75e8 int public SI
            size <integer_cst 0x7f091f192df8 constant 32>
            unit-size <integer_cst 0x7f091f192e10 constant 4>
            align:32 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7f091f1a75e8 precision:32 min <integer_cst 0x7f091f192db0 -2147483648> max <integer_cst 0x7f091f192dc8 2147483647>
            pointer_to_this <pointer_type 0x7f091f1ae9d8>>
        public unsigned DI
        size <integer_cst 0x7f091f192bb8 constant 64>
        unit-size <integer_cst 0x7f091f192bd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
    var <var_decl 0x7f091fa3af30 p5>
    def_stmt p5_37 = (int *) _9;
    version:37
    ptr-info 0x7f091ecc92a0>

 ================== Start Use after free Check ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:0 [0m
[40;31m  	free count:0 [0m

======================================================================

======================================================================
[40;31m    no free stmt possible memory leak [0m

======================================================================

dot graph START

======================================================================
 <ssa_name 0x7f091f19aaf8
    type <pointer_type 0x7f091f1ae9d8
        type <integer_type 0x7f091f1a75e8 int public SI
            size <integer_cst 0x7f091f192df8 constant 32>
            unit-size <integer_cst 0x7f091f192e10 constant 4>
            align:32 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7f091f1a75e8 precision:32 min <integer_cst 0x7f091f192db0 -2147483648> max <integer_cst 0x7f091f192dc8 2147483647>
            pointer_to_this <pointer_type 0x7f091f1ae9d8>>
        public unsigned DI
        size <integer_cst 0x7f091f192bb8 constant 64>
        unit-size <integer_cst 0x7f091f192bd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
    var <var_decl 0x7f091ecc4090 p3>
    def_stmt GIMPLE_NOP
    version:43>
GIMPLE_NOP

 ================== trace ptable================== 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr--------
this other function -----------
 
 Start check Pointer Collect  

======================================================================
# .MEM_77 = VDEF <.MEM_75>
foo (p3_43(D));
foo (p3_43(D));
test.c:137:33: warning: use location
  137 |                                 foo(p3);
      |                                 ^
this stmt is child function---foo-----

 ================== trace ================== 
trace fucntion name:foo 
[40;44m =======trace_function_path foo  function_call count: 1 level :0========  [0m
# .MEM_4 = VDEF <.MEM_3(D)>
free (z_2(D));
[40;31m  find free stmt free same pointer [0m
# .MEM_4 = VDEF <.MEM_3(D)>
free (z_2(D));
test.c:29:9: warning: use location
   29 |         free(z);
      |         ^
[40;42m =======pre add _ fucntion:free========= [0m
[40;46m =======add node_fun stack:free========= [0m

 ================== trace ================== 
trace fucntion free:1 
# .MEM_77 = VDEF <.MEM_75>
foo (p3_43(D));
foo (p3_43(D));
test.c:137:33: warning: use location
  137 |                                 foo(p3);
      |                                 ^
this stmt is child function---foo-----

 ================== trace ================== 
trace fucntion name:foo 
[40;44m =======trace_function_path foo  function_call count: 1 level :0========  [0m
# .MEM_4 = VDEF <.MEM_3(D)>
free (z_2(D));
[40;31m  find free stmt free same pointer [0m
# .MEM_4 = VDEF <.MEM_3(D)>
free (z_2(D));
test.c:29:9: warning: use location
   29 |         free(z);
      |         ^
[40;42m =======pre add _ fucntion:free========= [0m
[40;46m =======add node_fun stack:free========= [0m

 ================== trace ================== 
trace fucntion free:2 

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7f091f19aaf8
    type <pointer_type 0x7f091f1ae9d8
        type <integer_type 0x7f091f1a75e8 int public SI
            size <integer_cst 0x7f091f192df8 constant 32>
            unit-size <integer_cst 0x7f091f192e10 constant 4>
            align:32 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7f091f1a75e8 precision:32 min <integer_cst 0x7f091f192db0 -2147483648> max <integer_cst 0x7f091f192dc8 2147483647>
            pointer_to_this <pointer_type 0x7f091f1ae9d8>>
        public unsigned DI
        size <integer_cst 0x7f091f192bb8 constant 64>
        unit-size <integer_cst 0x7f091f192bd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
    var <var_decl 0x7f091ecc4090 p3>
    def_stmt GIMPLE_NOP
    version:43>
[40;35m <Looserules> find realloc stmt free same pointer [0m
*/If realloc() fails, the initial memory block will not be freed() */# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: use location
   57 |         p6 = realloc(p6, 100);
      |              ^
[40;35m <Looserules> find realloc stmt free same pointer [0m
*/If realloc() fails, the initial memory block will not be freed() */# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: use location
   58 |         p7 = realloc(p6, 100);
      |              ^
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_66 = VDEF <.MEM_65>
free (p9_24);
test.c:74:9: warning: use location
   74 |         free(p9);
      |         ^

 ================== Start Use after free Check ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: Use after free error!: free location 
   57 |         p6 = realloc(p6, 100);
      |              ^
# .MEM_77 = VDEF <.MEM_75>
foo (p3_43(D));
test.c:137:33: warning: use location
  137 |                                 foo(p3);
      |                                 ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: Use after free error!: free location 
   58 |         p7 = realloc(p6, 100);
      |              ^
# .MEM_77 = VDEF <.MEM_75>
foo (p3_43(D));
test.c:137:33: warning: use location
  137 |                                 foo(p3);
      |                                 ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_66 = VDEF <.MEM_65>
free (p9_24);
test.c:74:9: warning: Use after free error!: free location 
   74 |         free(p9);
      |         ^
# .MEM_77 = VDEF <.MEM_75>
foo (p3_43(D));
test.c:137:33: warning: use location
  137 |                                 foo(p3);
      |                                 ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: Use after free error!: free location 
   57 |         p6 = realloc(p6, 100);
      |              ^
# .MEM_77 = VDEF <.MEM_75>
foo (p3_43(D));
test.c:137:33: warning: use location
  137 |                                 foo(p3);
      |                                 ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: Use after free error!: free location 
   58 |         p7 = realloc(p6, 100);
      |              ^
# .MEM_77 = VDEF <.MEM_75>
foo (p3_43(D));
test.c:137:33: warning: use location
  137 |                                 foo(p3);
      |                                 ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m

 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_66 = VDEF <.MEM_65>
free (p9_24);
test.c:74:9: warning: Use after free error!: free location 
   74 |         free(p9);
      |         ^
# .MEM_77 = VDEF <.MEM_75>
foo (p3_43(D));
test.c:137:33: warning: use location
  137 |                                 foo(p3);
      |                                 ^

 ================== warring ================== 
[40;35m    Use after free error! [0m

 ================== warring ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:3 [0m
[40;31m  	free count:2 [0m
[40;31m  	possible double free [Looserules]:3 [0m
[40;31m  	possible double free [rigorous]:2 [0m

======================================================================

======================================================================
[40;31m  	possible double free [rigorous]:2 [0m

======================================================================

dot graph START

======================================================================
 <ssa_name 0x7f091f19ab88
    type <pointer_type 0x7f091f1ae9d8
        type <integer_type 0x7f091f1a75e8 int public SI
            size <integer_cst 0x7f091f192df8 constant 32>
            unit-size <integer_cst 0x7f091f192e10 constant 4>
            align:32 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7f091f1a75e8 precision:32 min <integer_cst 0x7f091f192db0 -2147483648> max <integer_cst 0x7f091f192dc8 2147483647>
            pointer_to_this <pointer_type 0x7f091f1ae9d8>>
        public unsigned DI
        size <integer_cst 0x7f091f192bb8 constant 64>
        unit-size <integer_cst 0x7f091f192bd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
    var <var_decl 0x7f091ecc4000 p4>
    def_stmt GIMPLE_NOP
    version:52>
GIMPLE_NOP

 ================== trace ptable================== 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr--------
this other function -----------

======================================================================
[40;35m  	Looserules free count:0 [0m
[40;31m  	free count:0 [0m

======================================================================

======================================================================
[40;31m 	Can't find this fucntion in Pointer table [0m
[40;31m 	Possiable no other stmt relate with this stmt [0m

======================================================================
[40;33m =======POP node_fun stack:main========= [0m
[40;44m =======node_fun:foo9========= [0m
[40;44m fucntion collect path  [0m
[40;44m =======print_function_path foo9  function_call count: 1 level :0========  [0m
[40;44m =======print_function_type 0  ========  [0m
[40;42m =======pre add _ fucntion:free========= [0m
[40;33m =======POP node_fun stack:free========= [0m
[40;42m =======pre_check_funciton:foo9========= [0m
[40;42m =======start_check_funciton:foo9========= [0m
[40;33m =======POP node_fun stack:foo9========= [0m
[40;44m =======node_fun:foo========= [0m
[40;44m fucntion collect path  [0m
[40;44m =======print_function_path foo  function_call count: 1 level :0========  [0m
[40;44m =======print_function_type 0  ========  [0m
[40;42m =======pre add _ fucntion:free========= [0m
[40;33m =======POP node_fun stack:free========= [0m
[40;42m =======pre_check_funciton:foo========= [0m
[40;42m =======start_check_funciton:foo========= [0m
[40;33m =======POP node_fun stack:foo========= [0m
fucntion collect path finsh

=============== The third stage : detection  End=================

===============Print ALL GIMPLE IR=================
=======Mapping node_fun:main=========
=======is loop:0=========

 bb index 2 
<bb 2> [local count: 1073741824]:
p6_15 = malloc (100);
p6_17 = realloc (p6_15, 100);
p7_19 = realloc (p6_17, 100);
*p7_19 = 48;
_1 = (long int) "0";
_2 = (int) _1;
*p6_15 = _2;
_3 = (long int) "0";
_4 = (int) _3;
MEM[(int *)p6_15 + 4B] = _4;
p9_24 = malloc (0);
_5 = malloc (1);
MEM[(struct st *)p9_24 + 48B].f = _5;
free (p9_24);
p_29 = malloc (10);
_6 = malloc (1);
MEM[(struct st *)p_29 + 48B].f = _6;
_7 = malloc (1);
MEM[(struct st *)p_29 + 32B].f = _7;
foo (p_29);
_8 = foo9 (p5_35(D));
_9 = (long int) _8;
p5_37 = (int *) _9;
if (test_38(D) != 0)
  goto <bb 3>; [33.00%]
else
  goto <bb 12>; [67.00%]

=======is loop:0=========

 bb index 3 
<bb 3> [local count: 354334800]:
foo9 (p5_37);
if (test_38(D) > test2_40(D))
  goto <bb 4>; [50.00%]
else
  goto <bb 7>; [50.00%]

=======is loop:0=========

 bb index 4 
<bb 4> [local count: 177167400]:
foo (p_29);
if (test_38(D) < test2_40(D))
  goto <bb 5>; [50.00%]
else
  goto <bb 6>; [50.00%]

=======is loop:0=========

 bb index 5 
<bb 5> [local count: 88583700]:
foo (p_29);
foo9 (p5_37);
goto <bb 10>; [100.00%]

=======is loop:0=========

 bb index 6 
<bb 6> [local count: 88583700]:
foo (p_29);
goto <bb 10>; [100.00%]

=======is loop:0=========

 bb index 7 
<bb 7> [local count: 177167400]:
foo (p_29);
if (test_38(D) < test2_40(D))
  goto <bb 8>; [50.00%]
else
  goto <bb 9>; [50.00%]

=======is loop:0=========

 bb index 8 
<bb 8> [local count: 88583700]:
foo (p3_43(D));
goto <bb 10>; [100.00%]

=======is loop:0=========

 bb index 9 
<bb 9> [local count: 88583700]:
foo9 (p5_37);

=======is loop:0=========

 bb index 10 
<bb 10> [local count: 354334800]:
if (test3_49(D) != 0)
  goto <bb 11>; [33.00%]
else
  goto <bb 12>; [67.00%]

=======is loop:0=========

 bb index 11 
<bb 11> [local count: 116930483]:
foo (p_29);

=======is loop:0=========

 bb index 12 
<bb 12> [local count: 1073741824]:
if (test_38(D) == test2_40(D))
  goto <bb 13>; [20.24%]
else
  goto <bb 14>; [79.76%]

=======is loop:0=========

 bb index 13 
<bb 13> [local count: 217325344]:
foo9 (p5_37);
goto <bb 18>; [100.00%]

=======is loop:0=========

 bb index 14 
<bb 14> [local count: 856416481]:
if (test_38(D) >= test2_40(D))
  goto <bb 15>; [33.00%]
else
  goto <bb 16>; [67.00%]

=======is loop:0=========

 bb index 15 
<bb 15> [local count: 282617437]:
foo9 (p5_37);
goto <bb 18>; [100.00%]

=======is loop:0=========

 bb index 16 
<bb 16> [local count: 573799044]:
if (test_38(D) > test2_40(D))
  goto <bb 17>; [33.00%]
else
  goto <bb 18>; [67.00%]

=======is loop:0=========

 bb index 17 
<bb 17> [local count: 189353683]:
foo9 (p5_37);
foo (p4_52(D));

=======is loop:0=========

 bb index 18 
<bb 18> [local count: 1073741824]:
return 0;

=======Mapping node_fun:foo9=========
=======is loop:0=========

 bb index 2 
<bb 2> [local count: 1073741824]:
free (z_2(D));
return;

=======Mapping node_fun:foo=========
=======is loop:0=========

 bb index 2 
<bb 2> [local count: 1073741824]:
free (z_2(D));
return;


===============Print ALL GIMPLE IR=================
[40;32mSTART CHECKSTART CHECKSTART CHECKSTART CHECKSTART CHECK[0m
    =()=
 ,/'_||_
  (___  `.
 ./  `=='
                   
    ~~~~~~~~~~~  
 ~~~~~~
           ~~~~~~~
[40;34m    gimple malloc count : 8 [0m
[40;34m    gimple free   count : 3 [0m
[40;34m    find Entry point : 12 [0m
[40;34m    used_stmt array stack totalsize of : 0.001712 mb[0m
[40;34m    collect time: : 0.000584 s [0m
[40;34m    algorithm time: 0.029999 s [0m
[40;34m    gimple stmt count : : 49 [0m
[40;32mSTART CHECKSTART CHECKSTART CHECKSTART CHECKSTART CHECK[0m
Profile consistency report:

                                 |mismatch     |mismatch     |                     |
Pass name                        |IN    |IN    |OUT   |OUT   |overall              |
                                 |freq  |count |freq  |count |size      |time      |
cp                   ------------|      |      |      |      |          |          |
inline               ------------|      |      |      |      |          |          |
fixup_cfg            ------------|      |      |      |      |          |          |
adjust_alignment     ------------|      |      |      |      |          |          |
ccp                  ------------|      |      |      |      |          |          |
backprop             ------------|      |      |      |      |          |          |
phiprop              ------------|      |      |      |      |          |          |
forwprop             ------------|      |      |      |      |          |          |
objsz                ------------|      |      |      |      |          |          |
alias                ------------|      |      |      |      |          |          |
retslot              ------------|      |      |      |      |          |          |
mergephi             ------------|      |      |      |      |          |          |
dce                  ------------|      |      |      |      |          |          |
stdarg               ------------|      |      |      |      |          |          |
cdce                 ------------|      |      |      |      |          |          |
cselim               ------------|      |      |      |      |          |          |
copyprop             ------------|      |      |      |      |          |          |
ifcombine            ------------|      |      |      |      |          |          |
mergephi             ------------|      |      |      |      |          |          |
phiopt               ------------|      |      |      |      |          |          |
ch                   ------------|      |      |      |      |          |          |
cplxlower            ------------|      |      |      |      |          |          |
sra                  ------------|      |      |      |      |          |          |
dom                              |      |      |      |      |     +2.3%|     -0.2%|
copyprop                         |      |      |      |      |     +2.2%|     -0.2%|
reassoc              ------------|      |      |      |      |          |          |
dce                  ------------|      |      |      |      |          |          |
forwprop             ------------|      |      |      |      |          |          |
phiopt               ------------|      |      |      |      |          |          |
ccp                  ------------|      |      |      |      |          |          |
sincos               ------------|      |      |      |      |          |          |
laddress             ------------|      |      |      |      |          |          |
lim                  ------------|      |      |      |      |          |          |
walloca              ------------|      |      |      |      |          |          |
sink                 ------------|      |      |      |      |          |          |
dce                  ------------|      |      |      |      |          |          |
fix_loops            ------------|      |      |      |      |          |          |
no_loop              ------------|      |      |      |      |          |          |
veclower2            ------------|      |      |      |      |          |          |
switchlower          ------------|      |      |      |      |          |          |
reassoc              ------------|      |      |      |      |          |          |
slsr                 ------------|      |      |      |      |          |          |
dom                              |      |      |      |      |     +1.1%|     -0.0%|
strlen                           |      |      |      |      |     +1.1%|     -0.0%|
copyprop             ------------|      |      |      |      |          |          |
wrestrict            ------------|      |      |      |      |          |          |
cddce                ------------|      |      |      |      |          |          |
forwprop             ------------|      |      |      |      |          |          |
phiopt               ------------|      |      |      |      |          |          |
fab                  ------------|      |      |      |      |          |          |
dce                  ------------|      |      |      |      |          |          |
crited               ------------|      |      |      |      |          |          |
uncprop              ------------|      |      |      |      |          |          |
local-pure-const     ------------|      |      |      |      |          |          |
modref               ------------|      |      |      |      |          |          |
nrv                  ------------|      |      |      |      |          |          |
isel                 ------------|      |      |      |      |          |          |
optimized            ------------|      |      |      |      |          |          |
expand                           |      |      |      |      |----------|----------|
vregs                            |      |      |      |      |    +74.0%|    +29.2%|
into_cfglayout                   |      |      |      |      |     -2.5%|     -1.0%|
jump                             |      |      |      |      |     -2.6%|     -1.0%|
subreg1              ------------|      |      |      |      |          |          |
dfinit               ------------|      |      |      |      |          |          |
cse1                 ------------|      |      |      |      |          |          |
fwprop1                          |      |      |      |      |     -3.0%|     -5.1%|
ce1                              |      |      |      |      |     -3.1%|     -5.4%|
reginfo              ------------|      |      |      |      |          |          |
loop2                ------------|      |      |      |      |          |          |
loop2_init           ------------|      |      |      |      |          |          |
loop2_invariant      ------------|      |      |      |      |          |          |
loop2_done           ------------|      |      |      |      |          |          |
dse1                 ------------|      |      |      |      |          |          |
fwprop2              ------------|      |      |      |      |          |          |
init-regs                        |      |      |      |      |     +7.5%|     +4.9%|
combine                          |      |      |      |      |    -24.2%|     -7.0%|
ce2                              |      |      |      |      |    -41.0%|    -12.6%|
outof_cfglayout      ------------|      |      |      |      |          |          |
split1               ------------|      |      |      |      |          |          |
subreg3              ------------|      |      |      |      |          |          |
mode_sw              ------------|      |      |      |      |          |          |
asmcons              ------------|      |      |      |      |          |          |
ira                              |      |      |      |      |     -0.7%|     -0.7%|
reload                           |      |      |      |      |    -14.9%|    -15.0%|
postreload                       |      |      |      |      |    -16.7%|    -16.8%|
split2               ------------|      |      |      |      |          |          |
cmpelim              ------------|      |      |      |      |          |          |
pro_and_epilogue                 |      |      |      |      |     +7.4%|     +7.4%|
dse2                             |      |      |      |      |     +6.9%|     +6.9%|
csa                  ------------|      |      |      |      |          |          |
jump2                ------------|      |      |      |      |          |          |
ce3                  ------------|      |      |      |      |          |          |
cprop_hardreg        ------------|      |      |      |      |          |          |
rtl_dce              ------------|      |      |      |      |          |          |
bbro                 ------------|      |      |      |      |          |          |
split4               ------------|      |      |      |      |          |          |
stack                ------------|      |      |      |      |          |          |
zero_call_used_regs  ------------|      |      |      |      |          |          |
alignments           ------------|      |      |      |      |          |          |
