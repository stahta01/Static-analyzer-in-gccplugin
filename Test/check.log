test.c: In function â€˜mainâ€™:
test.c:60:14: warning: assignment to â€˜intâ€™ from â€˜char *â€™ makes integer from pointer without a cast [-Wint-conversion]
   60 |         q[0] = "0";
      |              ^
test.c:61:14: warning: assignment to â€˜intâ€™ from â€˜char *â€™ makes integer from pointer without a cast [-Wint-conversion]
   61 |         q[1] = "0";
      |              ^
test.c:80:13: warning: passing argument 1 of â€˜fooâ€™ from incompatible pointer type [-Wincompatible-pointer-types]
   80 |         foo(p);
      |             ^
      |             |
      |             struct st *
test.c:27:14: note: expected â€˜int *â€™ but argument is of type â€˜struct st *â€™
   27 | int foo(int *z)
      |         ~~~~~^
test.c:99:12: warning: assignment to â€˜int *â€™ from â€˜intâ€™ makes pointer from integer without a cast [-Wint-conversion]
   99 |         p5 = foo9(p5);
      |            ^
test.c:123:29: warning: passing argument 1 of â€˜fooâ€™ from incompatible pointer type [-Wincompatible-pointer-types]
  123 |                         foo(p);
      |                             ^
      |                             |
      |                             struct st *
test.c:27:14: note: expected â€˜int *â€™ but argument is of type â€˜struct st *â€™
   27 | int foo(int *z)
      |         ~~~~~^
test.c:126:37: warning: passing argument 1 of â€˜fooâ€™ from incompatible pointer type [-Wincompatible-pointer-types]
  126 |                                 foo(p);
      |                                     ^
      |                                     |
      |                                     struct st *
test.c:27:14: note: expected â€˜int *â€™ but argument is of type â€˜struct st *â€™
   27 | int foo(int *z)
      |         ~~~~~^
test.c:130:37: warning: passing argument 1 of â€˜fooâ€™ from incompatible pointer type [-Wincompatible-pointer-types]
  130 |                                 foo(p);
      |                                     ^
      |                                     |
      |                                     struct st *
test.c:27:14: note: expected â€˜int *â€™ but argument is of type â€˜struct st *â€™
   27 | int foo(int *z)
      |         ~~~~~^
test.c:134:29: warning: passing argument 1 of â€˜fooâ€™ from incompatible pointer type [-Wincompatible-pointer-types]
  134 |                         foo(p);
      |                             ^
      |                             |
      |                             struct st *
test.c:27:14: note: expected â€˜int *â€™ but argument is of type â€˜struct st *â€™
   27 | int foo(int *z)
      |         ~~~~~^
test.c:145:29: warning: passing argument 1 of â€˜fooâ€™ from incompatible pointer type [-Wincompatible-pointer-types]
  145 |                         foo(p);
      |                             ^
      |                             |
      |                             struct st *
test.c:27:14: note: expected â€˜int *â€™ but argument is of type â€˜struct st *â€™
   27 | int foo(int *z)
      |         ~~~~~^
Profile consistency report:

                                 |mismatch     |mismatch     |                     |
Pass name                        |IN    |IN    |OUT   |OUT   |overall              |
                                 |freq  |count |freq  |count |size      |time      |
cfg                  ------------|      |      |      |      |          |          |
ompexp                           |      |      |      |      |   +100.0%|          |
fixup_cfg            ------------|      |      |      |      |          |          |
ssa                              |      |      |      |      |     -1.0%|          |
nothrow                          |      |      |      |      |     -1.0%|          |
fixup_cfg            ------------|      |      |      |      |          |          |
local-fnsummary      ------------|      |      |      |      |          |          |
einline              ------------|      |      |      |      |          |          |
early_optimizations  ------------|      |      |      |      |          |          |
objsz                ------------|      |      |      |      |          |          |
ccp                  ------------|      |      |      |      |          |          |
forwprop                         |      |      |      |      |     -2.0%|          |
ethread                          |      |      |      |      |     -2.0%|          |
esra                 ------------|      |      |      |      |          |          |
ealias               ------------|      |      |      |      |          |          |
mergephi             ------------|      |      |      |      |          |          |
cddce                ------------|      |      |      |      |          |          |
phiopt               ------------|      |      |      |      |          |          |
modref               ------------|      |      |      |      |          |          |
iftoswitch           ------------|      |      |      |      |          |          |
profile_estimate     ------------|      |      |      |      |          |          |
local-pure-const                 |      |      |      |      |          |   +100.0%|
release_ssa          ------------|      |      |      |      |          |          |
local-fnsummary      ------------|      |      |      |      |          |          |
=======ipa_pta=========
===============The first stage : Point of interest stmt collect=================
=======node_fun:main=========
node:= 2 
 	from_branch :=2
	next_branch :=3
	from_branch :=2
	next_branch :=12
--------GIMPLE Cond -------
 initssssss:= 0
 initssssss:= 1
node:= 3 
 	from_branch :=3
	next_branch :=4
	from_branch :=3
	next_branch :=7
--------GIMPLE Cond -------
 initssssss:= 0
 initssssss:= 1
node:= 4 
 	from_branch :=4
	next_branch :=5
	from_branch :=4
	next_branch :=6
--------GIMPLE Cond -------
 initssssss:= 0
 initssssss:= 1
node:= 5 
 	from_branch :=5
	next_branch :=10
node:= 6 
 	from_branch :=6
	next_branch :=10
node:= 7 
 	from_branch :=7
	next_branch :=8
	from_branch :=7
	next_branch :=9
--------GIMPLE Cond -------
 initssssss:= 0
 initssssss:= 1
node:= 8 
 	from_branch :=8
	next_branch :=10
node:= 9 
 	from_branch :=9
	next_branch :=10
node:= 10 
 	from_branch :=10
	next_branch :=11
	from_branch :=10
	next_branch :=12
--------GIMPLE Cond -------
 initssssss:= 0
 initssssss:= 1
node:= 11 
 	from_branch :=11
	next_branch :=12
node:= 12 
 	from_branch :=12
	next_branch :=13
	from_branch :=12
	next_branch :=14
--------GIMPLE Cond -------
 initssssss:= 0
 initssssss:= 1
node:= 13 
 	from_branch :=13
	next_branch :=18
node:= 14 
 	from_branch :=14
	next_branch :=15
	from_branch :=14
	next_branch :=16
--------GIMPLE Cond -------
 initssssss:= 0
 initssssss:= 1
node:= 15 
 	from_branch :=15
	next_branch :=18
node:= 16 
 	from_branch :=16
	next_branch :=17
	from_branch :=16
	next_branch :=18
--------GIMPLE Cond -------
 initssssss:= 0
 initssssss:= 1
node:= 17 
 	from_branch :=17
	next_branch :=18
=======node_fun:foo9=========
=======node_fun:foo=========
===============The first stage : Point of interest stmt collect=================
start PointerConstraint
pointer ftable is 1 
pointer ptable is 1 
===============The second stage : Mapping stmt=================
# .MEM_57 = VDEF <.MEM_56(D)>
p6_15 = malloc (100);
# .MEM_63 = VDEF <.MEM_62>
p9_24 = malloc (0);
# .MEM_64 = VDEF <.MEM_63>
_5 = malloc (1);
# .MEM_67 = VDEF <.MEM_66>
p_29 = malloc (10);
# .MEM_68 = VDEF <.MEM_67>
_6 = malloc (1);
# .MEM_70 = VDEF <.MEM_69>
_7 = malloc (1);
# .MEM_72 = VDEF <.MEM_71>
foo (p_29);
# .MEM_73 = VDEF <.MEM_72>
_8 = foo9 (p5_35(D));
# .MEM_74 = VDEF <.MEM_73>
foo9 (p5_37);
# .MEM_78 = VDEF <.MEM_74>
foo (p_29);
# .MEM_80 = VDEF <.MEM_78>
foo (p_29);
# .MEM_81 = VDEF <.MEM_80>
foo9 (p5_37);
# .MEM_79 = VDEF <.MEM_78>
foo (p_29);
# .MEM_75 = VDEF <.MEM_74>
foo (p_29);
# .MEM_77 = VDEF <.MEM_75>
foo (p3_43(D));
# .MEM_76 = VDEF <.MEM_75>
foo9 (p5_37);
# .MEM_82 = VDEF <.MEM_53>
foo (p_29);
# .MEM_86 = VDEF <.MEM_54>
foo9 (p5_37);
# .MEM_85 = VDEF <.MEM_54>
foo9 (p5_37);
# .MEM_83 = VDEF <.MEM_54>
foo9 (p5_37);
# .MEM_84 = VDEF <.MEM_83>
foo (p4_52(D));
start collect similar stmtstart collect similar stmtstart collect similar stmtstart collect similar stmt
start collect similar stmtstart collect similar stmtstart collect similar stmtstart collect similar stmt
start collect similar stmtstart collect similar stmtstart collect similar stmtstart collect similar stmt
start collect similar stmtstart collect similar stmtstart collect similar stmtstart collect similar stmt
start collect similar stmtstart collect similar stmtstart collect similar stmtstart collect similar stmt
===============The second stage : build fucntion type=================
[40;41mSTART CHECKSTART CHECKSTART CHECKSTART CHECKSTART CHECK[0m
[40;41mSTART CHECKSTART CHECKSTART CHECKSTART CHECKSTART CHECK[0m
    =()=
 ,/'_||_
  (___  `.
 ./  `=='
      |||
      |||
      |||
      |||
[40;41mSTART CHECKSTART CHECKSTART CHECKSTART CHECKSTART CHECK[0m
[40;41mSTART CHECKSTART CHECKSTART CHECKSTART CHECKSTART CHECK[0m
===============The second stage : record fucntion =================

=============== The third stage : Start detection  =================
[40;44m =======node_fun:main========= [0m
[40;44m fucntion collect path  [0m
[40;44m =======print_function_path main  function_call count: 5 level :0========  [0m
[40;44m =======print_function_type 0  ========  [0m
[40;42m =======pre add _ fucntion:foo========= [0m
[40;44m =======print_function_type 0  ========  [0m
[40;44m =======print_function_path foo  function_call count: 1 level :1========  [0m
[40;44m =======print_function_type 0  ========  [0m
[40;42m =======pre add _ fucntion:free========= [0m
[40;33m =======POP node_fun stack:free========= [0m
[40;42m =======pre_check_funciton:foo========= [0m
[40;42m =======start_check_funciton:foo========= [0m
[40;33m =======POP node_fun stack:foo========= [0m
[40;42m =======pre add _ fucntion:foo9========= [0m
[40;44m =======print_function_type 0  ========  [0m
[40;44m =======print_function_path foo9  function_call count: 1 level :1========  [0m
[40;44m =======print_function_type 0  ========  [0m
[40;42m =======pre add _ fucntion:free========= [0m
[40;33m =======POP node_fun stack:free========= [0m
[40;42m =======pre_check_funciton:foo9========= [0m
[40;42m =======start_check_funciton:foo9========= [0m
[40;33m =======POP node_fun stack:foo9========= [0m
[40;42m =======pre add _ fucntion:malloc========= [0m
[40;33m =======POP node_fun stack:malloc========= [0m
[40;42m =======pre add _ fucntion:free========= [0m
[40;33m =======POP node_fun stack:free========= [0m
[40;42m =======pre add _ fucntion:realloc========= [0m
[40;33m =======POP node_fun stack:realloc========= [0m
[40;42m =======pre_check_funciton:main========= [0m
[40;42m =======start_check_funciton:main========= [0m

dot graph START

======================================================================
 <ssa_name 0x7f971c2a0870
    type <pointer_type 0x7f971c2b49d8
        type <integer_type 0x7f971c2ad5e8 int public SI
            size <integer_cst 0x7f971c298df8 constant 32>
            unit-size <integer_cst 0x7f971c298e10 constant 4>
            align:32 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7f971c2ad5e8 precision:32 min <integer_cst 0x7f971c298db0 -2147483648> max <integer_cst 0x7f971c298dc8 2147483647>
            pointer_to_this <pointer_type 0x7f971c2b49d8>>
        public unsigned DI
        size <integer_cst 0x7f971c298bb8 constant 64>
        unit-size <integer_cst 0x7f971c298bd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
    var <var_decl 0x7f971cb40cf0 p6>
    def_stmt p6_15 = malloc (100);
    version:15
    ptr-info 0x7f971bdc5228>
# .MEM_57 = VDEF <.MEM_56(D)>
p6_15 = malloc (100);

 ================== trace ptable================== 
trace fucntion name:malloc 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr---malloc-----
this Reserved word function ------malloc-----
 
 Start check Pointer Collect  

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_62 = VDEF <.MEM_61>
MEM[(int *)p6_15 + 4B] = _4;
bb index := 2
# VUSE <.MEM_55>
return 0;
In function â€˜mainâ€™:
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
MEM[(int *)p6_15 + 4B] = _4;
test.c:61:14: warning: use location
   61 |         q[1] = "0";
      |              ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_62 = VDEF <.MEM_61>
MEM[(int *)p6_15 + 4B] = _4;
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
MEM[(int *)p6_15 + 4B] = _4;
test.c:61:14: warning: use location

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_61 = VDEF <.MEM_60>
*p6_15 = _2;
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
*p6_15 = _2;
test.c:60:14: warning: use location
   60 |         q[0] = "0";
      |              ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_61 = VDEF <.MEM_60>
*p6_15 = _2;
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
*p6_15 = _2;
test.c:60:14: warning: use location

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: use location
   57 |         p6 = realloc(p6, 100);
      |              ^
this stmt is child function---realloc-----

 ================== find ================== 
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: use location
[40;32m    FIND REALLOC STMT count:1 name:realloc [0m
[40;32m    this stmt possiable free memory [0m

 ================== find ================== 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: use location
   58 |         p7 = realloc(p6, 100);
      |              ^
this stmt is child function---realloc-----

 ================== find ================== 
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: use location
[40;32m    FIND REALLOC STMT count:2 name:realloc [0m
[40;32m    this stmt possiable free memory [0m

 ================== find ================== 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_60 = VDEF <.MEM_59>
*p7_19 = 48;
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
*p7_19 = 48;
test.c:59:15: warning: use location
   59 |         p7[0] = '0';
      |               ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_57 = VDEF <.MEM_56(D)>
p6_15 = malloc (100);
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
# .MEM_57 = VDEF <.MEM_56(D)>
p6_15 = malloc (100);
p6_15 = malloc (100);
test.c:54:19: warning: use location
   54 |         int *p6 = malloc(100);
      |                   ^
this stmt is child function---malloc-----

 ================== trace ================== 

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7f971c2a0870
    type <pointer_type 0x7f971c2b49d8
        type <integer_type 0x7f971c2ad5e8 int public SI
            size <integer_cst 0x7f971c298df8 constant 32>
            unit-size <integer_cst 0x7f971c298e10 constant 4>
            align:32 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7f971c2ad5e8 precision:32 min <integer_cst 0x7f971c298db0 -2147483648> max <integer_cst 0x7f971c298dc8 2147483647>
            pointer_to_this <pointer_type 0x7f971c2b49d8>>
        public unsigned DI
        size <integer_cst 0x7f971c298bb8 constant 64>
        unit-size <integer_cst 0x7f971c298bd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
    var <var_decl 0x7f971cb40cf0 p6>
    def_stmt p6_15 = malloc (100);
    version:15
    ptr-info 0x7f971bdc5228>
[40;35m <Looserules> find realloc stmt free same pointer [0m
*/If realloc() fails, the initial memory block will not be freed() */# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: use location
   57 |         p6 = realloc(p6, 100);
      |              ^
[40;35m <Looserules> find realloc stmt free same pointer [0m
*/If realloc() fails, the initial memory block will not be freed() */# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: use location
   58 |         p7 = realloc(p6, 100);
      |              ^

 ================== Start Use after free Check ================== 

============================================================
# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: Use after free error!: free location 
   57 |         p6 = realloc(p6, 100);
      |              ^
# .MEM_62 = VDEF <.MEM_61>
MEM[(int *)p6_15 + 4B] = _4;
test.c:61:14: warning: use location
   61 |         q[1] = "0";
      |              ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: Use after free error!: free location 
   58 |         p7 = realloc(p6, 100);
      |              ^
# .MEM_62 = VDEF <.MEM_61>
MEM[(int *)p6_15 + 4B] = _4;
test.c:61:14: warning: use location
   61 |         q[1] = "0";
      |              ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: Use after free error!: free location 
   57 |         p6 = realloc(p6, 100);
      |              ^
# .MEM_62 = VDEF <.MEM_61>
MEM[(int *)p6_15 + 4B] = _4;
test.c:61:14: warning: use location
   61 |         q[1] = "0";
      |              ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: Use after free error!: free location 
   58 |         p7 = realloc(p6, 100);
      |              ^
# .MEM_62 = VDEF <.MEM_61>
MEM[(int *)p6_15 + 4B] = _4;
test.c:61:14: warning: use location
   61 |         q[1] = "0";
      |              ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: Use after free error!: free location 
   57 |         p6 = realloc(p6, 100);
      |              ^
# .MEM_62 = VDEF <.MEM_61>
MEM[(int *)p6_15 + 4B] = _4;
test.c:61:14: warning: use location
   61 |         q[1] = "0";
      |              ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: Use after free error!: free location 
   58 |         p7 = realloc(p6, 100);
      |              ^
# .MEM_62 = VDEF <.MEM_61>
MEM[(int *)p6_15 + 4B] = _4;
test.c:61:14: warning: use location
   61 |         q[1] = "0";
      |              ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: Use after free error!: free location 
   57 |         p6 = realloc(p6, 100);
      |              ^
# .MEM_62 = VDEF <.MEM_61>
MEM[(int *)p6_15 + 4B] = _4;
test.c:61:14: warning: use location
   61 |         q[1] = "0";
      |              ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: Use after free error!: free location 
   58 |         p7 = realloc(p6, 100);
      |              ^
# .MEM_62 = VDEF <.MEM_61>
MEM[(int *)p6_15 + 4B] = _4;
test.c:61:14: warning: use location
   61 |         q[1] = "0";
      |              ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: Use after free error!: free location 
   57 |         p6 = realloc(p6, 100);
      |              ^
# .MEM_61 = VDEF <.MEM_60>
*p6_15 = _2;
test.c:60:14: warning: use location
   60 |         q[0] = "0";
      |              ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: Use after free error!: free location 
   58 |         p7 = realloc(p6, 100);
      |              ^
# .MEM_61 = VDEF <.MEM_60>
*p6_15 = _2;
test.c:60:14: warning: use location
   60 |         q[0] = "0";
      |              ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: Use after free error!: free location 
   57 |         p6 = realloc(p6, 100);
      |              ^
# .MEM_61 = VDEF <.MEM_60>
*p6_15 = _2;
test.c:60:14: warning: use location
   60 |         q[0] = "0";
      |              ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: Use after free error!: free location 
   58 |         p7 = realloc(p6, 100);
      |              ^
# .MEM_61 = VDEF <.MEM_60>
*p6_15 = _2;
test.c:60:14: warning: use location
   60 |         q[0] = "0";
      |              ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: Use after free error!: free location 
   57 |         p6 = realloc(p6, 100);
      |              ^
# .MEM_61 = VDEF <.MEM_60>
*p6_15 = _2;
test.c:60:14: warning: use location
   60 |         q[0] = "0";
      |              ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: Use after free error!: free location 
   58 |         p7 = realloc(p6, 100);
      |              ^
# .MEM_61 = VDEF <.MEM_60>
*p6_15 = _2;
test.c:60:14: warning: use location
   60 |         q[0] = "0";
      |              ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: Use after free error!: free location 
   57 |         p6 = realloc(p6, 100);
      |              ^
# .MEM_61 = VDEF <.MEM_60>
*p6_15 = _2;
test.c:60:14: warning: use location
   60 |         q[0] = "0";
      |              ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: Use after free error!: free location 
   58 |         p7 = realloc(p6, 100);
      |              ^
# .MEM_61 = VDEF <.MEM_60>
*p6_15 = _2;
test.c:60:14: warning: use location
   60 |         q[0] = "0";
      |              ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: Use after free error!: free location 
   57 |         p6 = realloc(p6, 100);
      |              ^
# .MEM_60 = VDEF <.MEM_59>
*p7_19 = 48;
test.c:59:15: warning: use location
   59 |         p7[0] = '0';
      |               ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: Use after free error!: free location 
   58 |         p7 = realloc(p6, 100);
      |              ^
# .MEM_60 = VDEF <.MEM_59>
*p7_19 = 48;
test.c:59:15: warning: use location
   59 |         p7[0] = '0';
      |               ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: Use after free error!: free location 
   57 |         p6 = realloc(p6, 100);
      |              ^
# .MEM_60 = VDEF <.MEM_59>
*p7_19 = 48;
test.c:59:15: warning: use location
   59 |         p7[0] = '0';
      |               ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: Use after free error!: free location 
   58 |         p7 = realloc(p6, 100);
      |              ^
# .MEM_60 = VDEF <.MEM_59>
*p7_19 = 48;
test.c:59:15: warning: use location
   59 |         p7[0] = '0';
      |               ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:2 [0m
[40;31m  	free count:2 [0m
[40;31m  	possible double free [Looserules]:2 [0m
[40;31m  	possible double free [rigorous]:2 [0m

======================================================================

======================================================================
[40;31m  	possible double free [rigorous]:2 [0m

======================================================================

dot graph START

======================================================================
 <ssa_name 0x7f971c2a08b8
    type <pointer_type 0x7f971c2b49d8
        type <integer_type 0x7f971c2ad5e8 int public SI
            size <integer_cst 0x7f971c298df8 constant 32>
            unit-size <integer_cst 0x7f971c298e10 constant 4>
            align:32 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7f971c2ad5e8 precision:32 min <integer_cst 0x7f971c298db0 -2147483648> max <integer_cst 0x7f971c298dc8 2147483647>
            pointer_to_this <pointer_type 0x7f971c2b49d8>>
        public unsigned DI
        size <integer_cst 0x7f971c298bb8 constant 64>
        unit-size <integer_cst 0x7f971c298bd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
    var <var_decl 0x7f971cb40cf0 p6>
    def_stmt p6_17 = realloc (p6_15, 100);
    version:17
    ptr-info 0x7f971bdc5240>
# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);

 ================== trace ptable================== 
trace fucntion name:realloc 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr---realloc-----
this Reserved word function ------realloc-----
 
 Start check Pointer Collect  

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_62 = VDEF <.MEM_61>
MEM[(int *)p6_15 + 4B] = _4;
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
MEM[(int *)p6_15 + 4B] = _4;
test.c:61:14: warning: use location
   61 |         q[1] = "0";
      |              ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_62 = VDEF <.MEM_61>
MEM[(int *)p6_15 + 4B] = _4;
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
MEM[(int *)p6_15 + 4B] = _4;
test.c:61:14: warning: use location

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_61 = VDEF <.MEM_60>
*p6_15 = _2;
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
*p6_15 = _2;
test.c:60:14: warning: use location
   60 |         q[0] = "0";
      |              ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_61 = VDEF <.MEM_60>
*p6_15 = _2;
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
*p6_15 = _2;
test.c:60:14: warning: use location

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: use location
   57 |         p6 = realloc(p6, 100);
      |              ^
this stmt is child function---realloc-----

 ================== find ================== 
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: use location
[40;32m    FIND REALLOC STMT count:1 name:realloc [0m
[40;32m    this stmt possiable free memory [0m

 ================== find ================== 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================

 Expand conflict 
 The same function may have multiple branches :realloc
# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: use location
# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: use location
   58 |         p7 = realloc(p6, 100);
      |              ^
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_60 = VDEF <.MEM_59>
*p7_19 = 48;
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
*p7_19 = 48;
test.c:59:15: warning: use location
   59 |         p7[0] = '0';
      |               ^

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7f971c2a08b8
    type <pointer_type 0x7f971c2b49d8
        type <integer_type 0x7f971c2ad5e8 int public SI
            size <integer_cst 0x7f971c298df8 constant 32>
            unit-size <integer_cst 0x7f971c298e10 constant 4>
            align:32 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7f971c2ad5e8 precision:32 min <integer_cst 0x7f971c298db0 -2147483648> max <integer_cst 0x7f971c298dc8 2147483647>
            pointer_to_this <pointer_type 0x7f971c2b49d8>>
        public unsigned DI
        size <integer_cst 0x7f971c298bb8 constant 64>
        unit-size <integer_cst 0x7f971c298bd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
    var <var_decl 0x7f971cb40cf0 p6>
    def_stmt p6_17 = realloc (p6_15, 100);
    version:17
    ptr-info 0x7f971bdc5240>
[40;35m <Looserules> find realloc stmt free same pointer [0m
*/If realloc() fails, the initial memory block will not be freed() */# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: use location
   57 |         p6 = realloc(p6, 100);
      |              ^
[40;35m <Looserules> find realloc stmt free same pointer [0m
*/If realloc() fails, the initial memory block will not be freed() */# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: use location
   58 |         p7 = realloc(p6, 100);
      |              ^

 ================== Start Use after free Check ================== 

============================================================
# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: Use after free error!: free location 
   57 |         p6 = realloc(p6, 100);
      |              ^
# .MEM_62 = VDEF <.MEM_61>
MEM[(int *)p6_15 + 4B] = _4;
test.c:61:14: warning: use location
   61 |         q[1] = "0";
      |              ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: Use after free error!: free location 
   57 |         p6 = realloc(p6, 100);
      |              ^
# .MEM_62 = VDEF <.MEM_61>
MEM[(int *)p6_15 + 4B] = _4;
test.c:61:14: warning: use location
   61 |         q[1] = "0";
      |              ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: Use after free error!: free location 
   58 |         p7 = realloc(p6, 100);
      |              ^
# .MEM_62 = VDEF <.MEM_61>
MEM[(int *)p6_15 + 4B] = _4;
test.c:61:14: warning: use location
   61 |         q[1] = "0";
      |              ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: Use after free error!: free location 
   57 |         p6 = realloc(p6, 100);
      |              ^
# .MEM_62 = VDEF <.MEM_61>
MEM[(int *)p6_15 + 4B] = _4;
test.c:61:14: warning: use location
   61 |         q[1] = "0";
      |              ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: Use after free error!: free location 
   57 |         p6 = realloc(p6, 100);
      |              ^
# .MEM_62 = VDEF <.MEM_61>
MEM[(int *)p6_15 + 4B] = _4;
test.c:61:14: warning: use location
   61 |         q[1] = "0";
      |              ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: Use after free error!: free location 
   58 |         p7 = realloc(p6, 100);
      |              ^
# .MEM_62 = VDEF <.MEM_61>
MEM[(int *)p6_15 + 4B] = _4;
test.c:61:14: warning: use location
   61 |         q[1] = "0";
      |              ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: Use after free error!: free location 
   57 |         p6 = realloc(p6, 100);
      |              ^
# .MEM_61 = VDEF <.MEM_60>
*p6_15 = _2;
test.c:60:14: warning: use location
   60 |         q[0] = "0";
      |              ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: Use after free error!: free location 
   57 |         p6 = realloc(p6, 100);
      |              ^
# .MEM_61 = VDEF <.MEM_60>
*p6_15 = _2;
test.c:60:14: warning: use location
   60 |         q[0] = "0";
      |              ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: Use after free error!: free location 
   58 |         p7 = realloc(p6, 100);
      |              ^
# .MEM_61 = VDEF <.MEM_60>
*p6_15 = _2;
test.c:60:14: warning: use location
   60 |         q[0] = "0";
      |              ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: Use after free error!: free location 
   57 |         p6 = realloc(p6, 100);
      |              ^
# .MEM_61 = VDEF <.MEM_60>
*p6_15 = _2;
test.c:60:14: warning: use location
   60 |         q[0] = "0";
      |              ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: Use after free error!: free location 
   57 |         p6 = realloc(p6, 100);
      |              ^
# .MEM_61 = VDEF <.MEM_60>
*p6_15 = _2;
test.c:60:14: warning: use location
   60 |         q[0] = "0";
      |              ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: Use after free error!: free location 
   58 |         p7 = realloc(p6, 100);
      |              ^
# .MEM_61 = VDEF <.MEM_60>
*p6_15 = _2;
test.c:60:14: warning: use location
   60 |         q[0] = "0";
      |              ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: Use after free error!: free location 
   57 |         p6 = realloc(p6, 100);
      |              ^
# .MEM_60 = VDEF <.MEM_59>
*p7_19 = 48;
test.c:59:15: warning: use location
   59 |         p7[0] = '0';
      |               ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: Use after free error!: free location 
   57 |         p6 = realloc(p6, 100);
      |              ^
# .MEM_60 = VDEF <.MEM_59>
*p7_19 = 48;
test.c:59:15: warning: use location
   59 |         p7[0] = '0';
      |               ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: Use after free error!: free location 
   58 |         p7 = realloc(p6, 100);
      |              ^
# .MEM_60 = VDEF <.MEM_59>
*p7_19 = 48;
test.c:59:15: warning: use location
   59 |         p7[0] = '0';
      |               ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:2 [0m
[40;31m  	free count:1 [0m
[40;31m  	possible double free [Looserules]:2 [0m

======================================================================

======================================================================
[40;32m   Maybe you don't have memory leak.... need more checks  [0m

======================================================================


dot graph START

======================================================================
 <ssa_name 0x7f971c2a0900
    type <pointer_type 0x7f971c2b49d8
        type <integer_type 0x7f971c2ad5e8 int public SI
            size <integer_cst 0x7f971c298df8 constant 32>
            unit-size <integer_cst 0x7f971c298e10 constant 4>
            align:32 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7f971c2ad5e8 precision:32 min <integer_cst 0x7f971c298db0 -2147483648> max <integer_cst 0x7f971c298dc8 2147483647>
            pointer_to_this <pointer_type 0x7f971c2b49d8>>
        public unsigned DI
        size <integer_cst 0x7f971c298bb8 constant 64>
        unit-size <integer_cst 0x7f971c298bd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
    var <var_decl 0x7f971cb40c60 p7>
    def_stmt p7_19 = realloc (p6_17, 100);
    version:19
    ptr-info 0x7f971bdc5258>
# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);

 ================== trace ptable================== 
trace fucntion name:realloc 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr---realloc-----
this Reserved word function ------realloc-----
 
 Start check Pointer Collect  

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: use location
   58 |         p7 = realloc(p6, 100);
      |              ^
this stmt is child function---realloc-----

 ================== find ================== 
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: use location
[40;32m    FIND REALLOC STMT count:1 name:realloc [0m
[40;32m    this stmt possiable free memory [0m

 ================== find ================== 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_60 = VDEF <.MEM_59>
*p7_19 = 48;
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
*p7_19 = 48;
test.c:59:15: warning: use location
   59 |         p7[0] = '0';
      |               ^

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7f971c2a0900
    type <pointer_type 0x7f971c2b49d8
        type <integer_type 0x7f971c2ad5e8 int public SI
            size <integer_cst 0x7f971c298df8 constant 32>
            unit-size <integer_cst 0x7f971c298e10 constant 4>
            align:32 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7f971c2ad5e8 precision:32 min <integer_cst 0x7f971c298db0 -2147483648> max <integer_cst 0x7f971c298dc8 2147483647>
            pointer_to_this <pointer_type 0x7f971c2b49d8>>
        public unsigned DI
        size <integer_cst 0x7f971c298bb8 constant 64>
        unit-size <integer_cst 0x7f971c298bd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
    var <var_decl 0x7f971cb40c60 p7>
    def_stmt p7_19 = realloc (p6_17, 100);
    version:19
    ptr-info 0x7f971bdc5258>
[40;35m <Looserules> find realloc stmt free same pointer [0m
*/If realloc() fails, the initial memory block will not be freed() */# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: use location
   57 |         p6 = realloc(p6, 100);
      |              ^
[40;35m <Looserules> find realloc stmt free same pointer [0m
*/If realloc() fails, the initial memory block will not be freed() */# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: use location
   58 |         p7 = realloc(p6, 100);
      |              ^

 ================== Start Use after free Check ================== 

============================================================
# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: Use after free error!: free location 
# .MEM_60 = VDEF <.MEM_59>
*p7_19 = 48;
test.c:59:15: warning: use location
   59 |         p7[0] = '0';
      |               ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: Use after free error!: free location 
   57 |         p6 = realloc(p6, 100);
      |              ^
# .MEM_60 = VDEF <.MEM_59>
*p7_19 = 48;
test.c:59:15: warning: use location
   59 |         p7[0] = '0';
      |               ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: Use after free error!: free location 
   58 |         p7 = realloc(p6, 100);
      |              ^
# .MEM_60 = VDEF <.MEM_59>
*p7_19 = 48;
test.c:59:15: warning: use location
   59 |         p7[0] = '0';
      |               ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:2 [0m
[40;31m  	free count:1 [0m
[40;31m  	possible double free [Looserules]:2 [0m

======================================================================

======================================================================
[40;32m   Maybe you don't have memory leak.... need more checks  [0m

======================================================================


dot graph START

======================================================================
 <ssa_name 0x7f971c2a0948
    type <pointer_type 0x7f971bdb7348
        type <record_type 0x7f971bdb7f18 st TI
            size <integer_cst 0x7f971c298c00 constant 128>
            unit-size <integer_cst 0x7f971c298c18 constant 16>
            align:64 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7f971bdb7f18 fields <field_decl 0x7f971bdba1c8 flag> context <translation_unit_decl 0x7f971c2a3168 test.c>
            pointer_to_this <pointer_type 0x7f971bdb7348>>
        unsigned DI
        size <integer_cst 0x7f971c298bb8 constant 64>
        unit-size <integer_cst 0x7f971c298bd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
    var <var_decl 0x7f971cb40bd0 p9>
    def_stmt p9_24 = malloc (0);
    version:24
    ptr-info 0x7f971bdc5270>
# .MEM_63 = VDEF <.MEM_62>
p9_24 = malloc (0);

 ================== trace ptable================== 
trace fucntion name:malloc 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr---malloc-----
this Reserved word function ------malloc-----
 
 Start check Pointer Collect  

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_66 = VDEF <.MEM_65>
free (p9_24);
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
free (p9_24);
test.c:74:9: warning: use location
   74 |         free(p9);
      |         ^
this stmt is child function---free-----

 ================== find ================== 
free (p9_24);
test.c:74:9: warning: use location
[40;32m    HAS FREE STMT count:1 name:free [0m

 ================== find ================== 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_65 = VDEF <.MEM_64>
MEM[(struct st *)p9_24 + 48B].f = _5;
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
MEM[(struct st *)p9_24 + 48B].f = _5;
test.c:73:17: warning: use location
   73 |         p9[3].f = malloc(1);
      |                 ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_65 = VDEF <.MEM_64>
MEM[(struct st *)p9_24 + 48B].f = _5;
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
MEM[(struct st *)p9_24 + 48B].f = _5;
test.c:73:17: warning: use location

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_63 = VDEF <.MEM_62>
p9_24 = malloc (0);
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
# .MEM_63 = VDEF <.MEM_62>
p9_24 = malloc (0);
p9_24 = malloc (0);
test.c:72:25: warning: use location
   72 |         struct st *p9 = malloc(0);
      |                         ^
this stmt is child function---malloc-----

 ================== trace ================== 

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7f971c2a0948
    type <pointer_type 0x7f971bdb7348
        type <record_type 0x7f971bdb7f18 st TI
            size <integer_cst 0x7f971c298c00 constant 128>
            unit-size <integer_cst 0x7f971c298c18 constant 16>
            align:64 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7f971bdb7f18 fields <field_decl 0x7f971bdba1c8 flag> context <translation_unit_decl 0x7f971c2a3168 test.c>
            pointer_to_this <pointer_type 0x7f971bdb7348>>
        unsigned DI
        size <integer_cst 0x7f971c298bb8 constant 64>
        unit-size <integer_cst 0x7f971c298bd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
    var <var_decl 0x7f971cb40bd0 p9>
    def_stmt p9_24 = malloc (0);
    version:24
    ptr-info 0x7f971bdc5270>
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_66 = VDEF <.MEM_65>
free (p9_24);
test.c:74:9: warning: use location
   74 |         free(p9);
      |         ^

 ================== Start Use after free Check ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:1 [0m
[40;31m  	free count:1 [0m

======================================================================

======================================================================
[40;32m   Maybe you don't have memory leak.... need more checks  [0m

======================================================================


dot graph START

======================================================================
 <ssa_name 0x7f971c2a0708
    type <pointer_type 0x7f971c2b4000
        type <void_type 0x7f971c2adf18 void VOID
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality
            pointer_to_this <pointer_type 0x7f971c2b4000>>
        public unsigned DI
        size <integer_cst 0x7f971c298bb8 constant 64>
        unit-size <integer_cst 0x7f971c298bd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality
        pointer_to_this <pointer_type 0x7f971c2b99d8>>
   
    def_stmt _5 = malloc (1);
    version:5
    ptr-info 0x7f971bdc51e0>
# .MEM_64 = VDEF <.MEM_63>
_5 = malloc (1);

 ================== trace ptable================== 
trace fucntion name:malloc 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr---malloc-----
this Reserved word function ------malloc-----
 
 Start check Pointer Collect  

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_65 = VDEF <.MEM_64>
MEM[(struct st *)p9_24 + 48B].f = _5;
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
MEM[(struct st *)p9_24 + 48B].f = _5;
test.c:73:17: warning: use location
   73 |         p9[3].f = malloc(1);
      |                 ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_65 = VDEF <.MEM_64>
MEM[(struct st *)p9_24 + 48B].f = _5;
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
MEM[(struct st *)p9_24 + 48B].f = _5;
test.c:73:17: warning: use location

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_66 = VDEF <.MEM_65>
free (p9_24);
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
free (p9_24);
test.c:74:9: warning: use location
   74 |         free(p9);
      |         ^
this stmt is child function---free-----

 ================== find ================== 
free (p9_24);
test.c:74:9: warning: use location
[40;32m    HAS FREE STMT count:1 name:free [0m

 ================== find ================== 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_64 = VDEF <.MEM_63>
_5 = malloc (1);
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
# .MEM_64 = VDEF <.MEM_63>
_5 = malloc (1);
_5 = malloc (1);
test.c:73:19: warning: use location
   73 |         p9[3].f = malloc(1);
      |                   ^
this stmt is child function---malloc-----

 ================== trace ================== 

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7f971c2a0708
    type <pointer_type 0x7f971c2b4000
        type <void_type 0x7f971c2adf18 void VOID
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality
            pointer_to_this <pointer_type 0x7f971c2b4000>>
        public unsigned DI
        size <integer_cst 0x7f971c298bb8 constant 64>
        unit-size <integer_cst 0x7f971c298bd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality
        pointer_to_this <pointer_type 0x7f971c2b99d8>>
   
    def_stmt _5 = malloc (1);
    version:5
    ptr-info 0x7f971bdc51e0>

 ================== Start Use after free Check ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:0 [0m
[40;31m  	free count:1 [0m

======================================================================

======================================================================
[40;32m   Maybe you don't have memory leak.... need more checks  [0m

======================================================================


dot graph START

======================================================================
 <ssa_name 0x7f971c2a0990
    type <pointer_type 0x7f971bdb7348
        type <record_type 0x7f971bdb7f18 st TI
            size <integer_cst 0x7f971c298c00 constant 128>
            unit-size <integer_cst 0x7f971c298c18 constant 16>
            align:64 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7f971bdb7f18 fields <field_decl 0x7f971bdba1c8 flag> context <translation_unit_decl 0x7f971c2a3168 test.c>
            pointer_to_this <pointer_type 0x7f971bdb7348>>
        unsigned DI
        size <integer_cst 0x7f971c298bb8 constant 64>
        unit-size <integer_cst 0x7f971c298bd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
    var <var_decl 0x7f971cb40b40 p>
    def_stmt p_29 = malloc (10);
    version:29
    ptr-info 0x7f971bdc5288>
# .MEM_67 = VDEF <.MEM_66>
p_29 = malloc (10);

 ================== trace ptable================== 
trace fucntion name:malloc 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr---malloc-----
this Reserved word function ------malloc-----
 
 Start check Pointer Collect  

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_82 = VDEF <.MEM_53>
foo (p_29);
bb index := 11
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 11 ,possiable got to succ := 18

======================================================================
foo (p_29);
test.c:145:25: warning: use location
  145 |                         foo(p);
      |                         ^
this stmt is child function---foo-----

 ================== trace ================== 
trace fucntion name:foo 
[40;44m =======trace_function_path foo  function_call count: 1 level :0========  [0m
# .MEM_4 = VDEF <.MEM_3(D)>
free (z_2(D));
[40;31m  find free stmt free same pointer [0m
# .MEM_4 = VDEF <.MEM_3(D)>
free (z_2(D));
test.c:29:9: warning: use location
   29 |         free(z);
      |         ^
[40;36m ======= node_fun:foo========= [0m
[40;36m ======= find relate stmt with p ========= [0m
[40;36m ======= relate stmt argument:p ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:free========= [0m
[40;46m =======add node_fun stack:free========= [0m

 ================== trace ================== 
trace fucntion free:1 
foo (p_29);
test.c:134:25: warning: use location
  134 |                         foo(p);
      |                         ^
this stmt is child function---foo-----

 ================== trace ================== 
trace fucntion name:foo 
[40;44m =======trace_function_path foo  function_call count: 1 level :0========  [0m
# .MEM_4 = VDEF <.MEM_3(D)>
free (z_2(D));
[40;31m  find free stmt free same pointer [0m
# .MEM_4 = VDEF <.MEM_3(D)>
free (z_2(D));
test.c:29:9: warning: use location
   29 |         free(z);
      |         ^
[40;36m ======= node_fun:foo========= [0m
[40;36m ======= find relate stmt with p ========= [0m
[40;36m ======= relate stmt argument:p ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:free========= [0m
[40;46m =======add node_fun stack:free========= [0m

 ================== trace ================== 
trace fucntion free:2 
foo (p_29);
test.c:130:33: warning: use location
  130 |                                 foo(p);
      |                                 ^
this stmt is child function---foo-----

 ================== trace ================== 
trace fucntion name:foo 
[40;44m =======trace_function_path foo  function_call count: 1 level :0========  [0m
# .MEM_4 = VDEF <.MEM_3(D)>
free (z_2(D));
[40;31m  find free stmt free same pointer [0m
# .MEM_4 = VDEF <.MEM_3(D)>
free (z_2(D));
test.c:29:9: warning: use location
   29 |         free(z);
      |         ^
[40;36m ======= node_fun:foo========= [0m
[40;36m ======= find relate stmt with p ========= [0m
[40;36m ======= relate stmt argument:p ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:free========= [0m
[40;46m =======add node_fun stack:free========= [0m

 ================== trace ================== 
trace fucntion free:3 
foo (p_29);
test.c:126:33: warning: use location
  126 |                                 foo(p);
      |                                 ^
this stmt is child function---foo-----

 ================== trace ================== 
trace fucntion name:foo 
[40;44m =======trace_function_path foo  function_call count: 1 level :0========  [0m
# .MEM_4 = VDEF <.MEM_3(D)>
free (z_2(D));
[40;31m  find free stmt free same pointer [0m
# .MEM_4 = VDEF <.MEM_3(D)>
free (z_2(D));
test.c:29:9: warning: use location
   29 |         free(z);
      |         ^
[40;36m ======= node_fun:foo========= [0m
[40;36m ======= find relate stmt with p ========= [0m
[40;36m ======= relate stmt argument:p ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:free========= [0m
[40;46m =======add node_fun stack:free========= [0m

 ================== trace ================== 
trace fucntion free:4 
foo (p_29);
test.c:123:25: warning: use location
  123 |                         foo(p);
      |                         ^
this stmt is child function---foo-----

 ================== trace ================== 
trace fucntion name:foo 
[40;44m =======trace_function_path foo  function_call count: 1 level :0========  [0m
# .MEM_4 = VDEF <.MEM_3(D)>
free (z_2(D));
[40;31m  find free stmt free same pointer [0m
# .MEM_4 = VDEF <.MEM_3(D)>
free (z_2(D));
test.c:29:9: warning: use location
   29 |         free(z);
      |         ^
[40;36m ======= node_fun:foo========= [0m
[40;36m ======= find relate stmt with p ========= [0m
[40;36m ======= relate stmt argument:p ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:free========= [0m
[40;46m =======add node_fun stack:free========= [0m

 ================== trace ================== 
trace fucntion free:5 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_72 = VDEF <.MEM_71>
foo (p_29);
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
foo (p_29);
test.c:80:9: warning: use location
   80 |         foo(p);
      |         ^
this stmt is child function---foo-----

 ================== trace ================== 
trace fucntion name:foo 
[40;44m =======trace_function_path foo  function_call count: 1 level :0========  [0m
# .MEM_4 = VDEF <.MEM_3(D)>
free (z_2(D));
[40;31m  find free stmt free same pointer [0m
# .MEM_4 = VDEF <.MEM_3(D)>
free (z_2(D));
test.c:29:9: warning: use location
   29 |         free(z);
      |         ^
[40;36m ======= node_fun:foo========= [0m
[40;36m ======= find relate stmt with p ========= [0m
[40;36m ======= relate stmt argument:p ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:free========= [0m
[40;46m =======add node_fun stack:free========= [0m

 ================== trace ================== 
trace fucntion free:6 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_71 = VDEF <.MEM_70>
MEM[(struct st *)p_29 + 32B].f = _7;
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
MEM[(struct st *)p_29 + 32B].f = _7;
test.c:79:16: warning: use location
   79 |         p[2].f = malloc(1);
      |                ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_71 = VDEF <.MEM_70>
MEM[(struct st *)p_29 + 32B].f = _7;
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
MEM[(struct st *)p_29 + 32B].f = _7;
test.c:79:16: warning: use location

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_69 = VDEF <.MEM_68>
MEM[(struct st *)p_29 + 48B].f = _6;
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
MEM[(struct st *)p_29 + 48B].f = _6;
test.c:76:16: warning: use location
   76 |         p[3].f = malloc(1);
      |                ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_69 = VDEF <.MEM_68>
MEM[(struct st *)p_29 + 48B].f = _6;
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
MEM[(struct st *)p_29 + 48B].f = _6;
test.c:76:16: warning: use location

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_67 = VDEF <.MEM_66>
p_29 = malloc (10);
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
# .MEM_67 = VDEF <.MEM_66>
p_29 = malloc (10);
p_29 = malloc (10);
test.c:75:24: warning: use location
   75 |         struct st *p = malloc(10);
      |                        ^
this stmt is child function---malloc-----

 ================== trace ================== 

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7f971c2a0990
    type <pointer_type 0x7f971bdb7348
        type <record_type 0x7f971bdb7f18 st TI
            size <integer_cst 0x7f971c298c00 constant 128>
            unit-size <integer_cst 0x7f971c298c18 constant 16>
            align:64 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7f971bdb7f18 fields <field_decl 0x7f971bdba1c8 flag> context <translation_unit_decl 0x7f971c2a3168 test.c>
            pointer_to_this <pointer_type 0x7f971bdb7348>>
        unsigned DI
        size <integer_cst 0x7f971c298bb8 constant 64>
        unit-size <integer_cst 0x7f971c298bd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
    var <var_decl 0x7f971cb40b40 p>
    def_stmt p_29 = malloc (10);
    version:29
    ptr-info 0x7f971bdc5288>

 ================== Start Use after free Check ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:0 [0m
[40;31m  	free count:6 [0m
[40;31m  	possible double free [rigorous]:6 [0m

======================================================================

======================================================================
[40;31m  	possible double free [rigorous]:6 [0m

======================================================================

dot graph START

======================================================================
 <ssa_name 0x7f971c2a0750
    type <pointer_type 0x7f971c2b4000
        type <void_type 0x7f971c2adf18 void VOID
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality
            pointer_to_this <pointer_type 0x7f971c2b4000>>
        public unsigned DI
        size <integer_cst 0x7f971c298bb8 constant 64>
        unit-size <integer_cst 0x7f971c298bd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality
        pointer_to_this <pointer_type 0x7f971c2b99d8>>
   
    def_stmt _6 = malloc (1);
    version:6
    ptr-info 0x7f971bdc51f8>
# .MEM_68 = VDEF <.MEM_67>
_6 = malloc (1);

 ================== trace ptable================== 
trace fucntion name:malloc 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr---malloc-----
this Reserved word function ------malloc-----
 
 Start check Pointer Collect  

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_69 = VDEF <.MEM_68>
MEM[(struct st *)p_29 + 48B].f = _6;
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
MEM[(struct st *)p_29 + 48B].f = _6;
test.c:76:16: warning: use location
   76 |         p[3].f = malloc(1);
      |                ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_69 = VDEF <.MEM_68>
MEM[(struct st *)p_29 + 48B].f = _6;
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
MEM[(struct st *)p_29 + 48B].f = _6;
test.c:76:16: warning: use location

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_82 = VDEF <.MEM_53>
foo (p_29);
bb index := 11
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 11 ,possiable got to succ := 18

======================================================================
foo (p_29);
test.c:145:25: warning: use location
  145 |                         foo(p);
      |                         ^
this stmt is child function---foo-----

 ================== trace ================== 
trace fucntion name:foo 
[40;44m =======trace_function_path foo  function_call count: 1 level :0========  [0m
# .MEM_4 = VDEF <.MEM_3(D)>
free (z_2(D));
[40;36m ======= node_fun:foo========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:free========= [0m
[40;46m =======add node_fun stack:free========= [0m

 ================== trace ================== 
trace fucntion free:0 
foo (p_29);
test.c:134:25: warning: use location
  134 |                         foo(p);
      |                         ^
this stmt is child function---foo-----

 ================== trace ================== 
trace fucntion name:foo 
[40;44m =======trace_function_path foo  function_call count: 1 level :0========  [0m
# .MEM_4 = VDEF <.MEM_3(D)>
free (z_2(D));
[40;36m ======= node_fun:foo========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:free========= [0m
[40;46m =======add node_fun stack:free========= [0m

 ================== trace ================== 
trace fucntion free:0 
foo (p_29);
test.c:130:33: warning: use location
  130 |                                 foo(p);
      |                                 ^
this stmt is child function---foo-----

 ================== trace ================== 
trace fucntion name:foo 
[40;44m =======trace_function_path foo  function_call count: 1 level :0========  [0m
# .MEM_4 = VDEF <.MEM_3(D)>
free (z_2(D));
[40;36m ======= node_fun:foo========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:free========= [0m
[40;46m =======add node_fun stack:free========= [0m

 ================== trace ================== 
trace fucntion free:0 
foo (p_29);
test.c:126:33: warning: use location
  126 |                                 foo(p);
      |                                 ^
this stmt is child function---foo-----

 ================== trace ================== 
trace fucntion name:foo 
[40;44m =======trace_function_path foo  function_call count: 1 level :0========  [0m
# .MEM_4 = VDEF <.MEM_3(D)>
free (z_2(D));
[40;36m ======= node_fun:foo========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:free========= [0m
[40;46m =======add node_fun stack:free========= [0m

 ================== trace ================== 
trace fucntion free:0 
foo (p_29);
test.c:123:25: warning: use location
  123 |                         foo(p);
      |                         ^
this stmt is child function---foo-----

 ================== trace ================== 
trace fucntion name:foo 
[40;44m =======trace_function_path foo  function_call count: 1 level :0========  [0m
# .MEM_4 = VDEF <.MEM_3(D)>
free (z_2(D));
[40;36m ======= node_fun:foo========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:free========= [0m
[40;46m =======add node_fun stack:free========= [0m

 ================== trace ================== 
trace fucntion free:0 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_72 = VDEF <.MEM_71>
foo (p_29);
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
foo (p_29);
test.c:80:9: warning: use location
   80 |         foo(p);
      |         ^
this stmt is child function---foo-----

 ================== trace ================== 
trace fucntion name:foo 
[40;44m =======trace_function_path foo  function_call count: 1 level :0========  [0m
# .MEM_4 = VDEF <.MEM_3(D)>
free (z_2(D));
[40;36m ======= node_fun:foo========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:free========= [0m
[40;46m =======add node_fun stack:free========= [0m

 ================== trace ================== 
trace fucntion free:0 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_71 = VDEF <.MEM_70>
MEM[(struct st *)p_29 + 32B].f = _7;
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
MEM[(struct st *)p_29 + 32B].f = _7;
test.c:79:16: warning: use location
   79 |         p[2].f = malloc(1);
      |                ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_71 = VDEF <.MEM_70>
MEM[(struct st *)p_29 + 32B].f = _7;
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
MEM[(struct st *)p_29 + 32B].f = _7;
test.c:79:16: warning: use location

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_68 = VDEF <.MEM_67>
_6 = malloc (1);
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
# .MEM_68 = VDEF <.MEM_67>
_6 = malloc (1);
_6 = malloc (1);
test.c:76:18: warning: use location
   76 |         p[3].f = malloc(1);
      |                  ^
this stmt is child function---malloc-----

 ================== trace ================== 

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7f971c2a0750
    type <pointer_type 0x7f971c2b4000
        type <void_type 0x7f971c2adf18 void VOID
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality
            pointer_to_this <pointer_type 0x7f971c2b4000>>
        public unsigned DI
        size <integer_cst 0x7f971c298bb8 constant 64>
        unit-size <integer_cst 0x7f971c298bd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality
        pointer_to_this <pointer_type 0x7f971c2b99d8>>
   
    def_stmt _6 = malloc (1);
    version:6
    ptr-info 0x7f971bdc51f8>

 ================== Start Use after free Check ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:0 [0m
[40;31m  	free count:0 [0m

======================================================================

======================================================================
[40;31m    no free stmt possible memory leak [0m

======================================================================

dot graph START

======================================================================
 <ssa_name 0x7f971c2a0798
    type <pointer_type 0x7f971c2b4000
        type <void_type 0x7f971c2adf18 void VOID
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality
            pointer_to_this <pointer_type 0x7f971c2b4000>>
        public unsigned DI
        size <integer_cst 0x7f971c298bb8 constant 64>
        unit-size <integer_cst 0x7f971c298bd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality
        pointer_to_this <pointer_type 0x7f971c2b99d8>>
   
    def_stmt _7 = malloc (1);
    version:7
    ptr-info 0x7f971bdc5210>
# .MEM_70 = VDEF <.MEM_69>
_7 = malloc (1);

 ================== trace ptable================== 
trace fucntion name:malloc 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr---malloc-----
this Reserved word function ------malloc-----
 
 Start check Pointer Collect  

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_71 = VDEF <.MEM_70>
MEM[(struct st *)p_29 + 32B].f = _7;
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
MEM[(struct st *)p_29 + 32B].f = _7;
test.c:79:16: warning: use location
   79 |         p[2].f = malloc(1);
      |                ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_71 = VDEF <.MEM_70>
MEM[(struct st *)p_29 + 32B].f = _7;
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
MEM[(struct st *)p_29 + 32B].f = _7;
test.c:79:16: warning: use location

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_82 = VDEF <.MEM_53>
foo (p_29);
bb index := 11
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 11 ,possiable got to succ := 18

======================================================================
foo (p_29);
test.c:145:25: warning: use location
  145 |                         foo(p);
      |                         ^
this stmt is child function---foo-----

 ================== trace ================== 
trace fucntion name:foo 
[40;44m =======trace_function_path foo  function_call count: 1 level :0========  [0m
# .MEM_4 = VDEF <.MEM_3(D)>
free (z_2(D));
[40;36m ======= node_fun:foo========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:free========= [0m
[40;46m =======add node_fun stack:free========= [0m

 ================== trace ================== 
trace fucntion free:0 
foo (p_29);
test.c:134:25: warning: use location
  134 |                         foo(p);
      |                         ^
this stmt is child function---foo-----

 ================== trace ================== 
trace fucntion name:foo 
[40;44m =======trace_function_path foo  function_call count: 1 level :0========  [0m
# .MEM_4 = VDEF <.MEM_3(D)>
free (z_2(D));
[40;36m ======= node_fun:foo========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:free========= [0m
[40;46m =======add node_fun stack:free========= [0m

 ================== trace ================== 
trace fucntion free:0 
foo (p_29);
test.c:130:33: warning: use location
  130 |                                 foo(p);
      |                                 ^
this stmt is child function---foo-----

 ================== trace ================== 
trace fucntion name:foo 
[40;44m =======trace_function_path foo  function_call count: 1 level :0========  [0m
# .MEM_4 = VDEF <.MEM_3(D)>
free (z_2(D));
[40;36m ======= node_fun:foo========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:free========= [0m
[40;46m =======add node_fun stack:free========= [0m

 ================== trace ================== 
trace fucntion free:0 
foo (p_29);
test.c:126:33: warning: use location
  126 |                                 foo(p);
      |                                 ^
this stmt is child function---foo-----

 ================== trace ================== 
trace fucntion name:foo 
[40;44m =======trace_function_path foo  function_call count: 1 level :0========  [0m
# .MEM_4 = VDEF <.MEM_3(D)>
free (z_2(D));
[40;36m ======= node_fun:foo========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:free========= [0m
[40;46m =======add node_fun stack:free========= [0m

 ================== trace ================== 
trace fucntion free:0 
foo (p_29);
test.c:123:25: warning: use location
  123 |                         foo(p);
      |                         ^
this stmt is child function---foo-----

 ================== trace ================== 
trace fucntion name:foo 
[40;44m =======trace_function_path foo  function_call count: 1 level :0========  [0m
# .MEM_4 = VDEF <.MEM_3(D)>
free (z_2(D));
[40;36m ======= node_fun:foo========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:free========= [0m
[40;46m =======add node_fun stack:free========= [0m

 ================== trace ================== 
trace fucntion free:0 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_72 = VDEF <.MEM_71>
foo (p_29);
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
foo (p_29);
test.c:80:9: warning: use location
   80 |         foo(p);
      |         ^
this stmt is child function---foo-----

 ================== trace ================== 
trace fucntion name:foo 
[40;44m =======trace_function_path foo  function_call count: 1 level :0========  [0m
# .MEM_4 = VDEF <.MEM_3(D)>
free (z_2(D));
[40;36m ======= node_fun:foo========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:free========= [0m
[40;46m =======add node_fun stack:free========= [0m

 ================== trace ================== 
trace fucntion free:0 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_69 = VDEF <.MEM_68>
MEM[(struct st *)p_29 + 48B].f = _6;
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
MEM[(struct st *)p_29 + 48B].f = _6;
test.c:76:16: warning: use location
   76 |         p[3].f = malloc(1);
      |                ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_69 = VDEF <.MEM_68>
MEM[(struct st *)p_29 + 48B].f = _6;
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
MEM[(struct st *)p_29 + 48B].f = _6;
test.c:76:16: warning: use location

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_70 = VDEF <.MEM_69>
_7 = malloc (1);
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
# .MEM_70 = VDEF <.MEM_69>
_7 = malloc (1);
_7 = malloc (1);
test.c:79:18: warning: use location
   79 |         p[2].f = malloc(1);
      |                  ^
this stmt is child function---malloc-----

 ================== trace ================== 

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7f971c2a0798
    type <pointer_type 0x7f971c2b4000
        type <void_type 0x7f971c2adf18 void VOID
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality
            pointer_to_this <pointer_type 0x7f971c2b4000>>
        public unsigned DI
        size <integer_cst 0x7f971c298bb8 constant 64>
        unit-size <integer_cst 0x7f971c298bd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality
        pointer_to_this <pointer_type 0x7f971c2b99d8>>
   
    def_stmt _7 = malloc (1);
    version:7
    ptr-info 0x7f971bdc5210>

 ================== Start Use after free Check ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:0 [0m
[40;31m  	free count:0 [0m

======================================================================

======================================================================
[40;31m    no free stmt possible memory leak [0m

======================================================================

dot graph START

======================================================================
 <ssa_name 0x7f971c2a0798
    type <pointer_type 0x7f971c2b4000
        type <void_type 0x7f971c2adf18 void VOID
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality
            pointer_to_this <pointer_type 0x7f971c2b4000>>
        public unsigned DI
        size <integer_cst 0x7f971c298bb8 constant 64>
        unit-size <integer_cst 0x7f971c298bd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality
        pointer_to_this <pointer_type 0x7f971c2b99d8>>
   
    def_stmt _7 = malloc (1);
    version:7
    ptr-info 0x7f971bdc5210>
# .MEM_70 = VDEF <.MEM_69>
_7 = malloc (1);

 ================== trace ptable================== 
trace fucntion name:malloc 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr---malloc-----
this Reserved word function ------malloc-----
 
 Start check Pointer Collect  

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_71 = VDEF <.MEM_70>
MEM[(struct st *)p_29 + 32B].f = _7;
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
MEM[(struct st *)p_29 + 32B].f = _7;
test.c:79:16: warning: use location
   79 |         p[2].f = malloc(1);
      |                ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_71 = VDEF <.MEM_70>
MEM[(struct st *)p_29 + 32B].f = _7;
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
MEM[(struct st *)p_29 + 32B].f = _7;
test.c:79:16: warning: use location

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_82 = VDEF <.MEM_53>
foo (p_29);
bb index := 11
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 11 ,possiable got to succ := 18

======================================================================
foo (p_29);
test.c:145:25: warning: use location
  145 |                         foo(p);
      |                         ^
this stmt is child function---foo-----

 ================== trace ================== 
trace fucntion name:foo 
[40;44m =======trace_function_path foo  function_call count: 1 level :0========  [0m
# .MEM_4 = VDEF <.MEM_3(D)>
free (z_2(D));
[40;36m ======= node_fun:foo========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:free========= [0m
[40;46m =======add node_fun stack:free========= [0m

 ================== trace ================== 
trace fucntion free:0 
foo (p_29);
test.c:134:25: warning: use location
  134 |                         foo(p);
      |                         ^
this stmt is child function---foo-----

 ================== trace ================== 
trace fucntion name:foo 
[40;44m =======trace_function_path foo  function_call count: 1 level :0========  [0m
# .MEM_4 = VDEF <.MEM_3(D)>
free (z_2(D));
[40;36m ======= node_fun:foo========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:free========= [0m
[40;46m =======add node_fun stack:free========= [0m

 ================== trace ================== 
trace fucntion free:0 
foo (p_29);
test.c:130:33: warning: use location
  130 |                                 foo(p);
      |                                 ^
this stmt is child function---foo-----

 ================== trace ================== 
trace fucntion name:foo 
[40;44m =======trace_function_path foo  function_call count: 1 level :0========  [0m
# .MEM_4 = VDEF <.MEM_3(D)>
free (z_2(D));
[40;36m ======= node_fun:foo========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:free========= [0m
[40;46m =======add node_fun stack:free========= [0m

 ================== trace ================== 
trace fucntion free:0 
foo (p_29);
test.c:126:33: warning: use location
  126 |                                 foo(p);
      |                                 ^
this stmt is child function---foo-----

 ================== trace ================== 
trace fucntion name:foo 
[40;44m =======trace_function_path foo  function_call count: 1 level :0========  [0m
# .MEM_4 = VDEF <.MEM_3(D)>
free (z_2(D));
[40;36m ======= node_fun:foo========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:free========= [0m
[40;46m =======add node_fun stack:free========= [0m

 ================== trace ================== 
trace fucntion free:0 
foo (p_29);
test.c:123:25: warning: use location
  123 |                         foo(p);
      |                         ^
this stmt is child function---foo-----

 ================== trace ================== 
trace fucntion name:foo 
[40;44m =======trace_function_path foo  function_call count: 1 level :0========  [0m
# .MEM_4 = VDEF <.MEM_3(D)>
free (z_2(D));
[40;36m ======= node_fun:foo========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:free========= [0m
[40;46m =======add node_fun stack:free========= [0m

 ================== trace ================== 
trace fucntion free:0 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_72 = VDEF <.MEM_71>
foo (p_29);
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
foo (p_29);
test.c:80:9: warning: use location
   80 |         foo(p);
      |         ^
this stmt is child function---foo-----

 ================== trace ================== 
trace fucntion name:foo 
[40;44m =======trace_function_path foo  function_call count: 1 level :0========  [0m
# .MEM_4 = VDEF <.MEM_3(D)>
free (z_2(D));
[40;36m ======= node_fun:foo========= [0m
[40;36m ======= find relate stmt with (null) ========= [0m
[40;36m ======= relate stmt argument:(null) ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:free========= [0m
[40;46m =======add node_fun stack:free========= [0m

 ================== trace ================== 
trace fucntion free:0 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_69 = VDEF <.MEM_68>
MEM[(struct st *)p_29 + 48B].f = _6;
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
MEM[(struct st *)p_29 + 48B].f = _6;
test.c:76:16: warning: use location
   76 |         p[3].f = malloc(1);
      |                ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_69 = VDEF <.MEM_68>
MEM[(struct st *)p_29 + 48B].f = _6;
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
MEM[(struct st *)p_29 + 48B].f = _6;
test.c:76:16: warning: use location

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_70 = VDEF <.MEM_69>
_7 = malloc (1);
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
# .MEM_70 = VDEF <.MEM_69>
_7 = malloc (1);
_7 = malloc (1);
test.c:79:18: warning: use location
   79 |         p[2].f = malloc(1);
      |                  ^
this stmt is child function---malloc-----

 ================== trace ================== 

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7f971c2a0798
    type <pointer_type 0x7f971c2b4000
        type <void_type 0x7f971c2adf18 void VOID
            align:8 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality
            pointer_to_this <pointer_type 0x7f971c2b4000>>
        public unsigned DI
        size <integer_cst 0x7f971c298bb8 constant 64>
        unit-size <integer_cst 0x7f971c298bd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality
        pointer_to_this <pointer_type 0x7f971c2b99d8>>
   
    def_stmt _7 = malloc (1);
    version:7
    ptr-info 0x7f971bdc5210>

 ================== Start Use after free Check ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:0 [0m
[40;31m  	free count:0 [0m

======================================================================

======================================================================
[40;31m    no free stmt possible memory leak [0m

======================================================================

dot graph START

======================================================================
 <ssa_name 0x7f971c2a07e0
    type <integer_type 0x7f971c2ad5e8 int public SI
        size <integer_cst 0x7f971c298df8 constant 32>
        unit-size <integer_cst 0x7f971c298e10 constant 4>
        align:32 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7f971c2ad5e8 precision:32 min <integer_cst 0x7f971c298db0 -2147483648> max <integer_cst 0x7f971c298dc8 2147483647>
        pointer_to_this <pointer_type 0x7f971c2b49d8>>
   
    def_stmt _8 = foo9 (p5_35(D));
    version:8>
# .MEM_73 = VDEF <.MEM_72>
_8 = foo9 (p5_35(D));

 ================== trace ptable================== 
trace fucntion name:foo9 
[40;44m =======trace_function_path foo9  function_call count: 1 level :888========  [0m
# .MEM_4 = VDEF <.MEM_3(D)>
free (z_2(D));
[40;31m  find free stmt free same pointer [0m
# .MEM_4 = VDEF <.MEM_3(D)>
free (z_2(D));
test.c:33:9: warning: use location
   33 |         free(z);
      |         ^
[40;42m =======pre add _ fucntion:free========= [0m
[40;46m =======add node_fun stack:free========= [0m

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr---foo9-----
this other function ------foo9-----
 
 Start check Pointer Collect  

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_73 = VDEF <.MEM_72>
_8 = foo9 (p5_35(D));
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
# .MEM_73 = VDEF <.MEM_72>
_8 = foo9 (p5_35(D));
_8 = foo9 (p5_35(D));
test.c:99:14: warning: use location
   99 |         p5 = foo9(p5);
      |              ^
this stmt is child function---foo9-----

 ================== trace ================== 
trace fucntion name:foo9 
[40;44m =======trace_function_path foo9  function_call count: 1 level :0========  [0m
# .MEM_4 = VDEF <.MEM_3(D)>
free (z_2(D));
[40;31m  find free stmt free same pointer [0m
# .MEM_4 = VDEF <.MEM_3(D)>
free (z_2(D));
test.c:33:9: warning: use location
   33 |         free(z);
      |         ^
[40;42m =======pre add _ fucntion:free========= [0m
[40;46m =======add node_fun stack:free========= [0m

 ================== trace ================== 
trace fucntion free:1 

======================================================================
[40;31m    branch possiable have return or exit  [0m
_9 = (long int) _8;
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
_9 = (long int) _8;
test.c:99:14: warning: use location
   99 |         p5 = foo9(p5);
      |              ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
p5_37 = (int *) _9;
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
p5_37 = (int *) _9;
test.c:99:12: warning: use location
   99 |         p5 = foo9(p5);
      |            ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_83 = VDEF <.MEM_54>
foo9 (p5_37);
bb index := 17
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 17 ,possiable got to succ := 18

======================================================================

 Expand conflict 
 The same function may have multiple branches :foo9
# .MEM_73 = VDEF <.MEM_72>
_8 = foo9 (p5_35(D));
test.c:99:14: warning: use location
   99 |         p5 = foo9(p5);
      |              ^
# .MEM_83 = VDEF <.MEM_54>
foo9 (p5_37);
test.c:157:25: warning: use location
  157 |                         foo9(p5);
      |                         ^
prev:= 17
=======================Path Constaint===========================

if (test_38(D) != 0)
test.c:114:12: warning: use location
  114 |         if (test)
      |            ^
if (test3_49(D) != 0)
test.c:143:20: warning: use location
  143 |                 if (test3)
      |                    ^
if (test_38(D) == test2_40(D))
test.c:149:12: warning: use location
  149 |         if (test == test2)
      |            ^
if (test_38(D) >= test2_40(D))
test.c:151:17: warning: use location
  151 |         else if (test >= test2)
      |                 ^
succs:= 16
if (test_38(D) > test2_40(D))
test.c:155:20: warning: use location
  155 |                 if (test > test2)
      |                    ^
=======================Path Constaint===========================


 Expand conflict 
 The same function may have multiple branches :foo9
# .MEM_73 = VDEF <.MEM_72>
_8 = foo9 (p5_35(D));
test.c:99:14: warning: use location
   99 |         p5 = foo9(p5);
      |              ^
# .MEM_85 = VDEF <.MEM_54>
foo9 (p5_37);
test.c:152:17: warning: use location
  152 |                 foo9(p5);
      |                 ^
prev:= 15
=======================Path Constaint===========================

if (test_38(D) != 0)
test.c:114:12: warning: use location
  114 |         if (test)
      |            ^
if (test3_49(D) != 0)
test.c:143:20: warning: use location
  143 |                 if (test3)
      |                    ^
if (test_38(D) == test2_40(D))
test.c:149:12: warning: use location
  149 |         if (test == test2)
      |            ^
succs:= 14
if (test_38(D) >= test2_40(D))
test.c:151:17: warning: use location
  151 |         else if (test >= test2)
      |                 ^
=======================Path Constaint===========================


 Expand conflict 
 The same function may have multiple branches :foo9
# .MEM_73 = VDEF <.MEM_72>
_8 = foo9 (p5_35(D));
test.c:99:14: warning: use location
   99 |         p5 = foo9(p5);
      |              ^
# .MEM_86 = VDEF <.MEM_54>
foo9 (p5_37);
test.c:150:17: warning: use location
  150 |                 foo9(p5);
      |                 ^
prev:= 13
=======================Path Constaint===========================

if (test_38(D) != 0)
test.c:114:12: warning: use location
  114 |         if (test)
      |            ^
if (test3_49(D) != 0)
test.c:143:20: warning: use location
  143 |                 if (test3)
      |                    ^
succs:= 12
if (test_38(D) == test2_40(D))
test.c:149:12: warning: use location
  149 |         if (test == test2)
      |            ^
=======================Path Constaint===========================


 Expand conflict 
 The same function may have multiple branches :foo9
# .MEM_73 = VDEF <.MEM_72>
_8 = foo9 (p5_35(D));
test.c:99:14: warning: use location
   99 |         p5 = foo9(p5);
      |              ^
# .MEM_76 = VDEF <.MEM_75>
foo9 (p5_37);
test.c:140:33: warning: use location
  140 |                                 foo9(p5);
      |                                 ^
prev:= 9
=======================Path Constaint===========================

succs:= 2
if (test_38(D) != 0)
test.c:114:12: warning: use location
  114 |         if (test)
      |            ^
if (test_38(D) > test2_40(D))
test.c:121:20: warning: use location
  121 |                 if (test > test2)
      |                    ^
if (test_38(D) < test2_40(D))
test.c:135:28: warning: use location
  135 |                         if (test < test2)
      |                            ^
=======================Path Constaint===========================


 Expand conflict 
 The same function may have multiple branches :foo9
# .MEM_73 = VDEF <.MEM_72>
_8 = foo9 (p5_35(D));
test.c:99:14: warning: use location
   99 |         p5 = foo9(p5);
      |              ^
# .MEM_81 = VDEF <.MEM_80>
foo9 (p5_37);
test.c:127:33: warning: use location
  127 |                                 foo9(p5);
      |                                 ^
prev:= 5
=======================Path Constaint===========================

succs:= 2
if (test_38(D) != 0)
test.c:114:12: warning: use location
  114 |         if (test)
      |            ^
succs:= 3
if (test_38(D) > test2_40(D))
test.c:121:20: warning: use location
  121 |                 if (test > test2)
      |                    ^
succs:= 4
if (test_38(D) < test2_40(D))
test.c:124:28: warning: use location
  124 |                         if (test < test2)
      |                            ^
=======================Path Constaint===========================


======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_74 = VDEF <.MEM_73>
foo9 (p5_37);
bb index := 3
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 3 ,possiable got to succ := 18

======================================================================

 Expand conflict 
 The same function may have multiple branches :foo9
# .MEM_73 = VDEF <.MEM_72>
_8 = foo9 (p5_35(D));
test.c:99:14: warning: use location
   99 |         p5 = foo9(p5);
      |              ^
# .MEM_74 = VDEF <.MEM_73>
foo9 (p5_37);
test.c:116:17: warning: use location
  116 |                 foo9(p5);
      |                 ^
prev:= 3
=======================Path Constaint===========================

succs:= 2
if (test_38(D) != 0)
test.c:114:12: warning: use location
  114 |         if (test)
      |            ^
=======================Path Constaint===========================


 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7f971c2a07e0
    type <integer_type 0x7f971c2ad5e8 int public SI
        size <integer_cst 0x7f971c298df8 constant 32>
        unit-size <integer_cst 0x7f971c298e10 constant 4>
        align:32 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7f971c2ad5e8 precision:32 min <integer_cst 0x7f971c298db0 -2147483648> max <integer_cst 0x7f971c298dc8 2147483647>
        pointer_to_this <pointer_type 0x7f971c2b49d8>>
   
    def_stmt _8 = foo9 (p5_35(D));
    version:8>
[40;35m <Looserules> find realloc stmt free same pointer [0m
*/If realloc() fails, the initial memory block will not be freed() */# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: use location
   57 |         p6 = realloc(p6, 100);
      |              ^
[40;35m <Looserules> find realloc stmt free same pointer [0m
*/If realloc() fails, the initial memory block will not be freed() */# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: use location
   58 |         p7 = realloc(p6, 100);
      |              ^
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_66 = VDEF <.MEM_65>
free (p9_24);
test.c:74:9: warning: use location
   74 |         free(p9);
      |         ^

 ================== Start Use after free Check ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: Use after free error!: free location 
   57 |         p6 = realloc(p6, 100);
      |              ^
# .MEM_73 = VDEF <.MEM_72>
_8 = foo9 (p5_35(D));
test.c:99:14: warning: use location
   99 |         p5 = foo9(p5);
      |              ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: Use after free error!: free location 
   58 |         p7 = realloc(p6, 100);
      |              ^
# .MEM_73 = VDEF <.MEM_72>
_8 = foo9 (p5_35(D));
test.c:99:14: warning: use location
   99 |         p5 = foo9(p5);
      |              ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_66 = VDEF <.MEM_65>
free (p9_24);
test.c:74:9: warning: Use after free error!: free location 
   74 |         free(p9);
      |         ^
# .MEM_73 = VDEF <.MEM_72>
_8 = foo9 (p5_35(D));
test.c:99:14: warning: use location
   99 |         p5 = foo9(p5);
      |              ^

 ================== warring ================== 
[40;35m    Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
# .MEM_73 = VDEF <.MEM_72>
_8 = foo9 (p5_35(D));
test.c:99:14: warning: Use after free error!: free location 
_9 = (long int) _8;
test.c:99:14: warning: use location

 ================== warring ================== 
[40;35m    Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: Use after free error!: free location 
   57 |         p6 = realloc(p6, 100);
      |              ^
_9 = (long int) _8;
test.c:99:14: warning: use location
   99 |         p5 = foo9(p5);
      |              ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: Use after free error!: free location 
   58 |         p7 = realloc(p6, 100);
      |              ^
_9 = (long int) _8;
test.c:99:14: warning: use location
   99 |         p5 = foo9(p5);
      |              ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_66 = VDEF <.MEM_65>
free (p9_24);
test.c:74:9: warning: Use after free error!: free location 
   74 |         free(p9);
      |         ^
_9 = (long int) _8;
test.c:99:14: warning: use location
   99 |         p5 = foo9(p5);
      |              ^

 ================== warring ================== 
[40;35m    Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
# .MEM_73 = VDEF <.MEM_72>
_8 = foo9 (p5_35(D));
test.c:99:14: warning: Use after free error!: free location 
p5_37 = (int *) _9;
test.c:99:12: warning: use location
   99 |         p5 = foo9(p5);
      |            ^

 ================== warring ================== 
[40;35m    Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: Use after free error!: free location 
   57 |         p6 = realloc(p6, 100);
      |              ^
p5_37 = (int *) _9;
test.c:99:12: warning: use location
   99 |         p5 = foo9(p5);
      |            ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: Use after free error!: free location 
   58 |         p7 = realloc(p6, 100);
      |              ^
p5_37 = (int *) _9;
test.c:99:12: warning: use location
   99 |         p5 = foo9(p5);
      |            ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_66 = VDEF <.MEM_65>
free (p9_24);
test.c:74:9: warning: Use after free error!: free location 
   74 |         free(p9);
      |         ^
p5_37 = (int *) _9;
test.c:99:12: warning: use location
   99 |         p5 = foo9(p5);
      |            ^

 ================== warring ================== 
[40;35m    Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: Use after free error!: free location 
   57 |         p6 = realloc(p6, 100);
      |              ^
# .MEM_83 = VDEF <.MEM_54>
foo9 (p5_37);
test.c:157:25: warning: use location
  157 |                         foo9(p5);
      |                         ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: Use after free error!: free location 
   58 |         p7 = realloc(p6, 100);
      |              ^
# .MEM_83 = VDEF <.MEM_54>
foo9 (p5_37);
test.c:157:25: warning: use location
  157 |                         foo9(p5);
      |                         ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_66 = VDEF <.MEM_65>
free (p9_24);
test.c:74:9: warning: Use after free error!: free location 
   74 |         free(p9);
      |         ^
# .MEM_83 = VDEF <.MEM_54>
foo9 (p5_37);
test.c:157:25: warning: use location
  157 |                         foo9(p5);
      |                         ^

 ================== warring ================== 
[40;35m    Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: Use after free error!: free location 
   57 |         p6 = realloc(p6, 100);
      |              ^
# .MEM_85 = VDEF <.MEM_54>
foo9 (p5_37);
test.c:152:17: warning: use location
  152 |                 foo9(p5);
      |                 ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: Use after free error!: free location 
   58 |         p7 = realloc(p6, 100);
      |              ^
# .MEM_85 = VDEF <.MEM_54>
foo9 (p5_37);
test.c:152:17: warning: use location
  152 |                 foo9(p5);
      |                 ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_66 = VDEF <.MEM_65>
free (p9_24);
test.c:74:9: warning: Use after free error!: free location 
   74 |         free(p9);
      |         ^
# .MEM_85 = VDEF <.MEM_54>
foo9 (p5_37);
test.c:152:17: warning: use location
  152 |                 foo9(p5);
      |                 ^

 ================== warring ================== 
[40;35m    Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: Use after free error!: free location 
   57 |         p6 = realloc(p6, 100);
      |              ^
# .MEM_86 = VDEF <.MEM_54>
foo9 (p5_37);
test.c:150:17: warning: use location
  150 |                 foo9(p5);
      |                 ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: Use after free error!: free location 
   58 |         p7 = realloc(p6, 100);
      |              ^
# .MEM_86 = VDEF <.MEM_54>
foo9 (p5_37);
test.c:150:17: warning: use location
  150 |                 foo9(p5);
      |                 ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_66 = VDEF <.MEM_65>
free (p9_24);
test.c:74:9: warning: Use after free error!: free location 
   74 |         free(p9);
      |         ^
# .MEM_86 = VDEF <.MEM_54>
foo9 (p5_37);
test.c:150:17: warning: use location
  150 |                 foo9(p5);
      |                 ^

 ================== warring ================== 
[40;35m    Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: Use after free error!: free location 
   57 |         p6 = realloc(p6, 100);
      |              ^
# .MEM_76 = VDEF <.MEM_75>
foo9 (p5_37);
test.c:140:33: warning: use location
  140 |                                 foo9(p5);
      |                                 ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: Use after free error!: free location 
   58 |         p7 = realloc(p6, 100);
      |              ^
# .MEM_76 = VDEF <.MEM_75>
foo9 (p5_37);
test.c:140:33: warning: use location
  140 |                                 foo9(p5);
      |                                 ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_66 = VDEF <.MEM_65>
free (p9_24);
test.c:74:9: warning: Use after free error!: free location 
   74 |         free(p9);
      |         ^
# .MEM_76 = VDEF <.MEM_75>
foo9 (p5_37);
test.c:140:33: warning: use location
  140 |                                 foo9(p5);
      |                                 ^

 ================== warring ================== 
[40;35m    Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: Use after free error!: free location 
   57 |         p6 = realloc(p6, 100);
      |              ^
# .MEM_81 = VDEF <.MEM_80>
foo9 (p5_37);
test.c:127:33: warning: use location
  127 |                                 foo9(p5);
      |                                 ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: Use after free error!: free location 
   58 |         p7 = realloc(p6, 100);
      |              ^
# .MEM_81 = VDEF <.MEM_80>
foo9 (p5_37);
test.c:127:33: warning: use location
  127 |                                 foo9(p5);
      |                                 ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_66 = VDEF <.MEM_65>
free (p9_24);
test.c:74:9: warning: Use after free error!: free location 
   74 |         free(p9);
      |         ^
# .MEM_81 = VDEF <.MEM_80>
foo9 (p5_37);
test.c:127:33: warning: use location
  127 |                                 foo9(p5);
      |                                 ^

 ================== warring ================== 
[40;35m    Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: Use after free error!: free location 
   57 |         p6 = realloc(p6, 100);
      |              ^
# .MEM_74 = VDEF <.MEM_73>
foo9 (p5_37);
test.c:116:17: warning: use location
  116 |                 foo9(p5);
      |                 ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: Use after free error!: free location 
   58 |         p7 = realloc(p6, 100);
      |              ^
# .MEM_74 = VDEF <.MEM_73>
foo9 (p5_37);
test.c:116:17: warning: use location
  116 |                 foo9(p5);
      |                 ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_66 = VDEF <.MEM_65>
free (p9_24);
test.c:74:9: warning: Use after free error!: free location 
   74 |         free(p9);
      |         ^
# .MEM_74 = VDEF <.MEM_73>
foo9 (p5_37);
test.c:116:17: warning: use location
  116 |                 foo9(p5);
      |                 ^

 ================== warring ================== 
[40;35m    Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:3 [0m
[40;31m  	free count:1 [0m
[40;31m  	possible double free [Looserules]:3 [0m

======================================================================

======================================================================
[40;31m 	this stmt need double check [0m

======================================================================

dot graph START

======================================================================
 <ssa_name 0x7f971c2a09d8
    type <pointer_type 0x7f971c2b49d8
        type <integer_type 0x7f971c2ad5e8 int public SI
            size <integer_cst 0x7f971c298df8 constant 32>
            unit-size <integer_cst 0x7f971c298e10 constant 4>
            align:32 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7f971c2ad5e8 precision:32 min <integer_cst 0x7f971c298db0 -2147483648> max <integer_cst 0x7f971c298dc8 2147483647>
            pointer_to_this <pointer_type 0x7f971c2b49d8>>
        public unsigned DI
        size <integer_cst 0x7f971c298bb8 constant 64>
        unit-size <integer_cst 0x7f971c298bd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
    var <var_decl 0x7f971cb40f30 p5>
    def_stmt GIMPLE_NOP
    version:35>
GIMPLE_NOP

 ================== trace ptable================== 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr--------
this other function -----------
 
 Start check Pointer Collect  

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_73 = VDEF <.MEM_72>
_8 = foo9 (p5_35(D));
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
# .MEM_73 = VDEF <.MEM_72>
_8 = foo9 (p5_35(D));
_8 = foo9 (p5_35(D));
test.c:99:14: warning: use location
   99 |         p5 = foo9(p5);
      |              ^
this stmt is child function---foo9-----

 ================== trace ================== 
trace fucntion name:foo9 
[40;44m =======trace_function_path foo9  function_call count: 1 level :0========  [0m
# .MEM_4 = VDEF <.MEM_3(D)>
free (z_2(D));
[40;31m  find free stmt free same pointer [0m
# .MEM_4 = VDEF <.MEM_3(D)>
free (z_2(D));
test.c:33:9: warning: use location
   33 |         free(z);
      |         ^
[40;42m =======pre add _ fucntion:free========= [0m
[40;46m =======add node_fun stack:free========= [0m

 ================== trace ================== 
trace fucntion free:1 

======================================================================
[40;31m    branch possiable have return or exit  [0m
_9 = (long int) _8;
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
_9 = (long int) _8;
test.c:99:14: warning: use location
   99 |         p5 = foo9(p5);
      |              ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
p5_37 = (int *) _9;
bb index := 2
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 2 ,possiable got to succ := 18

======================================================================
p5_37 = (int *) _9;
test.c:99:12: warning: use location
   99 |         p5 = foo9(p5);
      |            ^

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_83 = VDEF <.MEM_54>
foo9 (p5_37);
bb index := 17
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 17 ,possiable got to succ := 18

======================================================================

 Expand conflict 
 The same function may have multiple branches :foo9
# .MEM_73 = VDEF <.MEM_72>
_8 = foo9 (p5_35(D));
test.c:99:14: warning: use location
   99 |         p5 = foo9(p5);
      |              ^
# .MEM_83 = VDEF <.MEM_54>
foo9 (p5_37);
test.c:157:25: warning: use location
  157 |                         foo9(p5);
      |                         ^
prev:= 17
=======================Path Constaint===========================

if (test_38(D) != 0)
test.c:114:12: warning: use location
  114 |         if (test)
      |            ^
if (test3_49(D) != 0)
test.c:143:20: warning: use location
  143 |                 if (test3)
      |                    ^
if (test_38(D) == test2_40(D))
test.c:149:12: warning: use location
  149 |         if (test == test2)
      |            ^
if (test_38(D) >= test2_40(D))
test.c:151:17: warning: use location
  151 |         else if (test >= test2)
      |                 ^
succs:= 16
if (test_38(D) > test2_40(D))
test.c:155:20: warning: use location
  155 |                 if (test > test2)
      |                    ^
=======================Path Constaint===========================


 Expand conflict 
 The same function may have multiple branches :foo9
# .MEM_73 = VDEF <.MEM_72>
_8 = foo9 (p5_35(D));
test.c:99:14: warning: use location
   99 |         p5 = foo9(p5);
      |              ^
# .MEM_85 = VDEF <.MEM_54>
foo9 (p5_37);
test.c:152:17: warning: use location
  152 |                 foo9(p5);
      |                 ^
prev:= 15
=======================Path Constaint===========================

if (test_38(D) != 0)
test.c:114:12: warning: use location
  114 |         if (test)
      |            ^
if (test3_49(D) != 0)
test.c:143:20: warning: use location
  143 |                 if (test3)
      |                    ^
if (test_38(D) == test2_40(D))
test.c:149:12: warning: use location
  149 |         if (test == test2)
      |            ^
succs:= 14
if (test_38(D) >= test2_40(D))
test.c:151:17: warning: use location
  151 |         else if (test >= test2)
      |                 ^
=======================Path Constaint===========================


 Expand conflict 
 The same function may have multiple branches :foo9
# .MEM_73 = VDEF <.MEM_72>
_8 = foo9 (p5_35(D));
test.c:99:14: warning: use location
   99 |         p5 = foo9(p5);
      |              ^
# .MEM_86 = VDEF <.MEM_54>
foo9 (p5_37);
test.c:150:17: warning: use location
  150 |                 foo9(p5);
      |                 ^
prev:= 13
=======================Path Constaint===========================

if (test_38(D) != 0)
test.c:114:12: warning: use location
  114 |         if (test)
      |            ^
if (test3_49(D) != 0)
test.c:143:20: warning: use location
  143 |                 if (test3)
      |                    ^
succs:= 12
if (test_38(D) == test2_40(D))
test.c:149:12: warning: use location
  149 |         if (test == test2)
      |            ^
=======================Path Constaint===========================


 Expand conflict 
 The same function may have multiple branches :foo9
# .MEM_73 = VDEF <.MEM_72>
_8 = foo9 (p5_35(D));
test.c:99:14: warning: use location
   99 |         p5 = foo9(p5);
      |              ^
# .MEM_76 = VDEF <.MEM_75>
foo9 (p5_37);
test.c:140:33: warning: use location
  140 |                                 foo9(p5);
      |                                 ^
prev:= 9
=======================Path Constaint===========================

succs:= 2
if (test_38(D) != 0)
test.c:114:12: warning: use location
  114 |         if (test)
      |            ^
if (test_38(D) > test2_40(D))
test.c:121:20: warning: use location
  121 |                 if (test > test2)
      |                    ^
if (test_38(D) < test2_40(D))
test.c:135:28: warning: use location
  135 |                         if (test < test2)
      |                            ^
=======================Path Constaint===========================


 Expand conflict 
 The same function may have multiple branches :foo9
# .MEM_73 = VDEF <.MEM_72>
_8 = foo9 (p5_35(D));
test.c:99:14: warning: use location
   99 |         p5 = foo9(p5);
      |              ^
# .MEM_81 = VDEF <.MEM_80>
foo9 (p5_37);
test.c:127:33: warning: use location
  127 |                                 foo9(p5);
      |                                 ^
prev:= 5
=======================Path Constaint===========================

succs:= 2
if (test_38(D) != 0)
test.c:114:12: warning: use location
  114 |         if (test)
      |            ^
succs:= 3
if (test_38(D) > test2_40(D))
test.c:121:20: warning: use location
  121 |                 if (test > test2)
      |                    ^
succs:= 4
if (test_38(D) < test2_40(D))
test.c:124:28: warning: use location
  124 |                         if (test < test2)
      |                            ^
=======================Path Constaint===========================


======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_74 = VDEF <.MEM_73>
foo9 (p5_37);
bb index := 3
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 3 ,possiable got to succ := 18

======================================================================

 Expand conflict 
 The same function may have multiple branches :foo9
# .MEM_73 = VDEF <.MEM_72>
_8 = foo9 (p5_35(D));
test.c:99:14: warning: use location
   99 |         p5 = foo9(p5);
      |              ^
# .MEM_74 = VDEF <.MEM_73>
foo9 (p5_37);
test.c:116:17: warning: use location
  116 |                 foo9(p5);
      |                 ^
prev:= 3
=======================Path Constaint===========================

succs:= 2
if (test_38(D) != 0)
test.c:114:12: warning: use location
  114 |         if (test)
      |            ^
=======================Path Constaint===========================


 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7f971c2a09d8
    type <pointer_type 0x7f971c2b49d8
        type <integer_type 0x7f971c2ad5e8 int public SI
            size <integer_cst 0x7f971c298df8 constant 32>
            unit-size <integer_cst 0x7f971c298e10 constant 4>
            align:32 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7f971c2ad5e8 precision:32 min <integer_cst 0x7f971c298db0 -2147483648> max <integer_cst 0x7f971c298dc8 2147483647>
            pointer_to_this <pointer_type 0x7f971c2b49d8>>
        public unsigned DI
        size <integer_cst 0x7f971c298bb8 constant 64>
        unit-size <integer_cst 0x7f971c298bd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
    var <var_decl 0x7f971cb40f30 p5>
    def_stmt GIMPLE_NOP
    version:35>
[40;35m <Looserules> find realloc stmt free same pointer [0m
*/If realloc() fails, the initial memory block will not be freed() */# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: use location
   57 |         p6 = realloc(p6, 100);
      |              ^
[40;35m <Looserules> find realloc stmt free same pointer [0m
*/If realloc() fails, the initial memory block will not be freed() */# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: use location
   58 |         p7 = realloc(p6, 100);
      |              ^
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_66 = VDEF <.MEM_65>
free (p9_24);
test.c:74:9: warning: use location
   74 |         free(p9);
      |         ^

 ================== Start Use after free Check ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: Use after free error!: free location 
   57 |         p6 = realloc(p6, 100);
      |              ^
# .MEM_73 = VDEF <.MEM_72>
_8 = foo9 (p5_35(D));
test.c:99:14: warning: use location
   99 |         p5 = foo9(p5);
      |              ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: Use after free error!: free location 
   58 |         p7 = realloc(p6, 100);
      |              ^
# .MEM_73 = VDEF <.MEM_72>
_8 = foo9 (p5_35(D));
test.c:99:14: warning: use location
   99 |         p5 = foo9(p5);
      |              ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_66 = VDEF <.MEM_65>
free (p9_24);
test.c:74:9: warning: Use after free error!: free location 
   74 |         free(p9);
      |         ^
# .MEM_73 = VDEF <.MEM_72>
_8 = foo9 (p5_35(D));
test.c:99:14: warning: use location
   99 |         p5 = foo9(p5);
      |              ^

 ================== warring ================== 
[40;35m    Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
# .MEM_73 = VDEF <.MEM_72>
_8 = foo9 (p5_35(D));
test.c:99:14: warning: Use after free error!: free location 
_9 = (long int) _8;
test.c:99:14: warning: use location

 ================== warring ================== 
[40;35m    Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: Use after free error!: free location 
   57 |         p6 = realloc(p6, 100);
      |              ^
_9 = (long int) _8;
test.c:99:14: warning: use location
   99 |         p5 = foo9(p5);
      |              ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: Use after free error!: free location 
   58 |         p7 = realloc(p6, 100);
      |              ^
_9 = (long int) _8;
test.c:99:14: warning: use location
   99 |         p5 = foo9(p5);
      |              ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_66 = VDEF <.MEM_65>
free (p9_24);
test.c:74:9: warning: Use after free error!: free location 
   74 |         free(p9);
      |         ^
_9 = (long int) _8;
test.c:99:14: warning: use location
   99 |         p5 = foo9(p5);
      |              ^

 ================== warring ================== 
[40;35m    Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
# .MEM_73 = VDEF <.MEM_72>
_8 = foo9 (p5_35(D));
test.c:99:14: warning: Use after free error!: free location 
p5_37 = (int *) _9;
test.c:99:12: warning: use location
   99 |         p5 = foo9(p5);
      |            ^

 ================== warring ================== 
[40;35m    Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: Use after free error!: free location 
   57 |         p6 = realloc(p6, 100);
      |              ^
p5_37 = (int *) _9;
test.c:99:12: warning: use location
   99 |         p5 = foo9(p5);
      |            ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: Use after free error!: free location 
   58 |         p7 = realloc(p6, 100);
      |              ^
p5_37 = (int *) _9;
test.c:99:12: warning: use location
   99 |         p5 = foo9(p5);
      |            ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_66 = VDEF <.MEM_65>
free (p9_24);
test.c:74:9: warning: Use after free error!: free location 
   74 |         free(p9);
      |         ^
p5_37 = (int *) _9;
test.c:99:12: warning: use location
   99 |         p5 = foo9(p5);
      |            ^

 ================== warring ================== 
[40;35m    Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: Use after free error!: free location 
   57 |         p6 = realloc(p6, 100);
      |              ^
# .MEM_83 = VDEF <.MEM_54>
foo9 (p5_37);
test.c:157:25: warning: use location
  157 |                         foo9(p5);
      |                         ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: Use after free error!: free location 
   58 |         p7 = realloc(p6, 100);
      |              ^
# .MEM_83 = VDEF <.MEM_54>
foo9 (p5_37);
test.c:157:25: warning: use location
  157 |                         foo9(p5);
      |                         ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_66 = VDEF <.MEM_65>
free (p9_24);
test.c:74:9: warning: Use after free error!: free location 
   74 |         free(p9);
      |         ^
# .MEM_83 = VDEF <.MEM_54>
foo9 (p5_37);
test.c:157:25: warning: use location
  157 |                         foo9(p5);
      |                         ^

 ================== warring ================== 
[40;35m    Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: Use after free error!: free location 
   57 |         p6 = realloc(p6, 100);
      |              ^
# .MEM_85 = VDEF <.MEM_54>
foo9 (p5_37);
test.c:152:17: warning: use location
  152 |                 foo9(p5);
      |                 ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: Use after free error!: free location 
   58 |         p7 = realloc(p6, 100);
      |              ^
# .MEM_85 = VDEF <.MEM_54>
foo9 (p5_37);
test.c:152:17: warning: use location
  152 |                 foo9(p5);
      |                 ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_66 = VDEF <.MEM_65>
free (p9_24);
test.c:74:9: warning: Use after free error!: free location 
   74 |         free(p9);
      |         ^
# .MEM_85 = VDEF <.MEM_54>
foo9 (p5_37);
test.c:152:17: warning: use location
  152 |                 foo9(p5);
      |                 ^

 ================== warring ================== 
[40;35m    Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: Use after free error!: free location 
   57 |         p6 = realloc(p6, 100);
      |              ^
# .MEM_86 = VDEF <.MEM_54>
foo9 (p5_37);
test.c:150:17: warning: use location
  150 |                 foo9(p5);
      |                 ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: Use after free error!: free location 
   58 |         p7 = realloc(p6, 100);
      |              ^
# .MEM_86 = VDEF <.MEM_54>
foo9 (p5_37);
test.c:150:17: warning: use location
  150 |                 foo9(p5);
      |                 ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_66 = VDEF <.MEM_65>
free (p9_24);
test.c:74:9: warning: Use after free error!: free location 
   74 |         free(p9);
      |         ^
# .MEM_86 = VDEF <.MEM_54>
foo9 (p5_37);
test.c:150:17: warning: use location
  150 |                 foo9(p5);
      |                 ^

 ================== warring ================== 
[40;35m    Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: Use after free error!: free location 
   57 |         p6 = realloc(p6, 100);
      |              ^
# .MEM_76 = VDEF <.MEM_75>
foo9 (p5_37);
test.c:140:33: warning: use location
  140 |                                 foo9(p5);
      |                                 ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: Use after free error!: free location 
   58 |         p7 = realloc(p6, 100);
      |              ^
# .MEM_76 = VDEF <.MEM_75>
foo9 (p5_37);
test.c:140:33: warning: use location
  140 |                                 foo9(p5);
      |                                 ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_66 = VDEF <.MEM_65>
free (p9_24);
test.c:74:9: warning: Use after free error!: free location 
   74 |         free(p9);
      |         ^
# .MEM_76 = VDEF <.MEM_75>
foo9 (p5_37);
test.c:140:33: warning: use location
  140 |                                 foo9(p5);
      |                                 ^

 ================== warring ================== 
[40;35m    Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: Use after free error!: free location 
   57 |         p6 = realloc(p6, 100);
      |              ^
# .MEM_81 = VDEF <.MEM_80>
foo9 (p5_37);
test.c:127:33: warning: use location
  127 |                                 foo9(p5);
      |                                 ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: Use after free error!: free location 
   58 |         p7 = realloc(p6, 100);
      |              ^
# .MEM_81 = VDEF <.MEM_80>
foo9 (p5_37);
test.c:127:33: warning: use location
  127 |                                 foo9(p5);
      |                                 ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_66 = VDEF <.MEM_65>
free (p9_24);
test.c:74:9: warning: Use after free error!: free location 
   74 |         free(p9);
      |         ^
# .MEM_81 = VDEF <.MEM_80>
foo9 (p5_37);
test.c:127:33: warning: use location
  127 |                                 foo9(p5);
      |                                 ^

 ================== warring ================== 
[40;35m    Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: Use after free error!: free location 
   57 |         p6 = realloc(p6, 100);
      |              ^
# .MEM_74 = VDEF <.MEM_73>
foo9 (p5_37);
test.c:116:17: warning: use location
  116 |                 foo9(p5);
      |                 ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: Use after free error!: free location 
   58 |         p7 = realloc(p6, 100);
      |              ^
# .MEM_74 = VDEF <.MEM_73>
foo9 (p5_37);
test.c:116:17: warning: use location
  116 |                 foo9(p5);
      |                 ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_66 = VDEF <.MEM_65>
free (p9_24);
test.c:74:9: warning: Use after free error!: free location 
   74 |         free(p9);
      |         ^
# .MEM_74 = VDEF <.MEM_73>
foo9 (p5_37);
test.c:116:17: warning: use location
  116 |                 foo9(p5);
      |                 ^

 ================== warring ================== 
[40;35m    Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:3 [0m
[40;31m  	free count:1 [0m
[40;31m  	possible double free [Looserules]:3 [0m

======================================================================

======================================================================
[40;31m 	this stmt need double check [0m

======================================================================

dot graph START

======================================================================
 <ssa_name 0x7f971c2a0a20
    type <pointer_type 0x7f971c2b49d8
        type <integer_type 0x7f971c2ad5e8 int public SI
            size <integer_cst 0x7f971c298df8 constant 32>
            unit-size <integer_cst 0x7f971c298e10 constant 4>
            align:32 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7f971c2ad5e8 precision:32 min <integer_cst 0x7f971c298db0 -2147483648> max <integer_cst 0x7f971c298dc8 2147483647>
            pointer_to_this <pointer_type 0x7f971c2b49d8>>
        public unsigned DI
        size <integer_cst 0x7f971c298bb8 constant 64>
        unit-size <integer_cst 0x7f971c298bd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
    var <var_decl 0x7f971cb40f30 p5>
    def_stmt p5_37 = (int *) _9;
    version:37
    ptr-info 0x7f971bdc52a0>
p5_37 = (int *) _9;

 ================== trace ptable================== 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr--------
this other function -----------
 
 Start check Pointer Collect  

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_83 = VDEF <.MEM_54>
foo9 (p5_37);
bb index := 17
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 17 ,possiable got to succ := 18

======================================================================

 Expand conflict 
 The same function may have multiple branches :foo9
# .MEM_74 = VDEF <.MEM_73>
foo9 (p5_37);
test.c:116:17: warning: use location
# .MEM_83 = VDEF <.MEM_54>
foo9 (p5_37);
test.c:157:25: warning: use location
  157 |                         foo9(p5);
      |                         ^
prev:= 17
=======================Path Constaint===========================

if (test_38(D) != 0)
test.c:114:12: warning: use location
  114 |         if (test)
      |            ^
if (test3_49(D) != 0)
test.c:143:20: warning: use location
  143 |                 if (test3)
      |                    ^
if (test_38(D) == test2_40(D))
test.c:149:12: warning: use location
  149 |         if (test == test2)
      |            ^
if (test_38(D) >= test2_40(D))
test.c:151:17: warning: use location
  151 |         else if (test >= test2)
      |                 ^
succs:= 16
if (test_38(D) > test2_40(D))
test.c:155:20: warning: use location
  155 |                 if (test > test2)
      |                    ^
=======================Path Constaint===========================


 Expand conflict 
 The same function may have multiple branches :foo9
# .MEM_74 = VDEF <.MEM_73>
foo9 (p5_37);
test.c:116:17: warning: use location
  116 |                 foo9(p5);
      |                 ^
# .MEM_85 = VDEF <.MEM_54>
foo9 (p5_37);
test.c:152:17: warning: use location
  152 |                 foo9(p5);
      |                 ^
prev:= 15
=======================Path Constaint===========================

if (test_38(D) != 0)
test.c:114:12: warning: use location
  114 |         if (test)
      |            ^
if (test3_49(D) != 0)
test.c:143:20: warning: use location
  143 |                 if (test3)
      |                    ^
if (test_38(D) == test2_40(D))
test.c:149:12: warning: use location
  149 |         if (test == test2)
      |            ^
succs:= 14
if (test_38(D) >= test2_40(D))
test.c:151:17: warning: use location
  151 |         else if (test >= test2)
      |                 ^
=======================Path Constaint===========================


 Expand conflict 
 The same function may have multiple branches :foo9
# .MEM_74 = VDEF <.MEM_73>
foo9 (p5_37);
test.c:116:17: warning: use location
  116 |                 foo9(p5);
      |                 ^
# .MEM_86 = VDEF <.MEM_54>
foo9 (p5_37);
test.c:150:17: warning: use location
  150 |                 foo9(p5);
      |                 ^
prev:= 13
=======================Path Constaint===========================

if (test_38(D) != 0)
test.c:114:12: warning: use location
  114 |         if (test)
      |            ^
if (test3_49(D) != 0)
test.c:143:20: warning: use location
  143 |                 if (test3)
      |                    ^
succs:= 12
if (test_38(D) == test2_40(D))
test.c:149:12: warning: use location
  149 |         if (test == test2)
      |            ^
=======================Path Constaint===========================


 Expand conflict 
 The same function may have multiple branches :foo9
# .MEM_74 = VDEF <.MEM_73>
foo9 (p5_37);
test.c:116:17: warning: use location
  116 |                 foo9(p5);
      |                 ^
# .MEM_76 = VDEF <.MEM_75>
foo9 (p5_37);
test.c:140:33: warning: use location
  140 |                                 foo9(p5);
      |                                 ^
prev:= 9
=======================Path Constaint===========================

succs:= 2
if (test_38(D) != 0)
test.c:114:12: warning: use location
  114 |         if (test)
      |            ^
if (test_38(D) > test2_40(D))
test.c:121:20: warning: use location
  121 |                 if (test > test2)
      |                    ^
if (test_38(D) < test2_40(D))
test.c:135:28: warning: use location
  135 |                         if (test < test2)
      |                            ^
=======================Path Constaint===========================


 Expand conflict 
 The same function may have multiple branches :foo9
# .MEM_74 = VDEF <.MEM_73>
foo9 (p5_37);
test.c:116:17: warning: use location
  116 |                 foo9(p5);
      |                 ^
# .MEM_81 = VDEF <.MEM_80>
foo9 (p5_37);
test.c:127:33: warning: use location
  127 |                                 foo9(p5);
      |                                 ^
prev:= 5
=======================Path Constaint===========================

succs:= 2
if (test_38(D) != 0)
test.c:114:12: warning: use location
  114 |         if (test)
      |            ^
succs:= 3
if (test_38(D) > test2_40(D))
test.c:121:20: warning: use location
  121 |                 if (test > test2)
      |                    ^
succs:= 4
if (test_38(D) < test2_40(D))
test.c:124:28: warning: use location
  124 |                         if (test < test2)
      |                            ^
=======================Path Constaint===========================


======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_74 = VDEF <.MEM_73>
foo9 (p5_37);
bb index := 3
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 3 ,possiable got to succ := 18

======================================================================
# .MEM_74 = VDEF <.MEM_73>
foo9 (p5_37);
foo9 (p5_37);
test.c:116:17: warning: use location
  116 |                 foo9(p5);
      |                 ^
this stmt is child function---foo9-----

 ================== trace ================== 
trace fucntion name:foo9 
[40;44m =======trace_function_path foo9  function_call count: 1 level :0========  [0m
# .MEM_4 = VDEF <.MEM_3(D)>
free (z_2(D));
[40;36m ======= node_fun:foo9========= [0m
[40;36m ======= find relate stmt with p5 ========= [0m
[40;36m ======= relate stmt argument:p5 ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:free========= [0m
[40;46m =======add node_fun stack:free========= [0m

 ================== trace ================== 
trace fucntion free:0 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_74 = VDEF <.MEM_73>
foo9 (p5_37);
bb index := 3
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 3 ,possiable got to succ := 18

======================================================================
# .MEM_74 = VDEF <.MEM_73>
foo9 (p5_37);
foo9 (p5_37);
test.c:116:17: warning: use location
this stmt is child function---foo9-----

 ================== trace ================== 
trace fucntion name:foo9 
[40;44m =======trace_function_path foo9  function_call count: 1 level :0========  [0m
# .MEM_4 = VDEF <.MEM_3(D)>
free (z_2(D));
[40;36m ======= node_fun:foo9========= [0m
[40;36m ======= find relate stmt with p5 ========= [0m
[40;36m ======= relate stmt argument:p5 ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:free========= [0m
[40;46m =======add node_fun stack:free========= [0m

 ================== trace ================== 
trace fucntion free:0 

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7f971c2a0a20
    type <pointer_type 0x7f971c2b49d8
        type <integer_type 0x7f971c2ad5e8 int public SI
            size <integer_cst 0x7f971c298df8 constant 32>
            unit-size <integer_cst 0x7f971c298e10 constant 4>
            align:32 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7f971c2ad5e8 precision:32 min <integer_cst 0x7f971c298db0 -2147483648> max <integer_cst 0x7f971c298dc8 2147483647>
            pointer_to_this <pointer_type 0x7f971c2b49d8>>
        public unsigned DI
        size <integer_cst 0x7f971c298bb8 constant 64>
        unit-size <integer_cst 0x7f971c298bd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
    var <var_decl 0x7f971cb40f30 p5>
    def_stmt p5_37 = (int *) _9;
    version:37
    ptr-info 0x7f971bdc52a0>

 ================== Start Use after free Check ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:0 [0m
[40;31m  	free count:0 [0m

======================================================================

======================================================================
[40;31m    no free stmt possible memory leak [0m

======================================================================

dot graph START

======================================================================
 <ssa_name 0x7f971c2a0a20
    type <pointer_type 0x7f971c2b49d8
        type <integer_type 0x7f971c2ad5e8 int public SI
            size <integer_cst 0x7f971c298df8 constant 32>
            unit-size <integer_cst 0x7f971c298e10 constant 4>
            align:32 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7f971c2ad5e8 precision:32 min <integer_cst 0x7f971c298db0 -2147483648> max <integer_cst 0x7f971c298dc8 2147483647>
            pointer_to_this <pointer_type 0x7f971c2b49d8>>
        public unsigned DI
        size <integer_cst 0x7f971c298bb8 constant 64>
        unit-size <integer_cst 0x7f971c298bd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
    var <var_decl 0x7f971cb40f30 p5>
    def_stmt p5_37 = (int *) _9;
    version:37
    ptr-info 0x7f971bdc52a0>
p5_37 = (int *) _9;

 ================== trace ptable================== 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr--------
this other function -----------
 
 Start check Pointer Collect  

======================================================================

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_83 = VDEF <.MEM_54>
foo9 (p5_37);
bb index := 17
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 17 ,possiable got to succ := 18

======================================================================

 Expand conflict 
 The same function may have multiple branches :foo9
# .MEM_81 = VDEF <.MEM_80>
foo9 (p5_37);
test.c:127:33: warning: use location
  127 |                                 foo9(p5);
      |                                 ^
# .MEM_83 = VDEF <.MEM_54>
foo9 (p5_37);
test.c:157:25: warning: use location
  157 |                         foo9(p5);
      |                         ^
prev:= 17
=======================Path Constaint===========================

if (test_38(D) != 0)
test.c:114:12: warning: use location
  114 |         if (test)
      |            ^
if (test3_49(D) != 0)
test.c:143:20: warning: use location
  143 |                 if (test3)
      |                    ^
if (test_38(D) == test2_40(D))
test.c:149:12: warning: use location
  149 |         if (test == test2)
      |            ^
if (test_38(D) >= test2_40(D))
test.c:151:17: warning: use location
  151 |         else if (test >= test2)
      |                 ^
succs:= 16
if (test_38(D) > test2_40(D))
test.c:155:20: warning: use location
  155 |                 if (test > test2)
      |                    ^
=======================Path Constaint===========================


 Expand conflict 
 The same function may have multiple branches :foo9
# .MEM_81 = VDEF <.MEM_80>
foo9 (p5_37);
test.c:127:33: warning: use location
  127 |                                 foo9(p5);
      |                                 ^
# .MEM_85 = VDEF <.MEM_54>
foo9 (p5_37);
test.c:152:17: warning: use location
  152 |                 foo9(p5);
      |                 ^
prev:= 15
=======================Path Constaint===========================

if (test_38(D) != 0)
test.c:114:12: warning: use location
  114 |         if (test)
      |            ^
if (test3_49(D) != 0)
test.c:143:20: warning: use location
  143 |                 if (test3)
      |                    ^
if (test_38(D) == test2_40(D))
test.c:149:12: warning: use location
  149 |         if (test == test2)
      |            ^
succs:= 14
if (test_38(D) >= test2_40(D))
test.c:151:17: warning: use location
  151 |         else if (test >= test2)
      |                 ^
=======================Path Constaint===========================


 Expand conflict 
 The same function may have multiple branches :foo9
# .MEM_81 = VDEF <.MEM_80>
foo9 (p5_37);
test.c:127:33: warning: use location
  127 |                                 foo9(p5);
      |                                 ^
# .MEM_86 = VDEF <.MEM_54>
foo9 (p5_37);
test.c:150:17: warning: use location
  150 |                 foo9(p5);
      |                 ^
prev:= 13
=======================Path Constaint===========================

if (test_38(D) != 0)
test.c:114:12: warning: use location
  114 |         if (test)
      |            ^
if (test3_49(D) != 0)
test.c:143:20: warning: use location
  143 |                 if (test3)
      |                    ^
succs:= 12
if (test_38(D) == test2_40(D))
test.c:149:12: warning: use location
  149 |         if (test == test2)
      |            ^
=======================Path Constaint===========================


 Expand conflict 
 The same function may have multiple branches :foo9
# .MEM_81 = VDEF <.MEM_80>
foo9 (p5_37);
test.c:127:33: warning: use location
  127 |                                 foo9(p5);
      |                                 ^
# .MEM_76 = VDEF <.MEM_75>
foo9 (p5_37);
test.c:140:33: warning: use location
  140 |                                 foo9(p5);
      |                                 ^
prev:= 9
=======================Path Constaint===========================

succs:= 2
if (test_38(D) != 0)
test.c:114:12: warning: use location
  114 |         if (test)
      |            ^
if (test_38(D) > test2_40(D))
test.c:121:20: warning: use location
  121 |                 if (test > test2)
      |                    ^
if (test_38(D) < test2_40(D))
test.c:135:28: warning: use location
  135 |                         if (test < test2)
      |                            ^
=======================Path Constaint===========================

# .MEM_81 = VDEF <.MEM_80>
foo9 (p5_37);
foo9 (p5_37);
test.c:127:33: warning: use location
  127 |                                 foo9(p5);
      |                                 ^
this stmt is child function---foo9-----

 ================== trace ================== 
trace fucntion name:foo9 
[40;44m =======trace_function_path foo9  function_call count: 1 level :0========  [0m
# .MEM_4 = VDEF <.MEM_3(D)>
free (z_2(D));
[40;36m ======= node_fun:foo9========= [0m
[40;36m ======= find relate stmt with p5 ========= [0m
[40;36m ======= relate stmt argument:p5 ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:free========= [0m
[40;46m =======add node_fun stack:free========= [0m

 ================== trace ================== 
trace fucntion free:0 

======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_74 = VDEF <.MEM_73>
foo9 (p5_37);
bb index := 3
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 3 ,possiable got to succ := 18

======================================================================

 Expand conflict 
 The same function may have multiple branches :foo9
# .MEM_81 = VDEF <.MEM_80>
foo9 (p5_37);
test.c:127:33: warning: use location
# .MEM_74 = VDEF <.MEM_73>
foo9 (p5_37);
test.c:116:17: warning: use location
  116 |                 foo9(p5);
      |                 ^
prev:= 3
=======================Path Constaint===========================

succs:= 2
if (test_38(D) != 0)
test.c:114:12: warning: use location
  114 |         if (test)
      |            ^
=======================Path Constaint===========================


======================================================================
[40;31m    branch possiable have return or exit  [0m
# .MEM_74 = VDEF <.MEM_73>
foo9 (p5_37);
bb index := 3
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
beacuse in succ := 18 have return or exit
# VUSE <.MEM_55>
return 0;
lto1: warning: use location
gimple stmt in succ := 3 ,possiable got to succ := 18

======================================================================

 Expand conflict 
 The same function may have multiple branches :foo9
# .MEM_81 = VDEF <.MEM_80>
foo9 (p5_37);
test.c:127:33: warning: use location
  127 |                                 foo9(p5);
      |                                 ^
# .MEM_74 = VDEF <.MEM_73>
foo9 (p5_37);
test.c:116:17: warning: use location
  116 |                 foo9(p5);
      |                 ^
prev:= 3
=======================Path Constaint===========================

succs:= 2
if (test_38(D) != 0)
test.c:114:12: warning: use location
  114 |         if (test)
      |            ^
=======================Path Constaint===========================


 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7f971c2a0a20
    type <pointer_type 0x7f971c2b49d8
        type <integer_type 0x7f971c2ad5e8 int public SI
            size <integer_cst 0x7f971c298df8 constant 32>
            unit-size <integer_cst 0x7f971c298e10 constant 4>
            align:32 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7f971c2ad5e8 precision:32 min <integer_cst 0x7f971c298db0 -2147483648> max <integer_cst 0x7f971c298dc8 2147483647>
            pointer_to_this <pointer_type 0x7f971c2b49d8>>
        public unsigned DI
        size <integer_cst 0x7f971c298bb8 constant 64>
        unit-size <integer_cst 0x7f971c298bd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
    var <var_decl 0x7f971cb40f30 p5>
    def_stmt p5_37 = (int *) _9;
    version:37
    ptr-info 0x7f971bdc52a0>

 ================== Start Use after free Check ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:0 [0m
[40;31m  	free count:0 [0m

======================================================================

======================================================================
[40;31m    no free stmt possible memory leak [0m

======================================================================

dot graph START

======================================================================
 <ssa_name 0x7f971c2a0af8
    type <pointer_type 0x7f971c2b49d8
        type <integer_type 0x7f971c2ad5e8 int public SI
            size <integer_cst 0x7f971c298df8 constant 32>
            unit-size <integer_cst 0x7f971c298e10 constant 4>
            align:32 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7f971c2ad5e8 precision:32 min <integer_cst 0x7f971c298db0 -2147483648> max <integer_cst 0x7f971c298dc8 2147483647>
            pointer_to_this <pointer_type 0x7f971c2b49d8>>
        public unsigned DI
        size <integer_cst 0x7f971c298bb8 constant 64>
        unit-size <integer_cst 0x7f971c298bd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
    var <var_decl 0x7f971bdc0090 p3>
    def_stmt GIMPLE_NOP
    version:43>
GIMPLE_NOP

 ================== trace ptable================== 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr--------
this other function -----------
 
 Start check Pointer Collect  

======================================================================
# .MEM_77 = VDEF <.MEM_75>
foo (p3_43(D));
foo (p3_43(D));
test.c:137:33: warning: use location
  137 |                                 foo(p3);
      |                                 ^
this stmt is child function---foo-----

 ================== trace ================== 
trace fucntion name:foo 
[40;44m =======trace_function_path foo  function_call count: 1 level :0========  [0m
# .MEM_4 = VDEF <.MEM_3(D)>
free (z_2(D));
[40;31m  find free stmt free same pointer [0m
# .MEM_4 = VDEF <.MEM_3(D)>
free (z_2(D));
test.c:29:9: warning: use location
   29 |         free(z);
      |         ^
[40;42m =======pre add _ fucntion:free========= [0m
[40;46m =======add node_fun stack:free========= [0m

 ================== trace ================== 
trace fucntion free:1 
# .MEM_77 = VDEF <.MEM_75>
foo (p3_43(D));
foo (p3_43(D));
test.c:137:33: warning: use location
  137 |                                 foo(p3);
      |                                 ^
this stmt is child function---foo-----

 ================== trace ================== 
trace fucntion name:foo 
[40;44m =======trace_function_path foo  function_call count: 1 level :0========  [0m
# .MEM_4 = VDEF <.MEM_3(D)>
free (z_2(D));
[40;31m  find free stmt free same pointer [0m
# .MEM_4 = VDEF <.MEM_3(D)>
free (z_2(D));
test.c:29:9: warning: use location
   29 |         free(z);
      |         ^
[40;42m =======pre add _ fucntion:free========= [0m
[40;46m =======add node_fun stack:free========= [0m

 ================== trace ================== 
trace fucntion free:2 

 ================== Start Looserules free Check ================== 

 ================== warring ================== 
[40;35m   this module possiable false positives [0m

 ================== warring ================== 
 <ssa_name 0x7f971c2a0af8
    type <pointer_type 0x7f971c2b49d8
        type <integer_type 0x7f971c2ad5e8 int public SI
            size <integer_cst 0x7f971c298df8 constant 32>
            unit-size <integer_cst 0x7f971c298e10 constant 4>
            align:32 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7f971c2ad5e8 precision:32 min <integer_cst 0x7f971c298db0 -2147483648> max <integer_cst 0x7f971c298dc8 2147483647>
            pointer_to_this <pointer_type 0x7f971c2b49d8>>
        public unsigned DI
        size <integer_cst 0x7f971c298bb8 constant 64>
        unit-size <integer_cst 0x7f971c298bd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
    var <var_decl 0x7f971bdc0090 p3>
    def_stmt GIMPLE_NOP
    version:43>
[40;35m <Looserules> find realloc stmt free same pointer [0m
*/If realloc() fails, the initial memory block will not be freed() */# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: use location
   57 |         p6 = realloc(p6, 100);
      |              ^
[40;35m <Looserules> find realloc stmt free same pointer [0m
*/If realloc() fails, the initial memory block will not be freed() */# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: use location
   58 |         p7 = realloc(p6, 100);
      |              ^
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_66 = VDEF <.MEM_65>
free (p9_24);
test.c:74:9: warning: use location
   74 |         free(p9);
      |         ^

 ================== Start Use after free Check ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: Use after free error!: free location 
   57 |         p6 = realloc(p6, 100);
      |              ^
# .MEM_77 = VDEF <.MEM_75>
foo (p3_43(D));
test.c:137:33: warning: use location
  137 |                                 foo(p3);
      |                                 ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: Use after free error!: free location 
   58 |         p7 = realloc(p6, 100);
      |              ^
# .MEM_77 = VDEF <.MEM_75>
foo (p3_43(D));
test.c:137:33: warning: use location
  137 |                                 foo(p3);
      |                                 ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_66 = VDEF <.MEM_65>
free (p9_24);
test.c:74:9: warning: Use after free error!: free location 
   74 |         free(p9);
      |         ^
# .MEM_77 = VDEF <.MEM_75>
foo (p3_43(D));
test.c:137:33: warning: use location
  137 |                                 foo(p3);
      |                                 ^

 ================== warring ================== 
[40;35m    Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_58 = VDEF <.MEM_57>
p6_17 = realloc (p6_15, 100);
test.c:57:14: warning: Use after free error!: free location 
   57 |         p6 = realloc(p6, 100);
      |              ^
# .MEM_77 = VDEF <.MEM_75>
foo (p3_43(D));
test.c:137:33: warning: use location
  137 |                                 foo(p3);
      |                                 ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_59 = VDEF <.MEM_58>
p7_19 = realloc (p6_17, 100);
test.c:58:14: warning: Use after free error!: free location 
   58 |         p7 = realloc(p6, 100);
      |              ^
# .MEM_77 = VDEF <.MEM_75>
foo (p3_43(D));
test.c:137:33: warning: use location
  137 |                                 foo(p3);
      |                                 ^

 ================== warring ================== 
[40;35m  realloc Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

============================================================
[40;35m <Looserules> find free stmt free same pointer [0m
# .MEM_66 = VDEF <.MEM_65>
free (p9_24);
test.c:74:9: warning: Use after free error!: free location 
   74 |         free(p9);
      |         ^
# .MEM_77 = VDEF <.MEM_75>
foo (p3_43(D));
test.c:137:33: warning: use location
  137 |                                 foo(p3);
      |                                 ^

 ================== warring ================== 
[40;35m    Use after free error! [0m
prev:= 2
=======================Path Constaint===========================

=======================Path Constaint===========================


 ================== warring ================== 

dot graph END

======================================================================
[40;35m  	Looserules free count:3 [0m
[40;31m  	free count:2 [0m
[40;31m  	possible double free [Looserules]:3 [0m
[40;31m  	possible double free [rigorous]:2 [0m

======================================================================

======================================================================
[40;31m  	possible double free [rigorous]:2 [0m

======================================================================

dot graph START

======================================================================
 <ssa_name 0x7f971c2a0b88
    type <pointer_type 0x7f971c2b49d8
        type <integer_type 0x7f971c2ad5e8 int public SI
            size <integer_cst 0x7f971c298df8 constant 32>
            unit-size <integer_cst 0x7f971c298e10 constant 4>
            align:32 warn_if_not_align:0 symtab:0 alias-set -1 canonical-type 0x7f971c2ad5e8 precision:32 min <integer_cst 0x7f971c298db0 -2147483648> max <integer_cst 0x7f971c298dc8 2147483647>
            pointer_to_this <pointer_type 0x7f971c2b49d8>>
        public unsigned DI
        size <integer_cst 0x7f971c298bb8 constant 64>
        unit-size <integer_cst 0x7f971c298bd0 constant 8>
        align:64 warn_if_not_align:0 symtab:0 alias-set -1 structural-equality>
    var <var_decl 0x7f971bdc0000 p4>
    def_stmt GIMPLE_NOP
    version:52>
GIMPLE_NOP

 ================== trace ptable================== 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr--------
this other function -----------

======================================================================
[40;35m  	Looserules free count:0 [0m
[40;31m  	free count:0 [0m

======================================================================

======================================================================
[40;31m 	Can't find this fucntion in Pointer table [0m
[40;31m 	Possiable no other stmt relate with this stmt [0m

======================================================================
[40;33m =======POP node_fun stack:main========= [0m
[40;44m =======node_fun:foo9========= [0m
[40;44m fucntion collect path  [0m
[40;44m =======print_function_path foo9  function_call count: 1 level :0========  [0m
[40;44m =======print_function_type 0  ========  [0m
[40;42m =======pre add _ fucntion:free========= [0m
[40;33m =======POP node_fun stack:free========= [0m
[40;42m =======pre_check_funciton:foo9========= [0m
[40;42m =======start_check_funciton:foo9========= [0m
[40;33m =======POP node_fun stack:foo9========= [0m
[40;44m =======node_fun:foo========= [0m
[40;44m fucntion collect path  [0m
[40;44m =======print_function_path foo  function_call count: 1 level :0========  [0m
[40;44m =======print_function_type 0  ========  [0m
[40;42m =======pre add _ fucntion:free========= [0m
[40;33m =======POP node_fun stack:free========= [0m
[40;42m =======pre_check_funciton:foo========= [0m
[40;42m =======start_check_funciton:foo========= [0m
[40;33m =======POP node_fun stack:foo========= [0m
fucntion collect path finsh

=============== The third stage : detection  End=================

===============Print ALL GIMPLE IR=================
=======Mapping node_fun:main=========
=======is loop:0=========

 bb index 2 
<bb 2> [local count: 1073741824]:
p6_15 = malloc (100);
p6_17 = realloc (p6_15, 100);
p7_19 = realloc (p6_17, 100);
*p7_19 = 48;
_1 = (long int) "0";
_2 = (int) _1;
*p6_15 = _2;
_3 = (long int) "0";
_4 = (int) _3;
MEM[(int *)p6_15 + 4B] = _4;
p9_24 = malloc (0);
_5 = malloc (1);
MEM[(struct st *)p9_24 + 48B].f = _5;
free (p9_24);
p_29 = malloc (10);
_6 = malloc (1);
MEM[(struct st *)p_29 + 48B].f = _6;
_7 = malloc (1);
MEM[(struct st *)p_29 + 32B].f = _7;
foo (p_29);
_8 = foo9 (p5_35(D));
_9 = (long int) _8;
p5_37 = (int *) _9;
if (test_38(D) != 0)
  goto <bb 3>; [33.00%]
else
  goto <bb 12>; [67.00%]

=======is loop:0=========

 bb index 3 
<bb 3> [local count: 354334800]:
foo9 (p5_37);
if (test_38(D) > test2_40(D))
  goto <bb 4>; [50.00%]
else
  goto <bb 7>; [50.00%]

=======is loop:0=========

 bb index 4 
<bb 4> [local count: 177167400]:
foo (p_29);
if (test_38(D) < test2_40(D))
  goto <bb 5>; [50.00%]
else
  goto <bb 6>; [50.00%]

=======is loop:0=========

 bb index 5 
<bb 5> [local count: 88583700]:
foo (p_29);
foo9 (p5_37);
goto <bb 10>; [100.00%]

=======is loop:0=========

 bb index 6 
<bb 6> [local count: 88583700]:
foo (p_29);
goto <bb 10>; [100.00%]

=======is loop:0=========

 bb index 7 
<bb 7> [local count: 177167400]:
foo (p_29);
if (test_38(D) < test2_40(D))
  goto <bb 8>; [50.00%]
else
  goto <bb 9>; [50.00%]

=======is loop:0=========

 bb index 8 
<bb 8> [local count: 88583700]:
foo (p3_43(D));
goto <bb 10>; [100.00%]

=======is loop:0=========

 bb index 9 
<bb 9> [local count: 88583700]:
foo9 (p5_37);

=======is loop:0=========

 bb index 10 
<bb 10> [local count: 354334800]:
if (test3_49(D) != 0)
  goto <bb 11>; [33.00%]
else
  goto <bb 12>; [67.00%]

=======is loop:0=========

 bb index 11 
<bb 11> [local count: 116930483]:
foo (p_29);

=======is loop:0=========

 bb index 12 
<bb 12> [local count: 1073741824]:
if (test_38(D) == test2_40(D))
  goto <bb 13>; [20.24%]
else
  goto <bb 14>; [79.76%]

=======is loop:0=========

 bb index 13 
<bb 13> [local count: 217325344]:
foo9 (p5_37);
goto <bb 18>; [100.00%]

=======is loop:0=========

 bb index 14 
<bb 14> [local count: 856416481]:
if (test_38(D) >= test2_40(D))
  goto <bb 15>; [33.00%]
else
  goto <bb 16>; [67.00%]

=======is loop:0=========

 bb index 15 
<bb 15> [local count: 282617437]:
foo9 (p5_37);
goto <bb 18>; [100.00%]

=======is loop:0=========

 bb index 16 
<bb 16> [local count: 573799044]:
if (test_38(D) > test2_40(D))
  goto <bb 17>; [33.00%]
else
  goto <bb 18>; [67.00%]

=======is loop:0=========

 bb index 17 
<bb 17> [local count: 189353683]:
foo9 (p5_37);
foo (p4_52(D));

=======is loop:0=========

 bb index 18 
<bb 18> [local count: 1073741824]:
return 0;

=======Mapping node_fun:foo9=========
=======is loop:0=========

 bb index 2 
<bb 2> [local count: 1073741824]:
free (z_2(D));
return;

=======Mapping node_fun:foo=========
=======is loop:0=========

 bb index 2 
<bb 2> [local count: 1073741824]:
free (z_2(D));
return;


===============Print ALL GIMPLE IR=================
[40;32mSTART CHECKSTART CHECKSTART CHECKSTART CHECKSTART CHECK[0m
    =()=
 ,/'_||_
  (___  `.
 ./  `=='
                   
    ~~~~~~~~~~~  
 ~~~~~~
           ~~~~~~~
[40;34m    gimple malloc count : 8 [0m
[40;34m    gimple free   count : 3 [0m
[40;34m    find Entry point : 12 [0m
[40;34m    used_stmt array stack totalsize of : 0.001712 mb[0m
[40;34m    collect time: : 0.000367 s [0m
[40;34m    algorithm time: 0.029256 s [0m
[40;34m    gimple stmt count : : 49 [0m
[40;32mSTART CHECKSTART CHECKSTART CHECKSTART CHECKSTART CHECK[0m
Profile consistency report:

                                 |mismatch     |mismatch     |                     |
Pass name                        |IN    |IN    |OUT   |OUT   |overall              |
                                 |freq  |count |freq  |count |size      |time      |
cp                   ------------|      |      |      |      |          |          |
inline               ------------|      |      |      |      |          |          |
fixup_cfg            ------------|      |      |      |      |          |          |
adjust_alignment     ------------|      |      |      |      |          |          |
ccp                  ------------|      |      |      |      |          |          |
backprop             ------------|      |      |      |      |          |          |
phiprop              ------------|      |      |      |      |          |          |
forwprop             ------------|      |      |      |      |          |          |
objsz                ------------|      |      |      |      |          |          |
alias                ------------|      |      |      |      |          |          |
retslot              ------------|      |      |      |      |          |          |
mergephi             ------------|      |      |      |      |          |          |
dce                  ------------|      |      |      |      |          |          |
stdarg               ------------|      |      |      |      |          |          |
cdce                 ------------|      |      |      |      |          |          |
cselim               ------------|      |      |      |      |          |          |
copyprop             ------------|      |      |      |      |          |          |
ifcombine            ------------|      |      |      |      |          |          |
mergephi             ------------|      |      |      |      |          |          |
phiopt               ------------|      |      |      |      |          |          |
ch                   ------------|      |      |      |      |          |          |
cplxlower            ------------|      |      |      |      |          |          |
sra                  ------------|      |      |      |      |          |          |
dom                              |      |      |      |      |     +2.3%|     -0.2%|
copyprop                         |      |      |      |      |     +2.2%|     -0.2%|
reassoc              ------------|      |      |      |      |          |          |
dce                  ------------|      |      |      |      |          |          |
forwprop             ------------|      |      |      |      |          |          |
phiopt               ------------|      |      |      |      |          |          |
ccp                  ------------|      |      |      |      |          |          |
sincos               ------------|      |      |      |      |          |          |
laddress             ------------|      |      |      |      |          |          |
lim                  ------------|      |      |      |      |          |          |
walloca              ------------|      |      |      |      |          |          |
sink                 ------------|      |      |      |      |          |          |
dce                  ------------|      |      |      |      |          |          |
fix_loops            ------------|      |      |      |      |          |          |
no_loop              ------------|      |      |      |      |          |          |
veclower2            ------------|      |      |      |      |          |          |
switchlower          ------------|      |      |      |      |          |          |
reassoc              ------------|      |      |      |      |          |          |
slsr                 ------------|      |      |      |      |          |          |
dom                              |      |      |      |      |     +1.1%|     -0.0%|
strlen                           |      |      |      |      |     +1.1%|     -0.0%|
copyprop             ------------|      |      |      |      |          |          |
wrestrict            ------------|      |      |      |      |          |          |
cddce                ------------|      |      |      |      |          |          |
forwprop             ------------|      |      |      |      |          |          |
phiopt               ------------|      |      |      |      |          |          |
fab                  ------------|      |      |      |      |          |          |
dce                  ------------|      |      |      |      |          |          |
crited               ------------|      |      |      |      |          |          |
uncprop              ------------|      |      |      |      |          |          |
local-pure-const     ------------|      |      |      |      |          |          |
modref               ------------|      |      |      |      |          |          |
nrv                  ------------|      |      |      |      |          |          |
isel                 ------------|      |      |      |      |          |          |
optimized            ------------|      |      |      |      |          |          |
expand                           |      |      |      |      |----------|----------|
vregs                            |      |      |      |      |    +74.0%|    +29.2%|
into_cfglayout                   |      |      |      |      |     -2.5%|     -1.0%|
jump                             |      |      |      |      |     -2.6%|     -1.0%|
subreg1              ------------|      |      |      |      |          |          |
dfinit               ------------|      |      |      |      |          |          |
cse1                 ------------|      |      |      |      |          |          |
fwprop1                          |      |      |      |      |     -3.0%|     -5.1%|
ce1                              |      |      |      |      |     -3.1%|     -5.4%|
reginfo              ------------|      |      |      |      |          |          |
loop2                ------------|      |      |      |      |          |          |
loop2_init           ------------|      |      |      |      |          |          |
loop2_invariant      ------------|      |      |      |      |          |          |
loop2_done           ------------|      |      |      |      |          |          |
dse1                 ------------|      |      |      |      |          |          |
fwprop2              ------------|      |      |      |      |          |          |
init-regs                        |      |      |      |      |     +7.5%|     +4.9%|
combine                          |      |      |      |      |    -24.2%|     -7.0%|
ce2                              |      |      |      |      |    -41.0%|    -12.6%|
outof_cfglayout      ------------|      |      |      |      |          |          |
split1               ------------|      |      |      |      |          |          |
subreg3              ------------|      |      |      |      |          |          |
mode_sw              ------------|      |      |      |      |          |          |
asmcons              ------------|      |      |      |      |          |          |
ira                              |      |      |      |      |     -0.7%|     -0.7%|
reload                           |      |      |      |      |    -14.9%|    -15.0%|
postreload                       |      |      |      |      |    -16.7%|    -16.8%|
split2               ------------|      |      |      |      |          |          |
cmpelim              ------------|      |      |      |      |          |          |
pro_and_epilogue                 |      |      |      |      |     +7.4%|     +7.4%|
dse2                             |      |      |      |      |     +6.9%|     +6.9%|
csa                  ------------|      |      |      |      |          |          |
jump2                ------------|      |      |      |      |          |          |
ce3                  ------------|      |      |      |      |          |          |
cprop_hardreg        ------------|      |      |      |      |          |          |
rtl_dce              ------------|      |      |      |      |          |          |
bbro                 ------------|      |      |      |      |          |          |
split4               ------------|      |      |      |      |          |          |
stack                ------------|      |      |      |      |          |          |
zero_call_used_regs  ------------|      |      |      |      |          |          |
alignments           ------------|      |      |      |      |          |          |
