test.c: In function â€˜fooâ€™:
test.c:14:5: warning: assignment makes integer from pointer without a cast [-Wint-conversion]
  *z = malloc(10);
     ^
=======ipa_pta=========
hwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwas
# .MEM_8 = VDEF <.MEM_7(D)>
_1 = malloc (10);
bb index 2
hwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwas
hwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwas
_2 = (long int) _1;
bb index 2
hwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwas
hwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwas
_3 = (int) _2;
bb index 2
hwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwas
hwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwas
# .MEM_9 = VDEF <.MEM_8>
*z_6(D) = _3;
bb index 2
hwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwas
hwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwas
# VUSE <.MEM_9>
return;
bb index 2
hwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwas
if (test_2(D) != 0)
--------GIMPLE Cond -------
node:= 2 
 true succs:= 3
 false succs:= 10
hwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwas
if (test_2(D) != 0)
bb index 2
hwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwas
if (test_2(D) > test2_3(D))
--------GIMPLE Cond -------
node:= 3 
 true succs:= 4
 false succs:= 7
prev succs:= 2
path constaint-----------
succs:= 2
if (test_2(D) != 0)
 relate logic:= 1
3index 1
hwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwas
if (test_2(D) > test2_3(D))
path constaint-----------
succs:= 2
if (test_2(D) != 0)
 relate logic:= 1
bb index 3
hwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwas
hwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwas
# .MEM_20 = VDEF <.MEM_14(D)>
foo (p_7(D));
path constaint-----------
succs:= 3
if (test_2(D) > test2_3(D))
 relate logic:= 1
3index 1
-----------
succs:= 2
if (test_2(D) != 0)
 relate logic:= 1
bb index 4
hwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwas
if (test_2(D) < test2_3(D))
--------GIMPLE Cond -------
node:= 4 
 true succs:= 5
 false succs:= 6
prev succs:= 3
sub prevlogic:= 1
path constaint-----------
succs:= 3
if (test_2(D) > test2_3(D))
 relate logic:= 1
-----------
succs:= 2
if (test_2(D) != 0)
 relate logic:= 1
hwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwas
if (test_2(D) < test2_3(D))
path constaint-----------
succs:= 3
if (test_2(D) > test2_3(D))
 relate logic:= 1
-----------
succs:= 2
if (test_2(D) != 0)
 relate logic:= 1
bb index 4
hwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwas
hwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwas
# .MEM_22 = VDEF <.MEM_20>
foo (p_7(D));
path constaint-----------
succs:= 4
if (test_2(D) < test2_3(D))
 relate logic:= 1
3index 1
-----------
succs:= 3
if (test_2(D) > test2_3(D))
 relate logic:= 1
-----------
succs:= 2
if (test_2(D) != 0)
 relate logic:= 1
bb index 5
hwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwas
hwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwas
# .MEM_21 = VDEF <.MEM_20>
foo (p_7(D));
path constaint-----------
succs:= 4
if (test_2(D) < test2_3(D))
 relate logic:= 0
3index 0
-----------
succs:= 3
if (test_2(D) > test2_3(D))
 relate logic:= 1
-----------
succs:= 2
if (test_2(D) != 0)
 relate logic:= 1
bb index 6
hwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwas
hwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwas
# .MEM_17 = VDEF <.MEM_14(D)>
foo (p_7(D));
path constaint-----------
succs:= 3
if (test_2(D) > test2_3(D))
 relate logic:= 0
3index 0
-----------
succs:= 2
if (test_2(D) != 0)
 relate logic:= 1
bb index 7
hwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwas
if (test_2(D) < test2_3(D))
--------GIMPLE Cond -------
node:= 7 
 true succs:= 8
 false succs:= 9
prev succs:= 3
sub prevlogic:= 1
path constaint-----------
succs:= 3
if (test_2(D) > test2_3(D))
 relate logic:= 0
-----------
succs:= 2
if (test_2(D) != 0)
 relate logic:= 1
hwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwas
if (test_2(D) < test2_3(D))
path constaint-----------
succs:= 3
if (test_2(D) > test2_3(D))
 relate logic:= 0
-----------
succs:= 2
if (test_2(D) != 0)
 relate logic:= 1
bb index 7
hwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwas
hwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwas
# .MEM_19 = VDEF <.MEM_17>
foo (p3_12(D));
path constaint-----------
succs:= 7
if (test_2(D) < test2_3(D))
 relate logic:= 1
3index 1
-----------
succs:= 3
if (test_2(D) > test2_3(D))
 relate logic:= 0
-----------
succs:= 2
if (test_2(D) != 0)
 relate logic:= 1
bb index 8
hwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwas
hwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwas
# .MEM_18 = VDEF <.MEM_17>
foo (p5_10(D));
path constaint-----------
succs:= 7
if (test_2(D) < test2_3(D))
 relate logic:= 0
3index 0
-----------
succs:= 3
if (test_2(D) > test2_3(D))
 relate logic:= 0
-----------
succs:= 2
if (test_2(D) != 0)
 relate logic:= 1
bb index 9
hwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwas
if (test_2(D) == test2_3(D))
--------GIMPLE Cond -------
node:= 10 
 true succs:= 11
 false succs:= 12
prev succs:= 2
path constaint-----------
succs:= 2
if (test_2(D) != 0)
 relate logic:= 0
3index 0
hwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwas
if (test_2(D) == test2_3(D))
path constaint-----------
succs:= 2
if (test_2(D) != 0)
 relate logic:= 0
bb index 10
hwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwas
hwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwas
# .MEM_16 = VDEF <.MEM_14(D)>
foo (p_7(D));
path constaint-----------
succs:= 10
if (test_2(D) == test2_3(D))
 relate logic:= 1
3index 1
-----------
succs:= 2
if (test_2(D) != 0)
 relate logic:= 0
bb index 11
hwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwas
if (test_2(D) > test2_3(D))
--------GIMPLE Cond -------
node:= 12 
 true succs:= 13
 false succs:= 14
prev succs:= 10
sub prevlogic:= 0
path constaint-----------
succs:= 10
if (test_2(D) == test2_3(D))
 relate logic:= 0
3index 0
-----------
succs:= 2
if (test_2(D) != 0)
 relate logic:= 0
hwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwas
if (test_2(D) > test2_3(D))
path constaint-----------
succs:= 10
if (test_2(D) == test2_3(D))
 relate logic:= 0
-----------
succs:= 2
if (test_2(D) != 0)
 relate logic:= 0
bb index 12
hwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwas
hwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwas
# .MEM_15 = VDEF <.MEM_14(D)>
foo (p4_5(D));
path constaint-----------
succs:= 12
if (test_2(D) > test2_3(D))
 relate logic:= 1
3index 1
-----------
succs:= 10
if (test_2(D) == test2_3(D))
 relate logic:= 0
-----------
succs:= 2
if (test_2(D) != 0)
 relate logic:= 0
bb index 13
hwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwas
hwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwas
# VUSE <.MEM_13>
return 0;
path constaint-----------
succs:= 12
if (test_2(D) > test2_3(D))
 relate logic:= 0
3index 0
-----------
succs:= 10
if (test_2(D) == test2_3(D))
 relate logic:= 0
-----------
succs:= 2
if (test_2(D) != 0)
 relate logic:= 0
bb index 14
hwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwas
start PointerConstraint
pointer ftable is 0 
pointer ptable is 1 
# .MEM_8 = VDEF <.MEM_7(D)>
_1 = malloc (10);
# .MEM_20 = VDEF <.MEM_14(D)>
foo (p_7(D));
# .MEM_22 = VDEF <.MEM_20>
foo (p_7(D));
# .MEM_21 = VDEF <.MEM_20>
foo (p_7(D));
# .MEM_17 = VDEF <.MEM_14(D)>
foo (p_7(D));
# .MEM_19 = VDEF <.MEM_17>
foo (p3_12(D));
# .MEM_18 = VDEF <.MEM_17>
foo (p5_10(D));
# .MEM_16 = VDEF <.MEM_14(D)>
foo (p_7(D));
# .MEM_15 = VDEF <.MEM_14(D)>
foo (p4_5(D));
start collect similar stmtstart collect similar stmtstart collect similar stmtstart collect similar stmt
start collect similar stmtstart collect similar stmtstart collect similar stmtstart collect similar stmt
start collect similar stmtstart collect similar stmtstart collect similar stmtstart collect similar stmt
start collect similar stmtstart collect similar stmtstart collect similar stmtstart collect similar stmt
start collect similar stmtstart collect similar stmtstart collect similar stmtstart collect similar stmt
[40;41mSTART CHECKSTART CHECKSTART CHECKSTART CHECKSTART CHECK[0m
[40;41mSTART CHECKSTART CHECKSTART CHECKSTART CHECKSTART CHECK[0m
    =()=
 ,/'_||_
  (___  `.
 ./  `=='
      |||
      |||
      |||
      |||
[40;41mSTART CHECKSTART CHECKSTART CHECKSTART CHECKSTART CHECK[0m
[40;41mSTART CHECKSTART CHECKSTART CHECKSTART CHECKSTART CHECK[0m
=======================================================
[40;44m =======node_fun:foo========= [0m
[40;44m fucntion collect path  [0m
[40;44m =======print_function_path foo  function_call count: 1 level :0========  [0m
[40;42m =======pre add _ fucntion:malloc========= [0m
[40;33m =======POP node_fun stack:malloc========= [0m
[40;42m =======pre_check_funciton:foo========= [0m
[40;42m =======start_check_funciton:foo========= [0m

dot graph START

======================================================================
 <ssa_name 0x7f96a648d708
    type <pointer_type 0x7f96a64a00a8
        type <void_type 0x7f96a6499f18 void VOID
            align 8 symtab 0 alias set -1 structural equality
            pointer_to_this <pointer_type 0x7f96a64a00a8>>
        public unsigned DI
        size <integer_cst 0x7f96a6485be8 constant 64>
        unit size <integer_cst 0x7f96a6485c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality
        pointer_to_this <pointer_type 0x7f96a64a5bd0>>
   
    def_stmt _1 = malloc (10);
    version 1
    ptr-info 0x7f96a5fbaaf8>

 ================== trace ptable================== 
trace fucntion name:malloc 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr---malloc-----
this Reserved word function ------malloc-----
 
 Start check Pointer Collect  

======================================================================
_2 = (long int) _1;
In function â€˜fooâ€™:
test.c:14:5: warning: use location
  *z = malloc(10);
     ^
_3 = (int) _2;
test.c:14:5: warning: use location
*z_6(D) = _3;
test.c:14:5: warning: use location

 ================== Start Use after free Check ================== 

dot graph END

 ================== Start Use after free Check ================== 

======================================================================
[40;31m    no free stmt possible memory leak [0m

======================================================================

dot graph START

======================================================================
 <integer_cst 0x7f96a5fbaab0 type <integer_type 0x7f96a5fb7930 size_t> constant 10>
[40;33m =======POP node_fun stack:foo========= [0m
[40;44m =======node_fun:main========= [0m
[40;44m fucntion collect path  [0m
[40;44m =======print_function_path main  function_call count: 1 level :0========  [0m
[40;44m =======print_function_type 0  ========  [0m
[40;42m =======pre add _ fucntion:foo========= [0m
[40;44m =======print_function_path foo  function_call count: 1 level :1========  [0m
[40;42m =======pre add _ fucntion:malloc========= [0m
[40;33m =======POP node_fun stack:malloc========= [0m
[40;42m =======pre_check_funciton:foo========= [0m
[40;42m =======start_check_funciton:foo========= [0m

dot graph START

======================================================================
 <ssa_name 0x7f96a648d708
    type <pointer_type 0x7f96a64a00a8
        type <void_type 0x7f96a6499f18 void VOID
            align 8 symtab 0 alias set -1 structural equality
            pointer_to_this <pointer_type 0x7f96a64a00a8>>
        public unsigned DI
        size <integer_cst 0x7f96a6485be8 constant 64>
        unit size <integer_cst 0x7f96a6485c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality
        pointer_to_this <pointer_type 0x7f96a64a5bd0>>
   
    def_stmt _1 = malloc (10);
    version 1
    ptr-info 0x7f96a5fbaaf8>

 ================== trace ptable================== 
trace fucntion name:malloc 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr---malloc-----
this Reserved word function ------malloc-----
 
 Start check Pointer Collect  

======================================================================
_2 = (long int) _1;
In function â€˜mainâ€™:
test.c:14:5: warning: use location
_3 = (int) _2;
test.c:14:5: warning: use location
*z_6(D) = _3;
test.c:14:5: warning: use location

 ================== Start Use after free Check ================== 

dot graph END

 ================== Start Use after free Check ================== 

======================================================================
[40;31m    no free stmt possible memory leak [0m

======================================================================

dot graph START

======================================================================
 <integer_cst 0x7f96a5fbaab0 type <integer_type 0x7f96a5fb7930 size_t> constant 10>
[40;33m =======POP node_fun stack:foo========= [0m
[40;42m =======pre_check_funciton:main========= [0m
[40;42m =======start_check_funciton:main========= [0m

dot graph START

======================================================================
 <ssa_name 0x7f96a648da68
    type <pointer_type 0x7f96a64a0a80
        type <integer_type 0x7f96a64995e8 int public SI
            size <integer_cst 0x7f96a6485e28 constant 32>
            unit size <integer_cst 0x7f96a6485e40 constant 4>
            align 32 symtab 0 alias set -1 canonical type 0x7f96a64995e8 precision 32 min <integer_cst 0x7f96a6485de0 -2147483648> max <integer_cst 0x7f96a6485df8 2147483647>
            pointer_to_this <pointer_type 0x7f96a64a0a80>>
        public unsigned DI
        size <integer_cst 0x7f96a6485be8 constant 64>
        unit size <integer_cst 0x7f96a6485c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality>
    var <var_decl 0x7f96a721aea0 p>
    def_stmt GIMPLE_NOP
    version 7
    ptr-info 0x7f96a5fbab40>

 ================== trace ptable================== 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr--------
this other function -----------
 
 Start check Pointer Collect  

======================================================================

 Expand conflict 
 The same function may have multiple branches :foo
# .MEM_20 = VDEF <.MEM_14(D)>
foo (p_7(D));
test.c:54:4: warning: use location
    foo(p);
    ^
# .MEM_16 = VDEF <.MEM_14(D)>
foo (p_7(D));
==============symbolic excution===========================
succs:= 10
if (test_2(D) == test2_3(D))
	relate logic:= 1
succs:= 2
if (test_2(D) != 0)
	relate logic:= 0
==============symbolic excution===========================
test.c:78:3: warning: use location
   foo(p);
   ^

 Expand conflict 
 The same function may have multiple branches :foo
# .MEM_20 = VDEF <.MEM_14(D)>
foo (p_7(D));
test.c:54:4: warning: use location
    foo(p);
    ^
# .MEM_17 = VDEF <.MEM_14(D)>
foo (p_7(D));
==============symbolic excution===========================
=succs:= 3
if (test_2(D) > test2_3(D))
	relate logic:= 0
=succs:= 2
if (test_2(D) != 0)
	relate logic:= 1
==============symbolic excution===========================
test.c:64:4: warning: use location
    foo(p);
    ^

 Expand conflict 
 The same function may have multiple branches :foo
# .MEM_20 = VDEF <.MEM_14(D)>
foo (p_7(D));
test.c:54:4: warning: use location
    foo(p);
    ^
# .MEM_21 = VDEF <.MEM_20>
foo (p_7(D));
==============symbolic excution===========================
=succs:= 4
if (test_2(D) < test2_3(D))
	relate logic:= 0
=succs:= 3
if (test_2(D) > test2_3(D))
	relate logic:= 1
=succs:= 2
if (test_2(D) != 0)
	relate logic:= 1
==============symbolic excution===========================
test.c:60:5: warning: use location
     foo(p);
     ^

 Expand conflict 
 The same function may have multiple branches :foo
# .MEM_20 = VDEF <.MEM_14(D)>
foo (p_7(D));
test.c:54:4: warning: use location
    foo(p);
    ^
# .MEM_22 = VDEF <.MEM_20>
foo (p_7(D));
==============symbolic excution===========================
succs:= 4
if (test_2(D) < test2_3(D))
	relate logic:= 1
succs:= 3
if (test_2(D) > test2_3(D))
	relate logic:= 1
succs:= 2
if (test_2(D) != 0)
	relate logic:= 1
==============symbolic excution===========================
test.c:57:5: warning: use location
     foo(p);
     ^
# .MEM_20 = VDEF <.MEM_14(D)>
foo (p_7(D));
==============symbolic excution===========================
succs:= 3
if (test_2(D) > test2_3(D))
	relate logic:= 1
succs:= 2
if (test_2(D) != 0)
	relate logic:= 1
==============symbolic excution===========================
foo (p_7(D));
test.c:54:4: warning: use location
    foo(p);
    ^
this stmt is child function---foo-----

 ================== trace ================== 
 <ssa_name 0x7f96a648da68
    type <pointer_type 0x7f96a64a0a80
        type <integer_type 0x7f96a64995e8 int public SI
            size <integer_cst 0x7f96a6485e28 constant 32>
            unit size <integer_cst 0x7f96a6485e40 constant 4>
            align 32 symtab 0 alias set -1 canonical type 0x7f96a64995e8 precision 32 min <integer_cst 0x7f96a6485de0 -2147483648> max <integer_cst 0x7f96a6485df8 2147483647>
            pointer_to_this <pointer_type 0x7f96a64a0a80>>
        public unsigned DI
        size <integer_cst 0x7f96a6485be8 constant 64>
        unit size <integer_cst 0x7f96a6485c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality>
    var <var_decl 0x7f96a721aea0 p>
    def_stmt GIMPLE_NOP
    version 7
    ptr-info 0x7f96a5fbab40>
trace fucntion name:foo 
[40;44m =======trace_function_path foo  function_call count: 1 level :0========  [0m
[40;36m ======= node_fun:foo========= [0m
[40;36m ======= find relate stmt with p ========= [0m
[40;36m ======= relate stmt argument:p ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:malloc========= [0m
[40;46m =======add node_fun stack:malloc========= [0m

 ================== trace ================== 
trace fucntion free:0 

 ================== Start Use after free Check ================== 

dot graph END

 ================== Start Use after free Check ================== 

======================================================================
[40;31m    no free stmt possible memory leak [0m

======================================================================

dot graph START

======================================================================
 <ssa_name 0x7f96a648da68
    type <pointer_type 0x7f96a64a0a80
        type <integer_type 0x7f96a64995e8 int public SI
            size <integer_cst 0x7f96a6485e28 constant 32>
            unit size <integer_cst 0x7f96a6485e40 constant 4>
            align 32 symtab 0 alias set -1 canonical type 0x7f96a64995e8 precision 32 min <integer_cst 0x7f96a6485de0 -2147483648> max <integer_cst 0x7f96a6485df8 2147483647>
            pointer_to_this <pointer_type 0x7f96a64a0a80>>
        public unsigned DI
        size <integer_cst 0x7f96a6485be8 constant 64>
        unit size <integer_cst 0x7f96a6485c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality>
    var <var_decl 0x7f96a721aea0 p>
    def_stmt GIMPLE_NOP
    version 7
    ptr-info 0x7f96a5fbab40>

 ================== trace ptable================== 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr--------
this other function -----------
 
 Start check Pointer Collect  

======================================================================

 Expand conflict 
 The same function may have multiple branches :foo
# .MEM_22 = VDEF <.MEM_20>
foo (p_7(D));
test.c:57:5: warning: use location
     foo(p);
     ^
# .MEM_16 = VDEF <.MEM_14(D)>
foo (p_7(D));
==============symbolic excution===========================
succs:= 10
if (test_2(D) == test2_3(D))
	relate logic:= 1
succs:= 2
if (test_2(D) != 0)
	relate logic:= 0
==============symbolic excution===========================
test.c:78:3: warning: use location
   foo(p);
   ^

 Expand conflict 
 The same function may have multiple branches :foo
# .MEM_22 = VDEF <.MEM_20>
foo (p_7(D));
test.c:57:5: warning: use location
     foo(p);
     ^
# .MEM_17 = VDEF <.MEM_14(D)>
foo (p_7(D));
==============symbolic excution===========================
=succs:= 3
if (test_2(D) > test2_3(D))
	relate logic:= 0
=succs:= 2
if (test_2(D) != 0)
	relate logic:= 1
==============symbolic excution===========================
test.c:64:4: warning: use location
    foo(p);
    ^

 Expand conflict 
 The same function may have multiple branches :foo
# .MEM_22 = VDEF <.MEM_20>
foo (p_7(D));
test.c:57:5: warning: use location
     foo(p);
     ^
# .MEM_21 = VDEF <.MEM_20>
foo (p_7(D));
==============symbolic excution===========================
=succs:= 4
if (test_2(D) < test2_3(D))
	relate logic:= 0
=succs:= 3
if (test_2(D) > test2_3(D))
	relate logic:= 1
=succs:= 2
if (test_2(D) != 0)
	relate logic:= 1
==============symbolic excution===========================
test.c:60:5: warning: use location
     foo(p);
     ^
# .MEM_22 = VDEF <.MEM_20>
foo (p_7(D));
==============symbolic excution===========================
succs:= 4
if (test_2(D) < test2_3(D))
	relate logic:= 1
succs:= 3
if (test_2(D) > test2_3(D))
	relate logic:= 1
succs:= 2
if (test_2(D) != 0)
	relate logic:= 1
==============symbolic excution===========================
foo (p_7(D));
test.c:57:5: warning: use location
     foo(p);
     ^
this stmt is child function---foo-----

 ================== trace ================== 
 <ssa_name 0x7f96a648da68
    type <pointer_type 0x7f96a64a0a80
        type <integer_type 0x7f96a64995e8 int public SI
            size <integer_cst 0x7f96a6485e28 constant 32>
            unit size <integer_cst 0x7f96a6485e40 constant 4>
            align 32 symtab 0 alias set -1 canonical type 0x7f96a64995e8 precision 32 min <integer_cst 0x7f96a6485de0 -2147483648> max <integer_cst 0x7f96a6485df8 2147483647>
            pointer_to_this <pointer_type 0x7f96a64a0a80>>
        public unsigned DI
        size <integer_cst 0x7f96a6485be8 constant 64>
        unit size <integer_cst 0x7f96a6485c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality>
    var <var_decl 0x7f96a721aea0 p>
    def_stmt GIMPLE_NOP
    version 7
    ptr-info 0x7f96a5fbab40>
trace fucntion name:foo 
[40;44m =======trace_function_path foo  function_call count: 1 level :0========  [0m
[40;36m ======= node_fun:foo========= [0m
[40;36m ======= find relate stmt with p ========= [0m
[40;36m ======= relate stmt argument:p ========= [0m
fucntion collect path finsh
[40;42m =======pre add _ fucntion:malloc========= [0m
[40;46m =======add node_fun stack:malloc========= [0m

 ================== trace ================== 
trace fucntion free:0 

 Expand conflict 
 The same function may have multiple branches :foo
# .MEM_22 = VDEF <.MEM_20>
foo (p_7(D));
test.c:57:5: warning: use location
# .MEM_20 = VDEF <.MEM_14(D)>
foo (p_7(D));
==============symbolic excution===========================
succs:= 3
if (test_2(D) > test2_3(D))
	relate logic:= 1
succs:= 2
if (test_2(D) != 0)
	relate logic:= 1
==============symbolic excution===========================
test.c:54:4: warning: use location
    foo(p);
    ^

 ================== Start Use after free Check ================== 

dot graph END

 ================== Start Use after free Check ================== 

======================================================================
[40;31m    no free stmt possible memory leak [0m

======================================================================

dot graph START

======================================================================
 <ssa_name 0x7f96a648daf8
    type <pointer_type 0x7f96a64a0a80
        type <integer_type 0x7f96a64995e8 int public SI
            size <integer_cst 0x7f96a6485e28 constant 32>
            unit size <integer_cst 0x7f96a6485e40 constant 4>
            align 32 symtab 0 alias set -1 canonical type 0x7f96a64995e8 precision 32 min <integer_cst 0x7f96a6485de0 -2147483648> max <integer_cst 0x7f96a6485df8 2147483647>
            pointer_to_this <pointer_type 0x7f96a64a0a80>>
        public unsigned DI
        size <integer_cst 0x7f96a6485be8 constant 64>
        unit size <integer_cst 0x7f96a6485c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality>
    var <var_decl 0x7f96a721ae10 p3>
    def_stmt GIMPLE_NOP
    version 12
    ptr-info 0x7f96a5fbab70>

 ================== trace ptable================== 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr--------
this other function -----------

======================================================================
[40;31m 	Can't find this fucntion in Pointer table [0m
[40;31m 	Possiable no other stmt relate with this stmt [0m

======================================================================

dot graph START

======================================================================
 <ssa_name 0x7f96a648dab0
    type <pointer_type 0x7f96a64a0a80
        type <integer_type 0x7f96a64995e8 int public SI
            size <integer_cst 0x7f96a6485e28 constant 32>
            unit size <integer_cst 0x7f96a6485e40 constant 4>
            align 32 symtab 0 alias set -1 canonical type 0x7f96a64995e8 precision 32 min <integer_cst 0x7f96a6485de0 -2147483648> max <integer_cst 0x7f96a6485df8 2147483647>
            pointer_to_this <pointer_type 0x7f96a64a0a80>>
        public unsigned DI
        size <integer_cst 0x7f96a6485be8 constant 64>
        unit size <integer_cst 0x7f96a6485c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality>
    var <var_decl 0x7f96a721acf0 p5>
    def_stmt GIMPLE_NOP
    version 10
    ptr-info 0x7f96a5fbab58>

 ================== trace ptable================== 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr--------
this other function -----------

======================================================================
[40;31m 	Can't find this fucntion in Pointer table [0m
[40;31m 	Possiable no other stmt relate with this stmt [0m

======================================================================

dot graph START

======================================================================
 <ssa_name 0x7f96a648da20
    type <pointer_type 0x7f96a64a0a80
        type <integer_type 0x7f96a64995e8 int public SI
            size <integer_cst 0x7f96a6485e28 constant 32>
            unit size <integer_cst 0x7f96a6485e40 constant 4>
            align 32 symtab 0 alias set -1 canonical type 0x7f96a64995e8 precision 32 min <integer_cst 0x7f96a6485de0 -2147483648> max <integer_cst 0x7f96a6485df8 2147483647>
            pointer_to_this <pointer_type 0x7f96a64a0a80>>
        public unsigned DI
        size <integer_cst 0x7f96a6485be8 constant 64>
        unit size <integer_cst 0x7f96a6485c00 constant 8>
        align 64 symtab 0 alias set -1 structural equality>
    var <var_decl 0x7f96a721ad80 p4>
    def_stmt GIMPLE_NOP
    version 5
    ptr-info 0x7f96a5fbab28>

 ================== trace ptable================== 

 ================== trace ptable ================== 
GIMPLE CODE :addr_expr--------
this other function -----------

======================================================================
[40;31m 	Can't find this fucntion in Pointer table [0m
[40;31m 	Possiable no other stmt relate with this stmt [0m

======================================================================
[40;33m =======POP node_fun stack:main========= [0m
fucntion collect path finsh
=======Mapping node_fun:foo=========
<bb 2> [100.00%]:
_1 = malloc (10);
_2 = (long int) _1;
_3 = (int) _2;
*z_6(D) = _3;
return;

=======is loop:0=========
=======Mapping node_fun:main=========
<bb 2> [100.00%]:
if (test_2(D) != 0)
  goto <bb 3>; [50.00%]
else
  goto <bb 10>; [50.00%]

=======is loop:0=========
<bb 3> [50.00%]:
if (test_2(D) > test2_3(D))
  goto <bb 4>; [50.00%]
else
  goto <bb 7>; [50.00%]

=======is loop:0=========
<bb 4> [25.00%]:
foo (p_7(D));
if (test_2(D) < test2_3(D))
  goto <bb 5>; [50.00%]
else
  goto <bb 6>; [50.00%]

=======is loop:0=========
<bb 5> [12.50%]:
foo (p_7(D));
goto <bb 14>; [100.00%]

=======is loop:0=========
<bb 6> [12.50%]:
foo (p_7(D));
goto <bb 14>; [100.00%]

=======is loop:0=========
<bb 7> [25.00%]:
foo (p_7(D));
if (test_2(D) < test2_3(D))
  goto <bb 8>; [50.00%]
else
  goto <bb 9>; [50.00%]

=======is loop:0=========
<bb 8> [12.50%]:
foo (p3_12(D));
goto <bb 14>; [100.00%]

=======is loop:0=========
<bb 9> [12.50%]:
foo (p5_10(D));
goto <bb 14>; [100.00%]

=======is loop:0=========
<bb 10> [50.00%]:
if (test_2(D) == test2_3(D))
  goto <bb 11>; [17.77%]
else
  goto <bb 12>; [82.23%]

=======is loop:0=========
<bb 11> [8.88%]:
foo (p_7(D));
goto <bb 14>; [100.00%]

=======is loop:0=========
<bb 12> [41.12%]:
if (test_2(D) > test2_3(D))
  goto <bb 13>; [36.64%]
else
  goto <bb 14>; [63.36%]

=======is loop:0=========
<bb 13> [15.06%]:
foo (p4_5(D));

=======is loop:0=========
<bb 14> [100.00%]:
return 0;

=======is loop:0=========
[40;32mSTART CHECKSTART CHECKSTART CHECKSTART CHECKSTART CHECK[0m
    =()=
 ,/'_||_
  (___  `.
 ./  `=='
                   
    ~~~~~~~~~~~  
 ~~~~~~
           ~~~~~~~
[40;34m    find Entry point : 2 [0m
[40;34m    used_stmt array stack totalsize of : 240 [0m
[40;34m    collect time: : 0.000051 s [0m
[40;34m    algorithm time: 0.004588 s [0m
[40;34m    gimple stmt count : : 20 [0m
[40;32mSTART CHECKSTART CHECKSTART CHECKSTART CHECKSTART CHECK[0m
