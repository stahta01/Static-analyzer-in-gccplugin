
;; Function discard_cleanups (discard_cleanups, funcdef_no=22, decl_uid=3018, cgraph_uid=23, symbol_order=27)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
void discard_cleanups (struct cleanup * old_chain)
{
  <bb 2> :
  discard_my_cleanups (&cleanup_chain, old_chain);
  return;

}



;; Function discard_final_cleanups (discard_final_cleanups, funcdef_no=23, decl_uid=3023, cgraph_uid=24, symbol_order=28)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
void discard_final_cleanups (struct cleanup * old_chain)
{
  <bb 2> :
  discard_my_cleanups (&final_cleanup_chain, old_chain);
  return;

}



;; Function discard_my_cleanups (discard_my_cleanups, funcdef_no=24, decl_uid=3021, cgraph_uid=25, symbol_order=29)

;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7
;;
;; Loop 1
;;  header 6, latch 5
;;  depth 1, outer 0
;;  nodes: 6 5 3 4
;; 2 succs { 6 }
;; 3 succs { 4 5 }
;; 4 succs { 5 }
;; 5 succs { 6 }
;; 6 succs { 3 7 }
;; 7 succs { 1 }
void discard_my_cleanups (struct cleanup * * pmy_chain, struct cleanup * old_chain)
{
  struct cleanup * ptr;

  <bb 2> :
  goto <bb 6>; [INV]

  <bb 3> :
  _1 = ptr->next;
  *pmy_chain = _1;
  _2 = ptr->free_arg;
  if (_2 != 0B)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  _3 = ptr->free_arg;
  _4 = ptr->arg;
  _3 (_4);

  <bb 5> :
  free (ptr);

  <bb 6> :
  ptr = *pmy_chain;
  if (ptr != old_chain)
    goto <bb 3>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  _5 = ptr->arg;
  printf ("freearg: %x\n", _5);
  return;

}



;; Function do_cleanups (do_cleanups, funcdef_no=26, decl_uid=3028, cgraph_uid=27, symbol_order=31)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
void do_cleanups (struct cleanup * old_chain)
{
  <bb 2> :
  do_my_cleanups (&cleanup_chain, old_chain);
  return;

}



;; Function do_my_cleanups (do_my_cleanups, funcdef_no=25, decl_uid=3026, cgraph_uid=26, symbol_order=30)

;; 2 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7
;;
;; Loop 1
;;  header 6, latch 5
;;  depth 1, outer 0
;;  nodes: 6 5 3 4
;; 2 succs { 6 }
;; 3 succs { 4 5 }
;; 4 succs { 5 }
;; 5 succs { 6 }
;; 6 succs { 3 7 }
;; 7 succs { 1 }
void do_my_cleanups (struct cleanup * * pmy_chain, struct cleanup * old_chain)
{
  struct cleanup * ptr;

  <bb 2> :
  goto <bb 6>; [INV]

  <bb 3> :
  _1 = ptr->next;
  *pmy_chain = _1;
  _2 = ptr->function;
  _3 = ptr->arg;
  _2 (_3);
  __builtin_puts (&"cleanup!!!!! ========="[0]);
  _4 = ptr->arg;
  printf ("%x\n", _4);
  _5 = ptr->free_arg;
  if (_5 != 0B)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  _6 = ptr->free_arg;
  _7 = ptr->arg;
  _6 (_7);

  <bb 5> :
  free (ptr);

  <bb 6> :
  ptr = *pmy_chain;
  if (ptr != old_chain)
    goto <bb 3>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 7> :
  return;

}



;; Function make_cleanup (make_cleanup, funcdef_no=29, decl_uid=3041, cgraph_uid=30, symbol_order=34)

Merging blocks 2 and 3
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
struct cleanup * make_cleanup (void (*<T59c>) (void *) function, void * arg)
{
  struct cleanup * D.3156;

  <bb 2> :
  D.3156 = make_my_cleanup (&cleanup_chain, function, arg);
  return D.3156;

}



;; Function make_my_cleanup (make_my_cleanup, funcdef_no=28, decl_uid=3038, cgraph_uid=29, symbol_order=33)

Merging blocks 2 and 3
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
struct cleanup * make_my_cleanup (struct cleanup * * pmy_chain, void (*<T59c>) (void *) function, void * arg)
{
  struct cleanup * D.3158;

  <bb 2> :
  D.3158 = make_my_cleanup2 (pmy_chain, function, arg, 0B);
  return D.3158;

}



;; Function make_my_cleanup2 (make_my_cleanup2, funcdef_no=27, decl_uid=3034, cgraph_uid=28, symbol_order=32)

Merging blocks 4 and 5
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4
;; 2 succs { 3 4 }
;; 3 succs { }
;; 4 succs { 1 }
struct cleanup * make_my_cleanup2 (struct cleanup * * pmy_chain, void (*<T59c>) (void *) function, void * arg, void (*<Tee>) (void *) free_arg)
{
  struct cleanup * old_chain;
  struct cleanup * new;
  struct cleanup * D.3162;

  <bb 2> :
  new = malloc (32);
  old_chain = *pmy_chain;
  _1 = *pmy_chain;
  new->next = _1;
  new->function = function;
  new->free_arg = free_arg;
  new->arg = arg;
  *pmy_chain = new;
  if (old_chain == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  exit (1);

  <bb 4> :
  D.3162 = old_chain;
  return D.3162;

}



;; Function vec_o_reserve (vec_o_reserve, funcdef_no=31, decl_uid=3102, cgraph_uid=32, symbol_order=36)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9
;; 2 succs { 3 4 }
;; 3 succs { 9 }
;; 4 succs { 5 6 }
;; 5 succs { }
;; 6 succs { 7 8 }
;; 7 succs { 8 }
;; 8 succs { 9 }
;; 9 succs { 1 }
void * vec_o_reserve (void * vec, int reserve, size_t vec_offset, size_t elt_size)
{
  unsigned int alloc;
  struct vec_prefix * pfx;
  void * D.3166;

  <bb 2> :
  pfx = vec;
  alloc = calculate_allocation (pfx, reserve);
  if (alloc == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  D.3166 = 0B;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 9>; [INV]

  <bb 4> :
  _1 = (long unsigned int) alloc;
  _2 = elt_size * _1;
  _3 = vec_offset + _2;
  vec = realloc (vec, _3);
  if (vec == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  exit (1);

  <bb 6> :
  MEM[(struct vec_prefix *)vec].alloc = alloc;
  if (pfx == 0B)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  MEM[(struct vec_prefix *)vec].num = 0;

  <bb 8> :
  D.3166 = vec;

  <bb 9> :
  return D.3166;

}



;; Function calculate_allocation (calculate_allocation, funcdef_no=30, decl_uid=3091, cgraph_uid=31, symbol_order=35)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18
;; 2 succs { 3 4 }
;; 3 succs { 6 }
;; 4 succs { 5 6 }
;; 5 succs { 18 }
;; 6 succs { 7 8 }
;; 7 succs { }
;; 8 succs { 9 10 }
;; 9 succs { 17 }
;; 10 succs { 11 12 }
;; 11 succs { 15 }
;; 12 succs { 13 14 }
;; 13 succs { 15 }
;; 14 succs { 15 }
;; 15 succs { 16 17 }
;; 16 succs { 17 }
;; 17 succs { 18 }
;; 18 succs { 1 }
unsigned int calculate_allocation (const struct vec_prefix * pfx, int reserve)
{
  unsigned int num;
  unsigned int alloc;
  unsigned int D.3177;

  <bb 2> :
  alloc = 0;
  num = 0;
  if (pfx != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  alloc = pfx->alloc;
  num = pfx->num;
  goto <bb 6>; [INV]

  <bb 4> :
  if (reserve == 0)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  D.3177 = 0;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 18>; [INV]

  <bb 6> :
  _1 = alloc - num;
  _2 = ABS_EXPR <reserve>;
  _3 = (unsigned int) _2;
  if (_1 >= _3)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  exit (1);

  <bb 8> :
  if (reserve < 0)
    goto <bb 9>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 9> :
  reserve.0_4 = (unsigned int) reserve;
  alloc = num - reserve.0_4;
  goto <bb 17>; [INV]

  <bb 10> :
  if (alloc == 0)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  alloc = 4;
  goto <bb 15>; [INV]

  <bb 12> :
  if (alloc <= 15)
    goto <bb 13>; [INV]
  else
    goto <bb 14>; [INV]

  <bb 13> :
  alloc = alloc * 2;
  goto <bb 15>; [INV]

  <bb 14> :
  _5 = alloc * 3;
  alloc = _5 / 2;

  <bb 15> :
  reserve.1_6 = (unsigned int) reserve;
  _7 = num + reserve.1_6;
  if (alloc < _7)
    goto <bb 16>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 16> :
  reserve.2_8 = (unsigned int) reserve;
  alloc = num + reserve.2_8;

  <bb 17> :
  D.3177 = alloc;

  <bb 18> :
  return D.3177;

}



;; Function null_cleanup (null_cleanup, funcdef_no=32, decl_uid=3116, cgraph_uid=33, symbol_order=37)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
void null_cleanup (void * arg)
{
  <bb 2> :
  return;

}



;; Function xrealloc (xrealloc, funcdef_no=33, decl_uid=3120, cgraph_uid=34, symbol_order=38)

Merging blocks 6 and 7
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6
;; 2 succs { 3 4 }
;; 3 succs { 4 }
;; 4 succs { 5 6 }
;; 5 succs { }
;; 6 succs { 1 }
void * xrealloc (void * oldmem, size_t size)
{
  void * newmem;
  void * D.3196;

  <bb 2> :
  if (size == 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  size = 1;

  <bb 4> :
  newmem = realloc (oldmem, size);
  if (newmem == 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  exit (1);

  <bb 6> :
  D.3196 = newmem;
  return D.3196;

}



;; Function main (main, funcdef_no=35, decl_uid=3148, cgraph_uid=36, symbol_order=40)

Merging blocks 2 and 3
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
int main ()
{
  const char * args[6];
  int D.3198;

  <bb 2> :
  args[0] = "prog";
  args[1] = "v";
  args[2] = "-s";
  args[3] = "idx";
  args[4] = "addr";
  args[5] = 0B;
  add_symbol_file_command (&args);
  args = {CLOBBER};
  D.3198 = 0;
  return D.3198;

}



;; Function add_symbol_file_command (add_symbol_file_command, funcdef_no=34, decl_uid=3124, cgraph_uid=35, symbol_order=39)

Removing basic block 10
Removing basic block 16
Merging blocks 27 and 28
;; 3 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
;;
;; Loop 2
;;  header 24, latch 23
;;  depth 1, outer 0
;;  nodes: 24 23
;;
;; Loop 1
;;  header 19, latch 18
;;  depth 1, outer 0
;;  nodes: 19 18 6 9 11 14 16 8 13 12 10 7 5 15
;; 2 succs { 3 4 }
;; 3 succs { }
;; 4 succs { 19 }
;; 5 succs { 6 7 }
;; 6 succs { 18 }
;; 7 succs { 8 10 }
;; 8 succs { 9 18 }
;; 9 succs { 18 }
;; 10 succs { 11 12 }
;; 11 succs { 18 }
;; 12 succs { 13 15 }
;; 13 succs { 14 18 }
;; 14 succs { 18 }
;; 15 succs { 16 17 }
;; 16 succs { 18 }
;; 17 succs { }
;; 18 succs { 19 }
;; 19 succs { 5 20 }
;; 20 succs { 21 22 }
;; 21 succs { }
;; 22 succs { 24 }
;; 23 succs { 24 }
;; 24 succs { 23 25 }
;; 25 succs { 1 }
void add_symbol_file_command (char * * args)
{
  const char * sec;
  const char * val;
  size_t num_sect_opts;
  struct sect_opt * sect_opts;
  struct section_addr_info * section_addrs;
  struct cleanup * my_cleanups;
  int i;
  int argcnt;
  int expecting_sec_name;
  int expecting_sec_addr;
  char * arg;
  int sec_num;
  int section_index;

  <bb 2> :
  section_index = 0;
  sec_num = 0;
  expecting_sec_addr = 0;
  expecting_sec_name = 0;
  argcnt = 0;
  my_cleanups = make_cleanup (null_cleanup, 0B);
  sect_opts = 0B;
  num_sect_opts = 0;
  num_sect_opts = 4;
  _1 = num_sect_opts * 16;
  sect_opts = malloc (_1);
  if (args == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  exit (1);

  <bb 4> :
  arg = *args;
  goto <bb 19>; [INV]

  <bb 5> :
  if (argcnt == 0)
    goto <bb 6>; [INV]
  else
    goto <bb 7>; [INV]

  <bb 6> :
  // predicted unlikely by continue predictor.
  goto <bb 18>; [INV]

  <bb 7> :
  if (argcnt == 1)
    goto <bb 8>; [INV]
  else
    goto <bb 10>; [INV]

  <bb 8> :
  _2 = (long unsigned int) section_index;
  _3 = _2 * 16;
  _4 = sect_opts + _3;
  _4->name = ".text";
  _5 = (long unsigned int) section_index;
  _6 = _5 * 16;
  _7 = sect_opts + _6;
  _7->value = arg;
  section_index = section_index + 1;
  _8 = (long unsigned int) section_index;
  if (num_sect_opts <= _8)
    goto <bb 9>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 9> :
  num_sect_opts = num_sect_opts * 2;
  _9 = num_sect_opts * 16;
  sect_opts = xrealloc (sect_opts, _9);
  goto <bb 18>; [INV]

  <bb 10> :
  if (expecting_sec_name != 0)
    goto <bb 11>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 11> :
  _10 = (long unsigned int) section_index;
  _11 = _10 * 16;
  _12 = sect_opts + _11;
  _12->value = arg;
  expecting_sec_addr = 0;
  goto <bb 18>; [INV]

  <bb 12> :
  if (expecting_sec_addr != 0)
    goto <bb 13>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 13> :
  _13 = (long unsigned int) section_index;
  _14 = _13 * 16;
  _15 = sect_opts + _14;
  _15->value = arg;
  expecting_sec_addr = 0;
  section_index = section_index + 1;
  _16 = (long unsigned int) section_index;
  if (num_sect_opts <= _16)
    goto <bb 14>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 14> :
  num_sect_opts = num_sect_opts * 2;
  _17 = num_sect_opts * 16;
  sect_opts = xrealloc (sect_opts, _17);
  goto <bb 18>; [INV]

  <bb 15> :
  _18 = strcmp (arg, "-s");
  if (_18 == 0)
    goto <bb 16>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 16> :
  expecting_sec_name = 1;
  expecting_sec_addr = 1;
  goto <bb 18>; [INV]

  <bb 17> :
  exit (1);

  <bb 18> :
  argcnt = argcnt + 1;
  _19 = (long unsigned int) argcnt;
  _20 = _19 * 8;
  _21 = args + _20;
  arg = *_21;

  <bb 19> :
  if (arg != 0B)
    goto <bb 5>; [INV]
  else
    goto <bb 20>; [INV]

  <bb 20> :
  if (section_index <= 0)
    goto <bb 21>; [INV]
  else
    goto <bb 22>; [INV]

  <bb 21> :
  exit (1);

  <bb 22> :
  section_addrs = malloc (24);
  make_cleanup (free, section_addrs);
  i = 0;
  goto <bb 24>; [INV]

  <bb 23> :
  _22 = (long unsigned int) i;
  _23 = _22 * 16;
  _24 = sect_opts + _23;
  val = _24->value;
  _25 = (long unsigned int) i;
  _26 = _25 * 16;
  _27 = sect_opts + _26;
  sec = _27->name;
  section_addrs->other[sec_num].name = sec;
  sec_num = sec_num + 1;
  i = i + 1;

  <bb 24> :
  if (i < section_index)
    goto <bb 23>; [INV]
  else
    goto <bb 25>; [INV]

  <bb 25> :
  _28 = (long unsigned int) sec_num;
  section_addrs->num_sections = _28;
  do_cleanups (my_cleanups);
  return;

}


