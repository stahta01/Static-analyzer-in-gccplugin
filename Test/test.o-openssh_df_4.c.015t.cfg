
;; Function percent_expand (percent_expand, funcdef_no=22, decl_uid=3474, cgraph_uid=23, symbol_order=22)

Removing basic block 15
Merging blocks 22 and 23
Merging blocks 22 and 24
;; 3 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21
;;
;; Loop 1
;;  header 20, latch 19
;;  depth 1, outer 0
;;  nodes: 20 19 8 17 13 16 11 15 12 9 5 6 10
;;
;; Loop 2
;;  header 16, latch 15
;;  depth 2, outer 1
;;  nodes: 16 15 12
;; 2 succs { 3 4 }
;; 3 succs { }
;; 4 succs { 20 }
;; 5 succs { 6 9 }
;; 6 succs { 7 8 }
;; 7 succs { }
;; 8 succs { 19 }
;; 9 succs { 10 11 }
;; 10 succs { 6 }
;; 11 succs { 16 }
;; 12 succs { 13 15 }
;; 13 succs { 14 17 }
;; 14 succs { }
;; 15 succs { 16 }
;; 16 succs { 12 17 }
;; 17 succs { 18 19 }
;; 18 succs { }
;; 19 succs { 20 }
;; 20 succs { 5 21 }
;; 21 succs { 1 }
char * percent_expand (const char * string)
{
  char buf[4096];
  u_int j;
  u_int i;
  u_int num_keys;
  struct 
  {
    const char * key;
    const char * repl;
  } keys[16];
  char * D.3608;

  <bb 2> :
  if (num_keys > 15)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  printf ("percent_expand: too many keys%s", "");
  exit (1);

  <bb 4> :
  buf[0] = 0;
  i = 0;
  goto <bb 20>; [INV]

  <bb 5> :
  _1 = *string;
  if (_1 != 37)
    goto <bb 6>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 6> :
append:
  i.0_2 = i;
  i = i.0_2 + 1;
  _3 = *string;
  buf[i.0_2] = _3;
  if (i > 4095)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  printf ("percent_expand: string too long%s", "");
  exit (1);

  <bb 8> :
  buf[i] = 0;
  // predicted unlikely by continue predictor.
  goto <bb 19>; [INV]

  <bb 9> :
  string = string + 1;
  _4 = *string;
  if (_4 == 37)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  // predicted unlikely by goto predictor.
  goto <bb 6>; [INV]

  <bb 11> :
  j = 0;
  goto <bb 16>; [INV]

  <bb 12> :
  _5 = *string;
  _6 = (int) _5;
  _7 = keys[j].key;
  _8 = strchr (_7, _6);
  if (_8 != 0B)
    goto <bb 13>; [INV]
  else
    goto <bb 15>; [INV]

  <bb 13> :
  _9 = keys[j].repl;
  _10 = strlcat (&buf, _9, 4096);
  i = (u_int) _10;
  if (i > 4095)
    goto <bb 14>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 14> :
  printf ("percent_expand: string too long%s", "");
  exit (1);

  <bb 15> :
  j = j + 1;

  <bb 16> :
  if (j < num_keys)
    goto <bb 12>; [INV]
  else
    goto <bb 17>; [INV]

  <bb 17> :
  if (j >= num_keys)
    goto <bb 18>; [INV]
  else
    goto <bb 19>; [INV]

  <bb 18> :
  _11 = *string;
  _12 = (int) _11;
  printf ("percent_expand: unknown key %c", _12);
  exit (1);

  <bb 19> :
  string = string + 1;

  <bb 20> :
  _13 = *string;
  if (_13 != 0)
    goto <bb 5>; [INV]
  else
    goto <bb 21>; [INV]

  <bb 21> :
  D.3608 = strdup (&buf);
  keys = {CLOBBER};
  buf = {CLOBBER};
  return D.3608;

}



;; Function read_keyfile_line (read_keyfile_line, funcdef_no=24, decl_uid=3510, cgraph_uid=25, symbol_order=24)

;; 3 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13
;;
;; Loop 1
;;  header 11, multiple latches: 4 9 10
;;  depth 1, outer 0
;;  nodes: 11 4 9 10 8 6 5 3
;;
;; Loop 2
;;  header 9, latch 10
;;  depth 2, outer 1
;;  nodes: 9 10
;; 2 succs { 11 }
;; 3 succs { 4 5 }
;; 4 succs { 11 }
;; 5 succs { 7 6 }
;; 6 succs { 7 8 }
;; 7 succs { 13 }
;; 8 succs { 9 }
;; 9 succs { 10 11 }
;; 10 succs { 9 11 }
;; 11 succs { 3 12 }
;; 12 succs { 13 }
;; 13 succs { 1 }
int read_keyfile_line (struct FILE * f, const char * filename, char * buf, size_t bufsz, u_long * lineno)
{
  static const char __func__[18] = "read_keyfile_line";
  int D.3616;

  <bb 2> :
  goto <bb 11>; [INV]

  <bb 3> :
  _1 = *buf;
  if (_1 == 0)
    goto <bb 4>; [INV]
  else
    goto <bb 5>; [INV]

  <bb 4> :
  // predicted unlikely by continue predictor.
  goto <bb 11>; [INV]

  <bb 5> :
  _2 = *lineno;
  _3 = _2 + 1;
  *lineno = _3;
  _4 = strlen (buf);
  _5 = _4 + 18446744073709551615;
  _6 = buf + _5;
  _7 = *_6;
  if (_7 == 10)
    goto <bb 7>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 6> :
  _8 = feof (f);
  if (_8 != 0)
    goto <bb 7>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 7> :
  D.3616 = 0;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 13>; [INV]

  <bb 8> :
  _9 = *lineno;
  debug ("%s: %s line %lu exceeds size limit", &__func__, filename, _9);

  <bb 9> :
  _10 = fgetc (f);
  if (_10 != 10)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  _11 = feof (f);
  if (_11 == 0)
    goto <bb 9>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 11> :
  _12 = (int) bufsz;
  _13 = fgets (buf, _12, f);
  if (_13 != 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 12>; [INV]

  <bb 12> :
  D.3616 = -1;

  <bb 13> :
  return D.3616;

}



;; Function authorized_keys_file (authorized_keys_file, funcdef_no=25, decl_uid=3523, cgraph_uid=26, symbol_order=25)

Merging blocks 2 and 3
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
char * authorized_keys_file (struct passwd * pw)
{
  char * D.3619;

  <bb 2> :
  D.3619 = expand_authorized_keys ("filename", pw);
  return D.3619;

}



;; Function expand_authorized_keys (expand_authorized_keys, funcdef_no=23, decl_uid=3499, cgraph_uid=24, symbol_order=23)

Merging blocks 7 and 8
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7
;; 2 succs { 3 4 }
;; 3 succs { 7 }
;; 4 succs { 5 6 }
;; 5 succs { }
;; 6 succs { 7 }
;; 7 succs { 1 }
char * expand_authorized_keys (const char * filename, struct passwd * pw)
{
  int i;
  char ret[64];
  char * file;
  char * D.3623;

  <bb 2> :
  _1 = pw->pw_name;
  _2 = pw->pw_dir;
  file = percent_expand (filename, "h", _2, "u", _1, 0B);
  _3 = *file;
  if (_3 == 47)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  D.3623 = file;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 7>; [INV]

  <bb 4> :
  _4 = pw->pw_dir;
  i = snprintf (&ret, 64, "%s/%s", _4, file);
  i.1_5 = (unsigned int) i;
  if (i.1_5 > 63)
    goto <bb 5>; [INV]
  else
    goto <bb 6>; [INV]

  <bb 5> :
  printf ("expand_authorized_keys: path too long%s", "");
  exit (1);

  <bb 6> :
  free (file);
  D.3623 = strdup (&ret);

  <bb 7> :
  ret = {CLOBBER};
  return D.3623;

}



;; Function user_key_allowed (user_key_allowed, funcdef_no=27, decl_uid=3583, cgraph_uid=28, symbol_order=27)

;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5
;; 2 succs { 3 4 }
;; 3 succs { 5 }
;; 4 succs { 5 }
;; 5 succs { 1 }
int user_key_allowed (struct passwd * pw, struct Key * key)
{
  char * file;
  int success;
  int D.3630;

  <bb 2> :
  file = authorized_keys_file (pw);
  success = user_key_allowed2 (pw, key, file);
  free (file);
  if (success != 0)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  D.3630 = success;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 5>; [INV]

  <bb 4> :
  _1 = authorized_keys_file2 (pw);
  _2 = (long int) _1;
  file = (char *) _2;
  success = user_key_allowed2 (pw, key, file);
  free (file);
  D.3630 = success;

  <bb 5> :
  return D.3630;

}



;; Function user_key_allowed2 (user_key_allowed2, funcdef_no=26, decl_uid=3528, cgraph_uid=27, symbol_order=26)

Removing basic block 22
Merging blocks 29 and 32
Merging blocks 37 and 38
;; 5 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35
;;
;; Loop 1
;;  header 31, multiple latches: 29 30
;;  depth 1, outer 0
;;  nodes: 31 29 30 10 25 24 23 21 22 19 12 18 15 16 17 13 14 20 11 9 8 7 5 6 26 27
;;
;; Loop 4
;;  header 23, latch 22
;;  depth 2, outer 1
;;  nodes: 23 22
;;
;; Loop 3
;;  header 19, latch 18
;;  depth 2, outer 1
;;  nodes: 19 18 15 16 17 13 14 20 21
;;
;; Loop 2
;;  header 7, latch 6
;;  depth 2, outer 1
;;  nodes: 7 6
;; 2 succs { 3 4 }
;; 3 succs { 35 }
;; 4 succs { 31 }
;; 5 succs { 7 }
;; 6 succs { 7 }
;; 7 succs { 6 8 }
;; 8 succs { 10 9 }
;; 9 succs { 10 11 }
;; 10 succs { 30 }
;; 11 succs { 12 26 }
;; 12 succs { 19 }
;; 13 succs { 14 16 }
;; 14 succs { 15 16 }
;; 15 succs { 18 }
;; 16 succs { 17 18 }
;; 17 succs { 18 }
;; 18 succs { 19 }
;; 19 succs { 20 23 }
;; 20 succs { 13 21 }
;; 21 succs { 13 23 }
;; 22 succs { 23 }
;; 23 succs { 22 24 }
;; 24 succs { 25 26 }
;; 25 succs { 30 }
;; 26 succs { 27 29 }
;; 27 succs { 28 29 }
;; 28 succs { 32 }
;; 29 succs { 31 }
;; 30 succs { 31 }
;; 31 succs { 5 32 }
;; 32 succs { 33 34 }
;; 33 succs { 34 }
;; 34 succs { 35 }
;; 35 succs { 1 }
int user_key_allowed2 (struct passwd * pw, struct Key * key, char * file)
{
  int quoted;
  char * key_options;
  char * cp;
  char * fp;
  struct Key * found;
  u_long linenum;
  struct FILE * f;
  int found_key;
  char line[16384];
  char D.3651;
  char D.3650;
  char D.3638;
  char D.3635;
  int D.3634;

  <bb 2> :
  found_key = 0;
  linenum = 0;
  temporarily_use_uid (pw);
  debug ("trying public key file %s", file);
  _1 = auth_openkeyfile (file, pw, 0);
  _2 = (long int) _1;
  f = (struct FILE *) _2;
  if (f == 0B)
    goto <bb 3>; [INV]
  else
    goto <bb 4>; [INV]

  <bb 3> :
  free (file);
  restore_uid ();
  D.3634 = 0;
  // predicted unlikely by early return (on trees) predictor.
  goto <bb 35>; [INV]

  <bb 4> :
  found_key = 0;
  _3 = key->type;
  _4 = key_new (_3);
  _5 = (long int) _4;
  found = (struct Key *) _5;
  goto <bb 31>; [INV]

  <bb 5> :
  key_options = 0B;
  cp = &line;
  goto <bb 7>; [INV]

  <bb 6> :
  cp.2_6 = cp;
  _7 = cp.2_6 + 1;
  cp = _7;

  <bb 7> :
  cp.3_8 = cp;
  D.3635 = *cp.3_8;
  _9 = D.3635 == 32;
  _10 = D.3635 == 9;
  _11 = _9 | _10;
  if (_11 != 0)
    goto <bb 6>; [INV]
  else
    goto <bb 8>; [INV]

  <bb 8> :
  cp.4_12 = cp;
  D.3638 = *cp.4_12;
  _13 = D.3638 == 0;
  _14 = D.3638 == 10;
  _15 = _13 | _14;
  if (_15 != 0)
    goto <bb 10>; [INV]
  else
    goto <bb 9>; [INV]

  <bb 9> :
  cp.5_16 = cp;
  _17 = *cp.5_16;
  if (_17 == 35)
    goto <bb 10>; [INV]
  else
    goto <bb 11>; [INV]

  <bb 10> :
  // predicted unlikely by continue predictor.
  goto <bb 30>; [INV]

  <bb 11> :
  _18 = key_read (found, &cp);
  if (_18 != 1)
    goto <bb 12>; [INV]
  else
    goto <bb 26>; [INV]

  <bb 12> :
  quoted = 0;
  cp.6_19 = cp;
  debug2 ("user_key_allowed: check options: \'%s\'", cp.6_19);
  key_options = cp;
  goto <bb 19>; [INV]

  <bb 13> :
  cp.7_20 = cp;
  _21 = *cp.7_20;
  if (_21 == 92)
    goto <bb 14>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 14> :
  cp.8_22 = cp;
  _23 = cp.8_22 + 1;
  _24 = *_23;
  if (_24 == 34)
    goto <bb 15>; [INV]
  else
    goto <bb 16>; [INV]

  <bb 15> :
  cp.9_25 = cp;
  _26 = cp.9_25 + 1;
  cp = _26;
  goto <bb 18>; [INV]

  <bb 16> :
  cp.10_27 = cp;
  _28 = *cp.10_27;
  if (_28 == 34)
    goto <bb 17>; [INV]
  else
    goto <bb 18>; [INV]

  <bb 17> :
  _29 = quoted == 0;
  quoted = (int) _29;

  <bb 18> :
  cp.11_30 = cp;
  _31 = cp.11_30 + 1;
  cp = _31;

  <bb 19> :
  cp.12_32 = cp;
  _33 = *cp.12_32;
  if (_33 != 0)
    goto <bb 20>; [INV]
  else
    goto <bb 23>; [INV]

  <bb 20> :
  if (quoted != 0)
    goto <bb 13>; [INV]
  else
    goto <bb 21>; [INV]

  <bb 21> :
  cp.13_34 = cp;
  D.3650 = *cp.13_34;
  _35 = D.3650 != 32;
  _36 = D.3650 != 9;
  _37 = _35 & _36;
  if (_37 != 0)
    goto <bb 13>; [INV]
  else
    goto <bb 23>; [INV]

  <bb 22> :
  cp.14_38 = cp;
  _39 = cp.14_38 + 1;
  cp = _39;

  <bb 23> :
  cp.15_40 = cp;
  D.3651 = *cp.15_40;
  _41 = D.3651 == 32;
  _42 = D.3651 == 9;
  _43 = _41 | _42;
  if (_43 != 0)
    goto <bb 22>; [INV]
  else
    goto <bb 24>; [INV]

  <bb 24> :
  _44 = key_read (found, &cp);
  if (_44 != 1)
    goto <bb 25>; [INV]
  else
    goto <bb 26>; [INV]

  <bb 25> :
  cp.16_45 = cp;
  debug2 ("user_key_allowed: advance: \'%s\'", cp.16_45);
  // predicted unlikely by continue predictor.
  goto <bb 30>; [INV]

  <bb 26> :
  _46 = key_equal (found, key);
  if (_46 != 0)
    goto <bb 27>; [INV]
  else
    goto <bb 29>; [INV]

  <bb 27> :
  linenum.17_47 = linenum;
  _48 = auth_parse_options (pw, key_options, file, linenum.17_47);
  if (_48 == 1)
    goto <bb 28>; [INV]
  else
    goto <bb 29>; [INV]

  <bb 28> :
  found_key = 1;
  linenum.18_49 = linenum;
  debug ("matching key found: file %s, line %lu", file, linenum.18_49);
  _50 = key_fingerprint (found, 1, 1);
  _51 = (long int) _50;
  fp = (char *) _51;
  _52 = key_type (found);
  verbose ("Found matching %s key: %s", _52, fp);
  free (fp);
  cp = {CLOBBER};
  goto <bb 32>; [INV]

  <bb 29> :
  cp = {CLOBBER};
  goto <bb 31>; [INV]

  <bb 30> :
  cp = {CLOBBER};

  <bb 31> :
  _53 = read_keyfile_line (f, file, &line, 16384, &linenum);
  if (_53 != -1)
    goto <bb 5>; [INV]
  else
    goto <bb 32>; [INV]

  <bb 32> :
  restore_uid ();
  fclose (f);
  key_free (found);
  if (found_key == 0)
    goto <bb 33>; [INV]
  else
    goto <bb 34>; [INV]

  <bb 33> :
  debug2 ("key not found");

  <bb 34> :
  D.3634 = found_key;

  <bb 35> :
  line = {CLOBBER};
  linenum = {CLOBBER};
  return D.3634;

}



;; Function main (main, funcdef_no=28, decl_uid=3589, cgraph_uid=29, symbol_order=28)

Removing basic block 4
Merging blocks 2 and 3
Merging blocks 2 and 5
;; 1 loops found
;;
;; Loop 0
;;  header 0, latch 1
;;  depth 0, outer -1
;;  nodes: 0 1 2
;; 2 succs { 1 }
int main ()
{
  struct Key key;
  struct passwd pw;
  int D.3665;

  <bb 2> :
  user_key_allowed (&pw, &key);
  D.3665 = 0;
  pw = {CLOBBER};
  key = {CLOBBER};
  return D.3665;

}


