/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

#line 216 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 144 "/usr/include/libio.h"
struct _IO_FILE;
#line 150 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 156 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 241 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 29 "../include/common.h"
typedef int bool;
#line 34 "../include/common.h"
typedef void make_cleanup_ftype(void * );
#line 36 "../include/common.h"
struct cleanup {
   struct cleanup *next ;
   void (*function)(void * ) ;
   void (*free_arg)(void * ) ;
   void *arg ;
};
#line 8 "binutils_leak_10.c"
typedef void (*stinst_type)();
#line 10 "binutils_leak_10.c"
struct dict_struct {
   char *word ;
   struct dict_struct *next ;
   stinst_type *code ;
   int code_length ;
   int code_end ;
   int var ;
};
#line 20 "binutils_leak_10.c"
typedef struct dict_struct dict_type;
#line 22 "binutils_leak_10.c"
struct buffer {
   char *ptr ;
   unsigned long write_idx ;
   unsigned long size ;
};
#line 22 "binutils_leak_10.c"
typedef struct buffer string_type;
#line 29 "binutils_leak_10.c"
typedef int *word_type;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 31 "../include/common.h"
bool true  =    1;
#line 32 "../include/common.h"
bool false  =    0;
#line 44 "../include/common.h"
static struct cleanup  const  sentinel_cleanup  =    {(struct cleanup *)0, (void (*)(void * ))0, (void (*)(void * ))0, (void *)0};
#line 49 "../include/common.h"
static struct cleanup *cleanup_chain  =    (struct cleanup *)(& sentinel_cleanup);
#line 50 "../include/common.h"
static struct cleanup *final_cleanup_chain  ;
#line 52
void discard_cleanups(struct cleanup *old_chain ) ;
#line 53
void discard_my_cleanups(struct cleanup **pmy_chain , struct cleanup *old_chain ) ;
#line 55
void discard_final_cleanups(struct cleanup *old_chain ) ;
#line 56
static void do_my_cleanups(struct cleanup **pmy_chain , struct cleanup *old_chain ) ;
#line 58
void do_cleanups(struct cleanup *old_chain ) ;
#line 59
static struct cleanup *make_my_cleanup2(struct cleanup **pmy_chain , make_cleanup_ftype *function ,
                                        void *arg , void (*free_arg)(void * ) ) ;
#line 62
static struct cleanup *make_my_cleanup(struct cleanup **pmy_chain , make_cleanup_ftype *function ,
                                       void *arg ) ;
#line 65
struct cleanup *make_cleanup(make_cleanup_ftype *function , void *arg ) ;
#line 68 "../include/common.h"
void discard_cleanups(struct cleanup *old_chain ) 
{ 


  {
#line 71
  discard_my_cleanups(& cleanup_chain, old_chain);
#line 72
  return;
}
}
#line 74 "../include/common.h"
void discard_final_cleanups(struct cleanup *old_chain ) 
{ 


  {
#line 77
  discard_my_cleanups(& final_cleanup_chain, old_chain);
#line 78
  return;
}
}
#line 80 "../include/common.h"
void discard_my_cleanups(struct cleanup **pmy_chain , struct cleanup *old_chain ) 
{ 
  struct cleanup *ptr ;

  {
#line 86
  while (1) {
#line 86
    ptr = *pmy_chain;
#line 86
    if (! ((unsigned long )ptr != (unsigned long )old_chain)) {
#line 86
      break;
    }
#line 88
    *pmy_chain = ptr->next;
#line 89
    if (ptr->free_arg) {
#line 90
      (*(ptr->free_arg))(ptr->arg);
    }
#line 91
    free((void *)ptr);
  }
#line 94
  printf((char const   * __restrict  )"freearg: %x\n", ptr->arg);
#line 95
  return;
}
}
#line 97 "../include/common.h"
static void do_my_cleanups(struct cleanup **pmy_chain , struct cleanup *old_chain ) 
{ 
  struct cleanup *ptr ;

  {
#line 103
  while (1) {
#line 103
    ptr = *pmy_chain;
#line 103
    if (! ((unsigned long )ptr != (unsigned long )old_chain)) {
#line 103
      break;
    }
#line 105
    *pmy_chain = ptr->next;
#line 106
    (*(ptr->function))(ptr->arg);
#line 107
    printf((char const   * __restrict  )"cleanup!!!!! =========\n");
#line 108
    printf((char const   * __restrict  )"%x\n", ptr->arg);
#line 109
    if (ptr->free_arg) {
#line 110
      (*(ptr->free_arg))(ptr->arg);
    }
#line 112
    free((void *)ptr);
  }
#line 114
  return;
}
}
#line 116 "../include/common.h"
void do_cleanups(struct cleanup *old_chain ) 
{ 


  {
#line 118
  do_my_cleanups(& cleanup_chain, old_chain);
#line 119
  return;
}
}
#line 121 "../include/common.h"
static struct cleanup *make_my_cleanup2(struct cleanup **pmy_chain , make_cleanup_ftype *function ,
                                        void *arg , void (*free_arg)(void * ) ) 
{ 
  struct cleanup *new ;
  void *tmp ;
  struct cleanup *old_chain ;

  {
#line 125
  tmp = malloc(sizeof(struct cleanup ));
#line 125
  new = (struct cleanup *)tmp;
#line 127
  old_chain = *pmy_chain;
#line 129
  new->next = *pmy_chain;
#line 130
  new->function = function;
#line 131
  new->free_arg = free_arg;
#line 132
  new->arg = arg;
#line 133
  *pmy_chain = new;
#line 135
  if ((unsigned long )old_chain == (unsigned long )((void *)0)) {
#line 136
    exit(1);
  }
#line 138
  return (old_chain);
}
}
#line 141 "../include/common.h"
static struct cleanup *make_my_cleanup(struct cleanup **pmy_chain , make_cleanup_ftype *function ,
                                       void *arg ) 
{ 
  struct cleanup *tmp ;

  {
#line 145
  tmp = make_my_cleanup2(pmy_chain, function, arg, (void (*)(void * ))((void *)0));
#line 145
  return (tmp);
}
}
#line 148 "../include/common.h"
struct cleanup *make_cleanup(make_cleanup_ftype *function , void *arg ) 
{ 
  struct cleanup *tmp ;

  {
#line 151
  tmp = make_my_cleanup(& cleanup_chain, function, arg);
#line 151
  return (tmp);
}
}
#line 31 "binutils_leak_10.c"
string_type *ptr  ;
#line 33 "binutils_leak_10.c"
dict_type *root  ;
#line 35 "binutils_leak_10.c"
dict_type *newentry(char *word ) 
{ 
  dict_type *new_d ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 37
  tmp = malloc(sizeof(dict_type ));
#line 37
  new_d = (dict_type *)tmp;
#line 38
  new_d->word = word;
#line 39
  new_d->next = root;
#line 40
  root = new_d;
#line 41
  tmp___0 = malloc(sizeof(void (*)()));
#line 41
  new_d->code = (stinst_type *)tmp___0;
#line 42
  new_d->code_length = 1;
#line 43
  new_d->code_end = 0;
#line 44
  return (new_d);
}
}
#line 47 "binutils_leak_10.c"
void add_var(char *name ) 
{ 
  dict_type *new_d ;
  dict_type *tmp ;

  {
#line 51
  tmp = newentry(name);
#line 51
  new_d = tmp;
#line 52
  return;
}
}
#line 54 "binutils_leak_10.c"
unsigned int add_to_definition(dict_type *entry , void (*word)() ) 
{ 
  void *tmp ;
  int tmp___0 ;

  {
#line 59
  if (entry->code_end == entry->code_length) {
#line 61
    entry->code_length += 2;
#line 62
    tmp = realloc((void *)((char *)entry->code), (unsigned long )entry->code_length * sizeof(word_type ));
#line 62
    entry->code = (stinst_type *)tmp;
  }
#line 66
  *(entry->code + entry->code_end) = word;
#line 68
  tmp___0 = entry->code_end;
#line 68
  (entry->code_end) ++;
#line 68
  return ((unsigned int )tmp___0);
}
}
#line 87
extern int ( /* missing proto */  isspace)() ;
#line 71 "binutils_leak_10.c"
char *nextword(char *string , char **word ) 
{ 
  char *word_start ;
  int idx ;
  char *dst ;
  char *src ;
  int length ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;

  {
#line 82
  length = 0;
#line 84
  if (! string) {
#line 85
    return ((char *)((void *)0));
  }
#line 87
  while (1) {
#line 87
    tmp = isspace((int )((unsigned char )*string));
#line 87
    if (! tmp) {
#line 87
      if (! ((int )*string == 45)) {
#line 87
        break;
      }
    }
#line 89
    if ((int )*string == 45) {
#line 91
      while (1) {
#line 91
        if (*string) {
#line 91
          if (! ((int )*string != 10)) {
#line 91
            break;
          }
        } else {
#line 91
          break;
        }
#line 92
        string ++;
      }
    } else {
#line 97
      string ++;
    }
  }
#line 101
  if (! *string) {
#line 102
    return ((char *)0);
  }
#line 105
  word_start = string;
#line 106
  if ((int )*string == 34) {
#line 108
    while (1) {
#line 110
      string ++;
#line 111
      length ++;
#line 112
      if ((int )*string == 92) {
#line 114
        string += 2;
#line 115
        length += 2;
      }
#line 108
      if (! ((int )*string != 34)) {
#line 108
        break;
      }
    }
  } else {
#line 123
    while (1) {
#line 123
      tmp___0 = isspace((int )((unsigned char )*string));
#line 123
      if (tmp___0) {
#line 123
        break;
      }
#line 125
      string ++;
#line 126
      length ++;
    }
  }
#line 131
  tmp___1 = malloc((size_t )(length + 1));
#line 131
  *word = (char *)tmp___1;
#line 133
  dst = *word;
#line 134
  src = word_start;
#line 136
  idx = 0;
#line 136
  while (idx < length) {
#line 138
    if ((int )*(src + idx) == 92) {
#line 139
      switch ((int )*(src + (idx + 1))) {
      case 110: 
#line 142
      tmp___2 = dst;
#line 142
      dst ++;
#line 142
      *tmp___2 = (char )'\n';
#line 143
      idx ++;
#line 144
      break;
      case 92: 
      case 34: 
#line 147
      tmp___3 = dst;
#line 147
      dst ++;
#line 147
      *tmp___3 = *(src + (idx + 1));
#line 148
      idx ++;
#line 149
      break;
      default: 
#line 151
      tmp___4 = dst;
#line 151
      dst ++;
#line 151
      *tmp___4 = (char )'\\';
#line 152
      break;
      }
    } else {
#line 155
      tmp___5 = dst;
#line 155
      dst ++;
#line 155
      *tmp___5 = *(src + idx);
    }
#line 136
    idx ++;
  }
#line 157
  tmp___6 = dst;
#line 157
  dst ++;
#line 157
  *tmp___6 = (char)0;
#line 159
  if (*string) {
#line 160
    return (string + 1);
  } else {
#line 162
    return ((char *)0);
  }
}
}
#line 174
extern int ( /* missing proto */  strcmp)() ;
#line 165 "binutils_leak_10.c"
void compile(char *string ) 
{ 
  char *word ;
  dict_type *ptr___0 ;
  int tmp ;

  {
#line 169
  string = nextword(string, & word);
#line 170
  while (1) {
#line 170
    if (string) {
#line 170
      if (*string) {
#line 170
        if (! *(word + 0)) {
#line 170
          break;
        }
      } else {
#line 170
        break;
      }
    } else {
#line 170
      break;
    }
#line 173
    printf((char const   * __restrict  )"string: %s\n", string);
#line 174
    tmp = strcmp(word, "var");
#line 174
    if (tmp == 0) {
#line 176
      string = nextword(string, & word);
#line 179
      add_var(word);
#line 180
      string = nextword(string, & word);
    } else
#line 182
    if ((int )*(word + 0) == 58) {
#line 186
      free((void *)word);
#line 187
      string = nextword(string, & word);
#line 190
      ptr___0 = newentry(word);
#line 191
      string = nextword(string, & word);
#line 193
      while ((int )*(word + 0) != 59) {
#line 195
        switch ((int )*(word + 0)) {
        case 34: 
#line 200
        add_to_definition(ptr___0, (void (*)())(word + 1));
#line 201
        break;
        case 57: 
        case 56: 
        case 55: 
        case 54: 
        case 53: 
        case 52: 
        case 51: 
        case 50: 
        case 49: 
        case 48: 
#line 214
        printf((char const   * __restrict  )"%d\n", *((int *)ptr___0));
#line 216
        free((void *)word);
#line 217
        break;
        default: 
#line 219
        printf((char const   * __restrict  )"%d\n", *((int *)ptr___0));
#line 220
        free((void *)word);
        }
#line 224
        string = nextword(string, & word);
#line 225
        if (! string) {
#line 226
          break;
        }
      }
#line 228
      printf((char const   * __restrict  )"%d\n", *((int *)ptr___0));
#line 229
      string = nextword(string, & word);
    } else {
#line 233
      fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"syntax error at %s\n",
              string - 1);
    }
  }
#line 238
  return;
}
}
#line 240 "binutils_leak_10.c"
int main(void) 
{ 
  dict_type *dict ;
  char *string ;

  {
#line 243
  string = (char *)"var second : stored_in_dict 5 ; : next";
#line 245
  compile(string);
#line 246
  dict = root;
#line 248
  while ((unsigned long )dict != (unsigned long )((void *)0)) {
#line 249
    printf((char const   * __restrict  )"%s\n", dict->word);
#line 250
    free((void *)dict->word);
#line 251
    dict = dict->next;
  }
#line 254
  return (0);
}
}
