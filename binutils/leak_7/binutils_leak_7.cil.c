/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

#line 216 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 144 "/usr/include/libio.h"
struct _IO_FILE;
#line 150 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 156 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 241 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 328 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h"
typedef int wchar_t;
#line 28 "../include/common.h"
typedef int bool;
#line 33 "../include/common.h"
typedef void make_cleanup_ftype(void * );
#line 35 "../include/common.h"
struct cleanup {
   struct cleanup *next ;
   void (*function)(void * ) ;
   void (*free_arg)(void * ) ;
   void *arg ;
};
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 873
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) mbstowcs)(wchar_t * __restrict  __pwcs ,
                                                                                  char const   * __restrict  __s ,
                                                                                  size_t __n ) ;
#line 30 "../include/common.h"
bool true  =    1;
#line 31 "../include/common.h"
bool false  =    0;
static struct cleanup  const  sentinel_cleanup  =    {(struct cleanup *)0, (void (*)(void * ))0, (void (*)(void * ))0, (void *)0};
#line 48 "../include/common.h"
static struct cleanup *cleanup_chain  =    (struct cleanup *)(& sentinel_cleanup);
#line 49 "../include/common.h"
static struct cleanup *final_cleanup_chain  ;
#line 51
void discard_cleanups(struct cleanup *old_chain ) ;
#line 52
void discard_my_cleanups(struct cleanup **pmy_chain , struct cleanup *old_chain ) ;
#line 54
void discard_final_cleanups(struct cleanup *old_chain ) ;
#line 55
static void do_my_cleanups(struct cleanup **pmy_chain , struct cleanup *old_chain ) ;
#line 57
void do_cleanups(struct cleanup *old_chain ) ;
#line 58
static struct cleanup *make_my_cleanup2(struct cleanup **pmy_chain , make_cleanup_ftype *function ,
                                        void *arg , void (*free_arg)(void * ) ) ;
#line 61
static struct cleanup *make_my_cleanup(struct cleanup **pmy_chain , make_cleanup_ftype *function ,
                                       void *arg ) ;
#line 64
struct cleanup *make_cleanup(make_cleanup_ftype *function , void *arg ) ;
#line 67 "../include/common.h"
void discard_cleanups(struct cleanup *old_chain ) 
{ 


  {
#line 70
  discard_my_cleanups(& cleanup_chain, old_chain);
#line 71
  return;
}
}
#line 73 "../include/common.h"
void discard_final_cleanups(struct cleanup *old_chain ) 
{ 


  {
#line 76
  discard_my_cleanups(& final_cleanup_chain, old_chain);
#line 77
  return;
}
}
#line 79 "../include/common.h"
void discard_my_cleanups(struct cleanup **pmy_chain , struct cleanup *old_chain ) 
{ 
  struct cleanup *ptr ;

  {
#line 85
  while (1) {
#line 85
    ptr = *pmy_chain;
#line 85
    if (! ((unsigned long )ptr != (unsigned long )old_chain)) {
#line 85
      break;
    }
#line 87
    *pmy_chain = ptr->next;
#line 88
    if (ptr->free_arg) {
#line 89
      (*(ptr->free_arg))(ptr->arg);
    }
#line 90
    free((void *)ptr);
  }
#line 93
  printf((char const   * __restrict  )"freearg: %x\n", ptr->arg);
#line 94
  return;
}
}
#line 96 "../include/common.h"
static void do_my_cleanups(struct cleanup **pmy_chain , struct cleanup *old_chain ) 
{ 
  struct cleanup *ptr ;

  {
#line 102
  while (1) {
#line 102
    ptr = *pmy_chain;
#line 102
    if (! ((unsigned long )ptr != (unsigned long )old_chain)) {
#line 102
      break;
    }
#line 104
    *pmy_chain = ptr->next;
#line 105
    (*(ptr->function))(ptr->arg);
#line 106
    printf((char const   * __restrict  )"cleanup!!!!! =========\n");
#line 107
    printf((char const   * __restrict  )"%x\n", ptr->arg);
#line 108
    if (ptr->free_arg) {
#line 109
      (*(ptr->free_arg))(ptr->arg);
    }
#line 111
    free((void *)ptr);
  }
#line 113
  return;
}
}
#line 115 "../include/common.h"
void do_cleanups(struct cleanup *old_chain ) 
{ 


  {
#line 117
  do_my_cleanups(& cleanup_chain, old_chain);
#line 118
  return;
}
}
#line 120 "../include/common.h"
static struct cleanup *make_my_cleanup2(struct cleanup **pmy_chain , make_cleanup_ftype *function ,
                                        void *arg , void (*free_arg)(void * ) ) 
{ 
  struct cleanup *new ;
  void *tmp ;
  struct cleanup *old_chain ;

  {
#line 124
  tmp = malloc(sizeof(struct cleanup ));
#line 124
  new = (struct cleanup *)tmp;
#line 126
  old_chain = *pmy_chain;
#line 128
  new->next = *pmy_chain;
#line 129
  new->function = function;
#line 130
  new->free_arg = free_arg;
#line 131
  new->arg = arg;
#line 132
  *pmy_chain = new;
#line 134
  if ((unsigned long )old_chain == (unsigned long )((struct cleanup *)0)) {
#line 135
    exit(1);
  }
#line 137
  return (old_chain);
}
}
#line 140 "../include/common.h"
static struct cleanup *make_my_cleanup(struct cleanup **pmy_chain , make_cleanup_ftype *function ,
                                       void *arg ) 
{ 
  struct cleanup *tmp ;

  {
#line 144
  tmp = make_my_cleanup2(pmy_chain, function, arg, (void (*)(void * ))0);
#line 144
  return (tmp);
}
}
#line 147 "../include/common.h"
struct cleanup *make_cleanup(make_cleanup_ftype *function , void *arg ) 
{ 
  struct cleanup *tmp ;

  {
#line 150
  tmp = make_my_cleanup(& cleanup_chain, function, arg);
#line 150
  return (tmp);
}
}
#line 12 "binutils_leak_7_python.c"
char *python_libdir  =    (char *)0;
#line 14 "binutils_leak_7_python.c"
char const   *unix_lbasename(char const   *name ) 
{ 
  char const   *base ;

  {
#line 19
  base = name;
#line 19
  while (*name) {
#line 20
    base = name + 1;
#line 19
    name ++;
  }
#line 22
  return (base);
}
}
#line 25 "binutils_leak_7_python.c"
char const   *lbasename(char const   *name ) 
{ 
  char const   *tmp ;

  {
#line 28
  tmp = unix_lbasename(name);
#line 28
  return (tmp);
}
}
#line 44
extern int ( /* missing proto */  memcpy)() ;
#line 31 "binutils_leak_7_python.c"
char *ldirname(char const   *filename ) 
{ 
  char const   *base ;
  char const   *tmp ;
  char *dirname ;
  void *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 34
  tmp = lbasename(filename);
#line 34
  base = tmp;
#line 37
  while (1) {
#line 37
    if ((unsigned long )base > (unsigned long )filename) {
#line 37
      if (! ((int const   )*(base + -1) == 47)) {
#line 37
        if ((int const   )*(base + -1) == 92) {
#line 37
          break;
        } else {
#line 37
          break;
        }
      }
    } else {
#line 37
      break;
    }
#line 38
    base --;
  }
#line 40
  if ((unsigned long )base == (unsigned long )filename) {
#line 41
    return ((char *)0);
  }
#line 43
  tmp___0 = malloc((size_t )((base - filename) + 2L));
#line 43
  dirname = (char *)tmp___0;
#line 44
  memcpy(dirname, filename, base - filename);
#line 48
  if (base - filename == 2L) {
#line 48
    if ((int const   )*(base + 0) == 47) {
#line 48
      goto _L;
    } else
#line 48
    if ((int const   )*(base + 0) == 92) {
#line 48
      goto _L___0;
    } else
    _L___0: /* CIL Label */ 
#line 48
    if (*(base + 0)) {
#line 48
      if ((int const   )*(base + 1) == 58) {
#line 48
        if (0) {
          _L: /* CIL Label */ 
#line 48
          if (! ((int const   )*(filename + 0) == 47)) {
#line 48
            if ((int const   )*(filename + 0) == 92) {
#line 50
              tmp___1 = base;
#line 50
              base ++;
#line 50
              *(dirname + (tmp___1 - filename)) = (char )'.';
            } else {
#line 50
              tmp___1 = base;
#line 50
              base ++;
#line 50
              *(dirname + (tmp___1 - filename)) = (char )'.';
            }
          }
        }
      }
    }
  }
#line 52
  *(dirname + (base - filename)) = (char )'\000';
#line 53
  return (dirname);
}
}
#line 61
extern int ( /* missing proto */  strlen)() ;
#line 56 "binutils_leak_7_python.c"
__inline static char *vconcat_copy(char *dst , char const   *first , char const   *arg ) 
{ 
  char *end ;
  unsigned long length ;
  int tmp ;

  {
#line 59
  end = dst;
#line 61
  tmp = strlen(arg);
#line 61
  length = (unsigned long )tmp;
#line 62
  memcpy(end, arg, length);
#line 63
  end += length;
#line 65
  *end = (char )'\000';
#line 67
  return (dst);
}
}
#line 70 "binutils_leak_7_python.c"
char *concat(char const   *first , char const   *arg ) 
{ 
  char *newstr ;
  void *tmp ;

  {
#line 76
  tmp = malloc(sizeof(char ));
#line 76
  newstr = (char *)tmp;
#line 79
  vconcat_copy(newstr, first, arg);
#line 81
  return (newstr);
}
}
#line 84 "binutils_leak_7_python.c"
void *PyMem_Malloc(size_t size ) 
{ 
  void *ret ;
  void *tmp ;

  {
#line 86
  tmp = malloc(size);
#line 86
  ret = tmp;
#line 87
  return (ret);
}
}
#line 89 "binutils_leak_7_python.c"
void Py_SetProgramName(wchar_t const   *progname ) 
{ 


  {
#line 91
  printf((char const   * __restrict  )"%d\n", *progname);
#line 92
  return;
}
}
#line 110
extern int ( /* missing proto */  strdup)() ;
#line 110
extern int ( /* missing proto */  setlocale)() ;
#line 94 "binutils_leak_7_python.c"
static bool do_start_initialization(void) 
{ 
  char *progname ;
  size_t progsize ;
  size_t count ;
  char *oldloc ;
  wchar_t *progname_copy ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;

  {
#line 109
  tmp = ldirname((char const   *)python_libdir);
#line 109
  progname = concat((char const   *)tmp, "bin");
	*tmp = '\0';
#line 110
  tmp___0 = setlocale("LC_ALL", 0);
#line 110
  tmp___1 = strdup(tmp___0);
#line 110
  oldloc = (char *)tmp___1;
#line 111
  setlocale("LC_ALL", "");
#line 112
  tmp___2 = strlen(progname);
#line 112
  progsize = (size_t )tmp___2;
#line 113
  tmp___3 = PyMem_Malloc((progsize + 1UL) * sizeof(wchar_t ));
#line 113
  progname_copy = (wchar_t *)tmp___3;
#line 114
  if (! progname_copy) {
#line 116
    free((void *)oldloc);
#line 117
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"out of memory\n");
#line 118
    return (false);
  }
#line 120
  count = mbstowcs((wchar_t * __restrict  )progname_copy, (char const   * __restrict  )progname,
                   progsize + 1UL);
#line 121
  if (count == 0xffffffffffffffffUL) {
#line 123
    free((void *)oldloc);
#line 124
    free((void *)progname_copy);
#line 125
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"Could not convert python path to string\n");
#line 126
    return (false);
  }
#line 128
  setlocale("LC_ALL", oldloc);
#line 129
  free((void *)oldloc);
#line 134
  Py_SetProgramName((wchar_t const   *)progname_copy);
#line 135
  free((void *)progname_copy);
#line 136
  return (true);
}
}
#line 139 "binutils_leak_7_python.c"
int main(void) 
{ 


  {
#line 141
  do_start_initialization();
	char *dummy = "dummy";
	concat(dummy, "");
	printf("%d\n", *(int *)dummy);

#line 142
  return (0);
}
}
