/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

#line 216 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h"
typedef unsigned long size_t;
#line 184 "../git.h"
struct split_index {

};
#line 185 "../git.h"
struct cache_time {

};
#line 186 "../git.h"
struct hashmap {

};
#line 187 "../git.h"
struct hashmap_entry {

};
#line 188 "../git.h"
struct untracked_cache {

};
#line 189 "../git.h"
struct stat_data {

};
#line 222 "../git.h"
struct string_list_item {
   char *string ;
   void *util ;
};
#line 227 "../git.h"
struct string_list {
   struct string_list_item *items ;
   unsigned int nr ;
   unsigned int alloc ;
   unsigned int strdup_strings : 1 ;
   int (*cmp)(char const   * , char const   * ) ;
};
#line 241 "../git.h"
struct strbuf {
   size_t alloc ;
   size_t len ;
   char *buf ;
};
#line 247
struct cache_tree;
#line 247 "../git.h"
struct cache_tree_sub {
   struct cache_tree *cache_tree ;
   int count ;
   int namelen ;
   int used ;
   char name[] ;
};
#line 255 "../git.h"
struct object_id {
   unsigned char hash[20] ;
};
#line 259 "../git.h"
struct cache_tree {
   int entry_count ;
   struct object_id oid ;
   int subtree_nr ;
   int subtree_alloc ;
   struct cache_tree_sub **down ;
};
#line 267 "../git.h"
struct object {
   unsigned int parsed : 1 ;
   unsigned int type : 3 ;
   unsigned int flags : 27 ;
   struct object_id oid ;
};
#line 274 "../git.h"
struct tree {
   struct object object ;
   void *buffer ;
   unsigned long size ;
};
#line 280 "../git.h"
struct cache_entry {
   struct hashmap_entry ent ;
   struct stat_data ce_stat_data ;
   unsigned int ce_mode ;
   unsigned int ce_flags ;
   unsigned int ce_namelen ;
   unsigned int index ;
   struct object_id oid ;
   char name[] ;
};
#line 291 "../git.h"
struct index_state {
   struct cache_entry **cache ;
   unsigned int version ;
   unsigned int cache_nr ;
   unsigned int cache_alloc ;
   unsigned int cache_changed ;
   struct string_list *resolve_undo ;
   struct cache_tree *cache_tree ;
   struct split_index *split_index ;
   struct cache_time timestamp ;
   unsigned int name_hash_initialized : 1 ;
   unsigned int initialized : 1 ;
   struct hashmap name_hash ;
   struct hashmap dir_hash ;
   unsigned char sha1[20] ;
   struct untracked_cache *untracked ;
};
#line 51 "git_leak_8.c"
struct userdiff_driver;
#line 51
struct userdiff_driver;
#line 53 "git_leak_8.c"
struct diff_filespec {
   struct object_id oid ;
   char *path ;
   void *data ;
   void *cnt_data ;
   unsigned long size ;
   int count ;
   int rename_used ;
   unsigned short mode ;
   unsigned int oid_valid : 1 ;
   unsigned int should_free : 1 ;
   unsigned int should_munmap : 1 ;
   unsigned int dirty_submodule : 2 ;
   unsigned int is_stdin : 1 ;
   unsigned int has_more_entries : 1 ;
   int is_binary : 2 ;
   struct userdiff_driver *driver ;
};
#line 79 "git_leak_8.c"
struct __anonstruct_stages_26 {
   unsigned int mode ;
   struct object_id oid ;
};
#line 79
struct rename_conflict_info;
#line 79 "git_leak_8.c"
struct stage_data {
   struct __anonstruct_stages_26 stages[4] ;
   struct rename_conflict_info *rename_conflict_info ;
   unsigned int processed : 1 ;
};
#line 91
struct diff_queue_struct;
#line 93
enum __anonenum_recursive_variant_27 {
    MERGE_RECURSIVE_NORMAL = 0,
    MERGE_RECURSIVE_OURS = 1,
    MERGE_RECURSIVE_THEIRS = 2
} ;
#line 93 "git_leak_8.c"
struct merge_options {
   char const   *ancestor ;
   char const   *branch1 ;
   char const   *branch2 ;
   enum __anonenum_recursive_variant_27 recursive_variant ;
   char const   *subtree_shift ;
   unsigned int buffer_output ;
   unsigned int renormalize : 1 ;
   long xdl_opts ;
   int verbosity ;
   int detect_rename ;
   int diff_rename_limit ;
   int merge_rename_limit ;
   int rename_score ;
   int needed_rename_limit ;
   int show_rename_progress ;
   int call_depth ;
   struct strbuf obuf ;
   struct string_list current_file_set ;
   struct string_list current_directory_set ;
   struct string_list df_conflict_file_set ;
};
#line 120 "git_leak_8.c"
struct diff_filepair {
   struct diff_filespec *one ;
   struct diff_filespec *two ;
   unsigned short score ;
   char status ;
   unsigned int broken_pair : 1 ;
   unsigned int renamed_pair : 1 ;
   unsigned int is_unmerged : 1 ;
   unsigned int done_skip_stat_unmatch : 1 ;
   unsigned int skip_stat_unmatch_result : 1 ;
};
#line 132 "git_leak_8.c"
struct diff_queue_struct {
   struct diff_filepair **queue ;
   int alloc ;
   int nr ;
};
#line 138 "git_leak_8.c"
struct rename {
   struct diff_filepair *pair ;
   struct stage_data *src_entry ;
   struct stage_data *dst_entry ;
   unsigned int processed : 1 ;
};
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 161 "../git.h"
extern int ( /* missing proto */  st_mult)() ;
#line 169
extern int ( /* missing proto */  memmove)() ;
#line 166 "../git.h"
__inline static void move_array(void *dst , void const   *src , size_t n , size_t size ) 
{ 
  int tmp ;

  {
#line 168
  if (n) {
#line 169
    tmp = st_mult(size, n);
#line 169
    memmove(dst, src, tmp);
  }
#line 170
  return;
}
}
#line 174
extern int ( /* missing proto */  strdup)() ;
#line 385
extern struct index_state the_index ;
#line 91 "git_leak_8.c"
struct diff_queue_struct diff_queued_diff  ;
#line 145 "git_leak_8.c"
void string_list_clear(struct string_list *list , int free_util ) 
{ 
  int i ;
  unsigned int tmp ;

  {
#line 147
  if (list->items) {
#line 149
    if (list->strdup_strings) {
#line 150
      i = 0;
#line 150
      while ((unsigned int )i < list->nr) {
#line 151
        free((void *)(list->items + i)->string);
#line 150
        i ++;
      }
    }
#line 153
    if (free_util) {
#line 154
      i = 0;
#line 154
      while ((unsigned int )i < list->nr) {
#line 155
        free((list->items + i)->util);
#line 154
        i ++;
      }
    }
#line 157
    free((void *)list->items);
  }
#line 159
  list->items = (struct string_list_item *)((void *)0);
#line 160
  tmp = 0U;
#line 160
  list->alloc = tmp;
#line 160
  list->nr = tmp;
#line 161
  return;
}
}
#line 167
extern int ( /* missing proto */  get_entry_index)() ;
#line 172
extern int ( /* missing proto */  alloc_nr)() ;
#line 172
extern int ( /* missing proto */  xrealloc)() ;
#line 164 "git_leak_8.c"
static int add_entry(int insert_at , struct string_list *list , char const   *string ) 
{ 
  int exact_match ;
  int index ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 166
  exact_match = 0;
#line 167
  if (insert_at != -1) {
#line 167
    tmp___0 = insert_at;
  } else {
#line 167
    tmp = get_entry_index(list, string, & exact_match);
#line 167
    tmp___0 = tmp;
  }
#line 167
  index = tmp___0;
#line 169
  if (exact_match) {
#line 170
    return (-1 - index);
  }
#line 172
  while (1) {
#line 172
    if (list->nr + 1U > list->alloc) {
#line 172
      tmp___2 = alloc_nr(list->alloc);
#line 172
      if ((unsigned int )tmp___2 < list->nr + 1U) {
#line 172
        list->alloc = list->nr + 1U;
      } else {
#line 172
        tmp___1 = alloc_nr(list->alloc);
#line 172
        list->alloc = (unsigned int )tmp___1;
      }
#line 172
      tmp___3 = st_mult(sizeof(*(list->items)), list->alloc);
#line 172
      tmp___4 = xrealloc(list->items, tmp___3);
#line 172
      list->items = (struct string_list_item *)tmp___4;
    }
#line 172
    break;
  }
#line 173
  if ((unsigned int )index < list->nr) {
#line 174
    move_array((void *)((list->items + index) + 1), (void const   *)(list->items + index),
               (size_t )(list->nr - (unsigned int )index), sizeof(*((list->items + index) + 1)) + (sizeof(char [1]) - 1UL));
  }
#line 176
  if (list->strdup_strings) {
#line 176
    tmp___5 = strdup(string);
#line 176
    (list->items + index)->string = (char *)tmp___5;
  } else {
#line 176
    (list->items + index)->string = (char *)string;
  }
#line 178
  (list->items + index)->util = (void *)0;
#line 179
  (list->nr) ++;
#line 181
  return (index);
}
}
#line 184 "git_leak_8.c"
struct string_list_item *string_list_insert(struct string_list *list , char const   *string ) 
{ 
  int index ;
  int tmp ;

  {
#line 186
  tmp = add_entry(-1, list, string);
#line 186
  index = tmp;
#line 188
  if (index < 0) {
#line 189
    index = -1 - index;
  }
#line 191
  return (list->items + index);
}
}
#line 209
extern int ( /* missing proto */  ce_stage)() ;
#line 212
extern int ( /* missing proto */  string_list_lookup)() ;
#line 198 "git_leak_8.c"
static struct string_list *get_unmerged(void) 
{ 
  struct string_list *unmerged ;
  void *tmp ;
  int i ;
  struct string_list_item *item ;
  struct stage_data *e ;
  struct cache_entry  const  *ce ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 200
  tmp = calloc((size_t )1, sizeof(struct string_list ));
#line 200
  unmerged = (struct string_list *)tmp;
#line 203
  unmerged->strdup_strings = 1U;
#line 205
  i = 0;
#line 205
  while ((unsigned int )i < the_index.cache_nr) {
#line 208
    ce = (struct cache_entry  const  *)*(the_index.cache + i);
#line 209
    tmp___0 = ce_stage(ce);
#line 209
    if (! tmp___0) {
#line 210
      goto __Cont;
    }
#line 212
    tmp___1 = string_list_lookup(unmerged, ce->name);
#line 212
    item = (struct string_list_item *)tmp___1;
#line 213
    if (! item) {
#line 214
      item = string_list_insert(unmerged, (char const   *)(ce->name));
#line 215
      item->util = calloc((size_t )1, sizeof(struct stage_data ));
    }
#line 217
    e = (struct stage_data *)item->util;
    __Cont: /* CIL Label */ 
#line 205
    i ++;
  }
#line 220
  return (unmerged);
}
}
#line 248
extern int ( /* missing proto */  diff_free_filepair)() ;
#line 229 "git_leak_8.c"
static struct string_list *get_renames(struct merge_options *o , struct tree *tree ,
                                       struct tree *o_tree , struct tree *a_tree ,
                                       struct tree *b_tree , struct string_list *entries ) 
{ 
  int i ;
  struct string_list *renames ;
  void *tmp ;
  struct string_list_item *item ;
  struct rename *re ;
  struct diff_filepair *pair ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 239
  tmp = calloc((size_t )1, sizeof(struct string_list ));
#line 239
  renames = (struct string_list *)tmp;
#line 240
  if (! o->detect_rename) {
#line 241
    return (renames);
  }
#line 243
  i = 0;
#line 243
  while (i < diff_queued_diff.nr) {
#line 246
    pair = *(diff_queued_diff.queue + i);
#line 247
    if ((int )pair->status != 82) {
#line 248
      diff_free_filepair(pair);
#line 249
      goto __Cont;
    }
#line 251
    tmp___0 = malloc(sizeof(*re));
#line 251
    re = (struct rename *)tmp___0;
#line 252
    re->processed = 0U;
#line 253
    re->pair = pair;
#line 254
    tmp___1 = string_list_lookup(entries, ((re->pair)->two)->path);
#line 254
    item = (struct string_list_item *)tmp___1;
#line 255
    item = string_list_insert(renames, (char const   *)(pair->one)->path);
#line 256
    item->util = (void *)re;
    __Cont: /* CIL Label */ 
#line 243
    i ++;
  }
#line 258
  diff_queued_diff.nr = 0;
#line 259
  return (renames);
}
}
#line 271
extern int ( /* missing proto */  git_merge_trees)() ;
#line 276
extern int ( /* missing proto */  get_files_dirs)() ;
#line 280
extern int ( /* missing proto */  record_df_conflict_files)() ;
#line 283
extern int ( /* missing proto */  process_renames)() ;
#line 290
extern int ( /* missing proto */  process_entry)() ;
#line 273
extern int ( /* missing proto */  unmerged_index)() ;
#line 263 "git_leak_8.c"
int merge_trees(struct merge_options *o , struct tree *head , struct tree *merge ,
                struct tree *common , struct tree **result ) 
{ 
  int code ;
  int clean ;
  struct string_list *entries ;
  struct string_list *re_head ;
  struct string_list *re_merge ;
  int i ;
  char const   *path ;
  struct stage_data *e ;
  int ret ;
  int tmp ;
  struct stage_data *e___0 ;
  int tmp___0 ;

  {
#line 271
  code = git_merge_trees(o->call_depth, common, head, merge);
#line 273
  tmp___0 = unmerged_index(& the_index);
#line 273
  if (tmp___0) {
#line 276
    get_files_dirs(o, head);
#line 277
    get_files_dirs(o, merge);
#line 279
    entries = get_unmerged();
#line 280
    record_df_conflict_files(o, entries);
#line 281
    re_head = get_renames(o, head, common, head, merge, entries);
#line 282
    re_merge = get_renames(o, merge, common, head, merge, entries);
#line 283
    clean = process_renames(o, re_head, re_merge);
#line 284
    if (clean < 0) {
#line 285
      return (clean);
    }
#line 286
    i = (int )(entries->nr - 1U);
#line 286
    while (0 <= i) {
#line 287
      path = (char const   *)(entries->items + i)->string;
#line 288
      e = (struct stage_data *)(entries->items + i)->util;
#line 289
      if (! e->processed) {
#line 290
        tmp = process_entry(o, path, e);
#line 290
        ret = tmp;
#line 291
        if (! ret) {
#line 292
          clean = 0;
        } else
#line 293
        if (ret < 0) {
#line 294
          return (ret);
        }
      }
#line 286
      i --;
    }
#line 297
    i = 0;
#line 297
    while ((unsigned int )i < entries->nr) {
#line 298
      e___0 = (struct stage_data *)(entries->items + i)->util;
#line 299
      if (! e___0->processed) {
#line 300
        printf((char const   * __restrict  )"BUG: unprocessed path??? %s", (entries->items + i)->string);
#line 300
        exit(1);
      }
#line 297
      i ++;
    }
#line 304
    string_list_clear(re_merge, 0);
#line 305
    string_list_clear(re_head, 0);
#line 306
    string_list_clear(entries, 1);
#line 308
    free((void *)re_merge);
#line 309
    free((void *)re_head);
#line 310
    free((void *)entries);
  } else {
#line 313
    clean = 1;
  }
#line 315
  return (clean);
}
}
#line 318 "git_leak_8.c"
int main(void) 
{ 
  struct merge_options o ;
  struct tree head ;
  struct tree merge ;
  struct tree common ;
  struct tree *result ;

  {
#line 325
  merge_trees(& o, & head, & merge, & common, & result);
#line 326
  return (0);
}
}
