/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

#line 216 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h"
typedef unsigned long size_t;
#line 184 "../git.h"
struct split_index {

};
#line 185 "../git.h"
struct cache_time {

};
#line 186 "../git.h"
struct hashmap {

};
#line 187 "../git.h"
struct hashmap_entry {

};
#line 188 "../git.h"
struct untracked_cache {

};
#line 189 "../git.h"
struct stat_data {

};
#line 191
enum attr_match_mode {
    MATCH_SET = 0,
    MATCH_UNSET = 1,
    MATCH_VALUE = 2,
    MATCH_UNSPECIFIED = 3
} ;
#line 191 "../git.h"
struct attr_match {
   char *value ;
   enum attr_match_mode match_mode ;
};
#line 191
struct attr_check;
#line 191 "../git.h"
struct pathspec_item {
   char *match ;
   char *original ;
   unsigned int magic ;
   int len ;
   int prefix ;
   int nowildcard_len ;
   int flags ;
   int attr_match_nr ;
   struct attr_match *attr_match ;
   struct attr_check *attr_check ;
};
#line 191 "../git.h"
struct pathspec {
   int nr ;
   unsigned int has_wildcard : 1 ;
   unsigned int recursive : 1 ;
   unsigned int magic ;
   int max_depth ;
   struct pathspec_item *items ;
};
#line 222 "../git.h"
struct string_list_item {
   char *string ;
   void *util ;
};
#line 227 "../git.h"
struct string_list {
   struct string_list_item *items ;
   unsigned int nr ;
   unsigned int alloc ;
   unsigned int strdup_strings : 1 ;
   int (*cmp)(char const   * , char const   * ) ;
};
#line 241 "../git.h"
struct strbuf {
   size_t alloc ;
   size_t len ;
   char *buf ;
};
#line 247
struct cache_tree;
#line 247 "../git.h"
struct cache_tree_sub {
   struct cache_tree *cache_tree ;
   int count ;
   int namelen ;
   int used ;
   char name[] ;
};
#line 255 "../git.h"
struct object_id {
   unsigned char hash[20] ;
};
#line 259 "../git.h"
struct cache_tree {
   int entry_count ;
   struct object_id oid ;
   int subtree_nr ;
   int subtree_alloc ;
   struct cache_tree_sub **down ;
};
#line 267 "../git.h"
struct object {
   unsigned int parsed : 1 ;
   unsigned int type : 3 ;
   unsigned int flags : 27 ;
   struct object_id oid ;
};
#line 274 "../git.h"
struct tree {
   struct object object ;
   void *buffer ;
   unsigned long size ;
};
#line 280 "../git.h"
struct cache_entry {
   struct hashmap_entry ent ;
   struct stat_data ce_stat_data ;
   unsigned int ce_mode ;
   unsigned int ce_flags ;
   unsigned int ce_namelen ;
   unsigned int index ;
   struct object_id oid ;
   char name[] ;
};
#line 291 "../git.h"
struct index_state {
   struct cache_entry **cache ;
   unsigned int version ;
   unsigned int cache_nr ;
   unsigned int cache_alloc ;
   unsigned int cache_changed ;
   struct string_list *resolve_undo ;
   struct cache_tree *cache_tree ;
   struct split_index *split_index ;
   struct cache_time timestamp ;
   unsigned int name_hash_initialized : 1 ;
   unsigned int initialized : 1 ;
   struct hashmap name_hash ;
   struct hashmap dir_hash ;
   unsigned char sha1[20] ;
   struct untracked_cache *untracked ;
};
#line 29 "git_leak_10.c"
struct unpack_trees_options;
#line 29
struct unpack_trees_options;
#line 30
struct exclude_list;
#line 30
struct exclude_list;
#line 62 "git_leak_10.c"
struct name_entry {
   struct object_id  const  *oid ;
   char const   *path ;
   unsigned int mode ;
};
#line 68 "git_leak_10.c"
struct tree_desc {
   void const   *buffer ;
   struct name_entry entry ;
   unsigned int size ;
};
#line 74
struct dir_struct;
#line 74 "git_leak_10.c"
struct unpack_trees_options {
   unsigned int reset ;
   unsigned int merge ;
   unsigned int update ;
   unsigned int index_only ;
   unsigned int nontrivial_merge ;
   unsigned int trivial_merges_only ;
   unsigned int verbose_update ;
   unsigned int aggressive ;
   unsigned int skip_unmerged ;
   unsigned int initial_checkout ;
   unsigned int diff_index_cached ;
   unsigned int debug_unpack ;
   unsigned int skip_sparse_checkout ;
   unsigned int gently ;
   unsigned int exiting_early ;
   unsigned int show_all_errors ;
   unsigned int dry_run ;
   char const   *prefix ;
   int cache_bottom ;
   struct dir_struct *dir ;
   struct pathspec *pathspec ;
   int (*fn)(struct cache_entry  const  * const  *src , struct unpack_trees_options *options ) ;
   char const   *msgs[10] ;
   struct string_list unpack_rejects[10] ;
   int head_idx ;
   int merge_size ;
   struct cache_entry *df_conflict_entry ;
   void *unpack_data ;
   struct index_state *dst_index ;
   struct index_state *src_index ;
   struct index_state result ;
   struct exclude_list *el ;
};
#line 117 "git_leak_10.c"
struct tree_desc_skip {
   struct tree_desc_skip *prev ;
   void const   *ptr ;
};
#line 122 "git_leak_10.c"
struct tree_desc_x {
   struct tree_desc d ;
   struct tree_desc_skip *skip ;
};
#line 182
struct traverse_info;
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 385 "../git.h"
extern struct index_state the_index ;
#line 386
extern char strbuf_slopbuf[] ;
#line 410 "../git.h"
void *xrealloc(void *ptr , size_t size ) 
{ 
  void *ret ;

  {
#line 414
  ret = realloc(ptr, size);
#line 415
  if (! ret) {
#line 415
    if (! size) {
#line 416
      ret = realloc(ptr, (size_t )1);
    }
  }
#line 417
  if (! ret) {
#line 418
    ret = realloc(ptr, size);
#line 419
    if (! ret) {
#line 419
      if (! size) {
#line 420
        ret = realloc(ptr, (size_t )1);
      }
    }
#line 421
    if (! ret) {
#line 422
      printf((char const   * __restrict  )"Out of memory, realloc failed%s", "");
#line 422
      exit(1);
    }
  }
#line 424
  return (ret);
}
}
#line 25 "git_leak_10.c"
char const   *tree_type  =    "tree";
#line 56
extern int oneway_merge(struct cache_entry  const  * const  *src , struct unpack_trees_options *o ) ;
#line 59
extern int twoway_merge(struct cache_entry  const  * const  *src , struct unpack_trees_options *o ) ;
#line 141
extern int ( /* missing proto */  decode_tree_entry)() ;
#line 127 "git_leak_10.c"
static int update_tree_entry_internal(struct tree_desc *desc , struct strbuf *err ) 
{ 
  void const   *buf ;
  unsigned char const   *end ;
  unsigned long size ;
  unsigned long len ;
  int tmp ;

  {
#line 129
  buf = desc->buffer;
#line 130
  end = (unsigned char const   *)((desc->entry.oid)->hash + 20);
#line 131
  size = (unsigned long )desc->size;
#line 132
  len = (unsigned long )(end - (unsigned char const   *)buf);
#line 134
  if (size < len) {
#line 135
    printf((char const   * __restrict  )"too-short tree file%s", buf);
#line 135
    exit(1);
  }
#line 136
  buf = (void const   *)end;
#line 137
  size -= len;
#line 138
  desc->buffer = buf;
#line 139
  desc->size = (unsigned int )size;
#line 140
  if (size) {
#line 141
    tmp = decode_tree_entry(desc, buf, size, err);
#line 141
    return (tmp);
  }
#line 142
  return (0);
}
}
#line 150
extern int ( /* missing proto */  strbuf_release)() ;
#line 145 "git_leak_10.c"
void update_tree_entry(struct tree_desc *desc ) 
{ 
  struct strbuf err ;
  int tmp ;

  {
#line 147
  err.alloc = (size_t )0;
#line 147
  err.len = (size_t )0;
#line 147
  err.buf = strbuf_slopbuf;
#line 148
  tmp = update_tree_entry_internal(desc, & err);
#line 148
  if (tmp) {
#line 149
    printf((char const   * __restrict  )"%s", err.buf);
#line 149
    exit(1);
  }
#line 150
  strbuf_release(& err);
#line 151
  return;
}
}
#line 169
extern int ( /* missing proto */  entry_clear)() ;
#line 172
extern int ( /* missing proto */  entry_extract)() ;
#line 153 "git_leak_10.c"
static void extended_entry_extract(struct tree_desc_x *t , struct name_entry *a ,
                                   char const   *first , int first_len ) 
{ 
  struct tree_desc_skip *skip ;

  {
#line 167
  while (1) {
#line 168
    if (! t->d.size) {
#line 169
      entry_clear(a);
#line 170
      break;
    }
#line 172
    entry_extract(& t->d, a);
#line 173
    skip = t->skip;
#line 173
    while (skip) {
#line 174
      if ((unsigned long )a->path == (unsigned long )skip->ptr) {
#line 175
        break;
      }
#line 173
      skip = skip->prev;
    }
#line 176
    if (! skip) {
#line 177
      break;
    }
#line 179
    update_tree_entry(& t->d);
  }
#line 181
  return;
}
}
#line 182 "git_leak_10.c"
int traverse_trees(int n , struct tree_desc *t , struct traverse_info *info ) 
{ 
  int i ;
  int n___0 ;
  struct tree_desc_x *tx ;
  void *tmp ;
  struct name_entry *entry ;
  void *tmp___0 ;
  struct name_entry *e ;

  {
#line 185
  tmp = calloc((size_t )n___0, sizeof(*tx));
#line 185
  tx = (struct tree_desc_x *)tmp;
#line 186
  tmp___0 = malloc((unsigned long )n___0 * sizeof(*entry));
#line 186
  entry = (struct name_entry *)tmp___0;
#line 187
  e = (struct name_entry *)((void *)0);
#line 188
  i = 0;
#line 188
  while (i < n___0) {
#line 189
    (tx + i)->d = *(t + i);
#line 188
    i ++;
  }
#line 190
  i = 0;
#line 190
  while (i < n___0) {
#line 191
    e = entry + i;
#line 192
    extended_entry_extract(tx + i, e, (char const   *)((void *)0), 0);
#line 190
    i ++;
  }
#line 194
  free((void *)tx);
#line 195
  return (1);
}
}
#line 198 "git_leak_10.c"
int unpack_trees(unsigned int len , struct tree_desc *t , struct unpack_trees_options *o ) 
{ 


  {
#line 200
  traverse_trees((int )len, t, (struct traverse_info *)((void *)0));
#line 201
  return (0);
}
}
#line 205 "git_leak_10.c"
static int init_tree_desc_internal(struct tree_desc *desc , void const   *buffer ,
                                   unsigned long size , struct strbuf *err ) 
{ 
  int tmp ;

  {
#line 207
  desc->buffer = buffer;
#line 208
  desc->size = (unsigned int )size;
#line 209
  if (size) {
#line 210
    tmp = decode_tree_entry(desc, buffer, size, err);
#line 210
    return (tmp);
  }
#line 211
  return (0);
}
}
#line 214 "git_leak_10.c"
void init_tree_desc(struct tree_desc *desc , void const   *buffer , unsigned long size ) 
{ 
  struct strbuf err ;
  int tmp ;

  {
#line 216
  err.alloc = (size_t )0;
#line 216
  err.len = (size_t )0;
#line 216
  err.buf = strbuf_slopbuf;
#line 217
  tmp = init_tree_desc_internal(desc, buffer, size, & err);
#line 217
  if (tmp) {
#line 218
    printf((char const   * __restrict  )"%s", err.buf);
#line 218
    exit(1);
  }
#line 219
  strbuf_release(& err);
#line 220
  return;
}
}
#line 230
extern int ( /* missing proto */  oid_to_hex)() ;
#line 222 "git_leak_10.c"
void fill_tree_descriptor(struct tree_desc *desc , struct object_id  const  *oid ) 
{ 
  unsigned long size ;
  void *buf ;
  int tmp ;

  {
#line 224
  size = 0UL;
#line 225
  buf = (void *)0;
#line 227
  if (oid) {
#line 228
    buf = malloc((size_t )100);
#line 229
    if (! buf) {
#line 230
      tmp = oid_to_hex(oid);
#line 230
      printf((char const   * __restrict  )"unable to read tree %s", tmp);
#line 230
      exit(1);
    }
  }
#line 232
  init_tree_desc(desc, (void const   *)buf, size);
#line 233
  return;
}
}
#line 242
extern int ( /* missing proto */  memset)() ;
#line 262
extern int ( /* missing proto */  read_cache_unmerged)() ;
#line 267
extern int ( /* missing proto */  error)() ;
#line 267
extern int ( /* missing proto */  _)() ;
#line 266
extern int ( /* missing proto */  get_oid)() ;
#line 281
extern int ( /* missing proto */  parse_tree_indirect)() ;
#line 282
extern int ( /* missing proto */  prime_cache_tree)() ;
#line 235 "git_leak_10.c"
static int reset_index(struct object_id  const  *oid , int reset_type , int quiet ) 
{ 
  int nr ;
  struct tree_desc desc[2] ;
  struct tree *tree ;
  struct unpack_trees_options opts ;
  struct object_id head_oid ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 237
  nr = 0;
#line 242
  memset(& opts, 0, sizeof(opts));
#line 243
  opts.head_idx = 1;
#line 244
  opts.src_index = & the_index;
#line 245
  opts.dst_index = & the_index;
#line 246
  opts.fn = & oneway_merge;
#line 247
  opts.merge = 1U;
#line 248
  if (! quiet) {
#line 249
    opts.verbose_update = 1U;
  }
#line 250
  switch (reset_type) {
  case 3: 
  case 4: 
#line 253
  opts.update = 1U;
#line 254
  break;
  case 2: 
#line 256
  opts.update = 1U;
  default: 
#line 259
  opts.reset = 1U;
  }
#line 262
  read_cache_unmerged();
#line 264
  if (reset_type == 4) {
#line 266
    tmp___1 = get_oid("HEAD", & head_oid);
#line 266
    if (tmp___1) {
#line 267
      tmp = _("You do not have a valid HEAD.");
#line 267
      tmp___0 = error(tmp);
#line 267
      return (tmp___0);
    }
#line 268
    fill_tree_descriptor(desc + nr, (struct object_id  const  *)(& head_oid));
#line 269
    nr ++;
#line 270
    opts.fn = & twoway_merge;
  }
#line 273
  fill_tree_descriptor(desc + nr, oid);
#line 274
  nr ++;
#line 276
  printf((char const   * __restrict  )"%d\n", desc[nr].buffer);
#line 277
  tmp___2 = unpack_trees((unsigned int )nr, desc, & opts);
#line 277
  if (tmp___2) {
#line 278
    return (-1);
  }
#line 280
  if (reset_type == 0) {
#line 281
    tmp___3 = parse_tree_indirect(oid);
#line 281
    tree = (struct tree *)tmp___3;
#line 282
    prime_cache_tree(& the_index, tree);
  } else
#line 280
  if (reset_type == 2) {
#line 281
    tmp___3 = parse_tree_indirect(oid);
#line 281
    tree = (struct tree *)tmp___3;
#line 282
    prime_cache_tree(& the_index, tree);
  }
#line 285
  return (0);
}
}
#line 288 "git_leak_10.c"
int main(void) 
{ 
  struct object_id oid ;
  int type ;
  int quiet ;

  {
#line 292
  reset_index((struct object_id  const  *)(& oid), type, quiet);
#line 293
  return (0);
}
}
