/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

#line 216 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h"
typedef unsigned long size_t;
#line 179 "../git.h"
struct rev_info {

};
#line 218 "../git.h"
typedef unsigned long long uintmax_t;
#line 219 "../git.h"
typedef uintmax_t timestamp_t;
#line 241 "../git.h"
struct strbuf {
   size_t alloc ;
   size_t len ;
   char *buf ;
};
#line 255 "../git.h"
struct object_id {
   unsigned char hash[20] ;
};
#line 267 "../git.h"
struct object {
   unsigned int parsed : 1 ;
   unsigned int type : 3 ;
   unsigned int flags : 27 ;
   struct object_id oid ;
};
#line 274 "../git.h"
struct tree {
   struct object object ;
   void *buffer ;
   unsigned long size ;
};
#line 307
struct commit;
#line 307 "../git.h"
struct commit_list {
   struct commit *item ;
   struct commit_list *next ;
};
#line 312 "../git.h"
struct commit {
   struct object object ;
   void *util ;
   unsigned int index ;
   timestamp_t date ;
   struct commit_list *parents ;
   struct tree *tree ;
};
#line 375 "../git.h"
struct merge_parent {
   struct object_id given ;
   struct object_id commit ;
   unsigned char used ;
};
#line 375 "../git.h"
struct merge_parents {
   int alloc ;
   int nr ;
   struct merge_parent *item ;
};
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 133 "../git.h"
static unsigned int const   all_flags  =    (unsigned int const   )((((1U << 16) | (1U << 17)) | (1U << 18)) | (1U << 19));
#line 161
extern int ( /* missing proto */  memcpy)() ;
#line 161
extern int ( /* missing proto */  st_mult)() ;
#line 158 "../git.h"
__inline static void copy_array(void *dst , void const   *src , size_t n , size_t size ) 
{ 
  int tmp ;

  {
#line 160
  if (n) {
#line 161
    tmp = st_mult(size, n);
#line 161
    memcpy(dst, src, tmp);
  }
#line 162
  return;
}
}
#line 12 "git_leak_4.c"
struct commit_list *commit_list_insert(struct commit *item , struct commit_list **list_p ) 
{ 
  struct commit_list *new_list ;
  void *tmp ;

  {
#line 14
  tmp = malloc(sizeof(struct commit_list ));
#line 14
  new_list = (struct commit_list *)tmp;
#line 15
  new_list->item = item;
#line 16
  new_list->next = *list_p;
#line 17
  *list_p = new_list;
#line 18
  return (new_list);
}
}
#line 39
extern int ( /* missing proto */  parse_commit)() ;
#line 51
extern int ( /* missing proto */  paint_down_to_common)() ;
#line 57
extern int ( /* missing proto */  clear_commit_marks)() ;
#line 60
extern int ( /* missing proto */  free_commit_list)() ;
#line 21 "git_leak_4.c"
static int remove_redundant(struct commit **array , int cnt ) 
{ 
  struct commit **work ;
  unsigned char *redundant ;
  int *filled_index ;
  int i ;
  int j ;
  int filled ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  struct commit_list *common ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 34
  tmp = calloc((size_t )cnt, sizeof(*work));
#line 34
  work = (struct commit **)tmp;
#line 35
  tmp___0 = calloc((size_t )cnt, (size_t )1);
#line 35
  redundant = (unsigned char *)tmp___0;
#line 36
  tmp___1 = st_mult(sizeof(*filled_index), cnt - 1);
#line 36
  tmp___2 = malloc((size_t )tmp___1);
#line 36
  filled_index = (int *)tmp___2;
#line 38
  i = 0;
#line 38
  while (i < cnt) {
#line 39
    parse_commit(*(array + i));
#line 38
    i ++;
  }
#line 40
  i = 0;
#line 40
  while (i < cnt) {
#line 43
    if (*(redundant + i)) {
#line 44
      goto __Cont;
    }
#line 45
    filled = 0;
#line 45
    j = filled;
#line 45
    while (j < cnt) {
#line 46
      if (i == j) {
#line 47
        goto __Cont___0;
      } else
#line 46
      if (*(redundant + j)) {
#line 47
        goto __Cont___0;
      }
#line 48
      *(filled_index + filled) = j;
#line 49
      tmp___3 = filled;
#line 49
      filled ++;
#line 49
      *(work + tmp___3) = *(array + j);
      __Cont___0: /* CIL Label */ 
#line 45
      j ++;
    }
#line 51
    tmp___4 = paint_down_to_common(*(array + i), filled, work);
#line 51
    common = (struct commit_list *)tmp___4;
#line 52
    if ((*(array + i))->object.flags & (1U << 17)) {
#line 53
      *(redundant + i) = (unsigned char)1;
    }
#line 54
    j = 0;
#line 54
    while (j < filled) {
#line 55
      if ((*(work + j))->object.flags & (1U << 16)) {
#line 56
        *(redundant + *(filled_index + j)) = (unsigned char)1;
      }
#line 54
      j ++;
    }
#line 57
    clear_commit_marks(*(array + i), all_flags);
#line 58
    j = 0;
#line 58
    while (j < filled) {
#line 59
      clear_commit_marks(*(work + j), all_flags);
#line 58
      j ++;
    }
#line 60
    free_commit_list(common);
    __Cont: /* CIL Label */ 
#line 40
    i ++;
  }
#line 64
  copy_array((void *)work, (void const   *)array, (size_t )cnt, sizeof(*work) + (sizeof(char [1]) - 1UL));
#line 65
  filled = 0;
#line 65
  i = filled;
#line 65
  while (i < cnt) {
#line 66
    if (! *(redundant + i)) {
#line 67
      tmp___5 = filled;
#line 67
      filled ++;
#line 67
      *(array + tmp___5) = *(work + i);
    }
#line 65
    i ++;
  }
#line 68
  j = filled;
#line 68
  i = 0;
#line 68
  while (i < cnt) {
#line 69
    if (*(redundant + i)) {
#line 70
      tmp___6 = j;
#line 70
      j ++;
#line 70
      *(array + tmp___6) = *(work + i);
    }
#line 68
    i ++;
  }
#line 71
  free((void *)work);
#line 72
  free((void *)redundant);
#line 73
  free((void *)filled_index);
#line 74
  return (filled);
}
}
#line 77 "git_leak_4.c"
struct commit_list *reduce_heads(struct commit_list *heads ) 
{ 
  struct commit_list *p ;
  struct commit_list *result ;
  struct commit_list **tail ;
  struct commit **array ;
  int num_head ;
  int i ;
  void *tmp ;
  int tmp___0 ;
  struct commit_list *tmp___1 ;

  {
#line 80
  result = (struct commit_list *)((void *)0);
#line 80
  tail = & result;
#line 84
  if (! heads) {
#line 85
    return ((struct commit_list *)((void *)0));
  }
#line 88
  p = heads;
#line 88
  while (p) {
#line 89
    (p->item)->object.flags &= ~ (1U << 18);
#line 88
    p = p->next;
  }
#line 90
  p = heads;
#line 90
  num_head = 0;
#line 90
  while (p) {
#line 91
    if ((p->item)->object.flags & (1U << 18)) {
#line 92
      goto __Cont;
    }
#line 93
    (p->item)->object.flags |= 1U << 18;
#line 94
    num_head ++;
    __Cont: /* CIL Label */ 
#line 90
    p = p->next;
  }
#line 96
  tmp = calloc((size_t )num_head, sizeof(*array));
#line 96
  array = (struct commit **)tmp;
#line 97
  p = heads;
#line 97
  i = 0;
#line 97
  while (p) {
#line 98
    if ((p->item)->object.flags & (1U << 18)) {
#line 99
      tmp___0 = i;
#line 99
      i ++;
#line 99
      *(array + tmp___0) = p->item;
#line 100
      (p->item)->object.flags &= ~ (1U << 18);
    }
#line 97
    p = p->next;
  }
#line 103
  num_head = remove_redundant(array, num_head);
#line 104
  i = 0;
#line 104
  while (i < num_head) {
#line 105
    tmp___1 = commit_list_insert(*(array + i), tail);
#line 105
    tail = & tmp___1->next;
#line 104
    i ++;
  }
#line 106
  free((void *)array);
#line 107
  return (result);
}
}
#line 121
extern int ( /* missing proto */  strchr)() ;
#line 126
extern int ( /* missing proto */  strlen)() ;
#line 129
extern int ( /* missing proto */  get_oid_hex)() ;
#line 139
extern int ( /* missing proto */  parse_object)() ;
#line 140
extern int ( /* missing proto */  peel_to_type)() ;
#line 144
extern int ( /* missing proto */  add_merge_parent)() ;
#line 146
extern int ( /* missing proto */  lookup_commit)() ;
#line 152
extern int ( /* missing proto */  pop_commit)() ;
#line 154
extern int ( /* missing proto */  oidcmp)() ;
#line 110 "git_leak_4.c"
static void find_merge_parents(struct merge_parents *result , struct strbuf *in ,
                               struct object_id *head ) 
{ 
  struct commit_list *parents ;
  struct commit *head_commit ;
  int pos ;
  int i ;
  int j ;
  int len ;
  char *p ;
  char *newline ;
  int tmp ;
  struct object_id oid ;
  struct commit *parent ;
  struct object *obj ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  struct commit *cmit ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 115
  pos = 0;
#line 117
  parents = (struct commit_list *)((void *)0);
#line 118
  while ((size_t )pos < in->len) {
#line 120
    p = in->buf + pos;
#line 121
    tmp = strchr(p, '\n');
#line 121
    newline = (char *)tmp;
#line 126
    if (newline) {
#line 126
      len = (int )(newline - p);
    } else {
#line 126
      tmp___0 = strlen(p);
#line 126
      len = tmp___0;
    }
#line 127
    pos += len + ! (! newline);
#line 129
    if (len < 43) {
#line 133
      continue;
    } else {
#line 129
      tmp___1 = get_oid_hex(p, & oid);
#line 129
      if (tmp___1) {
#line 133
        continue;
      } else
#line 129
      if ((int )*(p + 40) != 9) {
#line 133
        continue;
      } else
#line 129
      if ((int )*(p + 41) != 9) {
#line 133
        continue;
      }
    }
#line 139
    tmp___2 = parse_object(& oid);
#line 139
    obj = (struct object *)tmp___2;
#line 140
    tmp___3 = peel_to_type((void *)0, 0, obj, 1);
#line 140
    parent = (struct commit *)tmp___3;
#line 141
    if (! parent) {
#line 142
      continue;
    }
#line 143
    commit_list_insert(parent, & parents);
#line 144
    add_merge_parent(result, & obj->oid, & parent->object.oid);
  }
#line 146
  tmp___4 = lookup_commit(head);
#line 146
  head_commit = (struct commit *)tmp___4;
#line 147
  if (head_commit) {
#line 148
    commit_list_insert(head_commit, & parents);
  }
#line 149
  parents = reduce_heads(parents);
#line 151
  while (parents) {
#line 152
    tmp___5 = pop_commit(& parents);
#line 152
    cmit = (struct commit *)tmp___5;
#line 153
    i = 0;
#line 153
    while (i < result->nr) {
#line 154
      tmp___6 = oidcmp(& (result->item + i)->commit, & cmit->object.oid);
#line 154
      if (! tmp___6) {
#line 155
        (result->item + i)->used = (unsigned char)1;
      }
#line 153
      i ++;
    }
  }
#line 158
  j = 0;
#line 158
  i = j;
#line 158
  while (i < result->nr) {
#line 159
    if ((result->item + i)->used) {
#line 160
      if (i != j) {
#line 161
        *(result->item + j) = *(result->item + i);
      }
#line 162
      j ++;
    }
#line 158
    i ++;
  }
#line 165
  result->nr = j;
#line 166
  return;
}
}
#line 175
extern int ( /* missing proto */  commit_list_count)() ;
#line 168 "git_leak_4.c"
static int mark_redundant_parents(struct rev_info *revs , struct commit *commit ) 
{ 
  struct commit_list *h ;
  struct commit_list *tmp ;
  int i ;
  int marked ;
  struct commit_list *po ;
  struct commit_list *pn ;
  int orig_cnt ;
  int tmp___0 ;
  int cnt ;
  int tmp___1 ;

  {
#line 170
  tmp = reduce_heads(commit->parents);
#line 170
  h = tmp;
#line 171
  i = 0;
#line 171
  marked = 0;
#line 175
  tmp___0 = commit_list_count(commit->parents);
#line 175
  orig_cnt = tmp___0;
#line 176
  tmp___1 = commit_list_count(h);
#line 176
  cnt = tmp___1;
#line 183
  po = commit->parents;
#line 184
  pn = h;
#line 185
  while (po) {
#line 186
    if (pn) {
#line 186
      if ((unsigned long )po->item == (unsigned long )pn->item) {
#line 187
        pn = pn->next;
#line 188
        i ++;
      } else {
#line 190
        (po->item)->object.flags |= 1U << 4;
#line 191
        marked ++;
      }
    } else {
#line 190
      (po->item)->object.flags |= 1U << 4;
#line 191
      marked ++;
    }
#line 193
    po = po->next;
  }
#line 196
  if (i != cnt) {
#line 197
    printf((char const   * __restrict  )"mark_redundant_parents %d", orig_cnt);
#line 197
    exit(1);
  } else
#line 196
  if (cnt + marked != orig_cnt) {
#line 197
    printf((char const   * __restrict  )"mark_redundant_parents %d", orig_cnt);
#line 197
    exit(1);
  }
#line 199
  free_commit_list(h);
#line 201
  return (marked);
}
}
#line 204 "git_leak_4.c"
int main(void) 
{ 
  struct merge_parents result ;
  struct strbuf in ;
  struct object_id head ;
  struct rev_info revs ;
  struct commit_list *list ;
  int i ;

  {
#line 211
  i = 0;
#line 211
  while (i < 10) {
#line 213
    commit_list_insert((struct commit *)((void *)0), & list);
#line 211
    i ++;
  }
#line 215
  mark_redundant_parents(& revs, list->item);
#line 216
  free_commit_list(list);
#line 217
  find_merge_parents(& result, & in, & head);
#line 218
  return (0);
}
}
