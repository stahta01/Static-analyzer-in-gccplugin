/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

#line 216 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h"
typedef unsigned long size_t;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 70 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __mode_t mode_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 184 "../git.h"
struct split_index {

};
#line 185 "../git.h"
struct cache_time {

};
#line 186 "../git.h"
struct hashmap {

};
#line 187 "../git.h"
struct hashmap_entry {

};
#line 188 "../git.h"
struct untracked_cache {

};
#line 189 "../git.h"
struct stat_data {

};
#line 222 "../git.h"
struct string_list_item {
   char *string ;
   void *util ;
};
#line 227 "../git.h"
struct string_list {
   struct string_list_item *items ;
   unsigned int nr ;
   unsigned int alloc ;
   unsigned int strdup_strings : 1 ;
   int (*cmp)(char const   * , char const   * ) ;
};
#line 247
struct cache_tree;
#line 247 "../git.h"
struct cache_tree_sub {
   struct cache_tree *cache_tree ;
   int count ;
   int namelen ;
   int used ;
   char name[] ;
};
#line 255 "../git.h"
struct object_id {
   unsigned char hash[20] ;
};
#line 259 "../git.h"
struct cache_tree {
   int entry_count ;
   struct object_id oid ;
   int subtree_nr ;
   int subtree_alloc ;
   struct cache_tree_sub **down ;
};
#line 280 "../git.h"
struct cache_entry {
   struct hashmap_entry ent ;
   struct stat_data ce_stat_data ;
   unsigned int ce_mode ;
   unsigned int ce_flags ;
   unsigned int ce_namelen ;
   unsigned int index ;
   struct object_id oid ;
   char name[] ;
};
#line 291 "../git.h"
struct index_state {
   struct cache_entry **cache ;
   unsigned int version ;
   unsigned int cache_nr ;
   unsigned int cache_alloc ;
   unsigned int cache_changed ;
   struct string_list *resolve_undo ;
   struct cache_tree *cache_tree ;
   struct split_index *split_index ;
   struct cache_time timestamp ;
   unsigned int name_hash_initialized : 1 ;
   unsigned int initialized : 1 ;
   struct hashmap name_hash ;
   struct hashmap dir_hash ;
   unsigned char sha1[20] ;
   struct untracked_cache *untracked ;
};
#line 74 "git_uaf_4_dir.c"
struct dir_entry {
   struct hashmap_entry ent ;
   struct dir_entry *parent ;
   struct cache_entry *ce ;
   int nr ;
   unsigned int namelen ;
};
#line 86 "git_uaf_4_dir.c"
struct hashmap___0 {
   struct hashmap_entry **table ;
   int (*cmpfn)(void const   *entry , void const   *entry_or_key , void const   *keydata ) ;
   unsigned int size ;
   unsigned int tablesize ;
   unsigned int grow_at ;
   unsigned int shrink_at ;
};
#line 92 "git_uaf_4_dir.c"
struct hashmap_iter {
   struct hashmap___0 *map ;
   struct hashmap_entry *next ;
   unsigned int tablepos ;
};
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 161 "../git.h"
extern int ( /* missing proto */  memcpy)() ;
#line 98 "git_uaf_4_dir.c"
extern int ignore_case ;
#line 107
extern int ( /* missing proto */  hashmap_iter_init)() ;
#line 108
extern int ( /* missing proto */  hashmap_iter_next)() ;
#line 112
extern int ( /* missing proto */  memset)() ;
#line 100 "git_uaf_4_dir.c"
void hashmap_free(struct hashmap___0 *map , int free_entries ) 
{ 
  struct hashmap_iter iter ;
  struct hashmap_entry *e ;
  int tmp ;

  {
#line 102
  if (! map) {
#line 103
    return;
  } else
#line 102
  if (! map->table) {
#line 103
    return;
  }
#line 104
  if (free_entries) {
#line 107
    hashmap_iter_init(map, & iter);
#line 108
    while (1) {
#line 108
      tmp = hashmap_iter_next(& iter);
#line 108
      e = (struct hashmap_entry *)tmp;
#line 108
      if (! e) {
#line 108
        break;
      }
#line 109
      free((void *)e);
    }
  }
#line 111
  free((void *)map->table);
#line 112
  memset(map, 0, sizeof(*map));
#line 113
  return;
}
}
#line 115 "git_uaf_4_dir.c"
void free_name_hash(struct index_state *istate ) 
{ 


  {
#line 117
  if (! istate->name_hash_initialized) {
#line 118
    return;
  }
#line 119
  istate->name_hash_initialized = 0U;
#line 121
  hashmap_free((struct hashmap___0 *)(& istate->name_hash), 0);
#line 122
  hashmap_free((struct hashmap___0 *)(& istate->dir_hash), 1);
#line 123
  return;
}
}
#line 135
extern int ( /* missing proto */  hashmap_entry_init)() ;
#line 135
extern int ( /* missing proto */  memihash)() ;
#line 137
extern int ( /* missing proto */  hashmap_get)() ;
#line 131 "git_uaf_4_dir.c"
static struct dir_entry *find_dir_entry(struct index_state *istate , char const   *name ,
                                        unsigned int namelen ) 
{ 
  struct dir_entry key ;
  int tmp ;
  int tmp___0 ;

  {
#line 135
  tmp = memihash(name, namelen);
#line 135
  hashmap_entry_init(& key, tmp);
#line 136
  key.namelen = namelen;
#line 137
  tmp___0 = hashmap_get(& istate->dir_hash, & key, name);
#line 137
  return ((struct dir_entry *)tmp___0);
}
}
#line 146
extern int ( /* missing proto */  is_dir_sep)() ;
#line 160
extern int ( /* missing proto */  hashmap_add)() ;
#line 140 "git_uaf_4_dir.c"
static struct dir_entry *hash_dir_entry(struct index_state *istate , struct cache_entry *ce ,
                                        int namelen ) 
{ 
  struct dir_entry *dir ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 146
  while (1) {
#line 146
    if (namelen > 0) {
#line 146
      tmp = is_dir_sep((int )ce->name[namelen - 1]);
#line 146
      if (tmp) {
#line 146
        break;
      }
    } else {
#line 146
      break;
    }
#line 147
    namelen --;
  }
#line 148
  if (namelen <= 0) {
#line 149
    return ((struct dir_entry *)((void *)0));
  }
#line 150
  namelen --;
#line 153
  dir = find_dir_entry(istate, (char const   *)(ce->name), (unsigned int )namelen);
#line 154
  if (! dir) {
#line 156
    tmp___0 = calloc((size_t )1, sizeof(struct dir_entry ));
#line 156
    dir = (struct dir_entry *)tmp___0;
#line 157
    tmp___1 = memihash(ce->name, namelen);
#line 157
    hashmap_entry_init(dir, tmp___1);
#line 158
    dir->namelen = (unsigned int )namelen;
#line 159
    dir->ce = ce;
#line 160
    hashmap_add(& istate->dir_hash, dir);
#line 163
    dir->parent = hash_dir_entry(istate, ce, namelen);
  }
#line 165
  return (dir);
}
}
#line 173
extern int ( /* missing proto */  lazy_init_name_hash)() ;
#line 168 "git_uaf_4_dir.c"
struct cache_entry *index_dir_exists(struct index_state *istate , char const   *name ,
                                     int namelen ) 
{ 
  struct dir_entry *dir ;

  {
#line 173
  lazy_init_name_hash(istate);
#line 174
  dir = find_dir_entry(istate, name, (unsigned int )namelen);
#line 175
  if (dir) {
#line 175
    if (dir->nr) {
#line 176
      return (dir->ce);
    }
  }
#line 178
  return ((struct cache_entry *)((void *)0));
}
}
#line 184
extern int ( /* missing proto */  ce_namelen)() ;
#line 181 "git_uaf_4_dir.c"
static void add_dir_entry(struct index_state *istate , struct cache_entry *ce ) 
{ 
  struct dir_entry *dir ;
  int tmp ;
  struct dir_entry *tmp___0 ;
  int tmp___1 ;

  {
#line 184
  tmp = ce_namelen(ce);
#line 184
  tmp___0 = hash_dir_entry(istate, ce, tmp);
#line 184
  dir = tmp___0;
#line 185
  while (1) {
#line 185
    if (dir) {
#line 185
      tmp___1 = dir->nr;
#line 185
      (dir->nr) ++;
#line 185
      if (tmp___1) {
#line 185
        break;
      }
    } else {
#line 185
      break;
    }
#line 186
    dir = dir->parent;
  }
#line 187
  return;
}
}
#line 189 "git_uaf_4_dir.c"
static void hash_index_entry(struct index_state *istate , struct cache_entry *ce ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 191
  if (ce->ce_flags & (unsigned int )(1 << 20)) {
#line 192
    return;
  }
#line 193
  ce->ce_flags |= (unsigned int )(1 << 20);
#line 194
  tmp = ce_namelen(ce);
#line 194
  tmp___0 = memihash(ce->name, tmp);
#line 194
  hashmap_entry_init(ce, tmp___0);
#line 195
  hashmap_add(& istate->name_hash, ce);
#line 197
  if (ignore_case) {
#line 198
    add_dir_entry(istate, ce);
  }
#line 199
  return;
}
}
#line 212 "git_uaf_4_dir.c"
void add_name_hash(struct index_state *istate , struct cache_entry *ce ) 
{ 


  {
#line 214
  if (istate->name_hash_initialized) {
#line 215
    hash_index_entry(istate, ce);
  }
#line 216
  return;
}
}
#line 231
extern int ( /* missing proto */  error)() ;
#line 233
extern int ( /* missing proto */  strlen)() ;
#line 238
extern int ( /* missing proto */  cache_entry_size)() ;
#line 243
extern int ( /* missing proto */  fill_stat_cache_info)() ;
#line 270
extern int ( /* missing proto */  index_file_exists)() ;
#line 275
extern int ( /* missing proto */  ce_mark_uptodate)() ;
#line 274
extern int ( /* missing proto */  S_ISGITLINK)() ;
#line 271
extern int ( /* missing proto */  ce_stage)() ;
#line 271
extern int ( /* missing proto */  ie_match_stat)() ;
#line 281
extern int ( /* missing proto */  create_alias_ce)() ;
#line 280
extern int ( /* missing proto */  different_name)() ;
#line 286
extern int ( /* missing proto */  add_index_entry)() ;
#line 218 "git_uaf_4_dir.c"
int add_to_index(struct index_state *istate , char const   *path , struct stat *st ,
                 int flags ) 
{ 
  int size ;
  int namelen ;
  int was_same ;
  mode_t st_mode ;
  struct cache_entry *ce ;
  struct cache_entry *alias ;
  unsigned int ce_option ;
  int verbose ;
  int pretend ;
  int intent_only ;
  int add_option ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  char const   *startPtr ;
  char const   *ptr ;
  struct cache_entry *foundce ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 221
  st_mode = st->st_mode;
#line 223
  ce_option = 7U;
#line 224
  verbose = flags & 3;
#line 225
  pretend = flags & 2;
#line 226
  intent_only = flags & 16;
#line 227
  if (intent_only) {
#line 227
    tmp = 16;
  } else {
#line 227
    tmp = 0;
  }
#line 227
  add_option = 3 | tmp;
#line 230
  if (! ((st_mode & 61440U) == 32768U)) {
#line 230
    if (! ((st_mode & 61440U) == 40960U)) {
#line 230
      if (! ((st_mode & 61440U) == 16384U)) {
#line 231
        tmp___0 = error("%s: can only add regular files, symbolic links or git-directories",
                        path);
#line 231
        return (tmp___0);
      }
    }
  }
#line 233
  namelen = strlen(path);
#line 234
  if ((st_mode & 61440U) == 16384U) {
#line 235
    while (1) {
#line 235
      if (namelen) {
#line 235
        if (! ((int const   )*(path + (namelen - 1)) == 47)) {
#line 235
          break;
        }
      } else {
#line 235
        break;
      }
#line 236
      namelen --;
    }
  }
#line 238
  size = cache_entry_size(namelen);
#line 239
  tmp___1 = calloc((size_t )1, (size_t )size);
#line 239
  ce = (struct cache_entry *)tmp___1;
#line 240
  memcpy(ce->name, path, namelen);
#line 241
  ce->ce_namelen = (unsigned int )namelen;
#line 242
  if (! intent_only) {
#line 243
    fill_stat_cache_info(ce, st);
  } else {
#line 245
    ce->ce_flags |= (unsigned int )(1 << 29);
  }
#line 252
  if (ignore_case) {
#line 253
    startPtr = (char const   *)(ce->name);
#line 254
    ptr = startPtr;
#line 255
    while (*ptr) {
#line 256
      while (1) {
#line 256
        if (*ptr) {
#line 256
          if (! ((int const   )*ptr != 47)) {
#line 256
            break;
          }
        } else {
#line 256
          break;
        }
#line 257
        ptr ++;
      }
#line 258
      if ((int const   )*ptr == 47) {
#line 260
        ptr ++;
#line 261
        foundce = index_dir_exists(istate, (char const   *)(ce->name), (int )((ptr - (char const   *)(ce->name)) - 1L));
#line 262
        if (foundce) {
#line 263
          memcpy((void *)startPtr, foundce->name + (startPtr - (char const   *)(ce->name)),
                 ptr - startPtr);
#line 264
          startPtr = ptr;
        }
      }
    }
  }
#line 270
  tmp___2 = ce_namelen(ce);
#line 270
  tmp___3 = index_file_exists(istate, ce->name, tmp___2, ignore_case);
#line 270
  alias = (struct cache_entry *)tmp___3;
#line 271
  if (alias) {
#line 271
    tmp___5 = ce_stage(alias);
#line 271
    if (! tmp___5) {
#line 271
      tmp___6 = ie_match_stat(istate, alias, st, ce_option);
#line 271
      if (! tmp___6) {
#line 273
        free((void *)ce);
#line 274
        tmp___4 = S_ISGITLINK(alias->ce_mode);
#line 274
        if (! tmp___4) {
#line 275
          ce_mark_uptodate(alias);
        }
#line 276
        alias->ce_flags |= (unsigned int )(1 << 19);
#line 277
        return (0);
      }
    }
  }
#line 280
  if (ignore_case) {
#line 280
    if (alias) {
#line 280
      tmp___8 = different_name(ce, alias);
#line 280
      if (tmp___8) {
#line 281
        tmp___7 = create_alias_ce(istate, ce, alias);
#line 281
        ce = (struct cache_entry *)tmp___7;
      }
    }
  }
#line 282
  ce->ce_flags |= (unsigned int )(1 << 19);
#line 284
  if (! pretend) {
#line 286
    tmp___10 = add_index_entry(istate, ce, add_option);
#line 286
    if (tmp___10) {
#line 287
      tmp___9 = error("unable to add %s to index", path);
#line 287
      return (tmp___9);
    }
  }
#line 288
  if (verbose) {
#line 288
    if (! was_same) {
#line 289
      printf((char const   * __restrict  )"add \'%s\'\n", path);
    }
  }
#line 290
  return (0);
}
}
#line 293 "git_uaf_4_dir.c"
static void set_index_entry(struct index_state *istate , int nr , struct cache_entry *ce ) 
{ 


  {
#line 295
  *(istate->cache + nr) = ce;
#line 296
  add_name_hash(istate, ce);
#line 297
  return;
}
}
#line 299 "git_uaf_4_dir.c"
int main(int argc , char **argv ) 
{ 
  struct index_state istate ;
  struct cache_entry *ce ;
  struct stat st ;
  int flag ;
  void *tmp ;
  int i ;
  void *tmp___0 ;
  int i___0 ;

  {
#line 306
  tmp = calloc((size_t )argc, sizeof(istate.cache));
#line 306
  istate.cache = (struct cache_entry **)tmp;
#line 308
  i = 0;
#line 308
  while (i < argc) {
#line 310
    tmp___0 = malloc(sizeof(struct cache_entry ));
#line 310
    ce = (struct cache_entry *)tmp___0;
#line 311
    set_index_entry(& istate, i, ce);
#line 308
    i ++;
  }
#line 315
  i___0 = 0;
#line 315
  while (i___0 < argc) {
#line 316
    free((void *)*(istate.cache + i___0));
#line 315
    i___0 ++;
  }
#line 318
  free((void *)istate.cache);
#line 321
  add_to_index(& istate, "path", & st, flag);
#line 323
  free_name_hash(& istate);
#line 324
  return (0);
}
}
