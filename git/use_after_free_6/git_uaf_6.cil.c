/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

#line 216 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h"
typedef unsigned long size_t;
#line 66 "git_uaf_6.c"
struct stat;
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 161 "../git.h"
extern int ( /* missing proto */  memcpy)() ;
#line 174
extern int ( /* missing proto */  strdup)() ;
#line 27 "git_uaf_6.c"
extern int ( /* missing proto */  strlen)() ;
#line 29
extern int ( /* missing proto */  is_dir_sep)() ;
#line 33
extern int ( /* missing proto */  xmemdupz)() ;
#line 35
extern int ( /* missing proto */  basename)() ;
#line 18 "git_uaf_6.c"
static char const   **internal_copy_pathspec(char const   *prefix , char const   **pathspec ,
                                             int count , unsigned int flags ) 
{ 
  int i ;
  char const   **result ;
  void *tmp ;
  int length ;
  int tmp___0 ;
  int to_copy ;
  int tmp___1 ;
  char *it ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 23
  tmp = malloc((unsigned long )(count + 1) * sizeof(char const   *));
#line 23
  result = (char const   **)tmp;
#line 24
  memcpy(result, pathspec, (unsigned long )count * sizeof(char const   *));
#line 25
  *(result + count) = (char const   *)((void *)0);
#line 26
  i = 0;
#line 26
  while (i < count) {
#line 27
    tmp___0 = strlen(*(result + i));
#line 27
    length = tmp___0;
#line 28
    to_copy = length;
#line 29
    while (1) {
#line 29
      if (! (flags & 2U)) {
#line 29
        if (to_copy > 0) {
#line 29
          tmp___1 = is_dir_sep((int const   )*(*(result + i) + (to_copy - 1)));
#line 29
          if (! tmp___1) {
#line 29
            break;
          }
        } else {
#line 29
          break;
        }
      } else {
#line 29
        break;
      }
#line 31
      to_copy --;
    }
#line 32
    if (to_copy != length) {
#line 32
      goto _L;
    } else
#line 32
    if (flags & 1U) {
      _L: /* CIL Label */ 
#line 33
      tmp___2 = xmemdupz(*(result + i), to_copy);
#line 33
      it = (char *)tmp___2;
#line 34
      if (flags & 1U) {
#line 35
        tmp___3 = basename(it);
#line 35
        tmp___4 = strdup(tmp___3);
#line 35
        *(result + i) = (char const   *)tmp___4;
#line 36
        free((void *)it);
      } else {
#line 38
        *(result + i) = (char const   *)it;
      }
    }
#line 26
    i ++;
  }
#line 41
  return (result);
}
}
#line 44 "git_uaf_6.c"
static char const   *add_slash(char const   *path ) 
{ 
  int len ;
  int tmp ;
  char *with_slash ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 46
  tmp = strlen(path);
#line 46
  len = tmp;
#line 47
  if ((int const   )*(path + (len - 1)) != 47) {
#line 48
    tmp___0 = malloc((size_t )(len + 2));
#line 48
    with_slash = (char *)tmp___0;
#line 49
    memcpy(with_slash, path, len);
#line 50
    tmp___1 = len;
#line 50
    len ++;
#line 50
    *(with_slash + tmp___1) = (char )'/';
#line 51
    *(with_slash + len) = (char)0;
#line 52
    return ((char const   *)with_slash);
  }
#line 54
  return (path);
}
}
#line 77
extern int ( /* missing proto */  _)() ;
#line 81
extern int ( /* missing proto */  cache_name_pos)() ;
#line 60 "git_uaf_6.c"
int main(int argc , char const   **argv ) 
{ 
  char *prefix ;
  int i ;
  int verbose ;
  int show_only ;
  int force ;
  int ignore_errors ;
  char const   **source ;
  char const   *src ;
  int length ;
  int src_is_dir ;
  char const   *bad ;
  int tmp ;
  int first ;
  int tmp___0 ;
  char const   *src_w_slash ;
  char const   *tmp___1 ;
  int last ;
  int len_w_slash ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 63
  i = 0;
#line 64
  verbose = 0;
#line 64
  show_only = 0;
#line 64
  force = 0;
#line 64
  ignore_errors = 0;
#line 68
  source = internal_copy_pathspec((char const   *)prefix, argv, argc, 0U);
#line 71
  i = 0;
#line 71
  while (i < argc) {
#line 72
    src = *(source + i);
#line 74
    bad = (char const   *)((void *)0);
#line 76
    if (show_only) {
#line 77
      tmp = _("Checking rename of \'%s\'");
#line 77
      printf((char const   * __restrict  )tmp, src);
    }
#line 79
    length = strlen(src);
#line 80
    if (src_is_dir) {
#line 81
      tmp___0 = cache_name_pos(src, length);
#line 81
      first = tmp___0;
#line 82
      tmp___1 = add_slash(src);
#line 82
      src_w_slash = tmp___1;
#line 83
      len_w_slash = length + 1;
#line 86
      first = cache_name_pos(src_w_slash, len_w_slash);
#line 87
      if (first >= 0) {
#line 88
        tmp___2 = _("Huh? %s is in index?");
#line 88
        printf((char const   * __restrict  )tmp___2, src_w_slash);
#line 88
        exit(1);
      }
#line 91
      first = -1 - first;
#line 93
      free((void *)((char *)src_w_slash));
#line 95
      if (last - first < 1) {
#line 96
        tmp___3 = _("source directory is empty");
#line 96
        bad = (char const   *)tmp___3;
      }
#line 97
      argc += last - first;
    } else {
#line 99
      tmp___5 = cache_name_pos(src, length);
#line 99
      if (tmp___5 < 0) {
#line 100
        tmp___4 = _("not under version control");
#line 100
        bad = (char const   *)tmp___4;
      }
    }
#line 102
    if (bad) {
#line 103
      if (! ignore_errors) {
#line 104
        tmp___6 = _("source=%s");
#line 104
        printf((char const   * __restrict  )tmp___6, src);
#line 104
        exit(1);
      }
    }
#line 71
    i ++;
  }
#line 110
  return (0);
}
}
