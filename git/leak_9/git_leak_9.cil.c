/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

#line 216 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h"
typedef unsigned long size_t;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 177 "../git.h"
struct ref_cache {

};
#line 178 "../git.h"
struct ref_store {

};
#line 180 "../git.h"
struct packed_ref_cache {

};
#line 181 "../git.h"
struct lock_file {

};
#line 222 "../git.h"
struct string_list_item {
   char *string ;
   void *util ;
};
#line 227 "../git.h"
struct string_list {
   struct string_list_item *items ;
   unsigned int nr ;
   unsigned int alloc ;
   unsigned int strdup_strings : 1 ;
   int (*cmp)(char const   * , char const   * ) ;
};
#line 241 "../git.h"
struct strbuf {
   size_t alloc ;
   size_t len ;
   char *buf ;
};
#line 255 "../git.h"
struct object_id {
   unsigned char hash[20] ;
};
#line 14 "git_leak_9.c"
struct ref_lock {
   char *ref_name ;
   struct lock_file *lk ;
   struct object_id old_oid ;
};
#line 20 "git_leak_9.c"
struct files_ref_store {
   struct ref_store base ;
   unsigned int store_flags ;
   char *gitdir ;
   char *gitcommondir ;
   char *packed_refs_path ;
   struct ref_cache *loose ;
   struct packed_ref_cache *packed ;
   struct lock_file packed_refs_lock ;
};
#line 38 "git_leak_9.c"
struct ref_update {
   struct object_id new_oid ;
   struct object_id old_oid ;
   unsigned int flags ;
   void *backend_data ;
   unsigned int type ;
   char *msg ;
   struct ref_update *parent_update ;
   char refname[] ;
};
#line 78
enum ref_transaction_state {
    REF_TRANSACTION_OPEN = 0,
    REF_TRANSACTION_PREPARED = 1,
    REF_TRANSACTION_CLOSED = 2
} ;
#line 89 "git_leak_9.c"
struct ref_transaction {
   struct ref_store *ref_store ;
   struct ref_update **updates ;
   size_t alloc ;
   size_t nr ;
   enum ref_transaction_state state ;
};
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 468 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 262 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) lstat)(char const   * __restrict  __file ,
                                                                                              struct stat * __restrict  __buf ) ;
#line 161 "../git.h"
extern int ( /* missing proto */  memcpy)() ;
#line 161
extern int ( /* missing proto */  st_mult)() ;
#line 174
extern int ( /* missing proto */  strdup)() ;
#line 386
extern char strbuf_slopbuf[] ;
#line 405 "../git.h"
__inline static void strbuf_swap(struct strbuf *a , struct strbuf *b ) 
{ 
  void *_swap_a_ptr ;
  void *_swap_b_ptr ;
  unsigned char _swap_buffer[sizeof(*a)] ;

  {
#line 407
  while (1) {
#line 407
    _swap_a_ptr = (void *)a;
#line 407
    _swap_b_ptr = (void *)b;
#line 407
    memcpy(_swap_buffer, _swap_a_ptr, sizeof(*a));
#line 407
    memcpy(_swap_a_ptr, _swap_b_ptr, sizeof(*a) + (sizeof(char [1]) - 1UL));
#line 407
    memcpy(_swap_b_ptr, _swap_buffer, sizeof(*a));
#line 407
    break;
  }
#line 408
  return;
}
}
#line 410 "../git.h"
void *xrealloc(void *ptr , size_t size ) 
{ 
  void *ret ;

  {
#line 414
  ret = realloc(ptr, size);
#line 415
  if (! ret) {
#line 415
    if (! size) {
#line 416
      ret = realloc(ptr, (size_t )1);
    }
  }
#line 417
  if (! ret) {
#line 418
    ret = realloc(ptr, size);
#line 419
    if (! ret) {
#line 419
      if (! size) {
#line 420
        ret = realloc(ptr, (size_t )1);
      }
    }
#line 421
    if (! ret) {
#line 422
      printf((char const   * __restrict  )"Out of memory, realloc failed%s", "");
#line 422
      exit(1);
    }
  }
#line 424
  return (ret);
}
}
#line 102 "git_leak_9.c"
extern int ( /* missing proto */  unsigned_add_overflows)() ;
#line 107
extern int ( /* missing proto */  alloc_nr)() ;
#line 99 "git_leak_9.c"
void strbuf_grow(struct strbuf *sb , size_t extra ) 
{ 
  int new_buf ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;

  {
#line 101
  new_buf = ! sb->alloc;
#line 102
  tmp = unsigned_add_overflows(extra, 1);
#line 102
  if (tmp) {
#line 104
    printf((char const   * __restrict  )"you want to use way too much memory%s", "");
#line 104
    exit(1);
  } else {
#line 102
    tmp___0 = unsigned_add_overflows(sb->len, extra + 1UL);
#line 102
    if (tmp___0) {
#line 104
      printf((char const   * __restrict  )"you want to use way too much memory%s",
             "");
#line 104
      exit(1);
    }
  }
#line 105
  if (new_buf) {
#line 106
    sb->buf = (char *)((void *)0);
  }
#line 107
  while (1) {
#line 107
    if ((sb->len + extra) + 1UL > sb->alloc) {
#line 107
      tmp___2 = alloc_nr(sb->alloc);
#line 107
      if ((size_t )tmp___2 < (sb->len + extra) + 1UL) {
#line 107
        sb->alloc = (sb->len + extra) + 1UL;
      } else {
#line 107
        tmp___1 = alloc_nr(sb->alloc);
#line 107
        sb->alloc = (size_t )tmp___1;
      }
#line 107
      tmp___3 = st_mult(sizeof(*(sb->buf)), sb->alloc);
#line 107
      tmp___4 = xrealloc((void *)sb->buf, (size_t )tmp___3);
#line 107
      sb->buf = (char *)tmp___4;
    }
#line 107
    break;
  }
#line 108
  if (new_buf) {
#line 109
    *(sb->buf + 0) = (char )'\000';
  }
#line 110
  return;
}
}
#line 117
extern int ( /* missing proto */  strbuf_init)() ;
#line 113 "git_leak_9.c"
void strbuf_release(struct strbuf *sb ) 
{ 


  {
#line 115
  if (sb->alloc) {
#line 116
    free((void *)sb->buf);
#line 117
    strbuf_init(sb, 0);
  }
#line 119
  return;
}
}
#line 132
extern int ( /* missing proto */  readlink)() ;
#line 137
extern int ( /* missing proto */  strbuf_setlen)() ;
#line 121 "git_leak_9.c"
int strbuf_readlink(struct strbuf *sb , char const   *path , size_t hint ) 
{ 
  size_t oldalloc ;
  int len ;
  int *tmp ;

  {
#line 123
  oldalloc = sb->alloc;
#line 125
  if (hint < 32UL) {
#line 126
    hint = (size_t )32;
  }
#line 128
  while (hint < 8192UL) {
#line 131
    strbuf_grow(sb, hint);
#line 132
    len = readlink(path, sb->buf, hint);
#line 133
    if (len < 0) {
#line 134
      tmp = __errno_location();
#line 134
      if (*tmp != 34) {
#line 135
        break;
      }
    } else
#line 136
    if ((size_t )len < hint) {
#line 137
      strbuf_setlen(sb, len);
#line 138
      return (0);
    }
#line 142
    hint *= 2UL;
  }
#line 144
  if (oldalloc == 0UL) {
#line 145
    strbuf_release(sb);
  }
#line 146
  return (-1);
}
}
#line 153
extern int ( /* missing proto */  files_downcast)() ;
#line 165
extern int ( /* missing proto */  strbuf_reset)() ;
#line 167
extern int ( /* missing proto */  files_ref_path)() ;
#line 191
extern int ( /* missing proto */  resolve_packed_ref)() ;
#line 208
extern int ( /* missing proto */  starts_with)() ;
#line 208
extern int ( /* missing proto */  check_refname_format)() ;
#line 219
extern int ( /* missing proto */  close)() ;
#line 217
extern int ( /* missing proto */  strbuf_read)() ;
#line 223
extern int ( /* missing proto */  strbuf_rtrim)() ;
#line 227
extern int ( /* missing proto */  isspace)() ;
#line 231
extern int ( /* missing proto */  strbuf_addstr)() ;
#line 241
extern int ( /* missing proto */  get_sha1_hex)() ;
#line 149 "git_leak_9.c"
static int files_read_raw_ref(struct ref_store *ref_store , char const   *refname ,
                              unsigned char *sha1 , struct strbuf *referent , unsigned int *type ) 
{ 
  struct files_ref_store *refs ;
  int tmp ;
  struct strbuf sb_contents ;
  struct strbuf sb_path ;
  char const   *path ;
  char const   *buf ;
  int fd ;
  int ret ;
  int save_errno ;
  int remaining_retries ;
  struct stat st ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int save_errno___0 ;
  int *tmp___10 ;
  int *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int *tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int *tmp___18 ;
  int *tmp___19 ;

  {
#line 153
  tmp = files_downcast(ref_store, 1, "read_raw_ref");
#line 153
  refs = (struct files_ref_store *)tmp;
#line 155
  sb_contents.alloc = (size_t )0;
#line 155
  sb_contents.len = (size_t )0;
#line 155
  sb_contents.buf = strbuf_slopbuf;
#line 156
  sb_path.alloc = (size_t )0;
#line 156
  sb_path.len = (size_t )0;
#line 156
  sb_path.buf = strbuf_slopbuf;
#line 160
  ret = -1;
#line 162
  remaining_retries = 3;
#line 164
  *type = 0U;
#line 165
  strbuf_reset(& sb_path);
#line 167
  files_ref_path(refs, & sb_path, refname);
#line 169
  path = (char const   *)sb_path.buf;
  stat_ref: 
#line 185
  tmp___0 = remaining_retries;
#line 185
  remaining_retries --;
#line 185
  if (tmp___0 <= 0) {
#line 186
    goto out;
  }
#line 188
  tmp___4 = lstat((char const   * __restrict  )path, (struct stat * __restrict  )(& st));
#line 188
  if (tmp___4 < 0) {
#line 189
    tmp___1 = __errno_location();
#line 189
    if (*tmp___1 != 2) {
#line 190
      goto out;
    }
#line 191
    tmp___3 = resolve_packed_ref(refs, refname, sha1, type);
#line 191
    if (tmp___3) {
#line 192
      tmp___2 = __errno_location();
#line 192
      *tmp___2 = 2;
#line 193
      goto out;
    }
#line 195
    ret = 0;
#line 196
    goto out;
  }
#line 200
  strbuf_reset(& sb_contents);
#line 201
  tmp___7 = strbuf_readlink(& sb_contents, path, (size_t )0);
#line 201
  if (tmp___7 < 0) {
#line 202
    tmp___5 = __errno_location();
#line 202
    if (*tmp___5 == 2) {
#line 204
      goto stat_ref;
    } else {
#line 202
      tmp___6 = __errno_location();
#line 202
      if (*tmp___6 == 22) {
#line 204
        goto stat_ref;
      } else {
#line 206
        goto out;
      }
    }
  }
#line 208
  tmp___8 = starts_with(sb_contents.buf, "refs/");
#line 208
  if (tmp___8) {
#line 208
    tmp___9 = check_refname_format(sb_contents.buf, 0);
#line 208
    if (! tmp___9) {
#line 210
      strbuf_swap(& sb_contents, referent);
#line 211
      *type |= 1U;
#line 212
      ret = 0;
#line 213
      goto out;
    }
  }
#line 216
  strbuf_reset(& sb_contents);
#line 217
  tmp___12 = strbuf_read(& sb_contents, fd, 256);
#line 217
  if (tmp___12 < 0) {
#line 218
    tmp___10 = __errno_location();
#line 218
    save_errno___0 = *tmp___10;
#line 219
    close(fd);
#line 220
    tmp___11 = __errno_location();
#line 220
    *tmp___11 = save_errno___0;
#line 221
    goto out;
  }
#line 223
  strbuf_rtrim(& sb_contents);
#line 224
  buf = (char const   *)sb_contents.buf;
#line 225
  tmp___14 = starts_with(buf, "ref:");
#line 225
  if (tmp___14) {
#line 226
    buf += 4;
#line 227
    while (1) {
#line 227
      tmp___13 = isspace((int const   )*buf);
#line 227
      if (! tmp___13) {
#line 227
        break;
      }
#line 228
      buf ++;
    }
#line 230
    strbuf_reset(referent);
#line 231
    strbuf_addstr(referent, buf);
#line 232
    *type |= 1U;
#line 233
    ret = 0;
#line 234
    goto out;
  }
#line 241
  tmp___16 = get_sha1_hex(buf, sha1);
#line 241
  if (tmp___16) {
#line 243
    *type |= 4U;
#line 244
    tmp___15 = __errno_location();
#line 244
    *tmp___15 = 22;
#line 245
    goto out;
  } else
#line 241
  if ((int const   )*(buf + 40) != 0) {
#line 241
    tmp___17 = isspace((int const   )*(buf + 40));
#line 241
    if (! tmp___17) {
#line 243
      *type |= 4U;
#line 244
      tmp___15 = __errno_location();
#line 244
      *tmp___15 = 22;
#line 245
      goto out;
    }
  }
#line 248
  ret = 0;
  out: 
#line 251
  tmp___18 = __errno_location();
#line 251
  save_errno = *tmp___18;
#line 252
  strbuf_release(& sb_path);
#line 253
  strbuf_release(& sb_contents);
#line 254
  tmp___19 = __errno_location();
#line 254
  *tmp___19 = save_errno;
#line 255
  return (ret);
}
}
#line 289
extern int ( /* missing proto */  strbuf_addf)() ;
#line 300
extern int ( /* missing proto */  unlock_ref)() ;
#line 258 "git_leak_9.c"
static int lock_raw_ref(struct files_ref_store *refs , char const   *refname , int mustexist ,
                        struct string_list  const  *extras , struct string_list  const  *skip ,
                        struct ref_lock **lock_p , struct strbuf *referent , unsigned int *type ,
                        struct strbuf *err ) 
{ 
  struct ref_lock *lock ;
  struct strbuf ref_file ;
  int attempts_remaining ;
  int ret ;
  void *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
#line 268
  ref_file.alloc = (size_t )0;
#line 268
  ref_file.len = (size_t )0;
#line 268
  ref_file.buf = strbuf_slopbuf;
#line 269
  attempts_remaining = 3;
#line 270
  ret = -2;
#line 272
  *type = 0U;
#line 274
  tmp = calloc((size_t )1, sizeof(*lock));
#line 274
  lock = (struct ref_lock *)tmp;
#line 274
  *lock_p = lock;
#line 276
  tmp___0 = strdup(refname);
#line 276
  lock->ref_name = (char *)tmp___0;
#line 277
  files_ref_path(refs, & ref_file, refname);
#line 284
  tmp___2 = files_read_raw_ref(& refs->base, refname, lock->old_oid.hash, referent,
                               type);
#line 284
  if (tmp___2) {
#line 286
    tmp___1 = __errno_location();
#line 286
    if (*tmp___1 == 2) {
#line 287
      if (mustexist) {
#line 289
        strbuf_addf(err, "unable to resolve reference \'%s\'", refname);
#line 291
        goto error_return;
      }
    }
  }
#line 296
  ret = 0;
#line 297
  goto out;
  error_return: 
#line 300
  unlock_ref(lock);
#line 301
  *lock_p = (struct ref_lock *)((void *)0);
  out: 
#line 304
  strbuf_release(& ref_file);
#line 305
  return (ret);
}
}
#line 335
extern int ( /* missing proto */  split_head_update)() ;
#line 348
extern int ( /* missing proto */  strbuf_detach)() ;
#line 349
extern int ( /* missing proto */  original_update_refname)() ;
#line 373
extern int ( /* missing proto */  check_old_oid)() ;
#line 364
extern int ( /* missing proto */  refs_read_ref_full)() ;
#line 384
extern int ( /* missing proto */  split_symref_update)() ;
#line 407
extern int ( /* missing proto */  write_ref_to_lockfile)() ;
#line 401
extern int ( /* missing proto */  oidcmp)() ;
#line 427
extern int ( /* missing proto */  close_ref)() ;
#line 322 "git_leak_9.c"
static int lock_ref_for_update(struct files_ref_store *refs , struct ref_update *update ,
                               struct ref_transaction *transaction , char const   *head_ref ,
                               struct string_list *affected_refnames , struct strbuf *err ) 
{ 
  struct strbuf referent ;
  int mustexist ;
  int ret ;
  struct ref_lock *lock ;
  char *reason ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *write_err ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 329
  referent.alloc = (size_t )0;
#line 329
  referent.len = (size_t )0;
#line 329
  referent.buf = strbuf_slopbuf;
#line 334
  if (head_ref) {
#line 335
    ret = split_head_update(update, transaction, head_ref, affected_refnames, err);
#line 337
    if (ret) {
#line 338
      return (ret);
    }
  }
#line 341
  ret = lock_raw_ref(refs, update->refname, mustexist, (struct string_list  const  *)affected_refnames,
                     (struct string_list  const  *)((void *)0), & lock, & referent,
                     & update->type, err);
#line 345
  if (ret) {
#line 348
    tmp = strbuf_detach(err, (void *)0);
#line 348
    reason = (char *)tmp;
#line 349
    tmp___0 = original_update_refname(update);
#line 349
    strbuf_addf(err, "cannot lock ref \'%s\': %s", tmp___0, reason);
#line 351
    free((void *)reason);
#line 352
    return (ret);
  }
#line 355
  update->backend_data = (void *)lock;
#line 357
  if (update->type & 1U) {
#line 358
    if (update->flags & 1U) {
#line 364
      tmp___3 = refs_read_ref_full(& refs->base, referent.buf, 0, lock->old_oid.hash,
                                   (void *)0);
#line 364
      if (tmp___3) {
#line 367
        if (update->flags & 16U) {
#line 368
          tmp___1 = original_update_refname(update);
#line 368
          strbuf_addf(err, "cannot lock ref \'%s\': error reading reference", tmp___1);
#line 371
          return (-1);
        }
      } else {
#line 373
        tmp___2 = check_old_oid(update, & lock->old_oid, err);
#line 373
        if (tmp___2) {
#line 374
          return (-2);
        }
      }
    } else {
#line 384
      ret = split_symref_update(refs, update, referent.buf, transaction, affected_refnames,
                                err);
#line 387
      if (ret) {
#line 388
        return (ret);
      }
    }
  } else {
#line 393
    tmp___4 = check_old_oid(update, & lock->old_oid, err);
#line 393
    if (tmp___4) {
#line 394
      return (-2);
    }
  }
#line 398
  if (update->flags & 8U) {
#line 398
    if (! (update->flags & 2U)) {
#line 398
      if (! (update->flags & 128U)) {
#line 401
        if (! (update->type & 1U)) {
#line 401
          tmp___7 = oidcmp(& lock->old_oid, & update->new_oid);
#line 401
          if (tmp___7) {
#line 401
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
#line 407
          tmp___6 = write_ref_to_lockfile(lock, & update->new_oid, err);
#line 407
          if (tmp___6) {
#line 409
            tmp___5 = strbuf_detach(err, (void *)0);
#line 409
            write_err = (char *)tmp___5;
#line 415
            update->backend_data = (void *)0;
#line 416
            return (-2);
          } else {
#line 418
            update->flags |= 32U;
          }
        }
      }
    }
  }
#line 421
  if (! (update->flags & 32U)) {
#line 427
    tmp___8 = close_ref(lock);
#line 427
    if (tmp___8) {
#line 428
      return (-2);
    }
  }
#line 431
  return (0);
}
}
#line 434 "git_leak_9.c"
int main(void) 
{ 
  struct files_ref_store refs ;
  struct ref_update update ;
  struct ref_transaction transaction ;
  char *head_ref ;
  struct string_list affected_refnames ;
  struct strbuf err ;

  {
#line 442
  lock_ref_for_update(& refs, & update, & transaction, (char const   *)head_ref, & affected_refnames,
                      & err);
#line 443
  return (0);
}
}
