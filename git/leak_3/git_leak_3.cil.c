/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

#line 216 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h"
typedef unsigned long size_t;
#line 218 "../git.h"
typedef unsigned long long uintmax_t;
#line 219 "../git.h"
typedef uintmax_t timestamp_t;
#line 255 "../git.h"
struct object_id {
   unsigned char hash[20] ;
};
#line 267 "../git.h"
struct object {
   unsigned int parsed : 1 ;
   unsigned int type : 3 ;
   unsigned int flags : 27 ;
   struct object_id oid ;
};
#line 274 "../git.h"
struct tree {
   struct object object ;
   void *buffer ;
   unsigned long size ;
};
#line 307
struct commit;
#line 307 "../git.h"
struct commit_list {
   struct commit *item ;
   struct commit_list *next ;
};
#line 312 "../git.h"
struct commit {
   struct object object ;
   void *util ;
   unsigned int index ;
   timestamp_t date ;
   struct commit_list *parents ;
   struct tree *tree ;
};
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 19 "git_leak_3.c"
extern int ( /* missing proto */  show_list)() ;
#line 12 "git_leak_3.c"
void find_bisection(struct commit_list **commit_list , int *reaches , int *all , int find_all ) 
{ 
  int nr ;
  int on_list ;
  struct commit_list *list ;
  struct commit_list *p ;
  struct commit_list *next ;
  struct commit_list *last ;
  unsigned int flags ;

  {
#line 19
  show_list("bisection 2 entry", 0, 0, *commit_list);
#line 25
  on_list = 0;
#line 25
  nr = on_list;
#line 25
  last = (struct commit_list *)((void *)0);
#line 25
  p = *commit_list;
#line 25
  while (p) {
#line 28
    flags = (p->item)->object.flags;
#line 30
    next = p->next;
#line 31
    if (flags & (1U << 1)) {
#line 33
      goto __Cont;
    }
#line 35
    p->next = last;
#line 36
    last = p;
#line 37
    if (! (flags & (1U << 2))) {
#line 38
      nr ++;
    }
#line 39
    on_list ++;
    __Cont: /* CIL Label */ 
#line 25
    p = next;
  }
#line 41
  list = last;
#line 42
  show_list("bisection 2 sorted", 0, nr, list);
#line 44
  *all = nr;
#line 46
  *commit_list = list;
#line 47
  return;
}
}
#line 49 "git_leak_3.c"
struct commit_list *commit_list_insert(struct commit *item , struct commit_list **list_p ) 
{ 
  struct commit_list *new_list ;
  void *tmp ;

  {
#line 51
  tmp = malloc(sizeof(struct commit_list ));
#line 51
  new_list = (struct commit_list *)tmp;
#line 52
  new_list->item = item;
#line 53
  new_list->next = *list_p;
#line 54
  *list_p = new_list;
#line 55
  return (new_list);
}
}
#line 58 "git_leak_3.c"
struct commit *pop_commit(struct commit_list **stack ) 
{ 
  struct commit_list *top ;
  struct commit *item ;
  struct commit *tmp ;

  {
#line 60
  top = *stack;
#line 61
  if (top) {
#line 61
    tmp = top->item;
  } else {
#line 61
    tmp = (struct commit *)((void *)0);
  }
#line 61
  item = tmp;
#line 63
  if (top) {
#line 64
    *stack = top->next;
#line 65
    free((void *)top);
  }
#line 67
  return (item);
}
}
#line 71 "git_leak_3.c"
void free_commit_list(struct commit_list *list ) 
{ 


  {
#line 73
  while (list) {
#line 74
    pop_commit(& list);
  }
#line 75
  return;
}
}
#line 77 "git_leak_3.c"
int main(void) 
{ 
  struct commit_list *list ;
  int reaches ;
  int all ;
  int find_all ;
  int i ;

  {
#line 81
  i = 0;
#line 81
  while (i < 10) {
#line 83
    commit_list_insert((struct commit *)((void *)0), & list);
#line 81
    i ++;
  }
#line 85
  find_bisection(& list, & reaches, & all, find_all);
#line 87
  free_commit_list(list);
#line 88
  return (0);
}
}
