/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

#line 216 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 144 "/usr/include/libio.h"
struct _IO_FILE;
#line 150 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 156 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 241 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 85 "../stdio.h"
typedef int pid_t___0;
#line 241 "../git.h"
struct strbuf {
   size_t alloc ;
   size_t len ;
   char *buf ;
};
#line 29 "git_uaf_2.c"
enum child_state {
    GIT_CP_FREE = 0,
    GIT_CP_WORKING = 1,
    GIT_CP_WAIT_CLEANUP = 2
} ;
#line 35 "git_uaf_2.c"
struct pollfd {
   int fd ;
   short events ;
   short revents ;
};
#line 42 "git_uaf_2.c"
struct argv_array {
   char const   **argv ;
   int argc ;
   int alloc ;
};
#line 48 "git_uaf_2.c"
struct child_process {
   char const   **argv ;
   struct argv_array args ;
   struct argv_array env_array ;
   pid_t___0 pid ;
   int in ;
   int out ;
   int err ;
   char const   *dir ;
   char const   * const  *env ;
   unsigned int no_stdin : 1 ;
   unsigned int no_stdout : 1 ;
   unsigned int no_stderr : 1 ;
   unsigned int git_cmd : 1 ;
   unsigned int silent_exec_failure : 1 ;
   unsigned int stdout_to_stderr : 1 ;
   unsigned int use_shell : 1 ;
   unsigned int clean_on_exit : 1 ;
};
#line 102 "git_uaf_2.c"
struct __anonstruct_children_26 {
   enum child_state state ;
   struct child_process process ;
   struct strbuf err ;
   void *data ;
};
#line 102 "git_uaf_2.c"
struct parallel_processes {
   void *data ;
   int max_processes ;
   int nr_processes ;
   int (*get_next_task)(struct child_process *cp , struct strbuf *err , void *pp_cb ,
                        void **pp_task_cb ) ;
   int (*start_failure)(struct child_process *cp , struct strbuf *err , void *pp_cb ,
                        void *pp_task_cb ) ;
   int (*task_finished)(int result , struct child_process *cp , struct strbuf *err ,
                        void *pp_cb , void *pp_task_cb ) ;
   struct __anonstruct_children_26 *children ;
   struct pollfd *pfd ;
   unsigned int shutdown : 1 ;
   int output_owner ;
   struct strbuf buffered_output ;
};
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 27 "git_uaf_2.c"
extern char const   *empty_argv[] ;
#line 138
extern int ( /* missing proto */  strbuf_addstr)() ;
#line 140
extern int ( /* missing proto */  strbuf_addf)() ;
#line 131 "git_uaf_2.c"
static int default_start_failure(struct child_process *cp , struct strbuf *err , void *pp_cb ,
                                 void *pp_task_cb ) 
{ 
  int i ;

  {
#line 138
  strbuf_addstr(err, "Starting a child failed:");
#line 139
  i = 0;
#line 139
  while (*(cp->argv + i)) {
#line 140
    strbuf_addf(err, " %s", *(cp->argv + i));
#line 139
    i ++;
  }
#line 142
  return (0);
}
}
#line 145 "git_uaf_2.c"
static int default_task_finished(int result , struct child_process *cp , struct strbuf *err ,
                                 void *pp_cb , void *pp_task_cb ) 
{ 
  int i ;

  {
#line 153
  if (! result) {
#line 154
    return (0);
  }
#line 156
  strbuf_addf(err, "A child failed with return code %d:", result);
#line 157
  i = 0;
#line 157
  while (*(cp->argv + i)) {
#line 158
    strbuf_addf(err, " %s", *(cp->argv + i));
#line 157
    i ++;
  }
#line 160
  return (0);
}
}
#line 163 "git_uaf_2.c"
static struct parallel_processes *pp_for_signal  ;
#line 174
extern int ( /* missing proto */  online_cpus)() ;
#line 178
extern int ( /* missing proto */  trace_printf)() ;
#line 193
extern int ( /* missing proto */  strbuf_init)() ;
#line 197
extern int ( /* missing proto */  child_process_init)() ;
#line 164 "git_uaf_2.c"
static void pp_init(struct parallel_processes *pp , int n , int (*get_next_task)(struct child_process *cp ,
                                                                                 struct strbuf *err ,
                                                                                 void *pp_cb ,
                                                                                 void **pp_task_cb ) ,
                    int (*start_failure)(struct child_process *cp , struct strbuf *err ,
                                         void *pp_cb , void *pp_task_cb ) , int (*task_finished)(int result ,
                                                                                                 struct child_process *cp ,
                                                                                                 struct strbuf *err ,
                                                                                                 void *pp_cb ,
                                                                                                 void *pp_task_cb ) ,
                    void *data ) 
{ 
  int i ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 173
  if (n < 1) {
#line 174
    n = online_cpus();
  }
#line 176
  pp->max_processes = n;
#line 178
  trace_printf("run_processes_parallel: preparing to run up to %d tasks", n);
#line 180
  pp->data = data;
#line 181
  if (! get_next_task) {
#line 182
    printf((char const   * __restrict  )"BUG: you need to specify a get_next_task function%s",
           "");
#line 182
    exit(1);
  }
#line 183
  pp->get_next_task = get_next_task;
#line 185
  if (start_failure) {
#line 185
    pp->start_failure = start_failure;
  } else {
#line 185
    pp->start_failure = & default_start_failure;
  }
#line 186
  if (task_finished) {
#line 186
    pp->task_finished = task_finished;
  } else {
#line 186
    pp->task_finished = & default_task_finished;
  }
#line 188
  pp->nr_processes = 0;
#line 189
  pp->output_owner = 0;
#line 190
  pp->shutdown = 0U;
#line 191
  tmp = calloc((size_t )n, sizeof(*(pp->children)));
#line 191
  pp->children = (struct __anonstruct_children_26 *)tmp;
#line 192
  tmp___0 = calloc((size_t )n, sizeof(*(pp->pfd)));
#line 192
  pp->pfd = (struct pollfd *)tmp___0;
#line 193
  strbuf_init(& pp->buffered_output, 0);
#line 195
  i = 0;
#line 195
  while (i < n) {
#line 196
    strbuf_init(& (pp->children + i)->err, 0);
#line 197
    child_process_init(& (pp->children + i)->process);
#line 198
    (pp->pfd + i)->events = (short)17;
#line 199
    (pp->pfd + i)->fd = -1;
#line 195
    i ++;
  }
#line 202
  pp_for_signal = pp;
#line 203
  return;
}
}
#line 227
extern int ( /* missing proto */  strbuf_addbuf)() ;
#line 228
extern int ( /* missing proto */  strbuf_reset)() ;
#line 235
extern int ( /* missing proto */  start_command)() ;
#line 212 "git_uaf_2.c"
static int pp_start_one(struct parallel_processes *pp ) 
{ 
  int i ;
  int code ;
  int tmp ;

  {
#line 216
  i = 0;
#line 216
  while (i < pp->max_processes) {
#line 217
    if ((unsigned int )(pp->children + i)->state == 0U) {
#line 218
      break;
    }
#line 216
    i ++;
  }
#line 219
  if (i == pp->max_processes) {
#line 220
    printf((char const   * __restrict  )"BUG: bookkeeping is hard%s", "");
#line 220
    exit(1);
  }
#line 222
  code = (*(pp->get_next_task))(& (pp->children + i)->process, & (pp->children + i)->err,
                                pp->data, & (pp->children + i)->data);
#line 226
  if (! code) {
#line 227
    strbuf_addbuf(& pp->buffered_output, & (pp->children + i)->err);
#line 228
    strbuf_reset(& (pp->children + i)->err);
#line 229
    return (1);
  }
#line 231
  (pp->children + i)->process.err = -1;
#line 232
  (pp->children + i)->process.stdout_to_stderr = 1U;
#line 233
  (pp->children + i)->process.no_stdin = 1U;
#line 235
  tmp = start_command(& (pp->children + i)->process);
#line 235
  if (tmp) {
#line 236
    code = (*(pp->start_failure))(& (pp->children + i)->process, & (pp->children + i)->err,
                                  pp->data, (void *)(& (pp->children + i)->data));
#line 240
    strbuf_addbuf(& pp->buffered_output, & (pp->children + i)->err);
#line 241
    strbuf_reset(& (pp->children + i)->err);
#line 242
    if (code) {
#line 243
      pp->shutdown = 1U;
    }
#line 244
    return (code);
  }
#line 247
  (pp->nr_processes) ++;
#line 248
  (pp->children + i)->state = (enum child_state )1;
#line 249
  (pp->pfd + i)->fd = (pp->children + i)->process.err;
#line 250
  return (0);
}
}
#line 259
extern int ( /* missing proto */  kill)() ;
#line 253 "git_uaf_2.c"
static void kill_children(struct parallel_processes *pp , int signo ) 
{ 
  int i ;
  int n ;

  {
#line 255
  n = pp->max_processes;
#line 257
  i = 0;
#line 257
  while (i < n) {
#line 258
    if ((unsigned int )(pp->children + i)->state == 1U) {
#line 259
      kill((pp->children + i)->process.pid, signo);
    }
#line 257
    i ++;
  }
#line 260
  return;
}
}
#line 275
int finish_command(struct child_process *cmd ) ;
#line 262 "git_uaf_2.c"
static int pp_collect_finished(struct parallel_processes *pp ) 
{ 
  int i ;
  int code ;
  int n ;
  int result ;

  {
#line 265
  n = pp->max_processes;
#line 266
  result = 0;
#line 268
  while (pp->nr_processes > 0) {
#line 269
    i = 0;
#line 269
    while (i < pp->max_processes) {
#line 270
      if ((unsigned int )(pp->children + i)->state == 2U) {
#line 271
        break;
      }
#line 269
      i ++;
    }
#line 272
    if (i == pp->max_processes) {
#line 273
      break;
    }
#line 275
    code = finish_command(& (pp->children + i)->process);
#line 277
    code = (*(pp->task_finished))(code, & (pp->children + i)->process, & (pp->children + i)->err,
                                  pp->data, (void *)(& (pp->children + i)->data));
#line 281
    if (code) {
#line 282
      result = code;
    }
#line 283
    if (code < 0) {
#line 284
      break;
    }
#line 286
    (pp->nr_processes) --;
#line 287
    (pp->children + i)->state = (enum child_state )0;
#line 288
    (pp->pfd + i)->fd = -1;
#line 289
    child_process_init(& (pp->children + i)->process);
#line 291
    if (i != pp->output_owner) {
#line 292
      strbuf_addbuf(& pp->buffered_output, & (pp->children + i)->err);
#line 293
      strbuf_reset(& (pp->children + i)->err);
    } else {
#line 295
      fputs((char const   * __restrict  )(pp->children + i)->err.buf, (FILE * __restrict  )stderr);
#line 296
      strbuf_reset(& (pp->children + i)->err);
#line 299
      fputs((char const   * __restrict  )pp->buffered_output.buf, (FILE * __restrict  )stderr);
#line 300
      strbuf_reset(& pp->buffered_output);
#line 310
      i = 0;
#line 310
      while (i < n) {
#line 311
        if ((unsigned int )(pp->children + (pp->output_owner + i) % n)->state == 1U) {
#line 312
          break;
        }
#line 310
        i ++;
      }
#line 313
      pp->output_owner = (pp->output_owner + i) % n;
    }
  }
#line 316
  return (result);
}
}
#line 321
extern int ( /* missing proto */  wait_or_whine)() ;
#line 322
void child_process_clear(struct child_process *child ) ;
#line 319 "git_uaf_2.c"
int finish_command(struct child_process *cmd ) 
{ 
  int ret ;
  int tmp ;

  {
#line 321
  tmp = wait_or_whine(cmd->pid, *(cmd->argv + 0), 0);
#line 321
  ret = tmp;
#line 322
  child_process_clear(cmd);
#line 323
  return (ret);
}
}
#line 328
extern int ( /* missing proto */  argv_array_clear)() ;
#line 326 "git_uaf_2.c"
void child_process_clear(struct child_process *child ) 
{ 


  {
#line 328
  argv_array_clear(& child->args);
#line 329
  argv_array_clear(& child->env_array);
#line 330
  return;
}
}
#line 361
extern int ( /* missing proto */  pp_buffer_stderr)() ;
#line 362
extern int ( /* missing proto */  pp_output)() ;
#line 371
extern int ( /* missing proto */  pp_cleanup)() ;
#line 333 "git_uaf_2.c"
int run_processes_parallel(int n , int (*get_next_task)(struct child_process *cp ,
                                                        struct strbuf *err , void *pp_cb ,
                                                        void **pp_task_cb ) , int (*start_failure)(struct child_process *cp ,
                                                                                                   struct strbuf *err ,
                                                                                                   void *pp_cb ,
                                                                                                   void *pp_task_cb ) ,
                           int (*task_finished)(int result , struct child_process *cp ,
                                                struct strbuf *err , void *pp_cb ,
                                                void *pp_task_cb ) , void *pp_cb ) 
{ 
  int i ;
  int code ;
  int output_timeout ;
  int spawn_cap ;
  struct parallel_processes pp ;

  {
#line 340
  output_timeout = 100;
#line 341
  spawn_cap = 4;
#line 344
  pp_init(& pp, n, get_next_task, start_failure, task_finished, pp_cb);
#line 345
  while (1) {
#line 346
    i = 0;
#line 346
    while (1) {
#line 346
      if (i < spawn_cap) {
#line 346
        if (! pp.shutdown) {
#line 346
          if (! (pp.nr_processes < pp.max_processes)) {
#line 346
            break;
          }
        } else {
#line 346
          break;
        }
      } else {
#line 346
        break;
      }
#line 350
      code = pp_start_one(& pp);
#line 351
      if (! code) {
#line 352
        goto __Cont;
      }
#line 353
      if (code < 0) {
#line 354
        pp.shutdown = 1U;
#line 355
        kill_children(& pp, - code);
      }
#line 357
      break;
      __Cont: /* CIL Label */ 
#line 346
      i ++;
    }
#line 359
    if (! pp.nr_processes) {
#line 360
      break;
    }
#line 361
    pp_buffer_stderr(& pp, output_timeout);
#line 362
    pp_output(& pp);
#line 363
    code = pp_collect_finished(& pp);
#line 364
    if (code) {
#line 365
      pp.shutdown = 1U;
#line 366
      if (code < 0) {
#line 367
        kill_children(& pp, - code);
      }
    }
  }
#line 371
  pp_cleanup(& pp);
#line 372
  return (0);
}
}
#line 375 "git_uaf_2.c"
static int number_callbacks  ;
#line 385
extern int ( /* missing proto */  argv_array_pushv)() ;
#line 376 "git_uaf_2.c"
static int parallel_next(struct child_process *cp , struct strbuf *err , void *cb ,
                         void **task_cb ) 
{ 
  struct child_process *d ;

  {
#line 381
  d = (struct child_process *)cb;
#line 382
  if (number_callbacks >= 4) {
#line 383
    return (0);
  }
#line 385
  argv_array_pushv(& cp->args, d->argv);
#line 386
  strbuf_addf(err, "preloaded output of a child\n");
#line 387
  number_callbacks ++;
#line 388
  return (1);
}
}
#line 391 "git_uaf_2.c"
static int no_job(struct child_process *cp , struct strbuf *err , void *cb , void **task_cb ) 
{ 


  {
#line 396
  strbuf_addf(err, "no further jobs available\n");
#line 397
  return (0);
}
}
#line 400 "git_uaf_2.c"
static int task_finished(int result , struct child_process *cp , struct strbuf *err ,
                         void *pp_cb , void *pp_task_cb ) 
{ 


  {
#line 406
  strbuf_addf(err, "asking for a quick stop\n");
#line 407
  return (1);
}
}
#line 419
extern int ( /* missing proto */  strcmp)() ;
#line 426
extern int ( /* missing proto */  run_command)() ;
#line 410 "git_uaf_2.c"
int main(int argc , char **argv ) 
{ 
  struct child_process proc ;
  int jobs ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 412
  proc.argv = (char const   **)((void *)0);
#line 412
  proc.args.argv = empty_argv;
#line 412
  proc.args.argc = 0;
#line 412
  proc.args.alloc = 0;
#line 412
  proc.env_array.argv = empty_argv;
#line 412
  proc.env_array.argc = 0;
#line 412
  proc.env_array.alloc = 0;
#line 412
  proc.pid = 0;
#line 412
  proc.in = 0;
#line 412
  proc.out = 0;
#line 412
  proc.err = 0;
#line 412
  proc.dir = (char const   *)0;
#line 412
  proc.env = (char const   * const  *)0;
#line 412
  proc.no_stdin = 0U;
#line 412
  proc.no_stdout = 0U;
#line 412
  proc.no_stderr = 0U;
#line 412
  proc.git_cmd = 0U;
#line 412
  proc.silent_exec_failure = 0U;
#line 412
  proc.stdout_to_stderr = 0U;
#line 412
  proc.use_shell = 0U;
#line 412
  proc.clean_on_exit = 0U;
#line 415
  if (argc < 3) {
#line 416
    return (1);
  }
#line 417
  proc.argv = (char const   **)argv + 2;
#line 419
  tmp___1 = strcmp(*(argv + 1), "start-command-ENOENT");
#line 419
  if (! tmp___1) {
#line 420
    tmp = start_command(& proc);
#line 420
    if (tmp < 0) {
#line 420
      tmp___0 = __errno_location();
#line 420
      if (*tmp___0 == 2) {
#line 421
        return (0);
      }
    }
#line 422
    fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"FAIL %s\n",
            *(argv + 1));
#line 423
    return (1);
  }
#line 425
  tmp___3 = strcmp(*(argv + 1), "run-command");
#line 425
  if (! tmp___3) {
#line 426
    tmp___2 = run_command(& proc);
#line 426
    exit(tmp___2);
  }
#line 428
  jobs = atoi((char const   *)*(argv + 2));
#line 429
  proc.argv = (char const   **)argv + 3;
#line 431
  tmp___5 = strcmp(*(argv + 1), "run-command-parallel");
#line 431
  if (! tmp___5) {
#line 432
    tmp___4 = run_processes_parallel(jobs, & parallel_next, (int (*)(struct child_process *cp ,
                                                                     struct strbuf *err ,
                                                                     void *pp_cb ,
                                                                     void *pp_task_cb ))((void *)0),
                                     (int (*)(int result , struct child_process *cp ,
                                              struct strbuf *err , void *pp_cb , void *pp_task_cb ))((void *)0),
                                     (void *)(& proc));
#line 432
    exit(tmp___4);
  }
#line 435
  tmp___7 = strcmp(*(argv + 1), "run-command-abort");
#line 435
  if (! tmp___7) {
#line 436
    tmp___6 = run_processes_parallel(jobs, & parallel_next, (int (*)(struct child_process *cp ,
                                                                     struct strbuf *err ,
                                                                     void *pp_cb ,
                                                                     void *pp_task_cb ))((void *)0),
                                     & task_finished, (void *)(& proc));
#line 436
    exit(tmp___6);
  }
#line 439
  tmp___9 = strcmp(*(argv + 1), "run-command-no-jobs");
#line 439
  if (! tmp___9) {
#line 440
    tmp___8 = run_processes_parallel(jobs, & no_job, (int (*)(struct child_process *cp ,
                                                              struct strbuf *err ,
                                                              void *pp_cb , void *pp_task_cb ))((void *)0),
                                     & task_finished, (void *)(& proc));
#line 440
    exit(tmp___8);
  }
#line 443
  fprintf((FILE * __restrict  )stderr, (char const   * __restrict  )"check usage\n");
#line 444
  return (1);
}
}
