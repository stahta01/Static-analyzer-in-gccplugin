/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

#line 216 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h"
typedef unsigned long size_t;
#line 218 "../git.h"
typedef unsigned long long uintmax_t;
#line 219 "../git.h"
typedef uintmax_t timestamp_t;
#line 255 "../git.h"
struct object_id {
   unsigned char hash[20] ;
};
#line 267 "../git.h"
struct object {
   unsigned int parsed : 1 ;
   unsigned int type : 3 ;
   unsigned int flags : 27 ;
   struct object_id oid ;
};
#line 274 "../git.h"
struct tree {
   struct object object ;
   void *buffer ;
   unsigned long size ;
};
#line 307
struct commit;
#line 307 "../git.h"
struct commit_list {
   struct commit *item ;
   struct commit_list *next ;
};
#line 312 "../git.h"
struct commit {
   struct object object ;
   void *util ;
   unsigned int index ;
   timestamp_t date ;
   struct commit_list *parents ;
   struct tree *tree ;
};
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 133 "../git.h"
static unsigned int const   all_flags  =    (unsigned int const   )((((1U << 16) | (1U << 17)) | (1U << 18)) | (1U << 19));
#line 22 "git_leak_6.c"
struct commit_list *commit_list_insert(struct commit *item , struct commit_list **list_p ) ;
#line 12 "git_leak_6.c"
struct commit_list *commit_list_insert_by_date(struct commit *item , struct commit_list **list ) 
{ 
  struct commit_list **pp ;
  struct commit_list *p ;
  int tmp ;

  {
#line 14
  pp = list;
#line 16
  while (1) {
#line 16
    p = *pp;
#line 16
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 16
      break;
    }
#line 17
    if ((p->item)->date < item->date) {
#line 18
      break;
    }
#line 20
    pp = & p->next;
  }
#line 22
  tmp = (int )commit_list_insert(item, pp);
#line 22
  return ((struct commit_list *)tmp);
}
}
#line 40
extern int ( /* missing proto */  parse_commit)() ;
#line 47
extern int ( /* missing proto */  paint_down_to_common)() ;
#line 50
extern int ( /* missing proto */  pop_commit)() ;
#line 25 "git_leak_6.c"
static struct commit_list *merge_bases_many(struct commit *one , int n , struct commit **twos ) 
{ 
  struct commit_list *list ;
  struct commit_list *result ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  struct commit *commit ;
  int tmp___3 ;

  {
#line 27
  list = (struct commit_list *)((void *)0);
#line 28
  result = (struct commit_list *)((void *)0);
#line 31
  i = 0;
#line 31
  while (i < n) {
#line 32
    if ((unsigned long )one == (unsigned long )*(twos + i)) {
#line 37
      tmp = (int )commit_list_insert(one, & result);
#line 37
      return ((struct commit_list *)tmp);
    }
#line 31
    i ++;
  }
#line 40
  tmp___0 = parse_commit(one);
#line 40
  if (tmp___0) {
#line 41
    return ((struct commit_list *)((void *)0));
  }
#line 42
  i = 0;
#line 42
  while (i < n) {
#line 43
    tmp___1 = parse_commit(*(twos + i));
#line 43
    if (tmp___1) {
#line 44
      return ((struct commit_list *)((void *)0));
    }
#line 42
    i ++;
  }
#line 47
  tmp___2 = paint_down_to_common(one, n, twos);
#line 47
  list = (struct commit_list *)tmp___2;
#line 49
  while (list) {
#line 50
    tmp___3 = pop_commit(& list);
#line 50
    commit = (struct commit *)tmp___3;
#line 51
    if (! (commit->object.flags & (1U << 18))) {
#line 52
      commit_list_insert_by_date(commit, & result);
    }
  }
#line 54
  return (result);
}
}
#line 57 "git_leak_6.c"
struct commit_list *commit_list_insert(struct commit *item , struct commit_list **list_p ) 
{ 
  struct commit_list *new_list ;
  void *tmp ;

  {
#line 59
  tmp = malloc(sizeof(struct commit_list ));
#line 59
  new_list = (struct commit_list *)tmp;
#line 60
  new_list->item = item;
#line 61
  new_list->next = *list_p;
#line 62
  *list_p = new_list;
#line 63
  return (new_list);
}
}
#line 83
extern int ( /* missing proto */  clear_commit_marks)() ;
#line 84
extern int ( /* missing proto */  clear_commit_marks_many)() ;
#line 90
extern int ( /* missing proto */  commit_list_count)() ;
#line 94
extern int ( /* missing proto */  free_commit_list)() ;
#line 99
extern int ( /* missing proto */  remove_redundant)() ;
#line 66 "git_leak_6.c"
static struct commit_list *get_merge_bases_many_0(struct commit *one , int n , struct commit **twos ,
                                                  int cleanup ) 
{ 
  struct commit_list *list ;
  struct commit **rslt ;
  struct commit_list *result ;
  int cnt ;
  int i ;
  void *tmp ;
  int tmp___0 ;

  {
#line 76
  result = merge_bases_many(one, n, twos);
#line 77
  i = 0;
#line 77
  while (i < n) {
#line 78
    if ((unsigned long )one == (unsigned long )*(twos + i)) {
#line 79
      return (result);
    }
#line 77
    i ++;
  }
#line 81
  if (! result) {
#line 81
    goto _L;
  } else
#line 81
  if (! result->next) {
    _L: /* CIL Label */ 
#line 82
    if (cleanup) {
#line 83
      clear_commit_marks(one, all_flags);
#line 84
      clear_commit_marks_many(n, twos, all_flags);
    }
#line 86
    return (result);
  }
#line 90
  cnt = commit_list_count(result);
#line 91
  tmp = calloc((size_t )cnt, sizeof(*rslt));
#line 91
  rslt = (struct commit **)tmp;
#line 92
  list = result;
#line 92
  i = 0;
#line 92
  while (list) {
#line 93
    tmp___0 = i;
#line 93
    i ++;
#line 93
    *(rslt + tmp___0) = list->item;
#line 92
    list = list->next;
  }
#line 94
  free_commit_list(result);
#line 96
  clear_commit_marks(one, all_flags);
#line 97
  clear_commit_marks_many(n, twos, all_flags);
#line 99
  cnt = remove_redundant(rslt, cnt);
#line 100
  result = (struct commit_list *)((void *)0);
#line 101
  i = 0;
#line 101
  while (i < cnt) {
#line 102
    commit_list_insert_by_date(*(rslt + i), & result);
#line 101
    i ++;
  }
#line 103
  free((void *)rslt);
#line 104
  return (result);
}
}
#line 107 "git_leak_6.c"
struct commit_list *get_merge_bases_many_dirty(struct commit *one , int n , struct commit **twos ) 
{ 
  struct commit_list *tmp ;

  {
#line 111
  tmp = get_merge_bases_many_0(one, n, twos, 0);
#line 111
  return (tmp);
}
}
#line 124
extern int ( /* missing proto */  oid_to_hex)() ;
#line 114 "git_leak_6.c"
static int show_merge_base(struct commit **rev , int rev_nr , int show_all ) 
{ 
  struct commit_list *result ;
  int tmp ;

  {
#line 118
  result = get_merge_bases_many_dirty(*(rev + 0), rev_nr - 1, rev + 1);
#line 120
  if (! result) {
#line 121
    return (1);
  }
#line 123
  while (result) {
#line 124
    tmp = oid_to_hex(& (result->item)->object.oid);
#line 124
    printf((char const   * __restrict  )"%s\n", tmp);
#line 125
    if (! show_all) {
#line 126
      return (0);
    }
#line 127
    result = result->next;
  }
#line 130
  return (0);
}
}
#line 140
extern int ( /* missing proto */  get_commit_reference)() ;
#line 142
extern int ( /* missing proto */  reduce_heads)() ;
#line 133 "git_leak_6.c"
static int handle_independent(int count , char const   **args ) 
{ 
  struct commit_list *revs ;
  struct commit_list *result ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 135
  revs = (struct commit_list *)((void *)0);
#line 139
  i = count - 1;
#line 139
  while (i >= 0) {
#line 140
    tmp = get_commit_reference(*(args + i));
#line 140
    commit_list_insert((struct commit *)tmp, & revs);
#line 139
    i --;
  }
#line 142
  tmp___0 = reduce_heads(revs);
#line 142
  result = (struct commit_list *)tmp___0;
#line 143
  if (! result) {
#line 144
    return (1);
  }
#line 146
  while (result) {
#line 147
    tmp___1 = oid_to_hex(& (result->item)->object.oid);
#line 147
    printf((char const   * __restrict  )"%s\n", tmp___1);
#line 148
    result = result->next;
  }
#line 151
  return (0);
}
}
#line 154 "git_leak_6.c"
int main(int argc , char **argv ) 
{ 
  struct commit *rev ;
  int show_all ;
  int rev_nr ;

  {
#line 158
  show_merge_base(& rev, rev_nr, show_all);
#line 159
  handle_independent(argc, (char const   **)argv);
#line 160
  return (0);
}
}
