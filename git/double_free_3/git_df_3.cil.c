/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

#line 216 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 144 "/usr/include/libio.h"
struct _IO_FILE;
#line 150 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 156 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 241 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 218 "../git.h"
typedef unsigned long long uintmax_t;
#line 241 "../git.h"
struct strbuf {
   size_t alloc ;
   size_t len ;
   char *buf ;
};
#line 43 "git_df_3.c"
struct last_object {
   struct strbuf data ;
   int offset ;
   unsigned int depth ;
   unsigned int no_swap : 1 ;
};
#line 59 "git_df_3.c"
struct atom_str {
   struct atom_str *next_atom ;
   unsigned short str_len ;
   char str_dat[] ;
};
#line 66
struct tree_content;
#line 66
struct tree_content;
#line 67 "git_df_3.c"
struct tree_entry_ms {
   int mode ;
   unsigned char sha1[20] ;
};
#line 67 "git_df_3.c"
struct tree_entry {
   struct tree_content *tree ;
   struct atom_str *name ;
   struct tree_entry_ms versions[2] ;
};
#line 78 "git_df_3.c"
struct tree_content {
   unsigned int entry_capacity ;
   unsigned int entry_count ;
   unsigned int delta_depth ;
   struct tree_entry *entries[] ;
};
#line 92 "git_df_3.c"
struct branch {
   struct branch *table_next_branch ;
   struct branch *active_next_branch ;
   char const   *name ;
   struct tree_entry branch_tree ;
   int last_commit ;
   unsigned int active : 1 ;
   unsigned int pack_id : 16 ;
   unsigned char sha1[20] ;
};
#line 112 "git_df_3.c"
struct hash_list {
   struct hash_list *next ;
   unsigned char sha1[20] ;
};
#line 124 "git_df_3.c"
struct recent_command {
   struct recent_command *prev ;
   struct recent_command *next ;
   char *buf ;
};
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 531
extern int fgetc(FILE *__stream ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 187 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1),
__leaf__)) strtoul)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                    int __base ) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 161 "../git.h"
extern int ( /* missing proto */  memcpy)() ;
#line 161
extern int ( /* missing proto */  st_mult)() ;
#line 174
extern int ( /* missing proto */  strdup)() ;
#line 386
extern char strbuf_slopbuf[] ;
#line 410 "../git.h"
void *xrealloc(void *ptr , size_t size ) 
{ 
  void *ret ;

  {
#line 414
  ret = realloc(ptr, size);
#line 415
  if (! ret) {
#line 415
    if (! size) {
#line 416
      ret = realloc(ptr, (size_t )1);
    }
  }
#line 417
  if (! ret) {
#line 418
    ret = realloc(ptr, size);
#line 419
    if (! ret) {
#line 419
      if (! size) {
#line 420
        ret = realloc(ptr, (size_t )1);
      }
    }
#line 421
    if (! ret) {
#line 422
      printf((char const   * __restrict  )"Out of memory, realloc failed%s", "");
#line 422
      exit(1);
    }
  }
#line 424
  return (ret);
}
}
#line 139 "git_df_3.c"
static uintmax_t object_count_by_type[1 << 3]  ;
#line 145 "git_df_3.c"
static int failure  ;
#line 159 "git_df_3.c"
static unsigned int pack_id  ;
#line 172 "git_df_3.c"
static struct last_object last_blob  =    {{(size_t )0, (size_t )0, strbuf_slopbuf}, 0, 0U, 0U};
#line 183 "git_df_3.c"
static unsigned long max_active_branches  =    5UL;
#line 195 "git_df_3.c"
static struct strbuf command_buf  =    {(size_t )0, (size_t )0, strbuf_slopbuf};
#line 196 "git_df_3.c"
static int unread_command_buf  ;
#line 197 "git_df_3.c"
static struct recent_command cmd_hist  =    {& cmd_hist, & cmd_hist, (char *)((void *)0)};
#line 198 "git_df_3.c"
static struct recent_command *cmd_tail  =    & cmd_hist;
#line 199 "git_df_3.c"
static struct recent_command *rc_free  ;
#line 200 "git_df_3.c"
static unsigned int cmd_save  =    100U;
#line 201 "git_df_3.c"
static uintmax_t next_mark  ;
#line 202 "git_df_3.c"
static struct strbuf new_data  =    {(size_t )0, (size_t )0, strbuf_slopbuf};
#line 210
extern int ( /* missing proto */  alloc_nr)() ;
#line 204 "git_df_3.c"
void strbuf_grow(struct strbuf *sb , size_t extra ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;

  {
#line 206
  if ((sb->len + extra) + 1UL <= sb->len) {
#line 207
    printf((char const   * __restrict  )"you want to use way too much memory%s", "");
#line 207
    exit(1);
  }
#line 208
  if (! sb->alloc) {
#line 209
    sb->buf = (char *)((void *)0);
  }
#line 210
  while (1) {
#line 210
    if ((sb->len + extra) + 1UL > sb->alloc) {
#line 210
      tmp___0 = alloc_nr(sb->alloc);
#line 210
      if ((size_t )tmp___0 < (sb->len + extra) + 1UL) {
#line 210
        sb->alloc = (sb->len + extra) + 1UL;
      } else {
#line 210
        tmp = alloc_nr(sb->alloc);
#line 210
        sb->alloc = (size_t )tmp;
      }
#line 210
      tmp___1 = st_mult(sizeof(*(sb->buf)), sb->alloc);
#line 210
      tmp___2 = xrealloc((void *)sb->buf, (size_t )tmp___1);
#line 210
      sb->buf = (char *)tmp___2;
    }
#line 210
    break;
  }
#line 211
  return;
}
}
#line 213 "git_df_3.c"
void strbuf_init(struct strbuf *sb , size_t hint ) 
{ 
  size_t tmp ;

  {
#line 215
  tmp = (size_t )0;
#line 215
  sb->len = tmp;
#line 215
  sb->alloc = tmp;
#line 216
  sb->buf = strbuf_slopbuf;
#line 217
  if (hint) {
#line 218
    strbuf_grow(sb, hint);
  }
#line 219
  return;
}
}
#line 221 "git_df_3.c"
char *strbuf_detach(struct strbuf *sb , size_t *sz ) 
{ 
  char *res ;
  char *tmp ;

  {
#line 223
  if (sb->alloc) {
#line 223
    tmp = sb->buf;
  } else {
#line 223
    tmp = (char *)((void *)0);
  }
#line 223
  res = tmp;
#line 224
  if (sz) {
#line 225
    *sz = sb->len;
  }
#line 226
  strbuf_init(sb, (size_t )0);
#line 227
  return (res);
}
}
#line 234
__inline static void strbuf_setlen(struct strbuf *sb , size_t len ) ;
#line 230 "git_df_3.c"
void strbuf_add(struct strbuf *sb , void const   *data , size_t len ) 
{ 


  {
#line 232
  strbuf_grow(sb, len);
#line 233
  memcpy(sb->buf + sb->len, data, len);
#line 234
  strbuf_setlen(sb, sb->len + len);
#line 235
  return;
}
}
#line 240
extern int ( /* missing proto */  assert)() ;
#line 237 "git_df_3.c"
__inline static void strbuf_setlen(struct strbuf *sb , size_t len ) 
{ 


  {
#line 238
  if (! sb->alloc) {
#line 239
    strbuf_grow(sb, (size_t )0);
  }
#line 240
  assert(len < sb->alloc);
#line 241
  sb->len = len;
#line 242
  *(sb->buf + len) = (char )'\000';
#line 243
  return;
}
}
#line 248 "git_df_3.c"
__inline static void strbuf_addbuf(struct strbuf *sb , struct strbuf *sb2 ) 
{ 


  {
#line 249
  strbuf_add(sb, (void const   *)sb2->buf, sb2->len);
#line 250
  return;
}
}
#line 252 "git_df_3.c"
int strbuf_getline(struct strbuf *sb , FILE *fp , int term ) 
{ 
  int ch ;
  int tmp ;
  size_t tmp___0 ;

  {
#line 256
  strbuf_grow(sb, (size_t )0);
#line 257
  tmp = feof(fp);
#line 257
  if (tmp) {
#line 258
    return (-1);
  }
#line 260
  strbuf_setlen(sb, (size_t )0);
#line 261
  while (1) {
#line 261
    ch = fgetc(fp);
#line 261
    if (! (ch != -1)) {
#line 261
      break;
    }
#line 262
    if (ch == term) {
#line 263
      break;
    }
#line 264
    strbuf_grow(sb, (size_t )1);
#line 265
    tmp___0 = sb->len;
#line 265
    (sb->len) ++;
#line 265
    *(sb->buf + tmp___0) = (char )ch;
  }
#line 267
  if (ch == -1) {
#line 267
    if (sb->len == 0UL) {
#line 268
      return (-1);
    }
  }
#line 270
  *(sb->buf + sb->len) = (char )'\000';
#line 271
  return (0);
}
}
#line 276
static int read_next_command(void) ;
#line 276 "git_df_3.c"
static int stdin_eof  =    0;
#line 274 "git_df_3.c"
static int read_next_command(void) 
{ 
  struct recent_command *rc ;

  {
#line 278
  if (stdin_eof) {
#line 279
    unread_command_buf = 0;
#line 280
    return (-1);
  }
#line 283
  while (1) {
#line 284
    if (unread_command_buf) {
#line 285
      unread_command_buf = 0;
    } else {
#line 289
      strbuf_detach(& command_buf, (size_t *)((void *)0));
#line 290
      stdin_eof = strbuf_getline(& command_buf, stdin, '\n');
#line 291
      if (stdin_eof) {
#line 292
        return (-1);
      }
#line 294
      rc = rc_free;
#line 295
      if (rc) {
#line 296
        rc_free = rc->next;
      } else {
#line 298
        rc = cmd_hist.next;
#line 299
        cmd_hist.next = rc->next;
#line 300
        (cmd_hist.next)->prev = & cmd_hist;
#line 301
        free((void *)rc->buf);
      }
#line 304
      rc->buf = command_buf.buf;
#line 305
      rc->prev = cmd_tail;
#line 306
      rc->next = cmd_hist.prev;
#line 307
      (rc->prev)->next = rc;
#line 308
      cmd_tail = rc;
    }
#line 283
    if (! ((int )*(command_buf.buf + 0) == 35)) {
#line 283
      break;
    }
  }
#line 312
  return (0);
}
}
#line 318
extern int ( /* missing proto */  strtoumax)() ;
#line 317
extern int ( /* missing proto */  prefixcmp)() ;
#line 315 "git_df_3.c"
static void cmd_mark(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 317
  tmp___0 = prefixcmp(command_buf.buf, "mark :");
#line 317
  if (tmp___0) {
#line 322
    next_mark = (uintmax_t )0;
  } else {
#line 318
    tmp = strtoumax(command_buf.buf + 6, (void *)0, 10);
#line 318
    next_mark = (uintmax_t )tmp;
#line 319
    read_next_command();
  }
#line 323
  return;
}
}
#line 327
static void cmd_new_blob(void) ;
#line 327 "git_df_3.c"
static struct strbuf buf  =    {(size_t )0, (size_t )0, strbuf_slopbuf};
#line 331
static void cmd_data(struct strbuf *sb ) ;
#line 332
extern int ( /* missing proto */  store_object)() ;
#line 325 "git_df_3.c"
static void cmd_new_blob(void) 
{ 


  {
#line 329
  read_next_command();
#line 330
  cmd_mark();
#line 331
  cmd_data(& buf);
#line 332
  store_object(3, & buf, & last_blob, (void *)0, next_mark);
#line 333
  return;
}
}
#line 349
extern int ( /* missing proto */  strcmp)() ;
#line 353
extern int ( /* missing proto */  strbuf_addch)() ;
#line 335 "git_df_3.c"
static void cmd_data(struct strbuf *sb ) 
{ 
  int tmp ;
  char *term ;
  int tmp___0 ;
  size_t term_len ;
  int tmp___1 ;
  int tmp___2 ;
  size_t n ;
  size_t length ;
  int tmp___3 ;

  {
#line 337
  strbuf_setlen(sb, (size_t )0);
#line 339
  tmp = prefixcmp(command_buf.buf, "data ");
#line 339
  if (tmp) {
#line 340
    printf((char const   * __restrict  )"Expected \'data n\' command, found: %s",
           command_buf.buf);
#line 340
    exit(1);
  }
#line 342
  tmp___3 = prefixcmp(command_buf.buf + 5, "<<");
#line 342
  if (tmp___3) {
#line 358
    n = (size_t )0;
#line 359
    length = strtoul((char const   * __restrict  )(command_buf.buf + 5), (char ** __restrict  )((void *)0),
                     10);
  } else {
#line 343
    tmp___0 = strdup((command_buf.buf + 5) + 2);
#line 343
    term = (char *)tmp___0;
#line 344
    term_len = (command_buf.len - 5UL) - 2UL;
#line 346
    while (1) {
#line 347
      tmp___1 = strbuf_getline(& command_buf, stdin, '\n');
#line 347
      if (tmp___1 == -1) {
#line 348
        printf((char const   * __restrict  )"EOF in data (terminator \'%s\' not found)",
               term);
#line 348
        exit(1);
      }
#line 349
      if (term_len == command_buf.len) {
#line 349
        tmp___2 = strcmp(term, command_buf.buf);
#line 349
        if (! tmp___2) {
#line 351
          break;
        }
      }
#line 352
      strbuf_addbuf(sb, & command_buf);
#line 353
      strbuf_addch(sb, '\n');
    }
#line 355
    free((void *)term);
  }
#line 361
  return;
}
}
#line 365
static void cmd_new_commit(void) ;
#line 365 "git_df_3.c"
static struct strbuf msg  =    {(size_t )0, (size_t )0, strbuf_slopbuf};
#line 374
extern int ( /* missing proto */  strchr)() ;
#line 375
extern int ( /* missing proto */  lookup_branch)() ;
#line 377
extern int ( /* missing proto */  new_branch)() ;
#line 382
extern int ( /* missing proto */  parse_ident)() ;
#line 393
extern int ( /* missing proto */  cmd_from)() ;
#line 394
extern int ( /* missing proto */  cmd_merge)() ;
#line 398
extern int ( /* missing proto */  unload_one_branch)() ;
#line 399
extern int ( /* missing proto */  load_branch)() ;
#line 405
extern int ( /* missing proto */  file_change_m)() ;
#line 407
extern int ( /* missing proto */  file_change_d)() ;
#line 409
extern int ( /* missing proto */  file_change_cr)() ;
#line 413
extern int ( /* missing proto */  file_change_deleteall)() ;
#line 423
extern int ( /* missing proto */  store_tree)() ;
#line 424
extern int ( /* missing proto */  hashcpy)() ;
#line 428
extern int ( /* missing proto */  strbuf_addf)() ;
#line 428
extern int ( /* missing proto */  sha1_to_hex)() ;
#line 430
extern int ( /* missing proto */  is_null_sha1)() ;
#line 363 "git_df_3.c"
static void cmd_new_commit(void) 
{ 
  struct branch *b ;
  char *sp ;
  char *author ;
  char *committer ;
  struct hash_list *merge_list ;
  unsigned int merge_count ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  struct hash_list *next ;
  int tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;

  {
#line 368
  author = (char *)((void *)0);
#line 369
  committer = (char *)((void *)0);
#line 370
  merge_list = (struct hash_list *)((void *)0);
#line 374
  tmp = strchr(command_buf.buf, ' ');
#line 374
  sp = (char *)(tmp + 1);
#line 375
  tmp___0 = lookup_branch(sp);
#line 375
  b = (struct branch *)tmp___0;
#line 376
  if (! b) {
#line 377
    tmp___1 = new_branch(sp);
#line 377
    b = (struct branch *)tmp___1;
  }
#line 379
  read_next_command();
#line 380
  cmd_mark();
#line 381
  tmp___3 = prefixcmp(command_buf.buf, "author ");
#line 381
  if (! tmp___3) {
#line 382
    tmp___2 = parse_ident(command_buf.buf + 7);
#line 382
    author = (char *)tmp___2;
#line 383
    read_next_command();
  }
#line 385
  tmp___5 = prefixcmp(command_buf.buf, "committer ");
#line 385
  if (! tmp___5) {
#line 386
    tmp___4 = parse_ident(command_buf.buf + 10);
#line 386
    committer = (char *)tmp___4;
#line 387
    read_next_command();
  }
#line 389
  if (! committer) {
#line 390
    printf((char const   * __restrict  )"Expected committer but didn\'t get one%s",
           "");
#line 390
    exit(1);
  }
#line 391
  cmd_data(& msg);
#line 392
  read_next_command();
#line 393
  cmd_from(b);
#line 394
  tmp___6 = cmd_merge(& merge_count);
#line 394
  merge_list = (struct hash_list *)tmp___6;
#line 397
  if (! b->branch_tree.tree) {
#line 398
    unload_one_branch();
#line 399
    load_branch(b);
  } else
#line 397
  if (! max_active_branches) {
#line 398
    unload_one_branch();
#line 399
    load_branch(b);
  }
#line 403
  while (command_buf.len > 0UL) {
#line 404
    tmp___11 = prefixcmp(command_buf.buf, "M ");
#line 404
    if (tmp___11) {
#line 406
      tmp___10 = prefixcmp(command_buf.buf, "D ");
#line 406
      if (tmp___10) {
#line 408
        tmp___9 = prefixcmp(command_buf.buf, "R ");
#line 408
        if (tmp___9) {
#line 410
          tmp___8 = prefixcmp(command_buf.buf, "C ");
#line 410
          if (tmp___8) {
#line 412
            tmp___7 = strcmp("deleteall", command_buf.buf);
#line 412
            if (tmp___7) {
#line 415
              unread_command_buf = 1;
#line 416
              break;
            } else {
#line 413
              file_change_deleteall(b);
            }
          } else {
#line 411
            file_change_cr(b, 0);
          }
        } else {
#line 409
          file_change_cr(b, 1);
        }
      } else {
#line 407
        file_change_d(b);
      }
    } else {
#line 405
      file_change_m(b);
    }
#line 418
    tmp___12 = read_next_command();
#line 418
    if (tmp___12 == -1) {
#line 419
      break;
    }
  }
#line 423
  store_tree(& b->branch_tree);
#line 424
  hashcpy(b->branch_tree.versions[0].sha1, b->branch_tree.versions[1].sha1);
#line 427
  strbuf_setlen(& new_data, (size_t )0);
#line 428
  tmp___13 = sha1_to_hex(b->branch_tree.versions[1].sha1);
#line 428
  strbuf_addf(& new_data, "tree %s\n", tmp___13);
#line 430
  tmp___15 = is_null_sha1(b->sha1);
#line 430
  if (! tmp___15) {
#line 431
    tmp___14 = sha1_to_hex(b->sha1);
#line 431
    strbuf_addf(& new_data, "parent %s\n", tmp___14);
  }
#line 432
  while (merge_list) {
#line 433
    next = merge_list->next;
#line 434
    tmp___16 = sha1_to_hex(merge_list->sha1);
#line 434
    strbuf_addf(& new_data, "parent %s\n", tmp___16);
#line 435
    free((void *)merge_list);
#line 436
    merge_list = next;
  }
#line 438
  if (author) {
#line 438
    tmp___17 = author;
  } else {
#line 438
    tmp___17 = committer;
  }
#line 438
  strbuf_addf(& new_data, "author %s\ncommitter %s\n\n", tmp___17, committer);
#line 443
  strbuf_addbuf(& new_data, & msg);
#line 444
  free((void *)author);
#line 445
  free((void *)committer);
#line 447
  tmp___18 = store_object(1, & new_data, (void *)0, b->sha1, next_mark);
#line 447
  if (! tmp___18) {
#line 448
    b->pack_id = pack_id;
  }
#line 449
  b->last_commit = (int )object_count_by_type[1];
#line 450
  return;
}
}
#line 459
extern int ( /* missing proto */  pool_alloc)() ;
#line 470
extern int ( /* missing proto */  cmd_new_tag)() ;
#line 453 "git_df_3.c"
int main(int argc , char const   **argv ) 
{ 
  unsigned int i ;
  unsigned int show_stats ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 455
  show_stats = 1U;
#line 457
  strbuf_init(& command_buf, (size_t )0);
#line 459
  tmp = pool_alloc((unsigned long )cmd_save * sizeof(*rc_free));
#line 459
  rc_free = (struct recent_command *)tmp;
#line 460
  i = 0U;
#line 460
  while (i < cmd_save - 1U) {
#line 461
    (rc_free + i)->next = rc_free + (i + 1U);
#line 460
    i ++;
  }
#line 462
  (rc_free + (cmd_save - 1U))->next = (struct recent_command *)((void *)0);
#line 464
  while (1) {
#line 464
    tmp___3 = read_next_command();
#line 464
    if (! (tmp___3 != -1)) {
#line 464
      break;
    }
#line 465
    tmp___2 = strcmp("blob", command_buf.buf);
#line 465
    if (tmp___2) {
#line 467
      tmp___1 = prefixcmp(command_buf.buf, "commit ");
#line 467
      if (tmp___1) {
#line 469
        tmp___0 = prefixcmp(command_buf.buf, "tag ");
#line 469
        if (tmp___0) {
#line 472
          printf((char const   * __restrict  )"Unsupported command: %s", command_buf.buf);
#line 472
          exit(1);
        } else {
#line 470
          cmd_new_tag();
        }
      } else {
#line 468
        cmd_new_commit();
      }
    } else {
#line 466
      cmd_new_blob();
    }
  }
#line 474
  if (failure) {
#line 474
    tmp___4 = 1;
  } else {
#line 474
    tmp___4 = 0;
  }
#line 474
  return (tmp___4);
}
}
