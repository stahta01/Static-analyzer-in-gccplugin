/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

#line 216 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h"
typedef unsigned long size_t;
#line 203 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned long u_int64_t;
#line 196 "../stdio.h"
typedef unsigned int u_int___0;
#line 200 "../stdio.h"
typedef int int32_t___0;
#line 207 "../stdio.h"
typedef unsigned char u_char___0;
#line 364 "../openssh.h"
typedef u_int___0 BN_ULONG;
#line 365 "../openssh.h"
struct __anonstruct_Buffer_25 {
   u_char___0 *buf ;
   u_int___0 alloc ;
   u_int___0 offset ;
   u_int___0 end ;
};
#line 365 "../openssh.h"
typedef struct __anonstruct_Buffer_25 Buffer;
#line 372 "../openssh.h"
struct bignum_st {
   BN_ULONG *d ;
   int top ;
   int dmax ;
   int neg ;
   int flags ;
};
#line 390 "../openssh.h"
typedef struct bignum_st BIGNUM;
#line 391 "../openssh.h"
struct rsa_st {
   int pad ;
   int32_t___0 version ;
   void const   *meth ;
   void *engine ;
   BIGNUM *n ;
   BIGNUM *e ;
   BIGNUM *d ;
   BIGNUM *p ;
   BIGNUM *q ;
   BIGNUM *dmp1 ;
   BIGNUM *dmq1 ;
   BIGNUM *iqmp ;
   void *pss ;
   int ex_data ;
   int references ;
   int flags ;
   void *_method_mod_n ;
   void *_method_mod_p ;
   void *_method_mod_q ;
   char *bignum_data ;
   void *blinding ;
   void *mt_blinding ;
   void *lock ;
};
#line 391 "../openssh.h"
typedef struct rsa_st RSA;
#line 434 "../openssh.h"
struct dsa_st {
   int pad ;
   int32_t___0 version ;
   BIGNUM *p ;
   BIGNUM *q ;
   BIGNUM *g ;
   BIGNUM *pub_key ;
   BIGNUM *priv_key ;
   int flags ;
};
#line 434 "../openssh.h"
typedef struct dsa_st DSA;
#line 1191
struct Key;
#line 1191 "../openssh.h"
typedef struct Key Key;
#line 1203 "../openssh.h"
struct KeyCert {
   Buffer certblob ;
   u_int___0 type ;
   u_int64_t serial ;
   char *key_id ;
   u_int___0 nprincipals ;
   char **principals ;
   u_int64_t valid_after ;
   u_int64_t valid_before ;
   Buffer critical ;
   Buffer extensions ;
   Key *signature_key ;
};
#line 1216 "../openssh.h"
struct Key {
   int type ;
   int flags ;
   RSA *rsa ;
   DSA *dsa ;
   int ecdsa_nid ;
   void *ecdsa ;
   struct KeyCert *cert ;
   u_char___0 *ed25519_sk ;
   u_char___0 *ed25519_pk ;
};
#line 1284 "../openssh.h"
struct __anonstruct_AuthenticationConnection_36 {
   int fd ;
   Buffer identities ;
   int howmany ;
};
#line 1284 "../openssh.h"
typedef struct __anonstruct_AuthenticationConnection_36 AuthenticationConnection;
#line 12 "openssh_leak_8.c"
struct identity;
#line 12 "openssh_leak_8.c"
typedef struct identity Identity;
#line 13 "openssh_leak_8.c"
struct __anonstruct_next_37 {
   struct identity *tqe_next ;
   struct identity **tqe_prev ;
};
#line 13 "openssh_leak_8.c"
struct identity {
   struct __anonstruct_next_37 next ;
   AuthenticationConnection *ac ;
   Key *key ;
   char *filename ;
   int tried ;
   int isprivate ;
   int userprovided ;
};
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 374 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rand)(void) ;
#line 376
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) srand)(unsigned int __seed ) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 26 "openssh_leak_8.c"
Key *key_new(int type ) 
{ 
  Key *k ;
  void *tmp ;

  {
#line 32
  tmp = calloc((size_t )1, sizeof(*k));
#line 32
  k = (Key *)tmp;
#line 33
  k->type = type;
#line 34
  k->ecdsa = (void *)0;
#line 35
  k->ecdsa_nid = -1;
#line 36
  k->dsa = (DSA *)((void *)0);
#line 37
  k->rsa = (RSA *)((void *)0);
#line 38
  k->cert = (struct KeyCert *)((void *)0);
#line 39
  switch (k->type) {
  case 11: 
#line 41
  break;
  default: 
#line 43
  printf((char const   * __restrict  )"key_new: bad key type %d", k->type);
#line 43
  exit(1);
#line 44
  break;
  }
#line 47
  return (k);
}
}
#line 51 "openssh_leak_8.c"
void key_free(Key *k ) 
{ 


  {
#line 54
  if ((unsigned long )k == (unsigned long )((void *)0)) {
#line 55
    printf((char const   * __restrict  )"key_free: key is NULL%s", "");
#line 55
    exit(1);
  }
#line 56
  switch (k->type) {
  case 5: 
  case 9: 
  case 1: 
  case 0: 
#line 61
  if ((unsigned long )k->rsa != (unsigned long )((void *)0)) {
#line 62
    free((void *)k->rsa);
  }
#line 63
  k->rsa = (RSA *)((void *)0);
#line 64
  break;
  case 6: 
  case 10: 
  case 2: 
#line 68
  if ((unsigned long )k->dsa != (unsigned long )((void *)0)) {
#line 69
    free((void *)k->dsa);
  }
#line 70
  k->dsa = (DSA *)((void *)0);
#line 71
  break;
  case 11: 
#line 73
  break;
  default: 
#line 75
  printf((char const   * __restrict  )"key_free: bad key type %d", k->type);
#line 75
  exit(1);
#line 76
  break;
  }
#line 78
  free((void *)k);
#line 79
  return;
}
}
#line 81 "openssh_leak_8.c"
static Key *key_parse_private_pem(Buffer *blob , int type , char const   *passphrase ,
                                  char **commentp ) 
{ 
  Key *prv ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 85
  prv = (Key *)((void *)0);
#line 87
  tmp___10 = rand();
#line 87
  if (tmp___10 % 2 == 1) {
#line 87
    tmp___9 = 1;
  } else {
#line 87
    tmp___9 = 0;
  }
#line 87
  if (tmp___9) {
#line 88
    printf((char const   * __restrict  )"%s: PEM_read_PrivateKey failed\n", "key_parse_private_pem");
  } else {
#line 89
    tmp___7 = rand();
#line 89
    if (tmp___7 % 2 == 1) {
#line 89
      tmp___6 = 1;
    } else {
#line 89
      tmp___6 = 0;
    }
#line 89
    if (tmp___6) {
#line 89
      if (type == 11) {
#line 89
        goto _L___0;
      } else
#line 89
      if (type == 1) {
        _L___0: /* CIL Label */ 
#line 90
        prv = key_new(11);
#line 91
        tmp = malloc(sizeof(RSA ));
#line 91
        prv->rsa = (RSA *)tmp;
#line 92
        prv->type = 1;
#line 93
        tmp___0 = rand();
#line 93
        if (tmp___0 % 5 == 0) {
#line 94
          printf((char const   * __restrict  )"%s: RSA_blinding_on failed\n", "key_parse_private_pem");
#line 95
          key_free(prv);
#line 96
          prv = (Key *)((void *)0);
        }
      } else {
#line 89
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 98
      tmp___4 = rand();
#line 98
      if (tmp___4 % 2 == 1) {
#line 98
        tmp___3 = 1;
      } else {
#line 98
        tmp___3 = 0;
      }
#line 98
      if (tmp___3) {
#line 98
        if (type == 11) {
#line 99
          prv = key_new(11);
#line 100
          tmp___1 = malloc(sizeof(BIGNUM ));
#line 100
          prv->dsa = (DSA *)tmp___1;
#line 101
          prv->type = 2;
        } else
#line 98
        if (type == 2) {
#line 99
          prv = key_new(11);
#line 100
          tmp___1 = malloc(sizeof(BIGNUM ));
#line 100
          prv->dsa = (DSA *)tmp___1;
#line 101
          prv->type = 2;
        } else {
#line 103
          printf((char const   * __restrict  )"%s: PEM_read_PrivateKey: mismatch or unknown EVP_PKEY save_type\n");
        }
      } else {
#line 103
        printf((char const   * __restrict  )"%s: PEM_read_PrivateKey: mismatch or unknown EVP_PKEY save_type\n");
      }
    }
  }
#line 106
  return (prv);
}
}
#line 115
extern int ( /* missing proto */  key_parse_private_rsa1)() ;
#line 109 "openssh_leak_8.c"
static Key *key_parse_private_type(Buffer *blob , int type , char const   *passphrase ,
                                   char **commentp ) 
{ 
  int tmp ;
  Key *tmp___0 ;

  {
#line 113
  switch (type) {
  case 0: 
#line 115
  tmp = key_parse_private_rsa1(blob, passphrase, commentp);
#line 115
  return ((Key *)tmp);
  case 11: 
  case 1: 
  case 3: 
  case 2: 
#line 120
  tmp___0 = key_parse_private_pem(blob, type, passphrase, commentp);
#line 120
  return (tmp___0);
  default: 
#line 122
  printf((char const   * __restrict  )"%s: cannot parse key type %d\n", "key_parse_private_type",
         type);
#line 123
  break;
  }
#line 125
  return ((Key *)((void *)0));
}
}
#line 127 "openssh_leak_8.c"
Key *key_load_private_type(int type , char const   *filename , char const   *passphrase ,
                           char **commentp , int *perm_ok ) 
{ 
  Key *ret ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 134
  tmp___1 = rand();
#line 134
  if (tmp___1 % 2 == 1) {
#line 134
    tmp___0 = 1;
  } else {
#line 134
    tmp___0 = 0;
  }
#line 134
  if (tmp___0) {
#line 135
    *perm_ok = 1;
  }
#line 137
  ret = key_parse_private_type((Buffer *)((void *)0), type, passphrase, commentp);
#line 138
  return (ret);
}
}
#line 162
extern int ( /* missing proto */  debug2)() ;
#line 157
extern int ( /* missing proto */  strcmp)() ;
#line 141 "openssh_leak_8.c"
static Key *load_identity_file(char *filename , int userprovided ) 
{ 
  Key *private ;
  char *passphrase ;
  int perm_ok ;
  int i ;
  int quit ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 146
  perm_ok = 0;
#line 149
  private = key_load_private_type(11, (char const   *)filename, "", (char **)((void *)0),
                                  & perm_ok);
#line 150
  if (! perm_ok) {
#line 151
    return ((Key *)((void *)0));
  }
#line 153
  if ((unsigned long )private == (unsigned long )((void *)0)) {
#line 154
    tmp___1 = rand();
#line 154
    if (tmp___1 % 2 == 1) {
#line 154
      tmp___0 = 1;
    } else {
#line 154
      tmp___0 = 0;
    }
#line 154
    if (tmp___0) {
#line 155
      return ((Key *)((void *)0));
    }
#line 156
    i = 0;
#line 156
    while (i < 100) {
#line 157
      tmp___2 = strcmp(passphrase, "");
#line 157
      if (tmp___2 != 0) {
#line 158
        private = key_load_private_type(11, (char const   *)filename, (char const   *)passphrase,
                                        (char **)((void *)0), (int *)((void *)0));
#line 160
        quit = 0;
      } else {
#line 162
        debug2("no passphrase given, try next key");
#line 163
        quit = 1;
      }
#line 165
      if ((unsigned long )private != (unsigned long )((void *)0)) {
#line 166
        break;
      } else
#line 165
      if (quit) {
#line 166
        break;
      }
#line 156
      i ++;
    }
  }
#line 170
  return (private);
}
}
#line 176
extern int ( /* missing proto */  time)() ;
#line 173 "openssh_leak_8.c"
int main(int argc , char **argv ) 
{ 
  Identity *id ;
  void *tmp ;
  int tmp___0 ;

  {
#line 175
  tmp = malloc(sizeof(Identity ));
#line 175
  id = (Identity *)tmp;
#line 176
  tmp___0 = time((void *)0);
#line 176
  srand((unsigned int )tmp___0);
#line 177
  id->filename = *(argv + 0);
#line 178
  id->key = load_identity_file(id->filename, id->userprovided);
#line 179
  printf((char const   * __restrict  )"%d\n", (id->key)->rsa);
#line 180
  if ((unsigned long )id->key != (unsigned long )((void *)0)) {
#line 181
    key_free(id->key);
  }
#line 182
  free((void *)id);
#line 183
  return (0);
}
}
