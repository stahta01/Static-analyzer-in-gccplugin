/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

#line 216 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h"
typedef unsigned long size_t;
#line 196 "../stdio.h"
typedef unsigned int u_int___0;
#line 364 "../openssh.h"
typedef u_int___0 BN_ULONG;
#line 372 "../openssh.h"
struct bignum_st {
   BN_ULONG *d ;
   int top ;
   int dmax ;
   int neg ;
   int flags ;
};
#line 390 "../openssh.h"
typedef struct bignum_st BIGNUM;
#line 1342 "../openssh.h"
struct __anonstruct_ECDSA_SIG_35 {
   BIGNUM *r ;
   BIGNUM *s ;
};
#line 1342 "../openssh.h"
typedef struct __anonstruct_ECDSA_SIG_35 ECDSA_SIG;
#line 14 "openssh_leak_7.c"
struct ASN1_ITEM_st;
#line 14 "openssh_leak_7.c"
typedef struct ASN1_ITEM_st ASN1_ITEM;
#line 15
struct ASN1_TEMPLATE_st;
#line 15 "openssh_leak_7.c"
typedef struct ASN1_TEMPLATE_st ASN1_TEMPLATE;
#line 16 "openssh_leak_7.c"
typedef void ASN1_VALUE;
#line 50 "openssh_leak_7.c"
struct ASN1_TEMPLATE_st {
   unsigned long flags ;
   long tag ;
   unsigned long offset ;
   char const   *field_name ;
   ASN1_ITEM *item ;
};
#line 60 "openssh_leak_7.c"
struct ASN1_ITEM_st {
   char itype ;
   long utype ;
   ASN1_TEMPLATE const   *templates ;
   long tcount ;
   void const   *funcs ;
   long size ;
   char const   *sname ;
};
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 70 "openssh_leak_7.c"
struct ASN1_ITEM_st  const  BIGNUM_it  =    {(char)0, 0L, (ASN1_TEMPLATE const   *)((void *)0), 0L, (void const   *)((void *)0),
    1L, "BIGNUM"};
#line 74 "openssh_leak_7.c"
static ASN1_TEMPLATE const   ECDSA_SIG_seq_tt[2]  = {      {0UL, 0L, (size_t )(& ((ECDSA_SIG *)0)->r), "r", (ASN1_ITEM *)(& BIGNUM_it)}, 
        {0UL,
      0L, (size_t )(& ((ECDSA_SIG *)0)->s), "s", (ASN1_ITEM *)(& BIGNUM_it)}};
#line 77 "openssh_leak_7.c"
struct ASN1_ITEM_st  const  ECDSA_SIG_it  =    {(char)1, 0L, ECDSA_SIG_seq_tt, (long )(sizeof(ECDSA_SIG_seq_tt) / sizeof(ASN1_TEMPLATE )),
    (void const   *)((void *)0), (long )sizeof(ECDSA_SIG ), "ECDSA_SIG"};
#line 90
extern int ( /* missing proto */  memset)() ;
#line 79 "openssh_leak_7.c"
int ASN1_item_new(ASN1_VALUE **pval , ASN1_ITEM *it ) 
{ 
  int i ;
  ASN1_VALUE *pseqval ;
  ASN1_TEMPLATE *tt ;
  int tmp ;

  {
#line 83
  tt = (ASN1_TEMPLATE *)it->templates;
#line 84
  switch ((int )it->itype) {
  case 0: 
#line 87
  *pval = malloc((size_t )it->size);
#line 88
  if (! *pval) {
#line 89
    goto memerr;
  }
#line 90
  memset(*pval, 0, it->size);
#line 91
  break;
  case 1: 
#line 93
  *pval = malloc((size_t )it->size);
#line 94
  if (! *pval) {
#line 95
    goto memerr;
  }
#line 96
  memset(*pval, 0, it->size);
#line 97
  i = 0;
#line 97
  tt = (ASN1_TEMPLATE *)it->templates;
#line 97
  while ((long )i < it->tcount) {
#line 99
    pseqval = *pval + tt->offset;
#line 100
    tmp = ASN1_item_new((ASN1_VALUE **)pseqval, tt->item);
#line 100
    if (! tmp) {
#line 101
      goto memerr;
    }
#line 97
    tt ++;
#line 97
    i ++;
  }
#line 103
  break;
  }
#line 105
  return (1);
  memerr: 
#line 108
  printf((char const   * __restrict  )"ASN1_ITEM_new ERROR\n");
#line 109
  return (0);
}
}
#line 112 "openssh_leak_7.c"
ECDSA_SIG *ECDSA_SIG_new(void) 
{ 
  ECDSA_SIG *ret ;

  {
#line 115
  ASN1_item_new((ASN1_VALUE **)(& ret), (ASN1_ITEM *)(& ECDSA_SIG_it));
#line 116
  return (ret);
}
}
#line 119 "openssh_leak_7.c"
void ECDSA_SIG_free(ECDSA_SIG *p ) 
{ 


  {
#line 121
  free((void *)p->r);
#line 122
  free((void *)p->s);
#line 123
  free((void *)p);
#line 124
  return;
}
}
#line 126 "openssh_leak_7.c"
BIGNUM *BN_new(void) 
{ 
  void *tmp ;

  {
#line 128
  tmp = malloc(sizeof(BIGNUM ));
#line 128
  return ((BIGNUM *)tmp);
}
}
#line 131 "openssh_leak_7.c"
int main(void) 
{ 
  ECDSA_SIG *sig ;
  BIGNUM *tmp ;
  BIGNUM *tmp___0 ;

  {
#line 135
  sig = ECDSA_SIG_new();
#line 135
  if ((unsigned long )sig == (unsigned long )((void *)0)) {
#line 136
    printf((char const   * __restrict  )"%s: ECDSA_SIG_new failed", "main");
#line 136
    exit(1);
  }
#line 138
  tmp = BN_new();
#line 138
  sig->r = tmp;
#line 138
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 140
    printf((char const   * __restrict  )"%s: BN_new failed", "main");
#line 140
    exit(1);
  } else {
#line 138
    tmp___0 = BN_new();
#line 138
    sig->s = tmp___0;
#line 138
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 140
      printf((char const   * __restrict  )"%s: BN_new failed", "main");
#line 140
      exit(1);
    }
  }
#line 142
  ECDSA_SIG_free(sig);
#line 143
  return (0);
}
}
