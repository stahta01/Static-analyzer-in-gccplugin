/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is true */

#line 216 "/usr/lib/gcc/x86_64-linux-gnu/5/include/stddef.h"
typedef unsigned long size_t;
#line 203 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned long u_int64_t;
#line 196 "../stdio.h"
typedef unsigned int u_int___0;
#line 203 "../stdio.h"
typedef unsigned int u_int32_t___0;
#line 207 "../stdio.h"
typedef unsigned char u_char___0;
#line 214 "../stdio.h"
typedef int sig_atomic_t;
#line 365 "../openssh.h"
struct __anonstruct_Buffer_25 {
   u_char___0 *buf ;
   u_int___0 alloc ;
   u_int___0 offset ;
   u_int___0 end ;
};
#line 365 "../openssh.h"
typedef struct __anonstruct_Buffer_25 Buffer;
#line 83 "openssh_leak_9.c"
struct Attrib;
#line 83 "openssh_leak_9.c"
typedef struct Attrib Attrib;
#line 86 "openssh_leak_9.c"
struct Attrib {
   u_int32_t___0 flags ;
   u_int64_t size ;
   u_int32_t___0 uid ;
   u_int32_t___0 gid ;
   u_int32_t___0 perm ;
   u_int32_t___0 atime ;
   u_int32_t___0 mtime ;
};
#line 96
struct SFTP_DIRENT;
#line 96 "openssh_leak_9.c"
typedef struct SFTP_DIRENT SFTP_DIRENT;
#line 98 "openssh_leak_9.c"
struct SFTP_DIRENT {
   char *filename ;
   char *longname ;
   Attrib a ;
};
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 374 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rand)(void) ;
#line 376
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) srand)(unsigned int __seed ) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 133 "openssh_leak_9.c"
int volatile   interrupted  =    (sig_atomic_t volatile   )0;
#line 135 "openssh_leak_9.c"
void *xrealloc(void *ptr , size_t nmemb , size_t size ) 
{ 
  void *new_ptr ;
  size_t new_size ;

  {
#line 139
  new_size = nmemb * size;
#line 141
  if (new_size == 0UL) {
#line 142
    printf((char const   * __restrict  )"xrealloc: zero size%s\n", "");
#line 142
    exit(1);
  }
#line 143
  if (10000UL / nmemb < size) {
#line 144
    printf((char const   * __restrict  )"xrealloc: nmemb * size > SIZE_T_MAX%s\n",
           "");
#line 144
    exit(1);
  }
#line 145
  if ((unsigned long )ptr == (unsigned long )((void *)0)) {
#line 146
    new_ptr = malloc(new_size);
  } else {
#line 148
    new_ptr = realloc(ptr, new_size);
  }
#line 149
  if ((unsigned long )new_ptr == (unsigned long )((void *)0)) {
#line 150
    printf((char const   * __restrict  )"xrealloc: out of memory (new_size %lu bytes\n)",
           new_size);
#line 150
    exit(1);
  }
#line 152
  return (new_ptr);
}
}
#line 155 "openssh_leak_9.c"
void free_sftp_dirents(SFTP_DIRENT **s ) 
{ 
  int i ;

  {
#line 159
  i = 0;
#line 159
  while (*(s + i)) {
#line 160
    free((void *)(*(s + i))->filename);
#line 161
    free((void *)(*(s + i))->longname);
#line 162
    free((void *)*(s + i));
#line 159
    i ++;
  }
#line 164
  free((void *)s);
#line 165
  return;
}
}
#line 202
extern int ( /* missing proto */  strchr)() ;
#line 211
extern int ( /* missing proto */  strdup)() ;
#line 167 "openssh_leak_9.c"
static int do_lsreaddir(char *path , int print_flag , SFTP_DIRENT ***dir ) 
{ 
  u_int___0 count ;
  u_int___0 i ;
  u_int___0 ents ;
  void *tmp ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *filename ;
  char *longname ;
  int tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___10 ;
  void *tmp___11 ;

  {
#line 172
  ents = (u_int___0 )0;
#line 175
  if (dir) {
#line 176
    ents = (u_int___0 )0;
#line 177
    tmp = calloc((size_t )1, sizeof(*(*dir)));
#line 177
    *dir = (SFTP_DIRENT **)tmp;
#line 178
    *(*dir + 0) = (SFTP_DIRENT *)((void *)0);
  }
#line 181
  while (! interrupted) {
#line 182
    tmp___2 = rand();
#line 182
    if (tmp___2 % 2 == 1) {
#line 182
      tmp___1 = 1;
    } else {
#line 182
      tmp___1 = 0;
    }
#line 182
    if (tmp___1) {
#line 183
      return (-1);
    }
#line 185
    tmp___3 = rand();
#line 185
    count = (u_int___0 )(tmp___3 % 5);
#line 186
    if (count == 0U) {
#line 187
      break;
    }
#line 188
    i = (u_int___0 )0;
#line 188
    while (i < count) {
#line 191
      filename = path;
#line 192
      longname = (char *)"longname";
#line 194
      if (print_flag) {
#line 195
        printf((char const   * __restrict  )"%s\n", longname);
      }
#line 202
      tmp___4 = strchr(filename, '/');
#line 202
      if ((unsigned long )tmp___4 != (unsigned long )((void *)0)) {
#line 203
        printf((char const   * __restrict  )"Server sent suspect path \"%s\" during readdir of \"%s\"",
               filename, path);
#line 205
        goto next;
      }
#line 208
      if (dir) {
#line 209
        tmp___5 = xrealloc((void *)*dir, (size_t )(ents + 2U), sizeof(*(*dir)));
#line 209
        *dir = (SFTP_DIRENT **)tmp___5;
#line 210
        tmp___6 = calloc((size_t )1, sizeof(*(*(*dir))));
#line 210
        *(*dir + ents) = (SFTP_DIRENT *)tmp___6;
#line 211
        tmp___7 = strdup(filename);
#line 211
        (*(*dir + ents))->filename = (char *)tmp___7;
#line 212
        tmp___8 = strdup(longname);
#line 212
        (*(*dir + ents))->longname = (char *)tmp___8;
#line 213
        ents ++;
#line 213
        *(*dir + ents) = (SFTP_DIRENT *)((void *)0);
      }
      next: 
#line 216
      tmp___10 = rand();
#line 216
      if (tmp___10 % 2 == 1) {
#line 216
        interrupted = (int volatile   )1;
      } else {
#line 216
        interrupted = (int volatile   )0;
      }
#line 188
      i ++;
    }
  }
#line 221
  if (interrupted) {
#line 221
    if ((unsigned long )dir != (unsigned long )((void *)0)) {
#line 221
      if ((unsigned long )*dir != (unsigned long )((void *)0)) {
#line 222
        free_sftp_dirents(*dir);
#line 223
        tmp___11 = calloc((size_t )1, sizeof(*(*dir)));
#line 223
        *dir = (SFTP_DIRENT **)tmp___11;
#line 224
        *(*dir) = (SFTP_DIRENT *)((void *)0);
      }
    }
  }
#line 227
  return (0);
}
}
#line 230 "openssh_leak_9.c"
int do_readdir(char *path , SFTP_DIRENT ***dir ) 
{ 
  int tmp ;

  {
#line 233
  tmp = do_lsreaddir(path, 0, dir);
#line 233
  return (tmp);
}
}
#line 243
extern int ( /* missing proto */  time)() ;
#line 259
extern int ( /* missing proto */  strcmp)() ;
#line 236 "openssh_leak_9.c"
int main(int argc , char **argv ) 
{ 
  char *src ;
  int i ;
  int ret ;
  SFTP_DIRENT **dir_entries ;
  char *filename ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 240
  ret = 0;
#line 243
  tmp = time((void *)0);
#line 243
  srand((unsigned int )tmp);
#line 245
  if (argc == 1) {
#line 246
    src = *(argv + 0);
  } else {
#line 248
    src = *(argv + 1);
  }
#line 250
  tmp___0 = do_readdir(src, & dir_entries);
#line 250
  if (tmp___0 == -1) {
#line 251
    printf((char const   * __restrict  )"%s: Failed to get directory contents", src);
#line 253
    return (-1);
  }
#line 256
  i = 0;
#line 256
  while ((unsigned long )*(dir_entries + i) != (unsigned long )((void *)0)) {
#line 257
    filename = (*(dir_entries + i))->filename;
#line 259
    tmp___1 = strcmp(filename, ".");
#line 259
    if (! (tmp___1 == 0)) {
#line 259
      tmp___2 = strcmp(filename, "..");
#line 259
      if (tmp___2 == 0) {
#line 261
        goto __Cont;
      }
    }
    __Cont: /* CIL Label */ 
#line 256
    i ++;
  }
#line 265
  free_sftp_dirents(dir_entries);
#line 267
  return (0);
}
}
